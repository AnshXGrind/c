"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdf-parse";
exports.ids = ["vendor-chunks/pdf-parse"];
exports.modules = {

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/Exception.js":
/*!****************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/Exception.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortException: () => (/* binding */ AbortException),\n/* harmony export */   FormatError: () => (/* binding */ FormatError),\n/* harmony export */   InvalidPDFException: () => (/* binding */ InvalidPDFException),\n/* harmony export */   PasswordException: () => (/* binding */ PasswordException),\n/* harmony export */   ResponseException: () => (/* binding */ ResponseException),\n/* harmony export */   UnknownErrorException: () => (/* binding */ UnknownErrorException),\n/* harmony export */   getException: () => (/* binding */ getException)\n/* harmony export */ });\n/* biome-ignore-all lint/suspicious/noExplicitAny: underline-type */ /**\n * Error thrown when the parsed data is not a valid PDF document.\n *\n * Use this exception to signal that the input cannot be interpreted as a PDF\n * (corrupt file, invalid header, etc.).\n *\n * @public\n */ class InvalidPDFException extends Error {\n    /**\n     * Create a new InvalidPDFException.\n     * @param message - Optional error message.\n     * @param cause - Optional underlying cause (preserved on modern runtimes).\n     */ constructor(message, cause){\n        if (cause !== undefined) {\n            // Use modern ErrorOptions to attach cause when supported\n            super(message ?? \"Invalid PDF\", {\n                cause\n            });\n        } else {\n            super(message ?? \"Invalid PDF\");\n        }\n        this.name = \"InvalidPDFException\";\n        // Fix TS/ES prototype chain (required)\n        Object.setPrototypeOf(this, InvalidPDFException.prototype);\n        // preserve native stack trace where available\n        if (typeof Error.captureStackTrace === \"function\") {\n            Error.captureStackTrace(this, InvalidPDFException);\n        }\n    // If you need to support older TS/targets that don't accept ErrorOptions,\n    // replace the above super(...) with super(...); and uncomment:\n    // if (cause !== undefined) (this as any).cause = cause;\n    }\n}\n/**\n * Error indicating a PDF file requires a password or the provided password is incorrect.\n *\n * @public\n */ class PasswordException extends Error {\n    /**\n     * Create a new PasswordException.\n     * @param message - Optional error message.\n     * @param cause - Optional underlying cause.\n     */ constructor(message, cause){\n        if (cause !== undefined) {\n            super(message ?? \"Password required or incorrect\", {\n                cause\n            });\n        } else {\n            super(message ?? \"Password required or incorrect\");\n        }\n        this.name = \"PasswordException\";\n        Object.setPrototypeOf(this, PasswordException.prototype);\n        if (typeof Error.captureStackTrace === \"function\") {\n            Error.captureStackTrace(this, PasswordException);\n        }\n    // Fallback for older targets: if needed use (this as any).cause = cause;\n    }\n}\n/**\n * Error thrown when the PDF structure/contents are malformed and cannot be parsed.\n *\n * This is raised for low-level format problems detected while reading PDF objects.\n * Errors caused during parsing PDF data.\n *\n * @public\n */ class FormatError extends Error {\n    /**\n     * Create a new FormatError.\n     * @param message - Optional message describing the format problem.\n     * @param cause - Optional underlying cause.\n     */ constructor(message, cause){\n        if (cause !== undefined) {\n            super(message ?? \"PDF format error\", {\n                cause\n            });\n        } else {\n            super(message ?? \"PDF format error\");\n        }\n        this.name = \"FormatError\";\n        Object.setPrototypeOf(this, FormatError.prototype);\n        if (typeof Error.captureStackTrace === \"function\") {\n            Error.captureStackTrace(this, FormatError);\n        }\n    // Fallback for older targets: if needed use (this as any).cause = cause;\n    }\n}\n/**\n * Generic wrapper for errors where the library cannot classify the cause.\n *\n * The `details` property may contain additional information provided by the\n * underlying PDF library.\n *\n * @public\n */ class UnknownErrorException extends Error {\n    /**\n     * Create a new UnknownErrorException.\n     * @param message - Optional error message.\n     * @param details - Optional additional details from the PDF library.\n     * @param cause - Optional underlying cause.\n     */ constructor(message, details, cause){\n        if (cause !== undefined) {\n            super(message ?? \"Unknown error\", {\n                cause\n            });\n        } else {\n            super(message ?? \"Unknown error\");\n        }\n        this.name = \"UnknownErrorException\";\n        Object.setPrototypeOf(this, UnknownErrorException.prototype);\n        if (typeof Error.captureStackTrace === \"function\") {\n            Error.captureStackTrace(this, UnknownErrorException);\n        }\n        // additional info field from pdf.mjs\n        this.details = details;\n    }\n}\n/**\n * Represents an HTTP/network response error encountered while fetching PDF data.\n *\n * The `status` and `missing` properties mirror values that may be provided\n * by the underlying PDF library's network layer.\n *\n * @public\n */ class ResponseException extends Error {\n    /**\n     * Create a new ResponseException.\n     * @param message - Optional error message.\n     * @param status - Optional numeric HTTP/status code.\n     * @param missing - Optional field describing missing resources.\n     * @param cause - Optional underlying cause.\n     */ constructor(message, status, missing, cause){\n        if (cause !== undefined) {\n            super(message ?? \"Response error\", {\n                cause\n            });\n        } else {\n            super(message ?? \"Response error\");\n        }\n        this.name = \"ResponseException\";\n        Object.setPrototypeOf(this, ResponseException.prototype);\n        if (typeof Error.captureStackTrace === \"function\") {\n            Error.captureStackTrace(this, ResponseException);\n        }\n        // fields from pdf.mjs\n        this.status = status;\n        this.missing = missing;\n    }\n}\n/**\n * Error used to indicate that an operation was aborted (for example by an AbortSignal).\n *\n * @public\n */ class AbortException extends Error {\n    /**\n     * Create a new AbortException.\n     * @param message - Optional error message.\n     * @param cause - Optional underlying cause.\n     */ constructor(message, cause){\n        if (cause !== undefined) {\n            super(message ?? \"Operation aborted\", {\n                cause\n            });\n        } else {\n            super(message ?? \"Operation aborted\");\n        }\n        this.name = \"AbortException\";\n        Object.setPrototypeOf(this, AbortException.prototype);\n        if (typeof Error.captureStackTrace === \"function\") {\n            Error.captureStackTrace(this, AbortException);\n        }\n    }\n}\n/**\n * Normalize arbitrary thrown values into an Error instance used by the library.\n *\n * Known Error instances with specific names are mapped to the library's\n * typed exceptions in order to preserve type information and any additional\n * fields (for example `details`, `status`, etc.). If the value is not an\n * Error it is converted to a generic Error containing the stringified value.\n *\n * @public\n * @param error - The thrown value to normalize.\n * @returns An Error instance representing the provided value.\n */ function getException(error) {\n    if (error instanceof Error) {\n        // preserve original error (stack) when not remapping\n        switch(error.name){\n            case \"InvalidPDFException\":\n                return new InvalidPDFException(error.message, error);\n            case \"PasswordException\":\n                return new PasswordException(error.message, error);\n            case \"FormatError\":\n                return new FormatError(error.message, error);\n            case \"UnknownErrorException\":\n                // preserve details if present on original\n                return new UnknownErrorException(error.message, error.details, error);\n            case \"ResponseException\":\n                return new ResponseException(error.message, error.status, error.missing, error);\n            case \"AbortException\":\n                return new AbortException(error.message, error);\n            // add other mappings as needed\n            default:\n                return error;\n        }\n    }\n    // non-Error value -> convert to Error\n    return new Error(String(error));\n} //# sourceMappingURL=Exception.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9FeGNlcHRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLGtFQUFrRSxHQUNsRTs7Ozs7OztDQU9DLEdBQ00sTUFBTUEsNEJBQTRCQztJQUNyQzs7OztLQUlDLEdBQ0RDLFlBQVlDLE9BQU8sRUFBRUMsS0FBSyxDQUFFO1FBQ3hCLElBQUlBLFVBQVVDLFdBQVc7WUFDckIseURBQXlEO1lBQ3pELEtBQUssQ0FBQ0YsV0FBVyxlQUFlO2dCQUFFQztZQUFNO1FBQzVDLE9BQ0s7WUFDRCxLQUFLLENBQUNELFdBQVc7UUFDckI7UUFDQSxJQUFJLENBQUNHLElBQUksR0FBRztRQUNaLHVDQUF1QztRQUN2Q0MsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRVIsb0JBQW9CUyxTQUFTO1FBQ3pELDhDQUE4QztRQUM5QyxJQUFJLE9BQU9SLE1BQU1TLGlCQUFpQixLQUFLLFlBQVk7WUFDL0NULE1BQU1TLGlCQUFpQixDQUFDLElBQUksRUFBRVY7UUFDbEM7SUFDQSwwRUFBMEU7SUFDMUUsK0RBQStEO0lBQy9ELHdEQUF3RDtJQUM1RDtBQUNKO0FBQ0E7Ozs7Q0FJQyxHQUNNLE1BQU1XLDBCQUEwQlY7SUFDbkM7Ozs7S0FJQyxHQUNEQyxZQUFZQyxPQUFPLEVBQUVDLEtBQUssQ0FBRTtRQUN4QixJQUFJQSxVQUFVQyxXQUFXO1lBQ3JCLEtBQUssQ0FBQ0YsV0FBVyxrQ0FBa0M7Z0JBQUVDO1lBQU07UUFDL0QsT0FDSztZQUNELEtBQUssQ0FBQ0QsV0FBVztRQUNyQjtRQUNBLElBQUksQ0FBQ0csSUFBSSxHQUFHO1FBQ1pDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUVHLGtCQUFrQkYsU0FBUztRQUN2RCxJQUFJLE9BQU9SLE1BQU1TLGlCQUFpQixLQUFLLFlBQVk7WUFDL0NULE1BQU1TLGlCQUFpQixDQUFDLElBQUksRUFBRUM7UUFDbEM7SUFDQSx5RUFBeUU7SUFDN0U7QUFD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QixPQUFPLEVBQUVpQjtZQUMxQyxLQUFLO2dCQUNELDBDQUEwQztnQkFDMUMsT0FBTyxJQUFJUCxzQkFBc0JPLE1BQU1qQixPQUFPLEVBQUVpQixNQUFNTixPQUFPLEVBQUVNO1lBQ25FLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJTCxrQkFBa0JLLE1BQU1qQixPQUFPLEVBQUVpQixNQUFNSixNQUFNLEVBQUVJLE1BQU1ILE9BQU8sRUFBRUc7WUFDN0UsS0FBSztnQkFDRCxPQUFPLElBQUlGLGVBQWVFLE1BQU1qQixPQUFPLEVBQUVpQjtZQUM3QywrQkFBK0I7WUFDL0I7Z0JBQ0ksT0FBT0E7UUFDZjtJQUNKO0lBQ0Esc0NBQXNDO0lBQ3RDLE9BQU8sSUFBSW5CLE1BQU1vQixPQUFPRDtBQUM1QixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWNhcmVlci1hc3Npc3RhbnQvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9FeGNlcHRpb24uanM/ODYzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBiaW9tZS1pZ25vcmUtYWxsIGxpbnQvc3VzcGljaW91cy9ub0V4cGxpY2l0QW55OiB1bmRlcmxpbmUtdHlwZSAqL1xuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgcGFyc2VkIGRhdGEgaXMgbm90IGEgdmFsaWQgUERGIGRvY3VtZW50LlxuICpcbiAqIFVzZSB0aGlzIGV4Y2VwdGlvbiB0byBzaWduYWwgdGhhdCB0aGUgaW5wdXQgY2Fubm90IGJlIGludGVycHJldGVkIGFzIGEgUERGXG4gKiAoY29ycnVwdCBmaWxlLCBpbnZhbGlkIGhlYWRlciwgZXRjLikuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFBERkV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgSW52YWxpZFBERkV4Y2VwdGlvbi5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIE9wdGlvbmFsIGVycm9yIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIGNhdXNlIC0gT3B0aW9uYWwgdW5kZXJseWluZyBjYXVzZSAocHJlc2VydmVkIG9uIG1vZGVybiBydW50aW1lcykuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICAgICAgaWYgKGNhdXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFVzZSBtb2Rlcm4gRXJyb3JPcHRpb25zIHRvIGF0dGFjaCBjYXVzZSB3aGVuIHN1cHBvcnRlZFxuICAgICAgICAgICAgc3VwZXIobWVzc2FnZSA/PyAnSW52YWxpZCBQREYnLCB7IGNhdXNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIobWVzc2FnZSA/PyAnSW52YWxpZCBQREYnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZFBERkV4Y2VwdGlvbic7XG4gICAgICAgIC8vIEZpeCBUUy9FUyBwcm90b3R5cGUgY2hhaW4gKHJlcXVpcmVkKVxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgSW52YWxpZFBERkV4Y2VwdGlvbi5wcm90b3R5cGUpO1xuICAgICAgICAvLyBwcmVzZXJ2ZSBuYXRpdmUgc3RhY2sgdHJhY2Ugd2hlcmUgYXZhaWxhYmxlXG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEludmFsaWRQREZFeGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgb2xkZXIgVFMvdGFyZ2V0cyB0aGF0IGRvbid0IGFjY2VwdCBFcnJvck9wdGlvbnMsXG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIGFib3ZlIHN1cGVyKC4uLikgd2l0aCBzdXBlciguLi4pOyBhbmQgdW5jb21tZW50OlxuICAgICAgICAvLyBpZiAoY2F1c2UgIT09IHVuZGVmaW5lZCkgKHRoaXMgYXMgYW55KS5jYXVzZSA9IGNhdXNlO1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3IgaW5kaWNhdGluZyBhIFBERiBmaWxlIHJlcXVpcmVzIGEgcGFzc3dvcmQgb3IgdGhlIHByb3ZpZGVkIHBhc3N3b3JkIGlzIGluY29ycmVjdC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXNzd29yZEV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgUGFzc3dvcmRFeGNlcHRpb24uXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBPcHRpb25hbCBlcnJvciBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBjYXVzZSAtIE9wdGlvbmFsIHVuZGVybHlpbmcgY2F1c2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICAgICAgaWYgKGNhdXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN1cGVyKG1lc3NhZ2UgPz8gJ1Bhc3N3b3JkIHJlcXVpcmVkIG9yIGluY29ycmVjdCcsIHsgY2F1c2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcihtZXNzYWdlID8/ICdQYXNzd29yZCByZXF1aXJlZCBvciBpbmNvcnJlY3QnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSAnUGFzc3dvcmRFeGNlcHRpb24nO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUGFzc3dvcmRFeGNlcHRpb24ucHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUGFzc3dvcmRFeGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrIGZvciBvbGRlciB0YXJnZXRzOiBpZiBuZWVkZWQgdXNlICh0aGlzIGFzIGFueSkuY2F1c2UgPSBjYXVzZTtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBQREYgc3RydWN0dXJlL2NvbnRlbnRzIGFyZSBtYWxmb3JtZWQgYW5kIGNhbm5vdCBiZSBwYXJzZWQuXG4gKlxuICogVGhpcyBpcyByYWlzZWQgZm9yIGxvdy1sZXZlbCBmb3JtYXQgcHJvYmxlbXMgZGV0ZWN0ZWQgd2hpbGUgcmVhZGluZyBQREYgb2JqZWN0cy5cbiAqIEVycm9ycyBjYXVzZWQgZHVyaW5nIHBhcnNpbmcgUERGIGRhdGEuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgRm9ybWF0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEZvcm1hdEVycm9yLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gT3B0aW9uYWwgbWVzc2FnZSBkZXNjcmliaW5nIHRoZSBmb3JtYXQgcHJvYmxlbS5cbiAgICAgKiBAcGFyYW0gY2F1c2UgLSBPcHRpb25hbCB1bmRlcmx5aW5nIGNhdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgICAgIGlmIChjYXVzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdXBlcihtZXNzYWdlID8/ICdQREYgZm9ybWF0IGVycm9yJywgeyBjYXVzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyKG1lc3NhZ2UgPz8gJ1BERiBmb3JtYXQgZXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSAnRm9ybWF0RXJyb3InO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRm9ybWF0RXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRm9ybWF0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrIGZvciBvbGRlciB0YXJnZXRzOiBpZiBuZWVkZWQgdXNlICh0aGlzIGFzIGFueSkuY2F1c2UgPSBjYXVzZTtcbiAgICB9XG59XG4vKipcbiAqIEdlbmVyaWMgd3JhcHBlciBmb3IgZXJyb3JzIHdoZXJlIHRoZSBsaWJyYXJ5IGNhbm5vdCBjbGFzc2lmeSB0aGUgY2F1c2UuXG4gKlxuICogVGhlIGBkZXRhaWxzYCBwcm9wZXJ0eSBtYXkgY29udGFpbiBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHByb3ZpZGVkIGJ5IHRoZVxuICogdW5kZXJseWluZyBQREYgbGlicmFyeS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBVbmtub3duRXJyb3JFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFVua25vd25FcnJvckV4Y2VwdGlvbi5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIE9wdGlvbmFsIGVycm9yIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIGRldGFpbHMgLSBPcHRpb25hbCBhZGRpdGlvbmFsIGRldGFpbHMgZnJvbSB0aGUgUERGIGxpYnJhcnkuXG4gICAgICogQHBhcmFtIGNhdXNlIC0gT3B0aW9uYWwgdW5kZXJseWluZyBjYXVzZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzLCBjYXVzZSkge1xuICAgICAgICBpZiAoY2F1c2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3VwZXIobWVzc2FnZSA/PyAnVW5rbm93biBlcnJvcicsIHsgY2F1c2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcihtZXNzYWdlID8/ICdVbmtub3duIGVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gJ1Vua25vd25FcnJvckV4Y2VwdGlvbic7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBVbmtub3duRXJyb3JFeGNlcHRpb24ucHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgVW5rbm93bkVycm9yRXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGRpdGlvbmFsIGluZm8gZmllbGQgZnJvbSBwZGYubWpzXG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIEhUVFAvbmV0d29yayByZXNwb25zZSBlcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBmZXRjaGluZyBQREYgZGF0YS5cbiAqXG4gKiBUaGUgYHN0YXR1c2AgYW5kIGBtaXNzaW5nYCBwcm9wZXJ0aWVzIG1pcnJvciB2YWx1ZXMgdGhhdCBtYXkgYmUgcHJvdmlkZWRcbiAqIGJ5IHRoZSB1bmRlcmx5aW5nIFBERiBsaWJyYXJ5J3MgbmV0d29yayBsYXllci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXNwb25zZUV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgUmVzcG9uc2VFeGNlcHRpb24uXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBPcHRpb25hbCBlcnJvciBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBzdGF0dXMgLSBPcHRpb25hbCBudW1lcmljIEhUVFAvc3RhdHVzIGNvZGUuXG4gICAgICogQHBhcmFtIG1pc3NpbmcgLSBPcHRpb25hbCBmaWVsZCBkZXNjcmliaW5nIG1pc3NpbmcgcmVzb3VyY2VzLlxuICAgICAqIEBwYXJhbSBjYXVzZSAtIE9wdGlvbmFsIHVuZGVybHlpbmcgY2F1c2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBtaXNzaW5nLCBjYXVzZSkge1xuICAgICAgICBpZiAoY2F1c2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3VwZXIobWVzc2FnZSA/PyAnUmVzcG9uc2UgZXJyb3InLCB7IGNhdXNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIobWVzc2FnZSA/PyAnUmVzcG9uc2UgZXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSAnUmVzcG9uc2VFeGNlcHRpb24nO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUmVzcG9uc2VFeGNlcHRpb24ucHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVzcG9uc2VFeGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpZWxkcyBmcm9tIHBkZi5tanNcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMubWlzc2luZyA9IG1pc3Npbmc7XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciB1c2VkIHRvIGluZGljYXRlIHRoYXQgYW4gb3BlcmF0aW9uIHdhcyBhYm9ydGVkIChmb3IgZXhhbXBsZSBieSBhbiBBYm9ydFNpZ25hbCkuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQWJvcnRFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEFib3J0RXhjZXB0aW9uLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gT3B0aW9uYWwgZXJyb3IgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gY2F1c2UgLSBPcHRpb25hbCB1bmRlcmx5aW5nIGNhdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgICAgIGlmIChjYXVzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdXBlcihtZXNzYWdlID8/ICdPcGVyYXRpb24gYWJvcnRlZCcsIHsgY2F1c2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcihtZXNzYWdlID8/ICdPcGVyYXRpb24gYWJvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9ICdBYm9ydEV4Y2VwdGlvbic7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBBYm9ydEV4Y2VwdGlvbi5wcm90b3R5cGUpO1xuICAgICAgICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBBYm9ydEV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhcmJpdHJhcnkgdGhyb3duIHZhbHVlcyBpbnRvIGFuIEVycm9yIGluc3RhbmNlIHVzZWQgYnkgdGhlIGxpYnJhcnkuXG4gKlxuICogS25vd24gRXJyb3IgaW5zdGFuY2VzIHdpdGggc3BlY2lmaWMgbmFtZXMgYXJlIG1hcHBlZCB0byB0aGUgbGlicmFyeSdzXG4gKiB0eXBlZCBleGNlcHRpb25zIGluIG9yZGVyIHRvIHByZXNlcnZlIHR5cGUgaW5mb3JtYXRpb24gYW5kIGFueSBhZGRpdGlvbmFsXG4gKiBmaWVsZHMgKGZvciBleGFtcGxlIGBkZXRhaWxzYCwgYHN0YXR1c2AsIGV0Yy4pLiBJZiB0aGUgdmFsdWUgaXMgbm90IGFuXG4gKiBFcnJvciBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBnZW5lcmljIEVycm9yIGNvbnRhaW5pbmcgdGhlIHN0cmluZ2lmaWVkIHZhbHVlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSB0aHJvd24gdmFsdWUgdG8gbm9ybWFsaXplLlxuICogQHJldHVybnMgQW4gRXJyb3IgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV4Y2VwdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIGVycm9yIChzdGFjaykgd2hlbiBub3QgcmVtYXBwaW5nXG4gICAgICAgIHN3aXRjaCAoZXJyb3IubmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnSW52YWxpZFBERkV4Y2VwdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkUERGRXhjZXB0aW9uKGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ1Bhc3N3b3JkRXhjZXB0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBhc3N3b3JkRXhjZXB0aW9uKGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ0Zvcm1hdEVycm9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ1Vua25vd25FcnJvckV4Y2VwdGlvbic6XG4gICAgICAgICAgICAgICAgLy8gcHJlc2VydmUgZGV0YWlscyBpZiBwcmVzZW50IG9uIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24oZXJyb3IubWVzc2FnZSwgZXJyb3IuZGV0YWlscywgZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnUmVzcG9uc2VFeGNlcHRpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2VFeGNlcHRpb24oZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhdHVzLCBlcnJvci5taXNzaW5nLCBlcnJvcik7XG4gICAgICAgICAgICBjYXNlICdBYm9ydEV4Y2VwdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBYm9ydEV4Y2VwdGlvbihlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAvLyBhZGQgb3RoZXIgbWFwcGluZ3MgYXMgbmVlZGVkXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBub24tRXJyb3IgdmFsdWUgLT4gY29udmVydCB0byBFcnJvclxuICAgIHJldHVybiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeGNlcHRpb24uanMubWFwIl0sIm5hbWVzIjpbIkludmFsaWRQREZFeGNlcHRpb24iLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImNhdXNlIiwidW5kZWZpbmVkIiwibmFtZSIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJQYXNzd29yZEV4Y2VwdGlvbiIsIkZvcm1hdEVycm9yIiwiVW5rbm93bkVycm9yRXhjZXB0aW9uIiwiZGV0YWlscyIsIlJlc3BvbnNlRXhjZXB0aW9uIiwic3RhdHVzIiwibWlzc2luZyIsIkFib3J0RXhjZXB0aW9uIiwiZ2V0RXhjZXB0aW9uIiwiZXJyb3IiLCJTdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/Exception.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/ImageResult.js":
/*!******************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/ImageResult.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImageResult: () => (/* binding */ ImageResult)\n/* harmony export */ });\n/**\n * @public\n * ImageResult\n * Helper container for extracted images grouped per page.\n */ class ImageResult {\n    getPageImage(num, name) {\n        for (const pageData of this.pages){\n            if (pageData.pageNumber === num) {\n                for (const img of pageData.images){\n                    if (img.name === name) {\n                        return img;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    constructor(total){\n        this.pages = [];\n        this.total = 0;\n        this.total = total;\n    }\n} //# sourceMappingURL=ImageResult.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9JbWFnZVJlc3VsdC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Q0FJQyxHQUNNLE1BQU1BO0lBR1RDLGFBQWFDLEdBQUcsRUFBRUMsSUFBSSxFQUFFO1FBQ3BCLEtBQUssTUFBTUMsWUFBWSxJQUFJLENBQUNDLEtBQUssQ0FBRTtZQUMvQixJQUFJRCxTQUFTRSxVQUFVLEtBQUtKLEtBQUs7Z0JBQzdCLEtBQUssTUFBTUssT0FBT0gsU0FBU0ksTUFBTSxDQUFFO29CQUMvQixJQUFJRCxJQUFJSixJQUFJLEtBQUtBLE1BQU07d0JBQ25CLE9BQU9JO29CQUNYO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLE9BQU87SUFDWDtJQUNBRSxZQUFZQyxLQUFLLENBQUU7YUFkbkJMLFFBQVEsRUFBRTthQUNWSyxRQUFRO1FBY0osSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0lBQ2pCO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1jYXJlZXItYXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL3BkZi1wYXJzZS9kaXN0L3BkZi1wYXJzZS9lc20vSW1hZ2VSZXN1bHQuanM/OGY4MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwdWJsaWNcbiAqIEltYWdlUmVzdWx0XG4gKiBIZWxwZXIgY29udGFpbmVyIGZvciBleHRyYWN0ZWQgaW1hZ2VzIGdyb3VwZWQgcGVyIHBhZ2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbWFnZVJlc3VsdCB7XG4gICAgcGFnZXMgPSBbXTtcbiAgICB0b3RhbCA9IDA7XG4gICAgZ2V0UGFnZUltYWdlKG51bSwgbmFtZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHBhZ2VEYXRhIG9mIHRoaXMucGFnZXMpIHtcbiAgICAgICAgICAgIGlmIChwYWdlRGF0YS5wYWdlTnVtYmVyID09PSBudW0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGltZyBvZiBwYWdlRGF0YS5pbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltZy5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0b3RhbCkge1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1hZ2VSZXN1bHQuanMubWFwIl0sIm5hbWVzIjpbIkltYWdlUmVzdWx0IiwiZ2V0UGFnZUltYWdlIiwibnVtIiwibmFtZSIsInBhZ2VEYXRhIiwicGFnZXMiLCJwYWdlTnVtYmVyIiwiaW1nIiwiaW1hZ2VzIiwiY29uc3RydWN0b3IiLCJ0b3RhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/ImageResult.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/InfoResult.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/InfoResult.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InfoResult: () => (/* binding */ InfoResult)\n/* harmony export */ });\n/* harmony import */ var pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pdfjs-dist/legacy/build/pdf.mjs */ \"(rsc)/./node_modules/pdf-parse/node_modules/pdfjs-dist/legacy/build/pdf.mjs\");\n\nconst XMP_DATE_PROPERTIES = [\n    \"xmp:createdate\",\n    \"xmp:modifydate\",\n    \"xmp:metadatadate\",\n    \"xap:createdate\",\n    \"xap:modifydate\",\n    \"xap:metadatadate\"\n];\n/**\n * @public\n * Aggregated information about a PDF document returned by getInfo().\n * The object contains high-level metadata, outline/bookmark structure,\n * per-page extracted hyperlinks and utility helpers for parsing dates.\n */ class InfoResult {\n    /**\n     * Collects dates from different sources (Info dictionary and XMP/XAP metadata)\n     * and returns them as a DateNode where available. This helps callers compare\n     * and choose the most relevant timestamp (for example a creation date vs XMP date).\n     */ getDateNode() {\n        const result = {};\n        // The Info dictionary may contain CreationDate/ModDate in PDF date string format.\n        // biome-ignore lint/suspicious/noExplicitAny: <unsupported underline type>\n        const CreationDate = this.info?.CreationDate;\n        if (CreationDate) {\n            result.CreationDate = pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.PDFDateString.toDateObject(CreationDate);\n        }\n        // biome-ignore lint/suspicious/noExplicitAny: <unsupported underline type>\n        const ModDate = this.info?.ModDate;\n        if (ModDate) {\n            result.ModDate = pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.PDFDateString.toDateObject(ModDate);\n        }\n        // If no XMP metadata is present, return the Info-based dates only.\n        if (!this.metadata) {\n            return result;\n        }\n        // Extract several XMP/XAP date properties (if present) and attempt to\n        // parse them as ISO-like strings. Parsed values are added to the\n        // corresponding DateNode fields.\n        for (const prop of XMP_DATE_PROPERTIES){\n            const value = this.metadata?.get(prop);\n            const date = this.parseISODateString(value);\n            switch(prop){\n                case XMP_DATE_PROPERTIES[0]:\n                    result.XmpCreateDate = date;\n                    break;\n                case XMP_DATE_PROPERTIES[1]:\n                    result.XmpModifyDate = date;\n                    break;\n                case XMP_DATE_PROPERTIES[2]:\n                    result.XmpMetadataDate = date;\n                    break;\n                case XMP_DATE_PROPERTIES[3]:\n                    result.XapCreateDate = date;\n                    break;\n                case XMP_DATE_PROPERTIES[4]:\n                    result.XapModifyDate = date;\n                    break;\n                case XMP_DATE_PROPERTIES[5]:\n                    result.XapMetadataDate = date;\n                    break;\n            }\n        }\n        return result;\n    }\n    /**\n     * Try to parse an ISO-8601 date string from XMP/XAP metadata. If the\n     * value is falsy or cannot be parsed, undefined is returned to indicate\n     * absence or unparsable input.\n     */ parseISODateString(isoDateString) {\n        if (!isoDateString) return undefined;\n        const parsedDate = Date.parse(isoDateString);\n        if (!Number.isNaN(parsedDate)) {\n            return new Date(parsedDate);\n        }\n        return undefined;\n    }\n    constructor(total){\n        // Results with per-page hyperlink extraction. Empty array by default.\n        this.pages = [];\n        this.total = total;\n    }\n} //# sourceMappingURL=InfoResult.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9JbmZvUmVzdWx0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlEO0FBQ3pELE1BQU1DLHNCQUFzQjtJQUN4QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNEOzs7OztDQUtDLEdBQ00sTUFBTUM7SUErQlQ7Ozs7S0FJQyxHQUNEQyxjQUFjO1FBQ1YsTUFBTUMsU0FBUyxDQUFDO1FBQ2hCLGtGQUFrRjtRQUNsRiwyRUFBMkU7UUFDM0UsTUFBTUMsZUFBZSxJQUFJLENBQUNDLElBQUksRUFBRUQ7UUFDaEMsSUFBSUEsY0FBYztZQUNkRCxPQUFPQyxZQUFZLEdBQUdMLDBFQUFtQixDQUFDUSxZQUFZLENBQUNIO1FBQzNEO1FBQ0EsMkVBQTJFO1FBQzNFLE1BQU1JLFVBQVUsSUFBSSxDQUFDSCxJQUFJLEVBQUVHO1FBQzNCLElBQUlBLFNBQVM7WUFDVEwsT0FBT0ssT0FBTyxHQUFHVCwwRUFBbUIsQ0FBQ1EsWUFBWSxDQUFDQztRQUN0RDtRQUNBLG1FQUFtRTtRQUNuRSxJQUFJLENBQUMsSUFBSSxDQUFDQyxRQUFRLEVBQUU7WUFDaEIsT0FBT047UUFDWDtRQUNBLHNFQUFzRTtRQUN0RSxpRUFBaUU7UUFDakUsaUNBQWlDO1FBQ2pDLEtBQUssTUFBTU8sUUFBUVYsb0JBQXFCO1lBQ3BDLE1BQU1XLFFBQVEsSUFBSSxDQUFDRixRQUFRLEVBQUVHLElBQUlGO1lBQ2pDLE1BQU1HLE9BQU8sSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQ0g7WUFDckMsT0FBUUQ7Z0JBQ0osS0FBS1YsbUJBQW1CLENBQUMsRUFBRTtvQkFDdkJHLE9BQU9ZLGFBQWEsR0FBR0Y7b0JBQ3ZCO2dCQUNKLEtBQUtiLG1CQUFtQixDQUFDLEVBQUU7b0JBQ3ZCRyxPQUFPYSxhQUFhLEdBQUdIO29CQUN2QjtnQkFDSixLQUFLYixtQkFBbUIsQ0FBQyxFQUFFO29CQUN2QkcsT0FBT2MsZUFBZSxHQUFHSjtvQkFDekI7Z0JBQ0osS0FBS2IsbUJBQW1CLENBQUMsRUFBRTtvQkFDdkJHLE9BQU9lLGFBQWEsR0FBR0w7b0JBQ3ZCO2dCQUNKLEtBQUtiLG1CQUFtQixDQUFDLEVBQUU7b0JBQ3ZCRyxPQUFPZ0IsYUFBYSxHQUFHTjtvQkFDdkI7Z0JBQ0osS0FBS2IsbUJBQW1CLENBQUMsRUFBRTtvQkFDdkJHLE9BQU9pQixlQUFlLEdBQUdQO29CQUN6QjtZQUNSO1FBQ0o7UUFDQSxPQUFPVjtJQUNYO0lBQ0E7Ozs7S0FJQyxHQUNEVyxtQkFBbUJPLGFBQWEsRUFBRTtRQUM5QixJQUFJLENBQUNBLGVBQ0QsT0FBT0M7UUFDWCxNQUFNQyxhQUFhQyxLQUFLQyxLQUFLLENBQUNKO1FBQzlCLElBQUksQ0FBQ0ssT0FBT0MsS0FBSyxDQUFDSixhQUFhO1lBQzNCLE9BQU8sSUFBSUMsS0FBS0Q7UUFDcEI7UUFDQSxPQUFPRDtJQUNYO0lBQ0FNLFlBQVlDLEtBQUssQ0FBRTtRQW5FbkIsc0VBQXNFO2FBQ3RFQyxRQUFRLEVBQUU7UUFtRU4sSUFBSSxDQUFDRCxLQUFLLEdBQUdBO0lBQ2pCO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1jYXJlZXItYXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL3BkZi1wYXJzZS9kaXN0L3BkZi1wYXJzZS9lc20vSW5mb1Jlc3VsdC5qcz8yMjViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBkZmpzIGZyb20gJ3BkZmpzLWRpc3QvbGVnYWN5L2J1aWxkL3BkZi5tanMnO1xuY29uc3QgWE1QX0RBVEVfUFJPUEVSVElFUyA9IFtcbiAgICAneG1wOmNyZWF0ZWRhdGUnLFxuICAgICd4bXA6bW9kaWZ5ZGF0ZScsXG4gICAgJ3htcDptZXRhZGF0YWRhdGUnLFxuICAgICd4YXA6Y3JlYXRlZGF0ZScsXG4gICAgJ3hhcDptb2RpZnlkYXRlJyxcbiAgICAneGFwOm1ldGFkYXRhZGF0ZScsXG5dO1xuLyoqXG4gKiBAcHVibGljXG4gKiBBZ2dyZWdhdGVkIGluZm9ybWF0aW9uIGFib3V0IGEgUERGIGRvY3VtZW50IHJldHVybmVkIGJ5IGdldEluZm8oKS5cbiAqIFRoZSBvYmplY3QgY29udGFpbnMgaGlnaC1sZXZlbCBtZXRhZGF0YSwgb3V0bGluZS9ib29rbWFyayBzdHJ1Y3R1cmUsXG4gKiBwZXItcGFnZSBleHRyYWN0ZWQgaHlwZXJsaW5rcyBhbmQgdXRpbGl0eSBoZWxwZXJzIGZvciBwYXJzaW5nIGRhdGVzLlxuICovXG5leHBvcnQgY2xhc3MgSW5mb1Jlc3VsdCB7XG4gICAgLy8gVG90YWwgbnVtYmVyIG9mIHBhZ2VzIGluIHRoZSBQREYgZG9jdW1lbnQgKGNvdW50IG9mIHBoeXNpY2FsIHBhZ2VzKS5cbiAgICB0b3RhbDtcbiAgICAvKipcbiAgICAgKiBUaGUgUERGICdJbmZvJyBkaWN0aW9uYXJ5LiBUeXBpY2FsIGZpZWxkcyBpbmNsdWRlIHRpdGxlLCBhdXRob3IsIHN1YmplY3QsXG4gICAgICogQ3JlYXRvciwgUHJvZHVjZXIgYW5kIENyZWF0aW9uL01vZGlmaWNhdGlvbiBkYXRlcy4gVGhlIGV4YWN0IHN0cnVjdHVyZSBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIFBERiBhbmQgYXMgcmV0dXJuZWQgYnkgUERGLmpzLlxuICAgICAqL1xuICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9FeHBsaWNpdEFueTogPHVuc3VwcG9ydGVkIHVuZGVybGluZSB0eXBlPlxuICAgIGluZm87XG4gICAgLy8gTG93LWxldmVsIGRvY3VtZW50IG1ldGFkYXRhIG9iamVjdCAoWE1QKS4gVXNlIHRoaXMgdG8gYWNjZXNzIGV4dGVuZGVkXG4gICAgLy8gcHJvcGVydGllcyB0aGF0IGFyZSBub3QgcHJlc2VudCBpbiB0aGUgSW5mbyBkaWN0aW9uYXJ5LlxuICAgIG1ldGFkYXRhO1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGRvY3VtZW50IGZpbmdlcnByaW50IHN0cmluZ3MgcHJvdmlkZWQgYnkgUERGLmpzLiBVc2VmdWxcbiAgICAgKiBmb3IgY2FjaGluZywgZGUtZHVwbGljYXRpb24gb3IgaWRlbnRpZnlpbmcgYSBkb2N1bWVudCBhY3Jvc3MgcnVucy5cbiAgICAgKi9cbiAgICBmaW5nZXJwcmludHM7XG4gICAgLyoqXG4gICAgICogUGVybWlzc2lvbiBmbGFncyBmb3IgdGhlIGRvY3VtZW50IGFzIHJldHVybmVkIGJ5IFBERi5qcyAob3IgbnVsbCkuXG4gICAgICogVGhlc2UgZmxhZ3MgaW5kaWNhdGUgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgcHJpbnRpbmcsIGNvcHlpbmcgYW5kXG4gICAgICogb3RoZXIgcmVzdHJpY3Rpb25zIGltcG9zZWQgYnkgdGhlIFBERiBzZWN1cml0eSBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICBwZXJtaXNzaW9uO1xuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIGRvY3VtZW50IG91dGxpbmUgKGJvb2ttYXJrcykuIFdoZW4gcHJlc2VudCB0aGlzIGlzIHRoZVxuICAgICAqIGhpZXJhcmNoaWNhbCBuYXZpZ2F0aW9uIHN0cnVjdHVyZSB3aGljaCB2aWV3ZXJzIHVzZSBmb3IgcXVpY2sgYWNjZXNzLlxuICAgICAqL1xuICAgIG91dGxpbmU7XG4gICAgLy8gUmVzdWx0cyB3aXRoIHBlci1wYWdlIGh5cGVybGluayBleHRyYWN0aW9uLiBFbXB0eSBhcnJheSBieSBkZWZhdWx0LlxuICAgIHBhZ2VzID0gW107XG4gICAgLyoqXG4gICAgICogQ29sbGVjdHMgZGF0ZXMgZnJvbSBkaWZmZXJlbnQgc291cmNlcyAoSW5mbyBkaWN0aW9uYXJ5IGFuZCBYTVAvWEFQIG1ldGFkYXRhKVxuICAgICAqIGFuZCByZXR1cm5zIHRoZW0gYXMgYSBEYXRlTm9kZSB3aGVyZSBhdmFpbGFibGUuIFRoaXMgaGVscHMgY2FsbGVycyBjb21wYXJlXG4gICAgICogYW5kIGNob29zZSB0aGUgbW9zdCByZWxldmFudCB0aW1lc3RhbXAgKGZvciBleGFtcGxlIGEgY3JlYXRpb24gZGF0ZSB2cyBYTVAgZGF0ZSkuXG4gICAgICovXG4gICAgZ2V0RGF0ZU5vZGUoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICAvLyBUaGUgSW5mbyBkaWN0aW9uYXJ5IG1heSBjb250YWluIENyZWF0aW9uRGF0ZS9Nb2REYXRlIGluIFBERiBkYXRlIHN0cmluZyBmb3JtYXQuXG4gICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9FeHBsaWNpdEFueTogPHVuc3VwcG9ydGVkIHVuZGVybGluZSB0eXBlPlxuICAgICAgICBjb25zdCBDcmVhdGlvbkRhdGUgPSB0aGlzLmluZm8/LkNyZWF0aW9uRGF0ZTtcbiAgICAgICAgaWYgKENyZWF0aW9uRGF0ZSkge1xuICAgICAgICAgICAgcmVzdWx0LkNyZWF0aW9uRGF0ZSA9IHBkZmpzLlBERkRhdGVTdHJpbmcudG9EYXRlT2JqZWN0KENyZWF0aW9uRGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0V4cGxpY2l0QW55OiA8dW5zdXBwb3J0ZWQgdW5kZXJsaW5lIHR5cGU+XG4gICAgICAgIGNvbnN0IE1vZERhdGUgPSB0aGlzLmluZm8/Lk1vZERhdGU7XG4gICAgICAgIGlmIChNb2REYXRlKSB7XG4gICAgICAgICAgICByZXN1bHQuTW9kRGF0ZSA9IHBkZmpzLlBERkRhdGVTdHJpbmcudG9EYXRlT2JqZWN0KE1vZERhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIFhNUCBtZXRhZGF0YSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIEluZm8tYmFzZWQgZGF0ZXMgb25seS5cbiAgICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4dHJhY3Qgc2V2ZXJhbCBYTVAvWEFQIGRhdGUgcHJvcGVydGllcyAoaWYgcHJlc2VudCkgYW5kIGF0dGVtcHQgdG9cbiAgICAgICAgLy8gcGFyc2UgdGhlbSBhcyBJU08tbGlrZSBzdHJpbmdzLiBQYXJzZWQgdmFsdWVzIGFyZSBhZGRlZCB0byB0aGVcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBEYXRlTm9kZSBmaWVsZHMuXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBYTVBfREFURV9QUk9QRVJUSUVTKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMubWV0YWRhdGE/LmdldChwcm9wKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLnBhcnNlSVNPRGF0ZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlIFhNUF9EQVRFX1BST1BFUlRJRVNbMF06XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5YbXBDcmVhdGVEYXRlID0gZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBYTVBfREFURV9QUk9QRVJUSUVTWzFdOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuWG1wTW9kaWZ5RGF0ZSA9IGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgWE1QX0RBVEVfUFJPUEVSVElFU1syXTpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LlhtcE1ldGFkYXRhRGF0ZSA9IGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgWE1QX0RBVEVfUFJPUEVSVElFU1szXTpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LlhhcENyZWF0ZURhdGUgPSBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFhNUF9EQVRFX1BST1BFUlRJRVNbNF06XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5YYXBNb2RpZnlEYXRlID0gZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBYTVBfREFURV9QUk9QRVJUSUVTWzVdOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuWGFwTWV0YWRhdGFEYXRlID0gZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ5IHRvIHBhcnNlIGFuIElTTy04NjAxIGRhdGUgc3RyaW5nIGZyb20gWE1QL1hBUCBtZXRhZGF0YS4gSWYgdGhlXG4gICAgICogdmFsdWUgaXMgZmFsc3kgb3IgY2Fubm90IGJlIHBhcnNlZCwgdW5kZWZpbmVkIGlzIHJldHVybmVkIHRvIGluZGljYXRlXG4gICAgICogYWJzZW5jZSBvciB1bnBhcnNhYmxlIGlucHV0LlxuICAgICAqL1xuICAgIHBhcnNlSVNPRGF0ZVN0cmluZyhpc29EYXRlU3RyaW5nKSB7XG4gICAgICAgIGlmICghaXNvRGF0ZVN0cmluZylcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHBhcnNlZERhdGUgPSBEYXRlLnBhcnNlKGlzb0RhdGVTdHJpbmcpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihwYXJzZWREYXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHBhcnNlZERhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHRvdGFsKSB7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbmZvUmVzdWx0LmpzLm1hcCJdLCJuYW1lcyI6WyJwZGZqcyIsIlhNUF9EQVRFX1BST1BFUlRJRVMiLCJJbmZvUmVzdWx0IiwiZ2V0RGF0ZU5vZGUiLCJyZXN1bHQiLCJDcmVhdGlvbkRhdGUiLCJpbmZvIiwiUERGRGF0ZVN0cmluZyIsInRvRGF0ZU9iamVjdCIsIk1vZERhdGUiLCJtZXRhZGF0YSIsInByb3AiLCJ2YWx1ZSIsImdldCIsImRhdGUiLCJwYXJzZUlTT0RhdGVTdHJpbmciLCJYbXBDcmVhdGVEYXRlIiwiWG1wTW9kaWZ5RGF0ZSIsIlhtcE1ldGFkYXRhRGF0ZSIsIlhhcENyZWF0ZURhdGUiLCJYYXBNb2RpZnlEYXRlIiwiWGFwTWV0YWRhdGFEYXRlIiwiaXNvRGF0ZVN0cmluZyIsInVuZGVmaW5lZCIsInBhcnNlZERhdGUiLCJEYXRlIiwicGFyc2UiLCJOdW1iZXIiLCJpc05hTiIsImNvbnN0cnVjdG9yIiwidG90YWwiLCJwYWdlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/InfoResult.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/PDFParse.js":
/*!***************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/PDFParse.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PDFParse: () => (/* binding */ PDFParse)\n/* harmony export */ });\n/* harmony import */ var pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pdfjs-dist/legacy/build/pdf.mjs */ \"(rsc)/./node_modules/pdf-parse/node_modules/pdfjs-dist/legacy/build/pdf.mjs\");\n/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Exception.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/Exception.js\");\n/* harmony import */ var _geometry_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometry/index.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/index.js\");\n/* harmony import */ var _ImageResult_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ImageResult.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/ImageResult.js\");\n/* harmony import */ var _InfoResult_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./InfoResult.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/InfoResult.js\");\n/* harmony import */ var _ParseParameters_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ParseParameters.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/ParseParameters.js\");\n/* harmony import */ var _PathGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PathGeometry.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/PathGeometry.js\");\n/* harmony import */ var _ScreenshotResult_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ScreenshotResult.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/ScreenshotResult.js\");\n/* harmony import */ var _TableResult_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TableResult.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/TableResult.js\");\n/* harmony import */ var _TextResult_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TextResult.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/TextResult.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * @public\n * Loads PDF documents and exposes helpers for text, image, table, metadata, and screenshot extraction.\n */ class PDFParse {\n    /**\n     * Create a new parser with `LoadParameters`.\n     * Converts Node.js `Buffer` data to `Uint8Array` automatically and ensures a default verbosity level.\n     * @param options - Initialization parameters.\n     */ constructor(options){\n        this.progress = {\n            loaded: -1,\n            total: 0\n        };\n        if (options.verbosity === undefined) {\n            options.verbosity = pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.VerbosityLevel.ERRORS;\n        }\n        if (typeof Buffer !== \"undefined\" && options.data instanceof Buffer) {\n            options.data = new Uint8Array(options.data);\n        }\n        this.options = options;\n    }\n    async destroy() {\n        if (this.doc) {\n            await this.doc.destroy();\n            this.doc = undefined;\n        }\n    }\n    // biome-ignore-start lint/suspicious/noExplicitAny: unsupported underline type\n    static get isNodeJS() {\n        const isNodeJS = typeof process === \"object\" && `${process}` === \"[object process]\" && !process.versions.nw && !(process.versions.electron && typeof process.type !== \"undefined\" && process.type !== \"browser\");\n        return isNodeJS;\n    }\n    static setWorker(workerSrc) {\n        if (typeof globalThis.pdfjs === \"undefined\") {\n            globalThis.pdfjs = pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__;\n        }\n        if (pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__?.GlobalWorkerOptions === null) return \"\";\n        if (workerSrc !== undefined) {\n            pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions.workerSrc = workerSrc;\n            return pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions.workerSrc;\n        }\n        // if (!PDFParse.isNodeJS) {\n        // \tpdfjs.GlobalWorkerOptions.workerSrc =\n        // \t\t'https://cdn.jsdelivr.net/npm/pdf-parse@latest/dist/browser/pdf.worker.min.mjs';\n        // \treturn pdfjs.GlobalWorkerOptions.workerSrc;\n        // }\n        return pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions.workerSrc;\n    }\n    // biome-ignore-end lint/suspicious/noExplicitAny: unsupported underline type\n    /**\n     * Load document-level metadata (info, outline, permissions, page labels) and optionally gather per-page link details.\n     * @param params - Parse options; set `parsePageInfo` to collect per-page metadata described in `ParseParameters`.\n     * @returns Aggregated document metadata in an `InfoResult`.\n     */ async getInfo(params = {}) {\n        const doc = await this.load();\n        const result = new _InfoResult_js__WEBPACK_IMPORTED_MODULE_4__.InfoResult(doc.numPages);\n        const { info, metadata } = await doc.getMetadata();\n        result.info = info;\n        result.metadata = metadata;\n        result.fingerprints = doc.fingerprints;\n        result.outline = await doc.getOutline();\n        result.permission = await doc.getPermissions();\n        const pageLabels = await doc.getPageLabels();\n        if (params.parsePageInfo) {\n            for(let i = 1; i <= result.total; i++){\n                if (this.shouldParse(i, result.total, params)) {\n                    const page = await doc.getPage(i);\n                    const pageLinkResult = await this.getPageLinks(page);\n                    pageLinkResult.pageLabel = pageLabels?.[page.pageNumber];\n                    result.pages.push(pageLinkResult);\n                    page.cleanup();\n                }\n            }\n        }\n        return result;\n    }\n    async getPageLinks(page) {\n        const viewport = page.getViewport({\n            scale: 1\n        });\n        const result = {\n            pageNumber: page.pageNumber,\n            links: [],\n            width: viewport.width,\n            height: viewport.height\n        };\n        // biome-ignore lint/suspicious/noExplicitAny: <unsupported underline type>\n        const annotations = await page.getAnnotations({\n            intent: \"display\"\n        }) || [];\n        for (const i of annotations){\n            if (i.subtype !== \"Link\") continue;\n            const url = i.url ?? i.unsafeUrl;\n            if (!url) continue;\n            const text = i.overlaidText || \"\";\n            result.links.push({\n                url,\n                text\n            });\n        }\n        return result;\n    }\n    /**\n     * Extract plain text for each requested page, optionally enriching hyperlinks and enforcing line or cell separators.\n     * @param params - Parse options controlling pagination, link handling, and line/cell thresholds.\n     * @returns A `TextResult` containing page-wise text and a concatenated document string.\n     */ async getText(params = {}) {\n        const doc = await this.load();\n        const result = new _TextResult_js__WEBPACK_IMPORTED_MODULE_9__.TextResult(doc.numPages);\n        for(let i = 1; i <= result.total; i++){\n            if (this.shouldParse(i, result.total, params)) {\n                const page = await doc.getPage(i);\n                const text = await this.getPageText(page, params, result.total);\n                result.pages.push({\n                    text: text,\n                    num: i\n                });\n                page.cleanup();\n            }\n        }\n        for (const page of result.pages){\n            if (params.pageJoiner) {\n                let pageNumber = params.pageJoiner.replace(\"page_number\", `${page.num}`);\n                pageNumber = pageNumber.replace(\"total_number\", `${result.total}`);\n                result.text += `${page.text}\\n${pageNumber}\\n\\n`;\n            } else {\n                result.text += `${page.text}\\n\\n`;\n            }\n        }\n        return result;\n    }\n    async load() {\n        try {\n            if (this.doc === undefined) {\n                const loadingTask = pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.getDocument(this.options);\n                loadingTask.onProgress = (progress)=>{\n                    this.progress = progress;\n                };\n                this.doc = await loadingTask.promise;\n            }\n            return this.doc;\n        } catch (error) {\n            throw (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.getException)(error);\n        }\n    }\n    shouldParse(currentPage, totalPage, params) {\n        params.partial = params?.partial ?? [];\n        params.first = params?.first ?? 0;\n        params.last = params?.last ?? 0;\n        // parse specific pages\n        if (params.partial.length > 0) {\n            if (params.partial.includes(currentPage)) {\n                return true;\n            }\n            return false;\n        }\n        // parse pagest beetween first..last\n        if (params.first > 0 && params.last > 0) {\n            if (currentPage >= params.first && currentPage <= params.last) {\n                return true;\n            }\n            return false;\n        }\n        // parse first x page\n        if (params.first > 0) {\n            if (currentPage <= params.first) {\n                return true;\n            }\n            return false;\n        }\n        // parse last x page\n        if (params.last > 0) {\n            if (currentPage > totalPage - params.last) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    async getPageText(page, parseParams, total) {\n        const viewport = page.getViewport({\n            scale: 1\n        });\n        const params = (0,_ParseParameters_js__WEBPACK_IMPORTED_MODULE_5__.setDefaultParseParameters)(parseParams);\n        const textContent = await page.getTextContent({\n            includeMarkedContent: !!params.includeMarkedContent,\n            disableNormalization: !!params.disableNormalization\n        });\n        let links = new Map();\n        if (params.parseHyperlinks) {\n            links = await this.getHyperlinks(page, viewport);\n        }\n        const strBuf = [];\n        let lastX;\n        let lastY;\n        let lineHeight = 0;\n        for (const item of textContent.items){\n            if (!(\"str\" in item)) continue;\n            const tm = item.transform ?? item.transform;\n            const [x, y] = viewport.convertToViewportPoint(tm[4], tm[5]);\n            if (params.parseHyperlinks) {\n                const posArr = links.get(item.str) || [];\n                const hit = posArr.find((l)=>x >= l.rect.left && x <= l.rect.right && y >= l.rect.top && y <= l.rect.bottom);\n                if (hit) {\n                    item.str = `[${item.str}](${hit.url})`;\n                }\n            }\n            if (params.lineEnforce) {\n                if (lastY !== undefined && Math.abs(lastY - y) > params.lineThreshold) {\n                    const lastItem = strBuf.length ? strBuf[strBuf.length - 1] : undefined;\n                    const isCurrentItemHasNewLine = item.str.startsWith(\"\\n\") || item.str.trim() === \"\" && item.hasEOL;\n                    if (lastItem?.endsWith(\"\\n\") === false && !isCurrentItemHasNewLine) {\n                        const ydiff = Math.abs(lastY - y);\n                        if (ydiff - 1 > lineHeight) {\n                            strBuf.push(\"\\n\");\n                            lineHeight = 0;\n                        }\n                    }\n                }\n            }\n            if (params.cellSeparator) {\n                if (lastY !== undefined && Math.abs(lastY - y) < params.lineThreshold) {\n                    if (lastX !== undefined && Math.abs(lastX - x) > params.cellThreshold) {\n                        item.str = `${params.cellSeparator}${item.str}`;\n                    }\n                }\n            }\n            strBuf.push(item.str);\n            lastX = x + item.width;\n            lastY = y;\n            lineHeight = Math.max(lineHeight, item.height);\n            if (item.hasEOL) {\n                strBuf.push(\"\\n\");\n            }\n            if (item.hasEOL || item.str.endsWith(\"\\n\")) {\n                lineHeight = 0;\n            }\n        }\n        if (params.itemJoiner) {\n            return strBuf.join(params.itemJoiner);\n        }\n        return strBuf.join(\"\");\n    }\n    async getHyperlinks(page, viewport) {\n        const result = new Map();\n        // biome-ignore lint/suspicious/noExplicitAny: <unsupported underline type>\n        const annotations = await page.getAnnotations({\n            intent: \"display\"\n        }) || [];\n        for (const i of annotations){\n            if (i.subtype !== \"Link\") continue;\n            const url = i.url ?? i.unsafeUrl;\n            if (!url) continue;\n            const text = i.overlaidText;\n            if (!text) continue;\n            const rectVp = viewport.convertToViewportRectangle(i.rect);\n            const left = Math.min(rectVp[0], rectVp[2]) - 0.5;\n            const top = Math.min(rectVp[1], rectVp[3]) - 0.5;\n            const right = Math.max(rectVp[0], rectVp[2]) + 0.5;\n            const bottom = Math.max(rectVp[1], rectVp[3]) + 0.5;\n            const pos = {\n                rect: {\n                    left,\n                    top,\n                    right,\n                    bottom\n                },\n                url,\n                text,\n                used: false\n            };\n            const el = result.get(text);\n            if (el) {\n                el.push(pos);\n            } else {\n                result.set(text, [\n                    pos\n                ]);\n            }\n        }\n        return result;\n    }\n    /**\n     * Extract embedded images from requested pages.\n     *\n     * Behavior notes:\n     * - Pages are selected according to ParseParameters (partial, first, last).\n     * - Images smaller than `params.imageThreshold` (width OR height) are skipped.\n     * - Returned ImageResult contains per-page PageImages; each image entry includes:\n     *     - data: Uint8Array (present when params.imageBuffer === true)\n     *     - dataUrl: string (present when params.imageDataUrl === true)\n     *     - width, height, kind, name\n     * - Works in both Node.js (canvas.toBuffer) and browser (canvas.toDataURL) environments.\n     *\n     * @param params - ParseParameters controlling page selection, thresholds and output format.\n     * @returns Promise<ImageResult> with extracted images grouped by page.\n     */ async getImage(params = {}) {\n        const doc = await this.load();\n        const result = new _ImageResult_js__WEBPACK_IMPORTED_MODULE_3__.ImageResult(doc.numPages);\n        (0,_ParseParameters_js__WEBPACK_IMPORTED_MODULE_5__.setDefaultParseParameters)(params);\n        for(let i = 1; i <= result.total; i++){\n            if (this.shouldParse(i, result.total, params)) {\n                const page = await doc.getPage(i);\n                const ops = await page.getOperatorList();\n                const pageImages = {\n                    pageNumber: i,\n                    images: []\n                };\n                result.pages.push(pageImages);\n                for(let j = 0; j < ops.fnArray.length; j++){\n                    if (ops.fnArray[j] === pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.OPS.paintInlineImageXObject || ops.fnArray[j] === pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.OPS.paintImageXObject) {\n                        const name = ops.argsArray[j][0];\n                        const isCommon = page.commonObjs.has(name);\n                        const imgPromise = isCommon ? this.resolveEmbeddedImage(page.commonObjs, name) : this.resolveEmbeddedImage(page.objs, name);\n                        const { width, height, kind, data } = await imgPromise;\n                        if (params.imageThreshold) {\n                            if (params.imageThreshold >= width || params.imageThreshold >= height) {\n                                continue;\n                            }\n                        }\n                        // biome-ignore lint/suspicious/noExplicitAny: <underlying library does not contain valid typedefs>\n                        const canvasFactory = doc.canvasFactory;\n                        const canvasAndContext = canvasFactory.create(width, height);\n                        const context = canvasAndContext.context;\n                        let imgData = null;\n                        if (kind === pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.ImageKind.RGBA_32BPP) {\n                            imgData = context.createImageData(width, height);\n                            imgData.data.set(data);\n                        } else {\n                            imgData = context.createImageData(width, height);\n                            this.convertToRGBA({\n                                src: data,\n                                dest: new Uint32Array(imgData.data.buffer),\n                                width,\n                                height,\n                                kind\n                            });\n                        }\n                        context.putImageData(imgData, 0, 0);\n                        // Browser and Node.js compatibility\n                        let buffer = new Uint8Array();\n                        let dataUrl = \"\";\n                        if (typeof canvasAndContext.canvas.toBuffer === \"function\") {\n                            // Node.js environment (canvas package)\n                            // biome-ignore lint/suspicious/noExplicitAny: <underline lib not support>\n                            let nodeBuffer;\n                            if (params.imageBuffer) {\n                                nodeBuffer = canvasAndContext.canvas.toBuffer(\"image/png\");\n                                buffer = new Uint8Array(nodeBuffer);\n                            }\n                            if (params.imageDataUrl) {\n                                if (nodeBuffer) {\n                                    dataUrl = `data:image/png;base64,${nodeBuffer.toString(\"base64\")}`;\n                                } else {\n                                    nodeBuffer = canvasAndContext.canvas.toBuffer(\"image/png\");\n                                    buffer = new Uint8Array(nodeBuffer);\n                                    dataUrl = `data:image/png;base64,${nodeBuffer.toString(\"base64\")}`;\n                                }\n                            }\n                        } else {\n                            // Browser environment\n                            if (params.imageBuffer) {\n                                const imageData = canvasAndContext.context.getImageData(0, 0, canvasAndContext.canvas.width, canvasAndContext.canvas.height);\n                                buffer = new Uint8Array(imageData.data);\n                            }\n                            if (params.imageDataUrl) {\n                                dataUrl = canvasAndContext.canvas.toDataURL(\"image/png\");\n                            }\n                        }\n                        pageImages.images.push({\n                            data: buffer,\n                            dataUrl,\n                            name,\n                            height,\n                            width,\n                            kind\n                        });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    convertToRGBA({ src, dest, width, height, kind }) {\n        if (kind === pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.ImageKind.RGB_24BPP) {\n            // RGB 24-bit per pixel\n            for(let i = 0, j = 0; i < src.length; i += 3, j++){\n                const r = src[i];\n                const g = src[i + 1];\n                const b = src[i + 2];\n                dest[j] = 255 << 24 | b << 16 | g << 8 | r;\n            }\n        } else if (kind === pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.ImageKind.GRAYSCALE_1BPP) {\n            // Grayscale 1-bit per pixel\n            let pixelIndex = 0;\n            for(let i = 0; i < src.length; i++){\n                const byte = src[i];\n                for(let bit = 7; bit >= 0; bit--){\n                    if (pixelIndex >= width * height) break;\n                    const isWhite = (byte >> bit & 1) === 1;\n                    const gray = isWhite ? 255 : 0;\n                    dest[pixelIndex++] = 255 << 24 | gray << 16 | gray << 8 | gray;\n                }\n            }\n        } else if (kind === undefined || kind === null) {\n            // Unknown or undefined kind - try to infer from data length\n            const bytesPerPixel = src.length / (width * height);\n            if (Math.abs(bytesPerPixel - 3) < 0.1) {\n                // Likely RGB 24BPP\n                for(let i = 0, j = 0; i < src.length; i += 3, j++){\n                    const r = src[i];\n                    const g = src[i + 1];\n                    const b = src[i + 2];\n                    dest[j] = 255 << 24 | b << 16 | g << 8 | r;\n                }\n            } else if (Math.abs(bytesPerPixel - 4) < 0.1) {\n                // Likely RGBA 32BPP\n                for(let i = 0, j = 0; i < src.length; i += 4, j++){\n                    const r = src[i];\n                    const g = src[i + 1];\n                    const b = src[i + 2];\n                    const a = src[i + 3];\n                    dest[j] = a << 24 | b << 16 | g << 8 | r;\n                }\n            } else if (Math.abs(bytesPerPixel - 1) < 0.1) {\n                // Likely grayscale 8BPP\n                for(let i = 0; i < src.length; i++){\n                    const gray = src[i];\n                    dest[i] = 255 << 24 | gray << 16 | gray << 8 | gray;\n                }\n            } else {\n                throw new Error(`convertToRGBA: Cannot infer image format. kind: ${kind}, bytesPerPixel: ${bytesPerPixel}, width: ${width}, height: ${height}, dataLength: ${src.length}`);\n            }\n        } else {\n            throw new Error(`convertToRGBA: Unsupported image kind: ${kind}. Available kinds: GRAYSCALE_1BPP=${pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.ImageKind.GRAYSCALE_1BPP}, RGB_24BPP=${pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.ImageKind.RGB_24BPP}, RGBA_32BPP=${pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.ImageKind.RGBA_32BPP}`);\n        }\n    }\n    resolveEmbeddedImage(pdfObjects, name) {\n        return new Promise((resolve, reject)=>{\n            // biome-ignore lint/suspicious/noExplicitAny: <underlying library does not contain valid typedefs>\n            pdfObjects.get(name, (imgData)=>{\n                if (imgData) {\n                    // Check different possible data sources\n                    let dataBuff;\n                    if (imgData.data instanceof Uint8Array) {\n                        dataBuff = imgData.data;\n                    } else if (imgData.data instanceof Uint8ClampedArray) {\n                        dataBuff = new Uint8Array(imgData.data);\n                    } else if (imgData.data?.buffer) {\n                        // Typed array with buffer\n                        dataBuff = new Uint8Array(imgData.data.buffer);\n                    } else if (imgData.bitmap) {\n                        // Some browsers might use bitmap\n                        // biome-ignore lint/suspicious/noExplicitAny: <underlying library does not contain valid typedefs>\n                        const canvasFactory = this.doc.canvasFactory;\n                        const canvasAndContext = canvasFactory.create(imgData.bitmap.width, imgData.bitmap.height);\n                        canvasAndContext.context.drawImage(imgData.bitmap, 0, 0);\n                        const imageData = canvasAndContext.context.getImageData(0, 0, imgData.bitmap.width, imgData.bitmap.height);\n                        dataBuff = new Uint8Array(imageData.data.buffer);\n                    } else if (ArrayBuffer.isView(imgData.data)) {\n                        // Generic typed array\n                        dataBuff = new Uint8Array(imgData.data.buffer, imgData.data.byteOffset, imgData.data.byteLength);\n                    }\n                    if (!dataBuff) {\n                        reject(new Error(`Image object ${name}: data field is empty or invalid. Available fields: ${Object.keys(imgData).join(\", \")}`));\n                        return;\n                    }\n                    if (dataBuff.length === 0) {\n                        reject(new Error(`Image object ${name}: data buffer is empty (length: 0)`));\n                        return;\n                    }\n                    resolve({\n                        width: imgData.width,\n                        height: imgData.height,\n                        kind: imgData.kind,\n                        data: dataBuff\n                    });\n                } else {\n                    reject(new Error(`Image object ${name} not found`));\n                }\n            });\n        });\n    }\n    /**\n     * Render pages to raster screenshots.\n     *\n     * Behavior notes:\n     * - Pages are selected according to ParseParameters (partial, first, last).\n     * - Use params.scale for zoom; if params.desiredWidth is specified it takes precedence.\n     * - Each ScreenshotResult page contains:\n     *     - data: Uint8Array (when params.imageBuffer === true)\n     *     - dataUrl: string (when params.imageDataUrl === true)\n     *     - pageNumber, width, height, scale\n     * - Works in both Node.js (canvas.toBuffer) and browser (canvas.toDataURL) environments.\n     *\n     * @param parseParams - ParseParameters controlling page selection and render options.\n     * @returns Promise<ScreenshotResult> with rendered page images.\n     */ async getScreenshot(parseParams = {}) {\n        //const base = new URL('../../node_modules/pdfjs-dist/', import.meta.url);\n        //this.options.cMapUrl = new URL('cmaps/', base).href;\n        //this.options.cMapPacked = true;\n        //this.options.standardFontDataUrl = new URL('legacy/build/standard_fonts/', base).href;\n        const params = (0,_ParseParameters_js__WEBPACK_IMPORTED_MODULE_5__.setDefaultParseParameters)(parseParams);\n        const doc = await this.load();\n        const result = new _ScreenshotResult_js__WEBPACK_IMPORTED_MODULE_7__.ScreenshotResult(doc.numPages);\n        if (this.doc === undefined) {\n            throw new Error(\"PDF document not loaded\");\n        }\n        for(let i = 1; i <= result.total; i++){\n            if (this.shouldParse(i, result.total, params)) {\n                const page = await this.doc.getPage(i);\n                let viewport = page.getViewport({\n                    scale: params.scale\n                });\n                if (params.desiredWidth) {\n                    viewport = page.getViewport({\n                        scale: 1\n                    });\n                    // desiredWidth\n                    const scale = params.desiredWidth / viewport.width;\n                    viewport = page.getViewport({\n                        scale: scale\n                    });\n                }\n                // biome-ignore lint/suspicious/noExplicitAny: <underlying library does not contain valid typedefs>\n                const canvasFactory = this.doc.canvasFactory;\n                const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n                const renderContext = {\n                    canvasContext: canvasAndContext.context,\n                    viewport,\n                    canvas: canvasAndContext.canvas\n                };\n                const renderTask = page.render(renderContext);\n                await renderTask.promise;\n                // Convert the canvas to an image buffer.\n                let data = new Uint8Array();\n                let dataUrl = \"\";\n                if (typeof canvasAndContext.canvas.toBuffer === \"function\") {\n                    // Node.js environment (canvas package)\n                    // biome-ignore lint/suspicious/noExplicitAny: <underline lib not support>\n                    let nodeBuffer;\n                    if (params.imageBuffer) {\n                        nodeBuffer = canvasAndContext.canvas.toBuffer(\"image/png\");\n                        data = new Uint8Array(nodeBuffer);\n                    }\n                    if (params.imageDataUrl) {\n                        if (nodeBuffer) {\n                            dataUrl = `data:image/png;base64,${nodeBuffer.toString(\"base64\")}`;\n                        } else {\n                            nodeBuffer = canvasAndContext.canvas.toBuffer(\"image/png\");\n                            data = new Uint8Array(nodeBuffer);\n                            dataUrl = `data:image/png;base64,${nodeBuffer.toString(\"base64\")}`;\n                        }\n                    }\n                } else {\n                    // Browser environment\n                    if (params.imageBuffer) {\n                        const imageData = canvasAndContext.context.getImageData(0, 0, canvasAndContext.canvas.width, canvasAndContext.canvas.height);\n                        data = new Uint8Array(imageData.data);\n                    }\n                    if (params.imageDataUrl) {\n                        dataUrl = canvasAndContext.canvas.toDataURL(\"image/png\");\n                    //const base64 = dataUrl.split(',')[1];\n                    //const binaryString = atob(base64);\n                    //data = new Uint8Array(binaryString.length);\n                    //for (let i = 0; i < binaryString.length; i++) {\n                    //\tdata[i] = binaryString.charCodeAt(i);\n                    //}\n                    }\n                }\n                result.pages.push({\n                    data,\n                    dataUrl,\n                    pageNumber: i,\n                    width: viewport.width,\n                    height: viewport.height,\n                    scale: viewport.scale\n                });\n                page.cleanup();\n            }\n        }\n        return result;\n    }\n    /**\n     * Detect and extract tables from pages by analysing vector drawing operators, then populate cells with text.\n     *\n     * Behavior notes:\n     * - Scans operator lists for rectangles/lines that form table grids (uses PathGeometry and LineStore).\n     * - Normalizes detected geometry and matches positioned text to table cells.\n     * - Honors ParseParameters for page selection.\n     *\n     * @param params - ParseParameters controlling which pages to analyse (partial/first/last).\n     * @returns Promise<TableResult> containing discovered tables per page.\n     */ async getTable(params = {}) {\n        const doc = await this.load();\n        const result = new _TableResult_js__WEBPACK_IMPORTED_MODULE_8__.TableResult(doc.numPages);\n        if (this.doc === undefined) {\n            throw new Error(\"PDF document not loaded\");\n        }\n        for(let i = 1; i <= result.total; i++){\n            if (this.shouldParse(i, result.total, params)) {\n                const page = await this.doc.getPage(i);\n                //const viewport = page.getViewport({ scale: 1 });\n                //viewport.convertToViewportPoint(0, 0);\n                const store = await this.getPageTables(page);\n                //const store = await this.getPageGeometry(page);\n                store.normalize();\n                const tableDataArr = store.getTableData();\n                await this.fillPageTables(page, tableDataArr);\n                const pageTableResult = {\n                    num: i,\n                    tables: []\n                };\n                for (const table of tableDataArr){\n                    //if (table.cellCount < 3) continue\n                    pageTableResult.tables.push(table.toArray());\n                //const pageTableResult: PageTableResult = { num: i, tables: table.toArray() };\n                //pageTableResult.tables.push(table.toData())\n                }\n                result.pages.push(pageTableResult);\n                page.cleanup();\n            }\n        }\n        // for (const table of Table.AllTables) {\n        //     if (table.cellCount < 3) continue\n        //     const str = table.toString()\n        //     console.log(str)\n        // }\n        return result;\n    }\n    getPathGeometry(mm) {\n        const width = mm[2] - mm[0];\n        const height = mm[3] - mm[1];\n        if (mm[0] === Infinity) {\n            return _PathGeometry_js__WEBPACK_IMPORTED_MODULE_6__.PathGeometry.undefined;\n        }\n        if (width > 5 && height > 5) {\n            return _PathGeometry_js__WEBPACK_IMPORTED_MODULE_6__.PathGeometry.rectangle;\n        } else if (width > 5 && height === 0) {\n            return _PathGeometry_js__WEBPACK_IMPORTED_MODULE_6__.PathGeometry.hline;\n        } else if (width === 0 && height > 5) {\n            return _PathGeometry_js__WEBPACK_IMPORTED_MODULE_6__.PathGeometry.vline;\n        }\n        return _PathGeometry_js__WEBPACK_IMPORTED_MODULE_6__.PathGeometry.undefined;\n    }\n    async getPageTables(page) {\n        const lineStore = new _geometry_index_js__WEBPACK_IMPORTED_MODULE_2__.LineStore();\n        const viewport = page.getViewport({\n            scale: 1\n        });\n        let transformMatrix = [\n            1,\n            0,\n            0,\n            1,\n            0,\n            0\n        ];\n        const transformStack = [];\n        const opList = await page.getOperatorList();\n        for(let i = 0; i < opList.fnArray.length; i++){\n            const fn = opList.fnArray[i];\n            const args = opList.argsArray[i];\n            const op = args?.[0] ?? 0;\n            const mm = args?.[2] ?? [\n                Infinity,\n                Infinity,\n                -Infinity,\n                -Infinity\n            ];\n            //const minMax = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);\n            if (fn === pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.OPS.constructPath) {\n                if (op === pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.OPS.fill) {\n                //debugger;\n                }\n                if (op !== pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.OPS.stroke) {\n                    continue;\n                }\n                const pg = this.getPathGeometry(mm);\n                if (pg === _PathGeometry_js__WEBPACK_IMPORTED_MODULE_6__.PathGeometry.rectangle) {\n                    const rect = new _geometry_index_js__WEBPACK_IMPORTED_MODULE_2__.Rectangle(new _geometry_index_js__WEBPACK_IMPORTED_MODULE_2__.Point(mm[0], mm[1]), mm[2] - mm[0], mm[3] - mm[1]);\n                    rect.transform(transformMatrix);\n                    rect.transform(viewport.transform);\n                    lineStore.addRectangle(rect);\n                } else if (pg === _PathGeometry_js__WEBPACK_IMPORTED_MODULE_6__.PathGeometry.hline || pg === _PathGeometry_js__WEBPACK_IMPORTED_MODULE_6__.PathGeometry.vline) {\n                    const from = new _geometry_index_js__WEBPACK_IMPORTED_MODULE_2__.Point(mm[0], mm[1]);\n                    const to = new _geometry_index_js__WEBPACK_IMPORTED_MODULE_2__.Point(mm[2], mm[3]);\n                    const line = new _geometry_index_js__WEBPACK_IMPORTED_MODULE_2__.Line(from, to);\n                    line.transform(transformMatrix);\n                    line.transform(viewport.transform);\n                    lineStore.add(line);\n                } else {\n                //debugger;\n                }\n            // if (op === pdfjs.OPS.rectangle) {\n            // \tdebugger;\n            // } else if (op === pdfjs.OPS.moveTo) {\n            // \tdebugger;\n            // } else if (op === pdfjs.OPS.lineTo) {\n            // \tdebugger;\n            // } else if (op === pdfjs.OPS.endPath) {\n            // \tconst combinedMatrix = pdfjs.Util.transform(viewport.transform, transformMatrix);\n            // \t// while (args[1].length) {\n            // \t// \tconst drawOp = args[1].shift();\n            // \t// \tdebugger;\n            // \t// }\n            // } else {\n            // \t//debugger;\n            // }\n            } else if (fn === pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.OPS.setLineWidth) {\n            //debugger;\n            } else if (fn === pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.OPS.save) {\n                transformStack.push(transformMatrix);\n            } else if (fn === pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.OPS.restore) {\n                const restoredMatrix = transformStack.pop();\n                if (restoredMatrix) {\n                    transformMatrix = restoredMatrix;\n                }\n            } else if (fn === pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.OPS.transform) {\n                //transformMatrix = this.transform_fn(transformMatrix, args);\n                transformMatrix = pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.Util.transform(transformMatrix, args);\n            }\n        }\n        return lineStore;\n    }\n    // private async getPageGeometry(page: PDFPageProxy): Promise<LineStore> {\n    // \tconst lineStore: LineStore = new LineStore();\n    // \tconst opList = await page.getOperatorList();\n    // \tconst viewport = page.getViewport({ scale: 1 });\n    // \tlet transformMatrix = [1, 0, 0, 1, 0, 0];\n    // \tconst transformStack: Array<Array<number>> = [];\n    // \tlet current_x: number = 0;\n    // \tlet current_y: number = 0;\n    // \tfor (let j = 0; j < opList.fnArray.length; j++) {\n    // \t\tconst fn = opList.fnArray[j];\n    // \t\tconst args = opList.argsArray[j];\n    // \t\tif (fn === pdfjs.OPS.constructPath) {\n    // \t\t\twhile (args[0].length) {\n    // \t\t\t\tconst op = args[0].shift();\n    // \t\t\t\tconst combinedMatrix = pdfjs.Util.transform(viewport.transform, transformMatrix);\n    // \t\t\t\tif (op === pdfjs.OPS.rectangle) {\n    // \t\t\t\t\tconst x = args[1].shift();\n    // \t\t\t\t\tconst y = args[1].shift();\n    // \t\t\t\t\tconst width = args[1].shift();\n    // \t\t\t\t\tconst height = args[1].shift();\n    // \t\t\t\t\tif (Math.min(width, height) <= 2) {\n    // \t\t\t\t\t\t// TODO remove\n    // \t\t\t\t\t\tdebugger;\n    // \t\t\t\t\t}\n    // \t\t\t\t\tconst rect = new Rectangle(new Point(x, y), width, height);\n    // \t\t\t\t\trect.transform(combinedMatrix);\n    // \t\t\t\t\t//rect.transform(viewport.transform);\n    // \t\t\t\t\tlineStore.addRectangle(rect);\n    // \t\t\t\t} else if (op === pdfjs.OPS.moveTo) {\n    // \t\t\t\t\tcurrent_x = args[1].shift();\n    // \t\t\t\t\tcurrent_y = args[1].shift();\n    // \t\t\t\t} else if (op === pdfjs.OPS.lineTo) {\n    // \t\t\t\t\tconst x = args[1].shift();\n    // \t\t\t\t\tconst y = args[1].shift();\n    // \t\t\t\t\t//default trasform\n    // \t\t\t\t\tconst from = new Point(current_x, current_y);\n    // \t\t\t\t\tconst to = new Point(x, y);\n    // \t\t\t\t\tconst line = new Line(from, to);\n    // \t\t\t\t\tline.transform(combinedMatrix);\n    // \t\t\t\t\t//line.transform(viewport.transform);\n    // \t\t\t\t\t// // viewport transform\n    // \t\t\t\t\t// const _from = viewport.convertToViewportPoint(line.from.x, line.from.y)\n    // \t\t\t\t\t// const _to = viewport.convertToViewportPoint(line.to.x, line.to.y)\n    // \t\t\t\t\t//\n    // \t\t\t\t\t// const transformedLine = new Line(new Point(_from[0], _from[1]), new Point(_to[0], _to[1]))\n    // \t\t\t\t\tlineStore.add(line);\n    // \t\t\t\t\tcurrent_x = x;\n    // \t\t\t\t\tcurrent_y = y;\n    // \t\t\t\t}\n    // \t\t\t}\n    // \t\t} else if (fn === pdfjs.OPS.save) {\n    // \t\t\ttransformStack.push(transformMatrix);\n    // \t\t} else if (fn === pdfjs.OPS.restore) {\n    // \t\t\tconst restoredMatrix = transformStack.pop();\n    // \t\t\tif (restoredMatrix) {\n    // \t\t\t\ttransformMatrix = restoredMatrix;\n    // \t\t\t}\n    // \t\t} else if (fn === pdfjs.OPS.transform) {\n    // \t\t\t//transformMatrix = this.transform_fn(transformMatrix, args);\n    // \t\t\ttransformMatrix = pdfjs.Util.transform(transformMatrix, args);\n    // \t\t}\n    // \t}\n    // \treturn lineStore;\n    // }\n    async fillPageTables(page, pageTables) {\n        //const resultTable: Array<Table> = []\n        const viewport = page.getViewport({\n            scale: 1\n        });\n        // for (let i = 0; i < pageTables.length; i++) {\n        //     const currentTable = pageTables[i]\n        // }\n        //pageTables = pageTables.filter((table) => table.cellCount > 3)\n        const textContent = await page.getTextContent({\n            includeMarkedContent: false,\n            disableNormalization: false\n        });\n        for (const textItem of textContent.items){\n            if (!(\"str\" in textItem)) continue;\n            const tx = pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.Util.transform(pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_0__.Util.transform(viewport.transform, textItem.transform), [\n                1,\n                0,\n                0,\n                -1,\n                0,\n                0\n            ]);\n            //const resXY = viewport.convertToViewportPoint(tx[4], tx[5]);\n            // textItem.transform = pdfjs.Util.transform(viewport.transform, textItem.transform)\n            // textItem.transform[5] = viewport.height - textItem.transform[5] - textItem.height\n            for (const pageTable of pageTables){\n                const cell = pageTable.findCell(tx[4], tx[5]);\n                if (cell) {\n                    cell.text.push(textItem.str);\n                    if (textItem.hasEOL) {\n                        cell.text.push(\"\\n\");\n                    }\n                    break;\n                }\n            }\n        //Table.tryAddText(pageTables, textItem)\n        }\n    }\n} //PDFParse.setWorker();\n //# sourceMappingURL=PDFParse.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9QREZQYXJzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF5RDtBQUNYO0FBQzBCO0FBQ3pCO0FBQ0Y7QUFDb0I7QUFDaEI7QUFDUTtBQUNWO0FBQ0Y7QUFDN0M7OztDQUdDLEdBQ00sTUFBTWE7SUFJVDs7OztLQUlDLEdBQ0RDLFlBQVlDLE9BQU8sQ0FBRTthQU5yQkMsV0FBVztZQUFFQyxRQUFRLENBQUM7WUFBR0MsT0FBTztRQUFFO1FBTzlCLElBQUlILFFBQVFJLFNBQVMsS0FBS0MsV0FBVztZQUNqQ0wsUUFBUUksU0FBUyxHQUFHbkIsMkVBQW9CLENBQUNzQixNQUFNO1FBQ25EO1FBQ0EsSUFBSSxPQUFPQyxXQUFXLGVBQWVSLFFBQVFTLElBQUksWUFBWUQsUUFBUTtZQUNqRVIsUUFBUVMsSUFBSSxHQUFHLElBQUlDLFdBQVdWLFFBQVFTLElBQUk7UUFDOUM7UUFDQSxJQUFJLENBQUNULE9BQU8sR0FBR0E7SUFDbkI7SUFDQSxNQUFNVyxVQUFVO1FBQ1osSUFBSSxJQUFJLENBQUNDLEdBQUcsRUFBRTtZQUNWLE1BQU0sSUFBSSxDQUFDQSxHQUFHLENBQUNELE9BQU87WUFDdEIsSUFBSSxDQUFDQyxHQUFHLEdBQUdQO1FBQ2Y7SUFDSjtJQUNBLCtFQUErRTtJQUMvRSxXQUFXUSxXQUFXO1FBQ2xCLE1BQU1BLFdBQVcsT0FBT0MsWUFBWSxZQUNoQyxDQUFDLEVBQUVBLFFBQVEsQ0FBQyxLQUFLLHNCQUNqQixDQUFDQSxRQUFRQyxRQUFRLENBQUNDLEVBQUUsSUFDcEIsQ0FBRUYsQ0FBQUEsUUFBUUMsUUFBUSxDQUFDRSxRQUFRLElBQ3ZCLE9BQU9ILFFBQVFJLElBQUksS0FBSyxlQUN4QkosUUFBUUksSUFBSSxLQUFLLFNBQVE7UUFDakMsT0FBT0w7SUFDWDtJQUNBLE9BQU9NLFVBQVVDLFNBQVMsRUFBRTtRQUN4QixJQUFJLE9BQU9DLFdBQVdwQyxLQUFL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S2hNLElBQUksQ0FBQ2QsSUFBSSxDQUFDMk0sU0FBU3JKLEdBQUc7b0JBQzNCLElBQUlxSixTQUFTcEksTUFBTSxFQUFFO3dCQUNqQnVJLEtBQUtoTSxJQUFJLENBQUNkLElBQUksQ0FBQztvQkFDbkI7b0JBQ0E7Z0JBQ0o7WUFDSjtRQUNBLHdDQUF3QztRQUM1QztJQUNKO0FBQ0osRUFDQSx1QkFBdUI7Q0FDdkIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktY2FyZWVyLWFzc2lzdGFudC8uL25vZGVfbW9kdWxlcy9wZGYtcGFyc2UvZGlzdC9wZGYtcGFyc2UvZXNtL1BERlBhcnNlLmpzP2E2NTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcGRmanMgZnJvbSAncGRmanMtZGlzdC9sZWdhY3kvYnVpbGQvcGRmLm1qcyc7XG5pbXBvcnQgeyBnZXRFeGNlcHRpb24gfSBmcm9tICcuL0V4Y2VwdGlvbi5qcyc7XG5pbXBvcnQgeyBMaW5lLCBMaW5lU3RvcmUsIFBvaW50LCBSZWN0YW5nbGUgfSBmcm9tICcuL2dlb21ldHJ5L2luZGV4LmpzJztcbmltcG9ydCB7IEltYWdlUmVzdWx0IH0gZnJvbSAnLi9JbWFnZVJlc3VsdC5qcyc7XG5pbXBvcnQgeyBJbmZvUmVzdWx0IH0gZnJvbSAnLi9JbmZvUmVzdWx0LmpzJztcbmltcG9ydCB7IHNldERlZmF1bHRQYXJzZVBhcmFtZXRlcnMgfSBmcm9tICcuL1BhcnNlUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgeyBQYXRoR2VvbWV0cnkgfSBmcm9tICcuL1BhdGhHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBTY3JlZW5zaG90UmVzdWx0IH0gZnJvbSAnLi9TY3JlZW5zaG90UmVzdWx0LmpzJztcbmltcG9ydCB7IFRhYmxlUmVzdWx0IH0gZnJvbSAnLi9UYWJsZVJlc3VsdC5qcyc7XG5pbXBvcnQgeyBUZXh0UmVzdWx0IH0gZnJvbSAnLi9UZXh0UmVzdWx0LmpzJztcbi8qKlxuICogQHB1YmxpY1xuICogTG9hZHMgUERGIGRvY3VtZW50cyBhbmQgZXhwb3NlcyBoZWxwZXJzIGZvciB0ZXh0LCBpbWFnZSwgdGFibGUsIG1ldGFkYXRhLCBhbmQgc2NyZWVuc2hvdCBleHRyYWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgUERGUGFyc2Uge1xuICAgIG9wdGlvbnM7XG4gICAgZG9jO1xuICAgIHByb2dyZXNzID0geyBsb2FkZWQ6IC0xLCB0b3RhbDogMCB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBwYXJzZXIgd2l0aCBgTG9hZFBhcmFtZXRlcnNgLlxuICAgICAqIENvbnZlcnRzIE5vZGUuanMgYEJ1ZmZlcmAgZGF0YSB0byBgVWludDhBcnJheWAgYXV0b21hdGljYWxseSBhbmQgZW5zdXJlcyBhIGRlZmF1bHQgdmVyYm9zaXR5IGxldmVsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gSW5pdGlhbGl6YXRpb24gcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnZlcmJvc2l0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLnZlcmJvc2l0eSA9IHBkZmpzLlZlcmJvc2l0eUxldmVsLkVSUk9SUztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0aW9ucy5kYXRhIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBuZXcgVWludDhBcnJheShvcHRpb25zLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmRvYykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kb2MuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5kb2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYmlvbWUtaWdub3JlLXN0YXJ0IGxpbnQvc3VzcGljaW91cy9ub0V4cGxpY2l0QW55OiB1bnN1cHBvcnRlZCB1bmRlcmxpbmUgdHlwZVxuICAgIHN0YXRpYyBnZXQgaXNOb2RlSlMoKSB7XG4gICAgICAgIGNvbnN0IGlzTm9kZUpTID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBgJHtwcm9jZXNzfWAgPT09ICdbb2JqZWN0IHByb2Nlc3NdJyAmJlxuICAgICAgICAgICAgIXByb2Nlc3MudmVyc2lvbnMubncgJiZcbiAgICAgICAgICAgICEocHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBwcm9jZXNzLnR5cGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy50eXBlICE9PSAnYnJvd3NlcicpO1xuICAgICAgICByZXR1cm4gaXNOb2RlSlM7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRXb3JrZXIod29ya2VyU3JjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5wZGZqcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMucGRmanMgPSBwZGZqcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGRmanM/Lkdsb2JhbFdvcmtlck9wdGlvbnMgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGlmICh3b3JrZXJTcmMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGRmanMuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgPSB3b3JrZXJTcmM7XG4gICAgICAgICAgICByZXR1cm4gcGRmanMuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgKCFQREZQYXJzZS5pc05vZGVKUykge1xuICAgICAgICAvLyBcdHBkZmpzLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjID1cbiAgICAgICAgLy8gXHRcdCdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL3BkZi1wYXJzZUBsYXRlc3QvZGlzdC9icm93c2VyL3BkZi53b3JrZXIubWluLm1qcyc7XG4gICAgICAgIC8vIFx0cmV0dXJuIHBkZmpzLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBwZGZqcy5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYztcbiAgICB9XG4gICAgLy8gYmlvbWUtaWdub3JlLWVuZCBsaW50L3N1c3BpY2lvdXMvbm9FeHBsaWNpdEFueTogdW5zdXBwb3J0ZWQgdW5kZXJsaW5lIHR5cGVcbiAgICAvKipcbiAgICAgKiBMb2FkIGRvY3VtZW50LWxldmVsIG1ldGFkYXRhIChpbmZvLCBvdXRsaW5lLCBwZXJtaXNzaW9ucywgcGFnZSBsYWJlbHMpIGFuZCBvcHRpb25hbGx5IGdhdGhlciBwZXItcGFnZSBsaW5rIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFBhcnNlIG9wdGlvbnM7IHNldCBgcGFyc2VQYWdlSW5mb2AgdG8gY29sbGVjdCBwZXItcGFnZSBtZXRhZGF0YSBkZXNjcmliZWQgaW4gYFBhcnNlUGFyYW1ldGVyc2AuXG4gICAgICogQHJldHVybnMgQWdncmVnYXRlZCBkb2N1bWVudCBtZXRhZGF0YSBpbiBhbiBgSW5mb1Jlc3VsdGAuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SW5mbyhwYXJhbXMgPSB7fSkge1xuICAgICAgICBjb25zdCBkb2MgPSBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEluZm9SZXN1bHQoZG9jLm51bVBhZ2VzKTtcbiAgICAgICAgY29uc3QgeyBpbmZvLCBtZXRhZGF0YSB9ID0gYXdhaXQgZG9jLmdldE1ldGFkYXRhKCk7XG4gICAgICAgIHJlc3VsdC5pbmZvID0gaW5mbztcbiAgICAgICAgcmVzdWx0Lm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHJlc3VsdC5maW5nZXJwcmludHMgPSBkb2MuZmluZ2VycHJpbnRzO1xuICAgICAgICByZXN1bHQub3V0bGluZSA9IGF3YWl0IGRvYy5nZXRPdXRsaW5lKCk7XG4gICAgICAgIHJlc3VsdC5wZXJtaXNzaW9uID0gYXdhaXQgZG9jLmdldFBlcm1pc3Npb25zKCk7XG4gICAgICAgIGNvbnN0IHBhZ2VMYWJlbHMgPSBhd2FpdCBkb2MuZ2V0UGFnZUxhYmVscygpO1xuICAgICAgICBpZiAocGFyYW1zLnBhcnNlUGFnZUluZm8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHJlc3VsdC50b3RhbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkUGFyc2UoaSwgcmVzdWx0LnRvdGFsLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBkb2MuZ2V0UGFnZShpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZUxpbmtSZXN1bHQgPSBhd2FpdCB0aGlzLmdldFBhZ2VMaW5rcyhwYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcGFnZUxpbmtSZXN1bHQucGFnZUxhYmVsID0gcGFnZUxhYmVscz8uW3BhZ2UucGFnZU51bWJlcl07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wYWdlcy5wdXNoKHBhZ2VMaW5rUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGdldFBhZ2VMaW5rcyhwYWdlKSB7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gcGFnZS5nZXRWaWV3cG9ydCh7IHNjYWxlOiAxIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyOiBwYWdlLnBhZ2VOdW1iZXIsXG4gICAgICAgICAgICBsaW5rczogW10sXG4gICAgICAgICAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0V4cGxpY2l0QW55OiA8dW5zdXBwb3J0ZWQgdW5kZXJsaW5lIHR5cGU+XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25zID0gKGF3YWl0IHBhZ2UuZ2V0QW5ub3RhdGlvbnMoeyBpbnRlbnQ6ICdkaXNwbGF5JyB9KSkgfHwgW107XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiBhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgaWYgKGkuc3VidHlwZSAhPT0gJ0xpbmsnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gaS51cmwgPz8gaS51bnNhZmVVcmw7XG4gICAgICAgICAgICBpZiAoIXVybClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBpLm92ZXJsYWlkVGV4dCB8fCAnJztcbiAgICAgICAgICAgIHJlc3VsdC5saW5rcy5wdXNoKHsgdXJsLCB0ZXh0IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgcGxhaW4gdGV4dCBmb3IgZWFjaCByZXF1ZXN0ZWQgcGFnZSwgb3B0aW9uYWxseSBlbnJpY2hpbmcgaHlwZXJsaW5rcyBhbmQgZW5mb3JjaW5nIGxpbmUgb3IgY2VsbCBzZXBhcmF0b3JzLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJzZSBvcHRpb25zIGNvbnRyb2xsaW5nIHBhZ2luYXRpb24sIGxpbmsgaGFuZGxpbmcsIGFuZCBsaW5lL2NlbGwgdGhyZXNob2xkcy5cbiAgICAgKiBAcmV0dXJucyBBIGBUZXh0UmVzdWx0YCBjb250YWluaW5nIHBhZ2Utd2lzZSB0ZXh0IGFuZCBhIGNvbmNhdGVuYXRlZCBkb2N1bWVudCBzdHJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGV4dChwYXJhbXMgPSB7fSkge1xuICAgICAgICBjb25zdCBkb2MgPSBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFRleHRSZXN1bHQoZG9jLm51bVBhZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcmVzdWx0LnRvdGFsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFBhcnNlKGksIHJlc3VsdC50b3RhbCwgcGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBkb2MuZ2V0UGFnZShpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy5nZXRQYWdlVGV4dChwYWdlLCBwYXJhbXMsIHJlc3VsdC50b3RhbCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICBudW06IGksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcGFnZS5jbGVhbnVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYWdlIG9mIHJlc3VsdC5wYWdlcykge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5wYWdlSm9pbmVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhZ2VOdW1iZXIgPSBwYXJhbXMucGFnZUpvaW5lci5yZXBsYWNlKCdwYWdlX251bWJlcicsIGAke3BhZ2UubnVtfWApO1xuICAgICAgICAgICAgICAgIHBhZ2VOdW1iZXIgPSBwYWdlTnVtYmVyLnJlcGxhY2UoJ3RvdGFsX251bWJlcicsIGAke3Jlc3VsdC50b3RhbH1gKTtcbiAgICAgICAgICAgICAgICByZXN1bHQudGV4dCArPSBgJHtwYWdlLnRleHR9XFxuJHtwYWdlTnVtYmVyfVxcblxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGV4dCArPSBgJHtwYWdlLnRleHR9XFxuXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBsb2FkKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2FkaW5nVGFzayA9IHBkZmpzLmdldERvY3VtZW50KHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcyA9IChwcm9ncmVzcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvYyA9IGF3YWl0IGxvYWRpbmdUYXNrLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2M7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBnZXRFeGNlcHRpb24oZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZFBhcnNlKGN1cnJlbnRQYWdlLCB0b3RhbFBhZ2UsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMucGFydGlhbCA9IHBhcmFtcz8ucGFydGlhbCA/PyBbXTtcbiAgICAgICAgcGFyYW1zLmZpcnN0ID0gcGFyYW1zPy5maXJzdCA/PyAwO1xuICAgICAgICBwYXJhbXMubGFzdCA9IHBhcmFtcz8ubGFzdCA/PyAwO1xuICAgICAgICAvLyBwYXJzZSBzcGVjaWZpYyBwYWdlc1xuICAgICAgICBpZiAocGFyYW1zLnBhcnRpYWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5wYXJ0aWFsLmluY2x1ZGVzKGN1cnJlbnRQYWdlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhcnNlIHBhZ2VzdCBiZWV0d2VlbiBmaXJzdC4ubGFzdFxuICAgICAgICBpZiAocGFyYW1zLmZpcnN0ID4gMCAmJiBwYXJhbXMubGFzdCA+IDApIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFnZSA+PSBwYXJhbXMuZmlyc3QgJiYgY3VycmVudFBhZ2UgPD0gcGFyYW1zLmxhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJzZSBmaXJzdCB4IHBhZ2VcbiAgICAgICAgaWYgKHBhcmFtcy5maXJzdCA+IDApIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFnZSA8PSBwYXJhbXMuZmlyc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJzZSBsYXN0IHggcGFnZVxuICAgICAgICBpZiAocGFyYW1zLmxhc3QgPiAwKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhZ2UgPiB0b3RhbFBhZ2UgLSBwYXJhbXMubGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBnZXRQYWdlVGV4dChwYWdlLCBwYXJzZVBhcmFtcywgdG90YWwpIHtcbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IDEgfSk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHNldERlZmF1bHRQYXJzZVBhcmFtZXRlcnMocGFyc2VQYXJhbXMpO1xuICAgICAgICBjb25zdCB0ZXh0Q29udGVudCA9IGF3YWl0IHBhZ2UuZ2V0VGV4dENvbnRlbnQoe1xuICAgICAgICAgICAgaW5jbHVkZU1hcmtlZENvbnRlbnQ6ICEhcGFyYW1zLmluY2x1ZGVNYXJrZWRDb250ZW50LFxuICAgICAgICAgICAgZGlzYWJsZU5vcm1hbGl6YXRpb246ICEhcGFyYW1zLmRpc2FibGVOb3JtYWxpemF0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxpbmtzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAocGFyYW1zLnBhcnNlSHlwZXJsaW5rcykge1xuICAgICAgICAgICAgbGlua3MgPSBhd2FpdCB0aGlzLmdldEh5cGVybGlua3MocGFnZSwgdmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuICAgICAgICBsZXQgbGFzdFg7XG4gICAgICAgIGxldCBsYXN0WTtcbiAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGV4dENvbnRlbnQuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghKCdzdHInIGluIGl0ZW0pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgdG0gPSBpdGVtLnRyYW5zZm9ybSA/PyBpdGVtLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IHZpZXdwb3J0LmNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQodG1bNF0sIHRtWzVdKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMucGFyc2VIeXBlcmxpbmtzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zQXJyID0gbGlua3MuZ2V0KGl0ZW0uc3RyKSB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBoaXQgPSBwb3NBcnIuZmluZCgobCkgPT4geCA+PSBsLnJlY3QubGVmdCAmJiB4IDw9IGwucmVjdC5yaWdodCAmJiB5ID49IGwucmVjdC50b3AgJiYgeSA8PSBsLnJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc3RyID0gYFske2l0ZW0uc3RyfV0oJHtoaXQudXJsfSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMubGluZUVuZm9yY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFkgIT09IHVuZGVmaW5lZCAmJiBNYXRoLmFicyhsYXN0WSAtIHkpID4gcGFyYW1zLmxpbmVUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdEl0ZW0gPSBzdHJCdWYubGVuZ3RoID8gc3RyQnVmW3N0ckJ1Zi5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50SXRlbUhhc05ld0xpbmUgPSBpdGVtLnN0ci5zdGFydHNXaXRoKCdcXG4nKSB8fCAoaXRlbS5zdHIudHJpbSgpID09PSAnJyAmJiBpdGVtLmhhc0VPTCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0SXRlbT8uZW5kc1dpdGgoJ1xcbicpID09PSBmYWxzZSAmJiAhaXNDdXJyZW50SXRlbUhhc05ld0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHlkaWZmID0gTWF0aC5hYnMobGFzdFkgLSB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5ZGlmZiAtIDEgPiBsaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyQnVmLnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5jZWxsU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RZICE9PSB1bmRlZmluZWQgJiYgTWF0aC5hYnMobGFzdFkgLSB5KSA8IHBhcmFtcy5saW5lVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0WCAhPT0gdW5kZWZpbmVkICYmIE1hdGguYWJzKGxhc3RYIC0geCkgPiBwYXJhbXMuY2VsbFRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHIgPSBgJHtwYXJhbXMuY2VsbFNlcGFyYXRvcn0ke2l0ZW0uc3RyfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJCdWYucHVzaChpdGVtLnN0cik7XG4gICAgICAgICAgICBsYXN0WCA9IHggKyBpdGVtLndpZHRoO1xuICAgICAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgICAgICAgbGluZUhlaWdodCA9IE1hdGgubWF4KGxpbmVIZWlnaHQsIGl0ZW0uaGVpZ2h0KTtcbiAgICAgICAgICAgIGlmIChpdGVtLmhhc0VPTCkge1xuICAgICAgICAgICAgICAgIHN0ckJ1Zi5wdXNoKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLmhhc0VPTCB8fCBpdGVtLnN0ci5lbmRzV2l0aCgnXFxuJykpIHtcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLml0ZW1Kb2luZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJCdWYuam9pbihwYXJhbXMuaXRlbUpvaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ckJ1Zi5qb2luKCcnKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SHlwZXJsaW5rcyhwYWdlLCB2aWV3cG9ydCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9FeHBsaWNpdEFueTogPHVuc3VwcG9ydGVkIHVuZGVybGluZSB0eXBlPlxuICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IChhd2FpdCBwYWdlLmdldEFubm90YXRpb25zKHsgaW50ZW50OiAnZGlzcGxheScgfSkpIHx8IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChpLnN1YnR5cGUgIT09ICdMaW5rJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGkudXJsID8/IGkudW5zYWZlVXJsO1xuICAgICAgICAgICAgaWYgKCF1cmwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gaS5vdmVybGFpZFRleHQ7XG4gICAgICAgICAgICBpZiAoIXRleHQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCByZWN0VnAgPSB2aWV3cG9ydC5jb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZShpLnJlY3QpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IE1hdGgubWluKHJlY3RWcFswXSwgcmVjdFZwWzJdKSAtIDAuNTtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IE1hdGgubWluKHJlY3RWcFsxXSwgcmVjdFZwWzNdKSAtIDAuNTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgocmVjdFZwWzBdLCByZWN0VnBbMl0pICsgMC41O1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gTWF0aC5tYXgocmVjdFZwWzFdLCByZWN0VnBbM10pICsgMC41O1xuICAgICAgICAgICAgY29uc3QgcG9zID0geyByZWN0OiB7IGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSB9LCB1cmwsIHRleHQsIHVzZWQ6IGZhbHNlIH07XG4gICAgICAgICAgICBjb25zdCBlbCA9IHJlc3VsdC5nZXQodGV4dCk7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5wdXNoKHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHRleHQsIFtwb3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IGVtYmVkZGVkIGltYWdlcyBmcm9tIHJlcXVlc3RlZCBwYWdlcy5cbiAgICAgKlxuICAgICAqIEJlaGF2aW9yIG5vdGVzOlxuICAgICAqIC0gUGFnZXMgYXJlIHNlbGVjdGVkIGFjY29yZGluZyB0byBQYXJzZVBhcmFtZXRlcnMgKHBhcnRpYWwsIGZpcnN0LCBsYXN0KS5cbiAgICAgKiAtIEltYWdlcyBzbWFsbGVyIHRoYW4gYHBhcmFtcy5pbWFnZVRocmVzaG9sZGAgKHdpZHRoIE9SIGhlaWdodCkgYXJlIHNraXBwZWQuXG4gICAgICogLSBSZXR1cm5lZCBJbWFnZVJlc3VsdCBjb250YWlucyBwZXItcGFnZSBQYWdlSW1hZ2VzOyBlYWNoIGltYWdlIGVudHJ5IGluY2x1ZGVzOlxuICAgICAqICAgICAtIGRhdGE6IFVpbnQ4QXJyYXkgKHByZXNlbnQgd2hlbiBwYXJhbXMuaW1hZ2VCdWZmZXIgPT09IHRydWUpXG4gICAgICogICAgIC0gZGF0YVVybDogc3RyaW5nIChwcmVzZW50IHdoZW4gcGFyYW1zLmltYWdlRGF0YVVybCA9PT0gdHJ1ZSlcbiAgICAgKiAgICAgLSB3aWR0aCwgaGVpZ2h0LCBraW5kLCBuYW1lXG4gICAgICogLSBXb3JrcyBpbiBib3RoIE5vZGUuanMgKGNhbnZhcy50b0J1ZmZlcikgYW5kIGJyb3dzZXIgKGNhbnZhcy50b0RhdGFVUkwpIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJzZVBhcmFtZXRlcnMgY29udHJvbGxpbmcgcGFnZSBzZWxlY3Rpb24sIHRocmVzaG9sZHMgYW5kIG91dHB1dCBmb3JtYXQuXG4gICAgICogQHJldHVybnMgUHJvbWlzZTxJbWFnZVJlc3VsdD4gd2l0aCBleHRyYWN0ZWQgaW1hZ2VzIGdyb3VwZWQgYnkgcGFnZS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRJbWFnZShwYXJhbXMgPSB7fSkge1xuICAgICAgICBjb25zdCBkb2MgPSBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEltYWdlUmVzdWx0KGRvYy5udW1QYWdlcyk7XG4gICAgICAgIHNldERlZmF1bHRQYXJzZVBhcmFtZXRlcnMocGFyYW1zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcmVzdWx0LnRvdGFsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFBhcnNlKGksIHJlc3VsdC50b3RhbCwgcGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBkb2MuZ2V0UGFnZShpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHMgPSBhd2FpdCBwYWdlLmdldE9wZXJhdG9yTGlzdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VJbWFnZXMgPSB7IHBhZ2VOdW1iZXI6IGksIGltYWdlczogW10gfTtcbiAgICAgICAgICAgICAgICByZXN1bHQucGFnZXMucHVzaChwYWdlSW1hZ2VzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9wcy5mbkFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHMuZm5BcnJheVtqXSA9PT0gcGRmanMuT1BTLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0IHx8IG9wcy5mbkFycmF5W2pdID09PSBwZGZqcy5PUFMucGFpbnRJbWFnZVhPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBvcHMuYXJnc0FycmF5W2pdWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDb21tb24gPSBwYWdlLmNvbW1vbk9ianMuaGFzKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nUHJvbWlzZSA9IGlzQ29tbW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnJlc29sdmVFbWJlZGRlZEltYWdlKHBhZ2UuY29tbW9uT2JqcywgbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMucmVzb2x2ZUVtYmVkZGVkSW1hZ2UocGFnZS5vYmpzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwga2luZCwgZGF0YSB9ID0gYXdhaXQgaW1nUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaW1hZ2VUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmltYWdlVGhyZXNob2xkID49IHdpZHRoIHx8IHBhcmFtcy5pbWFnZVRocmVzaG9sZCA+PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0V4cGxpY2l0QW55OiA8dW5kZXJseWluZyBsaWJyYXJ5IGRvZXMgbm90IGNvbnRhaW4gdmFsaWQgdHlwZWRlZnM+XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW52YXNGYWN0b3J5ID0gZG9jLmNhbnZhc0ZhY3Rvcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW52YXNBbmRDb250ZXh0ID0gY2FudmFzRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzQW5kQ29udGV4dC5jb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltZ0RhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IHBkZmpzLkltYWdlS2luZC5SR0JBXzMyQlBQKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nRGF0YSA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZ0RhdGEuZGF0YS5zZXQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWdEYXRhID0gY29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0VG9SR0JBKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0OiBuZXcgVWludDMyQXJyYXkoaW1nRGF0YS5kYXRhLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJyb3dzZXIgYW5kIE5vZGUuanMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVVybCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy50b0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vZGUuanMgZW52aXJvbm1lbnQgKGNhbnZhcyBwYWNrYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9FeHBsaWNpdEFueTogPHVuZGVybGluZSBsaWIgbm90IHN1cHBvcnQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pbWFnZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlQnVmZmVyID0gY2FudmFzQW5kQ29udGV4dC5jYW52YXMudG9CdWZmZXIoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheShub2RlQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pbWFnZURhdGFVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFVcmwgPSBgZGF0YTppbWFnZS9wbmc7YmFzZTY0LCR7bm9kZUJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVCdWZmZXIgPSBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy50b0J1ZmZlcignaW1hZ2UvcG5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheShub2RlQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFVcmwgPSBgZGF0YTppbWFnZS9wbmc7YmFzZTY0LCR7bm9kZUJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmltYWdlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGNhbnZhc0FuZENvbnRleHQuY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGgsIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGltYWdlRGF0YS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pbWFnZURhdGFVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVVybCA9IGNhbnZhc0FuZENvbnRleHQuY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUltYWdlcy5pbWFnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnZlcnRUb1JHQkEoeyBzcmMsIGRlc3QsIHdpZHRoLCBoZWlnaHQsIGtpbmQsIH0pIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IHBkZmpzLkltYWdlS2luZC5SR0JfMjRCUFApIHtcbiAgICAgICAgICAgIC8vIFJHQiAyNC1iaXQgcGVyIHBpeGVsXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBzcmMubGVuZ3RoOyBpICs9IDMsIGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBzcmNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgZyA9IHNyY1tpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IHNyY1tpICsgMl07XG4gICAgICAgICAgICAgICAgZGVzdFtqXSA9ICgyNTUgPDwgMjQpIHwgKGIgPDwgMTYpIHwgKGcgPDwgOCkgfCByO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtpbmQgPT09IHBkZmpzLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUCkge1xuICAgICAgICAgICAgLy8gR3JheXNjYWxlIDEtYml0IHBlciBwaXhlbFxuICAgICAgICAgICAgbGV0IHBpeGVsSW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcmMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlID0gc3JjW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGJpdCA9IDc7IGJpdCA+PSAwOyBiaXQtLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWxJbmRleCA+PSB3aWR0aCAqIGhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1doaXRlID0gKChieXRlID4+IGJpdCkgJiAxKSA9PT0gMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3JheSA9IGlzV2hpdGUgPyAyNTUgOiAwO1xuICAgICAgICAgICAgICAgICAgICBkZXN0W3BpeGVsSW5kZXgrK10gPSAoMjU1IDw8IDI0KSB8IChncmF5IDw8IDE2KSB8IChncmF5IDw8IDgpIHwgZ3JheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2luZCA9PT0gdW5kZWZpbmVkIHx8IGtpbmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFVua25vd24gb3IgdW5kZWZpbmVkIGtpbmQgLSB0cnkgdG8gaW5mZXIgZnJvbSBkYXRhIGxlbmd0aFxuICAgICAgICAgICAgY29uc3QgYnl0ZXNQZXJQaXhlbCA9IHNyYy5sZW5ndGggLyAod2lkdGggKiBoZWlnaHQpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGJ5dGVzUGVyUGl4ZWwgLSAzKSA8IDAuMSkge1xuICAgICAgICAgICAgICAgIC8vIExpa2VseSBSR0IgMjRCUFBcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBzcmMubGVuZ3RoOyBpICs9IDMsIGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gc3JjW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnID0gc3JjW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IHNyY1tpICsgMl07XG4gICAgICAgICAgICAgICAgICAgIGRlc3Rbal0gPSAoMjU1IDw8IDI0KSB8IChiIDw8IDE2KSB8IChnIDw8IDgpIHwgcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhieXRlc1BlclBpeGVsIC0gNCkgPCAwLjEpIHtcbiAgICAgICAgICAgICAgICAvLyBMaWtlbHkgUkdCQSAzMkJQUFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHNyYy5sZW5ndGg7IGkgKz0gNCwgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBzcmNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBzcmNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gc3JjW2kgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IHNyY1tpICsgM107XG4gICAgICAgICAgICAgICAgICAgIGRlc3Rbal0gPSAoYSA8PCAyNCkgfCAoYiA8PCAxNikgfCAoZyA8PCA4KSB8IHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoYnl0ZXNQZXJQaXhlbCAtIDEpIDwgMC4xKSB7XG4gICAgICAgICAgICAgICAgLy8gTGlrZWx5IGdyYXlzY2FsZSA4QlBQXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcmMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3JheSA9IHNyY1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZGVzdFtpXSA9ICgyNTUgPDwgMjQpIHwgKGdyYXkgPDwgMTYpIHwgKGdyYXkgPDwgOCkgfCBncmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFRvUkdCQTogQ2Fubm90IGluZmVyIGltYWdlIGZvcm1hdC4ga2luZDogJHtraW5kfSwgYnl0ZXNQZXJQaXhlbDogJHtieXRlc1BlclBpeGVsfSwgd2lkdGg6ICR7d2lkdGh9LCBoZWlnaHQ6ICR7aGVpZ2h0fSwgZGF0YUxlbmd0aDogJHtzcmMubGVuZ3RofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0VG9SR0JBOiBVbnN1cHBvcnRlZCBpbWFnZSBraW5kOiAke2tpbmR9LiBBdmFpbGFibGUga2luZHM6IEdSQVlTQ0FMRV8xQlBQPSR7cGRmanMuSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQfSwgUkdCXzI0QlBQPSR7cGRmanMuSW1hZ2VLaW5kLlJHQl8yNEJQUH0sIFJHQkFfMzJCUFA9JHtwZGZqcy5JbWFnZUtpbmQuUkdCQV8zMkJQUH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlRW1iZWRkZWRJbWFnZShwZGZPYmplY3RzLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRXhwbGljaXRBbnk6IDx1bmRlcmx5aW5nIGxpYnJhcnkgZG9lcyBub3QgY29udGFpbiB2YWxpZCB0eXBlZGVmcz5cbiAgICAgICAgICAgIHBkZk9iamVjdHMuZ2V0KG5hbWUsIChpbWdEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGltZ0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZGlmZmVyZW50IHBvc3NpYmxlIGRhdGEgc291cmNlc1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YUJ1ZmY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWdEYXRhLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQnVmZiA9IGltZ0RhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbWdEYXRhLmRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUJ1ZmYgPSBuZXcgVWludDhBcnJheShpbWdEYXRhLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGltZ0RhdGEuZGF0YT8uYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBlZCBhcnJheSB3aXRoIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUJ1ZmYgPSBuZXcgVWludDhBcnJheShpbWdEYXRhLmRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZSBicm93c2VycyBtaWdodCB1c2UgYml0bWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRXhwbGljaXRBbnk6IDx1bmRlcmx5aW5nIGxpYnJhcnkgZG9lcyBub3QgY29udGFpbiB2YWxpZCB0eXBlZGVmcz5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhc0ZhY3RvcnkgPSB0aGlzLmRvYy5jYW52YXNGYWN0b3J5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FudmFzQW5kQ29udGV4dCA9IGNhbnZhc0ZhY3RvcnkuY3JlYXRlKGltZ0RhdGEuYml0bWFwLndpZHRoLCBpbWdEYXRhLmJpdG1hcC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzQW5kQ29udGV4dC5jb250ZXh0LmRyYXdJbWFnZShpbWdEYXRhLmJpdG1hcCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBjYW52YXNBbmRDb250ZXh0LmNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltZ0RhdGEuYml0bWFwLndpZHRoLCBpbWdEYXRhLmJpdG1hcC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUJ1ZmYgPSBuZXcgVWludDhBcnJheShpbWFnZURhdGEuZGF0YS5idWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhpbWdEYXRhLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmljIHR5cGVkIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQnVmZiA9IG5ldyBVaW50OEFycmF5KGltZ0RhdGEuZGF0YS5idWZmZXIsIGltZ0RhdGEuZGF0YS5ieXRlT2Zmc2V0LCBpbWdEYXRhLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhQnVmZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgSW1hZ2Ugb2JqZWN0ICR7bmFtZX06IGRhdGEgZmllbGQgaXMgZW1wdHkgb3IgaW52YWxpZC4gQXZhaWxhYmxlIGZpZWxkczogJHtPYmplY3Qua2V5cyhpbWdEYXRhKS5qb2luKCcsICcpfWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUJ1ZmYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBJbWFnZSBvYmplY3QgJHtuYW1lfTogZGF0YSBidWZmZXIgaXMgZW1wdHkgKGxlbmd0aDogMClgKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHdpZHRoOiBpbWdEYXRhLndpZHRoLCBoZWlnaHQ6IGltZ0RhdGEuaGVpZ2h0LCBraW5kOiBpbWdEYXRhLmtpbmQsIGRhdGE6IGRhdGFCdWZmIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgSW1hZ2Ugb2JqZWN0ICR7bmFtZX0gbm90IGZvdW5kYCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVyIHBhZ2VzIHRvIHJhc3RlciBzY3JlZW5zaG90cy5cbiAgICAgKlxuICAgICAqIEJlaGF2aW9yIG5vdGVzOlxuICAgICAqIC0gUGFnZXMgYXJlIHNlbGVjdGVkIGFjY29yZGluZyB0byBQYXJzZVBhcmFtZXRlcnMgKHBhcnRpYWwsIGZpcnN0LCBsYXN0KS5cbiAgICAgKiAtIFVzZSBwYXJhbXMuc2NhbGUgZm9yIHpvb207IGlmIHBhcmFtcy5kZXNpcmVkV2lkdGggaXMgc3BlY2lmaWVkIGl0IHRha2VzIHByZWNlZGVuY2UuXG4gICAgICogLSBFYWNoIFNjcmVlbnNob3RSZXN1bHQgcGFnZSBjb250YWluczpcbiAgICAgKiAgICAgLSBkYXRhOiBVaW50OEFycmF5ICh3aGVuIHBhcmFtcy5pbWFnZUJ1ZmZlciA9PT0gdHJ1ZSlcbiAgICAgKiAgICAgLSBkYXRhVXJsOiBzdHJpbmcgKHdoZW4gcGFyYW1zLmltYWdlRGF0YVVybCA9PT0gdHJ1ZSlcbiAgICAgKiAgICAgLSBwYWdlTnVtYmVyLCB3aWR0aCwgaGVpZ2h0LCBzY2FsZVxuICAgICAqIC0gV29ya3MgaW4gYm90aCBOb2RlLmpzIChjYW52YXMudG9CdWZmZXIpIGFuZCBicm93c2VyIChjYW52YXMudG9EYXRhVVJMKSBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyc2VQYXJhbXMgLSBQYXJzZVBhcmFtZXRlcnMgY29udHJvbGxpbmcgcGFnZSBzZWxlY3Rpb24gYW5kIHJlbmRlciBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIFByb21pc2U8U2NyZWVuc2hvdFJlc3VsdD4gd2l0aCByZW5kZXJlZCBwYWdlIGltYWdlcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTY3JlZW5zaG90KHBhcnNlUGFyYW1zID0ge30pIHtcbiAgICAgICAgLy9jb25zdCBiYXNlID0gbmV3IFVSTCgnLi4vLi4vbm9kZV9tb2R1bGVzL3BkZmpzLWRpc3QvJywgaW1wb3J0Lm1ldGEudXJsKTtcbiAgICAgICAgLy90aGlzLm9wdGlvbnMuY01hcFVybCA9IG5ldyBVUkwoJ2NtYXBzLycsIGJhc2UpLmhyZWY7XG4gICAgICAgIC8vdGhpcy5vcHRpb25zLmNNYXBQYWNrZWQgPSB0cnVlO1xuICAgICAgICAvL3RoaXMub3B0aW9ucy5zdGFuZGFyZEZvbnREYXRhVXJsID0gbmV3IFVSTCgnbGVnYWN5L2J1aWxkL3N0YW5kYXJkX2ZvbnRzLycsIGJhc2UpLmhyZWY7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHNldERlZmF1bHRQYXJzZVBhcmFtZXRlcnMocGFyc2VQYXJhbXMpO1xuICAgICAgICBjb25zdCBkb2MgPSBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNjcmVlbnNob3RSZXN1bHQoZG9jLm51bVBhZ2VzKTtcbiAgICAgICAgaWYgKHRoaXMuZG9jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUERGIGRvY3VtZW50IG5vdCBsb2FkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSByZXN1bHQudG90YWw7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkUGFyc2UoaSwgcmVzdWx0LnRvdGFsLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZSA9IGF3YWl0IHRoaXMuZG9jLmdldFBhZ2UoaSk7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXdwb3J0ID0gcGFnZS5nZXRWaWV3cG9ydCh7IHNjYWxlOiBwYXJhbXMuc2NhbGUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5kZXNpcmVkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IDEgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlc2lyZWRXaWR0aFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IHBhcmFtcy5kZXNpcmVkV2lkdGggLyB2aWV3cG9ydC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IHNjYWxlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRXhwbGljaXRBbnk6IDx1bmRlcmx5aW5nIGxpYnJhcnkgZG9lcyBub3QgY29udGFpbiB2YWxpZCB0eXBlZGVmcz5cbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXNGYWN0b3J5ID0gdGhpcy5kb2MuY2FudmFzRmFjdG9yeTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXNBbmRDb250ZXh0ID0gY2FudmFzRmFjdG9yeS5jcmVhdGUodmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dDogY2FudmFzQW5kQ29udGV4dC5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzOiBjYW52YXNBbmRDb250ZXh0LmNhbnZhcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlclRhc2sgPSBwYWdlLnJlbmRlcihyZW5kZXJDb250ZXh0KTtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW5kZXJUYXNrLnByb21pc2U7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgY2FudmFzIHRvIGFuIGltYWdlIGJ1ZmZlci5cbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGFVcmwgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLnRvQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vZGUuanMgZW52aXJvbm1lbnQgKGNhbnZhcyBwYWNrYWdlKVxuICAgICAgICAgICAgICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRXhwbGljaXRBbnk6IDx1bmRlcmxpbmUgbGliIG5vdCBzdXBwb3J0PlxuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZUJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pbWFnZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUJ1ZmZlciA9IGNhbnZhc0FuZENvbnRleHQuY2FudmFzLnRvQnVmZmVyKCdpbWFnZS9wbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShub2RlQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmltYWdlRGF0YVVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVXJsID0gYGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwke25vZGVCdWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlQnVmZmVyID0gY2FudmFzQW5kQ29udGV4dC5jYW52YXMudG9CdWZmZXIoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShub2RlQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVXJsID0gYGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwke25vZGVCdWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pbWFnZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY2FudmFzQW5kQ29udGV4dC5jb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCwgY2FudmFzQW5kQ29udGV4dC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShpbWFnZURhdGEuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pbWFnZURhdGFVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFVcmwgPSBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBiYXNlNjQgPSBkYXRhVXJsLnNwbGl0KCcsJylbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IGJpbmFyeVN0cmluZyA9IGF0b2IoYmFzZTY0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZGF0YSA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9cdGRhdGFbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVybCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZU51bWJlcjogaSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IHZpZXdwb3J0LnNjYWxlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhZ2UuY2xlYW51cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVjdCBhbmQgZXh0cmFjdCB0YWJsZXMgZnJvbSBwYWdlcyBieSBhbmFseXNpbmcgdmVjdG9yIGRyYXdpbmcgb3BlcmF0b3JzLCB0aGVuIHBvcHVsYXRlIGNlbGxzIHdpdGggdGV4dC5cbiAgICAgKlxuICAgICAqIEJlaGF2aW9yIG5vdGVzOlxuICAgICAqIC0gU2NhbnMgb3BlcmF0b3IgbGlzdHMgZm9yIHJlY3RhbmdsZXMvbGluZXMgdGhhdCBmb3JtIHRhYmxlIGdyaWRzICh1c2VzIFBhdGhHZW9tZXRyeSBhbmQgTGluZVN0b3JlKS5cbiAgICAgKiAtIE5vcm1hbGl6ZXMgZGV0ZWN0ZWQgZ2VvbWV0cnkgYW5kIG1hdGNoZXMgcG9zaXRpb25lZCB0ZXh0IHRvIHRhYmxlIGNlbGxzLlxuICAgICAqIC0gSG9ub3JzIFBhcnNlUGFyYW1ldGVycyBmb3IgcGFnZSBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyc2VQYXJhbWV0ZXJzIGNvbnRyb2xsaW5nIHdoaWNoIHBhZ2VzIHRvIGFuYWx5c2UgKHBhcnRpYWwvZmlyc3QvbGFzdCkuXG4gICAgICogQHJldHVybnMgUHJvbWlzZTxUYWJsZVJlc3VsdD4gY29udGFpbmluZyBkaXNjb3ZlcmVkIHRhYmxlcyBwZXIgcGFnZS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUYWJsZShwYXJhbXMgPSB7fSkge1xuICAgICAgICBjb25zdCBkb2MgPSBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFRhYmxlUmVzdWx0KGRvYy5udW1QYWdlcyk7XG4gICAgICAgIGlmICh0aGlzLmRvYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BERiBkb2N1bWVudCBub3QgbG9hZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcmVzdWx0LnRvdGFsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFBhcnNlKGksIHJlc3VsdC50b3RhbCwgcGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCB0aGlzLmRvYy5nZXRQYWdlKGkpO1xuICAgICAgICAgICAgICAgIC8vY29uc3Qgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IDEgfSk7XG4gICAgICAgICAgICAgICAgLy92aWV3cG9ydC5jb252ZXJ0VG9WaWV3cG9ydFBvaW50KDAsIDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5nZXRQYWdlVGFibGVzKHBhZ2UpO1xuICAgICAgICAgICAgICAgIC8vY29uc3Qgc3RvcmUgPSBhd2FpdCB0aGlzLmdldFBhZ2VHZW9tZXRyeShwYWdlKTtcbiAgICAgICAgICAgICAgICBzdG9yZS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZURhdGFBcnIgPSBzdG9yZS5nZXRUYWJsZURhdGEoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmZpbGxQYWdlVGFibGVzKHBhZ2UsIHRhYmxlRGF0YUFycik7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZVRhYmxlUmVzdWx0ID0geyBudW06IGksIHRhYmxlczogW10gfTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRhYmxlIG9mIHRhYmxlRGF0YUFycikge1xuICAgICAgICAgICAgICAgICAgICAvL2lmICh0YWJsZS5jZWxsQ291bnQgPCAzKSBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICBwYWdlVGFibGVSZXN1bHQudGFibGVzLnB1c2godGFibGUudG9BcnJheSgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBwYWdlVGFibGVSZXN1bHQ6IFBhZ2VUYWJsZVJlc3VsdCA9IHsgbnVtOiBpLCB0YWJsZXM6IHRhYmxlLnRvQXJyYXkoKSB9O1xuICAgICAgICAgICAgICAgICAgICAvL3BhZ2VUYWJsZVJlc3VsdC50YWJsZXMucHVzaCh0YWJsZS50b0RhdGEoKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhZ2VzLnB1c2gocGFnZVRhYmxlUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBwYWdlLmNsZWFudXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmb3IgKGNvbnN0IHRhYmxlIG9mIFRhYmxlLkFsbFRhYmxlcykge1xuICAgICAgICAvLyAgICAgaWYgKHRhYmxlLmNlbGxDb3VudCA8IDMpIGNvbnRpbnVlXG4gICAgICAgIC8vICAgICBjb25zdCBzdHIgPSB0YWJsZS50b1N0cmluZygpXG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhzdHIpXG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0UGF0aEdlb21ldHJ5KG1tKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbW1bMl0gLSBtbVswXTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbW1bM10gLSBtbVsxXTtcbiAgICAgICAgaWYgKG1tWzBdID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIFBhdGhHZW9tZXRyeS51bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoID4gNSAmJiBoZWlnaHQgPiA1KSB7XG4gICAgICAgICAgICByZXR1cm4gUGF0aEdlb21ldHJ5LnJlY3RhbmdsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3aWR0aCA+IDUgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUGF0aEdlb21ldHJ5LmhsaW5lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA+IDUpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXRoR2VvbWV0cnkudmxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBhdGhHZW9tZXRyeS51bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIGdldFBhZ2VUYWJsZXMocGFnZSkge1xuICAgICAgICBjb25zdCBsaW5lU3RvcmUgPSBuZXcgTGluZVN0b3JlKCk7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gcGFnZS5nZXRWaWV3cG9ydCh7IHNjYWxlOiAxIH0pO1xuICAgICAgICBsZXQgdHJhbnNmb3JtTWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgICAgICBjb25zdCBvcExpc3QgPSBhd2FpdCBwYWdlLmdldE9wZXJhdG9yTGlzdCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wTGlzdC5mbkFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IG9wTGlzdC5mbkFycmF5W2ldO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IG9wTGlzdC5hcmdzQXJyYXlbaV07XG4gICAgICAgICAgICBjb25zdCBvcCA9IGFyZ3M/LlswXSA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbW0gPSBhcmdzPy5bMl0gPz8gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgICAgICAgICAgLy9jb25zdCBtaW5NYXggPSBuZXcgRmxvYXQzMkFycmF5KFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XSk7XG4gICAgICAgICAgICBpZiAoZm4gPT09IHBkZmpzLk9QUy5jb25zdHJ1Y3RQYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wID09PSBwZGZqcy5PUFMuZmlsbCkge1xuICAgICAgICAgICAgICAgICAgICAvL2RlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3AgIT09IHBkZmpzLk9QUy5zdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBnID0gdGhpcy5nZXRQYXRoR2VvbWV0cnkobW0pO1xuICAgICAgICAgICAgICAgIGlmIChwZyA9PT0gUGF0aEdlb21ldHJ5LnJlY3RhbmdsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gbmV3IFJlY3RhbmdsZShuZXcgUG9pbnQobW1bMF0sIG1tWzFdKSwgbW1bMl0gLSBtbVswXSwgbW1bM10gLSBtbVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QudHJhbnNmb3JtKHRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QudHJhbnNmb3JtKHZpZXdwb3J0LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdG9yZS5hZGRSZWN0YW5nbGUocmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBnID09PSBQYXRoR2VvbWV0cnkuaGxpbmUgfHwgcGcgPT09IFBhdGhHZW9tZXRyeS52bGluZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gbmV3IFBvaW50KG1tWzBdLCBtbVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gbmV3IFBvaW50KG1tWzJdLCBtbVszXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBuZXcgTGluZShmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUudHJhbnNmb3JtKHRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUudHJhbnNmb3JtKHZpZXdwb3J0LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdG9yZS5hZGQobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2RlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiAob3AgPT09IHBkZmpzLk9QUy5yZWN0YW5nbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBcdGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAob3AgPT09IHBkZmpzLk9QUy5tb3ZlVG8pIHtcbiAgICAgICAgICAgICAgICAvLyBcdGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAob3AgPT09IHBkZmpzLk9QUy5saW5lVG8pIHtcbiAgICAgICAgICAgICAgICAvLyBcdGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAob3AgPT09IHBkZmpzLk9QUy5lbmRQYXRoKSB7XG4gICAgICAgICAgICAgICAgLy8gXHRjb25zdCBjb21iaW5lZE1hdHJpeCA9IHBkZmpzLlV0aWwudHJhbnNmb3JtKHZpZXdwb3J0LnRyYW5zZm9ybSwgdHJhbnNmb3JtTWF0cml4KTtcbiAgICAgICAgICAgICAgICAvLyBcdC8vIHdoaWxlIChhcmdzWzFdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIFx0Ly8gXHRjb25zdCBkcmF3T3AgPSBhcmdzWzFdLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgLy8gXHQvLyBcdGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIC8vIFx0Ly8gfVxuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gXHQvL2RlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZuID09PSBwZGZqcy5PUFMuc2V0TGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgLy9kZWJ1Z2dlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZuID09PSBwZGZqcy5PUFMuc2F2ZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVN0YWNrLnB1c2godHJhbnNmb3JtTWF0cml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZuID09PSBwZGZqcy5PUFMucmVzdG9yZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3RvcmVkTWF0cml4ID0gdHJhbnNmb3JtU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RvcmVkTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeCA9IHJlc3RvcmVkTWF0cml4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZuID09PSBwZGZqcy5PUFMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgLy90cmFuc2Zvcm1NYXRyaXggPSB0aGlzLnRyYW5zZm9ybV9mbih0cmFuc2Zvcm1NYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeCA9IHBkZmpzLlV0aWwudHJhbnNmb3JtKHRyYW5zZm9ybU1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVTdG9yZTtcbiAgICB9XG4gICAgLy8gcHJpdmF0ZSBhc3luYyBnZXRQYWdlR2VvbWV0cnkocGFnZTogUERGUGFnZVByb3h5KTogUHJvbWlzZTxMaW5lU3RvcmU+IHtcbiAgICAvLyBcdGNvbnN0IGxpbmVTdG9yZTogTGluZVN0b3JlID0gbmV3IExpbmVTdG9yZSgpO1xuICAgIC8vIFx0Y29uc3Qgb3BMaXN0ID0gYXdhaXQgcGFnZS5nZXRPcGVyYXRvckxpc3QoKTtcbiAgICAvLyBcdGNvbnN0IHZpZXdwb3J0ID0gcGFnZS5nZXRWaWV3cG9ydCh7IHNjYWxlOiAxIH0pO1xuICAgIC8vIFx0bGV0IHRyYW5zZm9ybU1hdHJpeCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICAvLyBcdGNvbnN0IHRyYW5zZm9ybVN0YWNrOiBBcnJheTxBcnJheTxudW1iZXI+PiA9IFtdO1xuICAgIC8vIFx0bGV0IGN1cnJlbnRfeDogbnVtYmVyID0gMDtcbiAgICAvLyBcdGxldCBjdXJyZW50X3k6IG51bWJlciA9IDA7XG4gICAgLy8gXHRmb3IgKGxldCBqID0gMDsgaiA8IG9wTGlzdC5mbkFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgLy8gXHRcdGNvbnN0IGZuID0gb3BMaXN0LmZuQXJyYXlbal07XG4gICAgLy8gXHRcdGNvbnN0IGFyZ3MgPSBvcExpc3QuYXJnc0FycmF5W2pdO1xuICAgIC8vIFx0XHRpZiAoZm4gPT09IHBkZmpzLk9QUy5jb25zdHJ1Y3RQYXRoKSB7XG4gICAgLy8gXHRcdFx0d2hpbGUgKGFyZ3NbMF0ubGVuZ3RoKSB7XG4gICAgLy8gXHRcdFx0XHRjb25zdCBvcCA9IGFyZ3NbMF0uc2hpZnQoKTtcbiAgICAvLyBcdFx0XHRcdGNvbnN0IGNvbWJpbmVkTWF0cml4ID0gcGRmanMuVXRpbC50cmFuc2Zvcm0odmlld3BvcnQudHJhbnNmb3JtLCB0cmFuc2Zvcm1NYXRyaXgpO1xuICAgIC8vIFx0XHRcdFx0aWYgKG9wID09PSBwZGZqcy5PUFMucmVjdGFuZ2xlKSB7XG4gICAgLy8gXHRcdFx0XHRcdGNvbnN0IHggPSBhcmdzWzFdLnNoaWZ0KCk7XG4gICAgLy8gXHRcdFx0XHRcdGNvbnN0IHkgPSBhcmdzWzFdLnNoaWZ0KCk7XG4gICAgLy8gXHRcdFx0XHRcdGNvbnN0IHdpZHRoID0gYXJnc1sxXS5zaGlmdCgpO1xuICAgIC8vIFx0XHRcdFx0XHRjb25zdCBoZWlnaHQgPSBhcmdzWzFdLnNoaWZ0KCk7XG4gICAgLy8gXHRcdFx0XHRcdGlmIChNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSA8PSAyKSB7XG4gICAgLy8gXHRcdFx0XHRcdFx0Ly8gVE9ETyByZW1vdmVcbiAgICAvLyBcdFx0XHRcdFx0XHRkZWJ1Z2dlcjtcbiAgICAvLyBcdFx0XHRcdFx0fVxuICAgIC8vIFx0XHRcdFx0XHRjb25zdCByZWN0ID0gbmV3IFJlY3RhbmdsZShuZXcgUG9pbnQoeCwgeSksIHdpZHRoLCBoZWlnaHQpO1xuICAgIC8vIFx0XHRcdFx0XHRyZWN0LnRyYW5zZm9ybShjb21iaW5lZE1hdHJpeCk7XG4gICAgLy8gXHRcdFx0XHRcdC8vcmVjdC50cmFuc2Zvcm0odmlld3BvcnQudHJhbnNmb3JtKTtcbiAgICAvLyBcdFx0XHRcdFx0bGluZVN0b3JlLmFkZFJlY3RhbmdsZShyZWN0KTtcbiAgICAvLyBcdFx0XHRcdH0gZWxzZSBpZiAob3AgPT09IHBkZmpzLk9QUy5tb3ZlVG8pIHtcbiAgICAvLyBcdFx0XHRcdFx0Y3VycmVudF94ID0gYXJnc1sxXS5zaGlmdCgpO1xuICAgIC8vIFx0XHRcdFx0XHRjdXJyZW50X3kgPSBhcmdzWzFdLnNoaWZ0KCk7XG4gICAgLy8gXHRcdFx0XHR9IGVsc2UgaWYgKG9wID09PSBwZGZqcy5PUFMubGluZVRvKSB7XG4gICAgLy8gXHRcdFx0XHRcdGNvbnN0IHggPSBhcmdzWzFdLnNoaWZ0KCk7XG4gICAgLy8gXHRcdFx0XHRcdGNvbnN0IHkgPSBhcmdzWzFdLnNoaWZ0KCk7XG4gICAgLy8gXHRcdFx0XHRcdC8vZGVmYXVsdCB0cmFzZm9ybVxuICAgIC8vIFx0XHRcdFx0XHRjb25zdCBmcm9tID0gbmV3IFBvaW50KGN1cnJlbnRfeCwgY3VycmVudF95KTtcbiAgICAvLyBcdFx0XHRcdFx0Y29uc3QgdG8gPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgLy8gXHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBuZXcgTGluZShmcm9tLCB0byk7XG4gICAgLy8gXHRcdFx0XHRcdGxpbmUudHJhbnNmb3JtKGNvbWJpbmVkTWF0cml4KTtcbiAgICAvLyBcdFx0XHRcdFx0Ly9saW5lLnRyYW5zZm9ybSh2aWV3cG9ydC50cmFuc2Zvcm0pO1xuICAgIC8vIFx0XHRcdFx0XHQvLyAvLyB2aWV3cG9ydCB0cmFuc2Zvcm1cbiAgICAvLyBcdFx0XHRcdFx0Ly8gY29uc3QgX2Zyb20gPSB2aWV3cG9ydC5jb252ZXJ0VG9WaWV3cG9ydFBvaW50KGxpbmUuZnJvbS54LCBsaW5lLmZyb20ueSlcbiAgICAvLyBcdFx0XHRcdFx0Ly8gY29uc3QgX3RvID0gdmlld3BvcnQuY29udmVydFRvVmlld3BvcnRQb2ludChsaW5lLnRvLngsIGxpbmUudG8ueSlcbiAgICAvLyBcdFx0XHRcdFx0Ly9cbiAgICAvLyBcdFx0XHRcdFx0Ly8gY29uc3QgdHJhbnNmb3JtZWRMaW5lID0gbmV3IExpbmUobmV3IFBvaW50KF9mcm9tWzBdLCBfZnJvbVsxXSksIG5ldyBQb2ludChfdG9bMF0sIF90b1sxXSkpXG4gICAgLy8gXHRcdFx0XHRcdGxpbmVTdG9yZS5hZGQobGluZSk7XG4gICAgLy8gXHRcdFx0XHRcdGN1cnJlbnRfeCA9IHg7XG4gICAgLy8gXHRcdFx0XHRcdGN1cnJlbnRfeSA9IHk7XG4gICAgLy8gXHRcdFx0XHR9XG4gICAgLy8gXHRcdFx0fVxuICAgIC8vIFx0XHR9IGVsc2UgaWYgKGZuID09PSBwZGZqcy5PUFMuc2F2ZSkge1xuICAgIC8vIFx0XHRcdHRyYW5zZm9ybVN0YWNrLnB1c2godHJhbnNmb3JtTWF0cml4KTtcbiAgICAvLyBcdFx0fSBlbHNlIGlmIChmbiA9PT0gcGRmanMuT1BTLnJlc3RvcmUpIHtcbiAgICAvLyBcdFx0XHRjb25zdCByZXN0b3JlZE1hdHJpeCA9IHRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICAgIC8vIFx0XHRcdGlmIChyZXN0b3JlZE1hdHJpeCkge1xuICAgIC8vIFx0XHRcdFx0dHJhbnNmb3JtTWF0cml4ID0gcmVzdG9yZWRNYXRyaXg7XG4gICAgLy8gXHRcdFx0fVxuICAgIC8vIFx0XHR9IGVsc2UgaWYgKGZuID09PSBwZGZqcy5PUFMudHJhbnNmb3JtKSB7XG4gICAgLy8gXHRcdFx0Ly90cmFuc2Zvcm1NYXRyaXggPSB0aGlzLnRyYW5zZm9ybV9mbih0cmFuc2Zvcm1NYXRyaXgsIGFyZ3MpO1xuICAgIC8vIFx0XHRcdHRyYW5zZm9ybU1hdHJpeCA9IHBkZmpzLlV0aWwudHJhbnNmb3JtKHRyYW5zZm9ybU1hdHJpeCwgYXJncyk7XG4gICAgLy8gXHRcdH1cbiAgICAvLyBcdH1cbiAgICAvLyBcdHJldHVybiBsaW5lU3RvcmU7XG4gICAgLy8gfVxuICAgIGFzeW5jIGZpbGxQYWdlVGFibGVzKHBhZ2UsIHBhZ2VUYWJsZXMpIHtcbiAgICAgICAgLy9jb25zdCByZXN1bHRUYWJsZTogQXJyYXk8VGFibGU+ID0gW11cbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IDEgfSk7XG4gICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgcGFnZVRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyAgICAgY29uc3QgY3VycmVudFRhYmxlID0gcGFnZVRhYmxlc1tpXVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vcGFnZVRhYmxlcyA9IHBhZ2VUYWJsZXMuZmlsdGVyKCh0YWJsZSkgPT4gdGFibGUuY2VsbENvdW50ID4gMylcbiAgICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSBhd2FpdCBwYWdlLmdldFRleHRDb250ZW50KHtcbiAgICAgICAgICAgIGluY2x1ZGVNYXJrZWRDb250ZW50OiBmYWxzZSxcbiAgICAgICAgICAgIGRpc2FibGVOb3JtYWxpemF0aW9uOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgdGV4dEl0ZW0gb2YgdGV4dENvbnRlbnQuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghKCdzdHInIGluIHRleHRJdGVtKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gcGRmanMuVXRpbC50cmFuc2Zvcm0ocGRmanMuVXRpbC50cmFuc2Zvcm0odmlld3BvcnQudHJhbnNmb3JtLCB0ZXh0SXRlbS50cmFuc2Zvcm0pLCBbMSwgMCwgMCwgLTEsIDAsIDBdKTtcbiAgICAgICAgICAgIC8vY29uc3QgcmVzWFkgPSB2aWV3cG9ydC5jb252ZXJ0VG9WaWV3cG9ydFBvaW50KHR4WzRdLCB0eFs1XSk7XG4gICAgICAgICAgICAvLyB0ZXh0SXRlbS50cmFuc2Zvcm0gPSBwZGZqcy5VdGlsLnRyYW5zZm9ybSh2aWV3cG9ydC50cmFuc2Zvcm0sIHRleHRJdGVtLnRyYW5zZm9ybSlcbiAgICAgICAgICAgIC8vIHRleHRJdGVtLnRyYW5zZm9ybVs1XSA9IHZpZXdwb3J0LmhlaWdodCAtIHRleHRJdGVtLnRyYW5zZm9ybVs1XSAtIHRleHRJdGVtLmhlaWdodFxuICAgICAgICAgICAgZm9yIChjb25zdCBwYWdlVGFibGUgb2YgcGFnZVRhYmxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBwYWdlVGFibGUuZmluZENlbGwodHhbNF0sIHR4WzVdKTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsLnRleHQucHVzaCh0ZXh0SXRlbS5zdHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dEl0ZW0uaGFzRU9MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnRleHQucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9UYWJsZS50cnlBZGRUZXh0KHBhZ2VUYWJsZXMsIHRleHRJdGVtKVxuICAgICAgICB9XG4gICAgfVxufVxuLy9QREZQYXJzZS5zZXRXb3JrZXIoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBERlBhcnNlLmpzLm1hcCJdLCJuYW1lcyI6WyJwZGZqcyIsImdldEV4Y2VwdGlvbiIsIkxpbmUiLCJMaW5lU3RvcmUiLCJQb2ludCIsIlJlY3RhbmdsZSIsIkltYWdlUmVzdWx0IiwiSW5mb1Jlc3VsdCIsInNldERlZmF1bHRQYXJzZVBhcmFtZXRlcnMiLCJQYXRoR2VvbWV0cnkiLCJTY3JlZW5zaG90UmVzdWx0IiwiVGFibGVSZXN1bHQiLCJUZXh0UmVzdWx0IiwiUERGUGFyc2UiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJwcm9ncmVzcyIsImxvYWRlZCIsInRvdGFsIiwidmVyYm9zaXR5IiwidW5kZWZpbmVkIiwiVmVyYm9zaXR5TGV2ZWwiLCJFUlJPUlMiLCJCdWZmZXIiLCJkYXRhIiwiVWludDhBcnJheSIsImRlc3Ryb3kiLCJkb2MiLCJpc05vZGVKUyIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm53IiwiZWxlY3Ryb24iLCJ0eXBlIiwic2V0V29ya2VyIiwid29ya2VyU3JjIiwiZ2xvYmFsVGhpcyIsIkdsb2JhbFdvcmtlck9wdGlvbnMiLCJnZXRJbmZvIiwicGFyYW1zIiwibG9hZCIsInJlc3VsdCIsIm51bVBhZ2VzIiwiaW5mbyIsIm1ldGFkYXRhIiwiZ2V0TWV0YWRhdGEiLCJmaW5nZXJwcmludHMiLCJvdXRsaW5lIiwiZ2V0T3V0bGluZSIsInBlcm1pc3Npb24iLCJnZXRQZXJtaXNzaW9ucyIsInBhZ2VMYWJlbHMiLCJnZXRQYWdlTGFiZWxzIiwicGFyc2VQYWdlSW5mbyIsImkiLCJzaG91bGRQYXJzZSIsInBhZ2UiLCJnZXRQYWdlIiwicGFnZUxpbmtSZXN1bHQiLCJnZXRQYWdlTGlua3MiLCJwYWdlTGFiZWwiLCJwYWdlTnVtYmVyIiwicGFnZXMiLCJwdXNoIiwiY2xlYW51cCIsInZpZXdwb3J0IiwiZ2V0Vmlld3BvcnQiLCJzY2FsZSIsImxpbmtzIiwid2lkdGgiLCJoZWlnaHQiLCJhbm5vdGF0aW9ucyIsImdldEFubm90YXRpb25zIiwiaW50ZW50Iiwic3VidHlwZSIsInVybCIsInVuc2FmZVVybCIsInRleHQiLCJvdmVybGFpZFRleHQiLCJnZXRUZXh0IiwiZ2V0UGFnZVRleHQiLCJudW0iLCJwYWdlSm9pbmVyIiwicmVwbGFjZSIsImxvYWRpbmdUYXNrIiwiZ2V0RG9jdW1lbnQiLCJvblByb2dyZXNzIiwicHJvbWlzZSIsImVycm9yIiwiY3VycmVudFBhZ2UiLCJ0b3RhbFBhZ2UiLCJwYXJ0aWFsIiwiZmlyc3QiLCJsYXN0IiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJwYXJzZVBhcmFtcyIsInRleHRDb250ZW50IiwiZ2V0VGV4dENvbnRlbnQiLCJpbmNsdWRlTWFya2VkQ29udGVudCIsImRpc2FibGVOb3JtYWxpemF0aW9uIiwiTWFwIiwicGFyc2VIeXBlcmxpbmtzIiwiZ2V0SHlwZXJsaW5rcyIsInN0ckJ1ZiIsImxhc3RYIiwibGFzdFkiLCJsaW5lSGVpZ2h0IiwiaXRlbSIsIml0ZW1zIiwidG0iLCJ0cmFuc2Zvcm0iLCJ4IiwieSIsImNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQiLCJwb3NBcnIiLCJnZXQiLCJzdHIiLCJoaXQiLCJmaW5kIiwibCIsInJlY3QiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJsaW5lRW5mb3JjZSIsIk1hdGgiLCJhYnMiLCJsaW5lVGhyZXNob2xkIiwibGFzdEl0ZW0iLCJpc0N1cnJlbnRJdGVtSGFzTmV3TGluZSIsInN0YXJ0c1dpdGgiLCJ0cmltIiwiaGFzRU9MIiwiZW5kc1dpdGgiLCJ5ZGlmZiIsImNlbGxTZXBhcmF0b3IiLCJjZWxsVGhyZXNob2xkIiwibWF4IiwiaXRlbUpvaW5lciIsImpvaW4iLCJyZWN0VnAiLCJjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZSIsIm1pbiIsInBvcyIsInVzZWQiLCJlbCIsInNldCIsImdldEltYWdlIiwib3BzIiwiZ2V0T3BlcmF0b3JMaXN0IiwicGFnZUltYWdlcyIsImltYWdlcyIsImoiLCJmbkFycmF5IiwiT1BTIiwicGFpbnRJbmxpbmVJbWFnZVhPYmplY3QiLCJwYWludEltYWdlWE9iamVjdCIsIm5hbWUiLCJhcmdzQXJyYXkiLCJpc0NvbW1vbiIsImNvbW1vbk9ianMiLCJoYXMiLCJpbWdQcm9taXNlIiwicmVzb2x2ZUVtYmVkZGVkSW1hZ2UiLCJvYmpzIiwia2luZCIsImltYWdlVGhyZXNob2xkIiwiY2FudmFzRmFjdG9yeSIsImNhbnZhc0FuZENvbnRleHQiLCJjcmVhdGUiLCJjb250ZXh0IiwiaW1nRGF0YSIsIkltYWdlS2luZCIsIlJHQkFfMzJCUFAiLCJjcmVhdGVJbWFnZURhdGEiLCJjb252ZXJ0VG9SR0JBIiwic3JjIiwiZGVzdCIsIlVpbnQzMkFycmF5IiwiYnVmZmVyIiwicHV0SW1hZ2VEYXRhIiwiZGF0YVVybCIsImNhbnZhcyIsInRvQnVmZmVyIiwibm9kZUJ1ZmZlciIsImltYWdlQnVmZmVyIiwiaW1hZ2VEYXRhVXJsIiwidG9TdHJpbmciLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJ0b0RhdGFVUkwiLCJSR0JfMjRCUFAiLCJyIiwiZyIsImIiLCJHUkFZU0NBTEVfMUJQUCIsInBpeGVsSW5kZXgiLCJieXRlIiwiYml0IiwiaXNXaGl0ZSIsImdyYXkiLCJieXRlc1BlclBpeGVsIiwiYSIsIkVycm9yIiwicGRmT2JqZWN0cyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZGF0YUJ1ZmYiLCJVaW50OENsYW1wZWRBcnJheSIsImJpdG1hcCIsImRyYXdJbWFnZSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJPYmplY3QiLCJrZXlzIiwiZ2V0U2NyZWVuc2hvdCIsImRlc2lyZWRXaWR0aCIsInJlbmRlckNvbnRleHQiLCJjYW52YXNDb250ZXh0IiwicmVuZGVyVGFzayIsInJlbmRlciIsImdldFRhYmxlIiwic3RvcmUiLCJnZXRQYWdlVGFibGVzIiwibm9ybWFsaXplIiwidGFibGVEYXRhQXJyIiwiZ2V0VGFibGVEYXRhIiwiZmlsbFBhZ2VUYWJsZXMiLCJwYWdlVGFibGVSZXN1bHQiLCJ0YWJsZXMiLCJ0YWJsZSIsInRvQXJyYXkiLCJnZXRQYXRoR2VvbWV0cnkiLCJtbSIsIkluZmluaXR5IiwicmVjdGFuZ2xlIiwiaGxpbmUiLCJ2bGluZSIsImxpbmVTdG9yZSIsInRyYW5zZm9ybU1hdHJpeCIsInRyYW5zZm9ybVN0YWNrIiwib3BMaXN0IiwiZm4iLCJhcmdzIiwib3AiLCJjb25zdHJ1Y3RQYXRoIiwiZmlsbCIsInN0cm9rZSIsInBnIiwiYWRkUmVjdGFuZ2xlIiwiZnJvbSIsInRvIiwibGluZSIsImFkZCIsInNldExpbmVXaWR0aCIsInNhdmUiLCJyZXN0b3JlIiwicmVzdG9yZWRNYXRyaXgiLCJwb3AiLCJVdGlsIiwicGFnZVRhYmxlcyIsInRleHRJdGVtIiwidHgiLCJwYWdlVGFibGUiLCJjZWxsIiwiZmluZENlbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/PDFParse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/ParseParameters.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/ParseParameters.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setDefaultParseParameters: () => (/* binding */ setDefaultParseParameters)\n/* harmony export */ });\nfunction setDefaultParseParameters(params) {\n    params.lineThreshold = params?.lineThreshold ?? 4.6;\n    params.cellThreshold = params?.cellThreshold ?? 7;\n    params.cellSeparator = params?.cellSeparator ?? \"\t\";\n    params.lineEnforce = params?.lineEnforce ?? true;\n    params.pageJoiner = params?.pageJoiner ?? \"\\n-- page_number of total_number --\";\n    params.imageThreshold = params?.imageThreshold ?? 80;\n    params.imageDataUrl = params?.imageDataUrl ?? true;\n    params.imageBuffer = params?.imageBuffer ?? true;\n    params.scale = params?.scale ?? 1;\n    return params;\n} //# sourceMappingURL=ParseParameters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9QYXJzZVBhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLFNBQVNBLDBCQUEwQkMsTUFBTTtJQUM1Q0EsT0FBT0MsYUFBYSxHQUFHRCxRQUFRQyxpQkFBaUI7SUFDaERELE9BQU9FLGFBQWEsR0FBR0YsUUFBUUUsaUJBQWlCO0lBQ2hERixPQUFPRyxhQUFhLEdBQUdILFFBQVFHLGlCQUFpQjtJQUNoREgsT0FBT0ksV0FBVyxHQUFHSixRQUFRSSxlQUFlO0lBQzVDSixPQUFPSyxVQUFVLEdBQUdMLFFBQVFLLGNBQWM7SUFDMUNMLE9BQU9NLGNBQWMsR0FBR04sUUFBUU0sa0JBQWtCO0lBQ2xETixPQUFPTyxZQUFZLEdBQUdQLFFBQVFPLGdCQUFnQjtJQUM5Q1AsT0FBT1EsV0FBVyxHQUFHUixRQUFRUSxlQUFlO0lBQzVDUixPQUFPUyxLQUFLLEdBQUdULFFBQVFTLFNBQVM7SUFDaEMsT0FBT1Q7QUFDWCxFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWNhcmVlci1hc3Npc3RhbnQvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9QYXJzZVBhcmFtZXRlcnMuanM/OTEwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gc2V0RGVmYXVsdFBhcnNlUGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICBwYXJhbXMubGluZVRocmVzaG9sZCA9IHBhcmFtcz8ubGluZVRocmVzaG9sZCA/PyA0LjY7XG4gICAgcGFyYW1zLmNlbGxUaHJlc2hvbGQgPSBwYXJhbXM/LmNlbGxUaHJlc2hvbGQgPz8gNztcbiAgICBwYXJhbXMuY2VsbFNlcGFyYXRvciA9IHBhcmFtcz8uY2VsbFNlcGFyYXRvciA/PyAnXFx0JztcbiAgICBwYXJhbXMubGluZUVuZm9yY2UgPSBwYXJhbXM/LmxpbmVFbmZvcmNlID8/IHRydWU7XG4gICAgcGFyYW1zLnBhZ2VKb2luZXIgPSBwYXJhbXM/LnBhZ2VKb2luZXIgPz8gJ1xcbi0tIHBhZ2VfbnVtYmVyIG9mIHRvdGFsX251bWJlciAtLSc7XG4gICAgcGFyYW1zLmltYWdlVGhyZXNob2xkID0gcGFyYW1zPy5pbWFnZVRocmVzaG9sZCA/PyA4MDtcbiAgICBwYXJhbXMuaW1hZ2VEYXRhVXJsID0gcGFyYW1zPy5pbWFnZURhdGFVcmwgPz8gdHJ1ZTtcbiAgICBwYXJhbXMuaW1hZ2VCdWZmZXIgPSBwYXJhbXM/LmltYWdlQnVmZmVyID8/IHRydWU7XG4gICAgcGFyYW1zLnNjYWxlID0gcGFyYW1zPy5zY2FsZSA/PyAxO1xuICAgIHJldHVybiBwYXJhbXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXJzZVBhcmFtZXRlcnMuanMubWFwIl0sIm5hbWVzIjpbInNldERlZmF1bHRQYXJzZVBhcmFtZXRlcnMiLCJwYXJhbXMiLCJsaW5lVGhyZXNob2xkIiwiY2VsbFRocmVzaG9sZCIsImNlbGxTZXBhcmF0b3IiLCJsaW5lRW5mb3JjZSIsInBhZ2VKb2luZXIiLCJpbWFnZVRocmVzaG9sZCIsImltYWdlRGF0YVVybCIsImltYWdlQnVmZmVyIiwic2NhbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/ParseParameters.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/PathGeometry.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/PathGeometry.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DrawOPS: () => (/* binding */ DrawOPS),\n/* harmony export */   PathGeometry: () => (/* binding */ PathGeometry)\n/* harmony export */ });\nvar PathGeometry;\n(function(PathGeometry) {\n    PathGeometry[PathGeometry[\"undefined\"] = 0] = \"undefined\";\n    PathGeometry[PathGeometry[\"hline\"] = 1] = \"hline\";\n    PathGeometry[PathGeometry[\"vline\"] = 2] = \"vline\";\n    PathGeometry[PathGeometry[\"rectangle\"] = 3] = \"rectangle\";\n})(PathGeometry || (PathGeometry = {}));\nvar DrawOPS;\n(function(DrawOPS) {\n    DrawOPS[DrawOPS[\"moveTo\"] = 0] = \"moveTo\";\n    DrawOPS[DrawOPS[\"lineTo\"] = 1] = \"lineTo\";\n    DrawOPS[DrawOPS[\"curveTo\"] = 2] = \"curveTo\";\n    DrawOPS[DrawOPS[\"closePath\"] = 3] = \"closePath\";\n    DrawOPS[DrawOPS[\"rectangle\"] = 4] = \"rectangle\";\n})(DrawOPS || (DrawOPS = {})); //# sourceMappingURL=PathGeometry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9QYXRoR2VvbWV0cnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxJQUFJQSxhQUFhO0FBQ3ZCLFVBQVVBLFlBQVk7SUFDbkJBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDOUNBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDMUNBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDMUNBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7QUFDbEQsR0FBR0EsZ0JBQWlCQSxDQUFBQSxlQUFlLENBQUM7QUFDN0IsSUFBSUMsUUFBUTtBQUNsQixVQUFVQSxPQUFPO0lBQ2RBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDakNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDakNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDbENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDcENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7QUFDeEMsR0FBR0EsV0FBWUEsQ0FBQUEsVUFBVSxDQUFDLEtBQzFCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWNhcmVlci1hc3Npc3RhbnQvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9QYXRoR2VvbWV0cnkuanM/MmFhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIFBhdGhHZW9tZXRyeTtcbihmdW5jdGlvbiAoUGF0aEdlb21ldHJ5KSB7XG4gICAgUGF0aEdlb21ldHJ5W1BhdGhHZW9tZXRyeVtcInVuZGVmaW5lZFwiXSA9IDBdID0gXCJ1bmRlZmluZWRcIjtcbiAgICBQYXRoR2VvbWV0cnlbUGF0aEdlb21ldHJ5W1wiaGxpbmVcIl0gPSAxXSA9IFwiaGxpbmVcIjtcbiAgICBQYXRoR2VvbWV0cnlbUGF0aEdlb21ldHJ5W1widmxpbmVcIl0gPSAyXSA9IFwidmxpbmVcIjtcbiAgICBQYXRoR2VvbWV0cnlbUGF0aEdlb21ldHJ5W1wicmVjdGFuZ2xlXCJdID0gM10gPSBcInJlY3RhbmdsZVwiO1xufSkoUGF0aEdlb21ldHJ5IHx8IChQYXRoR2VvbWV0cnkgPSB7fSkpO1xuZXhwb3J0IHZhciBEcmF3T1BTO1xuKGZ1bmN0aW9uIChEcmF3T1BTKSB7XG4gICAgRHJhd09QU1tEcmF3T1BTW1wibW92ZVRvXCJdID0gMF0gPSBcIm1vdmVUb1wiO1xuICAgIERyYXdPUFNbRHJhd09QU1tcImxpbmVUb1wiXSA9IDFdID0gXCJsaW5lVG9cIjtcbiAgICBEcmF3T1BTW0RyYXdPUFNbXCJjdXJ2ZVRvXCJdID0gMl0gPSBcImN1cnZlVG9cIjtcbiAgICBEcmF3T1BTW0RyYXdPUFNbXCJjbG9zZVBhdGhcIl0gPSAzXSA9IFwiY2xvc2VQYXRoXCI7XG4gICAgRHJhd09QU1tEcmF3T1BTW1wicmVjdGFuZ2xlXCJdID0gNF0gPSBcInJlY3RhbmdsZVwiO1xufSkoRHJhd09QUyB8fCAoRHJhd09QUyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXRoR2VvbWV0cnkuanMubWFwIl0sIm5hbWVzIjpbIlBhdGhHZW9tZXRyeSIsIkRyYXdPUFMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/PathGeometry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/ScreenshotResult.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/ScreenshotResult.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScreenshotResult: () => (/* binding */ ScreenshotResult)\n/* harmony export */ });\n/**\n * @public\n * ScreenshotResult\n */ class ScreenshotResult {\n    constructor(total){\n        this.pages = [];\n        this.total = 0;\n        this.total = total;\n    }\n} //# sourceMappingURL=ScreenshotResult.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9TY3JlZW5zaG90UmVzdWx0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0FDTSxNQUFNQTtJQUdUQyxZQUFZQyxLQUFLLENBQUU7YUFGbkJDLFFBQVEsRUFBRTthQUNWRCxRQUFRO1FBRUosSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0lBQ2pCO0FBQ0osRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1jYXJlZXItYXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL3BkZi1wYXJzZS9kaXN0L3BkZi1wYXJzZS9lc20vU2NyZWVuc2hvdFJlc3VsdC5qcz9mNGVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHB1YmxpY1xuICogU2NyZWVuc2hvdFJlc3VsdFxuICovXG5leHBvcnQgY2xhc3MgU2NyZWVuc2hvdFJlc3VsdCB7XG4gICAgcGFnZXMgPSBbXTtcbiAgICB0b3RhbCA9IDA7XG4gICAgY29uc3RydWN0b3IodG90YWwpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjcmVlbnNob3RSZXN1bHQuanMubWFwIl0sIm5hbWVzIjpbIlNjcmVlbnNob3RSZXN1bHQiLCJjb25zdHJ1Y3RvciIsInRvdGFsIiwicGFnZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/ScreenshotResult.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/TableResult.js":
/*!******************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/TableResult.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TableResult: () => (/* binding */ TableResult)\n/* harmony export */ });\n/**\n * @public\n * TableResult\n */ class TableResult {\n    constructor(total){\n        this.pages = [];\n        this.mergedTables = [];\n        this.total = 0;\n        this.total = total;\n    }\n} //# sourceMappingURL=TableResult.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9UYWJsZVJlc3VsdC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7OztDQUdDLEdBQ00sTUFBTUE7SUFJVEMsWUFBWUMsS0FBSyxDQUFFO2FBSG5CQyxRQUFRLEVBQUU7YUFDVkMsZUFBZSxFQUFFO2FBQ2pCRixRQUFRO1FBRUosSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0lBQ2pCO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1jYXJlZXItYXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL3BkZi1wYXJzZS9kaXN0L3BkZi1wYXJzZS9lc20vVGFibGVSZXN1bHQuanM/OTA2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwdWJsaWNcbiAqIFRhYmxlUmVzdWx0XG4gKi9cbmV4cG9ydCBjbGFzcyBUYWJsZVJlc3VsdCB7XG4gICAgcGFnZXMgPSBbXTtcbiAgICBtZXJnZWRUYWJsZXMgPSBbXTtcbiAgICB0b3RhbCA9IDA7XG4gICAgY29uc3RydWN0b3IodG90YWwpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRhYmxlUmVzdWx0LmpzLm1hcCJdLCJuYW1lcyI6WyJUYWJsZVJlc3VsdCIsImNvbnN0cnVjdG9yIiwidG90YWwiLCJwYWdlcyIsIm1lcmdlZFRhYmxlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/TableResult.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/TextResult.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/TextResult.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextResult: () => (/* binding */ TextResult)\n/* harmony export */ });\n/**\n * @public\n * TextResult\n */ class TextResult {\n    getPageText(num) {\n        for (const pageData of this.pages){\n            if (pageData.num === num) return pageData.text;\n        }\n        return \"\";\n    }\n    constructor(total){\n        this.pages = [];\n        this.text = \"\";\n        this.total = 0;\n        this.total = total;\n    }\n} //# sourceMappingURL=TextResult.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9UZXh0UmVzdWx0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0FDTSxNQUFNQTtJQUlUQyxZQUFZQyxHQUFHLEVBQUU7UUFDYixLQUFLLE1BQU1DLFlBQVksSUFBSSxDQUFDQyxLQUFLLENBQUU7WUFDL0IsSUFBSUQsU0FBU0QsR0FBRyxLQUFLQSxLQUNqQixPQUFPQyxTQUFTRSxJQUFJO1FBQzVCO1FBQ0EsT0FBTztJQUNYO0lBQ0FDLFlBQVlDLEtBQUssQ0FBRTthQVZuQkgsUUFBUSxFQUFFO2FBQ1ZDLE9BQU87YUFDUEUsUUFBUTtRQVNKLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNqQjtBQUNKLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktY2FyZWVyLWFzc2lzdGFudC8uL25vZGVfbW9kdWxlcy9wZGYtcGFyc2UvZGlzdC9wZGYtcGFyc2UvZXNtL1RleHRSZXN1bHQuanM/MDg4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwdWJsaWNcbiAqIFRleHRSZXN1bHRcbiAqL1xuZXhwb3J0IGNsYXNzIFRleHRSZXN1bHQge1xuICAgIHBhZ2VzID0gW107XG4gICAgdGV4dCA9ICcnO1xuICAgIHRvdGFsID0gMDtcbiAgICBnZXRQYWdlVGV4dChudW0pIHtcbiAgICAgICAgZm9yIChjb25zdCBwYWdlRGF0YSBvZiB0aGlzLnBhZ2VzKSB7XG4gICAgICAgICAgICBpZiAocGFnZURhdGEubnVtID09PSBudW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZ2VEYXRhLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0b3RhbCkge1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dFJlc3VsdC5qcy5tYXAiXSwibmFtZXMiOlsiVGV4dFJlc3VsdCIsImdldFBhZ2VUZXh0IiwibnVtIiwicGFnZURhdGEiLCJwYWdlcyIsInRleHQiLCJjb25zdHJ1Y3RvciIsInRvdGFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/TextResult.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Line.js":
/*!********************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Line.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   LineDirection: () => (/* binding */ LineDirection)\n/* harmony export */ });\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Point.js\");\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Shape.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Shape.js\");\n\n\nvar LineDirection;\n(function(LineDirection) {\n    LineDirection[LineDirection[\"None\"] = 0] = \"None\";\n    LineDirection[LineDirection[\"Horizontal\"] = 1] = \"Horizontal\";\n    LineDirection[LineDirection[\"Vertical\"] = 2] = \"Vertical\";\n})(LineDirection || (LineDirection = {}));\nclass Line extends _Shape_js__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(from, to){\n        super();\n        this.direction = LineDirection.None;\n        this.length = 0;\n        this.intersections = [];\n        this.gaps = [];\n        this._valid = undefined;\n        this.from = from;\n        this.to = to;\n        this.init();\n    }\n    init() {\n        let from = this.from;\n        let to = this.to;\n        if (Math.abs(from.y - to.y) < _Shape_js__WEBPACK_IMPORTED_MODULE_1__.Shape.tolerance) {\n            this.direction = LineDirection.Horizontal;\n            to.y = from.y;\n            if (from.x > to.x) {\n                const temp = from;\n                from = to;\n                to = temp;\n            }\n            this.length = to.x - from.x;\n        } else if (Math.abs(from.x - to.x) < _Shape_js__WEBPACK_IMPORTED_MODULE_1__.Shape.tolerance) {\n            this.direction = LineDirection.Vertical;\n            to.x = from.x;\n            if (from.y > to.y) {\n                const temp = from;\n                from = to;\n                to = temp;\n            }\n            this.length = to.y - from.y;\n        }\n        this.from = from;\n        this.to = to;\n    }\n    get valid() {\n        if (this._valid === undefined) {\n            this._valid = this.direction !== LineDirection.None && this.length > _Shape_js__WEBPACK_IMPORTED_MODULE_1__.Shape.tolerance;\n        }\n        return this._valid;\n    }\n    get normalized() {\n        if (this.direction === LineDirection.Horizontal) {\n            return new Line(new _Point_js__WEBPACK_IMPORTED_MODULE_0__.Point(this.from.x - _Shape_js__WEBPACK_IMPORTED_MODULE_1__.Shape.tolerance, this.from.y), new _Point_js__WEBPACK_IMPORTED_MODULE_0__.Point(this.to.x + _Shape_js__WEBPACK_IMPORTED_MODULE_1__.Shape.tolerance, this.from.y));\n        } else if (this.direction === LineDirection.Vertical) {\n            return new Line(new _Point_js__WEBPACK_IMPORTED_MODULE_0__.Point(this.from.x, this.from.y - _Shape_js__WEBPACK_IMPORTED_MODULE_1__.Shape.tolerance), new _Point_js__WEBPACK_IMPORTED_MODULE_0__.Point(this.from.x, this.to.y + _Shape_js__WEBPACK_IMPORTED_MODULE_1__.Shape.tolerance));\n        }\n        return this;\n    }\n    addGap(line) {\n        this.gaps.push(line);\n    }\n    containsPoint(p) {\n        if (this.direction === LineDirection.Vertical) {\n            return this.from.x === p.x && p.y >= this.from.y && p.y <= this.to.y;\n        } else if (this.direction === LineDirection.Horizontal) {\n            return this.from.y === p.y && p.x >= this.from.x && p.x <= this.to.x;\n        }\n        return false;\n    }\n    // // todo implement\n    // public containsLine(l:Line):boolean{\n    //     if(this.direction === LineDirection.Vertical && l.direction === LineDirection.Vertical){\n    //         return this.from.x === l.from.x\n    //     }\n    //     else if(this.direction === LineDirection.Horizontal && l.direction === LineDirection.Horizontal){\n    //         return this.from.y === l.from.y\n    //     }\n    //     return false\n    // }\n    addIntersectionPoint(point) {\n        for (const intPoint of this.intersections){\n            if (intPoint.equal(point)) return;\n        }\n        this.intersections.push(point);\n    }\n    intersection(line) {\n        let result;\n        if (!this.valid || !line.valid) {\n            return result;\n        }\n        const thisNormalized = this.normalized;\n        const lineNormalized = line.normalized;\n        if (this.direction === LineDirection.Horizontal && line.direction === LineDirection.Vertical) {\n            const x = lineNormalized.from.x;\n            const y = thisNormalized.from.y;\n            const isOk = x > thisNormalized.from.x && x < thisNormalized.to.x && y > lineNormalized.from.y && y < lineNormalized.to.y;\n            if (isOk) {\n                const intPoint = new _Point_js__WEBPACK_IMPORTED_MODULE_0__.Point(x, y);\n                this.addIntersectionPoint(intPoint);\n                line.addIntersectionPoint(intPoint);\n                result = intPoint;\n            }\n        } else if (this.direction === LineDirection.Vertical && line.direction === LineDirection.Horizontal) {\n            const x = thisNormalized.from.x;\n            const y = lineNormalized.from.y;\n            const isOk = x > lineNormalized.from.x && x < lineNormalized.to.x && y > thisNormalized.from.y && y < thisNormalized.to.y;\n            if (isOk) {\n                const intPoint = new _Point_js__WEBPACK_IMPORTED_MODULE_0__.Point(x, y);\n                this.addIntersectionPoint(intPoint);\n                line.addIntersectionPoint(intPoint);\n                result = intPoint;\n            }\n        }\n        // if(result){\n        //     for (const gapLine of this.gaps) {\n        //         if(gapLine.containsPoint(result)) return undefined\n        //     }\n        //\n        //     for (const gapLine of line.gaps) {\n        //         if(gapLine.containsPoint(result)) return undefined\n        //     }\n        // }\n        return result;\n    }\n    transform(matrix) {\n        const p1 = this.from.transform(matrix);\n        const p2 = this.to.transform(matrix);\n        const x = Math.min(p1.x, p2.x);\n        const y = Math.min(p1.y, p2.y);\n        const width = Math.abs(p1.x - p2.x);\n        const height = Math.abs(p1.y - p2.y);\n        this.from = new _Point_js__WEBPACK_IMPORTED_MODULE_0__.Point(x, y);\n        this.to = new _Point_js__WEBPACK_IMPORTED_MODULE_0__.Point(x + width, y + height);\n        this.init();\n        return this;\n    }\n} //# sourceMappingURL=Line.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9nZW9tZXRyeS9MaW5lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBbUM7QUFDQTtBQUM1QixJQUFJRSxjQUFjO0FBQ3hCLFVBQVVBLGFBQWE7SUFDcEJBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDM0NBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDakRBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7QUFDbkQsR0FBR0EsaUJBQWtCQSxDQUFBQSxnQkFBZ0IsQ0FBQztBQUMvQixNQUFNQyxhQUFhRiw0Q0FBS0E7SUFPM0JHLFlBQVlDLElBQUksRUFBRUMsRUFBRSxDQUFFO1FBQ2xCLEtBQUs7YUFMVEMsWUFBWUwsY0FBY00sSUFBSTthQUM5QkMsU0FBUzthQUNUQyxnQkFBZ0IsRUFBRTthQUNsQkMsT0FBTyxFQUFFO2FBaUNUQyxTQUFTQztRQTlCTCxJQUFJLENBQUNSLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNRLElBQUk7SUFDYjtJQUNBQSxPQUFPO1FBQ0gsSUFBSVQsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDcEIsSUFBSUMsS0FBSyxJQUFJLENBQUNBLEVBQUU7UUFDaEIsSUFBSVMsS0FBS0MsR0FBRyxDQUFDWCxLQUFLWSxDQUFDLEdBQUdYLEdBQUdXLENBQUMsSUFBSWhCLDRDQUFLQSxDQUFDaUIsU0FBUyxFQUFFO1lBQzNDLElBQUksQ0FBQ1gsU0FBUyxHQUFHTCxjQUFjaUIsVUFBVTtZQUN6Q2IsR0FBR1csQ0FBQyxHQUFHWixLQUFLWSxDQUFDO1lBQ2IsSUFBSVosS0FBS2UsQ0FBQyxHQUFHZCxHQUFHYyxDQUFDLEVBQUU7Z0JBQ2YsTUFBTUMsT0FBT2hCO2dCQUNiQSxPQUFPQztnQkFDUEEsS0FBS2U7WUFD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QUdzQixHQUFHdEIsQ0FBQztRQUNsQyxNQUFNeUIsU0FBUzlCLEtBQUtDLEdBQUcsQ0FBQ3lCLEdBQUd4QixDQUFDLEdBQUd5QixHQUFHekIsQ0FBQztRQUNuQyxJQUFJLENBQUNaLElBQUksR0FBRyxJQUFJTCw0Q0FBS0EsQ0FBQ29CLEdBQUdIO1FBQ3pCLElBQUksQ0FBQ1gsRUFBRSxHQUFHLElBQUlOLDRDQUFLQSxDQUFDb0IsSUFBSXdCLE9BQU8zQixJQUFJNEI7UUFDbkMsSUFBSSxDQUFDL0IsSUFBSTtRQUNULE9BQU8sSUFBSTtJQUNmO0FBQ0osRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1jYXJlZXItYXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL3BkZi1wYXJzZS9kaXN0L3BkZi1wYXJzZS9lc20vZ2VvbWV0cnkvTGluZS5qcz8xYWYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9Qb2ludC5qcyc7XG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4vU2hhcGUuanMnO1xuZXhwb3J0IHZhciBMaW5lRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChMaW5lRGlyZWN0aW9uKSB7XG4gICAgTGluZURpcmVjdGlvbltMaW5lRGlyZWN0aW9uW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgTGluZURpcmVjdGlvbltMaW5lRGlyZWN0aW9uW1wiSG9yaXpvbnRhbFwiXSA9IDFdID0gXCJIb3Jpem9udGFsXCI7XG4gICAgTGluZURpcmVjdGlvbltMaW5lRGlyZWN0aW9uW1wiVmVydGljYWxcIl0gPSAyXSA9IFwiVmVydGljYWxcIjtcbn0pKExpbmVEaXJlY3Rpb24gfHwgKExpbmVEaXJlY3Rpb24gPSB7fSkpO1xuZXhwb3J0IGNsYXNzIExpbmUgZXh0ZW5kcyBTaGFwZSB7XG4gICAgZnJvbTtcbiAgICB0bztcbiAgICBkaXJlY3Rpb24gPSBMaW5lRGlyZWN0aW9uLk5vbmU7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgZ2FwcyA9IFtdO1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGxldCBmcm9tID0gdGhpcy5mcm9tO1xuICAgICAgICBsZXQgdG8gPSB0aGlzLnRvO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZnJvbS55IC0gdG8ueSkgPCBTaGFwZS50b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gTGluZURpcmVjdGlvbi5Ib3Jpem9udGFsO1xuICAgICAgICAgICAgdG8ueSA9IGZyb20ueTtcbiAgICAgICAgICAgIGlmIChmcm9tLnggPiB0by54KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcCA9IGZyb207XG4gICAgICAgICAgICAgICAgZnJvbSA9IHRvO1xuICAgICAgICAgICAgICAgIHRvID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdG8ueCAtIGZyb20ueDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhmcm9tLnggLSB0by54KSA8IFNoYXBlLnRvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBMaW5lRGlyZWN0aW9uLlZlcnRpY2FsO1xuICAgICAgICAgICAgdG8ueCA9IGZyb20ueDtcbiAgICAgICAgICAgIGlmIChmcm9tLnkgPiB0by55KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcCA9IGZyb207XG4gICAgICAgICAgICAgICAgZnJvbSA9IHRvO1xuICAgICAgICAgICAgICAgIHRvID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdG8ueSAtIGZyb20ueTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIF92YWxpZCA9IHVuZGVmaW5lZDtcbiAgICBnZXQgdmFsaWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl92YWxpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl92YWxpZCA9IHRoaXMuZGlyZWN0aW9uICE9PSBMaW5lRGlyZWN0aW9uLk5vbmUgJiYgdGhpcy5sZW5ndGggPiBTaGFwZS50b2xlcmFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkO1xuICAgIH1cbiAgICBnZXQgbm9ybWFsaXplZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSBMaW5lRGlyZWN0aW9uLkhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGluZShuZXcgUG9pbnQodGhpcy5mcm9tLnggLSBTaGFwZS50b2xlcmFuY2UsIHRoaXMuZnJvbS55KSwgbmV3IFBvaW50KHRoaXMudG8ueCArIFNoYXBlLnRvbGVyYW5jZSwgdGhpcy5mcm9tLnkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gTGluZURpcmVjdGlvbi5WZXJ0aWNhbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lKG5ldyBQb2ludCh0aGlzLmZyb20ueCwgdGhpcy5mcm9tLnkgLSBTaGFwZS50b2xlcmFuY2UpLCBuZXcgUG9pbnQodGhpcy5mcm9tLngsIHRoaXMudG8ueSArIFNoYXBlLnRvbGVyYW5jZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRHYXAobGluZSkge1xuICAgICAgICB0aGlzLmdhcHMucHVzaChsaW5lKTtcbiAgICB9XG4gICAgY29udGFpbnNQb2ludChwKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gTGluZURpcmVjdGlvbi5WZXJ0aWNhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbS54ID09PSBwLnggJiYgcC55ID49IHRoaXMuZnJvbS55ICYmIHAueSA8PSB0aGlzLnRvLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJlY3Rpb24gPT09IExpbmVEaXJlY3Rpb24uSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbS55ID09PSBwLnkgJiYgcC54ID49IHRoaXMuZnJvbS54ICYmIHAueCA8PSB0aGlzLnRvLng7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyAvLyB0b2RvIGltcGxlbWVudFxuICAgIC8vIHB1YmxpYyBjb250YWluc0xpbmUobDpMaW5lKTpib29sZWFue1xuICAgIC8vICAgICBpZih0aGlzLmRpcmVjdGlvbiA9PT0gTGluZURpcmVjdGlvbi5WZXJ0aWNhbCAmJiBsLmRpcmVjdGlvbiA9PT0gTGluZURpcmVjdGlvbi5WZXJ0aWNhbCl7XG4gICAgLy8gICAgICAgICByZXR1cm4gdGhpcy5mcm9tLnggPT09IGwuZnJvbS54XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgZWxzZSBpZih0aGlzLmRpcmVjdGlvbiA9PT0gTGluZURpcmVjdGlvbi5Ib3Jpem9udGFsICYmIGwuZGlyZWN0aW9uID09PSBMaW5lRGlyZWN0aW9uLkhvcml6b250YWwpe1xuICAgIC8vICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbS55ID09PSBsLmZyb20ueVxuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHJldHVybiBmYWxzZVxuICAgIC8vIH1cbiAgICBhZGRJbnRlcnNlY3Rpb25Qb2ludChwb2ludCkge1xuICAgICAgICBmb3IgKGNvbnN0IGludFBvaW50IG9mIHRoaXMuaW50ZXJzZWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKGludFBvaW50LmVxdWFsKHBvaW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25zLnB1c2gocG9pbnQpO1xuICAgIH1cbiAgICBpbnRlcnNlY3Rpb24obGluZSkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoIXRoaXMudmFsaWQgfHwgIWxpbmUudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhpc05vcm1hbGl6ZWQgPSB0aGlzLm5vcm1hbGl6ZWQ7XG4gICAgICAgIGNvbnN0IGxpbmVOb3JtYWxpemVkID0gbGluZS5ub3JtYWxpemVkO1xuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09IExpbmVEaXJlY3Rpb24uSG9yaXpvbnRhbCAmJiBsaW5lLmRpcmVjdGlvbiA9PT0gTGluZURpcmVjdGlvbi5WZXJ0aWNhbCkge1xuICAgICAgICAgICAgY29uc3QgeCA9IGxpbmVOb3JtYWxpemVkLmZyb20ueDtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzTm9ybWFsaXplZC5mcm9tLnk7XG4gICAgICAgICAgICBjb25zdCBpc09rID0geCA+IHRoaXNOb3JtYWxpemVkLmZyb20ueCAmJiB4IDwgdGhpc05vcm1hbGl6ZWQudG8ueCAmJiB5ID4gbGluZU5vcm1hbGl6ZWQuZnJvbS55ICYmIHkgPCBsaW5lTm9ybWFsaXplZC50by55O1xuICAgICAgICAgICAgaWYgKGlzT2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEludGVyc2VjdGlvblBvaW50KGludFBvaW50KTtcbiAgICAgICAgICAgICAgICBsaW5lLmFkZEludGVyc2VjdGlvblBvaW50KGludFBvaW50KTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnRQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gTGluZURpcmVjdGlvbi5WZXJ0aWNhbCAmJiBsaW5lLmRpcmVjdGlvbiA9PT0gTGluZURpcmVjdGlvbi5Ib3Jpem9udGFsKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gdGhpc05vcm1hbGl6ZWQuZnJvbS54O1xuICAgICAgICAgICAgY29uc3QgeSA9IGxpbmVOb3JtYWxpemVkLmZyb20ueTtcbiAgICAgICAgICAgIGNvbnN0IGlzT2sgPSB4ID4gbGluZU5vcm1hbGl6ZWQuZnJvbS54ICYmIHggPCBsaW5lTm9ybWFsaXplZC50by54ICYmIHkgPiB0aGlzTm9ybWFsaXplZC5mcm9tLnkgJiYgeSA8IHRoaXNOb3JtYWxpemVkLnRvLnk7XG4gICAgICAgICAgICBpZiAoaXNPaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludFBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW50ZXJzZWN0aW9uUG9pbnQoaW50UG9pbnQpO1xuICAgICAgICAgICAgICAgIGxpbmUuYWRkSW50ZXJzZWN0aW9uUG9pbnQoaW50UG9pbnQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGludFBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmKHJlc3VsdCl7XG4gICAgICAgIC8vICAgICBmb3IgKGNvbnN0IGdhcExpbmUgb2YgdGhpcy5nYXBzKSB7XG4gICAgICAgIC8vICAgICAgICAgaWYoZ2FwTGluZS5jb250YWluc1BvaW50KHJlc3VsdCkpIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIGZvciAoY29uc3QgZ2FwTGluZSBvZiBsaW5lLmdhcHMpIHtcbiAgICAgICAgLy8gICAgICAgICBpZihnYXBMaW5lLmNvbnRhaW5zUG9pbnQocmVzdWx0KSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRyYW5zZm9ybShtYXRyaXgpIHtcbiAgICAgICAgY29uc3QgcDEgPSB0aGlzLmZyb20udHJhbnNmb3JtKG1hdHJpeCk7XG4gICAgICAgIGNvbnN0IHAyID0gdGhpcy50by50cmFuc2Zvcm0obWF0cml4KTtcbiAgICAgICAgY29uc3QgeCA9IE1hdGgubWluKHAxLngsIHAyLngpO1xuICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4ocDEueSwgcDIueSk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5hYnMocDEueCAtIHAyLngpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyhwMS55IC0gcDIueSk7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgdGhpcy50byA9IG5ldyBQb2ludCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGluZS5qcy5tYXAiXSwibmFtZXMiOlsiUG9pbnQiLCJTaGFwZSIsIkxpbmVEaXJlY3Rpb24iLCJMaW5lIiwiY29uc3RydWN0b3IiLCJmcm9tIiwidG8iLCJkaXJlY3Rpb24iLCJOb25lIiwibGVuZ3RoIiwiaW50ZXJzZWN0aW9ucyIsImdhcHMiLCJfdmFsaWQiLCJ1bmRlZmluZWQiLCJpbml0IiwiTWF0aCIsImFicyIsInkiLCJ0b2xlcmFuY2UiLCJIb3Jpem9udGFsIiwieCIsInRlbXAiLCJWZXJ0aWNhbCIsInZhbGlkIiwibm9ybWFsaXplZCIsImFkZEdhcCIsImxpbmUiLCJwdXNoIiwiY29udGFpbnNQb2ludCIsInAiLCJhZGRJbnRlcnNlY3Rpb25Qb2ludCIsInBvaW50IiwiaW50UG9pbnQiLCJlcXVhbCIsImludGVyc2VjdGlvbiIsInJlc3VsdCIsInRoaXNOb3JtYWxpemVkIiwibGluZU5vcm1hbGl6ZWQiLCJpc09rIiwidHJhbnNmb3JtIiwibWF0cml4IiwicDEiLCJwMiIsIm1pbiIsIndpZHRoIiwiaGVpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Line.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/LineStore.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/LineStore.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineStore: () => (/* binding */ LineStore)\n/* harmony export */ });\n/* harmony import */ var _Line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Line.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Line.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Point.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Point.js\");\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Shape.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Shape.js\");\n/* harmony import */ var _Table_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Table.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Table.js\");\n\n\n\n\nclass LineStore {\n    add(line) {\n        if (line.valid) {\n            if (line.direction === _Line_js__WEBPACK_IMPORTED_MODULE_0__.LineDirection.Horizontal) {\n                this.hLines.push(line);\n            } else if (line.direction === _Line_js__WEBPACK_IMPORTED_MODULE_0__.LineDirection.Vertical) {\n                this.vLines.push(line);\n            }\n        }\n    }\n    addRectangle(rect) {\n        for (const line of rect.getLines()){\n            this.add(line);\n        }\n    }\n    getTableData() {\n        const result = [];\n        const tables = this.getTables();\n        for (const table of tables){\n            const data = table.toData();\n            if (data) {\n                result.push(data);\n            }\n        }\n        return result;\n    }\n    getTables() {\n        const result = [];\n        while(this.hLines.length !== 0){\n            const hLine = this.hLines.shift();\n            if (!hLine) continue;\n            const filled = this.tryFill(result, hLine);\n            if (filled) continue;\n            const table = new _Table_js__WEBPACK_IMPORTED_MODULE_3__.Table(hLine);\n            this.fillTable(table);\n            result.push(table);\n        }\n        while(this.vLines.length !== 0){\n            const vLine = this.vLines.shift();\n            if (!vLine) continue;\n            const filled = this.tryFill(result, vLine);\n            if (filled) continue;\n            const table = new _Table_js__WEBPACK_IMPORTED_MODULE_3__.Table(vLine);\n            this.fillTable(table);\n            result.push(table);\n        }\n        const validTables = result.filter((t)=>t.isValid);\n        for (const table of validTables){\n            table.normalize();\n        }\n        return validTables;\n    }\n    normalize() {\n        this.normalizeHorizontal();\n        this.normalizeVertical();\n    }\n    normalizeHorizontal() {\n        this.hLines.sort((l1, l2)=>l1.from.y - l2.from.y);\n        const newLines = [];\n        let sameY = [];\n        for (const line of this.hLines){\n            if (sameY.length === 0) {\n                sameY.push(line);\n            } else if (Math.abs(sameY[0]?.from.y - line.from.y) < _Shape_js__WEBPACK_IMPORTED_MODULE_2__.Shape.tolerance) {\n                sameY.push(line);\n            } else {\n                const merged = this.margeHorizontalLines(sameY);\n                newLines.push(...merged);\n                sameY = [\n                    line\n                ];\n            }\n        }\n        if (sameY.length > 0) {\n            const merged = this.margeHorizontalLines(sameY);\n            newLines.push(...merged);\n        }\n        this.hLines = newLines;\n    }\n    normalizeVertical() {\n        this.vLines.sort((l1, l2)=>l1.from.x - l2.from.x);\n        const newLines = [];\n        let sameX = [];\n        for (const line of this.vLines){\n            if (sameX.length === 0) {\n                sameX.push(line);\n            } else if (Math.abs(sameX[0]?.from.x - line.from.x) < _Shape_js__WEBPACK_IMPORTED_MODULE_2__.Shape.tolerance) {\n                sameX.push(line);\n            } else {\n                const merged = this.margeVerticalLines(sameX);\n                newLines.push(...merged);\n                sameX = [\n                    line\n                ];\n            }\n        }\n        if (sameX.length > 0) {\n            const merged = this.margeVerticalLines(sameX);\n            newLines.push(...merged);\n        }\n        this.vLines = newLines;\n    }\n    fillTable(table) {\n        const newVLines = [];\n        const newHLines = [];\n        for (const vLine of this.vLines){\n            if (!table.add(vLine)) {\n                newVLines.push(vLine);\n            }\n        }\n        for (const hLine of this.hLines){\n            if (!table.add(hLine)) {\n                newHLines.push(hLine);\n            }\n        }\n        this.hLines = newHLines;\n        this.vLines = newVLines;\n    }\n    tryFill(tables, line) {\n        for (const table of tables){\n            if (table.add(line)) {\n                this.fillTable(table);\n                return true;\n            }\n        }\n        return false;\n    }\n    margeHorizontalLines(sameYLines) {\n        const result = [];\n        sameYLines.sort((l1, l2)=>l1.from.x - l2.from.x);\n        const sameY = sameYLines[0]?.from.y;\n        if (sameY === undefined) return result;\n        let minX = Number.MAX_SAFE_INTEGER;\n        let maxX = Number.MIN_SAFE_INTEGER;\n        for (const line of sameYLines){\n            if (line.from.x - maxX < _Shape_js__WEBPACK_IMPORTED_MODULE_2__.Shape.tolerance) {\n                if (line.from.x < minX) {\n                    minX = line.from.x;\n                }\n                if (line.to.x > maxX) {\n                    maxX = line.to.x;\n                }\n            } else {\n                if (maxX > minX) {\n                    result.push(new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(minX, sameY), new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(maxX, sameY)));\n                }\n                minX = line.from.x;\n                maxX = line.to.x;\n            }\n        }\n        const last = result[result.length - 1];\n        if (last) {\n            if (last.from.x !== minX && last.to.x !== maxX) {\n                result.push(new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(minX, sameY), new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(maxX, sameY)));\n            }\n        } else {\n            result.push(new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(minX, sameY), new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(maxX, sameY)));\n        }\n        return result;\n    }\n    margeVerticalLines(sameXLines) {\n        const result = [];\n        sameXLines.sort((l1, l2)=>l1.from.y - l2.from.y);\n        const sameX = sameXLines[0]?.from.x;\n        if (sameX === undefined) return result;\n        let minY = Number.MAX_SAFE_INTEGER;\n        let maxY = Number.MIN_SAFE_INTEGER;\n        for (const line of sameXLines){\n            if (line.from.y - maxY < _Shape_js__WEBPACK_IMPORTED_MODULE_2__.Shape.tolerance) {\n                if (line.from.y < minY) {\n                    minY = line.from.y;\n                }\n                if (line.to.y > maxY) {\n                    maxY = line.to.y;\n                }\n            } else {\n                if (maxY > minY) {\n                    result.push(new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(sameX, minY), new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(sameX, maxY)));\n                }\n                minY = line.from.y;\n                maxY = line.to.y;\n            }\n        }\n        const last = result[result.length - 1];\n        if (last) {\n            if (last.from.y !== minY && last.to.y !== maxY) {\n                result.push(new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(sameX, minY), new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(sameX, maxY)));\n            }\n        } else {\n            result.push(new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(sameX, minY), new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(sameX, maxY)));\n        }\n        return result;\n    }\n    constructor(){\n        this.hLines = [];\n        this.vLines = [];\n    }\n} //# sourceMappingURL=LineStore.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9nZW9tZXRyeS9MaW5lU3RvcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0Q7QUFDYjtBQUNBO0FBQ0E7QUFDNUIsTUFBTUs7SUFHVEMsSUFBSUMsSUFBSSxFQUFFO1FBQ04sSUFBSUEsS0FBS0MsS0FBSyxFQUFFO1lBQ1osSUFBSUQsS0FBS0UsU0FBUyxLQUFLUixtREFBYUEsQ0FBQ1MsVUFBVSxFQUFFO2dCQUM3QyxJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDTDtZQUNyQixPQUNLLElBQUlBLEtBQUtFLFNBQVMsS0FBS1IsbURBQWFBLENBQUNZLFFBQVEsRUFBRTtnQkFDaEQsSUFBSSxDQUFDQyxNQUFNLENBQUNGLElBQUksQ0FBQ0w7WUFDckI7UUFDSjtJQUNKO0lBQ0FRLGFBQWFDLElBQUksRUFBRTtRQUNmLEtBQUssTUFBTVQsUUFBUVMsS0FBS0MsUUFBUSxHQUFJO1lBQ2hDLElBQUksQ0FBQ1gsR0FBRyxDQUFDQztRQUNiO0lBQ0o7SUFDQVcsZUFBZTtRQUNYLE1BQU1DLFNBQVMsRUFBRTtRQUNqQixNQUFNQyxTQUFTLElBQUksQ0FBQ0MsU0FBUztRQUM3QixLQUFLLE1BQU1DLFNBQVNGLE9BQVE7WUFDeEIsTUFBTUcsT0FBT0QsTUFBTUUsTUFBTTtZQUN6QixJQUFJRCxNQUFNO2dCQUNOSixPQUFPUCxJQUFJLENBQUNXO1lBQ2hCO1FBQ0o7UUFDQSxPQUFPSjtJQUNYO0lBQ0FFLFlBQVk7UUFDUixNQUFNRixTQUFTLEVBQUU7UUFDakIsTUFBTyxJQUFJLENBQUNSLE1BQU0sQ0FBQ2MsTUFBTSxLQUFLLEVBQUc7WUFDN0IsTUFBTUMsUUFBUSxJQUFJLENBQUNmLE1BQU0sQ0FBQ2dCLEtBQUs7WUFDL0IsSUFBSSxDQUFDRCxPQUNEO1lBQ0osTUFBTUUsU0FBUyxJQUFJLENBQUNDLE9BQU8sQ0FBQ1YsUUFBUU87WUFDcEMsSUFBSUUsUUFDQTtZQUNKLE1BQU1OLFFBQVEsSUFBSWxCLDRDQUFLQSxDQUFDc0I7WUFDeEIsSUFBSSxDQUFDSSxTQUFTLENBQUNSO1lBQ2ZILE9BQU9QLElBQUksQ0FBQ1U7UUFDaEI7UUFDQSxNQUFPLElBQUksQ0FBQ1IsTUFBTSxDQUFDVyxNQUFNLEtBQUssRUFBRztZQUM3QixNQUFNTSxRQUFRLElBQUksQ0FBQ2pCLE1BQU0sQ0FBQ2EsS0FBSztZQUMvQixJQUFJLENBQUNJLE9BQ0Q7WUFDSixNQUFNSCxTQUFTLElBQUksQ0FBQ0MsT0FBTyxDQUFDVixRQUFRWTtZQUNwQyxJQUFJSCxRQUNBO1lBQ0osTUFBTU4sUUFBUSxJQUFJbEIsNENBQUtBLENBQUMyQjtZQUN4QixJQUFJLENBQUNELFNBQVMsQ0FBQ1I7WUFDZkgsT0FBT1AsSUFBSSxDQUFDVTtRQUNoQjtRQUNBLE1BQU1VLGNBQWNiLE9BQU9jLE1BQU0sQ0FBQyxDQUFDQyxJQUFNQSxFQUFFQyxPQUFPO1FBQ2xELEtBQUssTUFBTWIsU0FBU1UsWUFBYTtZQUM3QlYsTUFBTWMsU0FBUztRQUNuQjtRQUNBLE9BQU9KO0lBQ1g7SUFDQUksWUFBWTtRQUNSLElBQUksQ0FBQ0MsbUJBQW1CO1FBQ3hCLElBQUksQ0FBQ0MsaUJBQWlCO0lBQzFCO0lBQ0FELHNCQUFzQjtRQUNsQixJQUFJLENBQUMxQixNQUFNLENBQUM0QixJQUFJLENBQUMsQ0FBQ0MsSUFBSUMsS0FBT0QsR0FBR0UsSUFBSSxDQUFDQyxDQUFDLEdBQUdGLEdBQUdDLElBQUksQ0FBQ0MsQ0FBQztRQUNsRCxNQUFNQyxXQUFXLEVBQUU7UUFDbkIsSUFBSUMsUUFBUSxFQUFFO1FBQ2QsS0FBSyxNQUFNdEMsUUFBUSxJQUFJLENBQUNJLE1BQU0sQ0FBRTtZQUM1QixJQUFJa0MsTUFBTXBCLE1BQU0sS0FBSyxHQUFHO2dCQUNwQm9CLE1BQU1qQyxJQUFJLENBQUNMO1lBQ2YsT0FDSyxJQUFJdUMsS0FBS0MsR0FBRyxDQUFDRixLQUFLLENBQUMsRUFBRSxFQUFFSCxLQUFLQyxJQUFJcEMsS0FBS21DLElBQUksQ0FBQ0MsQ0FBQyxJQUFJeEMsNENBQUtBLENBQUM2QyxTQUFTLEVBQUU7Z0JBQ2pFSCxNQUFNakMsSUFBSSxDQUFDTDtZQUNmLE9BQ0s7Z0JBQ0QsTUFBTTBDLFNBQVMsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ0w7Z0JBQ3pDRCxTQUFTaEMsSUFBSSxJQUFJcUM7Z0JBQ2pCSixRQUFRO29CQUFDdEM7aUJBQUs7WUFDbEI7UUFDSjtRQUNBLElBQUlzQyxNQUFNcEIsTUFBTSxHQUFHLEdBQUc7WUFDbEIsTUFBTXdCLFNBQVMsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ0w7WUFDekNELFNBQVNoQyxJQUFJLElBQUlxQztRQUNyQjtRQUNBLElBQUksQ0FBQ3RDLE1BQU0sR0FBR2lDO0lBQ2xCO0lBQ0FOLG9CQUFvQjtRQUNoQixJQUFJLENBQUN4QixNQUFNLENBQUN5QixJQUFJLENBQUMsQ0FBQ0MsSUFBSUMsS0FBT0QsR0FBR0UsSUFBSSxDQUFDUyxDQUFDLEdBQUdWLEdBQUdDLElBQUksQ0FBQ1MsQ0FBQztRQUNsRCxNQUFNUCxXQUFXLEVBQUU7UUFDbkIsSUFBSVEsUUFBUSxFQUFFO1FBQ2QsS0FBSyxNQUFNN0MsUUFBUSxJQUFJLENBQUNPLE1BQU0sQ0FBRTtZQUM1QixJQUFJc0MsTUFBTTNCLE1BQU0sS0FBSyxHQUFHO2dCQUNwQjJCLE1BQU14QyxJQUFJLENBQUNMO1lBQ2YsT0FDSyxJQUFJdUMsS0FBS0MsR0FBRyxDQUFDSyxLQUFLLENBQUMsRUFBRSxFQUFFVixLQUFLUyxJQUFJNUMsS0FBS21DLElBQUksQ0FBQ1MsQ0FBQyxJQUFJaEQsNENBQUtBLENBQUM2QyxTQUFTLEVBQUU7Z0JBQ2pFSSxNQUFNeEMsSUFBSSxDQUFDTDtZQUNmLE9BQ0s7Z0JBQ0QsTUFBTTBDLFNBQVMsSUFBSSxDQUFDSSxrQkFBa0IsQ0FBQ0Q7Z0JBQ3ZDUixTQUFTaEMsSUFBSSxJQUFJcUM7Z0JBQ2pCRyxRQUFRO29CQUFDN0M7aUJBQUs7WUFDbEI7UUFDSjtRQUNBLElBQUk2QyxNQUFNM0IsTUFBTSxHQUFHLEdBQUc7WUFDbEIsTUFBTXdCLFNBQVMsSUFBSSxDQUFDSSxrQkFBa0IsQ0FBQ0Q7WUFDdkNSLFNBQVNoQyxJQUFJLElBQUlxQztRQUNyQjtRQUNBLElBQUksQ0FBQ25DLE1BQU0sR0FBRzhCO0lBQ2xCO0lBQ0FkLFVBQVVSLEtBQUssRUFBRTtRQUNiLE1BQU1nQyxZQUFZLEVBQUU7UUFDcEIsTUFBTUMsWUFBWSxFQUFFO1FBQ3BCLEtBQUssTUFBTXhCLFNBQVMsSUFBSSxDQUFDakIsTUFBTSxDQUFFO1lBQzdCLElBQUksQ0FBQ1EsTUFBTWhCLEdBQUcsQ0FBQ3lCLFFBQVE7Z0JBQ25CdUIsVUFBVTFDLElBQUksQ0FBQ21CO1lBQ25CO1FBQ0o7UUFDQSxLQUFLLE1BQU1MLFNBQVMsSUFBSSxDQUFDZixNQUFNLENBQUU7WUFDN0IsSUFBSSxDQUFDVyxNQUFNaEIsR0FBRyxDQUFDb0IsUUFBUTtnQkFDbkI2QixVQUFVM0MsSUFBSSxDQUFDYztZQUNuQjtRQUNKO1FBQ0EsSUFBSSxDQUFDZixNQUFNLEdBQUc0QztRQUNkLElBQUksQ0FBQ3pDLE1BQU0sR0FBR3dDO0lBQ2xCO0lBQ0F6QixRQUFRVCxNQUFNLEVBQUViLElBQUksRUFBRTtRQUNsQixLQUFLLE1BQU1lLFNBQVNGLE9BQVE7WUFDeEIsSUFBSUUsTUFBTWhCLEdBQUcsQ0FBQ0MsT0FBTztnQkFDakIsSUFBSSxDQUFDdUIsU0FBUyxDQUFDUjtnQkFDZixPQUFPO1lBQ1g7UUFDSjtRQUNBLE9BQU87SUFDWDtJQUNBNEIscUJBQXFCTSxVQUFVLEVBQUU7UUFDN0IsTUFBTXJDLFNBQVMsRUFBRTtRQUNqQnFDLFdBQVdqQixJQUFJLENBQUMsQ0FBQ0MsSUFBSUMsS0FBT0QsR0FBR0UsSUFBSSxDQUFDUyxDQUFDLEdBQUdWLEdBQUdDLElBQUksQ0FBQ1MsQ0FBQztRQUNqRCxNQUFNTixRQUFRVyxVQUFVLENBQUMsRUFBRSxFQUFFZCxLQUFLQztRQUNsQyxJQUFJRSxVQUFVWSxXQUNWLE9BQU90QztRQUNYLElBQUl1QyxPQUFPQyxPQUFPQyxnQkFBZ0I7UUFDbEMsSUFBSUMsT0FBT0YsT0FBT0csZ0JBQWdCO1FBQ2xDLEtBQUssTUFBTXZELFFBQVFpRCxXQUFZO1lBQzNCLElBQUlqRCxLQUFLbUMsSUFBSSxDQUFDUyxDQUFDLEdBQUdVLE9BQU8xRCw0Q0FBS0EsQ0FBQzZDLFNBQVMsRUFBRTtnQkFDdEMsSUFBSXpDLEtBQUttQyxJQUFJLENBQUNTLENBQUMsR0FBR08sTUFBTTtvQkFDcEJBLE9BQU9uRCxLQUFLbUMsSUFBSSxDQUFDUyxDQUFDO2dCQUN0QjtnQkFDQSxJQUFJNUMsS0FBS3dELEVBQUUsQ0FBQ1osQ0FBQyxHQUFHVSxNQUFNO29CQUNsQkEsT0FBT3RELEtBQUt3RCxFQUFFLENBQUNaLENBQUM7Z0JBQ3BCO1lBQ0osT0FDSztnQkFDRCxJQUFJVSxPQUFPSCxNQUFNO29CQUNidkMsT0FBT1AsSUFBSSxDQUFDLElBQUlaLDBDQUFJQSxDQUFDLElBQUlFLDRDQUFLQSxDQUFDd0QsTUFBTWIsUUFBUSxJQUFJM0MsNENBQUtBLENBQUMyRCxNQUFNaEI7Z0JBQ2pFO2dCQUNBYSxPQUFPbkQsS0FBS21DLElBQUksQ0FBQ1MsQ0FBQztnQkFDbEJVLE9BQU90RCxLQUFLd0QsRUFBRSxDQUFDWixDQUFDO1lBQ3BCO1FBQ0o7UUFDQSxNQUFNYSxPQUFPN0MsTUFBTSxDQUFDQSxPQUFPTSxNQUFNLEdBQUcsRUFBRTtRQUN0QyxJQUFJdUMsTUFBTTtZQUNOLElBQUlBLEtBQUt0QixJQUFJLENBQUNTLENBQUMsS0FBS08sUUFBUU0sS0FBS0QsRUFBRSxDQUFDWixDQUFDLEtBQUtVLE1BQU07Z0JBQzVDMUMsT0FBT1AsSUFBSSxDQUFDLElBQUlaLDBDQUFJQSxDQUFDLElBQUlFLDRDQUFLQSxDQUFDd0QsTUFBTWIsUUFBUSxJQUFJM0MsNENBQUtBLENBQUMyRCxNQUFNaEI7WUFDakU7UUFDSixPQUNLO1lBQ0QxQixPQUFPUCxJQUFJLENBQUMsSUFBSVosMENBQUlBLENBQUMsSUFBSUUsNENBQUtBLENBQUN3RCxNQUFNYixRQUFRLElBQUkzQyw0Q0FBS0EsQ0FBQzJELE1BQU1oQjtRQUNqRTtRQUNBLE9BQU8xQjtJQUNYO0lBQ0FrQyxtQkFBbUJZLFVBQVUsRUFBRTtRQUMzQixNQUFNOUMsU0FBUyxFQUFFO1FBQ2pCOEMsV0FBVzFCLElBQUksQ0FBQyxDQUFDQyxJQUFJQyxLQUFPRCxHQUFHRSxJQUFJLENBQUNDLENBQUMsR0FBR0YsR0FBR0MsSUFBSSxDQUFDQyxDQUFDO1FBQ2pELE1BQU1TLFFBQVFhLFVBQVUsQ0FBQyxFQUFFLEVBQUV2QixLQUFLUztRQUNsQyxJQUFJQyxVQUFVSyxXQUNWLE9BQU90QztRQUNYLElBQUkrQyxPQUFPUCxPQUFPQyxnQkFBZ0I7UUFDbEMsSUFBSU8sT0FBT1IsT0FBT0csZ0JBQWdCO1FBQ2xDLEtBQUssTUFBTXZELFFBQVEwRCxXQUFZO1lBQzNCLElBQUkxRCxLQUFLbUMsSUFBSSxDQUFDQyxDQUFDLEdBQUd3QixPQUFPaEUsNENBQUtBLENBQUM2QyxTQUFTLEVBQUU7Z0JBQ3RDLElBQUl6QyxLQUFLbUMsSUFBSSxDQUFDQyxDQUFDLEdBQUd1QixNQUFNO29CQUNwQkEsT0FBTzNELEtBQUttQyxJQUFJLENBQUNDLENBQUM7Z0JBQ3RCO2dCQUNBLElBQUlwQyxLQUFLd0QsRUFBRSxDQUFDcEIsQ0FBQyxHQUFHd0IsTUFBTTtvQkFDbEJBLE9BQU81RCxLQUFLd0QsRUFBRSxDQUFDcEIsQ0FBQztnQkFDcEI7WUFDSixPQUNLO2dCQUNELElBQUl3QixPQUFPRCxNQUFNO29CQUNiL0MsT0FBT1AsSUFBSSxDQUFDLElBQUlaLDBDQUFJQSxDQUFDLElBQUlFLDRDQUFLQSxDQUFDa0QsT0FBT2MsT0FBTyxJQUFJaEUsNENBQUtBLENBQUNrRCxPQUFPZTtnQkFDbEU7Z0JBQ0FELE9BQU8zRCxLQUFLbUMsSUFBSSxDQUFDQyxDQUFDO2dCQUNsQndCLE9BQU81RCxLQUFLd0QsRUFBRSxDQUFDcEIsQ0FBQztZQUNwQjtRQUNKO1FBQ0EsTUFBTXFCLE9BQU83QyxNQUFNLENBQUNBLE9BQU9NLE1BQU0sR0FBRyxFQUFFO1FBQ3RDLElBQUl1QyxNQUFNO1lBQ04sSUFBSUEsS0FBS3RCLElBQUksQ0FBQ0MsQ0FBQyxLQUFLdUIsUUFBUUYsS0FBS0QsRUFBRSxDQUFDcEIsQ0FBQyxLQUFLd0IsTUFBTTtnQkFDNUNoRCxPQUFPUCxJQUFJLENBQUMsSUFBSVosMENBQUlBLENBQUMsSUFBSUUsNENBQUtBLENBQUNrRCxPQUFPYyxPQUFPLElBQUloRSw0Q0FBS0EsQ0FBQ2tELE9BQU9lO1lBQ2xFO1FBQ0osT0FDSztZQUNEaEQsT0FBT1AsSUFBSSxDQUFDLElBQUlaLDBDQUFJQSxDQUFDLElBQUlFLDRDQUFLQSxDQUFDa0QsT0FBT2MsT0FBTyxJQUFJaEUsNENBQUtBLENBQUNrRCxPQUFPZTtRQUNsRTtRQUNBLE9BQU9oRDtJQUNYOzthQTVNQVIsU0FBUyxFQUFFO2FBQ1hHLFNBQVMsRUFBRTs7QUE0TWYsRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1jYXJlZXItYXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL3BkZi1wYXJzZS9kaXN0L3BkZi1wYXJzZS9lc20vZ2VvbWV0cnkvTGluZVN0b3JlLmpzPzFiNDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTGluZSwgTGluZURpcmVjdGlvbiB9IGZyb20gJy4vTGluZS5qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vUG9pbnQuanMnO1xuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuL1NoYXBlLmpzJztcbmltcG9ydCB7IFRhYmxlIH0gZnJvbSAnLi9UYWJsZS5qcyc7XG5leHBvcnQgY2xhc3MgTGluZVN0b3JlIHtcbiAgICBoTGluZXMgPSBbXTtcbiAgICB2TGluZXMgPSBbXTtcbiAgICBhZGQobGluZSkge1xuICAgICAgICBpZiAobGluZS52YWxpZCkge1xuICAgICAgICAgICAgaWYgKGxpbmUuZGlyZWN0aW9uID09PSBMaW5lRGlyZWN0aW9uLkhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGluZS5kaXJlY3Rpb24gPT09IExpbmVEaXJlY3Rpb24uVmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFJlY3RhbmdsZShyZWN0KSB7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiByZWN0LmdldExpbmVzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFRhYmxlRGF0YSgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IHRhYmxlcyA9IHRoaXMuZ2V0VGFibGVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgdGFibGUgb2YgdGFibGVzKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGFibGUudG9EYXRhKCk7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldFRhYmxlcygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLmhMaW5lcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGhMaW5lID0gdGhpcy5oTGluZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghaExpbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBmaWxsZWQgPSB0aGlzLnRyeUZpbGwocmVzdWx0LCBoTGluZSk7XG4gICAgICAgICAgICBpZiAoZmlsbGVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgdGFibGUgPSBuZXcgVGFibGUoaExpbmUpO1xuICAgICAgICAgICAgdGhpcy5maWxsVGFibGUodGFibGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnZMaW5lcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHZMaW5lID0gdGhpcy52TGluZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghdkxpbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBmaWxsZWQgPSB0aGlzLnRyeUZpbGwocmVzdWx0LCB2TGluZSk7XG4gICAgICAgICAgICBpZiAoZmlsbGVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgdGFibGUgPSBuZXcgVGFibGUodkxpbmUpO1xuICAgICAgICAgICAgdGhpcy5maWxsVGFibGUodGFibGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkVGFibGVzID0gcmVzdWx0LmZpbHRlcigodCkgPT4gdC5pc1ZhbGlkKTtcbiAgICAgICAgZm9yIChjb25zdCB0YWJsZSBvZiB2YWxpZFRhYmxlcykge1xuICAgICAgICAgICAgdGFibGUubm9ybWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkVGFibGVzO1xuICAgIH1cbiAgICBub3JtYWxpemUoKSB7XG4gICAgICAgIHRoaXMubm9ybWFsaXplSG9yaXpvbnRhbCgpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZVZlcnRpY2FsKCk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZUhvcml6b250YWwoKSB7XG4gICAgICAgIHRoaXMuaExpbmVzLnNvcnQoKGwxLCBsMikgPT4gbDEuZnJvbS55IC0gbDIuZnJvbS55KTtcbiAgICAgICAgY29uc3QgbmV3TGluZXMgPSBbXTtcbiAgICAgICAgbGV0IHNhbWVZID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLmhMaW5lcykge1xuICAgICAgICAgICAgaWYgKHNhbWVZLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNhbWVZLnB1c2gobGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhzYW1lWVswXT8uZnJvbS55IC0gbGluZS5mcm9tLnkpIDwgU2hhcGUudG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgc2FtZVkucHVzaChsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IHRoaXMubWFyZ2VIb3Jpem9udGFsTGluZXMoc2FtZVkpO1xuICAgICAgICAgICAgICAgIG5ld0xpbmVzLnB1c2goLi4ubWVyZ2VkKTtcbiAgICAgICAgICAgICAgICBzYW1lWSA9IFtsaW5lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2FtZVkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gdGhpcy5tYXJnZUhvcml6b250YWxMaW5lcyhzYW1lWSk7XG4gICAgICAgICAgICBuZXdMaW5lcy5wdXNoKC4uLm1lcmdlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oTGluZXMgPSBuZXdMaW5lcztcbiAgICB9XG4gICAgbm9ybWFsaXplVmVydGljYWwoKSB7XG4gICAgICAgIHRoaXMudkxpbmVzLnNvcnQoKGwxLCBsMikgPT4gbDEuZnJvbS54IC0gbDIuZnJvbS54KTtcbiAgICAgICAgY29uc3QgbmV3TGluZXMgPSBbXTtcbiAgICAgICAgbGV0IHNhbWVYID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLnZMaW5lcykge1xuICAgICAgICAgICAgaWYgKHNhbWVYLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNhbWVYLnB1c2gobGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhzYW1lWFswXT8uZnJvbS54IC0gbGluZS5mcm9tLngpIDwgU2hhcGUudG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgc2FtZVgucHVzaChsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IHRoaXMubWFyZ2VWZXJ0aWNhbExpbmVzKHNhbWVYKTtcbiAgICAgICAgICAgICAgICBuZXdMaW5lcy5wdXNoKC4uLm1lcmdlZCk7XG4gICAgICAgICAgICAgICAgc2FtZVggPSBbbGluZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbWVYLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IHRoaXMubWFyZ2VWZXJ0aWNhbExpbmVzKHNhbWVYKTtcbiAgICAgICAgICAgIG5ld0xpbmVzLnB1c2goLi4ubWVyZ2VkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZMaW5lcyA9IG5ld0xpbmVzO1xuICAgIH1cbiAgICBmaWxsVGFibGUodGFibGUpIHtcbiAgICAgICAgY29uc3QgbmV3VkxpbmVzID0gW107XG4gICAgICAgIGNvbnN0IG5ld0hMaW5lcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHZMaW5lIG9mIHRoaXMudkxpbmVzKSB7XG4gICAgICAgICAgICBpZiAoIXRhYmxlLmFkZCh2TGluZSkpIHtcbiAgICAgICAgICAgICAgICBuZXdWTGluZXMucHVzaCh2TGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBoTGluZSBvZiB0aGlzLmhMaW5lcykge1xuICAgICAgICAgICAgaWYgKCF0YWJsZS5hZGQoaExpbmUpKSB7XG4gICAgICAgICAgICAgICAgbmV3SExpbmVzLnB1c2goaExpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaExpbmVzID0gbmV3SExpbmVzO1xuICAgICAgICB0aGlzLnZMaW5lcyA9IG5ld1ZMaW5lcztcbiAgICB9XG4gICAgdHJ5RmlsbCh0YWJsZXMsIGxpbmUpIHtcbiAgICAgICAgZm9yIChjb25zdCB0YWJsZSBvZiB0YWJsZXMpIHtcbiAgICAgICAgICAgIGlmICh0YWJsZS5hZGQobGluZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxUYWJsZSh0YWJsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXJnZUhvcml6b250YWxMaW5lcyhzYW1lWUxpbmVzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBzYW1lWUxpbmVzLnNvcnQoKGwxLCBsMikgPT4gbDEuZnJvbS54IC0gbDIuZnJvbS54KTtcbiAgICAgICAgY29uc3Qgc2FtZVkgPSBzYW1lWUxpbmVzWzBdPy5mcm9tLnk7XG4gICAgICAgIGlmIChzYW1lWSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgbGV0IG1pblggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgbGV0IG1heFggPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHNhbWVZTGluZXMpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20ueCAtIG1heFggPCBTaGFwZS50b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5mcm9tLnggPCBtaW5YKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblggPSBsaW5lLmZyb20ueDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudG8ueCA+IG1heFgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IGxpbmUudG8ueDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4WCA+IG1pblgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IExpbmUobmV3IFBvaW50KG1pblgsIHNhbWVZKSwgbmV3IFBvaW50KG1heFgsIHNhbWVZKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtaW5YID0gbGluZS5mcm9tLng7XG4gICAgICAgICAgICAgICAgbWF4WCA9IGxpbmUudG8ueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIGlmIChsYXN0LmZyb20ueCAhPT0gbWluWCAmJiBsYXN0LnRvLnggIT09IG1heFgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgTGluZShuZXcgUG9pbnQobWluWCwgc2FtZVkpLCBuZXcgUG9pbnQobWF4WCwgc2FtZVkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgTGluZShuZXcgUG9pbnQobWluWCwgc2FtZVkpLCBuZXcgUG9pbnQobWF4WCwgc2FtZVkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbWFyZ2VWZXJ0aWNhbExpbmVzKHNhbWVYTGluZXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHNhbWVYTGluZXMuc29ydCgobDEsIGwyKSA9PiBsMS5mcm9tLnkgLSBsMi5mcm9tLnkpO1xuICAgICAgICBjb25zdCBzYW1lWCA9IHNhbWVYTGluZXNbMF0/LmZyb20ueDtcbiAgICAgICAgaWYgKHNhbWVYID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgbWluWSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICBsZXQgbWF4WSA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygc2FtZVhMaW5lcykge1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbS55IC0gbWF4WSA8IFNoYXBlLnRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmZyb20ueSA8IG1pblkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IGxpbmUuZnJvbS55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGluZS50by55ID4gbWF4WSkge1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0gbGluZS50by55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtYXhZID4gbWluWSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgTGluZShuZXcgUG9pbnQoc2FtZVgsIG1pblkpLCBuZXcgUG9pbnQoc2FtZVgsIG1heFkpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1pblkgPSBsaW5lLmZyb20ueTtcbiAgICAgICAgICAgICAgICBtYXhZID0gbGluZS50by55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3QgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgaWYgKGxhc3QuZnJvbS55ICE9PSBtaW5ZICYmIGxhc3QudG8ueSAhPT0gbWF4WSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChzYW1lWCwgbWluWSksIG5ldyBQb2ludChzYW1lWCwgbWF4WSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChzYW1lWCwgbWluWSksIG5ldyBQb2ludChzYW1lWCwgbWF4WSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmVTdG9yZS5qcy5tYXAiXSwibmFtZXMiOlsiTGluZSIsIkxpbmVEaXJlY3Rpb24iLCJQb2ludCIsIlNoYXBlIiwiVGFibGUiLCJMaW5lU3RvcmUiLCJhZGQiLCJsaW5lIiwidmFsaWQiLCJkaXJlY3Rpb24iLCJIb3Jpem9udGFsIiwiaExpbmVzIiwicHVzaCIsIlZlcnRpY2FsIiwidkxpbmVzIiwiYWRkUmVjdGFuZ2xlIiwicmVjdCIsImdldExpbmVzIiwiZ2V0VGFibGVEYXRhIiwicmVzdWx0IiwidGFibGVzIiwiZ2V0VGFibGVzIiwidGFibGUiLCJkYXRhIiwidG9EYXRhIiwibGVuZ3RoIiwiaExpbmUiLCJzaGlmdCIsImZpbGxlZCIsInRyeUZpbGwiLCJmaWxsVGFibGUiLCJ2TGluZSIsInZhbGlkVGFibGVzIiwiZmlsdGVyIiwidCIsImlzVmFsaWQiLCJub3JtYWxpemUiLCJub3JtYWxpemVIb3Jpem9udGFsIiwibm9ybWFsaXplVmVydGljYWwiLCJzb3J0IiwibDEiLCJsMiIsImZyb20iLCJ5IiwibmV3TGluZXMiLCJzYW1lWSIsIk1hdGgiLCJhYnMiLCJ0b2xlcmFuY2UiLCJtZXJnZWQiLCJtYXJnZUhvcml6b250YWxMaW5lcyIsIngiLCJzYW1lWCIsIm1hcmdlVmVydGljYWxMaW5lcyIsIm5ld1ZMaW5lcyIsIm5ld0hMaW5lcyIsInNhbWVZTGluZXMiLCJ1bmRlZmluZWQiLCJtaW5YIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIm1heFgiLCJNSU5fU0FGRV9JTlRFR0VSIiwidG8iLCJsYXN0Iiwic2FtZVhMaW5lcyIsIm1pblkiLCJtYXhZIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/LineStore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Point.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Point.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Point: () => (/* binding */ Point)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Shape.js\");\n\nclass Point extends _Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape {\n    constructor(x, y){\n        super();\n        this.x = x;\n        this.y = y;\n    }\n    equal(point) {\n        return point.x === this.x && point.y === this.y;\n    }\n    transform(matrix) {\n        const p = _Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape.applyTransform([\n            this.x,\n            this.y\n        ], matrix);\n        this.x = p[0];\n        this.y = p[1];\n        return this;\n    }\n} //# sourceMappingURL=Point.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9nZW9tZXRyeS9Qb2ludC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFtQztBQUM1QixNQUFNQyxjQUFjRCw0Q0FBS0E7SUFHNUJFLFlBQVlDLENBQUMsRUFBRUMsQ0FBQyxDQUFFO1FBQ2QsS0FBSztRQUNMLElBQUksQ0FBQ0QsQ0FBQyxHQUFHQTtRQUNULElBQUksQ0FBQ0MsQ0FBQyxHQUFHQTtJQUNiO0lBQ0FDLE1BQU1DLEtBQUssRUFBRTtRQUNULE9BQU9BLE1BQU1ILENBQUMsS0FBSyxJQUFJLENBQUNBLENBQUMsSUFBSUcsTUFBTUYsQ0FBQyxLQUFLLElBQUksQ0FBQ0EsQ0FBQztJQUNuRDtJQUNBRyxVQUFVQyxNQUFNLEVBQUU7UUFDZCxNQUFNQyxJQUFJVCw0Q0FBS0EsQ0FBQ1UsY0FBYyxDQUFDO1lBQUMsSUFBSSxDQUFDUCxDQUFDO1lBQUUsSUFBSSxDQUFDQyxDQUFDO1NBQUMsRUFBRUk7UUFDakQsSUFBSSxDQUFDTCxDQUFDLEdBQUdNLENBQUMsQ0FBQyxFQUFFO1FBQ2IsSUFBSSxDQUFDTCxDQUFDLEdBQUdLLENBQUMsQ0FBQyxFQUFFO1FBQ2IsT0FBTyxJQUFJO0lBQ2Y7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWNhcmVlci1hc3Npc3RhbnQvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9nZW9tZXRyeS9Qb2ludC5qcz8zY2NlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi9TaGFwZS5qcyc7XG5leHBvcnQgY2xhc3MgUG9pbnQgZXh0ZW5kcyBTaGFwZSB7XG4gICAgeDtcbiAgICB5O1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG4gICAgZXF1YWwocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJiBwb2ludC55ID09PSB0aGlzLnk7XG4gICAgfVxuICAgIHRyYW5zZm9ybShtYXRyaXgpIHtcbiAgICAgICAgY29uc3QgcCA9IFNoYXBlLmFwcGx5VHJhbnNmb3JtKFt0aGlzLngsIHRoaXMueV0sIG1hdHJpeCk7XG4gICAgICAgIHRoaXMueCA9IHBbMF07XG4gICAgICAgIHRoaXMueSA9IHBbMV07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvaW50LmpzLm1hcCJdLCJuYW1lcyI6WyJTaGFwZSIsIlBvaW50IiwiY29uc3RydWN0b3IiLCJ4IiwieSIsImVxdWFsIiwicG9pbnQiLCJ0cmFuc2Zvcm0iLCJtYXRyaXgiLCJwIiwiYXBwbHlUcmFuc2Zvcm0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Point.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Rectangle.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Rectangle.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rectangle: () => (/* binding */ Rectangle)\n/* harmony export */ });\n/* harmony import */ var _Line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Line.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Line.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Point.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Point.js\");\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Shape.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Shape.js\");\n\n\n\nclass Rectangle extends _Shape_js__WEBPACK_IMPORTED_MODULE_2__.Shape {\n    constructor(from, width, height){\n        super();\n        this.from = from;\n        this.width = width;\n        this.height = height;\n    }\n    get to() {\n        return new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(this.from.x + this.width, this.from.y + this.height);\n    }\n    getLines() {\n        const to = this.to;\n        const lines = [\n            new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(this.from, new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(to.x, this.from.y)),\n            new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(this.from, new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(this.from.x, to.y)),\n            new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(to.x, this.from.y), to),\n            new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(this.from.x, to.y), to)\n        ];\n        return lines.filter((l)=>l.valid);\n    }\n    transform(matrix) {\n        const p1 = _Shape_js__WEBPACK_IMPORTED_MODULE_2__.Shape.applyTransform([\n            this.from.x,\n            this.from.y\n        ], matrix);\n        const p2 = _Shape_js__WEBPACK_IMPORTED_MODULE_2__.Shape.applyTransform([\n            this.from.x + this.width,\n            this.from.y + this.height\n        ], matrix);\n        const x = Math.min(p1[0], p2[0]);\n        const y = Math.min(p1[1], p2[1]);\n        const width = Math.abs(p1[0] - p2[0]);\n        const height = Math.abs(p1[1] - p2[1]);\n        this.from = new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(x, y);\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n} //# sourceMappingURL=Rectangle.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9nZW9tZXRyeS9SZWN0YW5nbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNFO0FBQ0E7QUFDNUIsTUFBTUcsa0JBQWtCRCw0Q0FBS0E7SUFJaENFLFlBQVlDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxNQUFNLENBQUU7UUFDN0IsS0FBSztRQUNMLElBQUksQ0FBQ0YsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtJQUNsQjtJQUNBLElBQUlDLEtBQUs7UUFDTCxPQUFPLElBQUlQLDRDQUFLQSxDQUFDLElBQUksQ0FBQ0ksSUFBSSxDQUFDSSxDQUFDLEdBQUcsSUFBSSxDQUFDSCxLQUFLLEVBQUUsSUFBSSxDQUFDRCxJQUFJLENBQUNLLENBQUMsR0FBRyxJQUFJLENBQUNILE1BQU07SUFDeEU7SUFDQUksV0FBVztRQUNQLE1BQU1ILEtBQUssSUFBSSxDQUFDQSxFQUFFO1FBQ2xCLE1BQU1JLFFBQVE7WUFDVixJQUFJWiwwQ0FBSUEsQ0FBQyxJQUFJLENBQUNLLElBQUksRUFBRSxJQUFJSiw0Q0FBS0EsQ0FBQ08sR0FBR0MsQ0FBQyxFQUFFLElBQUksQ0FBQ0osSUFBSSxDQUFDSyxDQUFDO1lBQy9DLElBQUlWLDBDQUFJQSxDQUFDLElBQUksQ0FBQ0ssSUFBSSxFQUFFLElBQUlKLDRDQUFLQSxDQUFDLElBQUksQ0FBQ0ksSUFBSSxDQUFDSSxDQUFDLEVBQUVELEdBQUdFLENBQUM7WUFDL0MsSUFBSVYsMENBQUlBLENBQUMsSUFBSUMsNENBQUtBLENBQUNPLEdBQUdDLENBQUMsRUFBRSxJQUFJLENBQUNKLElBQUksQ0FBQ0ssQ0FBQyxHQUFHRjtZQUN2QyxJQUFJUiwwQ0FBSUEsQ0FBQyxJQUFJQyw0Q0FBS0EsQ0FBQyxJQUFJLENBQUNJLElBQUksQ0FBQ0ksQ0FBQyxFQUFFRCxHQUFHRSxDQUFDLEdBQUdGO1NBQzFDO1FBQ0QsT0FBT0ksTUFBTUMsTUFBTSxDQUFDLENBQUNDLElBQU1BLEVBQUVDLEtBQUs7SUFDdEM7SUFDQUMsVUFBVUMsTUFBTSxFQUFFO1FBQ2QsTUFBTUMsS0FBS2hCLDRDQUFLQSxDQUFDaUIsY0FBYyxDQUFDO1lBQUMsSUFBSSxDQUFDZCxJQUFJLENBQUNJLENBQUM7WUFBRSxJQUFJLENBQUNKLElBQUksQ0FBQ0ssQ0FBQztTQUFDLEVBQUVPO1FBQzVELE1BQU1HLEtBQUtsQiw0Q0FBS0EsQ0FBQ2lCLGNBQWMsQ0FBQztZQUFDLElBQUksQ0FBQ2QsSUFBSSxDQUFDSSxDQUFDLEdBQUcsSUFBSSxDQUFDSCxLQUFLO1lBQUUsSUFBSSxDQUFDRCxJQUFJLENBQUNLLENBQUMsR0FBRyxJQUFJLENBQUNILE1BQU07U0FBQyxFQUFFVTtRQUN2RixNQUFNUixJQUFJWSxLQUFLQyxHQUFHLENBQUNKLEVBQUUsQ0FBQyxFQUFFLEVBQUVFLEVBQUUsQ0FBQyxFQUFFO1FBQy9CLE1BQU1WLElBQUlXLEtBQUtDLEdBQUcsQ0FBQ0osRUFBRSxDQUFDLEVBQUUsRUFBRUUsRUFBRSxDQUFDLEVBQUU7UUFDL0IsTUFBTWQsUUFBUWUsS0FBS0UsR0FBRyxDQUFDTCxFQUFFLENBQUMsRUFBRSxHQUFHRSxFQUFFLENBQUMsRUFBRTtRQUNwQyxNQUFNYixTQUFTYyxLQUFLRSxHQUFHLENBQUNMLEVBQUUsQ0FBQyxFQUFFLEdBQUdFLEVBQUUsQ0FBQyxFQUFFO1FBQ3JDLElBQUksQ0FBQ2YsSUFBSSxHQUFHLElBQUlKLDRDQUFLQSxDQUFDUSxHQUFHQztRQUN6QixJQUFJLENBQUNKLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxPQUFPLElBQUk7SUFDZjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktY2FyZWVyLWFzc2lzdGFudC8uL25vZGVfbW9kdWxlcy9wZGYtcGFyc2UvZGlzdC9wZGYtcGFyc2UvZXNtL2dlb21ldHJ5L1JlY3RhbmdsZS5qcz9kNTAzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExpbmUgfSBmcm9tICcuL0xpbmUuanMnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL1BvaW50LmpzJztcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi9TaGFwZS5qcyc7XG5leHBvcnQgY2xhc3MgUmVjdGFuZ2xlIGV4dGVuZHMgU2hhcGUge1xuICAgIGZyb207XG4gICAgd2lkdGg7XG4gICAgaGVpZ2h0O1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgZ2V0IHRvKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuZnJvbS54ICsgdGhpcy53aWR0aCwgdGhpcy5mcm9tLnkgKyB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIGdldExpbmVzKCkge1xuICAgICAgICBjb25zdCB0byA9IHRoaXMudG87XG4gICAgICAgIGNvbnN0IGxpbmVzID0gW1xuICAgICAgICAgICAgbmV3IExpbmUodGhpcy5mcm9tLCBuZXcgUG9pbnQodG8ueCwgdGhpcy5mcm9tLnkpKSxcbiAgICAgICAgICAgIG5ldyBMaW5lKHRoaXMuZnJvbSwgbmV3IFBvaW50KHRoaXMuZnJvbS54LCB0by55KSksXG4gICAgICAgICAgICBuZXcgTGluZShuZXcgUG9pbnQodG8ueCwgdGhpcy5mcm9tLnkpLCB0byksXG4gICAgICAgICAgICBuZXcgTGluZShuZXcgUG9pbnQodGhpcy5mcm9tLngsIHRvLnkpLCB0byksXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBsaW5lcy5maWx0ZXIoKGwpID0+IGwudmFsaWQpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0obWF0cml4KSB7XG4gICAgICAgIGNvbnN0IHAxID0gU2hhcGUuYXBwbHlUcmFuc2Zvcm0oW3RoaXMuZnJvbS54LCB0aGlzLmZyb20ueV0sIG1hdHJpeCk7XG4gICAgICAgIGNvbnN0IHAyID0gU2hhcGUuYXBwbHlUcmFuc2Zvcm0oW3RoaXMuZnJvbS54ICsgdGhpcy53aWR0aCwgdGhpcy5mcm9tLnkgKyB0aGlzLmhlaWdodF0sIG1hdHJpeCk7XG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1pbihwMVswXSwgcDJbMF0pO1xuICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4ocDFbMV0sIHAyWzFdKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmFicyhwMVswXSAtIHAyWzBdKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnMocDFbMV0gLSBwMlsxXSk7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVjdGFuZ2xlLmpzLm1hcCJdLCJuYW1lcyI6WyJMaW5lIiwiUG9pbnQiLCJTaGFwZSIsIlJlY3RhbmdsZSIsImNvbnN0cnVjdG9yIiwiZnJvbSIsIndpZHRoIiwiaGVpZ2h0IiwidG8iLCJ4IiwieSIsImdldExpbmVzIiwibGluZXMiLCJmaWx0ZXIiLCJsIiwidmFsaWQiLCJ0cmFuc2Zvcm0iLCJtYXRyaXgiLCJwMSIsImFwcGx5VHJhbnNmb3JtIiwicDIiLCJNYXRoIiwibWluIiwiYWJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Rectangle.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Shape.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Shape.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shape: () => (/* binding */ Shape)\n/* harmony export */ });\nclass Shape {\n    static{\n        this.tolerance = 2;\n    }\n    static applyTransform(p, m) {\n        const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n        const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n        return [\n            xt,\n            yt\n        ];\n    }\n} //# sourceMappingURL=Shape.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9nZW9tZXRyeS9TaGFwZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUE7O2FBQ0ZDLFlBQVk7O0lBQ25CLE9BQU9DLGVBQWVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ3hCLE1BQU1DLEtBQUtGLENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFO1FBQzNDLE1BQU1FLEtBQUtILENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFO1FBQzNDLE9BQU87WUFBQ0M7WUFBSUM7U0FBRztJQUNuQjtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktY2FyZWVyLWFzc2lzdGFudC8uL25vZGVfbW9kdWxlcy9wZGYtcGFyc2UvZGlzdC9wZGYtcGFyc2UvZXNtL2dlb21ldHJ5L1NoYXBlLmpzP2NhODMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFNoYXBlIHtcbiAgICBzdGF0aWMgdG9sZXJhbmNlID0gMjtcbiAgICBzdGF0aWMgYXBwbHlUcmFuc2Zvcm0ocCwgbSkge1xuICAgICAgICBjb25zdCB4dCA9IHBbMF0gKiBtWzBdICsgcFsxXSAqIG1bMl0gKyBtWzRdO1xuICAgICAgICBjb25zdCB5dCA9IHBbMF0gKiBtWzFdICsgcFsxXSAqIG1bM10gKyBtWzVdO1xuICAgICAgICByZXR1cm4gW3h0LCB5dF07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2hhcGUuanMubWFwIl0sIm5hbWVzIjpbIlNoYXBlIiwidG9sZXJhbmNlIiwiYXBwbHlUcmFuc2Zvcm0iLCJwIiwibSIsInh0IiwieXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Shape.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Table.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Table.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Table: () => (/* binding */ Table)\n/* harmony export */ });\n/* harmony import */ var _Line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Line.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Line.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Point.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Point.js\");\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Shape.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Shape.js\");\n/* harmony import */ var _TableData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TableData.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/TableData.js\");\n\n\n\n\nclass Table {\n    constructor(line){\n        this.hLines = [];\n        this.vLines = [];\n        if (line.direction === _Line_js__WEBPACK_IMPORTED_MODULE_0__.LineDirection.Horizontal) {\n            this.hLines.push(line);\n        } else if (line.direction === _Line_js__WEBPACK_IMPORTED_MODULE_0__.LineDirection.Vertical) {\n            this.vLines.push(line);\n        }\n    }\n    get isValid() {\n        return this.hLines.length + this.vLines.length > 4;\n    }\n    get rowPivots() {\n        const rowSet = new Set();\n        for (const line of this.hLines){\n            rowSet.add(line.from.y);\n        }\n        return [\n            ...rowSet\n        ].sort((a, b)=>a - b);\n    }\n    get colPivots() {\n        const colSet = new Set();\n        for (const line of this.vLines){\n            colSet.add(line.from.x);\n        }\n        return [\n            ...colSet\n        ].sort((a, b)=>a - b);\n    }\n    add(line) {\n        const hasIntersection = this.intersection(line);\n        if (hasIntersection) {\n            if (line.direction === _Line_js__WEBPACK_IMPORTED_MODULE_0__.LineDirection.Horizontal) {\n                this.hLines.push(line);\n                return true;\n            } else if (line.direction === _Line_js__WEBPACK_IMPORTED_MODULE_0__.LineDirection.Vertical) {\n                this.vLines.push(line);\n                return true;\n            }\n        }\n        return false;\n    }\n    intersection(line) {\n        let flag = false;\n        if (!line.valid) return flag;\n        if (line.direction === _Line_js__WEBPACK_IMPORTED_MODULE_0__.LineDirection.Horizontal) {\n            for (const vLine of this.vLines){\n                const p = line.intersection(vLine);\n                if (p) {\n                    flag = true;\n                }\n            }\n        } else if (line.direction === _Line_js__WEBPACK_IMPORTED_MODULE_0__.LineDirection.Vertical) {\n            for (const hLine of this.hLines){\n                const p = line.intersection(hLine);\n                if (p) {\n                    flag = true;\n                }\n            }\n        }\n        return flag;\n    }\n    getSameHorizontal(line) {\n        const same = [\n            line\n        ];\n        const other = [];\n        while(this.hLines.length > 0){\n            const hLine = this.hLines.shift();\n            if (!hLine) continue;\n            if (hLine.from.y === line.from.y) {\n                same.push(hLine);\n            } else {\n                other.push(hLine);\n            }\n        }\n        this.hLines = other;\n        return same;\n    }\n    getSameVertical(line) {\n        const same = [\n            line\n        ];\n        const other = [];\n        while(this.vLines.length > 0){\n            const vLine = this.vLines.shift();\n            if (!vLine) continue;\n            if (vLine.from.x === line.from.x) {\n                same.push(vLine);\n            } else {\n                other.push(vLine);\n            }\n        }\n        this.vLines = other;\n        return same;\n    }\n    mergeHorizontalLines(lines) {\n        lines.sort((l1, l2)=>l1.from.x - l2.from.x);\n        const minX = lines[0].from.x;\n        const maxX = lines[lines.length - 1].to.x;\n        const resultLine = new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(minX, lines[0].from.y), new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(maxX, lines[0].from.y));\n        for(let i = 1; i < lines.length; i++){\n            const prevLine = lines[i - 1];\n            const currLine = lines[i];\n            if (Math.abs(prevLine.to.x - currLine.from.x) > _Shape_js__WEBPACK_IMPORTED_MODULE_2__.Shape.tolerance) {\n                const gapLine = new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(prevLine.to.x, prevLine.from.y), new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(currLine.from.x, currLine.from.y));\n                resultLine.addGap(gapLine);\n            }\n        }\n        return resultLine;\n    }\n    mergeVerticalLines(lines) {\n        lines.sort((l1, l2)=>l1.from.y - l2.from.y);\n        const minY = lines[0].from.y;\n        const maxY = lines[lines.length - 1].to.y;\n        const resultLine = new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(lines[0].from.x, minY), new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(lines[0].from.x, maxY));\n        for(let i = 1; i < lines.length; i++){\n            const prevLine = lines[i - 1];\n            const currLine = lines[i];\n            if (Math.abs(prevLine.to.y - currLine.from.y) > _Shape_js__WEBPACK_IMPORTED_MODULE_2__.Shape.tolerance) {\n                const gapLine = new _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line(new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(prevLine.to.x, prevLine.to.y), new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(prevLine.to.x, currLine.from.y));\n                resultLine.addGap(gapLine);\n            }\n        }\n        return resultLine;\n    }\n    normalize() {\n        this.hLines = this.hLines.filter((l)=>l.intersections.length > 1);\n        this.vLines = this.vLines.filter((l)=>l.intersections.length > 1);\n        this.hLines.sort((l1, l2)=>l1.from.y - l2.from.y);\n        this.vLines.sort((l1, l2)=>l1.from.x - l2.from.x);\n        const newHLines = [];\n        while(this.hLines.length > 0){\n            const line = this.hLines.shift();\n            if (!line) continue;\n            const lines = this.getSameHorizontal(line);\n            const merged = this.mergeHorizontalLines(lines);\n            newHLines.push(merged);\n        }\n        this.hLines = newHLines;\n        const newVLines = [];\n        while(this.vLines.length > 0){\n            const line = this.vLines.shift();\n            if (!line) continue;\n            const lines = this.getSameVertical(line);\n            const merged = this.mergeVerticalLines(lines);\n            newVLines.push(merged);\n        }\n        this.vLines = newVLines;\n    }\n    verticalExists(line, y1, y2) {\n        if (line.direction !== _Line_js__WEBPACK_IMPORTED_MODULE_0__.LineDirection.Vertical) {\n            throw new Error(\"Line is not vertical\");\n        }\n        if (y1 >= y2) {\n            throw new Error(\"y1 must be less than y2\");\n        }\n        if (line.from.y <= y1 && line.to.y >= y2) {\n            for (const gap of line.gaps){\n                if (gap.from.y <= y1 && gap.to.y >= y2) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    horizontalExists(line, x1, x2) {\n        if (line.direction !== _Line_js__WEBPACK_IMPORTED_MODULE_0__.LineDirection.Horizontal) {\n            throw new Error(\"Line is not horizontal\");\n        }\n        if (x1 >= x2) {\n            throw new Error(\"x1 must be less than x2\");\n        }\n        if (line.from.x <= x1 && line.to.x >= x2) {\n            for (const gap of line.gaps){\n                if (gap.from.x <= x1 && gap.to.x >= x2) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    findBottomLineIndex(h2Index, xMiddle) {\n        for(let i = h2Index; i < this.hLines.length; i++){\n            const hLine = this.hLines[i];\n            if (hLine.from.x <= xMiddle && hLine.to.x >= xMiddle) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    findVerticalLineIndexs(topHLine, yMiddle) {\n        const result = [];\n        for(let i = 0; i < this.vLines.length; i++){\n            const vLine = this.vLines[i];\n            if (vLine.from.y <= yMiddle && vLine.to.y >= yMiddle && topHLine.intersection(vLine)) {\n                result.push(i);\n            }\n        }\n        return result;\n    }\n    getRow(h1Index, h2Index, yMiddle) {\n        const tableRow = [];\n        //const colCount = this.vLines.length -1\n        const topHLine = this.hLines[h1Index];\n        const vLineIndexes = this.findVerticalLineIndexs(topHLine, yMiddle);\n        for(let i = 1; i < vLineIndexes.length; i++){\n            const leftVLine = this.vLines[vLineIndexes[i - 1]];\n            const rightVLine = this.vLines[vLineIndexes[i]];\n            const xMiddle = (leftVLine.from.x + rightVLine.from.x) / 2;\n            const bottomHLineIndex = this.findBottomLineIndex(h2Index, xMiddle);\n            const bottomHLine = this.hLines[bottomHLineIndex];\n            // minXY: {x:leftVLine.from.x,y:topHLine.from.y},\n            // maxXY: {x:rightVLine.from.x,y:bottomHLine.from.y},\n            const tableCell = {\n                minXY: new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(leftVLine.from.x, topHLine.from.y),\n                maxXY: new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(rightVLine.from.x, bottomHLine.from.y),\n                width: rightVLine.from.x - leftVLine.from.x,\n                height: bottomHLine.from.y - topHLine.from.y,\n                text: []\n            };\n            const colSpan = vLineIndexes[i] - vLineIndexes[i - 1];\n            const rowSpan = bottomHLineIndex - h1Index;\n            if (colSpan > 1) {\n                tableCell.colspan = colSpan;\n            }\n            if (rowSpan > 1) {\n                tableCell.rowspan = rowSpan;\n            }\n            tableRow.push(tableCell);\n        }\n        return tableRow;\n    }\n    toData() {\n        const rowPivots = this.rowPivots;\n        const colPivots = this.colPivots;\n        const minXY = new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(colPivots[0], rowPivots[0]);\n        const maxXY = new _Point_js__WEBPACK_IMPORTED_MODULE_1__.Point(colPivots[colPivots.length - 1], rowPivots[rowPivots.length - 1]);\n        const result = new _TableData_js__WEBPACK_IMPORTED_MODULE_3__.TableData(minXY, maxXY, rowPivots, colPivots);\n        for(let h1 = 1; h1 < this.hLines.length; h1++){\n            const prevHLine = this.hLines[h1 - 1];\n            const currHLine = this.hLines[h1];\n            const YMiddle = (prevHLine.from.y + currHLine.from.y) / 2;\n            const rowData = this.getRow(h1 - 1, h1, YMiddle);\n            result.rows.push(rowData);\n        }\n        return result;\n    }\n} //# sourceMappingURL=Table.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9nZW9tZXRyeS9UYWJsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFnRDtBQUNiO0FBQ0E7QUFDUTtBQUNwQyxNQUFNSztJQUdUQyxZQUFZQyxJQUFJLENBQUU7YUFGbEJDLFNBQVMsRUFBRTthQUNYQyxTQUFTLEVBQUU7UUFFUCxJQUFJRixLQUFLRyxTQUFTLEtBQUtULG1EQUFhQSxDQUFDVSxVQUFVLEVBQUU7WUFDN0MsSUFBSSxDQUFDSCxNQUFNLENBQUNJLElBQUksQ0FBQ0w7UUFDckIsT0FDSyxJQUFJQSxLQUFLRyxTQUFTLEtBQUtULG1EQUFhQSxDQUFDWSxRQUFRLEVBQUU7WUFDaEQsSUFBSSxDQUFDSixNQUFNLENBQUNHLElBQUksQ0FBQ0w7UUFDckI7SUFDSjtJQUNBLElBQUlPLFVBQVU7UUFDVixPQUFPLElBQUksQ0FBQ04sTUFBTSxDQUFDTyxNQUFNLEdBQUcsSUFBSSxDQUFDTixNQUFNLENBQUNNLE1BQU0sR0FBRztJQUNyRDtJQUNBLElBQUlDLFlBQVk7UUFDWixNQUFNQyxTQUFTLElBQUlDO1FBQ25CLEtBQUssTUFBTVgsUUFBUSxJQUFJLENBQUNDLE1BQU0sQ0FBRTtZQUM1QlMsT0FBT0UsR0FBRyxDQUFDWixLQUFLYSxJQUFJLENBQUNDLENBQUM7UUFDMUI7UUFDQSxPQUFPO2VBQUlKO1NBQU8sQ0FBQ0ssSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDO0lBQzFDO0lBQ0EsSUFBSUMsWUFBWTtRQUNaLE1BQU1DLFNBQVMsSUFBSVI7UUFDbkIsS0FBSyxNQUFNWCxRQUFRLElBQUksQ0FBQ0UsTUFBTSxDQUFFO1lBQzVCaUIsT0FBT1AsR0FBRyxDQUFDWixLQUFLYSxJQUFJLENBQUNPLENBQUM7UUFDMUI7UUFDQSxPQUFPO2VBQUlEO1NBQU8sQ0FBQ0osSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDO0lBQzFDO0lBQ0FMLElB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QU00RSxRQUFRLElBQUkxRiw0Q0FBS0EsQ0FBQ3VCLFNBQVMsQ0FBQ0EsVUFBVVYsTUFBTSxHQUFHLEVBQUUsRUFBRUMsU0FBUyxDQUFDQSxVQUFVRCxNQUFNLEdBQUcsRUFBRTtRQUN4RixNQUFNa0UsU0FBUyxJQUFJN0Usb0RBQVNBLENBQUN1RixPQUFPQyxPQUFPNUUsV0FBV1M7UUFDdEQsSUFBSyxJQUFJNEUsS0FBSyxHQUFHQSxLQUFLLElBQUksQ0FBQzdGLE1BQU0sQ0FBQ08sTUFBTSxFQUFFc0YsS0FBTTtZQUM1QyxNQUFNQyxZQUFZLElBQUksQ0FBQzlGLE1BQU0sQ0FBQzZGLEtBQUssRUFBRTtZQUNyQyxNQUFNRSxZQUFZLElBQUksQ0FBQy9GLE1BQU0sQ0FBQzZGLEdBQUc7WUFDakMsTUFBTUcsVUFBVSxDQUFDRixVQUFVbEYsSUFBSSxDQUFDQyxDQUFDLEdBQUdrRixVQUFVbkYsSUFBSSxDQUFDQyxDQUFDLElBQUk7WUFDeEQsTUFBTW9GLFVBQVUsSUFBSSxDQUFDdkIsTUFBTSxDQUFDbUIsS0FBSyxHQUFHQSxJQUFJRztZQUN4Q3ZCLE9BQU95QixJQUFJLENBQUM5RixJQUFJLENBQUM2RjtRQUNyQjtRQUNBLE9BQU94QjtJQUNYO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1jYXJlZXItYXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL3BkZi1wYXJzZS9kaXN0L3BkZi1wYXJzZS9lc20vZ2VvbWV0cnkvVGFibGUuanM/MzYwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMaW5lLCBMaW5lRGlyZWN0aW9uIH0gZnJvbSAnLi9MaW5lLmpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9Qb2ludC5qcyc7XG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4vU2hhcGUuanMnO1xuaW1wb3J0IHsgVGFibGVEYXRhIH0gZnJvbSAnLi9UYWJsZURhdGEuanMnO1xuZXhwb3J0IGNsYXNzIFRhYmxlIHtcbiAgICBoTGluZXMgPSBbXTtcbiAgICB2TGluZXMgPSBbXTtcbiAgICBjb25zdHJ1Y3RvcihsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmRpcmVjdGlvbiA9PT0gTGluZURpcmVjdGlvbi5Ib3Jpem9udGFsKSB7XG4gICAgICAgICAgICB0aGlzLmhMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmUuZGlyZWN0aW9uID09PSBMaW5lRGlyZWN0aW9uLlZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLnZMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oTGluZXMubGVuZ3RoICsgdGhpcy52TGluZXMubGVuZ3RoID4gNDtcbiAgICB9XG4gICAgZ2V0IHJvd1Bpdm90cygpIHtcbiAgICAgICAgY29uc3Qgcm93U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy5oTGluZXMpIHtcbiAgICAgICAgICAgIHJvd1NldC5hZGQobGluZS5mcm9tLnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4ucm93U2V0XS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgfVxuICAgIGdldCBjb2xQaXZvdHMoKSB7XG4gICAgICAgIGNvbnN0IGNvbFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMudkxpbmVzKSB7XG4gICAgICAgICAgICBjb2xTZXQuYWRkKGxpbmUuZnJvbS54KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWy4uLmNvbFNldF0uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIH1cbiAgICBhZGQobGluZSkge1xuICAgICAgICBjb25zdCBoYXNJbnRlcnNlY3Rpb24gPSB0aGlzLmludGVyc2VjdGlvbihsaW5lKTtcbiAgICAgICAgaWYgKGhhc0ludGVyc2VjdGlvbikge1xuICAgICAgICAgICAgaWYgKGxpbmUuZGlyZWN0aW9uID09PSBMaW5lRGlyZWN0aW9uLkhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGluZS5kaXJlY3Rpb24gPT09IExpbmVEaXJlY3Rpb24uVmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW50ZXJzZWN0aW9uKGxpbmUpIHtcbiAgICAgICAgbGV0IGZsYWcgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFsaW5lLnZhbGlkKVxuICAgICAgICAgICAgcmV0dXJuIGZsYWc7XG4gICAgICAgIGlmIChsaW5lLmRpcmVjdGlvbiA9PT0gTGluZURpcmVjdGlvbi5Ib3Jpem9udGFsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZMaW5lIG9mIHRoaXMudkxpbmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IGxpbmUuaW50ZXJzZWN0aW9uKHZMaW5lKTtcbiAgICAgICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGluZS5kaXJlY3Rpb24gPT09IExpbmVEaXJlY3Rpb24uVmVydGljYWwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaExpbmUgb2YgdGhpcy5oTGluZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gbGluZS5pbnRlcnNlY3Rpb24oaExpbmUpO1xuICAgICAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhZztcbiAgICB9XG4gICAgZ2V0U2FtZUhvcml6b250YWwobGluZSkge1xuICAgICAgICBjb25zdCBzYW1lID0gW2xpbmVdO1xuICAgICAgICBjb25zdCBvdGhlciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5oTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaExpbmUgPSB0aGlzLmhMaW5lcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCFoTGluZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChoTGluZS5mcm9tLnkgPT09IGxpbmUuZnJvbS55KSB7XG4gICAgICAgICAgICAgICAgc2FtZS5wdXNoKGhMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG90aGVyLnB1c2goaExpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaExpbmVzID0gb3RoZXI7XG4gICAgICAgIHJldHVybiBzYW1lO1xuICAgIH1cbiAgICBnZXRTYW1lVmVydGljYWwobGluZSkge1xuICAgICAgICBjb25zdCBzYW1lID0gW2xpbmVdO1xuICAgICAgICBjb25zdCBvdGhlciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy52TGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdkxpbmUgPSB0aGlzLnZMaW5lcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCF2TGluZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh2TGluZS5mcm9tLnggPT09IGxpbmUuZnJvbS54KSB7XG4gICAgICAgICAgICAgICAgc2FtZS5wdXNoKHZMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG90aGVyLnB1c2godkxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudkxpbmVzID0gb3RoZXI7XG4gICAgICAgIHJldHVybiBzYW1lO1xuICAgIH1cbiAgICBtZXJnZUhvcml6b250YWxMaW5lcyhsaW5lcykge1xuICAgICAgICBsaW5lcy5zb3J0KChsMSwgbDIpID0+IGwxLmZyb20ueCAtIGwyLmZyb20ueCk7XG4gICAgICAgIGNvbnN0IG1pblggPSBsaW5lc1swXS5mcm9tLng7XG4gICAgICAgIGNvbnN0IG1heFggPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS50by54O1xuICAgICAgICBjb25zdCByZXN1bHRMaW5lID0gbmV3IExpbmUobmV3IFBvaW50KG1pblgsIGxpbmVzWzBdLmZyb20ueSksIG5ldyBQb2ludChtYXhYLCBsaW5lc1swXS5mcm9tLnkpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJldkxpbmUgPSBsaW5lc1tpIC0gMV07XG4gICAgICAgICAgICBjb25zdCBjdXJyTGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHByZXZMaW5lLnRvLnggLSBjdXJyTGluZS5mcm9tLngpID4gU2hhcGUudG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FwTGluZSA9IG5ldyBMaW5lKG5ldyBQb2ludChwcmV2TGluZS50by54LCBwcmV2TGluZS5mcm9tLnkpLCBuZXcgUG9pbnQoY3VyckxpbmUuZnJvbS54LCBjdXJyTGluZS5mcm9tLnkpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRMaW5lLmFkZEdhcChnYXBMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0TGluZTtcbiAgICB9XG4gICAgbWVyZ2VWZXJ0aWNhbExpbmVzKGxpbmVzKSB7XG4gICAgICAgIGxpbmVzLnNvcnQoKGwxLCBsMikgPT4gbDEuZnJvbS55IC0gbDIuZnJvbS55KTtcbiAgICAgICAgY29uc3QgbWluWSA9IGxpbmVzWzBdLmZyb20ueTtcbiAgICAgICAgY29uc3QgbWF4WSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLnRvLnk7XG4gICAgICAgIGNvbnN0IHJlc3VsdExpbmUgPSBuZXcgTGluZShuZXcgUG9pbnQobGluZXNbMF0uZnJvbS54LCBtaW5ZKSwgbmV3IFBvaW50KGxpbmVzWzBdLmZyb20ueCwgbWF4WSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2TGluZSA9IGxpbmVzW2kgLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJMaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMocHJldkxpbmUudG8ueSAtIGN1cnJMaW5lLmZyb20ueSkgPiBTaGFwZS50b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXBMaW5lID0gbmV3IExpbmUobmV3IFBvaW50KHByZXZMaW5lLnRvLngsIHByZXZMaW5lLnRvLnkpLCBuZXcgUG9pbnQocHJldkxpbmUudG8ueCwgY3VyckxpbmUuZnJvbS55KSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0TGluZS5hZGRHYXAoZ2FwTGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdExpbmU7XG4gICAgfVxuICAgIG5vcm1hbGl6ZSgpIHtcbiAgICAgICAgdGhpcy5oTGluZXMgPSB0aGlzLmhMaW5lcy5maWx0ZXIoKGwpID0+IGwuaW50ZXJzZWN0aW9ucy5sZW5ndGggPiAxKTtcbiAgICAgICAgdGhpcy52TGluZXMgPSB0aGlzLnZMaW5lcy5maWx0ZXIoKGwpID0+IGwuaW50ZXJzZWN0aW9ucy5sZW5ndGggPiAxKTtcbiAgICAgICAgdGhpcy5oTGluZXMuc29ydCgobDEsIGwyKSA9PiBsMS5mcm9tLnkgLSBsMi5mcm9tLnkpO1xuICAgICAgICB0aGlzLnZMaW5lcy5zb3J0KChsMSwgbDIpID0+IGwxLmZyb20ueCAtIGwyLmZyb20ueCk7XG4gICAgICAgIGNvbnN0IG5ld0hMaW5lcyA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5oTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IHRoaXMuaExpbmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHRoaXMuZ2V0U2FtZUhvcml6b250YWwobGluZSk7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSB0aGlzLm1lcmdlSG9yaXpvbnRhbExpbmVzKGxpbmVzKTtcbiAgICAgICAgICAgIG5ld0hMaW5lcy5wdXNoKG1lcmdlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oTGluZXMgPSBuZXdITGluZXM7XG4gICAgICAgIGNvbnN0IG5ld1ZMaW5lcyA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy52TGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IHRoaXMudkxpbmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHRoaXMuZ2V0U2FtZVZlcnRpY2FsKGxpbmUpO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gdGhpcy5tZXJnZVZlcnRpY2FsTGluZXMobGluZXMpO1xuICAgICAgICAgICAgbmV3VkxpbmVzLnB1c2gobWVyZ2VkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZMaW5lcyA9IG5ld1ZMaW5lcztcbiAgICB9XG4gICAgdmVydGljYWxFeGlzdHMobGluZSwgeTEsIHkyKSB7XG4gICAgICAgIGlmIChsaW5lLmRpcmVjdGlvbiAhPT0gTGluZURpcmVjdGlvbi5WZXJ0aWNhbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5lIGlzIG5vdCB2ZXJ0aWNhbCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5MSA+PSB5Mikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5MSBtdXN0IGJlIGxlc3MgdGhhbiB5MicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lLmZyb20ueSA8PSB5MSAmJiBsaW5lLnRvLnkgPj0geTIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZ2FwIG9mIGxpbmUuZ2Fwcykge1xuICAgICAgICAgICAgICAgIGlmIChnYXAuZnJvbS55IDw9IHkxICYmIGdhcC50by55ID49IHkyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhvcml6b250YWxFeGlzdHMobGluZSwgeDEsIHgyKSB7XG4gICAgICAgIGlmIChsaW5lLmRpcmVjdGlvbiAhPT0gTGluZURpcmVjdGlvbi5Ib3Jpem9udGFsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmUgaXMgbm90IGhvcml6b250YWwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeDEgPj0geDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneDEgbXVzdCBiZSBsZXNzIHRoYW4geDInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZS5mcm9tLnggPD0geDEgJiYgbGluZS50by54ID49IHgyKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGdhcCBvZiBsaW5lLmdhcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2FwLmZyb20ueCA8PSB4MSAmJiBnYXAudG8ueCA+PSB4Mikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmaW5kQm90dG9tTGluZUluZGV4KGgySW5kZXgsIHhNaWRkbGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGgySW5kZXg7IGkgPCB0aGlzLmhMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaExpbmUgPSB0aGlzLmhMaW5lc1tpXTtcbiAgICAgICAgICAgIGlmIChoTGluZS5mcm9tLnggPD0geE1pZGRsZSAmJiBoTGluZS50by54ID49IHhNaWRkbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGZpbmRWZXJ0aWNhbExpbmVJbmRleHModG9wSExpbmUsIHlNaWRkbGUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZMaW5lID0gdGhpcy52TGluZXNbaV07XG4gICAgICAgICAgICBpZiAodkxpbmUuZnJvbS55IDw9IHlNaWRkbGUgJiYgdkxpbmUudG8ueSA+PSB5TWlkZGxlICYmIHRvcEhMaW5lLmludGVyc2VjdGlvbih2TGluZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRSb3coaDFJbmRleCwgaDJJbmRleCwgeU1pZGRsZSkge1xuICAgICAgICBjb25zdCB0YWJsZVJvdyA9IFtdO1xuICAgICAgICAvL2NvbnN0IGNvbENvdW50ID0gdGhpcy52TGluZXMubGVuZ3RoIC0xXG4gICAgICAgIGNvbnN0IHRvcEhMaW5lID0gdGhpcy5oTGluZXNbaDFJbmRleF07XG4gICAgICAgIGNvbnN0IHZMaW5lSW5kZXhlcyA9IHRoaXMuZmluZFZlcnRpY2FsTGluZUluZGV4cyh0b3BITGluZSwgeU1pZGRsZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdkxpbmVJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0VkxpbmUgPSB0aGlzLnZMaW5lc1t2TGluZUluZGV4ZXNbaSAtIDFdXTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0VkxpbmUgPSB0aGlzLnZMaW5lc1t2TGluZUluZGV4ZXNbaV1dO1xuICAgICAgICAgICAgY29uc3QgeE1pZGRsZSA9IChsZWZ0VkxpbmUuZnJvbS54ICsgcmlnaHRWTGluZS5mcm9tLngpIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbUhMaW5lSW5kZXggPSB0aGlzLmZpbmRCb3R0b21MaW5lSW5kZXgoaDJJbmRleCwgeE1pZGRsZSk7XG4gICAgICAgICAgICBjb25zdCBib3R0b21ITGluZSA9IHRoaXMuaExpbmVzW2JvdHRvbUhMaW5lSW5kZXhdO1xuICAgICAgICAgICAgLy8gbWluWFk6IHt4OmxlZnRWTGluZS5mcm9tLngseTp0b3BITGluZS5mcm9tLnl9LFxuICAgICAgICAgICAgLy8gbWF4WFk6IHt4OnJpZ2h0VkxpbmUuZnJvbS54LHk6Ym90dG9tSExpbmUuZnJvbS55fSxcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICBtaW5YWTogbmV3IFBvaW50KGxlZnRWTGluZS5mcm9tLngsIHRvcEhMaW5lLmZyb20ueSksXG4gICAgICAgICAgICAgICAgbWF4WFk6IG5ldyBQb2ludChyaWdodFZMaW5lLmZyb20ueCwgYm90dG9tSExpbmUuZnJvbS55KSxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmlnaHRWTGluZS5mcm9tLnggLSBsZWZ0VkxpbmUuZnJvbS54LFxuICAgICAgICAgICAgICAgIGhlaWdodDogYm90dG9tSExpbmUuZnJvbS55IC0gdG9wSExpbmUuZnJvbS55LFxuICAgICAgICAgICAgICAgIHRleHQ6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNvbFNwYW4gPSB2TGluZUluZGV4ZXNbaV0gLSB2TGluZUluZGV4ZXNbaSAtIDFdO1xuICAgICAgICAgICAgY29uc3Qgcm93U3BhbiA9IGJvdHRvbUhMaW5lSW5kZXggLSBoMUluZGV4O1xuICAgICAgICAgICAgaWYgKGNvbFNwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgdGFibGVDZWxsLmNvbHNwYW4gPSBjb2xTcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvd1NwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgdGFibGVDZWxsLnJvd3NwYW4gPSByb3dTcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFibGVSb3cucHVzaCh0YWJsZUNlbGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWJsZVJvdztcbiAgICB9XG4gICAgdG9EYXRhKCkge1xuICAgICAgICBjb25zdCByb3dQaXZvdHMgPSB0aGlzLnJvd1Bpdm90cztcbiAgICAgICAgY29uc3QgY29sUGl2b3RzID0gdGhpcy5jb2xQaXZvdHM7XG4gICAgICAgIGNvbnN0IG1pblhZID0gbmV3IFBvaW50KGNvbFBpdm90c1swXSwgcm93UGl2b3RzWzBdKTtcbiAgICAgICAgY29uc3QgbWF4WFkgPSBuZXcgUG9pbnQoY29sUGl2b3RzW2NvbFBpdm90cy5sZW5ndGggLSAxXSwgcm93UGl2b3RzW3Jvd1Bpdm90cy5sZW5ndGggLSAxXSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBUYWJsZURhdGEobWluWFksIG1heFhZLCByb3dQaXZvdHMsIGNvbFBpdm90cyk7XG4gICAgICAgIGZvciAobGV0IGgxID0gMTsgaDEgPCB0aGlzLmhMaW5lcy5sZW5ndGg7IGgxKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZITGluZSA9IHRoaXMuaExpbmVzW2gxIC0gMV07XG4gICAgICAgICAgICBjb25zdCBjdXJySExpbmUgPSB0aGlzLmhMaW5lc1toMV07XG4gICAgICAgICAgICBjb25zdCBZTWlkZGxlID0gKHByZXZITGluZS5mcm9tLnkgKyBjdXJySExpbmUuZnJvbS55KSAvIDI7XG4gICAgICAgICAgICBjb25zdCByb3dEYXRhID0gdGhpcy5nZXRSb3coaDEgLSAxLCBoMSwgWU1pZGRsZSk7XG4gICAgICAgICAgICByZXN1bHQucm93cy5wdXNoKHJvd0RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGFibGUuanMubWFwIl0sIm5hbWVzIjpbIkxpbmUiLCJMaW5lRGlyZWN0aW9uIiwiUG9pbnQiLCJTaGFwZSIsIlRhYmxlRGF0YSIsIlRhYmxlIiwiY29uc3RydWN0b3IiLCJsaW5lIiwiaExpbmVzIiwidkxpbmVzIiwiZGlyZWN0aW9uIiwiSG9yaXpvbnRhbCIsInB1c2giLCJWZXJ0aWNhbCIsImlzVmFsaWQiLCJsZW5ndGgiLCJyb3dQaXZvdHMiLCJyb3dTZXQiLCJTZXQiLCJhZGQiLCJmcm9tIiwieSIsInNvcnQiLCJhIiwiYiIsImNvbFBpdm90cyIsImNvbFNldCIsIngiLCJoYXNJbnRlcnNlY3Rpb24iLCJpbnRlcnNlY3Rpb24iLCJmbGFnIiwidmFsaWQiLCJ2TGluZSIsInAiLCJoTGluZSIsImdldFNhbWVIb3Jpem9udGFsIiwic2FtZSIsIm90aGVyIiwic2hpZnQiLCJnZXRTYW1lVmVydGljYWwiLCJtZXJnZUhvcml6b250YWxMaW5lcyIsImxpbmVzIiwibDEiLCJsMiIsIm1pblgiLCJtYXhYIiwidG8iLCJyZXN1bHRMaW5lIiwiaSIsInByZXZMaW5lIiwiY3VyckxpbmUiLCJNYXRoIiwiYWJzIiwidG9sZXJhbmNlIiwiZ2FwTGluZSIsImFkZEdhcCIsIm1lcmdlVmVydGljYWxMaW5lcyIsIm1pblkiLCJtYXhZIiwibm9ybWFsaXplIiwiZmlsdGVyIiwibCIsImludGVyc2VjdGlvbnMiLCJuZXdITGluZXMiLCJtZXJnZWQiLCJuZXdWTGluZXMiLCJ2ZXJ0aWNhbEV4aXN0cyIsInkxIiwieTIiLCJFcnJvciIsImdhcCIsImdhcHMiLCJob3Jpem9udGFsRXhpc3RzIiwieDEiLCJ4MiIsImZpbmRCb3R0b21MaW5lSW5kZXgiLCJoMkluZGV4IiwieE1pZGRsZSIsImZpbmRWZXJ0aWNhbExpbmVJbmRleHMiLCJ0b3BITGluZSIsInlNaWRkbGUiLCJyZXN1bHQiLCJnZXRSb3ciLCJoMUluZGV4IiwidGFibGVSb3ciLCJ2TGluZUluZGV4ZXMiLCJsZWZ0VkxpbmUiLCJyaWdodFZMaW5lIiwiYm90dG9tSExpbmVJbmRleCIsImJvdHRvbUhMaW5lIiwidGFibGVDZWxsIiwibWluWFkiLCJtYXhYWSIsIndpZHRoIiwiaGVpZ2h0IiwidGV4dCIsImNvbFNwYW4iLCJyb3dTcGFuIiwiY29sc3BhbiIsInJvd3NwYW4iLCJ0b0RhdGEiLCJoMSIsInByZXZITGluZSIsImN1cnJITGluZSIsIllNaWRkbGUiLCJyb3dEYXRhIiwicm93cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Table.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/TableData.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/TableData.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TableData: () => (/* binding */ TableData)\n/* harmony export */ });\nclass TableData {\n    constructor(minXY, maxXY, rowPivots, colPivots){\n        this.minXY = minXY;\n        this.maxXY = maxXY;\n        this.rows = [];\n        this.rowPivots = rowPivots;\n        this.colPivots = colPivots;\n    }\n    findCell(x, y) {\n        if (x >= this.minXY.x && y >= this.minXY.y && x <= this.maxXY.x && y <= this.maxXY.y) {\n            for (const row of this.rows){\n                for (const cell of row){\n                    if (cell.minXY.x <= x && cell.minXY.y <= y && cell.maxXY.x >= x && cell.maxXY.y >= y) {\n                        return cell;\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n    get cellCount() {\n        return this.rows.reduce((acc, row)=>acc + row.length, 0);\n    }\n    get rowCount() {\n        return this.rows.length;\n    }\n    check() {\n        // const cellCounts:Array<number> = []\n        //\n        // for (const row of this.rows) {\n        //     let cellNum = 0\n        //     for (const cell of row) {\n        //         cellNum += cell.colspan || 1\n        //     }\n        //     cellCounts.push(cellNum)\n        // }\n        //\n        // for (let i = 1; i < cellCounts.length; i++) {\n        //     if (cellCounts[i] !== cellCounts[i - 1]) {\n        //         return false\n        //     }\n        // }\n        const virtualCellCount = (this.colPivots.length - 1) * (this.rowPivots.length - 1);\n        let allCellCount = 0;\n        for (const row of this.rows){\n            for (const cell of row){\n                const count = (cell.colspan || 1) * (cell.rowspan || 1);\n                allCellCount += count;\n            }\n        }\n        if (virtualCellCount !== allCellCount) {\n            return false;\n        }\n        return true;\n    }\n    toArray() {\n        const tableArr = [];\n        for (const row of this.rows){\n            const rowArr = [];\n            for (const cell of row){\n                let text = cell.text.join(\"\");\n                text = text.replace(/^[\\s]+|[\\s]+$/g, \"\");\n                text = text.trim();\n                rowArr.push(text);\n            }\n            tableArr.push(rowArr);\n        }\n        return tableArr;\n    }\n} //# sourceMappingURL=TableData.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9nZW9tZXRyeS9UYWJsZURhdGEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BO0lBTVRDLFlBQVlDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsQ0FBRTtRQUM1QyxJQUFJLENBQUNILEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNHLElBQUksR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDRixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtJQUNyQjtJQUNBRSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNYLElBQUlELEtBQUssSUFBSSxDQUFDTixLQUFLLENBQUNNLENBQUMsSUFBSUMsS0FBSyxJQUFJLENBQUNQLEtBQUssQ0FBQ08sQ0FBQyxJQUFJRCxLQUFLLElBQUksQ0FBQ0wsS0FBSyxDQUFDSyxDQUFDLElBQUlDLEtBQUssSUFBSSxDQUFDTixLQUFLLENBQUNNLENBQUMsRUFBRTtZQUNsRixLQUFLLE1BQU1DLE9BQU8sSUFBSSxDQUFDSixJQUFJLENBQUU7Z0JBQ3pCLEtBQUssTUFBTUssUUFBUUQsSUFBSztvQkFDcEIsSUFBSUMsS0FBS1QsS0FBSyxDQUFDTSxDQUFDLElBQUlBLEtBQUtHLEtBQUtULEtBQUssQ0FBQ08sQ0FBQyxJQUFJQSxLQUFLRSxLQUFLUixLQUFLLENBQUNLLENBQUMsSUFBSUEsS0FBS0csS0FBS1IsS0FBSyxDQUFDTSxDQUFDLElBQUlBLEdBQUc7d0JBQ2xGLE9BQU9FO29CQUNYO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLE9BQU9DO0lBQ1g7SUFDQSxJQUFJQyxZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUNQLElBQUksQ0FBQ1EsTUFBTSxDQUFDLENBQUNDLEtBQUtMLE1BQVFLLE1BQU1MLElBQUlNLE1BQU0sRUFBRTtJQUM1RDtJQUNBLElBQUlDLFdBQVc7UUFDWCxPQUFPLElBQUksQ0FBQ1gsSUFBSSxDQUFDVSxNQUFNO0lBQzNCO0lBQ0FFLFFBQVE7UUFDSixzQ0FBc0M7UUFDdEMsRUFBRTtRQUNGLGlDQUFpQztRQUNqQyxzQkFBc0I7UUFDdEIsZ0NBQWdDO1FBQ2hDLHVDQUF1QztRQUN2QyxRQUFRO1FBQ1IsK0JBQStCO1FBQy9CLElBQUk7UUFDSixFQUFFO1FBQ0YsZ0RBQWdEO1FBQ2hELGlEQUFpRDtRQUNqRCx1QkFBdUI7UUFDdkIsUUFBUTtRQUNSLElBQUk7UUFDSixNQUFNQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUNkLFNBQVMsQ0FBQ1csTUFBTSxHQUFHLEtBQU0sS0FBSSxDQUFDWixTQUFTLENBQUNZLE1BQU0sR0FBRztRQUNoRixJQUFJSSxlQUFlO1FBQ25CLEtBQUssTUFBTVYsT0FBTyxJQUFJLENBQUNKLElBQUksQ0FBRTtZQUN6QixLQUFLLE1BQU1LLFFBQVFELElBQUs7Z0JBQ3BCLE1BQU1XLFFBQVEsQ0FBQ1YsS0FBS1csT0FBTyxJQUFJLEtBQU1YLENBQUFBLEtBQUtZLE9BQU8sSUFBSTtnQkFDckRILGdCQUFnQkM7WUFDcEI7UUFDSjtRQUNBLElBQUlGLHFCQUFxQkMsY0FBYztZQUNuQyxPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQUksVUFBVTtRQUNOLE1BQU1DLFdBQVcsRUFBRTtRQUNuQixLQUFLLE1BQU1mLE9BQU8sSUFBSSxDQUFDSixJQUFJLENBQUU7WUFDekIsTUFBTW9CLFNBQVMsRUFBRTtZQUNqQixLQUFLLE1BQU1mLFFBQVFELElBQUs7Z0JBQ3BCLElBQUlpQixPQUFPaEIsS0FBS2dCLElBQUksQ0FBQ0MsSUFBSSxDQUFDO2dCQUMxQkQsT0FBT0EsS0FBS0UsT0FBTyxDQUFDLGtCQUFrQjtnQkFDdENGLE9BQU9BLEtBQUtHLElBQUk7Z0JBQ2hCSixPQUFPSyxJQUFJLENBQUNKO1lBQ2hCO1lBQ0FGLFNBQVNNLElBQUksQ0FBQ0w7UUFDbEI7UUFDQSxPQUFPRDtJQUNYO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1jYXJlZXItYXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL3BkZi1wYXJzZS9kaXN0L3BkZi1wYXJzZS9lc20vZ2VvbWV0cnkvVGFibGVEYXRhLmpzPzc2ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFRhYmxlRGF0YSB7XG4gICAgbWluWFk7XG4gICAgbWF4WFk7XG4gICAgcm93cztcbiAgICByb3dQaXZvdHM7XG4gICAgY29sUGl2b3RzO1xuICAgIGNvbnN0cnVjdG9yKG1pblhZLCBtYXhYWSwgcm93UGl2b3RzLCBjb2xQaXZvdHMpIHtcbiAgICAgICAgdGhpcy5taW5YWSA9IG1pblhZO1xuICAgICAgICB0aGlzLm1heFhZID0gbWF4WFk7XG4gICAgICAgIHRoaXMucm93cyA9IFtdO1xuICAgICAgICB0aGlzLnJvd1Bpdm90cyA9IHJvd1Bpdm90cztcbiAgICAgICAgdGhpcy5jb2xQaXZvdHMgPSBjb2xQaXZvdHM7XG4gICAgfVxuICAgIGZpbmRDZWxsKHgsIHkpIHtcbiAgICAgICAgaWYgKHggPj0gdGhpcy5taW5YWS54ICYmIHkgPj0gdGhpcy5taW5YWS55ICYmIHggPD0gdGhpcy5tYXhYWS54ICYmIHkgPD0gdGhpcy5tYXhYWS55KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0aGlzLnJvd3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsLm1pblhZLnggPD0geCAmJiBjZWxsLm1pblhZLnkgPD0geSAmJiBjZWxsLm1heFhZLnggPj0geCAmJiBjZWxsLm1heFhZLnkgPj0geSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGNlbGxDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93cy5yZWR1Y2UoKGFjYywgcm93KSA9PiBhY2MgKyByb3cubGVuZ3RoLCAwKTtcbiAgICB9XG4gICAgZ2V0IHJvd0NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzLmxlbmd0aDtcbiAgICB9XG4gICAgY2hlY2soKSB7XG4gICAgICAgIC8vIGNvbnN0IGNlbGxDb3VudHM6QXJyYXk8bnVtYmVyPiA9IFtdXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGZvciAoY29uc3Qgcm93IG9mIHRoaXMucm93cykge1xuICAgICAgICAvLyAgICAgbGV0IGNlbGxOdW0gPSAwXG4gICAgICAgIC8vICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XG4gICAgICAgIC8vICAgICAgICAgY2VsbE51bSArPSBjZWxsLmNvbHNwYW4gfHwgMVxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgY2VsbENvdW50cy5wdXNoKGNlbGxOdW0pXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gZm9yIChsZXQgaSA9IDE7IGkgPCBjZWxsQ291bnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vICAgICBpZiAoY2VsbENvdW50c1tpXSAhPT0gY2VsbENvdW50c1tpIC0gMV0pIHtcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICBjb25zdCB2aXJ0dWFsQ2VsbENvdW50ID0gKHRoaXMuY29sUGl2b3RzLmxlbmd0aCAtIDEpICogKHRoaXMucm93UGl2b3RzLmxlbmd0aCAtIDEpO1xuICAgICAgICBsZXQgYWxsQ2VsbENvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5yb3dzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSAoY2VsbC5jb2xzcGFuIHx8IDEpICogKGNlbGwucm93c3BhbiB8fCAxKTtcbiAgICAgICAgICAgICAgICBhbGxDZWxsQ291bnQgKz0gY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpcnR1YWxDZWxsQ291bnQgIT09IGFsbENlbGxDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0b0FycmF5KCkge1xuICAgICAgICBjb25zdCB0YWJsZUFyciA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0aGlzLnJvd3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvd0FyciA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHJvdykge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gY2VsbC50ZXh0LmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL15bXFxzXSt8W1xcc10rJC9nLCAnJyk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQudHJpbSgpO1xuICAgICAgICAgICAgICAgIHJvd0Fyci5wdXNoKHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFibGVBcnIucHVzaChyb3dBcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWJsZUFycjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYWJsZURhdGEuanMubWFwIl0sIm5hbWVzIjpbIlRhYmxlRGF0YSIsImNvbnN0cnVjdG9yIiwibWluWFkiLCJtYXhYWSIsInJvd1Bpdm90cyIsImNvbFBpdm90cyIsInJvd3MiLCJmaW5kQ2VsbCIsIngiLCJ5Iiwicm93IiwiY2VsbCIsInVuZGVmaW5lZCIsImNlbGxDb3VudCIsInJlZHVjZSIsImFjYyIsImxlbmd0aCIsInJvd0NvdW50IiwiY2hlY2siLCJ2aXJ0dWFsQ2VsbENvdW50IiwiYWxsQ2VsbENvdW50IiwiY291bnQiLCJjb2xzcGFuIiwicm93c3BhbiIsInRvQXJyYXkiLCJ0YWJsZUFyciIsInJvd0FyciIsInRleHQiLCJqb2luIiwicmVwbGFjZSIsInRyaW0iLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/TableData.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Line: () => (/* reexport safe */ _Line_js__WEBPACK_IMPORTED_MODULE_0__.Line),\n/* harmony export */   LineDirection: () => (/* reexport safe */ _Line_js__WEBPACK_IMPORTED_MODULE_0__.LineDirection),\n/* harmony export */   LineStore: () => (/* reexport safe */ _LineStore_js__WEBPACK_IMPORTED_MODULE_1__.LineStore),\n/* harmony export */   Point: () => (/* reexport safe */ _Point_js__WEBPACK_IMPORTED_MODULE_2__.Point),\n/* harmony export */   Rectangle: () => (/* reexport safe */ _Rectangle_js__WEBPACK_IMPORTED_MODULE_3__.Rectangle),\n/* harmony export */   Shape: () => (/* reexport safe */ _Shape_js__WEBPACK_IMPORTED_MODULE_4__.Shape),\n/* harmony export */   Table: () => (/* reexport safe */ _Table_js__WEBPACK_IMPORTED_MODULE_5__.Table)\n/* harmony export */ });\n/* harmony import */ var _Line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Line.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Line.js\");\n/* harmony import */ var _LineStore_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LineStore.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/LineStore.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Point.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Point.js\");\n/* harmony import */ var _Rectangle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rectangle.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Rectangle.js\");\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Shape.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Shape.js\");\n/* harmony import */ var _Table_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Table.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Table.js\");\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9nZW9tZXRyeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ0w7QUFDUjtBQUNRO0FBQ1I7QUFDQSxDQUNuQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1jYXJlZXItYXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL3BkZi1wYXJzZS9kaXN0L3BkZi1wYXJzZS9lc20vZ2VvbWV0cnkvaW5kZXguanM/MWY0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBMaW5lLCBMaW5lRGlyZWN0aW9uIH0gZnJvbSAnLi9MaW5lLmpzJztcbmV4cG9ydCB7IExpbmVTdG9yZSB9IGZyb20gJy4vTGluZVN0b3JlLmpzJztcbmV4cG9ydCB7IFBvaW50IH0gZnJvbSAnLi9Qb2ludC5qcyc7XG5leHBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuL1JlY3RhbmdsZS5qcyc7XG5leHBvcnQgeyBTaGFwZSB9IGZyb20gJy4vU2hhcGUuanMnO1xuZXhwb3J0IHsgVGFibGUgfSBmcm9tICcuL1RhYmxlLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJMaW5lIiwiTGluZURpcmVjdGlvbiIsIkxpbmVTdG9yZSIsIlBvaW50IiwiUmVjdGFuZ2xlIiwiU2hhcGUiLCJUYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/pdf-parse/dist/pdf-parse/esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortException: () => (/* reexport safe */ _Exception_js__WEBPACK_IMPORTED_MODULE_2__.AbortException),\n/* harmony export */   FormatError: () => (/* reexport safe */ _Exception_js__WEBPACK_IMPORTED_MODULE_2__.FormatError),\n/* harmony export */   InvalidPDFException: () => (/* reexport safe */ _Exception_js__WEBPACK_IMPORTED_MODULE_2__.InvalidPDFException),\n/* harmony export */   Line: () => (/* reexport safe */ _geometry_index_js__WEBPACK_IMPORTED_MODULE_3__.Line),\n/* harmony export */   LineDirection: () => (/* reexport safe */ _geometry_index_js__WEBPACK_IMPORTED_MODULE_3__.LineDirection),\n/* harmony export */   LineStore: () => (/* reexport safe */ _geometry_index_js__WEBPACK_IMPORTED_MODULE_3__.LineStore),\n/* harmony export */   PDFParse: () => (/* reexport safe */ _PDFParse_js__WEBPACK_IMPORTED_MODULE_0__.PDFParse),\n/* harmony export */   PasswordException: () => (/* reexport safe */ _Exception_js__WEBPACK_IMPORTED_MODULE_2__.PasswordException),\n/* harmony export */   Point: () => (/* reexport safe */ _geometry_index_js__WEBPACK_IMPORTED_MODULE_3__.Point),\n/* harmony export */   Rectangle: () => (/* reexport safe */ _geometry_index_js__WEBPACK_IMPORTED_MODULE_3__.Rectangle),\n/* harmony export */   ResponseException: () => (/* reexport safe */ _Exception_js__WEBPACK_IMPORTED_MODULE_2__.ResponseException),\n/* harmony export */   Shape: () => (/* reexport safe */ _geometry_index_js__WEBPACK_IMPORTED_MODULE_3__.Shape),\n/* harmony export */   Table: () => (/* reexport safe */ _geometry_index_js__WEBPACK_IMPORTED_MODULE_3__.Table),\n/* harmony export */   UnknownErrorException: () => (/* reexport safe */ _Exception_js__WEBPACK_IMPORTED_MODULE_2__.UnknownErrorException),\n/* harmony export */   VerbosityLevel: () => (/* reexport safe */ pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_1__.VerbosityLevel),\n/* harmony export */   getException: () => (/* reexport safe */ _Exception_js__WEBPACK_IMPORTED_MODULE_2__.getException)\n/* harmony export */ });\n/* harmony import */ var _PDFParse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PDFParse.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/PDFParse.js\");\n/* harmony import */ var pdfjs_dist_legacy_build_pdf_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pdfjs-dist/legacy/build/pdf.mjs */ \"(rsc)/./node_modules/pdf-parse/node_modules/pdfjs-dist/legacy/build/pdf.mjs\");\n/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Exception.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/Exception.js\");\n/* harmony import */ var _geometry_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry/index.js */ \"(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/geometry/index.js\");\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUN3QjtBQUNsQztBQUNLO0FBQ2hCLENBQ3BCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWNhcmVlci1hc3Npc3RhbnQvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL2Rpc3QvcGRmLXBhcnNlL2VzbS9pbmRleC5qcz83ZDU5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBERlBhcnNlIH0gZnJvbSAnLi9QREZQYXJzZS5qcyc7XG5leHBvcnQgeyBWZXJib3NpdHlMZXZlbCB9IGZyb20gJ3BkZmpzLWRpc3QvbGVnYWN5L2J1aWxkL3BkZi5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9FeGNlcHRpb24uanMnO1xuZXhwb3J0ICogZnJvbSAnLi9nZW9tZXRyeS9pbmRleC5qcyc7XG5leHBvcnQgeyBQREZQYXJzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIlBERlBhcnNlIiwiVmVyYm9zaXR5TGV2ZWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/dist/pdf-parse/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdf-parse/node_modules/pdfjs-dist/legacy/build/pdf.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pdf-parse/node_modules/pdfjs-dist/legacy/build/pdf.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortException: () => (/* binding */ AbortException),\n/* harmony export */   AnnotationEditorLayer: () => (/* binding */ AnnotationEditorLayer),\n/* harmony export */   AnnotationEditorParamsType: () => (/* binding */ AnnotationEditorParamsType),\n/* harmony export */   AnnotationEditorType: () => (/* binding */ AnnotationEditorType),\n/* harmony export */   AnnotationEditorUIManager: () => (/* binding */ AnnotationEditorUIManager),\n/* harmony export */   AnnotationLayer: () => (/* binding */ AnnotationLayer),\n/* harmony export */   AnnotationMode: () => (/* binding */ AnnotationMode),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   CSSConstants: () => (/* binding */ CSSConstants),\n/* harmony export */   ColorPicker: () => (/* binding */ ColorPicker),\n/* harmony export */   DOMSVGFactory: () => (/* binding */ DOMSVGFactory),\n/* harmony export */   DrawLayer: () => (/* binding */ DrawLayer),\n/* harmony export */   FeatureTest: () => (/* binding */ util_FeatureTest),\n/* harmony export */   GlobalWorkerOptions: () => (/* binding */ GlobalWorkerOptions),\n/* harmony export */   ImageKind: () => (/* binding */ util_ImageKind),\n/* harmony export */   InvalidPDFException: () => (/* binding */ InvalidPDFException),\n/* harmony export */   MathClamp: () => (/* binding */ MathClamp),\n/* harmony export */   OPS: () => (/* binding */ OPS),\n/* harmony export */   OutputScale: () => (/* binding */ OutputScale),\n/* harmony export */   PDFDataRangeTransport: () => (/* binding */ PDFDataRangeTransport),\n/* harmony export */   PDFDateString: () => (/* binding */ PDFDateString),\n/* harmony export */   PDFWorker: () => (/* binding */ PDFWorker),\n/* harmony export */   PasswordResponses: () => (/* binding */ PasswordResponses),\n/* harmony export */   PermissionFlag: () => (/* binding */ PermissionFlag),\n/* harmony export */   PixelsPerInch: () => (/* binding */ PixelsPerInch),\n/* harmony export */   RenderingCancelledException: () => (/* binding */ RenderingCancelledException),\n/* harmony export */   ResponseException: () => (/* binding */ ResponseException),\n/* harmony export */   SignatureExtractor: () => (/* binding */ SignatureExtractor),\n/* harmony export */   SupportedImageMimeTypes: () => (/* binding */ SupportedImageMimeTypes),\n/* harmony export */   TextLayer: () => (/* binding */ TextLayer),\n/* harmony export */   TouchManager: () => (/* binding */ TouchManager),\n/* harmony export */   Util: () => (/* binding */ Util),\n/* harmony export */   VerbosityLevel: () => (/* binding */ VerbosityLevel),\n/* harmony export */   XfaLayer: () => (/* binding */ XfaLayer),\n/* harmony export */   applyOpacity: () => (/* binding */ applyOpacity),\n/* harmony export */   build: () => (/* binding */ build),\n/* harmony export */   createValidAbsoluteUrl: () => (/* binding */ createValidAbsoluteUrl),\n/* harmony export */   fetchData: () => (/* binding */ fetchData),\n/* harmony export */   findContrastColor: () => (/* binding */ findContrastColor),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getFilenameFromUrl: () => (/* binding */ getFilenameFromUrl),\n/* harmony export */   getPdfFilenameFromUrl: () => (/* binding */ getPdfFilenameFromUrl),\n/* harmony export */   getRGB: () => (/* binding */ getRGB),\n/* harmony export */   getUuid: () => (/* binding */ getUuid),\n/* harmony export */   getXfaPageViewport: () => (/* binding */ getXfaPageViewport),\n/* harmony export */   isDataScheme: () => (/* binding */ isDataScheme),\n/* harmony export */   isPdfFile: () => (/* binding */ isPdfFile),\n/* harmony export */   isValidExplicitDest: () => (/* binding */ isValidExplicitDest),\n/* harmony export */   noContextMenu: () => (/* binding */ noContextMenu),\n/* harmony export */   normalizeUnicode: () => (/* binding */ normalizeUnicode),\n/* harmony export */   renderRichText: () => (/* binding */ renderRichText),\n/* harmony export */   setLayerDimensions: () => (/* binding */ setLayerDimensions),\n/* harmony export */   shadow: () => (/* binding */ shadow),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent),\n/* harmony export */   updateUrlHash: () => (/* binding */ updateUrlHash),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2024 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */ /**\n * pdfjsVersion = 5.4.296\n * pdfjsBuild = f56dc8601\n */ /******/ var __webpack_modules__ = {\n    /***/ 34: /***/ (module, __unused_webpack_exports, __nested_webpack_require_947__)=>{\n        var isCallable = __nested_webpack_require_947__(4901);\n        module.exports = function(it) {\n            return typeof it == \"object\" ? it !== null : isCallable(it);\n        };\n    /***/ },\n    /***/ 81: /***/ (module, __unused_webpack_exports, __nested_webpack_require_1215__)=>{\n        var call = __nested_webpack_require_1215__(9565);\n        var aCallable = __nested_webpack_require_1215__(9306);\n        var anObject = __nested_webpack_require_1215__(8551);\n        var tryToString = __nested_webpack_require_1215__(6823);\n        var getIteratorMethod = __nested_webpack_require_1215__(851);\n        var $TypeError = TypeError;\n        module.exports = function(argument, usingIterator) {\n            var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;\n            if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));\n            throw new $TypeError(tryToString(argument) + \" is not iterable\");\n        };\n    /***/ },\n    /***/ 116: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_1962__)=>{\n        var $ = __nested_webpack_require_1962__(6518);\n        var call = __nested_webpack_require_1962__(9565);\n        var iterate = __nested_webpack_require_1962__(2652);\n        var aCallable = __nested_webpack_require_1962__(9306);\n        var anObject = __nested_webpack_require_1962__(8551);\n        var getIteratorDirect = __nested_webpack_require_1962__(1767);\n        var iteratorClose = __nested_webpack_require_1962__(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_1962__(4549);\n        var findWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError(\"find\", TypeError);\n        // `Iterator.prototype.find` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.find\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: findWithoutClosingOnEarlyError\n        }, {\n            find: function find(predicate) {\n                anObject(this);\n                try {\n                    aCallable(predicate);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (findWithoutClosingOnEarlyError) return call(findWithoutClosingOnEarlyError, this, predicate);\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                return iterate(record, function(value, stop) {\n                    if (predicate(value, counter++)) return stop(value);\n                }, {\n                    IS_RECORD: true,\n                    INTERRUPTED: true\n                }).result;\n            }\n        });\n    /***/ },\n    /***/ 283: /***/ (module, __unused_webpack_exports, __nested_webpack_require_3597__)=>{\n        var uncurryThis = __nested_webpack_require_3597__(9504);\n        var fails = __nested_webpack_require_3597__(9039);\n        var isCallable = __nested_webpack_require_3597__(4901);\n        var hasOwn = __nested_webpack_require_3597__(9297);\n        var DESCRIPTORS = __nested_webpack_require_3597__(3724);\n        var CONFIGURABLE_FUNCTION_NAME = __nested_webpack_require_3597__(350).CONFIGURABLE;\n        var inspectSource = __nested_webpack_require_3597__(3706);\n        var InternalStateModule = __nested_webpack_require_3597__(1181);\n        var enforceInternalState = InternalStateModule.enforce;\n        var getInternalState = InternalStateModule.get;\n        var $String = String;\n        // eslint-disable-next-line es/no-object-defineproperty -- safe\n        var defineProperty = Object.defineProperty;\n        var stringSlice = uncurryThis(\"\".slice);\n        var replace = uncurryThis(\"\".replace);\n        var join = uncurryThis([].join);\n        var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {\n            return defineProperty(function() {}, \"length\", {\n                value: 8\n            }).length !== 8;\n        });\n        var TEMPLATE = String(String).split(\"String\");\n        var makeBuiltIn = module.exports = function(value, name, options) {\n            if (stringSlice($String(name), 0, 7) === \"Symbol(\") {\n                name = \"[\" + replace($String(name), /^Symbol\\(([^)]*)\\).*$/, \"$1\") + \"]\";\n            }\n            if (options && options.getter) name = \"get \" + name;\n            if (options && options.setter) name = \"set \" + name;\n            if (!hasOwn(value, \"name\") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {\n                if (DESCRIPTORS) defineProperty(value, \"name\", {\n                    value: name,\n                    configurable: true\n                });\n                else value.name = name;\n            }\n            if (CONFIGURABLE_LENGTH && options && hasOwn(options, \"arity\") && value.length !== options.arity) {\n                defineProperty(value, \"length\", {\n                    value: options.arity\n                });\n            }\n            try {\n                if (options && hasOwn(options, \"constructor\") && options.constructor) {\n                    if (DESCRIPTORS) defineProperty(value, \"prototype\", {\n                        writable: false\n                    });\n                // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n                } else if (value.prototype) value.prototype = undefined;\n            } catch (error) {}\n            var state = enforceInternalState(value);\n            if (!hasOwn(state, \"source\")) {\n                state.source = join(TEMPLATE, typeof name == \"string\" ? name : \"\");\n            }\n            return value;\n        };\n        // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n        // eslint-disable-next-line no-extend-native -- required\n        Function.prototype.toString = makeBuiltIn(function toString() {\n            return isCallable(this) && getInternalState(this).source || inspectSource(this);\n        }, \"toString\");\n    /***/ },\n    /***/ 350: /***/ (module, __unused_webpack_exports, __nested_webpack_require_6788__)=>{\n        var DESCRIPTORS = __nested_webpack_require_6788__(3724);\n        var hasOwn = __nested_webpack_require_6788__(9297);\n        var FunctionPrototype = Function.prototype;\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n        var EXISTS = hasOwn(FunctionPrototype, \"name\");\n        // additional protection from minified / mangled / dropped function names\n        var PROPER = EXISTS && (function something() {}).name === \"something\";\n        var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, \"name\").configurable);\n        module.exports = {\n            EXISTS: EXISTS,\n            PROPER: PROPER,\n            CONFIGURABLE: CONFIGURABLE\n        };\n    /***/ },\n    /***/ 397: /***/ (module, __unused_webpack_exports, __nested_webpack_require_7667__)=>{\n        var getBuiltIn = __nested_webpack_require_7667__(7751);\n        module.exports = getBuiltIn(\"document\", \"documentElement\");\n    /***/ },\n    /***/ 421: /***/ (module)=>{\n        module.exports = {};\n    /***/ },\n    /***/ 456: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_7972__)=>{\n        var $ = __nested_webpack_require_7972__(6518);\n        var globalThis1 = __nested_webpack_require_7972__(4576);\n        var uncurryThis = __nested_webpack_require_7972__(9504);\n        var anUint8Array = __nested_webpack_require_7972__(4154);\n        var notDetached = __nested_webpack_require_7972__(5169);\n        var numberToString = uncurryThis(1.1.toString);\n        var Uint8Array1 = globalThis1.Uint8Array;\n        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array1 || !Uint8Array1.prototype.toHex || !function() {\n            try {\n                var target = new Uint8Array1([\n                    255,\n                    255,\n                    255,\n                    255,\n                    255,\n                    255,\n                    255,\n                    255\n                ]);\n                return target.toHex() === \"ffffffffffffffff\";\n            } catch (error) {\n                return false;\n            }\n        }();\n        // `Uint8Array.prototype.toHex` method\n        // https://github.com/tc39/proposal-arraybuffer-base64\n        if (Uint8Array1) $({\n            target: \"Uint8Array\",\n            proto: true,\n            forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS\n        }, {\n            toHex: function toHex() {\n                anUint8Array(this);\n                notDetached(this.buffer);\n                var result = \"\";\n                for(var i = 0, length = this.length; i < length; i++){\n                    var hex = numberToString(this[i], 16);\n                    result += hex.length === 1 ? \"0\" + hex : hex;\n                }\n                return result;\n            }\n        });\n    /***/ },\n    /***/ 507: /***/ (module, __unused_webpack_exports, __nested_webpack_require_9659__)=>{\n        var call = __nested_webpack_require_9659__(9565);\n        module.exports = function(record, fn, ITERATOR_INSTEAD_OF_RECORD) {\n            var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;\n            var next = record.next;\n            var step, result;\n            while(!(step = call(next, iterator)).done){\n                result = fn(step.value);\n                if (result !== undefined) return result;\n            }\n        };\n    /***/ },\n    /***/ 531: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_10218__)=>{\n        var $ = __nested_webpack_require_10218__(6518);\n        var call = __nested_webpack_require_10218__(9565);\n        var aCallable = __nested_webpack_require_10218__(9306);\n        var anObject = __nested_webpack_require_10218__(8551);\n        var getIteratorDirect = __nested_webpack_require_10218__(1767);\n        var getIteratorFlattenable = __nested_webpack_require_10218__(8646);\n        var createIteratorProxy = __nested_webpack_require_10218__(9462);\n        var iteratorClose = __nested_webpack_require_10218__(9539);\n        var IS_PURE = __nested_webpack_require_10218__(6395);\n        var iteratorHelperThrowsOnInvalidIterator = __nested_webpack_require_10218__(684);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_10218__(4549);\n        var FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator(\"flatMap\", function() {});\n        var flatMapWithoutClosingOnEarlyError = !IS_PURE && !FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError(\"flatMap\", TypeError);\n        var FORCED = IS_PURE || FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || flatMapWithoutClosingOnEarlyError;\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            var mapper = this.mapper;\n            var result, inner;\n            while(true){\n                if (inner = this.inner) try {\n                    result = anObject(call(inner.next, inner.iterator));\n                    if (!result.done) return result.value;\n                    this.inner = null;\n                } catch (error) {\n                    iteratorClose(iterator, \"throw\", error);\n                }\n                result = anObject(call(this.next, iterator));\n                if (this.done = !!result.done) return;\n                try {\n                    this.inner = getIteratorFlattenable(mapper(result.value, this.counter++), false);\n                } catch (error) {\n                    iteratorClose(iterator, \"throw\", error);\n                }\n            }\n        });\n        // `Iterator.prototype.flatMap` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.flatmap\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            flatMap: function flatMap(mapper) {\n                anObject(this);\n                try {\n                    aCallable(mapper);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (flatMapWithoutClosingOnEarlyError) return call(flatMapWithoutClosingOnEarlyError, this, mapper);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    mapper: mapper,\n                    inner: null\n                });\n            }\n        });\n    /***/ },\n    /***/ 616: /***/ (module, __unused_webpack_exports, __nested_webpack_require_13080__)=>{\n        var fails = __nested_webpack_require_13080__(9039);\n        module.exports = !fails(function() {\n            // eslint-disable-next-line es/no-function-prototype-bind -- safe\n            var test = (function() {}).bind();\n            // eslint-disable-next-line no-prototype-builtins -- safe\n            return typeof test != \"function\" || test.hasOwnProperty(\"prototype\");\n        });\n    /***/ },\n    /***/ 655: /***/ (module, __unused_webpack_exports, __nested_webpack_require_13554__)=>{\n        var classof = __nested_webpack_require_13554__(6955);\n        var $String = String;\n        module.exports = function(argument) {\n            if (classof(argument) === \"Symbol\") throw new TypeError(\"Cannot convert a Symbol value to a string\");\n            return $String(argument);\n        };\n    /***/ },\n    /***/ 679: /***/ (module, __unused_webpack_exports, __nested_webpack_require_13935__)=>{\n        var isPrototypeOf = __nested_webpack_require_13935__(1625);\n        var $TypeError = TypeError;\n        module.exports = function(it, Prototype) {\n            if (isPrototypeOf(Prototype, it)) return it;\n            throw new $TypeError(\"Incorrect invocation\");\n        };\n    /***/ },\n    /***/ 684: /***/ (module)=>{\n        // Should throw an error on invalid iterator\n        // https://issues.chromium.org/issues/336839115\n        module.exports = function(methodName, argument) {\n            // eslint-disable-next-line es/no-iterator -- required for testing\n            var method = typeof Iterator == \"function\" && Iterator.prototype[methodName];\n            if (method) try {\n                method.call({\n                    next: null\n                }, argument).next();\n            } catch (error) {\n                return true;\n            }\n        };\n    /***/ },\n    /***/ 741: /***/ (module)=>{\n        var ceil = Math.ceil;\n        var floor = Math.floor;\n        // `Math.trunc` method\n        // https://tc39.es/ecma262/#sec-math.trunc\n        // eslint-disable-next-line es/no-math-trunc -- safe\n        module.exports = Math.trunc || function trunc(x) {\n            var n = +x;\n            return (n > 0 ? floor : ceil)(n);\n        };\n    /***/ },\n    /***/ 757: /***/ (module, __unused_webpack_exports, __nested_webpack_require_15281__)=>{\n        var getBuiltIn = __nested_webpack_require_15281__(7751);\n        var isCallable = __nested_webpack_require_15281__(4901);\n        var isPrototypeOf = __nested_webpack_require_15281__(1625);\n        var USE_SYMBOL_AS_UID = __nested_webpack_require_15281__(7040);\n        var $Object = Object;\n        module.exports = USE_SYMBOL_AS_UID ? function(it) {\n            return typeof it == \"symbol\";\n        } : function(it) {\n            var $Symbol = getBuiltIn(\"Symbol\");\n            return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n        };\n    /***/ },\n    /***/ 851: /***/ (module, __unused_webpack_exports, __nested_webpack_require_15899__)=>{\n        var classof = __nested_webpack_require_15899__(6955);\n        var getMethod = __nested_webpack_require_15899__(5966);\n        var isNullOrUndefined = __nested_webpack_require_15899__(4117);\n        var Iterators = __nested_webpack_require_15899__(6269);\n        var wellKnownSymbol = __nested_webpack_require_15899__(8227);\n        var ITERATOR = wellKnownSymbol(\"iterator\");\n        module.exports = function(it) {\n            if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR) || getMethod(it, \"@@iterator\") || Iterators[classof(it)];\n        };\n    /***/ },\n    /***/ 944: /***/ (module)=>{\n        var $TypeError = TypeError;\n        module.exports = function(options) {\n            var alphabet = options && options.alphabet;\n            if (alphabet === undefined || alphabet === \"base64\" || alphabet === \"base64url\") return alphabet || \"base64\";\n            throw new $TypeError(\"Incorrect `alphabet` option\");\n        };\n    /***/ },\n    /***/ 1072: /***/ (module, __unused_webpack_exports, __nested_webpack_require_16873__)=>{\n        var internalObjectKeys = __nested_webpack_require_16873__(1828);\n        var enumBugKeys = __nested_webpack_require_16873__(8727);\n        // `Object.keys` method\n        // https://tc39.es/ecma262/#sec-object.keys\n        // eslint-disable-next-line es/no-object-keys -- safe\n        module.exports = Object.keys || function keys(O) {\n            return internalObjectKeys(O, enumBugKeys);\n        };\n    /***/ },\n    /***/ 1103: /***/ (module)=>{\n        module.exports = function(exec) {\n            try {\n                return {\n                    error: false,\n                    value: exec()\n                };\n            } catch (error) {\n                return {\n                    error: true,\n                    value: error\n                };\n            }\n        };\n    /***/ },\n    /***/ 1108: /***/ (module, __unused_webpack_exports, __nested_webpack_require_17735__)=>{\n        var classof = __nested_webpack_require_17735__(6955);\n        module.exports = function(it) {\n            var klass = classof(it);\n            return klass === \"BigInt64Array\" || klass === \"BigUint64Array\";\n        };\n    /***/ },\n    /***/ 1148: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_18059__)=>{\n        var $ = __nested_webpack_require_18059__(6518);\n        var call = __nested_webpack_require_18059__(9565);\n        var iterate = __nested_webpack_require_18059__(2652);\n        var aCallable = __nested_webpack_require_18059__(9306);\n        var anObject = __nested_webpack_require_18059__(8551);\n        var getIteratorDirect = __nested_webpack_require_18059__(1767);\n        var iteratorClose = __nested_webpack_require_18059__(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_18059__(4549);\n        var everyWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError(\"every\", TypeError);\n        // `Iterator.prototype.every` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.every\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: everyWithoutClosingOnEarlyError\n        }, {\n            every: function every(predicate) {\n                anObject(this);\n                try {\n                    aCallable(predicate);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (everyWithoutClosingOnEarlyError) return call(everyWithoutClosingOnEarlyError, this, predicate);\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                return !iterate(record, function(value, stop) {\n                    if (!predicate(value, counter++)) return stop();\n                }, {\n                    IS_RECORD: true,\n                    INTERRUPTED: true\n                }).stopped;\n            }\n        });\n    /***/ },\n    /***/ 1181: /***/ (module, __unused_webpack_exports, __nested_webpack_require_19702__)=>{\n        var NATIVE_WEAK_MAP = __nested_webpack_require_19702__(8622);\n        var globalThis1 = __nested_webpack_require_19702__(4576);\n        var isObject = __nested_webpack_require_19702__(34);\n        var createNonEnumerableProperty = __nested_webpack_require_19702__(6699);\n        var hasOwn = __nested_webpack_require_19702__(9297);\n        var shared = __nested_webpack_require_19702__(7629);\n        var sharedKey = __nested_webpack_require_19702__(6119);\n        var hiddenKeys = __nested_webpack_require_19702__(421);\n        var OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\n        var TypeError1 = globalThis1.TypeError;\n        var WeakMap1 = globalThis1.WeakMap;\n        var set, get, has;\n        var enforce = function(it) {\n            return has(it) ? get(it) : set(it, {});\n        };\n        var getterFor = function(TYPE) {\n            return function(it) {\n                var state;\n                if (!isObject(it) || (state = get(it)).type !== TYPE) {\n                    throw new TypeError1(\"Incompatible receiver, \" + TYPE + \" required\");\n                }\n                return state;\n            };\n        };\n        if (NATIVE_WEAK_MAP || shared.state) {\n            var store = shared.state || (shared.state = new WeakMap1());\n            /* eslint-disable no-self-assign -- prototype methods protection */ store.get = store.get;\n            store.has = store.has;\n            store.set = store.set;\n            /* eslint-enable no-self-assign -- prototype methods protection */ set = function(it, metadata) {\n                if (store.has(it)) throw new TypeError1(OBJECT_ALREADY_INITIALIZED);\n                metadata.facade = it;\n                store.set(it, metadata);\n                return metadata;\n            };\n            get = function(it) {\n                return store.get(it) || {};\n            };\n            has = function(it) {\n                return store.has(it);\n            };\n        } else {\n            var STATE = sharedKey(\"state\");\n            hiddenKeys[STATE] = true;\n            set = function(it, metadata) {\n                if (hasOwn(it, STATE)) throw new TypeError1(OBJECT_ALREADY_INITIALIZED);\n                metadata.facade = it;\n                createNonEnumerableProperty(it, STATE, metadata);\n                return metadata;\n            };\n            get = function(it) {\n                return hasOwn(it, STATE) ? it[STATE] : {};\n            };\n            has = function(it) {\n                return hasOwn(it, STATE);\n            };\n        }\n        module.exports = {\n            set: set,\n            get: get,\n            has: has,\n            enforce: enforce,\n            getterFor: getterFor\n        };\n    /***/ },\n    /***/ 1291: /***/ (module, __unused_webpack_exports, __nested_webpack_require_22399__)=>{\n        var trunc = __nested_webpack_require_22399__(741);\n        // `ToIntegerOrInfinity` abstract operation\n        // https://tc39.es/ecma262/#sec-tointegerorinfinity\n        module.exports = function(argument) {\n            var number = +argument;\n            // eslint-disable-next-line no-self-compare -- NaN check\n            return number !== number || number === 0 ? 0 : trunc(number);\n        };\n    /***/ },\n    /***/ 1385: /***/ (module, __unused_webpack_exports, __nested_webpack_require_22887__)=>{\n        var iteratorClose = __nested_webpack_require_22887__(9539);\n        module.exports = function(iters, kind, value) {\n            for(var i = iters.length - 1; i >= 0; i--){\n                if (iters[i] === undefined) continue;\n                try {\n                    value = iteratorClose(iters[i].iterator, kind, value);\n                } catch (error) {\n                    kind = \"throw\";\n                    value = error;\n                }\n            }\n            if (kind === \"throw\") throw value;\n            return value;\n        };\n    /***/ },\n    /***/ 1548: /***/ (module, __unused_webpack_exports, __nested_webpack_require_23520__)=>{\n        var globalThis1 = __nested_webpack_require_23520__(4576);\n        var fails = __nested_webpack_require_23520__(9039);\n        var V8 = __nested_webpack_require_23520__(9519);\n        var ENVIRONMENT = __nested_webpack_require_23520__(4215);\n        var structuredClone1 = globalThis1.structuredClone;\n        module.exports = !!structuredClone1 && !fails(function() {\n            // prevent V8 ArrayBufferDetaching protector cell invalidation and performance degradation\n            // https://github.com/zloirock/core-js/issues/679\n            if (ENVIRONMENT === \"DENO\" && V8 > 92 || ENVIRONMENT === \"NODE\" && V8 > 94 || ENVIRONMENT === \"BROWSER\" && V8 > 97) return false;\n            var buffer = new ArrayBuffer(8);\n            var clone = structuredClone1(buffer, {\n                transfer: [\n                    buffer\n                ]\n            });\n            return buffer.byteLength !== 0 || clone.byteLength !== 8;\n        });\n    /***/ },\n    /***/ 1549: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_24529__)=>{\n        // TODO: Remove from `core-js@4`\n        __nested_webpack_require_24529__(6632);\n    /***/ },\n    /***/ 1625: /***/ (module, __unused_webpack_exports, __nested_webpack_require_24699__)=>{\n        var uncurryThis = __nested_webpack_require_24699__(9504);\n        module.exports = uncurryThis({}.isPrototypeOf);\n    /***/ },\n    /***/ 1689: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_24919__)=>{\n        var $ = __nested_webpack_require_24919__(6518);\n        var globalThis1 = __nested_webpack_require_24919__(4576);\n        var apply = __nested_webpack_require_24919__(8745);\n        var slice = __nested_webpack_require_24919__(7680);\n        var newPromiseCapabilityModule = __nested_webpack_require_24919__(6043);\n        var aCallable = __nested_webpack_require_24919__(9306);\n        var perform = __nested_webpack_require_24919__(1103);\n        var Promise1 = globalThis1.Promise;\n        var ACCEPT_ARGUMENTS = false;\n        // Avoiding the use of polyfills of the previous iteration of this proposal\n        // that does not accept arguments of the callback\n        var FORCED = !Promise1 || !Promise1[\"try\"] || perform(function() {\n            Promise1[\"try\"](function(argument) {\n                ACCEPT_ARGUMENTS = argument === 8;\n            }, 8);\n        }).error || !ACCEPT_ARGUMENTS;\n        // `Promise.try` method\n        // https://tc39.es/ecma262/#sec-promise.try\n        $({\n            target: \"Promise\",\n            stat: true,\n            forced: FORCED\n        }, {\n            \"try\": function(callbackfn /* , ...args */ ) {\n                var args = arguments.length > 1 ? slice(arguments, 1) : [];\n                var promiseCapability = newPromiseCapabilityModule.f(this);\n                var result = perform(function() {\n                    return apply(aCallable(callbackfn), undefined, args);\n                });\n                (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);\n                return promiseCapability.promise;\n            }\n        });\n    /***/ },\n    /***/ 1698: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_26568__)=>{\n        var $ = __nested_webpack_require_26568__(6518);\n        var union = __nested_webpack_require_26568__(4204);\n        var setMethodGetKeysBeforeCloning = __nested_webpack_require_26568__(9835);\n        var setMethodAcceptSetLike = __nested_webpack_require_26568__(4916);\n        var FORCED = !setMethodAcceptSetLike(\"union\") || !setMethodGetKeysBeforeCloning(\"union\");\n        // `Set.prototype.union` method\n        // https://tc39.es/ecma262/#sec-set.prototype.union\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            union: union\n        });\n    /***/ },\n    /***/ 1701: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_27267__)=>{\n        var $ = __nested_webpack_require_27267__(6518);\n        var call = __nested_webpack_require_27267__(9565);\n        var aCallable = __nested_webpack_require_27267__(9306);\n        var anObject = __nested_webpack_require_27267__(8551);\n        var getIteratorDirect = __nested_webpack_require_27267__(1767);\n        var createIteratorProxy = __nested_webpack_require_27267__(9462);\n        var callWithSafeIterationClosing = __nested_webpack_require_27267__(6319);\n        var iteratorClose = __nested_webpack_require_27267__(9539);\n        var iteratorHelperThrowsOnInvalidIterator = __nested_webpack_require_27267__(684);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_27267__(4549);\n        var IS_PURE = __nested_webpack_require_27267__(6395);\n        var MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator(\"map\", function() {});\n        var mapWithoutClosingOnEarlyError = !IS_PURE && !MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError(\"map\", TypeError);\n        var FORCED = IS_PURE || MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || mapWithoutClosingOnEarlyError;\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            var result = anObject(call(this.next, iterator));\n            var done = this.done = !!result.done;\n            if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [\n                result.value,\n                this.counter++\n            ], true);\n        });\n        // `Iterator.prototype.map` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.map\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            map: function map(mapper) {\n                anObject(this);\n                try {\n                    aCallable(mapper);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (mapWithoutClosingOnEarlyError) return call(mapWithoutClosingOnEarlyError, this, mapper);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    mapper: mapper\n                });\n            }\n        });\n    /***/ },\n    /***/ 1767: /***/ (module)=>{\n        // `GetIteratorDirect(obj)` abstract operation\n        // https://tc39.es/ecma262/#sec-getiteratordirect\n        module.exports = function(obj) {\n            return {\n                iterator: obj,\n                next: obj.next,\n                done: false\n            };\n        };\n    /***/ },\n    /***/ 1828: /***/ (module, __unused_webpack_exports, __nested_webpack_require_29874__)=>{\n        var uncurryThis = __nested_webpack_require_29874__(9504);\n        var hasOwn = __nested_webpack_require_29874__(9297);\n        var toIndexedObject = __nested_webpack_require_29874__(5397);\n        var indexOf = __nested_webpack_require_29874__(9617).indexOf;\n        var hiddenKeys = __nested_webpack_require_29874__(421);\n        var push = uncurryThis([].push);\n        module.exports = function(object, names) {\n            var O = toIndexedObject(object);\n            var i = 0;\n            var result = [];\n            var key;\n            for(key in O)!hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n            // Don't enum bug & hidden keys\n            while(names.length > i)if (hasOwn(O, key = names[i++])) {\n                ~indexOf(result, key) || push(result, key);\n            }\n            return result;\n        };\n    /***/ },\n    /***/ 2106: /***/ (module, __unused_webpack_exports, __nested_webpack_require_30760__)=>{\n        var makeBuiltIn = __nested_webpack_require_30760__(283);\n        var defineProperty = __nested_webpack_require_30760__(4913);\n        module.exports = function(target, name, descriptor) {\n            if (descriptor.get) makeBuiltIn(descriptor.get, name, {\n                getter: true\n            });\n            if (descriptor.set) makeBuiltIn(descriptor.set, name, {\n                setter: true\n            });\n            return defineProperty.f(target, name, descriptor);\n        };\n    /***/ },\n    /***/ 2140: /***/ (module, __unused_webpack_exports, __nested_webpack_require_31324__)=>{\n        var wellKnownSymbol = __nested_webpack_require_31324__(8227);\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var test = {};\n        test[TO_STRING_TAG] = \"z\";\n        module.exports = String(test) === \"[object z]\";\n    /***/ },\n    /***/ 2195: /***/ (module, __unused_webpack_exports, __nested_webpack_require_31649__)=>{\n        var uncurryThis = __nested_webpack_require_31649__(9504);\n        var toString = uncurryThis({}.toString);\n        var stringSlice = uncurryThis(\"\".slice);\n        module.exports = function(it) {\n            return stringSlice(toString(it), 8, -1);\n        };\n    /***/ },\n    /***/ 2211: /***/ (module, __unused_webpack_exports, __nested_webpack_require_31998__)=>{\n        var fails = __nested_webpack_require_31998__(9039);\n        module.exports = !fails(function() {\n            function F() {}\n            F.prototype.constructor = null;\n            // eslint-disable-next-line es/no-object-getprototypeof -- required for testing\n            return Object.getPrototypeOf(new F()) !== F.prototype;\n        });\n    /***/ },\n    /***/ 2303: /***/ (module, __unused_webpack_exports, __nested_webpack_require_32427__)=>{\n        var globalThis1 = __nested_webpack_require_32427__(4576);\n        var uncurryThis = __nested_webpack_require_32427__(9504);\n        var Uint8Array1 = globalThis1.Uint8Array;\n        var SyntaxError1 = globalThis1.SyntaxError;\n        var parseInt1 = globalThis1.parseInt;\n        var min = Math.min;\n        var NOT_HEX = /[^\\da-f]/i;\n        var exec = uncurryThis(NOT_HEX.exec);\n        var stringSlice = uncurryThis(\"\".slice);\n        module.exports = function(string, into) {\n            var stringLength = string.length;\n            if (stringLength % 2 !== 0) throw new SyntaxError1(\"String should be an even number of characters\");\n            var maxLength = into ? min(into.length, stringLength / 2) : stringLength / 2;\n            var bytes = into || new Uint8Array1(maxLength);\n            var read = 0;\n            var written = 0;\n            while(written < maxLength){\n                var hexits = stringSlice(string, read, read += 2);\n                if (exec(NOT_HEX, hexits)) throw new SyntaxError1(\"String should only contain hex characters\");\n                bytes[written++] = parseInt1(hexits, 16);\n            }\n            return {\n                bytes: bytes,\n                read: read\n            };\n        };\n    /***/ },\n    /***/ 2360: /***/ (module, __unused_webpack_exports, __nested_webpack_require_33742__)=>{\n        /* global ActiveXObject -- old IE, WSH */ var anObject = __nested_webpack_require_33742__(8551);\n        var definePropertiesModule = __nested_webpack_require_33742__(6801);\n        var enumBugKeys = __nested_webpack_require_33742__(8727);\n        var hiddenKeys = __nested_webpack_require_33742__(421);\n        var html = __nested_webpack_require_33742__(397);\n        var documentCreateElement = __nested_webpack_require_33742__(4055);\n        var sharedKey = __nested_webpack_require_33742__(6119);\n        var GT = \">\";\n        var LT = \"<\";\n        var PROTOTYPE = \"prototype\";\n        var SCRIPT = \"script\";\n        var IE_PROTO = sharedKey(\"IE_PROTO\");\n        var EmptyConstructor = function() {};\n        var scriptTag = function(content) {\n            return LT + SCRIPT + GT + content + LT + \"/\" + SCRIPT + GT;\n        };\n        // Create object with fake `null` prototype: use ActiveX Object with cleared prototype\n        var NullProtoObjectViaActiveX = function(activeXDocument) {\n            activeXDocument.write(scriptTag(\"\"));\n            activeXDocument.close();\n            var temp = activeXDocument.parentWindow.Object;\n            // eslint-disable-next-line no-useless-assignment -- avoid memory leak\n            activeXDocument = null;\n            return temp;\n        };\n        // Create object with fake `null` prototype: use iframe Object with cleared prototype\n        var NullProtoObjectViaIFrame = function() {\n            // Thrash, waste and sodomy: IE GC bug\n            var iframe = documentCreateElement(\"iframe\");\n            var JS = \"java\" + SCRIPT + \":\";\n            var iframeDocument;\n            iframe.style.display = \"none\";\n            html.appendChild(iframe);\n            // https://github.com/zloirock/core-js/issues/475\n            iframe.src = String(JS);\n            iframeDocument = iframe.contentWindow.document;\n            iframeDocument.open();\n            iframeDocument.write(scriptTag(\"document.F=Object\"));\n            iframeDocument.close();\n            return iframeDocument.F;\n        };\n        // Check for document.domain and active x support\n        // No need to use active x approach when document.domain is not set\n        // see https://github.com/es-shims/es5-shim/issues/150\n        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n        // avoid IE GC bug\n        var activeXDocument;\n        var NullProtoObject = function() {\n            try {\n                activeXDocument = new ActiveXObject(\"htmlfile\");\n            } catch (error) {}\n            NullProtoObject = typeof document != \"undefined\" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n             : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH\n            var length = enumBugKeys.length;\n            while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n            return NullProtoObject();\n        };\n        hiddenKeys[IE_PROTO] = true;\n        // `Object.create` method\n        // https://tc39.es/ecma262/#sec-object.create\n        // eslint-disable-next-line es/no-object-create -- safe\n        module.exports = Object.create || function create(O, Properties) {\n            var result;\n            if (O !== null) {\n                EmptyConstructor[PROTOTYPE] = anObject(O);\n                result = new EmptyConstructor();\n                EmptyConstructor[PROTOTYPE] = null;\n                // add \"__proto__\" for Object.getPrototypeOf polyfill\n                result[IE_PROTO] = O;\n            } else result = NullProtoObject();\n            return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n        };\n    /***/ },\n    /***/ 2475: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_37490__)=>{\n        var $ = __nested_webpack_require_37490__(6518);\n        var isSupersetOf = __nested_webpack_require_37490__(8527);\n        var setMethodAcceptSetLike = __nested_webpack_require_37490__(4916);\n        var INCORRECT = !setMethodAcceptSetLike(\"isSupersetOf\", function(result) {\n            return !result;\n        });\n        // `Set.prototype.isSupersetOf` method\n        // https://tc39.es/ecma262/#sec-set.prototype.issupersetof\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: INCORRECT\n        }, {\n            isSupersetOf: isSupersetOf\n        });\n    /***/ },\n    /***/ 2489: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_38181__)=>{\n        var $ = __nested_webpack_require_38181__(6518);\n        var call = __nested_webpack_require_38181__(9565);\n        var aCallable = __nested_webpack_require_38181__(9306);\n        var anObject = __nested_webpack_require_38181__(8551);\n        var getIteratorDirect = __nested_webpack_require_38181__(1767);\n        var createIteratorProxy = __nested_webpack_require_38181__(9462);\n        var callWithSafeIterationClosing = __nested_webpack_require_38181__(6319);\n        var IS_PURE = __nested_webpack_require_38181__(6395);\n        var iteratorClose = __nested_webpack_require_38181__(9539);\n        var iteratorHelperThrowsOnInvalidIterator = __nested_webpack_require_38181__(684);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_38181__(4549);\n        var FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator(\"filter\", function() {});\n        var filterWithoutClosingOnEarlyError = !IS_PURE && !FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError(\"filter\", TypeError);\n        var FORCED = IS_PURE || FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR || filterWithoutClosingOnEarlyError;\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            var predicate = this.predicate;\n            var next = this.next;\n            var result, done, value;\n            while(true){\n                result = anObject(call(next, iterator));\n                done = this.done = !!result.done;\n                if (done) return;\n                value = result.value;\n                if (callWithSafeIterationClosing(iterator, predicate, [\n                    value,\n                    this.counter++\n                ], true)) return value;\n            }\n        });\n        // `Iterator.prototype.filter` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.filter\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            filter: function filter(predicate) {\n                anObject(this);\n                try {\n                    aCallable(predicate);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (filterWithoutClosingOnEarlyError) return call(filterWithoutClosingOnEarlyError, this, predicate);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    predicate: predicate\n                });\n            }\n        });\n    /***/ },\n    /***/ 2529: /***/ (module)=>{\n        // `CreateIterResultObject` abstract operation\n        // https://tc39.es/ecma262/#sec-createiterresultobject\n        module.exports = function(value, done) {\n            return {\n                value: value,\n                done: done\n            };\n        };\n    /***/ },\n    /***/ 2603: /***/ (module, __unused_webpack_exports, __nested_webpack_require_41049__)=>{\n        var toString = __nested_webpack_require_41049__(655);\n        module.exports = function(argument, $default) {\n            return argument === undefined ? arguments.length < 2 ? \"\" : $default : toString(argument);\n        };\n    /***/ },\n    /***/ 2652: /***/ (module, __unused_webpack_exports, __nested_webpack_require_41362__)=>{\n        var bind = __nested_webpack_require_41362__(6080);\n        var call = __nested_webpack_require_41362__(9565);\n        var anObject = __nested_webpack_require_41362__(8551);\n        var tryToString = __nested_webpack_require_41362__(6823);\n        var isArrayIteratorMethod = __nested_webpack_require_41362__(4209);\n        var lengthOfArrayLike = __nested_webpack_require_41362__(6198);\n        var isPrototypeOf = __nested_webpack_require_41362__(1625);\n        var getIterator = __nested_webpack_require_41362__(81);\n        var getIteratorMethod = __nested_webpack_require_41362__(851);\n        var iteratorClose = __nested_webpack_require_41362__(9539);\n        var $TypeError = TypeError;\n        var Result = function(stopped, result) {\n            this.stopped = stopped;\n            this.result = result;\n        };\n        var ResultPrototype = Result.prototype;\n        module.exports = function(iterable, unboundFunction, options) {\n            var that = options && options.that;\n            var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n            var IS_RECORD = !!(options && options.IS_RECORD);\n            var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n            var INTERRUPTED = !!(options && options.INTERRUPTED);\n            var fn = bind(unboundFunction, that);\n            var iterator, iterFn, index, length, result, next, step;\n            var stop = function(condition) {\n                if (iterator) iteratorClose(iterator, \"normal\");\n                return new Result(true, condition);\n            };\n            var callFn = function(value) {\n                if (AS_ENTRIES) {\n                    anObject(value);\n                    return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n                }\n                return INTERRUPTED ? fn(value, stop) : fn(value);\n            };\n            if (IS_RECORD) {\n                iterator = iterable.iterator;\n            } else if (IS_ITERATOR) {\n                iterator = iterable;\n            } else {\n                iterFn = getIteratorMethod(iterable);\n                if (!iterFn) throw new $TypeError(tryToString(iterable) + \" is not iterable\");\n                // optimisation for array iterators\n                if (isArrayIteratorMethod(iterFn)) {\n                    for(index = 0, length = lengthOfArrayLike(iterable); length > index; index++){\n                        result = callFn(iterable[index]);\n                        if (result && isPrototypeOf(ResultPrototype, result)) return result;\n                    }\n                    return new Result(false);\n                }\n                iterator = getIterator(iterable, iterFn);\n            }\n            next = IS_RECORD ? iterable.next : iterator.next;\n            while(!(step = call(next, iterator)).done){\n                try {\n                    result = callFn(step.value);\n                } catch (error) {\n                    iteratorClose(iterator, \"throw\", error);\n                }\n                if (typeof result == \"object\" && result && isPrototypeOf(ResultPrototype, result)) return result;\n            }\n            return new Result(false);\n        };\n    /***/ },\n    /***/ 2777: /***/ (module, __unused_webpack_exports, __nested_webpack_require_44501__)=>{\n        var call = __nested_webpack_require_44501__(9565);\n        var isObject = __nested_webpack_require_44501__(34);\n        var isSymbol = __nested_webpack_require_44501__(757);\n        var getMethod = __nested_webpack_require_44501__(5966);\n        var ordinaryToPrimitive = __nested_webpack_require_44501__(4270);\n        var wellKnownSymbol = __nested_webpack_require_44501__(8227);\n        var $TypeError = TypeError;\n        var TO_PRIMITIVE = wellKnownSymbol(\"toPrimitive\");\n        // `ToPrimitive` abstract operation\n        // https://tc39.es/ecma262/#sec-toprimitive\n        module.exports = function(input, pref) {\n            if (!isObject(input) || isSymbol(input)) return input;\n            var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n            var result;\n            if (exoticToPrim) {\n                if (pref === undefined) pref = \"default\";\n                result = call(exoticToPrim, input, pref);\n                if (!isObject(result) || isSymbol(result)) return result;\n                throw new $TypeError(\"Can't convert object to primitive value\");\n            }\n            if (pref === undefined) pref = \"number\";\n            return ordinaryToPrimitive(input, pref);\n        };\n    /***/ },\n    /***/ 2787: /***/ (module, __unused_webpack_exports, __nested_webpack_require_45735__)=>{\n        var hasOwn = __nested_webpack_require_45735__(9297);\n        var isCallable = __nested_webpack_require_45735__(4901);\n        var toObject = __nested_webpack_require_45735__(8981);\n        var sharedKey = __nested_webpack_require_45735__(6119);\n        var CORRECT_PROTOTYPE_GETTER = __nested_webpack_require_45735__(2211);\n        var IE_PROTO = sharedKey(\"IE_PROTO\");\n        var $Object = Object;\n        var ObjectPrototype = $Object.prototype;\n        // `Object.getPrototypeOf` method\n        // https://tc39.es/ecma262/#sec-object.getprototypeof\n        // eslint-disable-next-line es/no-object-getprototypeof -- safe\n        module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {\n            var object = toObject(O);\n            if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];\n            var constructor = object.constructor;\n            if (isCallable(constructor) && object instanceof constructor) {\n                return constructor.prototype;\n            }\n            return object instanceof $Object ? ObjectPrototype : null;\n        };\n    /***/ },\n    /***/ 2796: /***/ (module, __unused_webpack_exports, __nested_webpack_require_46861__)=>{\n        var fails = __nested_webpack_require_46861__(9039);\n        var isCallable = __nested_webpack_require_46861__(4901);\n        var replacement = /#|\\.prototype\\./;\n        var isForced = function(feature, detection) {\n            var value = data[normalize(feature)];\n            return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;\n        };\n        var normalize = isForced.normalize = function(string) {\n            return String(string).replace(replacement, \".\").toLowerCase();\n        };\n        var data = isForced.data = {};\n        var NATIVE = isForced.NATIVE = \"N\";\n        var POLYFILL = isForced.POLYFILL = \"P\";\n        module.exports = isForced;\n    /***/ },\n    /***/ 2804: /***/ (module)=>{\n        var commonAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n        var base64Alphabet = commonAlphabet + \"+/\";\n        var base64UrlAlphabet = commonAlphabet + \"-_\";\n        var inverse = function(characters) {\n            // TODO: use `Object.create(null)` in `core-js@4`\n            var result = {};\n            var index = 0;\n            for(; index < 64; index++)result[characters.charAt(index)] = index;\n            return result;\n        };\n        module.exports = {\n            i2c: base64Alphabet,\n            c2i: inverse(base64Alphabet),\n            i2cUrl: base64UrlAlphabet,\n            c2iUrl: inverse(base64UrlAlphabet)\n        };\n    /***/ },\n    /***/ 2812: /***/ (module)=>{\n        var $TypeError = TypeError;\n        module.exports = function(passed, required) {\n            if (passed < required) throw new $TypeError(\"Not enough arguments\");\n            return passed;\n        };\n    /***/ },\n    /***/ 2839: /***/ (module, __unused_webpack_exports, __nested_webpack_require_48645__)=>{\n        var globalThis1 = __nested_webpack_require_48645__(4576);\n        var navigator1 = globalThis1.navigator;\n        var userAgent = navigator1 && navigator1.userAgent;\n        module.exports = userAgent ? String(userAgent) : \"\";\n    /***/ },\n    /***/ 2967: /***/ (module, __unused_webpack_exports, __nested_webpack_require_48961__)=>{\n        /* eslint-disable no-proto -- safe */ var uncurryThisAccessor = __nested_webpack_require_48961__(6706);\n        var isObject = __nested_webpack_require_48961__(34);\n        var requireObjectCoercible = __nested_webpack_require_48961__(7750);\n        var aPossiblePrototype = __nested_webpack_require_48961__(3506);\n        // `Object.setPrototypeOf` method\n        // https://tc39.es/ecma262/#sec-object.setprototypeof\n        // Works with __proto__ only. Old v8 can't work with null proto objects.\n        // eslint-disable-next-line es/no-object-setprototypeof -- safe\n        module.exports = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n            var CORRECT_SETTER = false;\n            var test = {};\n            var setter;\n            try {\n                setter = uncurryThisAccessor(Object.prototype, \"__proto__\", \"set\");\n                setter(test, []);\n                CORRECT_SETTER = test instanceof Array;\n            } catch (error) {}\n            return function setPrototypeOf(O, proto) {\n                requireObjectCoercible(O);\n                aPossiblePrototype(proto);\n                if (!isObject(O)) return O;\n                if (CORRECT_SETTER) setter(O, proto);\n                else O.__proto__ = proto;\n                return O;\n            };\n        }() : undefined);\n    /***/ },\n    /***/ 3068: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_50346__)=>{\n        // based on Shewchuk's algorithm for exactly floating point addition\n        // adapted from https://github.com/tc39/proposal-math-sum/blob/3513d58323a1ae25560e8700aa5294500c6c9287/polyfill/polyfill.mjs\n        var $ = __nested_webpack_require_50346__(6518);\n        var uncurryThis = __nested_webpack_require_50346__(9504);\n        var iterate = __nested_webpack_require_50346__(2652);\n        var $RangeError = RangeError;\n        var $TypeError = TypeError;\n        var $Infinity = Infinity;\n        var $NaN = NaN;\n        var abs = Math.abs;\n        var pow = Math.pow;\n        var push = uncurryThis([].push);\n        var POW_2_1023 = pow(2, 1023);\n        var MAX_SAFE_INTEGER = pow(2, 53) - 1; // 2 ** 53 - 1 === 9007199254740992\n        var MAX_DOUBLE = Number.MAX_VALUE; // 2 ** 1024 - 2 ** (1023 - 52) === 1.79769313486231570815e+308\n        var MAX_ULP = pow(2, 971); // 2 ** (1023 - 52) === 1.99584030953471981166e+292\n        var NOT_A_NUMBER = {};\n        var MINUS_INFINITY = {};\n        var PLUS_INFINITY = {};\n        var MINUS_ZERO = {};\n        var FINITE = {};\n        // prerequisite: abs(x) >= abs(y)\n        var twosum = function(x, y) {\n            var hi = x + y;\n            var lo = y - (hi - x);\n            return {\n                hi: hi,\n                lo: lo\n            };\n        };\n        // `Math.sumPrecise` method\n        // https://github.com/tc39/proposal-math-sum\n        $({\n            target: \"Math\",\n            stat: true\n        }, {\n            // eslint-disable-next-line max-statements -- ok\n            sumPrecise: function sumPrecise(items) {\n                var numbers = [];\n                var count = 0;\n                var state = MINUS_ZERO;\n                iterate(items, function(n) {\n                    if (++count >= MAX_SAFE_INTEGER) throw new $RangeError(\"Maximum allowed index exceeded\");\n                    if (typeof n != \"number\") throw new $TypeError(\"Value is not a number\");\n                    if (state !== NOT_A_NUMBER) {\n                        // eslint-disable-next-line no-self-compare -- NaN check\n                        if (n !== n) state = NOT_A_NUMBER;\n                        else if (n === $Infinity) state = state === MINUS_INFINITY ? NOT_A_NUMBER : PLUS_INFINITY;\n                        else if (n === -$Infinity) state = state === PLUS_INFINITY ? NOT_A_NUMBER : MINUS_INFINITY;\n                        else if ((n !== 0 || 1 / n === $Infinity) && (state === MINUS_ZERO || state === FINITE)) {\n                            state = FINITE;\n                            push(numbers, n);\n                        }\n                    }\n                });\n                switch(state){\n                    case NOT_A_NUMBER:\n                        return $NaN;\n                    case MINUS_INFINITY:\n                        return -$Infinity;\n                    case PLUS_INFINITY:\n                        return $Infinity;\n                    case MINUS_ZERO:\n                        return -0;\n                }\n                var partials = [];\n                var overflow = 0; // conceptually 2 ** 1024 times this value; the final partial is biased by this amount\n                var x, y, sum, hi, lo, tmp;\n                for(var i = 0; i < numbers.length; i++){\n                    x = numbers[i];\n                    var actuallyUsedPartials = 0;\n                    for(var j = 0; j < partials.length; j++){\n                        y = partials[j];\n                        if (abs(x) < abs(y)) {\n                            tmp = x;\n                            x = y;\n                            y = tmp;\n                        }\n                        sum = twosum(x, y);\n                        hi = sum.hi;\n                        lo = sum.lo;\n                        if (abs(hi) === $Infinity) {\n                            var sign = hi === $Infinity ? 1 : -1;\n                            overflow += sign;\n                            x = x - sign * POW_2_1023 - sign * POW_2_1023;\n                            if (abs(x) < abs(y)) {\n                                tmp = x;\n                                x = y;\n                                y = tmp;\n                            }\n                            sum = twosum(x, y);\n                            hi = sum.hi;\n                            lo = sum.lo;\n                        }\n                        if (lo !== 0) partials[actuallyUsedPartials++] = lo;\n                        x = hi;\n                    }\n                    partials.length = actuallyUsedPartials;\n                    if (x !== 0) push(partials, x);\n                }\n                // compute the exact sum of partials, stopping once we lose precision\n                var n = partials.length - 1;\n                hi = 0;\n                lo = 0;\n                if (overflow !== 0) {\n                    var next = n >= 0 ? partials[n] : 0;\n                    n--;\n                    if (abs(overflow) > 1 || overflow > 0 && next > 0 || overflow < 0 && next < 0) {\n                        return overflow > 0 ? $Infinity : -$Infinity;\n                    }\n                    // here we actually have to do the arithmetic\n                    // drop a factor of 2 so we can do it without overflow\n                    // assert(abs(overflow) === 1)\n                    sum = twosum(overflow * POW_2_1023, next / 2);\n                    hi = sum.hi;\n                    lo = sum.lo;\n                    lo *= 2;\n                    if (abs(2 * hi) === $Infinity) {\n                        // rounding to the maximum value\n                        if (hi > 0) {\n                            return hi === POW_2_1023 && lo === -(MAX_ULP / 2) && n >= 0 && partials[n] < 0 ? MAX_DOUBLE : $Infinity;\n                        }\n                        return hi === -POW_2_1023 && lo === MAX_ULP / 2 && n >= 0 && partials[n] > 0 ? -MAX_DOUBLE : -$Infinity;\n                    }\n                    if (lo !== 0) {\n                        partials[++n] = lo;\n                        lo = 0;\n                    }\n                    hi *= 2;\n                }\n                while(n >= 0){\n                    sum = twosum(hi, partials[n--]);\n                    hi = sum.hi;\n                    lo = sum.lo;\n                    if (lo !== 0) break;\n                }\n                if (n >= 0 && (lo < 0 && partials[n] < 0 || lo > 0 && partials[n] > 0)) {\n                    y = lo * 2;\n                    x = hi + y;\n                    if (y === x - hi) hi = x;\n                }\n                return hi;\n            }\n        });\n    /***/ },\n    /***/ 3167: /***/ (module, __unused_webpack_exports, __nested_webpack_require_56987__)=>{\n        var isCallable = __nested_webpack_require_56987__(4901);\n        var isObject = __nested_webpack_require_56987__(34);\n        var setPrototypeOf = __nested_webpack_require_56987__(2967);\n        // makes subclassing work correct for wrapped built-ins\n        module.exports = function($this, dummy, Wrapper) {\n            var NewTarget, NewTargetPrototype;\n            if (// it can work only with native `setPrototypeOf`\n            setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n            isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);\n            return $this;\n        };\n    /***/ },\n    /***/ 3238: /***/ (module, __unused_webpack_exports, __nested_webpack_require_57843__)=>{\n        var globalThis1 = __nested_webpack_require_57843__(4576);\n        var NATIVE_ARRAY_BUFFER = __nested_webpack_require_57843__(7811);\n        var arrayBufferByteLength = __nested_webpack_require_57843__(7394);\n        var DataView1 = globalThis1.DataView;\n        module.exports = function(O) {\n            if (!NATIVE_ARRAY_BUFFER || arrayBufferByteLength(O) !== 0) return false;\n            try {\n                // eslint-disable-next-line no-new -- thrower\n                new DataView1(O);\n                return false;\n            } catch (error) {\n                return true;\n            }\n        };\n    /***/ },\n    /***/ 3392: /***/ (module, __unused_webpack_exports, __nested_webpack_require_58513__)=>{\n        var uncurryThis = __nested_webpack_require_58513__(9504);\n        var id = 0;\n        var postfix = Math.random();\n        var toString = uncurryThis(1.1.toString);\n        module.exports = function(key) {\n            return \"Symbol(\" + (key === undefined ? \"\" : key) + \")_\" + toString(++id + postfix, 36);\n        };\n    /***/ },\n    /***/ 3440: /***/ (module, __unused_webpack_exports, __nested_webpack_require_58920__)=>{\n        var aSet = __nested_webpack_require_58920__(7080);\n        var SetHelpers = __nested_webpack_require_58920__(4402);\n        var clone = __nested_webpack_require_58920__(9286);\n        var size = __nested_webpack_require_58920__(5170);\n        var getSetRecord = __nested_webpack_require_58920__(3789);\n        var iterateSet = __nested_webpack_require_58920__(8469);\n        var iterateSimple = __nested_webpack_require_58920__(507);\n        var has = SetHelpers.has;\n        var remove = SetHelpers.remove;\n        // `Set.prototype.difference` method\n        // https://tc39.es/ecma262/#sec-set.prototype.difference\n        module.exports = function difference(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            var result = clone(O);\n            if (size(O) <= otherRec.size) iterateSet(O, function(e) {\n                if (otherRec.includes(e)) remove(result, e);\n            });\n            else iterateSimple(otherRec.getIterator(), function(e) {\n                if (has(result, e)) remove(result, e);\n            });\n            return result;\n        };\n    /***/ },\n    /***/ 3463: /***/ (module)=>{\n        var $TypeError = TypeError;\n        module.exports = function(argument) {\n            if (typeof argument == \"string\") return argument;\n            throw new $TypeError(\"Argument is not a string\");\n        };\n    /***/ },\n    /***/ 3506: /***/ (module, __unused_webpack_exports, __nested_webpack_require_60307__)=>{\n        var isPossiblePrototype = __nested_webpack_require_60307__(3925);\n        var $String = String;\n        var $TypeError = TypeError;\n        module.exports = function(argument) {\n            if (isPossiblePrototype(argument)) return argument;\n            throw new $TypeError(\"Can't set \" + $String(argument) + \" as a prototype\");\n        };\n    /***/ },\n    /***/ 3579: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_60754__)=>{\n        var $ = __nested_webpack_require_60754__(6518);\n        var call = __nested_webpack_require_60754__(9565);\n        var iterate = __nested_webpack_require_60754__(2652);\n        var aCallable = __nested_webpack_require_60754__(9306);\n        var anObject = __nested_webpack_require_60754__(8551);\n        var getIteratorDirect = __nested_webpack_require_60754__(1767);\n        var iteratorClose = __nested_webpack_require_60754__(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_60754__(4549);\n        var someWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError(\"some\", TypeError);\n        // `Iterator.prototype.some` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.some\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: someWithoutClosingOnEarlyError\n        }, {\n            some: function some(predicate) {\n                anObject(this);\n                try {\n                    aCallable(predicate);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (someWithoutClosingOnEarlyError) return call(someWithoutClosingOnEarlyError, this, predicate);\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                return iterate(record, function(value, stop) {\n                    if (predicate(value, counter++)) return stop();\n                }, {\n                    IS_RECORD: true,\n                    INTERRUPTED: true\n                }).stopped;\n            }\n        });\n    /***/ },\n    /***/ 3650: /***/ (module, __unused_webpack_exports, __nested_webpack_require_62386__)=>{\n        var aSet = __nested_webpack_require_62386__(7080);\n        var SetHelpers = __nested_webpack_require_62386__(4402);\n        var clone = __nested_webpack_require_62386__(9286);\n        var getSetRecord = __nested_webpack_require_62386__(3789);\n        var iterateSimple = __nested_webpack_require_62386__(507);\n        var add = SetHelpers.add;\n        var has = SetHelpers.has;\n        var remove = SetHelpers.remove;\n        // `Set.prototype.symmetricDifference` method\n        // https://tc39.es/ecma262/#sec-set.prototype.symmetricdifference\n        module.exports = function symmetricDifference(other) {\n            var O = aSet(this);\n            var keysIter = getSetRecord(other).getIterator();\n            var result = clone(O);\n            iterateSimple(keysIter, function(e) {\n                if (has(O, e)) remove(result, e);\n                else add(result, e);\n            });\n            return result;\n        };\n    /***/ },\n    /***/ 3706: /***/ (module, __unused_webpack_exports, __nested_webpack_require_63352__)=>{\n        var uncurryThis = __nested_webpack_require_63352__(9504);\n        var isCallable = __nested_webpack_require_63352__(4901);\n        var store = __nested_webpack_require_63352__(7629);\n        var functionToString = uncurryThis(Function.toString);\n        // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\n        if (!isCallable(store.inspectSource)) {\n            store.inspectSource = function(it) {\n                return functionToString(it);\n            };\n        }\n        module.exports = store.inspectSource;\n    /***/ },\n    /***/ 3717: /***/ (__unused_webpack_module, exports)=>{\n        // eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\n        exports.f = Object.getOwnPropertySymbols;\n    /***/ },\n    /***/ 3724: /***/ (module, __unused_webpack_exports, __nested_webpack_require_64164__)=>{\n        var fails = __nested_webpack_require_64164__(9039);\n        // Detect IE8's incomplete defineProperty implementation\n        module.exports = !fails(function() {\n            // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n            return Object.defineProperty({}, 1, {\n                get: function() {\n                    return 7;\n                }\n            })[1] !== 7;\n        });\n    /***/ },\n    /***/ 3789: /***/ (module, __unused_webpack_exports, __nested_webpack_require_64676__)=>{\n        var aCallable = __nested_webpack_require_64676__(9306);\n        var anObject = __nested_webpack_require_64676__(8551);\n        var call = __nested_webpack_require_64676__(9565);\n        var toIntegerOrInfinity = __nested_webpack_require_64676__(1291);\n        var getIteratorDirect = __nested_webpack_require_64676__(1767);\n        var INVALID_SIZE = \"Invalid size\";\n        var $RangeError = RangeError;\n        var $TypeError = TypeError;\n        var max = Math.max;\n        var SetRecord = function(set, intSize) {\n            this.set = set;\n            this.size = max(intSize, 0);\n            this.has = aCallable(set.has);\n            this.keys = aCallable(set.keys);\n        };\n        SetRecord.prototype = {\n            getIterator: function() {\n                return getIteratorDirect(anObject(call(this.keys, this.set)));\n            },\n            includes: function(it) {\n                return call(this.has, this.set, it);\n            }\n        };\n        // `GetSetRecord` abstract operation\n        // https://tc39.es/proposal-set-methods/#sec-getsetrecord\n        module.exports = function(obj) {\n            anObject(obj);\n            var numSize = +obj.size;\n            // NOTE: If size is undefined, then numSize will be NaN\n            // eslint-disable-next-line no-self-compare -- NaN check\n            if (numSize !== numSize) throw new $TypeError(INVALID_SIZE);\n            var intSize = toIntegerOrInfinity(numSize);\n            if (intSize < 0) throw new $RangeError(INVALID_SIZE);\n            return new SetRecord(obj, intSize);\n        };\n    /***/ },\n    /***/ 3838: /***/ (module, __unused_webpack_exports, __nested_webpack_require_66285__)=>{\n        var aSet = __nested_webpack_require_66285__(7080);\n        var size = __nested_webpack_require_66285__(5170);\n        var iterate = __nested_webpack_require_66285__(8469);\n        var getSetRecord = __nested_webpack_require_66285__(3789);\n        // `Set.prototype.isSubsetOf` method\n        // https://tc39.es/ecma262/#sec-set.prototype.issubsetof\n        module.exports = function isSubsetOf(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            if (size(O) > otherRec.size) return false;\n            return iterate(O, function(e) {\n                if (!otherRec.includes(e)) return false;\n            }, true) !== false;\n        };\n    /***/ },\n    /***/ 3853: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_67034__)=>{\n        var $ = __nested_webpack_require_67034__(6518);\n        var isDisjointFrom = __nested_webpack_require_67034__(4449);\n        var setMethodAcceptSetLike = __nested_webpack_require_67034__(4916);\n        var INCORRECT = !setMethodAcceptSetLike(\"isDisjointFrom\", function(result) {\n            return !result;\n        });\n        // `Set.prototype.isDisjointFrom` method\n        // https://tc39.es/ecma262/#sec-set.prototype.isdisjointfrom\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: INCORRECT\n        }, {\n            isDisjointFrom: isDisjointFrom\n        });\n    /***/ },\n    /***/ 3925: /***/ (module, __unused_webpack_exports, __nested_webpack_require_67720__)=>{\n        var isObject = __nested_webpack_require_67720__(34);\n        module.exports = function(argument) {\n            return isObject(argument) || argument === null;\n        };\n    /***/ },\n    /***/ 3972: /***/ (module, __unused_webpack_exports, __nested_webpack_require_67979__)=>{\n        var isObject = __nested_webpack_require_67979__(34);\n        var $String = String;\n        var $TypeError = TypeError;\n        module.exports = function(argument) {\n            if (argument === undefined || isObject(argument)) return argument;\n            throw new $TypeError($String(argument) + \" is not an object or undefined\");\n        };\n    /***/ },\n    /***/ 4055: /***/ (module, __unused_webpack_exports, __nested_webpack_require_68411__)=>{\n        var globalThis1 = __nested_webpack_require_68411__(4576);\n        var isObject = __nested_webpack_require_68411__(34);\n        var document1 = globalThis1.document;\n        // typeof document.createElement is 'object' in old IE\n        var EXISTS = isObject(document1) && isObject(document1.createElement);\n        module.exports = function(it) {\n            return EXISTS ? document1.createElement(it) : {};\n        };\n    /***/ },\n    /***/ 4114: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_68924__)=>{\n        var $ = __nested_webpack_require_68924__(6518);\n        var toObject = __nested_webpack_require_68924__(8981);\n        var lengthOfArrayLike = __nested_webpack_require_68924__(6198);\n        var setArrayLength = __nested_webpack_require_68924__(4527);\n        var doesNotExceedSafeInteger = __nested_webpack_require_68924__(6837);\n        var fails = __nested_webpack_require_68924__(9039);\n        var INCORRECT_TO_LENGTH = fails(function() {\n            return [].push.call({\n                length: 0x100000000\n            }, 1) !== 4294967297;\n        });\n        // V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError\n        // https://bugs.chromium.org/p/v8/issues/detail?id=12681\n        var properErrorOnNonWritableLength = function() {\n            try {\n                // eslint-disable-next-line es/no-object-defineproperty -- safe\n                Object.defineProperty([], \"length\", {\n                    writable: false\n                }).push();\n            } catch (error) {\n                return error instanceof TypeError;\n            }\n        };\n        var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();\n        // `Array.prototype.push` method\n        // https://tc39.es/ecma262/#sec-array.prototype.push\n        $({\n            target: \"Array\",\n            proto: true,\n            arity: 1,\n            forced: FORCED\n        }, {\n            // eslint-disable-next-line no-unused-vars -- required for `.length`\n            push: function push(item) {\n                var O = toObject(this);\n                var len = lengthOfArrayLike(O);\n                var argCount = arguments.length;\n                doesNotExceedSafeInteger(len + argCount);\n                for(var i = 0; i < argCount; i++){\n                    O[len] = arguments[i];\n                    len++;\n                }\n                setArrayLength(O, len);\n                return len;\n            }\n        });\n    /***/ },\n    /***/ 4117: /***/ (module)=>{\n        // we can't use just `it == null` since of `document.all` special case\n        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec\n        module.exports = function(it) {\n            return it === null || it === undefined;\n        };\n    /***/ },\n    /***/ 4149: /***/ (module)=>{\n        var $RangeError = RangeError;\n        module.exports = function(it) {\n            // eslint-disable-next-line no-self-compare -- NaN check\n            if (it === it) return it;\n            throw new $RangeError(\"NaN is not allowed\");\n        };\n    /***/ },\n    /***/ 4154: /***/ (module, __unused_webpack_exports, __nested_webpack_require_71477__)=>{\n        var classof = __nested_webpack_require_71477__(6955);\n        var $TypeError = TypeError;\n        // Perform ? RequireInternalSlot(argument, [[TypedArrayName]])\n        // If argument.[[TypedArrayName]] is not \"Uint8Array\", throw a TypeError exception\n        module.exports = function(argument) {\n            if (classof(argument) === \"Uint8Array\") return argument;\n            throw new $TypeError(\"Argument is not an Uint8Array\");\n        };\n    /***/ },\n    /***/ 4204: /***/ (module, __unused_webpack_exports, __nested_webpack_require_72011__)=>{\n        var aSet = __nested_webpack_require_72011__(7080);\n        var add = __nested_webpack_require_72011__(4402).add;\n        var clone = __nested_webpack_require_72011__(9286);\n        var getSetRecord = __nested_webpack_require_72011__(3789);\n        var iterateSimple = __nested_webpack_require_72011__(507);\n        // `Set.prototype.union` method\n        // https://tc39.es/ecma262/#sec-set.prototype.union\n        module.exports = function union(other) {\n            var O = aSet(this);\n            var keysIter = getSetRecord(other).getIterator();\n            var result = clone(O);\n            iterateSimple(keysIter, function(it) {\n                add(result, it);\n            });\n            return result;\n        };\n    /***/ },\n    /***/ 4209: /***/ (module, __unused_webpack_exports, __nested_webpack_require_72771__)=>{\n        var wellKnownSymbol = __nested_webpack_require_72771__(8227);\n        var Iterators = __nested_webpack_require_72771__(6269);\n        var ITERATOR = wellKnownSymbol(\"iterator\");\n        var ArrayPrototype = Array.prototype;\n        // check on default Array iterator\n        module.exports = function(it) {\n            return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n        };\n    /***/ },\n    /***/ 4215: /***/ (module, __unused_webpack_exports, __nested_webpack_require_73265__)=>{\n        /* global Bun, Deno -- detection */ var globalThis1 = __nested_webpack_require_73265__(4576);\n        var userAgent = __nested_webpack_require_73265__(2839);\n        var classof = __nested_webpack_require_73265__(2195);\n        var userAgentStartsWith = function(string) {\n            return userAgent.slice(0, string.length) === string;\n        };\n        module.exports = function() {\n            if (userAgentStartsWith(\"Bun/\")) return \"BUN\";\n            if (userAgentStartsWith(\"Cloudflare-Workers\")) return \"CLOUDFLARE\";\n            if (userAgentStartsWith(\"Deno/\")) return \"DENO\";\n            if (userAgentStartsWith(\"Node.js/\")) return \"NODE\";\n            if (globalThis1.Bun && typeof Bun.version == \"string\") return \"BUN\";\n            if (globalThis1.Deno && typeof Deno.version == \"object\") return \"DENO\";\n            if (classof(globalThis1.process) === \"process\") return \"NODE\";\n            if (globalThis1.window && globalThis1.document) return \"BROWSER\";\n            return \"REST\";\n        }();\n    /***/ },\n    /***/ 4226: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_74354__)=>{\n        var $ = __nested_webpack_require_74354__(6518);\n        var globalThis1 = __nested_webpack_require_74354__(4576);\n        var aString = __nested_webpack_require_74354__(3463);\n        var anUint8Array = __nested_webpack_require_74354__(4154);\n        var notDetached = __nested_webpack_require_74354__(5169);\n        var $fromHex = __nested_webpack_require_74354__(2303);\n        // `Uint8Array.prototype.setFromHex` method\n        // https://github.com/tc39/proposal-arraybuffer-base64\n        if (globalThis1.Uint8Array) $({\n            target: \"Uint8Array\",\n            proto: true\n        }, {\n            setFromHex: function setFromHex(string) {\n                anUint8Array(this);\n                aString(string);\n                notDetached(this.buffer);\n                var read = $fromHex(string, this).read;\n                return {\n                    read: read,\n                    written: read / 2\n                };\n            }\n        });\n    /***/ },\n    /***/ 4235: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_75354__)=>{\n        // TODO: Remove from `core-js@4`\n        __nested_webpack_require_75354__(3068);\n    /***/ },\n    /***/ 4270: /***/ (module, __unused_webpack_exports, __nested_webpack_require_75524__)=>{\n        var call = __nested_webpack_require_75524__(9565);\n        var isCallable = __nested_webpack_require_75524__(4901);\n        var isObject = __nested_webpack_require_75524__(34);\n        var $TypeError = TypeError;\n        // `OrdinaryToPrimitive` abstract operation\n        // https://tc39.es/ecma262/#sec-ordinarytoprimitive\n        module.exports = function(input, pref) {\n            var fn, val;\n            if (pref === \"string\" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n            if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n            if (pref !== \"string\" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n            throw new $TypeError(\"Can't convert object to primitive value\");\n        };\n    /***/ },\n    /***/ 4376: /***/ (module, __unused_webpack_exports, __nested_webpack_require_76406__)=>{\n        var classof = __nested_webpack_require_76406__(2195);\n        // `IsArray` abstract operation\n        // https://tc39.es/ecma262/#sec-isarray\n        // eslint-disable-next-line es/no-array-isarray -- safe\n        module.exports = Array.isArray || function isArray(argument) {\n            return classof(argument) === \"Array\";\n        };\n    /***/ },\n    /***/ 4402: /***/ (module, __unused_webpack_exports, __nested_webpack_require_76833__)=>{\n        var uncurryThis = __nested_webpack_require_76833__(9504);\n        // eslint-disable-next-line es/no-set -- safe\n        var SetPrototype = Set.prototype;\n        module.exports = {\n            // eslint-disable-next-line es/no-set -- safe\n            Set: Set,\n            add: uncurryThis(SetPrototype.add),\n            has: uncurryThis(SetPrototype.has),\n            remove: uncurryThis(SetPrototype[\"delete\"]),\n            proto: SetPrototype\n        };\n    /***/ },\n    /***/ 4449: /***/ (module, __unused_webpack_exports, __nested_webpack_require_77379__)=>{\n        var aSet = __nested_webpack_require_77379__(7080);\n        var has = __nested_webpack_require_77379__(4402).has;\n        var size = __nested_webpack_require_77379__(5170);\n        var getSetRecord = __nested_webpack_require_77379__(3789);\n        var iterateSet = __nested_webpack_require_77379__(8469);\n        var iterateSimple = __nested_webpack_require_77379__(507);\n        var iteratorClose = __nested_webpack_require_77379__(9539);\n        // `Set.prototype.isDisjointFrom` method\n        // https://tc39.es/ecma262/#sec-set.prototype.isdisjointfrom\n        module.exports = function isDisjointFrom(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            if (size(O) <= otherRec.size) return iterateSet(O, function(e) {\n                if (otherRec.includes(e)) return false;\n            }, true) !== false;\n            var iterator = otherRec.getIterator();\n            return iterateSimple(iterator, function(e) {\n                if (has(O, e)) return iteratorClose(iterator, \"normal\", false);\n            }) !== false;\n        };\n    /***/ },\n    /***/ 4483: /***/ (module, __unused_webpack_exports, __nested_webpack_require_78475__)=>{\n        var globalThis1 = __nested_webpack_require_78475__(4576);\n        var getBuiltInNodeModule = __nested_webpack_require_78475__(9429);\n        var PROPER_STRUCTURED_CLONE_TRANSFER = __nested_webpack_require_78475__(1548);\n        var structuredClone1 = globalThis1.structuredClone;\n        var $ArrayBuffer = globalThis1.ArrayBuffer;\n        var $MessageChannel = globalThis1.MessageChannel;\n        var detach = false;\n        var WorkerThreads, channel, buffer, $detach;\n        if (PROPER_STRUCTURED_CLONE_TRANSFER) {\n            detach = function(transferable) {\n                structuredClone1(transferable, {\n                    transfer: [\n                        transferable\n                    ]\n                });\n            };\n        } else if ($ArrayBuffer) try {\n            if (!$MessageChannel) {\n                WorkerThreads = getBuiltInNodeModule(\"worker_threads\");\n                if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;\n            }\n            if ($MessageChannel) {\n                channel = new $MessageChannel();\n                buffer = new $ArrayBuffer(2);\n                $detach = function(transferable) {\n                    channel.port1.postMessage(null, [\n                        transferable\n                    ]);\n                };\n                if (buffer.byteLength === 2) {\n                    $detach(buffer);\n                    if (buffer.byteLength === 0) detach = $detach;\n                }\n            }\n        } catch (error) {}\n        module.exports = detach;\n    /***/ },\n    /***/ 4495: /***/ (module, __unused_webpack_exports, __nested_webpack_require_80080__)=>{\n        /* eslint-disable es/no-symbol -- required for testing */ var V8_VERSION = __nested_webpack_require_80080__(9519);\n        var fails = __nested_webpack_require_80080__(9039);\n        var globalThis1 = __nested_webpack_require_80080__(4576);\n        var $String = globalThis1.String;\n        // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\n        module.exports = !!Object.getOwnPropertySymbols && !fails(function() {\n            var symbol = Symbol(\"symbol detection\");\n            // Chrome 38 Symbol has incorrect toString conversion\n            // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n            // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,\n            // of course, fail.\n            return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n            !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n        });\n    /***/ },\n    /***/ 4527: /***/ (module, __unused_webpack_exports, __nested_webpack_require_81201__)=>{\n        var DESCRIPTORS = __nested_webpack_require_81201__(3724);\n        var isArray = __nested_webpack_require_81201__(4376);\n        var $TypeError = TypeError;\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        // Safari < 13 does not throw an error in this case\n        var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function() {\n            // makes no sense without proper strict mode support\n            if (this !== undefined) return true;\n            try {\n                // eslint-disable-next-line es/no-object-defineproperty -- safe\n                Object.defineProperty([], \"length\", {\n                    writable: false\n                }).length = 1;\n            } catch (error) {\n                return error instanceof TypeError;\n            }\n        }();\n        module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {\n            if (isArray(O) && !getOwnPropertyDescriptor(O, \"length\").writable) {\n                throw new $TypeError(\"Cannot set read only .length\");\n            }\n            return O.length = length;\n        } : function(O, length) {\n            return O.length = length;\n        };\n    /***/ },\n    /***/ 4549: /***/ (module, __unused_webpack_exports, __nested_webpack_require_82534__)=>{\n        var globalThis1 = __nested_webpack_require_82534__(4576);\n        // https://github.com/tc39/ecma262/pull/3467\n        module.exports = function(METHOD_NAME, ExpectedError) {\n            var Iterator1 = globalThis1.Iterator;\n            var IteratorPrototype = Iterator1 && Iterator1.prototype;\n            var method = IteratorPrototype && IteratorPrototype[METHOD_NAME];\n            var CLOSED = false;\n            if (method) try {\n                method.call({\n                    next: function() {\n                        return {\n                            done: true\n                        };\n                    },\n                    \"return\": function() {\n                        CLOSED = true;\n                    }\n                }, -1);\n            } catch (error) {\n                // https://bugs.webkit.org/show_bug.cgi?id=291195\n                if (!(error instanceof ExpectedError)) CLOSED = false;\n            }\n            if (!CLOSED) return method;\n        };\n    /***/ },\n    /***/ 4576: /***/ function(module) {\n        var check = function(it) {\n            return it && it.Math === Math && it;\n        };\n        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n        module.exports = // eslint-disable-next-line es/no-global-this -- safe\n        check(typeof globalThis == \"object\" && globalThis) || check( false && 0) || // eslint-disable-next-line no-restricted-globals -- safe\n        check(typeof self == \"object\" && self) || check(typeof global == \"object\" && global) || check(typeof this == \"object\" && this) || // eslint-disable-next-line no-new-func -- fallback\n        function() {\n            return this;\n        }() || Function(\"return this\")();\n    /***/ },\n    /***/ 4603: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_84376__)=>{\n        var defineBuiltIn = __nested_webpack_require_84376__(6840);\n        var uncurryThis = __nested_webpack_require_84376__(9504);\n        var toString = __nested_webpack_require_84376__(655);\n        var validateArgumentsLength = __nested_webpack_require_84376__(2812);\n        var $URLSearchParams = URLSearchParams;\n        var URLSearchParamsPrototype = $URLSearchParams.prototype;\n        var append = uncurryThis(URLSearchParamsPrototype.append);\n        var $delete = uncurryThis(URLSearchParamsPrototype[\"delete\"]);\n        var forEach = uncurryThis(URLSearchParamsPrototype.forEach);\n        var push = uncurryThis([].push);\n        var params = new $URLSearchParams(\"a=1&a=2&b=3\");\n        params[\"delete\"](\"a\", 1);\n        // `undefined` case is a Chromium 117 bug\n        // https://bugs.chromium.org/p/v8/issues/detail?id=14222\n        params[\"delete\"](\"b\", undefined);\n        if (params + \"\" !== \"a=2\") {\n            defineBuiltIn(URLSearchParamsPrototype, \"delete\", function(name /* , value */ ) {\n                var length = arguments.length;\n                var $value = length < 2 ? undefined : arguments[1];\n                if (length && $value === undefined) return $delete(this, name);\n                var entries = [];\n                forEach(this, function(v, k) {\n                    push(entries, {\n                        key: k,\n                        value: v\n                    });\n                });\n                validateArgumentsLength(length, 1);\n                var key = toString(name);\n                var value = toString($value);\n                var index = 0;\n                var dindex = 0;\n                var found = false;\n                var entriesLength = entries.length;\n                var entry;\n                while(index < entriesLength){\n                    entry = entries[index++];\n                    if (found || entry.key === key) {\n                        found = true;\n                        $delete(this, entry.key);\n                    } else dindex++;\n                }\n                while(dindex < entriesLength){\n                    entry = entries[dindex++];\n                    if (!(entry.key === key && entry.value === value)) append(this, entry.key, entry.value);\n                }\n            }, {\n                enumerable: true,\n                unsafe: true\n            });\n        }\n    /***/ },\n    /***/ 4628: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_86806__)=>{\n        var $ = __nested_webpack_require_86806__(6518);\n        var newPromiseCapabilityModule = __nested_webpack_require_86806__(6043);\n        // `Promise.withResolvers` method\n        // https://tc39.es/ecma262/#sec-promise.withResolvers\n        $({\n            target: \"Promise\",\n            stat: true\n        }, {\n            withResolvers: function withResolvers() {\n                var promiseCapability = newPromiseCapabilityModule.f(this);\n                return {\n                    promise: promiseCapability.promise,\n                    resolve: promiseCapability.resolve,\n                    reject: promiseCapability.reject\n                };\n            }\n        });\n    /***/ },\n    /***/ 4644: /***/ (module, __unused_webpack_exports, __nested_webpack_require_87559__)=>{\n        var NATIVE_ARRAY_BUFFER = __nested_webpack_require_87559__(7811);\n        var DESCRIPTORS = __nested_webpack_require_87559__(3724);\n        var globalThis1 = __nested_webpack_require_87559__(4576);\n        var isCallable = __nested_webpack_require_87559__(4901);\n        var isObject = __nested_webpack_require_87559__(34);\n        var hasOwn = __nested_webpack_require_87559__(9297);\n        var classof = __nested_webpack_require_87559__(6955);\n        var tryToString = __nested_webpack_require_87559__(6823);\n        var createNonEnumerableProperty = __nested_webpack_require_87559__(6699);\n        var defineBuiltIn = __nested_webpack_require_87559__(6840);\n        var defineBuiltInAccessor = __nested_webpack_require_87559__(2106);\n        var isPrototypeOf = __nested_webpack_require_87559__(1625);\n        var getPrototypeOf = __nested_webpack_require_87559__(2787);\n        var setPrototypeOf = __nested_webpack_require_87559__(2967);\n        var wellKnownSymbol = __nested_webpack_require_87559__(8227);\n        var uid = __nested_webpack_require_87559__(3392);\n        var InternalStateModule = __nested_webpack_require_87559__(1181);\n        var enforceInternalState = InternalStateModule.enforce;\n        var getInternalState = InternalStateModule.get;\n        var Int8Array1 = globalThis1.Int8Array;\n        var Int8ArrayPrototype = Int8Array1 && Int8Array1.prototype;\n        var Uint8ClampedArray1 = globalThis1.Uint8ClampedArray;\n        var Uint8ClampedArrayPrototype = Uint8ClampedArray1 && Uint8ClampedArray1.prototype;\n        var TypedArray = Int8Array1 && getPrototypeOf(Int8Array1);\n        var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);\n        var ObjectPrototype = Object.prototype;\n        var TypeError1 = globalThis1.TypeError;\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var TYPED_ARRAY_TAG = uid(\"TYPED_ARRAY_TAG\");\n        var TYPED_ARRAY_CONSTRUCTOR = \"TypedArrayConstructor\";\n        // Fixing native typed arrays in Opera Presto crashes the browser, see #595\n        var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(globalThis1.opera) !== \"Opera\";\n        var TYPED_ARRAY_TAG_REQUIRED = false;\n        var NAME, Constructor, Prototype;\n        var TypedArrayConstructorsList = {\n            Int8Array: 1,\n            Uint8Array: 1,\n            Uint8ClampedArray: 1,\n            Int16Array: 2,\n            Uint16Array: 2,\n            Int32Array: 4,\n            Uint32Array: 4,\n            Float32Array: 4,\n            Float64Array: 8\n        };\n        var BigIntArrayConstructorsList = {\n            BigInt64Array: 8,\n            BigUint64Array: 8\n        };\n        var isView = function isView(it) {\n            if (!isObject(it)) return false;\n            var klass = classof(it);\n            return klass === \"DataView\" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);\n        };\n        var getTypedArrayConstructor = function(it) {\n            var proto = getPrototypeOf(it);\n            if (!isObject(proto)) return;\n            var state = getInternalState(proto);\n            return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);\n        };\n        var isTypedArray = function(it) {\n            if (!isObject(it)) return false;\n            var klass = classof(it);\n            return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);\n        };\n        var aTypedArray = function(it) {\n            if (isTypedArray(it)) return it;\n            throw new TypeError1(\"Target is not a typed array\");\n        };\n        var aTypedArrayConstructor = function(C) {\n            if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;\n            throw new TypeError1(tryToString(C) + \" is not a typed array constructor\");\n        };\n        var exportTypedArrayMethod = function(KEY, property, forced, options) {\n            if (!DESCRIPTORS) return;\n            if (forced) for(var ARRAY in TypedArrayConstructorsList){\n                var TypedArrayConstructor = globalThis1[ARRAY];\n                if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {\n                    delete TypedArrayConstructor.prototype[KEY];\n                } catch (error) {\n                    // old WebKit bug - some methods are non-configurable\n                    try {\n                        TypedArrayConstructor.prototype[KEY] = property;\n                    } catch (error2) {}\n                }\n            }\n            if (!TypedArrayPrototype[KEY] || forced) {\n                defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);\n            }\n        };\n        var exportTypedArrayStaticMethod = function(KEY, property, forced) {\n            var ARRAY, TypedArrayConstructor;\n            if (!DESCRIPTORS) return;\n            if (setPrototypeOf) {\n                if (forced) for(ARRAY in TypedArrayConstructorsList){\n                    TypedArrayConstructor = globalThis1[ARRAY];\n                    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {\n                        delete TypedArrayConstructor[KEY];\n                    } catch (error) {}\n                }\n                if (!TypedArray[KEY] || forced) {\n                    // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable\n                    try {\n                        return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);\n                    } catch (error) {}\n                } else return;\n            }\n            for(ARRAY in TypedArrayConstructorsList){\n                TypedArrayConstructor = globalThis1[ARRAY];\n                if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n                    defineBuiltIn(TypedArrayConstructor, KEY, property);\n                }\n            }\n        };\n        for(NAME in TypedArrayConstructorsList){\n            Constructor = globalThis1[NAME];\n            Prototype = Constructor && Constructor.prototype;\n            if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n            else NATIVE_ARRAY_BUFFER_VIEWS = false;\n        }\n        for(NAME in BigIntArrayConstructorsList){\n            Constructor = globalThis1[NAME];\n            Prototype = Constructor && Constructor.prototype;\n            if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n        }\n        // WebKit bug - typed arrays constructors prototype is Object.prototype\n        if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {\n            // eslint-disable-next-line no-shadow -- safe\n            TypedArray = function TypedArray() {\n                throw new TypeError1(\"Incorrect invocation\");\n            };\n            if (NATIVE_ARRAY_BUFFER_VIEWS) for(NAME in TypedArrayConstructorsList){\n                if (globalThis1[NAME]) setPrototypeOf(globalThis1[NAME], TypedArray);\n            }\n        }\n        if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {\n            TypedArrayPrototype = TypedArray.prototype;\n            if (NATIVE_ARRAY_BUFFER_VIEWS) for(NAME in TypedArrayConstructorsList){\n                if (globalThis1[NAME]) setPrototypeOf(globalThis1[NAME].prototype, TypedArrayPrototype);\n            }\n        }\n        // WebKit bug - one more object in Uint8ClampedArray prototype chain\n        if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {\n            setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);\n        }\n        if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {\n            TYPED_ARRAY_TAG_REQUIRED = true;\n            defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {\n                configurable: true,\n                get: function() {\n                    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;\n                }\n            });\n            for(NAME in TypedArrayConstructorsList)if (globalThis1[NAME]) {\n                createNonEnumerableProperty(globalThis1[NAME], TYPED_ARRAY_TAG, NAME);\n            }\n        }\n        module.exports = {\n            NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,\n            TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,\n            aTypedArray: aTypedArray,\n            aTypedArrayConstructor: aTypedArrayConstructor,\n            exportTypedArrayMethod: exportTypedArrayMethod,\n            exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,\n            getTypedArrayConstructor: getTypedArrayConstructor,\n            isView: isView,\n            isTypedArray: isTypedArray,\n            TypedArray: TypedArray,\n            TypedArrayPrototype: TypedArrayPrototype\n        };\n    /***/ },\n    /***/ 4659: /***/ (module, __unused_webpack_exports, __nested_webpack_require_96551__)=>{\n        var DESCRIPTORS = __nested_webpack_require_96551__(3724);\n        var definePropertyModule = __nested_webpack_require_96551__(4913);\n        var createPropertyDescriptor = __nested_webpack_require_96551__(6980);\n        module.exports = function(object, key, value) {\n            if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));\n            else object[key] = value;\n        };\n    /***/ },\n    /***/ 4901: /***/ (module)=>{\n        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n        var documentAll = typeof document == \"object\" && document.all;\n        // `IsCallable` abstract operation\n        // https://tc39.es/ecma262/#sec-iscallable\n        // eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing\n        module.exports = typeof documentAll == \"undefined\" && documentAll !== undefined ? function(argument) {\n            return typeof argument == \"function\" || argument === documentAll;\n        } : function(argument) {\n            return typeof argument == \"function\";\n        };\n    /***/ },\n    /***/ 4913: /***/ (__unused_webpack_module, exports, __nested_webpack_require_97680__)=>{\n        var DESCRIPTORS = __nested_webpack_require_97680__(3724);\n        var IE8_DOM_DEFINE = __nested_webpack_require_97680__(5917);\n        var V8_PROTOTYPE_DEFINE_BUG = __nested_webpack_require_97680__(8686);\n        var anObject = __nested_webpack_require_97680__(8551);\n        var toPropertyKey = __nested_webpack_require_97680__(6969);\n        var $TypeError = TypeError;\n        // eslint-disable-next-line es/no-object-defineproperty -- safe\n        var $defineProperty = Object.defineProperty;\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        var ENUMERABLE = \"enumerable\";\n        var CONFIGURABLE = \"configurable\";\n        var WRITABLE = \"writable\";\n        // `Object.defineProperty` method\n        // https://tc39.es/ecma262/#sec-object.defineproperty\n        exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n            anObject(O);\n            P = toPropertyKey(P);\n            anObject(Attributes);\n            if (typeof O === \"function\" && P === \"prototype\" && \"value\" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n                var current = $getOwnPropertyDescriptor(O, P);\n                if (current && current[WRITABLE]) {\n                    O[P] = Attributes.value;\n                    Attributes = {\n                        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n                        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n                        writable: false\n                    };\n                }\n            }\n            return $defineProperty(O, P, Attributes);\n        } : $defineProperty : function defineProperty(O, P, Attributes) {\n            anObject(O);\n            P = toPropertyKey(P);\n            anObject(Attributes);\n            if (IE8_DOM_DEFINE) try {\n                return $defineProperty(O, P, Attributes);\n            } catch (error) {}\n            if (\"get\" in Attributes || \"set\" in Attributes) throw new $TypeError(\"Accessors not supported\");\n            if (\"value\" in Attributes) O[P] = Attributes.value;\n            return O;\n        };\n    /***/ },\n    /***/ 4916: /***/ (module, __unused_webpack_exports, __nested_webpack_require_99997__)=>{\n        var getBuiltIn = __nested_webpack_require_99997__(7751);\n        var createSetLike = function(size) {\n            return {\n                size: size,\n                has: function() {\n                    return false;\n                },\n                keys: function() {\n                    return {\n                        next: function() {\n                            return {\n                                done: true\n                            };\n                        }\n                    };\n                }\n            };\n        };\n        var createSetLikeWithInfinitySize = function(size) {\n            return {\n                size: size,\n                has: function() {\n                    return true;\n                },\n                keys: function() {\n                    throw new Error(\"e\");\n                }\n            };\n        };\n        module.exports = function(name, callback) {\n            var Set1 = getBuiltIn(\"Set\");\n            try {\n                new Set1()[name](createSetLike(0));\n                try {\n                    // late spec change, early WebKit ~ Safari 17 implementation does not pass it\n                    // https://github.com/tc39/proposal-set-methods/pull/88\n                    // also covered engines with\n                    // https://bugs.webkit.org/show_bug.cgi?id=272679\n                    new Set1()[name](createSetLike(-1));\n                    return false;\n                } catch (error2) {\n                    if (!callback) return true;\n                    // early V8 implementation bug\n                    // https://issues.chromium.org/issues/351332634\n                    try {\n                        new Set1()[name](createSetLikeWithInfinitySize(-Infinity));\n                        return false;\n                    } catch (error) {\n                        var set = new Set1();\n                        set.add(1);\n                        set.add(2);\n                        return callback(set[name](createSetLikeWithInfinitySize(Infinity)));\n                    }\n                }\n            } catch (error) {\n                return false;\n            }\n        };\n    /***/ },\n    /***/ 4972: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_102263__)=>{\n        var $ = __nested_webpack_require_102263__(6518);\n        var call = __nested_webpack_require_102263__(9565);\n        var anObject = __nested_webpack_require_102263__(8551);\n        var getIteratorDirect = __nested_webpack_require_102263__(1767);\n        var notANaN = __nested_webpack_require_102263__(4149);\n        var toPositiveInteger = __nested_webpack_require_102263__(9590);\n        var createIteratorProxy = __nested_webpack_require_102263__(9462);\n        var iteratorClose = __nested_webpack_require_102263__(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_102263__(4549);\n        var IS_PURE = __nested_webpack_require_102263__(6395);\n        var takeWithoutClosingOnEarlyError = !IS_PURE && iteratorHelperWithoutClosingOnEarlyError(\"take\", RangeError);\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            if (!this.remaining--) {\n                this.done = true;\n                return iteratorClose(iterator, \"normal\", undefined);\n            }\n            var result = anObject(call(this.next, iterator));\n            var done = this.done = !!result.done;\n            if (!done) return result.value;\n        });\n        // `Iterator.prototype.take` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.take\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: IS_PURE || takeWithoutClosingOnEarlyError\n        }, {\n            take: function take(limit) {\n                anObject(this);\n                var remaining;\n                try {\n                    remaining = toPositiveInteger(notANaN(+limit));\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (takeWithoutClosingOnEarlyError) return call(takeWithoutClosingOnEarlyError, this, remaining);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    remaining: remaining\n                });\n            }\n        });\n    /***/ },\n    /***/ 4979: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_104319__)=>{\n        var $ = __nested_webpack_require_104319__(6518);\n        var globalThis1 = __nested_webpack_require_104319__(4576);\n        var getBuiltIn = __nested_webpack_require_104319__(7751);\n        var createPropertyDescriptor = __nested_webpack_require_104319__(6980);\n        var defineProperty = __nested_webpack_require_104319__(4913).f;\n        var hasOwn = __nested_webpack_require_104319__(9297);\n        var anInstance = __nested_webpack_require_104319__(679);\n        var inheritIfRequired = __nested_webpack_require_104319__(3167);\n        var normalizeStringArgument = __nested_webpack_require_104319__(2603);\n        var DOMExceptionConstants = __nested_webpack_require_104319__(5002);\n        var clearErrorStack = __nested_webpack_require_104319__(8574);\n        var DESCRIPTORS = __nested_webpack_require_104319__(3724);\n        var IS_PURE = __nested_webpack_require_104319__(6395);\n        var DOM_EXCEPTION = \"DOMException\";\n        var Error1 = getBuiltIn(\"Error\");\n        var NativeDOMException = getBuiltIn(DOM_EXCEPTION);\n        var $DOMException = function DOMException() {\n            anInstance(this, DOMExceptionPrototype);\n            var argumentsLength = arguments.length;\n            var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);\n            var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], \"Error\");\n            var that = new NativeDOMException(message, name);\n            var error = new Error1(message);\n            error.name = DOM_EXCEPTION;\n            defineProperty(that, \"stack\", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));\n            inheritIfRequired(that, this, $DOMException);\n            return that;\n        };\n        var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;\n        var ERROR_HAS_STACK = \"stack\" in new Error1(DOM_EXCEPTION);\n        var DOM_EXCEPTION_HAS_STACK = \"stack\" in new NativeDOMException(1, 2);\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(globalThis1, DOM_EXCEPTION);\n        // Bun ~ 0.1.1 DOMException have incorrect descriptor and we can't redefine it\n        // https://github.com/Jarred-Sumner/bun/issues/399\n        var BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);\n        var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;\n        // `DOMException` constructor patch for `.stack` where it's required\n        // https://webidl.spec.whatwg.org/#es-DOMException-specialness\n        $({\n            global: true,\n            constructor: true,\n            forced: IS_PURE || FORCED_CONSTRUCTOR\n        }, {\n            DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException\n        });\n        var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);\n        var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;\n        if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {\n            if (!IS_PURE) {\n                defineProperty(PolyfilledDOMExceptionPrototype, \"constructor\", createPropertyDescriptor(1, PolyfilledDOMException));\n            }\n            for(var key in DOMExceptionConstants)if (hasOwn(DOMExceptionConstants, key)) {\n                var constant = DOMExceptionConstants[key];\n                var constantName = constant.s;\n                if (!hasOwn(PolyfilledDOMException, constantName)) {\n                    defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));\n                }\n            }\n        }\n    /***/ },\n    /***/ 5002: /***/ (module)=>{\n        module.exports = {\n            IndexSizeError: {\n                s: \"INDEX_SIZE_ERR\",\n                c: 1,\n                m: 1\n            },\n            DOMStringSizeError: {\n                s: \"DOMSTRING_SIZE_ERR\",\n                c: 2,\n                m: 0\n            },\n            HierarchyRequestError: {\n                s: \"HIERARCHY_REQUEST_ERR\",\n                c: 3,\n                m: 1\n            },\n            WrongDocumentError: {\n                s: \"WRONG_DOCUMENT_ERR\",\n                c: 4,\n                m: 1\n            },\n            InvalidCharacterError: {\n                s: \"INVALID_CHARACTER_ERR\",\n                c: 5,\n                m: 1\n            },\n            NoDataAllowedError: {\n                s: \"NO_DATA_ALLOWED_ERR\",\n                c: 6,\n                m: 0\n            },\n            NoModificationAllowedError: {\n                s: \"NO_MODIFICATION_ALLOWED_ERR\",\n                c: 7,\n                m: 1\n            },\n            NotFoundError: {\n                s: \"NOT_FOUND_ERR\",\n                c: 8,\n                m: 1\n            },\n            NotSupportedError: {\n                s: \"NOT_SUPPORTED_ERR\",\n                c: 9,\n                m: 1\n            },\n            InUseAttributeError: {\n                s: \"INUSE_ATTRIBUTE_ERR\",\n                c: 10,\n                m: 1\n            },\n            InvalidStateError: {\n                s: \"INVALID_STATE_ERR\",\n                c: 11,\n                m: 1\n            },\n            SyntaxError: {\n                s: \"SYNTAX_ERR\",\n                c: 12,\n                m: 1\n            },\n            InvalidModificationError: {\n                s: \"INVALID_MODIFICATION_ERR\",\n                c: 13,\n                m: 1\n            },\n            NamespaceError: {\n                s: \"NAMESPACE_ERR\",\n                c: 14,\n                m: 1\n            },\n            InvalidAccessError: {\n                s: \"INVALID_ACCESS_ERR\",\n                c: 15,\n                m: 1\n            },\n            ValidationError: {\n                s: \"VALIDATION_ERR\",\n                c: 16,\n                m: 0\n            },\n            TypeMismatchError: {\n                s: \"TYPE_MISMATCH_ERR\",\n                c: 17,\n                m: 1\n            },\n            SecurityError: {\n                s: \"SECURITY_ERR\",\n                c: 18,\n                m: 1\n            },\n            NetworkError: {\n                s: \"NETWORK_ERR\",\n                c: 19,\n                m: 1\n            },\n            AbortError: {\n                s: \"ABORT_ERR\",\n                c: 20,\n                m: 1\n            },\n            URLMismatchError: {\n                s: \"URL_MISMATCH_ERR\",\n                c: 21,\n                m: 1\n            },\n            QuotaExceededError: {\n                s: \"QUOTA_EXCEEDED_ERR\",\n                c: 22,\n                m: 1\n            },\n            TimeoutError: {\n                s: \"TIMEOUT_ERR\",\n                c: 23,\n                m: 1\n            },\n            InvalidNodeTypeError: {\n                s: \"INVALID_NODE_TYPE_ERR\",\n                c: 24,\n                m: 1\n            },\n            DataCloneError: {\n                s: \"DATA_CLONE_ERR\",\n                c: 25,\n                m: 1\n            }\n        };\n    /***/ },\n    /***/ 5024: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_111344__)=>{\n        var $ = __nested_webpack_require_111344__(6518);\n        var symmetricDifference = __nested_webpack_require_111344__(3650);\n        var setMethodGetKeysBeforeCloning = __nested_webpack_require_111344__(9835);\n        var setMethodAcceptSetLike = __nested_webpack_require_111344__(4916);\n        var FORCED = !setMethodAcceptSetLike(\"symmetricDifference\") || !setMethodGetKeysBeforeCloning(\"symmetricDifference\");\n        // `Set.prototype.symmetricDifference` method\n        // https://tc39.es/ecma262/#sec-set.prototype.symmetricdifference\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            symmetricDifference: symmetricDifference\n        });\n    /***/ },\n    /***/ 5031: /***/ (module, __unused_webpack_exports, __nested_webpack_require_112124__)=>{\n        var getBuiltIn = __nested_webpack_require_112124__(7751);\n        var uncurryThis = __nested_webpack_require_112124__(9504);\n        var getOwnPropertyNamesModule = __nested_webpack_require_112124__(8480);\n        var getOwnPropertySymbolsModule = __nested_webpack_require_112124__(3717);\n        var anObject = __nested_webpack_require_112124__(8551);\n        var concat = uncurryThis([].concat);\n        // all object keys, includes non-enumerable and symbols\n        module.exports = getBuiltIn(\"Reflect\", \"ownKeys\") || function ownKeys(it) {\n            var keys = getOwnPropertyNamesModule.f(anObject(it));\n            var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n            return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n        };\n    /***/ },\n    /***/ 5169: /***/ (module, __unused_webpack_exports, __nested_webpack_require_112941__)=>{\n        var isDetached = __nested_webpack_require_112941__(3238);\n        var $TypeError = TypeError;\n        module.exports = function(it) {\n            if (isDetached(it)) throw new $TypeError(\"ArrayBuffer is detached\");\n            return it;\n        };\n    /***/ },\n    /***/ 5170: /***/ (module, __unused_webpack_exports, __nested_webpack_require_113278__)=>{\n        var uncurryThisAccessor = __nested_webpack_require_113278__(6706);\n        var SetHelpers = __nested_webpack_require_113278__(4402);\n        module.exports = uncurryThisAccessor(SetHelpers.proto, \"size\", \"get\") || function(set) {\n            return set.size;\n        };\n    /***/ },\n    /***/ 5213: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_113639__)=>{\n        var $ = __nested_webpack_require_113639__(6518);\n        var globalThis1 = __nested_webpack_require_113639__(4576);\n        var arrayFromConstructorAndList = __nested_webpack_require_113639__(5370);\n        var $fromBase64 = __nested_webpack_require_113639__(9143);\n        var Uint8Array1 = globalThis1.Uint8Array;\n        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array1 || !Uint8Array1.fromBase64 || !function() {\n            // Webkit not throw an error on odd length string\n            try {\n                Uint8Array1.fromBase64(\"a\");\n                return;\n            } catch (error) {}\n            try {\n                Uint8Array1.fromBase64(\"\", null);\n            } catch (error) {\n                return true;\n            }\n        }();\n        // `Uint8Array.fromBase64` method\n        // https://github.com/tc39/proposal-arraybuffer-base64\n        if (Uint8Array1) $({\n            target: \"Uint8Array\",\n            stat: true,\n            forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS\n        }, {\n            fromBase64: function fromBase64(string /* , options */ ) {\n                var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : undefined, null, 0x1FFFFFFFFFFFFF);\n                return arrayFromConstructorAndList(Uint8Array1, result.bytes);\n            }\n        });\n    /***/ },\n    /***/ 5370: /***/ (module, __unused_webpack_exports, __nested_webpack_require_115002__)=>{\n        var lengthOfArrayLike = __nested_webpack_require_115002__(6198);\n        module.exports = function(Constructor, list, $length) {\n            var index = 0;\n            var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);\n            var result = new Constructor(length);\n            while(length > index)result[index] = list[index++];\n            return result;\n        };\n    /***/ },\n    /***/ 5397: /***/ (module, __unused_webpack_exports, __nested_webpack_require_115481__)=>{\n        // toObject with fallback for non-array-like ES3 strings\n        var IndexedObject = __nested_webpack_require_115481__(7055);\n        var requireObjectCoercible = __nested_webpack_require_115481__(7750);\n        module.exports = function(it) {\n            return IndexedObject(requireObjectCoercible(it));\n        };\n    /***/ },\n    /***/ 5610: /***/ (module, __unused_webpack_exports, __nested_webpack_require_115872__)=>{\n        var toIntegerOrInfinity = __nested_webpack_require_115872__(1291);\n        var max = Math.max;\n        var min = Math.min;\n        // Helper for a popular repeating case of the spec:\n        // Let integer be ? ToInteger(index).\n        // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n        module.exports = function(index, length) {\n            var integer = toIntegerOrInfinity(index);\n            return integer < 0 ? max(integer + length, 0) : min(integer, length);\n        };\n    /***/ },\n    /***/ 5623: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_116514__)=>{\n        // TODO: Remove from `core-js@4`\n        __nested_webpack_require_116514__(456);\n    /***/ },\n    /***/ 5636: /***/ (module, __unused_webpack_exports, __nested_webpack_require_116683__)=>{\n        var globalThis1 = __nested_webpack_require_116683__(4576);\n        var uncurryThis = __nested_webpack_require_116683__(9504);\n        var uncurryThisAccessor = __nested_webpack_require_116683__(6706);\n        var toIndex = __nested_webpack_require_116683__(7696);\n        var notDetached = __nested_webpack_require_116683__(5169);\n        var arrayBufferByteLength = __nested_webpack_require_116683__(7394);\n        var detachTransferable = __nested_webpack_require_116683__(4483);\n        var PROPER_STRUCTURED_CLONE_TRANSFER = __nested_webpack_require_116683__(1548);\n        var structuredClone1 = globalThis1.structuredClone;\n        var ArrayBuffer1 = globalThis1.ArrayBuffer;\n        var DataView1 = globalThis1.DataView;\n        var min = Math.min;\n        var ArrayBufferPrototype = ArrayBuffer1.prototype;\n        var DataViewPrototype = DataView1.prototype;\n        var slice = uncurryThis(ArrayBufferPrototype.slice);\n        var isResizable = uncurryThisAccessor(ArrayBufferPrototype, \"resizable\", \"get\");\n        var maxByteLength = uncurryThisAccessor(ArrayBufferPrototype, \"maxByteLength\", \"get\");\n        var getInt8 = uncurryThis(DataViewPrototype.getInt8);\n        var setInt8 = uncurryThis(DataViewPrototype.setInt8);\n        module.exports = (PROPER_STRUCTURED_CLONE_TRANSFER || detachTransferable) && function(arrayBuffer, newLength, preserveResizability) {\n            var byteLength = arrayBufferByteLength(arrayBuffer);\n            var newByteLength = newLength === undefined ? byteLength : toIndex(newLength);\n            var fixedLength = !isResizable || !isResizable(arrayBuffer);\n            var newBuffer;\n            notDetached(arrayBuffer);\n            if (PROPER_STRUCTURED_CLONE_TRANSFER) {\n                arrayBuffer = structuredClone1(arrayBuffer, {\n                    transfer: [\n                        arrayBuffer\n                    ]\n                });\n                if (byteLength === newByteLength && (preserveResizability || fixedLength)) return arrayBuffer;\n            }\n            if (byteLength >= newByteLength && (!preserveResizability || fixedLength)) {\n                newBuffer = slice(arrayBuffer, 0, newByteLength);\n            } else {\n                var options = preserveResizability && !fixedLength && maxByteLength ? {\n                    maxByteLength: maxByteLength(arrayBuffer)\n                } : undefined;\n                newBuffer = new ArrayBuffer1(newByteLength, options);\n                var a = new DataView1(arrayBuffer);\n                var b = new DataView1(newBuffer);\n                var copyLength = min(newByteLength, byteLength);\n                for(var i = 0; i < copyLength; i++)setInt8(b, i, getInt8(a, i));\n            }\n            if (!PROPER_STRUCTURED_CLONE_TRANSFER) detachTransferable(arrayBuffer);\n            return newBuffer;\n        };\n    /***/ },\n    /***/ 5745: /***/ (module, __unused_webpack_exports, __nested_webpack_require_119509__)=>{\n        var store = __nested_webpack_require_119509__(7629);\n        module.exports = function(key, value) {\n            return store[key] || (store[key] = value || {});\n        };\n    /***/ },\n    /***/ 5781: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_119787__)=>{\n        var $ = __nested_webpack_require_119787__(6518);\n        var getBuiltIn = __nested_webpack_require_119787__(7751);\n        var validateArgumentsLength = __nested_webpack_require_119787__(2812);\n        var toString = __nested_webpack_require_119787__(655);\n        var USE_NATIVE_URL = __nested_webpack_require_119787__(7416);\n        var URL1 = getBuiltIn(\"URL\");\n        // `URL.parse` method\n        // https://url.spec.whatwg.org/#dom-url-canparse\n        $({\n            target: \"URL\",\n            stat: true,\n            forced: !USE_NATIVE_URL\n        }, {\n            parse: function parse(url) {\n                var length = validateArgumentsLength(arguments.length, 1);\n                var urlString = toString(url);\n                var base = length < 2 || arguments[1] === undefined ? undefined : toString(arguments[1]);\n                try {\n                    return new URL1(urlString, base);\n                } catch (error) {\n                    return null;\n                }\n            }\n        });\n    /***/ },\n    /***/ 5854: /***/ (module, __unused_webpack_exports, __nested_webpack_require_120839__)=>{\n        var toPrimitive = __nested_webpack_require_120839__(2777);\n        var $TypeError = TypeError;\n        // `ToBigInt` abstract operation\n        // https://tc39.es/ecma262/#sec-tobigint\n        module.exports = function(argument) {\n            var prim = toPrimitive(argument, \"number\");\n            if (typeof prim == \"number\") throw new $TypeError(\"Can't convert number to bigint\");\n            // eslint-disable-next-line es/no-bigint -- safe\n            return BigInt(prim);\n        };\n    /***/ },\n    /***/ 5876: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_121433__)=>{\n        var $ = __nested_webpack_require_121433__(6518);\n        var isSubsetOf = __nested_webpack_require_121433__(3838);\n        var setMethodAcceptSetLike = __nested_webpack_require_121433__(4916);\n        var INCORRECT = !setMethodAcceptSetLike(\"isSubsetOf\", function(result) {\n            return result;\n        });\n        // `Set.prototype.isSubsetOf` method\n        // https://tc39.es/ecma262/#sec-set.prototype.issubsetof\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: INCORRECT\n        }, {\n            isSubsetOf: isSubsetOf\n        });\n    /***/ },\n    /***/ 5917: /***/ (module, __unused_webpack_exports, __nested_webpack_require_122094__)=>{\n        var DESCRIPTORS = __nested_webpack_require_122094__(3724);\n        var fails = __nested_webpack_require_122094__(9039);\n        var createElement = __nested_webpack_require_122094__(4055);\n        // Thanks to IE8 for its funny defineProperty\n        module.exports = !DESCRIPTORS && !fails(function() {\n            // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n            return Object.defineProperty(createElement(\"div\"), \"a\", {\n                get: function() {\n                    return 7;\n                }\n            }).a !== 7;\n        });\n    /***/ },\n    /***/ 5966: /***/ (module, __unused_webpack_exports, __nested_webpack_require_122738__)=>{\n        var aCallable = __nested_webpack_require_122738__(9306);\n        var isNullOrUndefined = __nested_webpack_require_122738__(4117);\n        // `GetMethod` abstract operation\n        // https://tc39.es/ecma262/#sec-getmethod\n        module.exports = function(V, P) {\n            var func = V[P];\n            return isNullOrUndefined(func) ? undefined : aCallable(func);\n        };\n    /***/ },\n    /***/ 6043: /***/ (module, __unused_webpack_exports, __nested_webpack_require_123190__)=>{\n        var aCallable = __nested_webpack_require_123190__(9306);\n        var $TypeError = TypeError;\n        var PromiseCapability = function(C) {\n            var resolve, reject;\n            this.promise = new C(function($$resolve, $$reject) {\n                if (resolve !== undefined || reject !== undefined) throw new $TypeError(\"Bad Promise constructor\");\n                resolve = $$resolve;\n                reject = $$reject;\n            });\n            this.resolve = aCallable(resolve);\n            this.reject = aCallable(reject);\n        };\n        // `NewPromiseCapability` abstract operation\n        // https://tc39.es/ecma262/#sec-newpromisecapability\n        module.exports.f = function(C) {\n            return new PromiseCapability(C);\n        };\n    /***/ },\n    /***/ 6080: /***/ (module, __unused_webpack_exports, __nested_webpack_require_124033__)=>{\n        var uncurryThis = __nested_webpack_require_124033__(7476);\n        var aCallable = __nested_webpack_require_124033__(9306);\n        var NATIVE_BIND = __nested_webpack_require_124033__(616);\n        var bind = uncurryThis(uncurryThis.bind);\n        // optional / simple context binding\n        module.exports = function(fn, that) {\n            aCallable(fn);\n            return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function() {\n                return fn.apply(that, arguments);\n            };\n        };\n    /***/ },\n    /***/ 6119: /***/ (module, __unused_webpack_exports, __nested_webpack_require_124616__)=>{\n        var shared = __nested_webpack_require_124616__(5745);\n        var uid = __nested_webpack_require_124616__(3392);\n        var keys = shared(\"keys\");\n        module.exports = function(key) {\n            return keys[key] || (keys[key] = uid(key));\n        };\n    /***/ },\n    /***/ 6193: /***/ (module, __unused_webpack_exports, __nested_webpack_require_124946__)=>{\n        var ENVIRONMENT = __nested_webpack_require_124946__(4215);\n        module.exports = ENVIRONMENT === \"NODE\";\n    /***/ },\n    /***/ 6198: /***/ (module, __unused_webpack_exports, __nested_webpack_require_125142__)=>{\n        var toLength = __nested_webpack_require_125142__(8014);\n        // `LengthOfArrayLike` abstract operation\n        // https://tc39.es/ecma262/#sec-lengthofarraylike\n        module.exports = function(obj) {\n            return toLength(obj.length);\n        };\n    /***/ },\n    /***/ 6269: /***/ (module)=>{\n        module.exports = {};\n    /***/ },\n    /***/ 6279: /***/ (module, __unused_webpack_exports, __nested_webpack_require_125563__)=>{\n        var defineBuiltIn = __nested_webpack_require_125563__(6840);\n        module.exports = function(target, src, options) {\n            for(var key in src)defineBuiltIn(target, key, src[key], options);\n            return target;\n        };\n    /***/ },\n    /***/ 6319: /***/ (module, __unused_webpack_exports, __nested_webpack_require_125886__)=>{\n        var anObject = __nested_webpack_require_125886__(8551);\n        var iteratorClose = __nested_webpack_require_125886__(9539);\n        // call something on iterator step with safe closing on error\n        module.exports = function(iterator, fn, value, ENTRIES) {\n            try {\n                return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n            } catch (error) {\n                iteratorClose(iterator, \"throw\", error);\n            }\n        };\n    /***/ },\n    /***/ 6395: /***/ (module)=>{\n        module.exports = false;\n    /***/ },\n    /***/ 6518: /***/ (module, __unused_webpack_exports, __nested_webpack_require_126509__)=>{\n        var globalThis1 = __nested_webpack_require_126509__(4576);\n        var getOwnPropertyDescriptor = __nested_webpack_require_126509__(7347).f;\n        var createNonEnumerableProperty = __nested_webpack_require_126509__(6699);\n        var defineBuiltIn = __nested_webpack_require_126509__(6840);\n        var defineGlobalProperty = __nested_webpack_require_126509__(9433);\n        var copyConstructorProperties = __nested_webpack_require_126509__(7740);\n        var isForced = __nested_webpack_require_126509__(2796);\n        /*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/ module.exports = function(options, source) {\n            var TARGET = options.target;\n            var GLOBAL = options.global;\n            var STATIC = options.stat;\n            var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n            if (GLOBAL) {\n                target = globalThis1;\n            } else if (STATIC) {\n                target = globalThis1[TARGET] || defineGlobalProperty(TARGET, {});\n            } else {\n                target = globalThis1[TARGET] && globalThis1[TARGET].prototype;\n            }\n            if (target) for(key in source){\n                sourceProperty = source[key];\n                if (options.dontCallGetSet) {\n                    descriptor = getOwnPropertyDescriptor(target, key);\n                    targetProperty = descriptor && descriptor.value;\n                } else targetProperty = target[key];\n                FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n                // contained in target\n                if (!FORCED && targetProperty !== undefined) {\n                    if (typeof sourceProperty == typeof targetProperty) continue;\n                    copyConstructorProperties(sourceProperty, targetProperty);\n                }\n                // add a flag to not completely full polyfills\n                if (options.sham || targetProperty && targetProperty.sham) {\n                    createNonEnumerableProperty(sourceProperty, \"sham\", true);\n                }\n                defineBuiltIn(target, key, sourceProperty, options);\n            }\n        };\n    /***/ },\n    /***/ 6573: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_129592__)=>{\n        var DESCRIPTORS = __nested_webpack_require_129592__(3724);\n        var defineBuiltInAccessor = __nested_webpack_require_129592__(2106);\n        var isDetached = __nested_webpack_require_129592__(3238);\n        var ArrayBufferPrototype = ArrayBuffer.prototype;\n        // `ArrayBuffer.prototype.detached` getter\n        // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.detached\n        if (DESCRIPTORS && !(\"detached\" in ArrayBufferPrototype)) {\n            defineBuiltInAccessor(ArrayBufferPrototype, \"detached\", {\n                configurable: true,\n                get: function detached() {\n                    return isDetached(this);\n                }\n            });\n        }\n    /***/ },\n    /***/ 6632: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_130361__)=>{\n        var $ = __nested_webpack_require_130361__(6518);\n        var globalThis1 = __nested_webpack_require_130361__(4576);\n        var $fromBase64 = __nested_webpack_require_130361__(9143);\n        var anUint8Array = __nested_webpack_require_130361__(4154);\n        var Uint8Array1 = globalThis1.Uint8Array;\n        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array1 || !Uint8Array1.prototype.setFromBase64 || !function() {\n            var target = new Uint8Array1([\n                255,\n                255,\n                255,\n                255,\n                255\n            ]);\n            try {\n                target.setFromBase64(\"\", null);\n                return;\n            } catch (error) {}\n            // Webkit not throw an error on odd length string\n            try {\n                target.setFromBase64(\"a\");\n                return;\n            } catch (error) {}\n            try {\n                target.setFromBase64(\"MjYyZg===\");\n            } catch (error) {\n                return target[0] === 50 && target[1] === 54 && target[2] === 50 && target[3] === 255 && target[4] === 255;\n            }\n        }();\n        // `Uint8Array.prototype.setFromBase64` method\n        // https://github.com/tc39/proposal-arraybuffer-base64\n        if (Uint8Array1) $({\n            target: \"Uint8Array\",\n            proto: true,\n            forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS\n        }, {\n            setFromBase64: function setFromBase64(string /* , options */ ) {\n                anUint8Array(this);\n                var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : undefined, this, this.length);\n                return {\n                    read: result.read,\n                    written: result.written\n                };\n            }\n        });\n    /***/ },\n    /***/ 6699: /***/ (module, __unused_webpack_exports, __nested_webpack_require_132198__)=>{\n        var DESCRIPTORS = __nested_webpack_require_132198__(3724);\n        var definePropertyModule = __nested_webpack_require_132198__(4913);\n        var createPropertyDescriptor = __nested_webpack_require_132198__(6980);\n        module.exports = DESCRIPTORS ? function(object, key, value) {\n            return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n        } : function(object, key, value) {\n            object[key] = value;\n            return object;\n        };\n    /***/ },\n    /***/ 6706: /***/ (module, __unused_webpack_exports, __nested_webpack_require_132749__)=>{\n        var uncurryThis = __nested_webpack_require_132749__(9504);\n        var aCallable = __nested_webpack_require_132749__(9306);\n        module.exports = function(object, key, method) {\n            try {\n                // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n                return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));\n            } catch (error) {}\n        };\n    /***/ },\n    /***/ 6801: /***/ (__unused_webpack_module, exports, __nested_webpack_require_133255__)=>{\n        var DESCRIPTORS = __nested_webpack_require_133255__(3724);\n        var V8_PROTOTYPE_DEFINE_BUG = __nested_webpack_require_133255__(8686);\n        var definePropertyModule = __nested_webpack_require_133255__(4913);\n        var anObject = __nested_webpack_require_133255__(8551);\n        var toIndexedObject = __nested_webpack_require_133255__(5397);\n        var objectKeys = __nested_webpack_require_133255__(1072);\n        // `Object.defineProperties` method\n        // https://tc39.es/ecma262/#sec-object.defineproperties\n        // eslint-disable-next-line es/no-object-defineproperties -- safe\n        exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n            anObject(O);\n            var props = toIndexedObject(Properties);\n            var keys = objectKeys(Properties);\n            var length = keys.length;\n            var index = 0;\n            var key;\n            while(length > index)definePropertyModule.f(O, key = keys[index++], props[key]);\n            return O;\n        };\n    /***/ },\n    /***/ 6823: /***/ (module)=>{\n        var $String = String;\n        module.exports = function(argument) {\n            try {\n                return $String(argument);\n            } catch (error) {\n                return \"Object\";\n            }\n        };\n    /***/ },\n    /***/ 6837: /***/ (module)=>{\n        var $TypeError = TypeError;\n        var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991\n        module.exports = function(it) {\n            if (it > MAX_SAFE_INTEGER) throw $TypeError(\"Maximum allowed index exceeded\");\n            return it;\n        };\n    /***/ },\n    /***/ 6840: /***/ (module, __unused_webpack_exports, __nested_webpack_require_134941__)=>{\n        var isCallable = __nested_webpack_require_134941__(4901);\n        var definePropertyModule = __nested_webpack_require_134941__(4913);\n        var makeBuiltIn = __nested_webpack_require_134941__(283);\n        var defineGlobalProperty = __nested_webpack_require_134941__(9433);\n        module.exports = function(O, key, value, options) {\n            if (!options) options = {};\n            var simple = options.enumerable;\n            var name = options.name !== undefined ? options.name : key;\n            if (isCallable(value)) makeBuiltIn(value, name, options);\n            if (options.global) {\n                if (simple) O[key] = value;\n                else defineGlobalProperty(key, value);\n            } else {\n                try {\n                    if (!options.unsafe) delete O[key];\n                    else if (O[key]) simple = true;\n                } catch (error) {}\n                if (simple) O[key] = value;\n                else definePropertyModule.f(O, key, {\n                    value: value,\n                    enumerable: false,\n                    configurable: !options.nonConfigurable,\n                    writable: !options.nonWritable\n                });\n            }\n            return O;\n        };\n    /***/ },\n    /***/ 6955: /***/ (module, __unused_webpack_exports, __nested_webpack_require_136218__)=>{\n        var TO_STRING_TAG_SUPPORT = __nested_webpack_require_136218__(2140);\n        var isCallable = __nested_webpack_require_136218__(4901);\n        var classofRaw = __nested_webpack_require_136218__(2195);\n        var wellKnownSymbol = __nested_webpack_require_136218__(8227);\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var $Object = Object;\n        // ES3 wrong here\n        var CORRECT_ARGUMENTS = classofRaw(function() {\n            return arguments;\n        }()) === \"Arguments\";\n        // fallback for IE11 Script Access Denied error\n        var tryGet = function(it, key) {\n            try {\n                return it[key];\n            } catch (error) {}\n        };\n        // getting tag from ES6+ `Object.prototype.toString`\n        module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n            var O, tag, result;\n            return it === undefined ? \"Undefined\" : it === null ? \"Null\" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === \"Object\" && isCallable(O.callee) ? \"Arguments\" : result;\n        };\n    /***/ },\n    /***/ 6969: /***/ (module, __unused_webpack_exports, __nested_webpack_require_137409__)=>{\n        var toPrimitive = __nested_webpack_require_137409__(2777);\n        var isSymbol = __nested_webpack_require_137409__(757);\n        // `ToPropertyKey` abstract operation\n        // https://tc39.es/ecma262/#sec-topropertykey\n        module.exports = function(argument) {\n            var key = toPrimitive(argument, \"string\");\n            return isSymbol(key) ? key : key + \"\";\n        };\n    /***/ },\n    /***/ 6980: /***/ (module)=>{\n        module.exports = function(bitmap, value) {\n            return {\n                enumerable: !(bitmap & 1),\n                configurable: !(bitmap & 2),\n                writable: !(bitmap & 4),\n                value: value\n            };\n        };\n    /***/ },\n    /***/ 7040: /***/ (module, __unused_webpack_exports, __nested_webpack_require_138171__)=>{\n        /* eslint-disable es/no-symbol -- required for testing */ var NATIVE_SYMBOL = __nested_webpack_require_138171__(4495);\n        module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\n    /***/ },\n    /***/ 7055: /***/ (module, __unused_webpack_exports, __nested_webpack_require_138472__)=>{\n        var uncurryThis = __nested_webpack_require_138472__(9504);\n        var fails = __nested_webpack_require_138472__(9039);\n        var classof = __nested_webpack_require_138472__(2195);\n        var $Object = Object;\n        var split = uncurryThis(\"\".split);\n        // fallback for non-array-like ES3 and non-enumerable old V8 strings\n        module.exports = fails(function() {\n            // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n            // eslint-disable-next-line no-prototype-builtins -- safe\n            return !$Object(\"z\").propertyIsEnumerable(0);\n        }) ? function(it) {\n            return classof(it) === \"String\" ? split(it, \"\") : $Object(it);\n        } : $Object;\n    /***/ },\n    /***/ 7080: /***/ (module, __unused_webpack_exports, __nested_webpack_require_139250__)=>{\n        var has = __nested_webpack_require_139250__(4402).has;\n        // Perform ? RequireInternalSlot(M, [[SetData]])\n        module.exports = function(it) {\n            has(it);\n            return it;\n        };\n    /***/ },\n    /***/ 7347: /***/ (__unused_webpack_module, exports, __nested_webpack_require_139545__)=>{\n        var DESCRIPTORS = __nested_webpack_require_139545__(3724);\n        var call = __nested_webpack_require_139545__(9565);\n        var propertyIsEnumerableModule = __nested_webpack_require_139545__(8773);\n        var createPropertyDescriptor = __nested_webpack_require_139545__(6980);\n        var toIndexedObject = __nested_webpack_require_139545__(5397);\n        var toPropertyKey = __nested_webpack_require_139545__(6969);\n        var hasOwn = __nested_webpack_require_139545__(9297);\n        var IE8_DOM_DEFINE = __nested_webpack_require_139545__(5917);\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        // `Object.getOwnPropertyDescriptor` method\n        // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n        exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n            O = toIndexedObject(O);\n            P = toPropertyKey(P);\n            if (IE8_DOM_DEFINE) try {\n                return $getOwnPropertyDescriptor(O, P);\n            } catch (error) {}\n            if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n        };\n    /***/ },\n    /***/ 7394: /***/ (module, __unused_webpack_exports, __nested_webpack_require_140789__)=>{\n        var globalThis1 = __nested_webpack_require_140789__(4576);\n        var uncurryThisAccessor = __nested_webpack_require_140789__(6706);\n        var classof = __nested_webpack_require_140789__(2195);\n        var ArrayBuffer1 = globalThis1.ArrayBuffer;\n        var TypeError1 = globalThis1.TypeError;\n        // Includes\n        // - Perform ? RequireInternalSlot(O, [[ArrayBufferData]]).\n        // - If IsSharedArrayBuffer(O) is true, throw a TypeError exception.\n        module.exports = ArrayBuffer1 && uncurryThisAccessor(ArrayBuffer1.prototype, \"byteLength\", \"get\") || function(O) {\n            if (classof(O) !== \"ArrayBuffer\") throw new TypeError1(\"ArrayBuffer expected\");\n            return O.byteLength;\n        };\n    /***/ },\n    /***/ 7416: /***/ (module, __unused_webpack_exports, __nested_webpack_require_141570__)=>{\n        var fails = __nested_webpack_require_141570__(9039);\n        var wellKnownSymbol = __nested_webpack_require_141570__(8227);\n        var DESCRIPTORS = __nested_webpack_require_141570__(3724);\n        var IS_PURE = __nested_webpack_require_141570__(6395);\n        var ITERATOR = wellKnownSymbol(\"iterator\");\n        module.exports = !fails(function() {\n            // eslint-disable-next-line unicorn/relative-url-style -- required for testing\n            var url = new URL(\"b?a=1&b=2&c=3\", \"https://a\");\n            var params = url.searchParams;\n            var params2 = new URLSearchParams(\"a=1&a=2&b=3\");\n            var result = \"\";\n            url.pathname = \"c%20d\";\n            params.forEach(function(value, key) {\n                params[\"delete\"](\"b\");\n                result += key + value;\n            });\n            params2[\"delete\"](\"a\", 2);\n            // `undefined` case is a Chromium 117 bug\n            // https://bugs.chromium.org/p/v8/issues/detail?id=14222\n            params2[\"delete\"](\"b\", undefined);\n            return IS_PURE && (!url.toJSON || !params2.has(\"a\", 1) || params2.has(\"a\", 2) || !params2.has(\"a\", undefined) || params2.has(\"b\")) || !params.size && (IS_PURE || !DESCRIPTORS) || !params.sort || url.href !== \"https://a/c%20d?a=1&c=3\" || params.get(\"c\") !== \"3\" || String(new URLSearchParams(\"?a=1\")) !== \"a=1\" || !params[ITERATOR] || new URL(\"https://a@b\").username !== \"a\" || new URLSearchParams(new URLSearchParams(\"a=b\")).get(\"a\") !== \"b\" || new URL(\"https://\").host !== \"xn--e1aybc\" || new URL(\"https://a#\").hash !== \"#%D0%B1\" || result !== \"a1c3\" || new URL(\"https://x\", undefined).host !== \"x\";\n        });\n    /***/ },\n    /***/ 7476: /***/ (module, __unused_webpack_exports, __nested_webpack_require_143272__)=>{\n        var classofRaw = __nested_webpack_require_143272__(2195);\n        var uncurryThis = __nested_webpack_require_143272__(9504);\n        module.exports = function(fn) {\n            // Nashorn bug:\n            //   https://github.com/zloirock/core-js/issues/1128\n            //   https://github.com/zloirock/core-js/issues/1130\n            if (classofRaw(fn) === \"Function\") return uncurryThis(fn);\n        };\n    /***/ },\n    /***/ 7566: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_143768__)=>{\n        var defineBuiltIn = __nested_webpack_require_143768__(6840);\n        var uncurryThis = __nested_webpack_require_143768__(9504);\n        var toString = __nested_webpack_require_143768__(655);\n        var validateArgumentsLength = __nested_webpack_require_143768__(2812);\n        var $URLSearchParams = URLSearchParams;\n        var URLSearchParamsPrototype = $URLSearchParams.prototype;\n        var getAll = uncurryThis(URLSearchParamsPrototype.getAll);\n        var $has = uncurryThis(URLSearchParamsPrototype.has);\n        var params = new $URLSearchParams(\"a=1\");\n        // `undefined` case is a Chromium 117 bug\n        // https://bugs.chromium.org/p/v8/issues/detail?id=14222\n        if (params.has(\"a\", 2) || !params.has(\"a\", undefined)) {\n            defineBuiltIn(URLSearchParamsPrototype, \"has\", function has(name /* , value */ ) {\n                var length = arguments.length;\n                var $value = length < 2 ? undefined : arguments[1];\n                if (length && $value === undefined) return $has(this, name);\n                var values = getAll(this, name); // also validates `this`\n                validateArgumentsLength(length, 1);\n                var value = toString($value);\n                var index = 0;\n                while(index < values.length){\n                    if (values[index++] === value) return true;\n                }\n                return false;\n            }, {\n                enumerable: true,\n                unsafe: true\n            });\n        }\n    /***/ },\n    /***/ 7588: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_145329__)=>{\n        var $ = __nested_webpack_require_145329__(6518);\n        var call = __nested_webpack_require_145329__(9565);\n        var iterate = __nested_webpack_require_145329__(2652);\n        var aCallable = __nested_webpack_require_145329__(9306);\n        var anObject = __nested_webpack_require_145329__(8551);\n        var getIteratorDirect = __nested_webpack_require_145329__(1767);\n        var iteratorClose = __nested_webpack_require_145329__(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_145329__(4549);\n        var forEachWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError(\"forEach\", TypeError);\n        // `Iterator.prototype.forEach` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.foreach\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: forEachWithoutClosingOnEarlyError\n        }, {\n            forEach: function forEach(fn) {\n                anObject(this);\n                try {\n                    aCallable(fn);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (forEachWithoutClosingOnEarlyError) return call(forEachWithoutClosingOnEarlyError, this, fn);\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                iterate(record, function(value) {\n                    fn(value, counter++);\n                }, {\n                    IS_RECORD: true\n                });\n            }\n        });\n    /***/ },\n    /***/ 7629: /***/ (module, __unused_webpack_exports, __nested_webpack_require_146881__)=>{\n        var IS_PURE = __nested_webpack_require_146881__(6395);\n        var globalThis1 = __nested_webpack_require_146881__(4576);\n        var defineGlobalProperty = __nested_webpack_require_146881__(9433);\n        var SHARED = \"__core-js_shared__\";\n        var store = module.exports = globalThis1[SHARED] || defineGlobalProperty(SHARED, {});\n        (store.versions || (store.versions = [])).push({\n            version: \"3.45.1\",\n            mode: IS_PURE ? \"pure\" : \"global\",\n            copyright: \"\\xa9 2014-2025 Denis Pushkarev (zloirock.ru)\",\n            license: \"https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE\",\n            source: \"https://github.com/zloirock/core-js\"\n        });\n    /***/ },\n    /***/ 7642: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_147650__)=>{\n        var $ = __nested_webpack_require_147650__(6518);\n        var difference = __nested_webpack_require_147650__(3440);\n        var fails = __nested_webpack_require_147650__(9039);\n        var setMethodAcceptSetLike = __nested_webpack_require_147650__(4916);\n        var SET_LIKE_INCORRECT_BEHAVIOR = !setMethodAcceptSetLike(\"difference\", function(result) {\n            return result.size === 0;\n        });\n        var FORCED = SET_LIKE_INCORRECT_BEHAVIOR || fails(function() {\n            // https://bugs.webkit.org/show_bug.cgi?id=288595\n            var setLike = {\n                size: 1,\n                has: function() {\n                    return true;\n                },\n                keys: function() {\n                    var index = 0;\n                    return {\n                        next: function() {\n                            var done = index++ > 1;\n                            if (baseSet.has(1)) baseSet.clear();\n                            return {\n                                done: done,\n                                value: 2\n                            };\n                        }\n                    };\n                }\n            };\n            // eslint-disable-next-line es/no-set -- testing\n            var baseSet = new Set([\n                1,\n                2,\n                3,\n                4\n            ]);\n            // eslint-disable-next-line es/no-set-prototype-difference -- testing\n            return baseSet.difference(setLike).size !== 3;\n        });\n        // `Set.prototype.difference` method\n        // https://tc39.es/ecma262/#sec-set.prototype.difference\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            difference: difference\n        });\n    /***/ },\n    /***/ 7657: /***/ (module, __unused_webpack_exports, __nested_webpack_require_149491__)=>{\n        var fails = __nested_webpack_require_149491__(9039);\n        var isCallable = __nested_webpack_require_149491__(4901);\n        var isObject = __nested_webpack_require_149491__(34);\n        var create = __nested_webpack_require_149491__(2360);\n        var getPrototypeOf = __nested_webpack_require_149491__(2787);\n        var defineBuiltIn = __nested_webpack_require_149491__(6840);\n        var wellKnownSymbol = __nested_webpack_require_149491__(8227);\n        var IS_PURE = __nested_webpack_require_149491__(6395);\n        var ITERATOR = wellKnownSymbol(\"iterator\");\n        var BUGGY_SAFARI_ITERATORS = false;\n        // `%IteratorPrototype%` object\n        // https://tc39.es/ecma262/#sec-%iteratorprototype%-object\n        var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n        /* eslint-disable es/no-array-prototype-keys -- safe */ if ([].keys) {\n            arrayIterator = [].keys();\n            // Safari 8 has buggy iterators w/o `next`\n            if (!(\"next\" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n            else {\n                PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n                if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n            }\n        }\n        var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {\n            var test = {};\n            // FF44- legacy iterators case\n            return IteratorPrototype[ITERATOR].call(test) !== test;\n        });\n        if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\n        else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);\n        // `%IteratorPrototype%[@@iterator]()` method\n        // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\n        if (!isCallable(IteratorPrototype[ITERATOR])) {\n            defineBuiltIn(IteratorPrototype, ITERATOR, function() {\n                return this;\n            });\n        }\n        module.exports = {\n            IteratorPrototype: IteratorPrototype,\n            BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n        };\n    /***/ },\n    /***/ 7680: /***/ (module, __unused_webpack_exports, __nested_webpack_require_151624__)=>{\n        var uncurryThis = __nested_webpack_require_151624__(9504);\n        module.exports = uncurryThis([].slice);\n    /***/ },\n    /***/ 7696: /***/ (module, __unused_webpack_exports, __nested_webpack_require_151819__)=>{\n        var toIntegerOrInfinity = __nested_webpack_require_151819__(1291);\n        var toLength = __nested_webpack_require_151819__(8014);\n        var $RangeError = RangeError;\n        // `ToIndex` abstract operation\n        // https://tc39.es/ecma262/#sec-toindex\n        module.exports = function(it) {\n            if (it === undefined) return 0;\n            var number = toIntegerOrInfinity(it);\n            var length = toLength(number);\n            if (number !== length) throw new $RangeError(\"Wrong length or index\");\n            return length;\n        };\n    /***/ },\n    /***/ 7740: /***/ (module, __unused_webpack_exports, __nested_webpack_require_152448__)=>{\n        var hasOwn = __nested_webpack_require_152448__(9297);\n        var ownKeys = __nested_webpack_require_152448__(5031);\n        var getOwnPropertyDescriptorModule = __nested_webpack_require_152448__(7347);\n        var definePropertyModule = __nested_webpack_require_152448__(4913);\n        module.exports = function(target, source, exceptions) {\n            var keys = ownKeys(source);\n            var defineProperty = definePropertyModule.f;\n            var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n            for(var i = 0; i < keys.length; i++){\n                var key = keys[i];\n                if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n                    defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n                }\n            }\n        };\n    /***/ },\n    /***/ 7750: /***/ (module, __unused_webpack_exports, __nested_webpack_require_153315__)=>{\n        var isNullOrUndefined = __nested_webpack_require_153315__(4117);\n        var $TypeError = TypeError;\n        // `RequireObjectCoercible` abstract operation\n        // https://tc39.es/ecma262/#sec-requireobjectcoercible\n        module.exports = function(it) {\n            if (isNullOrUndefined(it)) throw new $TypeError(\"Can't call method on \" + it);\n            return it;\n        };\n    /***/ },\n    /***/ 7751: /***/ (module, __unused_webpack_exports, __nested_webpack_require_153787__)=>{\n        var globalThis1 = __nested_webpack_require_153787__(4576);\n        var isCallable = __nested_webpack_require_153787__(4901);\n        var aFunction = function(argument) {\n            return isCallable(argument) ? argument : undefined;\n        };\n        module.exports = function(namespace, method) {\n            return arguments.length < 2 ? aFunction(globalThis1[namespace]) : globalThis1[namespace] && globalThis1[namespace][method];\n        };\n    /***/ },\n    /***/ 7811: /***/ (module)=>{\n        // eslint-disable-next-line es/no-typed-arrays -- safe\n        module.exports = typeof ArrayBuffer != \"undefined\" && typeof DataView != \"undefined\";\n    /***/ },\n    /***/ 7936: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_154529__)=>{\n        var $ = __nested_webpack_require_154529__(6518);\n        var $transfer = __nested_webpack_require_154529__(5636);\n        // `ArrayBuffer.prototype.transferToFixedLength` method\n        // https://tc39.es/ecma262/#sec-arraybuffer.prototype.transfertofixedlength\n        if ($transfer) $({\n            target: \"ArrayBuffer\",\n            proto: true\n        }, {\n            transferToFixedLength: function transferToFixedLength() {\n                return $transfer(this, arguments.length ? arguments[0] : undefined, false);\n            }\n        });\n    /***/ },\n    /***/ 8004: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_155169__)=>{\n        var $ = __nested_webpack_require_155169__(6518);\n        var fails = __nested_webpack_require_155169__(9039);\n        var intersection = __nested_webpack_require_155169__(8750);\n        var setMethodAcceptSetLike = __nested_webpack_require_155169__(4916);\n        var INCORRECT = !setMethodAcceptSetLike(\"intersection\", function(result) {\n            return result.size === 2 && result.has(1) && result.has(2);\n        }) || fails(function() {\n            // eslint-disable-next-line es/no-array-from, es/no-set, es/no-set-prototype-intersection -- testing\n            return String(Array.from(new Set([\n                1,\n                2,\n                3\n            ]).intersection(new Set([\n                3,\n                2\n            ])))) !== \"3,2\";\n        });\n        // `Set.prototype.intersection` method\n        // https://tc39.es/ecma262/#sec-set.prototype.intersection\n        $({\n            target: \"Set\",\n            proto: true,\n            real: true,\n            forced: INCORRECT\n        }, {\n            intersection: intersection\n        });\n    /***/ },\n    /***/ 8014: /***/ (module, __unused_webpack_exports, __nested_webpack_require_156287__)=>{\n        var toIntegerOrInfinity = __nested_webpack_require_156287__(1291);\n        var min = Math.min;\n        // `ToLength` abstract operation\n        // https://tc39.es/ecma262/#sec-tolength\n        module.exports = function(argument) {\n            var len = toIntegerOrInfinity(argument);\n            return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n        };\n    /***/ },\n    /***/ 8100: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_156783__)=>{\n        var $ = __nested_webpack_require_156783__(6518);\n        var $transfer = __nested_webpack_require_156783__(5636);\n        // `ArrayBuffer.prototype.transfer` method\n        // https://tc39.es/ecma262/#sec-arraybuffer.prototype.transfer\n        if ($transfer) $({\n            target: \"ArrayBuffer\",\n            proto: true\n        }, {\n            transfer: function transfer() {\n                return $transfer(this, arguments.length ? arguments[0] : undefined, true);\n            }\n        });\n    /***/ },\n    /***/ 8111: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_157370__)=>{\n        var $ = __nested_webpack_require_157370__(6518);\n        var globalThis1 = __nested_webpack_require_157370__(4576);\n        var anInstance = __nested_webpack_require_157370__(679);\n        var anObject = __nested_webpack_require_157370__(8551);\n        var isCallable = __nested_webpack_require_157370__(4901);\n        var getPrototypeOf = __nested_webpack_require_157370__(2787);\n        var defineBuiltInAccessor = __nested_webpack_require_157370__(2106);\n        var createProperty = __nested_webpack_require_157370__(4659);\n        var fails = __nested_webpack_require_157370__(9039);\n        var hasOwn = __nested_webpack_require_157370__(9297);\n        var wellKnownSymbol = __nested_webpack_require_157370__(8227);\n        var IteratorPrototype = __nested_webpack_require_157370__(7657).IteratorPrototype;\n        var DESCRIPTORS = __nested_webpack_require_157370__(3724);\n        var IS_PURE = __nested_webpack_require_157370__(6395);\n        var CONSTRUCTOR = \"constructor\";\n        var ITERATOR = \"Iterator\";\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var $TypeError = TypeError;\n        var NativeIterator = globalThis1[ITERATOR];\n        // FF56- have non-standard global helper `Iterator`\n        var FORCED = IS_PURE || !isCallable(NativeIterator) || NativeIterator.prototype !== IteratorPrototype || !fails(function() {\n            NativeIterator({});\n        });\n        var IteratorConstructor = function Iterator1() {\n            anInstance(this, IteratorPrototype);\n            if (getPrototypeOf(this) === IteratorPrototype) throw new $TypeError(\"Abstract class Iterator not directly constructable\");\n        };\n        var defineIteratorPrototypeAccessor = function(key, value) {\n            if (DESCRIPTORS) {\n                defineBuiltInAccessor(IteratorPrototype, key, {\n                    configurable: true,\n                    get: function() {\n                        return value;\n                    },\n                    set: function(replacement) {\n                        anObject(this);\n                        if (this === IteratorPrototype) throw new $TypeError(\"You can't redefine this property\");\n                        if (hasOwn(this, key)) this[key] = replacement;\n                        else createProperty(this, key, replacement);\n                    }\n                });\n            } else IteratorPrototype[key] = value;\n        };\n        if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);\n        if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {\n            defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);\n        }\n        IteratorConstructor.prototype = IteratorPrototype;\n        // `Iterator` constructor\n        // https://tc39.es/ecma262/#sec-iterator\n        $({\n            global: true,\n            constructor: true,\n            forced: FORCED\n        }, {\n            Iterator: IteratorConstructor\n        });\n    /***/ },\n    /***/ 8227: /***/ (module, __unused_webpack_exports, __nested_webpack_require_160301__)=>{\n        var globalThis1 = __nested_webpack_require_160301__(4576);\n        var shared = __nested_webpack_require_160301__(5745);\n        var hasOwn = __nested_webpack_require_160301__(9297);\n        var uid = __nested_webpack_require_160301__(3392);\n        var NATIVE_SYMBOL = __nested_webpack_require_160301__(4495);\n        var USE_SYMBOL_AS_UID = __nested_webpack_require_160301__(7040);\n        var Symbol1 = globalThis1.Symbol;\n        var WellKnownSymbolsStore = shared(\"wks\");\n        var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol1[\"for\"] || Symbol1 : Symbol1 && Symbol1.withoutSetter || uid;\n        module.exports = function(name) {\n            if (!hasOwn(WellKnownSymbolsStore, name)) {\n                WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol1, name) ? Symbol1[name] : createWellKnownSymbol(\"Symbol.\" + name);\n            }\n            return WellKnownSymbolsStore[name];\n        };\n    /***/ },\n    /***/ 8235: /***/ (module, __unused_webpack_exports, __nested_webpack_require_161236__)=>{\n        var uncurryThis = __nested_webpack_require_161236__(9504);\n        var hasOwn = __nested_webpack_require_161236__(9297);\n        var $SyntaxError = SyntaxError;\n        var $parseInt = parseInt;\n        var fromCharCode = String.fromCharCode;\n        var at = uncurryThis(\"\".charAt);\n        var slice = uncurryThis(\"\".slice);\n        var exec = uncurryThis(/./.exec);\n        var codePoints = {\n            '\\\\\"': '\"',\n            \"\\\\\\\\\": \"\\\\\",\n            \"\\\\/\": \"/\",\n            \"\\\\b\": \"\\b\",\n            \"\\\\f\": \"\\f\",\n            \"\\\\n\": \"\\n\",\n            \"\\\\r\": \"\\r\",\n            \"\\\\t\": \"\t\"\n        };\n        var IS_4_HEX_DIGITS = /^[\\da-f]{4}$/i;\n        // eslint-disable-next-line regexp/no-control-character -- safe\n        var IS_C0_CONTROL_CODE = /^[\\u0000-\\u001F]$/;\n        module.exports = function(source, i) {\n            var unterminated = true;\n            var value = \"\";\n            while(i < source.length){\n                var chr = at(source, i);\n                if (chr === \"\\\\\") {\n                    var twoChars = slice(source, i, i + 2);\n                    if (hasOwn(codePoints, twoChars)) {\n                        value += codePoints[twoChars];\n                        i += 2;\n                    } else if (twoChars === \"\\\\u\") {\n                        i += 2;\n                        var fourHexDigits = slice(source, i, i + 4);\n                        if (!exec(IS_4_HEX_DIGITS, fourHexDigits)) throw new $SyntaxError(\"Bad Unicode escape at: \" + i);\n                        value += fromCharCode($parseInt(fourHexDigits, 16));\n                        i += 4;\n                    } else throw new $SyntaxError('Unknown escape sequence: \"' + twoChars + '\"');\n                } else if (chr === '\"') {\n                    unterminated = false;\n                    i++;\n                    break;\n                } else {\n                    if (exec(IS_C0_CONTROL_CODE, chr)) throw new $SyntaxError(\"Bad control character in string literal at: \" + i);\n                    value += chr;\n                    i++;\n                }\n            }\n            if (unterminated) throw new $SyntaxError(\"Unterminated string at: \" + i);\n            return {\n                value: value,\n                end: i\n            };\n        };\n    /***/ },\n    /***/ 8237: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_163586__)=>{\n        var $ = __nested_webpack_require_163586__(6518);\n        var iterate = __nested_webpack_require_163586__(2652);\n        var aCallable = __nested_webpack_require_163586__(9306);\n        var anObject = __nested_webpack_require_163586__(8551);\n        var getIteratorDirect = __nested_webpack_require_163586__(1767);\n        var iteratorClose = __nested_webpack_require_163586__(9539);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_163586__(4549);\n        var apply = __nested_webpack_require_163586__(8745);\n        var fails = __nested_webpack_require_163586__(9039);\n        var $TypeError = TypeError;\n        // https://bugs.webkit.org/show_bug.cgi?id=291651\n        var FAILS_ON_INITIAL_UNDEFINED = fails(function() {\n            // eslint-disable-next-line es/no-iterator-prototype-reduce, es/no-array-prototype-keys, array-callback-return -- required for testing\n            [].keys().reduce(function() {}, undefined);\n        });\n        var reduceWithoutClosingOnEarlyError = !FAILS_ON_INITIAL_UNDEFINED && iteratorHelperWithoutClosingOnEarlyError(\"reduce\", $TypeError);\n        // `Iterator.prototype.reduce` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.reduce\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FAILS_ON_INITIAL_UNDEFINED || reduceWithoutClosingOnEarlyError\n        }, {\n            reduce: function reduce(reducer /* , initialValue */ ) {\n                anObject(this);\n                try {\n                    aCallable(reducer);\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                var noInitial = arguments.length < 2;\n                var accumulator = noInitial ? undefined : arguments[1];\n                if (reduceWithoutClosingOnEarlyError) {\n                    return apply(reduceWithoutClosingOnEarlyError, this, noInitial ? [\n                        reducer\n                    ] : [\n                        reducer,\n                        accumulator\n                    ]);\n                }\n                var record = getIteratorDirect(this);\n                var counter = 0;\n                iterate(record, function(value) {\n                    if (noInitial) {\n                        noInitial = false;\n                        accumulator = value;\n                    } else {\n                        accumulator = reducer(accumulator, value, counter);\n                    }\n                    counter++;\n                }, {\n                    IS_RECORD: true\n                });\n                if (noInitial) throw new $TypeError(\"Reduce of empty iterator with no initial value\");\n                return accumulator;\n            }\n        });\n    /***/ },\n    /***/ 8335: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_166364__)=>{\n        var $ = __nested_webpack_require_166364__(6518);\n        var DESCRIPTORS = __nested_webpack_require_166364__(3724);\n        var globalThis1 = __nested_webpack_require_166364__(4576);\n        var getBuiltIn = __nested_webpack_require_166364__(7751);\n        var uncurryThis = __nested_webpack_require_166364__(9504);\n        var call = __nested_webpack_require_166364__(9565);\n        var isCallable = __nested_webpack_require_166364__(4901);\n        var isObject = __nested_webpack_require_166364__(34);\n        var isArray = __nested_webpack_require_166364__(4376);\n        var hasOwn = __nested_webpack_require_166364__(9297);\n        var toString = __nested_webpack_require_166364__(655);\n        var lengthOfArrayLike = __nested_webpack_require_166364__(6198);\n        var createProperty = __nested_webpack_require_166364__(4659);\n        var fails = __nested_webpack_require_166364__(9039);\n        var parseJSONString = __nested_webpack_require_166364__(8235);\n        var NATIVE_SYMBOL = __nested_webpack_require_166364__(4495);\n        var JSON1 = globalThis1.JSON;\n        var Number1 = globalThis1.Number;\n        var SyntaxError1 = globalThis1.SyntaxError;\n        var nativeParse = JSON1 && JSON1.parse;\n        var enumerableOwnProperties = getBuiltIn(\"Object\", \"keys\");\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        var at = uncurryThis(\"\".charAt);\n        var slice = uncurryThis(\"\".slice);\n        var exec = uncurryThis(/./.exec);\n        var push = uncurryThis([].push);\n        var IS_DIGIT = /^\\d$/;\n        var IS_NON_ZERO_DIGIT = /^[1-9]$/;\n        var IS_NUMBER_START = /^[\\d-]$/;\n        var IS_WHITESPACE = /^[\\t\\n\\r ]$/;\n        var PRIMITIVE = 0;\n        var OBJECT = 1;\n        var $parse = function(source, reviver) {\n            source = toString(source);\n            var context = new Context(source, 0, \"\");\n            var root = context.parse();\n            var value = root.value;\n            var endIndex = context.skip(IS_WHITESPACE, root.end);\n            if (endIndex < source.length) {\n                throw new SyntaxError1('Unexpected extra character: \"' + at(source, endIndex) + '\" after the parsed data at: ' + endIndex);\n            }\n            return isCallable(reviver) ? internalize({\n                \"\": value\n            }, \"\", reviver, root) : value;\n        };\n        var internalize = function(holder, name, reviver, node) {\n            var val = holder[name];\n            var unmodified = node && val === node.value;\n            var context = unmodified && typeof node.source == \"string\" ? {\n                source: node.source\n            } : {};\n            var elementRecordsLen, keys, len, i, P;\n            if (isObject(val)) {\n                var nodeIsArray = isArray(val);\n                var nodes = unmodified ? node.nodes : nodeIsArray ? [] : {};\n                if (nodeIsArray) {\n                    elementRecordsLen = nodes.length;\n                    len = lengthOfArrayLike(val);\n                    for(i = 0; i < len; i++){\n                        internalizeProperty(val, i, internalize(val, \"\" + i, reviver, i < elementRecordsLen ? nodes[i] : undefined));\n                    }\n                } else {\n                    keys = enumerableOwnProperties(val);\n                    len = lengthOfArrayLike(keys);\n                    for(i = 0; i < len; i++){\n                        P = keys[i];\n                        internalizeProperty(val, P, internalize(val, P, reviver, hasOwn(nodes, P) ? nodes[P] : undefined));\n                    }\n                }\n            }\n            return call(reviver, holder, name, val, context);\n        };\n        var internalizeProperty = function(object, key, value) {\n            if (DESCRIPTORS) {\n                var descriptor = getOwnPropertyDescriptor(object, key);\n                if (descriptor && !descriptor.configurable) return;\n            }\n            if (value === undefined) delete object[key];\n            else createProperty(object, key, value);\n        };\n        var Node1 = function(value, end, source, nodes) {\n            this.value = value;\n            this.end = end;\n            this.source = source;\n            this.nodes = nodes;\n        };\n        var Context = function(source, index) {\n            this.source = source;\n            this.index = index;\n        };\n        // https://www.json.org/json-en.html\n        Context.prototype = {\n            fork: function(nextIndex) {\n                return new Context(this.source, nextIndex);\n            },\n            parse: function() {\n                var source = this.source;\n                var i = this.skip(IS_WHITESPACE, this.index);\n                var fork = this.fork(i);\n                var chr = at(source, i);\n                if (exec(IS_NUMBER_START, chr)) return fork.number();\n                switch(chr){\n                    case \"{\":\n                        return fork.object();\n                    case \"[\":\n                        return fork.array();\n                    case '\"':\n                        return fork.string();\n                    case \"t\":\n                        return fork.keyword(true);\n                    case \"f\":\n                        return fork.keyword(false);\n                    case \"n\":\n                        return fork.keyword(null);\n                }\n                throw new SyntaxError1('Unexpected character: \"' + chr + '\" at: ' + i);\n            },\n            node: function(type, value, start, end, nodes) {\n                return new Node1(value, end, type ? null : slice(this.source, start, end), nodes);\n            },\n            object: function() {\n                var source = this.source;\n                var i = this.index + 1;\n                var expectKeypair = false;\n                var object = {};\n                var nodes = {};\n                while(i < source.length){\n                    i = this.until([\n                        '\"',\n                        \"}\"\n                    ], i);\n                    if (at(source, i) === \"}\" && !expectKeypair) {\n                        i++;\n                        break;\n                    }\n                    // Parsing the key\n                    var result = this.fork(i).string();\n                    var key = result.value;\n                    i = result.end;\n                    i = this.until([\n                        \":\"\n                    ], i) + 1;\n                    // Parsing value\n                    i = this.skip(IS_WHITESPACE, i);\n                    result = this.fork(i).parse();\n                    createProperty(nodes, key, result);\n                    createProperty(object, key, result.value);\n                    i = this.until([\n                        \",\",\n                        \"}\"\n                    ], result.end);\n                    var chr = at(source, i);\n                    if (chr === \",\") {\n                        expectKeypair = true;\n                        i++;\n                    } else if (chr === \"}\") {\n                        i++;\n                        break;\n                    }\n                }\n                return this.node(OBJECT, object, this.index, i, nodes);\n            },\n            array: function() {\n                var source = this.source;\n                var i = this.index + 1;\n                var expectElement = false;\n                var array = [];\n                var nodes = [];\n                while(i < source.length){\n                    i = this.skip(IS_WHITESPACE, i);\n                    if (at(source, i) === \"]\" && !expectElement) {\n                        i++;\n                        break;\n                    }\n                    var result = this.fork(i).parse();\n                    push(nodes, result);\n                    push(array, result.value);\n                    i = this.until([\n                        \",\",\n                        \"]\"\n                    ], result.end);\n                    if (at(source, i) === \",\") {\n                        expectElement = true;\n                        i++;\n                    } else if (at(source, i) === \"]\") {\n                        i++;\n                        break;\n                    }\n                }\n                return this.node(OBJECT, array, this.index, i, nodes);\n            },\n            string: function() {\n                var index = this.index;\n                var parsed = parseJSONString(this.source, this.index + 1);\n                return this.node(PRIMITIVE, parsed.value, index, parsed.end);\n            },\n            number: function() {\n                var source = this.source;\n                var startIndex = this.index;\n                var i = startIndex;\n                if (at(source, i) === \"-\") i++;\n                if (at(source, i) === \"0\") i++;\n                else if (exec(IS_NON_ZERO_DIGIT, at(source, i))) i = this.skip(IS_DIGIT, i + 1);\n                else throw new SyntaxError1(\"Failed to parse number at: \" + i);\n                if (at(source, i) === \".\") i = this.skip(IS_DIGIT, i + 1);\n                if (at(source, i) === \"e\" || at(source, i) === \"E\") {\n                    i++;\n                    if (at(source, i) === \"+\" || at(source, i) === \"-\") i++;\n                    var exponentStartIndex = i;\n                    i = this.skip(IS_DIGIT, i);\n                    if (exponentStartIndex === i) throw new SyntaxError1(\"Failed to parse number's exponent value at: \" + i);\n                }\n                return this.node(PRIMITIVE, Number1(slice(source, startIndex, i)), startIndex, i);\n            },\n            keyword: function(value) {\n                var keyword = \"\" + value;\n                var index = this.index;\n                var endIndex = index + keyword.length;\n                if (slice(this.source, index, endIndex) !== keyword) throw new SyntaxError1(\"Failed to parse value at: \" + index);\n                return this.node(PRIMITIVE, value, index, endIndex);\n            },\n            skip: function(regex, i) {\n                var source = this.source;\n                for(; i < source.length; i++)if (!exec(regex, at(source, i))) break;\n                return i;\n            },\n            until: function(array, i) {\n                i = this.skip(IS_WHITESPACE, i);\n                var chr = at(this.source, i);\n                for(var j = 0; j < array.length; j++)if (array[j] === chr) return i;\n                throw new SyntaxError1('Unexpected character: \"' + chr + '\" at: ' + i);\n            }\n        };\n        var NO_SOURCE_SUPPORT = fails(function() {\n            var unsafeInt = \"9007199254740993\";\n            var source;\n            nativeParse(unsafeInt, function(key, value, context) {\n                source = context.source;\n            });\n            return source !== unsafeInt;\n        });\n        var PROPER_BASE_PARSE = NATIVE_SYMBOL && !fails(function() {\n            // Safari 9 bug\n            return 1 / nativeParse(\"-0 \t\") !== -Infinity;\n        });\n        // `JSON.parse` method\n        // https://tc39.es/ecma262/#sec-json.parse\n        // https://github.com/tc39/proposal-json-parse-with-source\n        $({\n            target: \"JSON\",\n            stat: true,\n            forced: NO_SOURCE_SUPPORT\n        }, {\n            parse: function parse(text, reviver) {\n                return PROPER_BASE_PARSE && !isCallable(reviver) ? nativeParse(text) : $parse(text, reviver);\n            }\n        });\n    /***/ },\n    /***/ 8469: /***/ (module, __unused_webpack_exports, __nested_webpack_require_177758__)=>{\n        var uncurryThis = __nested_webpack_require_177758__(9504);\n        var iterateSimple = __nested_webpack_require_177758__(507);\n        var SetHelpers = __nested_webpack_require_177758__(4402);\n        var Set1 = SetHelpers.Set;\n        var SetPrototype = SetHelpers.proto;\n        var forEach = uncurryThis(SetPrototype.forEach);\n        var keys = uncurryThis(SetPrototype.keys);\n        var next = keys(new Set1()).next;\n        module.exports = function(set, fn, interruptible) {\n            return interruptible ? iterateSimple({\n                iterator: keys(set),\n                next: next\n            }, fn) : forEach(set, fn);\n        };\n    /***/ },\n    /***/ 8480: /***/ (__unused_webpack_module, exports, __nested_webpack_require_178466__)=>{\n        var internalObjectKeys = __nested_webpack_require_178466__(1828);\n        var enumBugKeys = __nested_webpack_require_178466__(8727);\n        var hiddenKeys = enumBugKeys.concat(\"length\", \"prototype\");\n        // `Object.getOwnPropertyNames` method\n        // https://tc39.es/ecma262/#sec-object.getownpropertynames\n        // eslint-disable-next-line es/no-object-getownpropertynames -- safe\n        exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n            return internalObjectKeys(O, hiddenKeys);\n        };\n    /***/ },\n    /***/ 8527: /***/ (module, __unused_webpack_exports, __nested_webpack_require_179081__)=>{\n        var aSet = __nested_webpack_require_179081__(7080);\n        var has = __nested_webpack_require_179081__(4402).has;\n        var size = __nested_webpack_require_179081__(5170);\n        var getSetRecord = __nested_webpack_require_179081__(3789);\n        var iterateSimple = __nested_webpack_require_179081__(507);\n        var iteratorClose = __nested_webpack_require_179081__(9539);\n        // `Set.prototype.isSupersetOf` method\n        // https://tc39.es/ecma262/#sec-set.prototype.issupersetof\n        module.exports = function isSupersetOf(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            if (size(O) < otherRec.size) return false;\n            var iterator = otherRec.getIterator();\n            return iterateSimple(iterator, function(e) {\n                if (!has(O, e)) return iteratorClose(iterator, \"normal\", false);\n            }) !== false;\n        };\n    /***/ },\n    /***/ 8551: /***/ (module, __unused_webpack_exports, __nested_webpack_require_180010__)=>{\n        var isObject = __nested_webpack_require_180010__(34);\n        var $String = String;\n        var $TypeError = TypeError;\n        // `Assert: Type(argument) is Object`\n        module.exports = function(argument) {\n            if (isObject(argument)) return argument;\n            throw new $TypeError($String(argument) + \" is not an object\");\n        };\n    /***/ },\n    /***/ 8574: /***/ (module, __unused_webpack_exports, __nested_webpack_require_180449__)=>{\n        var uncurryThis = __nested_webpack_require_180449__(9504);\n        var $Error = Error;\n        var replace = uncurryThis(\"\".replace);\n        var TEST = function(arg) {\n            return String(new $Error(arg).stack);\n        }(\"zxcasd\");\n        // eslint-disable-next-line redos/no-vulnerable, sonarjs/slow-regex -- safe\n        var V8_OR_CHAKRA_STACK_ENTRY = /\\n\\s*at [^:]*:[^\\n]*/;\n        var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);\n        module.exports = function(stack, dropEntries) {\n            if (IS_V8_OR_CHAKRA_STACK && typeof stack == \"string\" && !$Error.prepareStackTrace) {\n                while(dropEntries--)stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, \"\");\n            }\n            return stack;\n        };\n    /***/ },\n    /***/ 8622: /***/ (module, __unused_webpack_exports, __nested_webpack_require_181292__)=>{\n        var globalThis1 = __nested_webpack_require_181292__(4576);\n        var isCallable = __nested_webpack_require_181292__(4901);\n        var WeakMap1 = globalThis1.WeakMap;\n        module.exports = isCallable(WeakMap1) && /native code/.test(String(WeakMap1));\n    /***/ },\n    /***/ 8646: /***/ (module, __unused_webpack_exports, __nested_webpack_require_181622__)=>{\n        var call = __nested_webpack_require_181622__(9565);\n        var anObject = __nested_webpack_require_181622__(8551);\n        var getIteratorDirect = __nested_webpack_require_181622__(1767);\n        var getIteratorMethod = __nested_webpack_require_181622__(851);\n        module.exports = function(obj, stringHandling) {\n            if (!stringHandling || typeof obj !== \"string\") anObject(obj);\n            var method = getIteratorMethod(obj);\n            return getIteratorDirect(anObject(method !== undefined ? call(method, obj) : obj));\n        };\n    /***/ },\n    /***/ 8686: /***/ (module, __unused_webpack_exports, __nested_webpack_require_182217__)=>{\n        var DESCRIPTORS = __nested_webpack_require_182217__(3724);\n        var fails = __nested_webpack_require_182217__(9039);\n        // V8 ~ Chrome 36-\n        // https://bugs.chromium.org/p/v8/issues/detail?id=3334\n        module.exports = DESCRIPTORS && fails(function() {\n            // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n            return Object.defineProperty(function() {}, \"prototype\", {\n                value: 42,\n                writable: false\n            }).prototype !== 42;\n        });\n    /***/ },\n    /***/ 8721: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_182845__)=>{\n        var DESCRIPTORS = __nested_webpack_require_182845__(3724);\n        var uncurryThis = __nested_webpack_require_182845__(9504);\n        var defineBuiltInAccessor = __nested_webpack_require_182845__(2106);\n        var URLSearchParamsPrototype = URLSearchParams.prototype;\n        var forEach = uncurryThis(URLSearchParamsPrototype.forEach);\n        // `URLSearchParams.prototype.size` getter\n        // https://github.com/whatwg/url/pull/734\n        if (DESCRIPTORS && !(\"size\" in URLSearchParamsPrototype)) {\n            defineBuiltInAccessor(URLSearchParamsPrototype, \"size\", {\n                get: function size() {\n                    var count = 0;\n                    forEach(this, function() {\n                        count++;\n                    });\n                    return count;\n                },\n                configurable: true,\n                enumerable: true\n            });\n        }\n    /***/ },\n    /***/ 8727: /***/ (module)=>{\n        // IE8- don't enum bug keys\n        module.exports = [\n            \"constructor\",\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\",\n            \"toLocaleString\",\n            \"toString\",\n            \"valueOf\"\n        ];\n    /***/ },\n    /***/ 8745: /***/ (module, __unused_webpack_exports, __nested_webpack_require_184127__)=>{\n        var NATIVE_BIND = __nested_webpack_require_184127__(616);\n        var FunctionPrototype = Function.prototype;\n        var apply = FunctionPrototype.apply;\n        var call = FunctionPrototype.call;\n        // eslint-disable-next-line es/no-function-prototype-bind, es/no-reflect -- safe\n        module.exports = typeof Reflect == \"object\" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {\n            return call.apply(apply, arguments);\n        });\n    /***/ },\n    /***/ 8750: /***/ (module, __unused_webpack_exports, __nested_webpack_require_184682__)=>{\n        var aSet = __nested_webpack_require_184682__(7080);\n        var SetHelpers = __nested_webpack_require_184682__(4402);\n        var size = __nested_webpack_require_184682__(5170);\n        var getSetRecord = __nested_webpack_require_184682__(3789);\n        var iterateSet = __nested_webpack_require_184682__(8469);\n        var iterateSimple = __nested_webpack_require_184682__(507);\n        var Set1 = SetHelpers.Set;\n        var add = SetHelpers.add;\n        var has = SetHelpers.has;\n        // `Set.prototype.intersection` method\n        // https://tc39.es/ecma262/#sec-set.prototype.intersection\n        module.exports = function intersection(other) {\n            var O = aSet(this);\n            var otherRec = getSetRecord(other);\n            var result = new Set1();\n            if (size(O) > otherRec.size) {\n                iterateSimple(otherRec.getIterator(), function(e) {\n                    if (has(O, e)) add(result, e);\n                });\n            } else {\n                iterateSet(O, function(e) {\n                    if (otherRec.includes(e)) add(result, e);\n                });\n            }\n            return result;\n        };\n    /***/ },\n    /***/ 8773: /***/ (__unused_webpack_module, exports)=>{\n        var $propertyIsEnumerable = {}.propertyIsEnumerable;\n        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        // Nashorn ~ JDK8 bug\n        var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({\n            1: 2\n        }, 1);\n        // `Object.prototype.propertyIsEnumerable` method implementation\n        // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\n        exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n            var descriptor = getOwnPropertyDescriptor(this, V);\n            return !!descriptor && descriptor.enumerable;\n        } : $propertyIsEnumerable;\n    /***/ },\n    /***/ 8981: /***/ (module, __unused_webpack_exports, __nested_webpack_require_186662__)=>{\n        var requireObjectCoercible = __nested_webpack_require_186662__(7750);\n        var $Object = Object;\n        // `ToObject` abstract operation\n        // https://tc39.es/ecma262/#sec-toobject\n        module.exports = function(argument) {\n            return $Object(requireObjectCoercible(argument));\n        };\n    /***/ },\n    /***/ 9039: /***/ (module)=>{\n        module.exports = function(exec) {\n            try {\n                return !!exec();\n            } catch (error) {\n                return true;\n            }\n        };\n    /***/ },\n    /***/ 9143: /***/ (module, __unused_webpack_exports, __nested_webpack_require_187283__)=>{\n        var globalThis1 = __nested_webpack_require_187283__(4576);\n        var uncurryThis = __nested_webpack_require_187283__(9504);\n        var anObjectOrUndefined = __nested_webpack_require_187283__(3972);\n        var aString = __nested_webpack_require_187283__(3463);\n        var hasOwn = __nested_webpack_require_187283__(9297);\n        var base64Map = __nested_webpack_require_187283__(2804);\n        var getAlphabetOption = __nested_webpack_require_187283__(944);\n        var notDetached = __nested_webpack_require_187283__(5169);\n        var base64Alphabet = base64Map.c2i;\n        var base64UrlAlphabet = base64Map.c2iUrl;\n        var SyntaxError1 = globalThis1.SyntaxError;\n        var TypeError1 = globalThis1.TypeError;\n        var at = uncurryThis(\"\".charAt);\n        var skipAsciiWhitespace = function(string, index) {\n            var length = string.length;\n            for(; index < length; index++){\n                var chr = at(string, index);\n                if (chr !== \" \" && chr !== \"\t\" && chr !== \"\\n\" && chr !== \"\\f\" && chr !== \"\\r\") break;\n            }\n            return index;\n        };\n        var decodeBase64Chunk = function(chunk, alphabet, throwOnExtraBits) {\n            var chunkLength = chunk.length;\n            if (chunkLength < 4) {\n                chunk += chunkLength === 2 ? \"AA\" : \"A\";\n            }\n            var triplet = (alphabet[at(chunk, 0)] << 18) + (alphabet[at(chunk, 1)] << 12) + (alphabet[at(chunk, 2)] << 6) + alphabet[at(chunk, 3)];\n            var chunkBytes = [\n                triplet >> 16 & 255,\n                triplet >> 8 & 255,\n                triplet & 255\n            ];\n            if (chunkLength === 2) {\n                if (throwOnExtraBits && chunkBytes[1] !== 0) {\n                    throw new SyntaxError1(\"Extra bits\");\n                }\n                return [\n                    chunkBytes[0]\n                ];\n            }\n            if (chunkLength === 3) {\n                if (throwOnExtraBits && chunkBytes[2] !== 0) {\n                    throw new SyntaxError1(\"Extra bits\");\n                }\n                return [\n                    chunkBytes[0],\n                    chunkBytes[1]\n                ];\n            }\n            return chunkBytes;\n        };\n        var writeBytes = function(bytes, elements, written) {\n            var elementsLength = elements.length;\n            for(var index = 0; index < elementsLength; index++){\n                bytes[written + index] = elements[index];\n            }\n            return written + elementsLength;\n        };\n        /* eslint-disable max-statements, max-depth -- TODO */ module.exports = function(string, options, into, maxLength) {\n            aString(string);\n            anObjectOrUndefined(options);\n            var alphabet = getAlphabetOption(options) === \"base64\" ? base64Alphabet : base64UrlAlphabet;\n            var lastChunkHandling = options ? options.lastChunkHandling : undefined;\n            if (lastChunkHandling === undefined) lastChunkHandling = \"loose\";\n            if (lastChunkHandling !== \"loose\" && lastChunkHandling !== \"strict\" && lastChunkHandling !== \"stop-before-partial\") {\n                throw new TypeError1(\"Incorrect `lastChunkHandling` option\");\n            }\n            if (into) notDetached(into.buffer);\n            var stringLength = string.length;\n            var bytes = into || [];\n            var written = 0;\n            var read = 0;\n            var chunk = \"\";\n            var index = 0;\n            if (maxLength) while(true){\n                index = skipAsciiWhitespace(string, index);\n                if (index === stringLength) {\n                    if (chunk.length > 0) {\n                        if (lastChunkHandling === \"stop-before-partial\") {\n                            break;\n                        }\n                        if (lastChunkHandling === \"loose\") {\n                            if (chunk.length === 1) {\n                                throw new SyntaxError1(\"Malformed padding: exactly one additional character\");\n                            }\n                            written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);\n                        } else {\n                            throw new SyntaxError1(\"Missing padding\");\n                        }\n                    }\n                    read = stringLength;\n                    break;\n                }\n                var chr = at(string, index);\n                ++index;\n                if (chr === \"=\") {\n                    if (chunk.length < 2) {\n                        throw new SyntaxError1(\"Padding is too early\");\n                    }\n                    index = skipAsciiWhitespace(string, index);\n                    if (chunk.length === 2) {\n                        if (index === stringLength) {\n                            if (lastChunkHandling === \"stop-before-partial\") {\n                                break;\n                            }\n                            throw new SyntaxError1(\"Malformed padding: only one =\");\n                        }\n                        if (at(string, index) === \"=\") {\n                            ++index;\n                            index = skipAsciiWhitespace(string, index);\n                        }\n                    }\n                    if (index < stringLength) {\n                        throw new SyntaxError1(\"Unexpected character after padding\");\n                    }\n                    written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, lastChunkHandling === \"strict\"), written);\n                    read = stringLength;\n                    break;\n                }\n                if (!hasOwn(alphabet, chr)) {\n                    throw new SyntaxError1(\"Unexpected character\");\n                }\n                var remainingBytes = maxLength - written;\n                if (remainingBytes === 1 && chunk.length === 2 || remainingBytes === 2 && chunk.length === 3) {\n                    break;\n                }\n                chunk += chr;\n                if (chunk.length === 4) {\n                    written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);\n                    chunk = \"\";\n                    read = index;\n                    if (written === maxLength) {\n                        break;\n                    }\n                }\n            }\n            return {\n                bytes: bytes,\n                read: read,\n                written: written\n            };\n        };\n    /***/ },\n    /***/ 9286: /***/ (module, __unused_webpack_exports, __nested_webpack_require_193785__)=>{\n        var SetHelpers = __nested_webpack_require_193785__(4402);\n        var iterate = __nested_webpack_require_193785__(8469);\n        var Set1 = SetHelpers.Set;\n        var add = SetHelpers.add;\n        module.exports = function(set) {\n            var result = new Set1();\n            iterate(set, function(it) {\n                add(result, it);\n            });\n            return result;\n        };\n    /***/ },\n    /***/ 9297: /***/ (module, __unused_webpack_exports, __nested_webpack_require_194254__)=>{\n        var uncurryThis = __nested_webpack_require_194254__(9504);\n        var toObject = __nested_webpack_require_194254__(8981);\n        var hasOwnProperty = uncurryThis({}.hasOwnProperty);\n        // `HasOwnProperty` abstract operation\n        // https://tc39.es/ecma262/#sec-hasownproperty\n        // eslint-disable-next-line es/no-object-hasown -- safe\n        module.exports = Object.hasOwn || function hasOwn(it, key) {\n            return hasOwnProperty(toObject(it), key);\n        };\n    /***/ },\n    /***/ 9306: /***/ (module, __unused_webpack_exports, __nested_webpack_require_194812__)=>{\n        var isCallable = __nested_webpack_require_194812__(4901);\n        var tryToString = __nested_webpack_require_194812__(6823);\n        var $TypeError = TypeError;\n        // `Assert: IsCallable(argument) is true`\n        module.exports = function(argument) {\n            if (isCallable(argument)) return argument;\n            throw new $TypeError(tryToString(argument) + \" is not a function\");\n        };\n    /***/ },\n    /***/ 9314: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_195306__)=>{\n        var $ = __nested_webpack_require_195306__(6518);\n        var call = __nested_webpack_require_195306__(9565);\n        var anObject = __nested_webpack_require_195306__(8551);\n        var getIteratorDirect = __nested_webpack_require_195306__(1767);\n        var notANaN = __nested_webpack_require_195306__(4149);\n        var toPositiveInteger = __nested_webpack_require_195306__(9590);\n        var iteratorClose = __nested_webpack_require_195306__(9539);\n        var createIteratorProxy = __nested_webpack_require_195306__(9462);\n        var iteratorHelperThrowsOnInvalidIterator = __nested_webpack_require_195306__(684);\n        var iteratorHelperWithoutClosingOnEarlyError = __nested_webpack_require_195306__(4549);\n        var IS_PURE = __nested_webpack_require_195306__(6395);\n        var DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator(\"drop\", 0);\n        var dropWithoutClosingOnEarlyError = !IS_PURE && !DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError(\"drop\", RangeError);\n        var FORCED = IS_PURE || DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR || dropWithoutClosingOnEarlyError;\n        var IteratorProxy = createIteratorProxy(function() {\n            var iterator = this.iterator;\n            var next = this.next;\n            var result, done;\n            while(this.remaining){\n                this.remaining--;\n                result = anObject(call(next, iterator));\n                done = this.done = !!result.done;\n                if (done) return;\n            }\n            result = anObject(call(next, iterator));\n            done = this.done = !!result.done;\n            if (!done) return result.value;\n        });\n        // `Iterator.prototype.drop` method\n        // https://tc39.es/ecma262/#sec-iterator.prototype.drop\n        $({\n            target: \"Iterator\",\n            proto: true,\n            real: true,\n            forced: FORCED\n        }, {\n            drop: function drop(limit) {\n                anObject(this);\n                var remaining;\n                try {\n                    remaining = toPositiveInteger(notANaN(+limit));\n                } catch (error) {\n                    iteratorClose(this, \"throw\", error);\n                }\n                if (dropWithoutClosingOnEarlyError) return call(dropWithoutClosingOnEarlyError, this, remaining);\n                return new IteratorProxy(getIteratorDirect(this), {\n                    remaining: remaining\n                });\n            }\n        });\n    /***/ },\n    /***/ 9429: /***/ (module, __unused_webpack_exports, __nested_webpack_require_197783__)=>{\n        var globalThis1 = __nested_webpack_require_197783__(4576);\n        var IS_NODE = __nested_webpack_require_197783__(6193);\n        module.exports = function(name) {\n            if (IS_NODE) {\n                try {\n                    return globalThis1.process.getBuiltinModule(name);\n                } catch (error) {}\n                try {\n                    // eslint-disable-next-line no-new-func -- safe\n                    return Function('return require(\"' + name + '\")')();\n                } catch (error) {}\n            }\n        };\n    /***/ },\n    /***/ 9432: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_198416__)=>{\n        // TODO: Remove from `core-js@4`\n        __nested_webpack_require_198416__(5213);\n    /***/ },\n    /***/ 9433: /***/ (module, __unused_webpack_exports, __nested_webpack_require_198586__)=>{\n        var globalThis1 = __nested_webpack_require_198586__(4576);\n        // eslint-disable-next-line es/no-object-defineproperty -- safe\n        var defineProperty = Object.defineProperty;\n        module.exports = function(key, value) {\n            try {\n                defineProperty(globalThis1, key, {\n                    value: value,\n                    configurable: true,\n                    writable: true\n                });\n            } catch (error) {\n                globalThis1[key] = value;\n            }\n            return value;\n        };\n    /***/ },\n    /***/ 9462: /***/ (module, __unused_webpack_exports, __nested_webpack_require_199226__)=>{\n        var call = __nested_webpack_require_199226__(9565);\n        var create = __nested_webpack_require_199226__(2360);\n        var createNonEnumerableProperty = __nested_webpack_require_199226__(6699);\n        var defineBuiltIns = __nested_webpack_require_199226__(6279);\n        var wellKnownSymbol = __nested_webpack_require_199226__(8227);\n        var InternalStateModule = __nested_webpack_require_199226__(1181);\n        var getMethod = __nested_webpack_require_199226__(5966);\n        var IteratorPrototype = __nested_webpack_require_199226__(7657).IteratorPrototype;\n        var createIterResultObject = __nested_webpack_require_199226__(2529);\n        var iteratorClose = __nested_webpack_require_199226__(9539);\n        var iteratorCloseAll = __nested_webpack_require_199226__(1385);\n        var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n        var ITERATOR_HELPER = \"IteratorHelper\";\n        var WRAP_FOR_VALID_ITERATOR = \"WrapForValidIterator\";\n        var NORMAL = \"normal\";\n        var THROW = \"throw\";\n        var setInternalState = InternalStateModule.set;\n        var createIteratorProxyPrototype = function(IS_ITERATOR) {\n            var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);\n            return defineBuiltIns(create(IteratorPrototype), {\n                next: function next() {\n                    var state = getInternalState(this);\n                    // for simplification:\n                    //   for `%WrapForValidIteratorPrototype%.next` or with `state.returnHandlerResult` our `nextHandler` returns `IterResultObject`\n                    //   for `%IteratorHelperPrototype%.next` - just a value\n                    if (IS_ITERATOR) return state.nextHandler();\n                    if (state.done) return createIterResultObject(undefined, true);\n                    try {\n                        var result = state.nextHandler();\n                        return state.returnHandlerResult ? result : createIterResultObject(result, state.done);\n                    } catch (error) {\n                        state.done = true;\n                        throw error;\n                    }\n                },\n                \"return\": function() {\n                    var state = getInternalState(this);\n                    var iterator = state.iterator;\n                    state.done = true;\n                    if (IS_ITERATOR) {\n                        var returnMethod = getMethod(iterator, \"return\");\n                        return returnMethod ? call(returnMethod, iterator) : createIterResultObject(undefined, true);\n                    }\n                    if (state.inner) try {\n                        iteratorClose(state.inner.iterator, NORMAL);\n                    } catch (error) {\n                        return iteratorClose(iterator, THROW, error);\n                    }\n                    if (state.openIters) try {\n                        iteratorCloseAll(state.openIters, NORMAL);\n                    } catch (error) {\n                        return iteratorClose(iterator, THROW, error);\n                    }\n                    if (iterator) iteratorClose(iterator, NORMAL);\n                    return createIterResultObject(undefined, true);\n                }\n            });\n        };\n        var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);\n        var IteratorHelperPrototype = createIteratorProxyPrototype(false);\n        createNonEnumerableProperty(IteratorHelperPrototype, TO_STRING_TAG, \"Iterator Helper\");\n        module.exports = function(nextHandler, IS_ITERATOR, RETURN_HANDLER_RESULT) {\n            var IteratorProxy = function Iterator1(record, state) {\n                if (state) {\n                    state.iterator = record.iterator;\n                    state.next = record.next;\n                } else state = record;\n                state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;\n                state.returnHandlerResult = !!RETURN_HANDLER_RESULT;\n                state.nextHandler = nextHandler;\n                state.counter = 0;\n                state.done = false;\n                setInternalState(this, state);\n            };\n            IteratorProxy.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;\n            return IteratorProxy;\n        };\n    /***/ },\n    /***/ 9486: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_203554__)=>{\n        var $ = __nested_webpack_require_203554__(6518);\n        var globalThis1 = __nested_webpack_require_203554__(4576);\n        var uncurryThis = __nested_webpack_require_203554__(9504);\n        var anObjectOrUndefined = __nested_webpack_require_203554__(3972);\n        var anUint8Array = __nested_webpack_require_203554__(4154);\n        var notDetached = __nested_webpack_require_203554__(5169);\n        var base64Map = __nested_webpack_require_203554__(2804);\n        var getAlphabetOption = __nested_webpack_require_203554__(944);\n        var base64Alphabet = base64Map.i2c;\n        var base64UrlAlphabet = base64Map.i2cUrl;\n        var charAt = uncurryThis(\"\".charAt);\n        var Uint8Array1 = globalThis1.Uint8Array;\n        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array1 || !Uint8Array1.prototype.toBase64 || !function() {\n            try {\n                var target = new Uint8Array1();\n                target.toBase64(null);\n            } catch (error) {\n                return true;\n            }\n        }();\n        // `Uint8Array.prototype.toBase64` method\n        // https://github.com/tc39/proposal-arraybuffer-base64\n        if (Uint8Array1) $({\n            target: \"Uint8Array\",\n            proto: true,\n            forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS\n        }, {\n            toBase64: function toBase64() {\n                var array = anUint8Array(this);\n                var options = arguments.length ? anObjectOrUndefined(arguments[0]) : undefined;\n                var alphabet = getAlphabetOption(options) === \"base64\" ? base64Alphabet : base64UrlAlphabet;\n                var omitPadding = !!options && !!options.omitPadding;\n                notDetached(this.buffer);\n                var result = \"\";\n                var i = 0;\n                var length = array.length;\n                var triplet;\n                var at = function(shift) {\n                    return charAt(alphabet, triplet >> 6 * shift & 63);\n                };\n                for(; i + 2 < length; i += 3){\n                    triplet = (array[i] << 16) + (array[i + 1] << 8) + array[i + 2];\n                    result += at(3) + at(2) + at(1) + at(0);\n                }\n                if (i + 2 === length) {\n                    triplet = (array[i] << 16) + (array[i + 1] << 8);\n                    result += at(3) + at(2) + at(1) + (omitPadding ? \"\" : \"=\");\n                } else if (i + 1 === length) {\n                    triplet = array[i] << 16;\n                    result += at(3) + at(2) + (omitPadding ? \"\" : \"==\");\n                }\n                return result;\n            }\n        });\n    /***/ },\n    /***/ 9504: /***/ (module, __unused_webpack_exports, __nested_webpack_require_206156__)=>{\n        var NATIVE_BIND = __nested_webpack_require_206156__(616);\n        var FunctionPrototype = Function.prototype;\n        var call = FunctionPrototype.call;\n        // eslint-disable-next-line es/no-function-prototype-bind -- safe\n        var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);\n        module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {\n            return function() {\n                return call.apply(fn, arguments);\n            };\n        };\n    /***/ },\n    /***/ 9519: /***/ (module, __unused_webpack_exports, __nested_webpack_require_206745__)=>{\n        var globalThis1 = __nested_webpack_require_206745__(4576);\n        var userAgent = __nested_webpack_require_206745__(2839);\n        var process1 = globalThis1.process;\n        var Deno1 = globalThis1.Deno;\n        var versions = process1 && process1.versions || Deno1 && Deno1.version;\n        var v8 = versions && versions.v8;\n        var match, version;\n        if (v8) {\n            match = v8.split(\".\");\n            // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n            // but their correct versions are not interesting for us\n            version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n        }\n        // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n        // so check `userAgent` even if `.v8` exists, but 0\n        if (!version && userAgent) {\n            match = userAgent.match(/Edge\\/(\\d+)/);\n            if (!match || match[1] >= 74) {\n                match = userAgent.match(/Chrome\\/(\\d+)/);\n                if (match) version = +match[1];\n            }\n        }\n        module.exports = version;\n    /***/ },\n    /***/ 9539: /***/ (module, __unused_webpack_exports, __nested_webpack_require_207891__)=>{\n        var call = __nested_webpack_require_207891__(9565);\n        var anObject = __nested_webpack_require_207891__(8551);\n        var getMethod = __nested_webpack_require_207891__(5966);\n        module.exports = function(iterator, kind, value) {\n            var innerResult, innerError;\n            anObject(iterator);\n            try {\n                innerResult = getMethod(iterator, \"return\");\n                if (!innerResult) {\n                    if (kind === \"throw\") throw value;\n                    return value;\n                }\n                innerResult = call(innerResult, iterator);\n            } catch (error) {\n                innerError = true;\n                innerResult = error;\n            }\n            if (kind === \"throw\") throw value;\n            if (innerError) throw innerResult;\n            anObject(innerResult);\n            return value;\n        };\n    /***/ },\n    /***/ 9565: /***/ (module, __unused_webpack_exports, __nested_webpack_require_208827__)=>{\n        var NATIVE_BIND = __nested_webpack_require_208827__(616);\n        var call = Function.prototype.call;\n        // eslint-disable-next-line es/no-function-prototype-bind -- safe\n        module.exports = NATIVE_BIND ? call.bind(call) : function() {\n            return call.apply(call, arguments);\n        };\n    /***/ },\n    /***/ 9577: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_209237__)=>{\n        var arrayWith = __nested_webpack_require_209237__(9928);\n        var ArrayBufferViewCore = __nested_webpack_require_209237__(4644);\n        var isBigIntArray = __nested_webpack_require_209237__(1108);\n        var toIntegerOrInfinity = __nested_webpack_require_209237__(1291);\n        var toBigInt = __nested_webpack_require_209237__(5854);\n        var aTypedArray = ArrayBufferViewCore.aTypedArray;\n        var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;\n        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n        var PROPER_ORDER = function() {\n            try {\n                // eslint-disable-next-line no-throw-literal, es/no-typed-arrays, es/no-array-prototype-with -- required for testing\n                new Int8Array(1)[\"with\"](2, {\n                    valueOf: function() {\n                        throw 8;\n                    }\n                });\n            } catch (error) {\n                // some early implementations, like WebKit, does not follow the final semantic\n                // https://github.com/tc39/proposal-change-array-by-copy/pull/86\n                return error === 8;\n            }\n        }();\n        // Bug in WebKit. It should truncate a negative fractional index to zero, but instead throws an error\n        var THROW_ON_NEGATIVE_FRACTIONAL_INDEX = PROPER_ORDER && function() {\n            try {\n                // eslint-disable-next-line es/no-typed-arrays, es/no-array-prototype-with -- required for testing\n                new Int8Array(1)[\"with\"](-0.5, 1);\n            } catch (error) {\n                return true;\n            }\n        }();\n        // `%TypedArray%.prototype.with` method\n        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.with\n        exportTypedArrayMethod(\"with\", {\n            \"with\": function(index, value) {\n                var O = aTypedArray(this);\n                var relativeIndex = toIntegerOrInfinity(index);\n                var actualValue = isBigIntArray(O) ? toBigInt(value) : +value;\n                return arrayWith(O, getTypedArrayConstructor(O), relativeIndex, actualValue);\n            }\n        }[\"with\"], !PROPER_ORDER || THROW_ON_NEGATIVE_FRACTIONAL_INDEX);\n    /***/ },\n    /***/ 9590: /***/ (module, __unused_webpack_exports, __nested_webpack_require_211484__)=>{\n        var toIntegerOrInfinity = __nested_webpack_require_211484__(1291);\n        var $RangeError = RangeError;\n        module.exports = function(it) {\n            var result = toIntegerOrInfinity(it);\n            if (result < 0) throw new $RangeError(\"The argument can't be less than 0\");\n            return result;\n        };\n    /***/ },\n    /***/ 9617: /***/ (module, __unused_webpack_exports, __nested_webpack_require_211893__)=>{\n        var toIndexedObject = __nested_webpack_require_211893__(5397);\n        var toAbsoluteIndex = __nested_webpack_require_211893__(5610);\n        var lengthOfArrayLike = __nested_webpack_require_211893__(6198);\n        // `Array.prototype.{ indexOf, includes }` methods implementation\n        var createMethod = function(IS_INCLUDES) {\n            return function($this, el, fromIndex) {\n                var O = toIndexedObject($this);\n                var length = lengthOfArrayLike(O);\n                if (length === 0) return !IS_INCLUDES && -1;\n                var index = toAbsoluteIndex(fromIndex, length);\n                var value;\n                // Array#includes uses SameValueZero equality algorithm\n                // eslint-disable-next-line no-self-compare -- NaN check\n                if (IS_INCLUDES && el !== el) while(length > index){\n                    value = O[index++];\n                    // eslint-disable-next-line no-self-compare -- NaN check\n                    if (value !== value) return true;\n                // Array#indexOf ignores holes, Array#includes - not\n                }\n                else for(; length > index; index++){\n                    if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n                }\n                return !IS_INCLUDES && -1;\n            };\n        };\n        module.exports = {\n            // `Array.prototype.includes` method\n            // https://tc39.es/ecma262/#sec-array.prototype.includes\n            includes: createMethod(true),\n            // `Array.prototype.indexOf` method\n            // https://tc39.es/ecma262/#sec-array.prototype.indexof\n            indexOf: createMethod(false)\n        };\n    /***/ },\n    /***/ 9631: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_213678__)=>{\n        // TODO: Remove from `core-js@4`\n        __nested_webpack_require_213678__(9486);\n    /***/ },\n    /***/ 9797: /***/ (__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_213865__)=>{\n        // TODO: Remove from `core-js@4`\n        __nested_webpack_require_213865__(4226);\n    /***/ },\n    /***/ 9835: /***/ (module)=>{\n        // Should get iterator record of a set-like object before cloning this\n        // https://bugs.webkit.org/show_bug.cgi?id=289430\n        module.exports = function(METHOD_NAME) {\n            try {\n                // eslint-disable-next-line es/no-set -- needed for test\n                var baseSet = new Set();\n                var setLike = {\n                    size: 0,\n                    has: function() {\n                        return true;\n                    },\n                    keys: function() {\n                        // eslint-disable-next-line es/no-object-defineproperty -- needed for test\n                        return Object.defineProperty({}, \"next\", {\n                            get: function() {\n                                baseSet.clear();\n                                baseSet.add(4);\n                                return function() {\n                                    return {\n                                        done: true\n                                    };\n                                };\n                            }\n                        });\n                    }\n                };\n                var result = baseSet[METHOD_NAME](setLike);\n                return result.size === 1 && result.values().next().value === 4;\n            } catch (error) {\n                return false;\n            }\n        };\n    /***/ },\n    /***/ 9928: /***/ (module, __unused_webpack_exports, __nested_webpack_require_215453__)=>{\n        var lengthOfArrayLike = __nested_webpack_require_215453__(6198);\n        var toIntegerOrInfinity = __nested_webpack_require_215453__(1291);\n        var $RangeError = RangeError;\n        // https://tc39.es/ecma262/#sec-array.prototype.with\n        // https://tc39.es/ecma262/#sec-%typedarray%.prototype.with\n        module.exports = function(O, C, index, value) {\n            var len = lengthOfArrayLike(O);\n            var relativeIndex = toIntegerOrInfinity(index);\n            var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;\n            if (actualIndex >= len || actualIndex < 0) throw new $RangeError(\"Incorrect index\");\n            var A = new C(len);\n            var k = 0;\n            for(; k < len; k++)A[k] = k === actualIndex ? value : O[k];\n            return A;\n        };\n    /***/ }\n};\n/************************************************************************/ /******/ // The module cache\n/******/ var __webpack_module_cache__ = {};\n/******/ /******/ // The require function\n/******/ function __nested_webpack_require_216482__(moduleId) {\n    /******/ // Check if module is in cache\n    /******/ var cachedModule = __webpack_module_cache__[moduleId];\n    /******/ if (cachedModule !== undefined) {\n        /******/ return cachedModule.exports;\n    /******/ }\n    /******/ // Create a new module (and put it into the cache)\n    /******/ var module = __webpack_module_cache__[moduleId] = {\n        /******/ // no module.id needed\n        /******/ // no module.loaded needed\n        /******/ exports: {}\n    };\n    /******/ /******/ // Execute the module function\n    /******/ __webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_216482__);\n    /******/ /******/ // Return the exports of the module\n    /******/ return module.exports;\n/******/ }\n/******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{\n    /******/ // define getter functions for harmony exports\n    /******/ __nested_webpack_require_216482__.d = (exports, definition)=>{\n        /******/ for(var key in definition){\n            /******/ if (__nested_webpack_require_216482__.o(definition, key) && !__nested_webpack_require_216482__.o(exports, key)) {\n                /******/ Object.defineProperty(exports, key, {\n                    enumerable: true,\n                    get: definition[key]\n                });\n            /******/ }\n        /******/ }\n    /******/ };\n/******/ })();\n/******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{\n    /******/ __nested_webpack_require_216482__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n/******/ })();\n/******/ /************************************************************************/ var __webpack_exports__ = {};\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js\nvar es_array_push = __nested_webpack_require_216482__(4114);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array-buffer.detached.js\nvar es_array_buffer_detached = __nested_webpack_require_216482__(6573);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array-buffer.transfer.js\nvar es_array_buffer_transfer = __nested_webpack_require_216482__(8100);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array-buffer.transfer-to-fixed-length.js\nvar es_array_buffer_transfer_to_fixed_length = __nested_webpack_require_216482__(7936);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.constructor.js\nvar es_iterator_constructor = __nested_webpack_require_216482__(8111);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.reduce.js\nvar es_iterator_reduce = __nested_webpack_require_216482__(8237);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.promise.try.js\nvar es_promise_try = __nested_webpack_require_216482__(1689);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.with.js\nvar es_typed_array_with = __nested_webpack_require_216482__(9577);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.math.sum-precise.js\nvar esnext_math_sum_precise = __nested_webpack_require_216482__(4235);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.uint8-array.from-base64.js\nvar esnext_uint8_array_from_base64 = __nested_webpack_require_216482__(9432);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.uint8-array.set-from-base64.js\nvar esnext_uint8_array_set_from_base64 = __nested_webpack_require_216482__(1549);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.uint8-array.set-from-hex.js\nvar esnext_uint8_array_set_from_hex = __nested_webpack_require_216482__(9797);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.uint8-array.to-base64.js\nvar esnext_uint8_array_to_base64 = __nested_webpack_require_216482__(9631);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.uint8-array.to-hex.js\nvar esnext_uint8_array_to_hex = __nested_webpack_require_216482__(5623);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-exception.stack.js\nvar web_dom_exception_stack = __nested_webpack_require_216482__(4979);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url.parse.js\nvar web_url_parse = __nested_webpack_require_216482__(5781);\n; // ./src/shared/util.js\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nconst FONT_IDENTITY_MATRIX = [\n    0.001,\n    0,\n    0,\n    0.001,\n    0,\n    0\n];\nconst LINE_FACTOR = 1.35;\nconst LINE_DESCENT_FACTOR = 0.35;\nconst BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\nconst RenderingIntentFlag = {\n    ANY: 0x01,\n    DISPLAY: 0x02,\n    PRINT: 0x04,\n    SAVE: 0x08,\n    ANNOTATIONS_FORMS: 0x10,\n    ANNOTATIONS_STORAGE: 0x20,\n    ANNOTATIONS_DISABLE: 0x40,\n    IS_EDITING: 0x80,\n    OPLIST: 0x100\n};\nconst AnnotationMode = {\n    DISABLE: 0,\n    ENABLE: 1,\n    ENABLE_FORMS: 2,\n    ENABLE_STORAGE: 3\n};\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nconst AnnotationEditorType = {\n    DISABLE: -1,\n    NONE: 0,\n    FREETEXT: 3,\n    HIGHLIGHT: 9,\n    STAMP: 13,\n    INK: 15,\n    POPUP: 16,\n    SIGNATURE: 101,\n    COMMENT: 102\n};\nconst AnnotationEditorParamsType = {\n    RESIZE: 1,\n    CREATE: 2,\n    FREETEXT_SIZE: 11,\n    FREETEXT_COLOR: 12,\n    FREETEXT_OPACITY: 13,\n    INK_COLOR: 21,\n    INK_THICKNESS: 22,\n    INK_OPACITY: 23,\n    HIGHLIGHT_COLOR: 31,\n    HIGHLIGHT_THICKNESS: 32,\n    HIGHLIGHT_FREE: 33,\n    HIGHLIGHT_SHOW_ALL: 34,\n    DRAW_STEP: 41\n};\nconst PermissionFlag = {\n    PRINT: 0x04,\n    MODIFY_CONTENTS: 0x08,\n    COPY: 0x10,\n    MODIFY_ANNOTATIONS: 0x20,\n    FILL_INTERACTIVE_FORMS: 0x100,\n    COPY_FOR_ACCESSIBILITY: 0x200,\n    ASSEMBLE: 0x400,\n    PRINT_HIGH_QUALITY: 0x800\n};\nconst TextRenderingMode = {\n    FILL: 0,\n    STROKE: 1,\n    FILL_STROKE: 2,\n    INVISIBLE: 3,\n    FILL_ADD_TO_PATH: 4,\n    STROKE_ADD_TO_PATH: 5,\n    FILL_STROKE_ADD_TO_PATH: 6,\n    ADD_TO_PATH: 7,\n    FILL_STROKE_MASK: 3,\n    ADD_TO_PATH_FLAG: 4\n};\nconst util_ImageKind = {\n    GRAYSCALE_1BPP: 1,\n    RGB_24BPP: 2,\n    RGBA_32BPP: 3\n};\nconst AnnotationType = {\n    TEXT: 1,\n    LINK: 2,\n    FREETEXT: 3,\n    LINE: 4,\n    SQUARE: 5,\n    CIRCLE: 6,\n    POLYGON: 7,\n    POLYLINE: 8,\n    HIGHLIGHT: 9,\n    UNDERLINE: 10,\n    SQUIGGLY: 11,\n    STRIKEOUT: 12,\n    STAMP: 13,\n    CARET: 14,\n    INK: 15,\n    POPUP: 16,\n    FILEATTACHMENT: 17,\n    SOUND: 18,\n    MOVIE: 19,\n    WIDGET: 20,\n    SCREEN: 21,\n    PRINTERMARK: 22,\n    TRAPNET: 23,\n    WATERMARK: 24,\n    THREED: 25,\n    REDACT: 26\n};\nconst AnnotationReplyType = {\n    GROUP: \"Group\",\n    REPLY: \"R\"\n};\nconst AnnotationFlag = {\n    INVISIBLE: 0x01,\n    HIDDEN: 0x02,\n    PRINT: 0x04,\n    NOZOOM: 0x08,\n    NOROTATE: 0x10,\n    NOVIEW: 0x20,\n    READONLY: 0x40,\n    LOCKED: 0x80,\n    TOGGLENOVIEW: 0x100,\n    LOCKEDCONTENTS: 0x200\n};\nconst AnnotationFieldFlag = {\n    READONLY: 0x0000001,\n    REQUIRED: 0x0000002,\n    NOEXPORT: 0x0000004,\n    MULTILINE: 0x0001000,\n    PASSWORD: 0x0002000,\n    NOTOGGLETOOFF: 0x0004000,\n    RADIO: 0x0008000,\n    PUSHBUTTON: 0x0010000,\n    COMBO: 0x0020000,\n    EDIT: 0x0040000,\n    SORT: 0x0080000,\n    FILESELECT: 0x0100000,\n    MULTISELECT: 0x0200000,\n    DONOTSPELLCHECK: 0x0400000,\n    DONOTSCROLL: 0x0800000,\n    COMB: 0x1000000,\n    RICHTEXT: 0x2000000,\n    RADIOSINUNISON: 0x2000000,\n    COMMITONSELCHANGE: 0x4000000\n};\nconst AnnotationBorderStyleType = {\n    SOLID: 1,\n    DASHED: 2,\n    BEVELED: 3,\n    INSET: 4,\n    UNDERLINE: 5\n};\nconst AnnotationActionEventType = {\n    E: \"Mouse Enter\",\n    X: \"Mouse Exit\",\n    D: \"Mouse Down\",\n    U: \"Mouse Up\",\n    Fo: \"Focus\",\n    Bl: \"Blur\",\n    PO: \"PageOpen\",\n    PC: \"PageClose\",\n    PV: \"PageVisible\",\n    PI: \"PageInvisible\",\n    K: \"Keystroke\",\n    F: \"Format\",\n    V: \"Validate\",\n    C: \"Calculate\"\n};\nconst DocumentActionEventType = {\n    WC: \"WillClose\",\n    WS: \"WillSave\",\n    DS: \"DidSave\",\n    WP: \"WillPrint\",\n    DP: \"DidPrint\"\n};\nconst PageActionEventType = {\n    O: \"PageOpen\",\n    C: \"PageClose\"\n};\nconst VerbosityLevel = {\n    ERRORS: 0,\n    WARNINGS: 1,\n    INFOS: 5\n};\nconst OPS = {\n    dependency: 1,\n    setLineWidth: 2,\n    setLineCap: 3,\n    setLineJoin: 4,\n    setMiterLimit: 5,\n    setDash: 6,\n    setRenderingIntent: 7,\n    setFlatness: 8,\n    setGState: 9,\n    save: 10,\n    restore: 11,\n    transform: 12,\n    moveTo: 13,\n    lineTo: 14,\n    curveTo: 15,\n    curveTo2: 16,\n    curveTo3: 17,\n    closePath: 18,\n    rectangle: 19,\n    stroke: 20,\n    closeStroke: 21,\n    fill: 22,\n    eoFill: 23,\n    fillStroke: 24,\n    eoFillStroke: 25,\n    closeFillStroke: 26,\n    closeEOFillStroke: 27,\n    endPath: 28,\n    clip: 29,\n    eoClip: 30,\n    beginText: 31,\n    endText: 32,\n    setCharSpacing: 33,\n    setWordSpacing: 34,\n    setHScale: 35,\n    setLeading: 36,\n    setFont: 37,\n    setTextRenderingMode: 38,\n    setTextRise: 39,\n    moveText: 40,\n    setLeadingMoveText: 41,\n    setTextMatrix: 42,\n    nextLine: 43,\n    showText: 44,\n    showSpacedText: 45,\n    nextLineShowText: 46,\n    nextLineSetSpacingShowText: 47,\n    setCharWidth: 48,\n    setCharWidthAndBounds: 49,\n    setStrokeColorSpace: 50,\n    setFillColorSpace: 51,\n    setStrokeColor: 52,\n    setStrokeColorN: 53,\n    setFillColor: 54,\n    setFillColorN: 55,\n    setStrokeGray: 56,\n    setFillGray: 57,\n    setStrokeRGBColor: 58,\n    setFillRGBColor: 59,\n    setStrokeCMYKColor: 60,\n    setFillCMYKColor: 61,\n    shadingFill: 62,\n    beginInlineImage: 63,\n    beginImageData: 64,\n    endInlineImage: 65,\n    paintXObject: 66,\n    markPoint: 67,\n    markPointProps: 68,\n    beginMarkedContent: 69,\n    beginMarkedContentProps: 70,\n    endMarkedContent: 71,\n    beginCompat: 72,\n    endCompat: 73,\n    paintFormXObjectBegin: 74,\n    paintFormXObjectEnd: 75,\n    beginGroup: 76,\n    endGroup: 77,\n    beginAnnotation: 80,\n    endAnnotation: 81,\n    paintImageMaskXObject: 83,\n    paintImageMaskXObjectGroup: 84,\n    paintImageXObject: 85,\n    paintInlineImageXObject: 86,\n    paintInlineImageXObjectGroup: 87,\n    paintImageXObjectRepeat: 88,\n    paintImageMaskXObjectRepeat: 89,\n    paintSolidColorImageMask: 90,\n    constructPath: 91,\n    setStrokeTransparent: 92,\n    setFillTransparent: 93,\n    rawFillPath: 94\n};\nconst DrawOPS = {\n    moveTo: 0,\n    lineTo: 1,\n    curveTo: 2,\n    closePath: 3\n};\nconst PasswordResponses = {\n    NEED_PASSWORD: 1,\n    INCORRECT_PASSWORD: 2\n};\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n    if (Number.isInteger(level)) {\n        verbosity = level;\n    }\n}\nfunction getVerbosityLevel() {\n    return verbosity;\n}\nfunction info(msg) {\n    if (verbosity >= VerbosityLevel.INFOS) {\n        console.info(`Info: ${msg}`);\n    }\n}\nfunction warn(msg) {\n    if (verbosity >= VerbosityLevel.WARNINGS) {\n        console.warn(`Warning: ${msg}`);\n    }\n}\nfunction unreachable(msg) {\n    throw new Error(msg);\n}\nfunction assert(cond, msg) {\n    if (!cond) {\n        unreachable(msg);\n    }\n}\nfunction _isValidProtocol(url) {\n    switch(url?.protocol){\n        case \"http:\":\n        case \"https:\":\n        case \"ftp:\":\n        case \"mailto:\":\n        case \"tel:\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n    if (!url) {\n        return null;\n    }\n    if (options && typeof url === \"string\") {\n        if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n            const dots = url.match(/\\./g);\n            if (dots?.length >= 2) {\n                url = `http://${url}`;\n            }\n        }\n        if (options.tryConvertEncoding) {\n            try {\n                url = stringToUTF8String(url);\n            } catch  {}\n        }\n    }\n    const absoluteUrl = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n    return _isValidProtocol(absoluteUrl) ? absoluteUrl : null;\n}\nfunction updateUrlHash(url, hash, allowRel = false) {\n    const res = URL.parse(url);\n    if (res) {\n        res.hash = hash;\n        return res.href;\n    }\n    if (allowRel && createValidAbsoluteUrl(url, \"http://example.com\")) {\n        return url.split(\"#\", 1)[0] + `${hash ? `#${hash}` : \"\"}`;\n    }\n    return \"\";\n}\nfunction shadow(obj, prop, value, nonSerializable = false) {\n    Object.defineProperty(obj, prop, {\n        value,\n        enumerable: !nonSerializable,\n        configurable: true,\n        writable: false\n    });\n    return value;\n}\nconst BaseException = function BaseExceptionClosure() {\n    function BaseException(message, name) {\n        this.message = message;\n        this.name = name;\n    }\n    BaseException.prototype = new Error();\n    BaseException.constructor = BaseException;\n    return BaseException;\n}();\nclass PasswordException extends BaseException {\n    constructor(msg, code){\n        super(msg, \"PasswordException\");\n        this.code = code;\n    }\n}\nclass UnknownErrorException extends BaseException {\n    constructor(msg, details){\n        super(msg, \"UnknownErrorException\");\n        this.details = details;\n    }\n}\nclass InvalidPDFException extends BaseException {\n    constructor(msg){\n        super(msg, \"InvalidPDFException\");\n    }\n}\nclass ResponseException extends BaseException {\n    constructor(msg, status, missing){\n        super(msg, \"ResponseException\");\n        this.status = status;\n        this.missing = missing;\n    }\n}\nclass FormatError extends BaseException {\n    constructor(msg){\n        super(msg, \"FormatError\");\n    }\n}\nclass AbortException extends BaseException {\n    constructor(msg){\n        super(msg, \"AbortException\");\n    }\n}\nfunction bytesToString(bytes) {\n    if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n        unreachable(\"Invalid argument for bytesToString\");\n    }\n    const length = bytes.length;\n    const MAX_ARGUMENT_COUNT = 8192;\n    if (length < MAX_ARGUMENT_COUNT) {\n        return String.fromCharCode.apply(null, bytes);\n    }\n    const strBuf = [];\n    for(let i = 0; i < length; i += MAX_ARGUMENT_COUNT){\n        const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n        const chunk = bytes.subarray(i, chunkEnd);\n        strBuf.push(String.fromCharCode.apply(null, chunk));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n    if (typeof str !== \"string\") {\n        unreachable(\"Invalid argument for stringToBytes\");\n    }\n    const length = str.length;\n    const bytes = new Uint8Array(length);\n    for(let i = 0; i < length; ++i){\n        bytes[i] = str.charCodeAt(i) & 0xff;\n    }\n    return bytes;\n}\nfunction string32(value) {\n    return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\nfunction objectSize(obj) {\n    return Object.keys(obj).length;\n}\nfunction isLittleEndian() {\n    const buffer8 = new Uint8Array(4);\n    buffer8[0] = 1;\n    const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n    return view32[0] === 1;\n}\nfunction isEvalSupported() {\n    try {\n        new Function(\"\");\n        return true;\n    } catch  {\n        return false;\n    }\n}\nclass util_FeatureTest {\n    static get isLittleEndian() {\n        return shadow(this, \"isLittleEndian\", isLittleEndian());\n    }\n    static get isEvalSupported() {\n        return shadow(this, \"isEvalSupported\", isEvalSupported());\n    }\n    static get isOffscreenCanvasSupported() {\n        return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n    }\n    static get isImageDecoderSupported() {\n        return shadow(this, \"isImageDecoderSupported\", typeof ImageDecoder !== \"undefined\");\n    }\n    static get platform() {\n        const { platform, userAgent } = navigator;\n        return shadow(this, \"platform\", {\n            isAndroid: userAgent.includes(\"Android\"),\n            isLinux: platform.includes(\"Linux\"),\n            isMac: platform.includes(\"Mac\"),\n            isWindows: platform.includes(\"Win\"),\n            isFirefox: userAgent.includes(\"Firefox\")\n        });\n    }\n    static get isCSSRoundSupported() {\n        return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n    }\n}\nconst hexNumbers = Array.from(Array(256).keys(), (n)=>n.toString(16).padStart(2, \"0\"));\nclass Util {\n    static makeHexColor(r, g, b) {\n        return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n    }\n    static domMatrixToTransform(dm) {\n        return [\n            dm.a,\n            dm.b,\n            dm.c,\n            dm.d,\n            dm.e,\n            dm.f\n        ];\n    }\n    static scaleMinMax(transform, minMax) {\n        let temp;\n        if (transform[0]) {\n            if (transform[0] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[0];\n            minMax[2] *= transform[0];\n            if (transform[3] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[3];\n            minMax[3] *= transform[3];\n        } else {\n            temp = minMax[0];\n            minMax[0] = minMax[1];\n            minMax[1] = temp;\n            temp = minMax[2];\n            minMax[2] = minMax[3];\n            minMax[3] = temp;\n            if (transform[1] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[1];\n            minMax[3] *= transform[1];\n            if (transform[2] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[2];\n            minMax[2] *= transform[2];\n        }\n        minMax[0] += transform[4];\n        minMax[1] += transform[5];\n        minMax[2] += transform[4];\n        minMax[3] += transform[5];\n    }\n    static transform(m1, m2) {\n        return [\n            m1[0] * m2[0] + m1[2] * m2[1],\n            m1[1] * m2[0] + m1[3] * m2[1],\n            m1[0] * m2[2] + m1[2] * m2[3],\n            m1[1] * m2[2] + m1[3] * m2[3],\n            m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n            m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n        ];\n    }\n    static multiplyByDOMMatrix(m, md) {\n        return [\n            m[0] * md.a + m[2] * md.b,\n            m[1] * md.a + m[3] * md.b,\n            m[0] * md.c + m[2] * md.d,\n            m[1] * md.c + m[3] * md.d,\n            m[0] * md.e + m[2] * md.f + m[4],\n            m[1] * md.e + m[3] * md.f + m[5]\n        ];\n    }\n    static applyTransform(p, m, pos = 0) {\n        const p0 = p[pos];\n        const p1 = p[pos + 1];\n        p[pos] = p0 * m[0] + p1 * m[2] + m[4];\n        p[pos + 1] = p0 * m[1] + p1 * m[3] + m[5];\n    }\n    static applyTransformToBezier(p, transform, pos = 0) {\n        const m0 = transform[0];\n        const m1 = transform[1];\n        const m2 = transform[2];\n        const m3 = transform[3];\n        const m4 = transform[4];\n        const m5 = transform[5];\n        for(let i = 0; i < 6; i += 2){\n            const pI = p[pos + i];\n            const pI1 = p[pos + i + 1];\n            p[pos + i] = pI * m0 + pI1 * m2 + m4;\n            p[pos + i + 1] = pI * m1 + pI1 * m3 + m5;\n        }\n    }\n    static applyInverseTransform(p, m) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const d = m[0] * m[3] - m[1] * m[2];\n        p[0] = (p0 * m[3] - p1 * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n        p[1] = (-p0 * m[1] + p1 * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    }\n    static axialAlignedBoundingBox(rect, transform, output) {\n        const m0 = transform[0];\n        const m1 = transform[1];\n        const m2 = transform[2];\n        const m3 = transform[3];\n        const m4 = transform[4];\n        const m5 = transform[5];\n        const r0 = rect[0];\n        const r1 = rect[1];\n        const r2 = rect[2];\n        const r3 = rect[3];\n        let a0 = m0 * r0 + m4;\n        let a2 = a0;\n        let a1 = m0 * r2 + m4;\n        let a3 = a1;\n        let b0 = m3 * r1 + m5;\n        let b2 = b0;\n        let b1 = m3 * r3 + m5;\n        let b3 = b1;\n        if (m1 !== 0 || m2 !== 0) {\n            const m1r0 = m1 * r0;\n            const m1r2 = m1 * r2;\n            const m2r1 = m2 * r1;\n            const m2r3 = m2 * r3;\n            a0 += m2r1;\n            a3 += m2r1;\n            a1 += m2r3;\n            a2 += m2r3;\n            b0 += m1r0;\n            b3 += m1r0;\n            b1 += m1r2;\n            b2 += m1r2;\n        }\n        output[0] = Math.min(output[0], a0, a1, a2, a3);\n        output[1] = Math.min(output[1], b0, b1, b2, b3);\n        output[2] = Math.max(output[2], a0, a1, a2, a3);\n        output[3] = Math.max(output[3], b0, b1, b2, b3);\n    }\n    static inverseTransform(m) {\n        const d = m[0] * m[3] - m[1] * m[2];\n        return [\n            m[3] / d,\n            -m[1] / d,\n            -m[2] / d,\n            m[0] / d,\n            (m[2] * m[5] - m[4] * m[3]) / d,\n            (m[4] * m[1] - m[5] * m[0]) / d\n        ];\n    }\n    static singularValueDecompose2dScale(matrix, output) {\n        const m0 = matrix[0];\n        const m1 = matrix[1];\n        const m2 = matrix[2];\n        const m3 = matrix[3];\n        const a = m0 ** 2 + m1 ** 2;\n        const b = m0 * m2 + m1 * m3;\n        const c = m2 ** 2 + m3 ** 2;\n        const first = (a + c) / 2;\n        const second = Math.sqrt(first ** 2 - (a * c - b ** 2));\n        output[0] = Math.sqrt(first + second || 1);\n        output[1] = Math.sqrt(first - second || 1);\n    }\n    static normalizeRect(rect) {\n        const r = rect.slice(0);\n        if (rect[0] > rect[2]) {\n            r[0] = rect[2];\n            r[2] = rect[0];\n        }\n        if (rect[1] > rect[3]) {\n            r[1] = rect[3];\n            r[3] = rect[1];\n        }\n        return r;\n    }\n    static intersect(rect1, rect2) {\n        const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n        const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n        if (xLow > xHigh) {\n            return null;\n        }\n        const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n        const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n        if (yLow > yHigh) {\n            return null;\n        }\n        return [\n            xLow,\n            yLow,\n            xHigh,\n            yHigh\n        ];\n    }\n    static pointBoundingBox(x, y, minMax) {\n        minMax[0] = Math.min(minMax[0], x);\n        minMax[1] = Math.min(minMax[1], y);\n        minMax[2] = Math.max(minMax[2], x);\n        minMax[3] = Math.max(minMax[3], y);\n    }\n    static rectBoundingBox(x0, y0, x1, y1, minMax) {\n        minMax[0] = Math.min(minMax[0], x0, x1);\n        minMax[1] = Math.min(minMax[1], y0, y1);\n        minMax[2] = Math.max(minMax[2], x0, x1);\n        minMax[3] = Math.max(minMax[3], y0, y1);\n    }\n    static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {\n        if (t <= 0 || t >= 1) {\n            return;\n        }\n        const mt = 1 - t;\n        const tt = t * t;\n        const ttt = tt * t;\n        const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;\n        const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;\n        minMax[0] = Math.min(minMax[0], x);\n        minMax[1] = Math.min(minMax[1], y);\n        minMax[2] = Math.max(minMax[2], x);\n        minMax[3] = Math.max(minMax[3], y);\n    }\n    static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {\n        if (Math.abs(a) < 1e-12) {\n            if (Math.abs(b) >= 1e-12) {\n                this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);\n            }\n            return;\n        }\n        const delta = b ** 2 - 4 * c * a;\n        if (delta < 0) {\n            return;\n        }\n        const sqrtDelta = Math.sqrt(delta);\n        const a2 = 2 * a;\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);\n    }\n    static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n        minMax[0] = Math.min(minMax[0], x0, x3);\n        minMax[1] = Math.min(minMax[1], y0, y3);\n        minMax[2] = Math.max(minMax[2], x0, x3);\n        minMax[3] = Math.max(minMax[3], y0, y3);\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);\n    }\n}\nconst PDFStringTranslateTable = /* unused pure expression or super */ null && 0;\nfunction stringToPDFString(str, keepEscapeSequence = false) {\n    if (str[0] >= \"\\xef\") {\n        let encoding;\n        if (str[0] === \"\\xfe\" && str[1] === \"\\xff\") {\n            encoding = \"utf-16be\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xff\" && str[1] === \"\\xfe\") {\n            encoding = \"utf-16le\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xef\" && str[1] === \"\\xbb\" && str[2] === \"\\xbf\") {\n            encoding = \"utf-8\";\n        }\n        if (encoding) {\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(str);\n                const decoded = decoder.decode(buffer);\n                if (keepEscapeSequence || !decoded.includes(\"\\x1b\")) {\n                    return decoded;\n                }\n                return decoded.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g, \"\");\n            } catch (ex) {\n                warn(`stringToPDFString: \"${ex}\".`);\n            }\n        }\n    }\n    const strBuf = [];\n    for(let i = 0, ii = str.length; i < ii; i++){\n        const charCode = str.charCodeAt(i);\n        if (!keepEscapeSequence && charCode === 0x1b) {\n            while(++i < ii && str.charCodeAt(i) !== 0x1b){}\n            continue;\n        }\n        const code = PDFStringTranslateTable[charCode];\n        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToUTF8String(str) {\n    return decodeURIComponent(escape(str));\n}\nfunction utf8StringToString(str) {\n    return unescape(encodeURIComponent(str));\n}\nfunction isArrayEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for(let i = 0, ii = arr1.length; i < ii; i++){\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getModificationDate(date = new Date()) {\n    if (!(date instanceof Date)) {\n        date = new Date(date);\n    }\n    const buffer = [\n        date.getUTCFullYear().toString(),\n        (date.getUTCMonth() + 1).toString().padStart(2, \"0\"),\n        date.getUTCDate().toString().padStart(2, \"0\"),\n        date.getUTCHours().toString().padStart(2, \"0\"),\n        date.getUTCMinutes().toString().padStart(2, \"0\"),\n        date.getUTCSeconds().toString().padStart(2, \"0\")\n    ];\n    return buffer.join(\"\");\n}\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n    if (!NormalizeRegex) {\n        NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n        NormalizationMap = new Map([\n            [\n                \"\",\n                \"t\"\n            ]\n        ]);\n    }\n    return str.replaceAll(NormalizeRegex, (_, p1, p2)=>p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2));\n}\nfunction getUuid() {\n    if (typeof crypto.randomUUID === \"function\") {\n        return crypto.randomUUID();\n    }\n    const buf = new Uint8Array(32);\n    crypto.getRandomValues(buf);\n    return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nfunction _isValidExplicitDest(validRef, validName, dest) {\n    if (!Array.isArray(dest) || dest.length < 2) {\n        return false;\n    }\n    const [page, zoom, ...args] = dest;\n    if (!validRef(page) && !Number.isInteger(page)) {\n        return false;\n    }\n    if (!validName(zoom)) {\n        return false;\n    }\n    const argsLen = args.length;\n    let allowNull = true;\n    switch(zoom.name){\n        case \"XYZ\":\n            if (argsLen < 2 || argsLen > 3) {\n                return false;\n            }\n            break;\n        case \"Fit\":\n        case \"FitB\":\n            return argsLen === 0;\n        case \"FitH\":\n        case \"FitBH\":\n        case \"FitV\":\n        case \"FitBV\":\n            if (argsLen > 1) {\n                return false;\n            }\n            break;\n        case \"FitR\":\n            if (argsLen !== 4) {\n                return false;\n            }\n            allowNull = false;\n            break;\n        default:\n            return false;\n    }\n    for (const arg of args){\n        if (typeof arg === \"number\" || allowNull && arg === null) {\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\nfunction MathClamp(v, min, max) {\n    return Math.min(Math.max(v, min), max);\n}\nfunction toHexUtil(arr) {\n    if (Uint8Array.prototype.toHex) {\n        return arr.toHex();\n    }\n    return Array.from(arr, (num)=>hexNumbers[num]).join(\"\");\n}\nfunction toBase64Util(arr) {\n    if (Uint8Array.prototype.toBase64) {\n        return arr.toBase64();\n    }\n    return btoa(bytesToString(arr));\n}\nfunction fromBase64Util(str) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(str);\n    }\n    return stringToBytes(atob(str));\n}\nif (typeof Math.sumPrecise !== \"function\") {\n    Math.sumPrecise = function(numbers) {\n        return numbers.reduce((a, b)=>a + b, 0);\n    };\n}\nif (typeof AbortSignal.any !== \"function\") {\n    AbortSignal.any = function(iterable) {\n        const ac = new AbortController();\n        const { signal } = ac;\n        for (const s of iterable){\n            if (s.aborted) {\n                ac.abort(s.reason);\n                return signal;\n            }\n        }\n        for (const s of iterable){\n            s.addEventListener(\"abort\", ()=>{\n                ac.abort(s.reason);\n            }, {\n                signal\n            });\n        }\n        return signal;\n    };\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.map.js\nvar es_iterator_map = __nested_webpack_require_216482__(1701);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.delete.js\nvar web_url_search_params_delete = __nested_webpack_require_216482__(4603);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.has.js\nvar web_url_search_params_has = __nested_webpack_require_216482__(7566);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.size.js\nvar web_url_search_params_size = __nested_webpack_require_216482__(8721);\n; // ./src/display/xfa_text.js\nclass XfaText {\n    static textContent(xfa) {\n        const items = [];\n        const output = {\n            items,\n            styles: Object.create(null)\n        };\n        function walk(node) {\n            if (!node) {\n                return;\n            }\n            let str = null;\n            const name = node.name;\n            if (name === \"#text\") {\n                str = node.value;\n            } else if (!XfaText.shouldBuildText(name)) {\n                return;\n            } else if (node?.attributes?.textContent) {\n                str = node.attributes.textContent;\n            } else if (node.value) {\n                str = node.value;\n            }\n            if (str !== null) {\n                items.push({\n                    str\n                });\n            }\n            if (!node.children) {\n                return;\n            }\n            for (const child of node.children){\n                walk(child);\n            }\n        }\n        walk(xfa);\n        return output;\n    }\n    static shouldBuildText(name) {\n        return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n    }\n}\n; // ./src/display/xfa_layer.js\nclass XfaLayer {\n    static setupStorage(html, id, element, storage, intent) {\n        const storedData = storage.getValue(id, {\n            value: null\n        });\n        switch(element.name){\n            case \"textarea\":\n                if (storedData.value !== null) {\n                    html.textContent = storedData.value;\n                }\n                if (intent === \"print\") {\n                    break;\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    storage.setValue(id, {\n                        value: event.target.value\n                    });\n                });\n                break;\n            case \"input\":\n                if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n                    if (storedData.value === element.attributes.xfaOn) {\n                        html.setAttribute(\"checked\", true);\n                    } else if (storedData.value === element.attributes.xfaOff) {\n                        html.removeAttribute(\"checked\");\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"change\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n                        });\n                    });\n                } else {\n                    if (storedData.value !== null) {\n                        html.setAttribute(\"value\", storedData.value);\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"input\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.value\n                        });\n                    });\n                }\n                break;\n            case \"select\":\n                if (storedData.value !== null) {\n                    html.setAttribute(\"value\", storedData.value);\n                    for (const option of element.children){\n                        if (option.attributes.value === storedData.value) {\n                            option.attributes.selected = true;\n                        } else if (option.attributes.hasOwnProperty(\"selected\")) {\n                            delete option.attributes.selected;\n                        }\n                    }\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    const options = event.target.options;\n                    const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n                    storage.setValue(id, {\n                        value\n                    });\n                });\n                break;\n        }\n    }\n    static setAttributes({ html, element, storage = null, intent, linkService }) {\n        const { attributes } = element;\n        const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n        if (attributes.type === \"radio\") {\n            attributes.name = `${attributes.name}-${intent}`;\n        }\n        for (const [key, value] of Object.entries(attributes)){\n            if (value === null || value === undefined) {\n                continue;\n            }\n            switch(key){\n                case \"class\":\n                    if (value.length) {\n                        html.setAttribute(key, value.join(\" \"));\n                    }\n                    break;\n                case \"dataId\":\n                    break;\n                case \"id\":\n                    html.setAttribute(\"data-element-id\", value);\n                    break;\n                case \"style\":\n                    Object.assign(html.style, value);\n                    break;\n                case \"textContent\":\n                    html.textContent = value;\n                    break;\n                default:\n                    if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n                        html.setAttribute(key, value);\n                    }\n            }\n        }\n        if (isHTMLAnchorElement) {\n            linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n        }\n        if (storage && attributes.dataId) {\n            this.setupStorage(html, attributes.dataId, element, storage);\n        }\n    }\n    static render(parameters) {\n        const storage = parameters.annotationStorage;\n        const linkService = parameters.linkService;\n        const root = parameters.xfaHtml;\n        const intent = parameters.intent || \"display\";\n        const rootHtml = document.createElement(root.name);\n        if (root.attributes) {\n            this.setAttributes({\n                html: rootHtml,\n                element: root,\n                intent,\n                linkService\n            });\n        }\n        const isNotForRichText = intent !== \"richText\";\n        const rootDiv = parameters.div;\n        rootDiv.append(rootHtml);\n        if (parameters.viewport) {\n            const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n            rootDiv.style.transform = transform;\n        }\n        if (isNotForRichText) {\n            rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n        }\n        const textDivs = [];\n        if (root.children.length === 0) {\n            if (root.value) {\n                const node = document.createTextNode(root.value);\n                rootHtml.append(node);\n                if (isNotForRichText && XfaText.shouldBuildText(root.name)) {\n                    textDivs.push(node);\n                }\n            }\n            return {\n                textDivs\n            };\n        }\n        const stack = [\n            [\n                root,\n                -1,\n                rootHtml\n            ]\n        ];\n        while(stack.length > 0){\n            const [parent, i, html] = stack.at(-1);\n            if (i + 1 === parent.children.length) {\n                stack.pop();\n                continue;\n            }\n            const child = parent.children[++stack.at(-1)[1]];\n            if (child === null) {\n                continue;\n            }\n            const { name } = child;\n            if (name === \"#text\") {\n                const node = document.createTextNode(child.value);\n                textDivs.push(node);\n                html.append(node);\n                continue;\n            }\n            const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n            html.append(childHtml);\n            if (child.attributes) {\n                this.setAttributes({\n                    html: childHtml,\n                    element: child,\n                    storage,\n                    intent,\n                    linkService\n                });\n            }\n            if (child.children?.length > 0) {\n                stack.push([\n                    child,\n                    -1,\n                    childHtml\n                ]);\n            } else if (child.value) {\n                const node = document.createTextNode(child.value);\n                if (isNotForRichText && XfaText.shouldBuildText(name)) {\n                    textDivs.push(node);\n                }\n                childHtml.append(node);\n            }\n        }\n        for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")){\n            el.setAttribute(\"readOnly\", true);\n        }\n        return {\n            textDivs\n        };\n    }\n    static update(parameters) {\n        const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n        parameters.div.style.transform = transform;\n        parameters.div.hidden = false;\n    }\n}\n; // ./src/display/display_utils.js\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nclass PixelsPerInch {\n    static{\n        this.CSS = 96.0;\n    }\n    static{\n        this.PDF = 72.0;\n    }\n    static{\n        this.PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n    }\n}\nasync function fetchData(url, type = \"text\") {\n    if (isValidFetchUrl(url, document.baseURI)) {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n        switch(type){\n            case \"arraybuffer\":\n                return response.arrayBuffer();\n            case \"blob\":\n                return response.blob();\n            case \"json\":\n                return response.json();\n        }\n        return response.text();\n    }\n    return new Promise((resolve, reject)=>{\n        const request = new XMLHttpRequest();\n        request.open(\"GET\", url, true);\n        request.responseType = type;\n        request.onreadystatechange = ()=>{\n            if (request.readyState !== XMLHttpRequest.DONE) {\n                return;\n            }\n            if (request.status === 200 || request.status === 0) {\n                switch(type){\n                    case \"arraybuffer\":\n                    case \"blob\":\n                    case \"json\":\n                        resolve(request.response);\n                        return;\n                }\n                resolve(request.responseText);\n                return;\n            }\n            reject(new Error(request.statusText));\n        };\n        request.send(null);\n    });\n}\nclass PageViewport {\n    constructor({ viewBox, userUnit, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }){\n        this.viewBox = viewBox;\n        this.userUnit = userUnit;\n        this.scale = scale;\n        this.rotation = rotation;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        scale *= userUnit;\n        const centerX = (viewBox[2] + viewBox[0]) / 2;\n        const centerY = (viewBox[3] + viewBox[1]) / 2;\n        let rotateA, rotateB, rotateC, rotateD;\n        rotation %= 360;\n        if (rotation < 0) {\n            rotation += 360;\n        }\n        switch(rotation){\n            case 180:\n                rotateA = -1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = 1;\n                break;\n            case 90:\n                rotateA = 0;\n                rotateB = 1;\n                rotateC = 1;\n                rotateD = 0;\n                break;\n            case 270:\n                rotateA = 0;\n                rotateB = -1;\n                rotateC = -1;\n                rotateD = 0;\n                break;\n            case 0:\n                rotateA = 1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = -1;\n                break;\n            default:\n                throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n        }\n        if (dontFlip) {\n            rotateC = -rotateC;\n            rotateD = -rotateD;\n        }\n        let offsetCanvasX, offsetCanvasY;\n        let width, height;\n        if (rotateA === 0) {\n            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n            width = (viewBox[3] - viewBox[1]) * scale;\n            height = (viewBox[2] - viewBox[0]) * scale;\n        } else {\n            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n            width = (viewBox[2] - viewBox[0]) * scale;\n            height = (viewBox[3] - viewBox[1]) * scale;\n        }\n        this.transform = [\n            rotateA * scale,\n            rotateB * scale,\n            rotateC * scale,\n            rotateD * scale,\n            offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n            offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY\n        ];\n        this.width = width;\n        this.height = height;\n    }\n    get rawDims() {\n        const dims = this.viewBox;\n        return shadow(this, \"rawDims\", {\n            pageWidth: dims[2] - dims[0],\n            pageHeight: dims[3] - dims[1],\n            pageX: dims[0],\n            pageY: dims[1]\n        });\n    }\n    clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.viewBox.slice(),\n            userUnit: this.userUnit,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    convertToViewportPoint(x, y) {\n        const p = [\n            x,\n            y\n        ];\n        Util.applyTransform(p, this.transform);\n        return p;\n    }\n    convertToViewportRectangle(rect) {\n        const topLeft = [\n            rect[0],\n            rect[1]\n        ];\n        Util.applyTransform(topLeft, this.transform);\n        const bottomRight = [\n            rect[2],\n            rect[3]\n        ];\n        Util.applyTransform(bottomRight, this.transform);\n        return [\n            topLeft[0],\n            topLeft[1],\n            bottomRight[0],\n            bottomRight[1]\n        ];\n    }\n    convertToPdfPoint(x, y) {\n        const p = [\n            x,\n            y\n        ];\n        Util.applyInverseTransform(p, this.transform);\n        return p;\n    }\n}\nclass RenderingCancelledException extends BaseException {\n    constructor(msg, extraDelay = 0){\n        super(msg, \"RenderingCancelledException\");\n        this.extraDelay = extraDelay;\n    }\n}\nfunction isDataScheme(url) {\n    const ii = url.length;\n    let i = 0;\n    while(i < ii && url[i].trim() === \"\"){\n        i++;\n    }\n    return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\nfunction isPdfFile(filename) {\n    return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\nfunction getFilenameFromUrl(url) {\n    [url] = url.split(/[#?]/, 1);\n    return url.substring(url.lastIndexOf(\"/\") + 1);\n}\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n    if (typeof url !== \"string\") {\n        return defaultFilename;\n    }\n    if (isDataScheme(url)) {\n        warn('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n        return defaultFilename;\n    }\n    const getURL = (urlString)=>{\n        try {\n            return new URL(urlString);\n        } catch  {\n            try {\n                return new URL(decodeURIComponent(urlString));\n            } catch  {\n                try {\n                    return new URL(urlString, \"https://foo.bar\");\n                } catch  {\n                    try {\n                        return new URL(decodeURIComponent(urlString), \"https://foo.bar\");\n                    } catch  {\n                        return null;\n                    }\n                }\n            }\n        }\n    };\n    const newURL = getURL(url);\n    if (!newURL) {\n        return defaultFilename;\n    }\n    const decode = (name)=>{\n        try {\n            let decoded = decodeURIComponent(name);\n            if (decoded.includes(\"/\")) {\n                decoded = decoded.split(\"/\").at(-1);\n                if (decoded.test(/^\\.pdf$/i)) {\n                    return decoded;\n                }\n                return name;\n            }\n            return decoded;\n        } catch  {\n            return name;\n        }\n    };\n    const pdfRegex = /\\.pdf$/i;\n    const filename = newURL.pathname.split(\"/\").at(-1);\n    if (pdfRegex.test(filename)) {\n        return decode(filename);\n    }\n    if (newURL.searchParams.size > 0) {\n        const values = Array.from(newURL.searchParams.values()).reverse();\n        for (const value of values){\n            if (pdfRegex.test(value)) {\n                return decode(value);\n            }\n        }\n        const keys = Array.from(newURL.searchParams.keys()).reverse();\n        for (const key of keys){\n            if (pdfRegex.test(key)) {\n                return decode(key);\n            }\n        }\n    }\n    if (newURL.hash) {\n        const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n        const hashFilename = reFilename.exec(newURL.hash);\n        if (hashFilename) {\n            return decode(hashFilename[0]);\n        }\n    }\n    return defaultFilename;\n}\nclass StatTimer {\n    time(name) {\n        if (name in this.started) {\n            warn(`Timer is already running for ${name}`);\n        }\n        this.started[name] = Date.now();\n    }\n    timeEnd(name) {\n        if (!(name in this.started)) {\n            warn(`Timer has not been started for ${name}`);\n        }\n        this.times.push({\n            name,\n            start: this.started[name],\n            end: Date.now()\n        });\n        delete this.started[name];\n    }\n    toString() {\n        const outBuf = [];\n        let longest = 0;\n        for (const { name } of this.times){\n            longest = Math.max(name.length, longest);\n        }\n        for (const { name, start, end } of this.times){\n            outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n        }\n        return outBuf.join(\"\");\n    }\n    constructor(){\n        this.started = Object.create(null);\n        this.times = [];\n    }\n}\nfunction isValidFetchUrl(url, baseUrl) {\n    const res = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n    return res?.protocol === \"http:\" || res?.protocol === \"https:\";\n}\nfunction noContextMenu(e) {\n    e.preventDefault();\n}\nfunction stopEvent(e) {\n    e.preventDefault();\n    e.stopPropagation();\n}\nfunction deprecated(details) {\n    console.log(\"Deprecated API usage: \" + details);\n}\nclass PDFDateString {\n    static #regex;\n    static toDateObject(input) {\n        if (input instanceof Date) {\n            return input;\n        }\n        if (!input || typeof input !== \"string\") {\n            return null;\n        }\n        this.#regex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n        const matches = this.#regex.exec(input);\n        if (!matches) {\n            return null;\n        }\n        const year = parseInt(matches[1], 10);\n        let month = parseInt(matches[2], 10);\n        month = month >= 1 && month <= 12 ? month - 1 : 0;\n        let day = parseInt(matches[3], 10);\n        day = day >= 1 && day <= 31 ? day : 1;\n        let hour = parseInt(matches[4], 10);\n        hour = hour >= 0 && hour <= 23 ? hour : 0;\n        let minute = parseInt(matches[5], 10);\n        minute = minute >= 0 && minute <= 59 ? minute : 0;\n        let second = parseInt(matches[6], 10);\n        second = second >= 0 && second <= 59 ? second : 0;\n        const universalTimeRelation = matches[7] || \"Z\";\n        let offsetHour = parseInt(matches[8], 10);\n        offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n        let offsetMinute = parseInt(matches[9], 10) || 0;\n        offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n        if (universalTimeRelation === \"-\") {\n            hour += offsetHour;\n            minute += offsetMinute;\n        } else if (universalTimeRelation === \"+\") {\n            hour -= offsetHour;\n            minute -= offsetMinute;\n        }\n        return new Date(Date.UTC(year, month, day, hour, minute, second));\n    }\n}\nfunction getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) {\n    const { width, height } = xfaPage.attributes.style;\n    const viewBox = [\n        0,\n        0,\n        parseInt(width),\n        parseInt(height)\n    ];\n    return new PageViewport({\n        viewBox,\n        userUnit: 1,\n        scale,\n        rotation\n    });\n}\nfunction getRGB(color) {\n    if (color.startsWith(\"#\")) {\n        const colorRGB = parseInt(color.slice(1), 16);\n        return [\n            (colorRGB & 0xff0000) >> 16,\n            (colorRGB & 0x00ff00) >> 8,\n            colorRGB & 0x0000ff\n        ];\n    }\n    if (color.startsWith(\"rgb(\")) {\n        return color.slice(4, -1).split(\",\").map((x)=>parseInt(x));\n    }\n    if (color.startsWith(\"rgba(\")) {\n        return color.slice(5, -1).split(\",\").map((x)=>parseInt(x)).slice(0, 3);\n    }\n    warn(`Not a valid color format: \"${color}\"`);\n    return [\n        0,\n        0,\n        0\n    ];\n}\nfunction getColorValues(colors) {\n    const span = document.createElement(\"span\");\n    span.style.visibility = \"hidden\";\n    span.style.colorScheme = \"only light\";\n    document.body.append(span);\n    for (const name of colors.keys()){\n        span.style.color = name;\n        const computedColor = window.getComputedStyle(span).color;\n        colors.set(name, getRGB(computedColor));\n    }\n    span.remove();\n}\nfunction getCurrentTransform(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction getCurrentTransformInverse(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform().invertSelf();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n    if (viewport instanceof PageViewport) {\n        const { pageWidth, pageHeight } = viewport.rawDims;\n        const { style } = div;\n        const useRound = util_FeatureTest.isCSSRoundSupported;\n        const w = `var(--total-scale-factor) * ${pageWidth}px`, h = `var(--total-scale-factor) * ${pageHeight}px`;\n        const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x))` : `calc(${w})`, heightStr = useRound ? `round(down, ${h}, var(--scale-round-y))` : `calc(${h})`;\n        if (!mustFlip || viewport.rotation % 180 === 0) {\n            style.width = widthStr;\n            style.height = heightStr;\n        } else {\n            style.width = heightStr;\n            style.height = widthStr;\n        }\n    }\n    if (mustRotate) {\n        div.setAttribute(\"data-main-rotation\", viewport.rotation);\n    }\n}\nclass OutputScale {\n    constructor(){\n        const { pixelRatio } = OutputScale;\n        this.sx = pixelRatio;\n        this.sy = pixelRatio;\n    }\n    get scaled() {\n        return this.sx !== 1 || this.sy !== 1;\n    }\n    get symmetric() {\n        return this.sx === this.sy;\n    }\n    limitCanvas(width, height, maxPixels, maxDim, capAreaFactor = -1) {\n        let maxAreaScale = Infinity, maxWidthScale = Infinity, maxHeightScale = Infinity;\n        maxPixels = OutputScale.capPixels(maxPixels, capAreaFactor);\n        if (maxPixels > 0) {\n            maxAreaScale = Math.sqrt(maxPixels / (width * height));\n        }\n        if (maxDim !== -1) {\n            maxWidthScale = maxDim / width;\n            maxHeightScale = maxDim / height;\n        }\n        const maxScale = Math.min(maxAreaScale, maxWidthScale, maxHeightScale);\n        if (this.sx > maxScale || this.sy > maxScale) {\n            this.sx = maxScale;\n            this.sy = maxScale;\n            return true;\n        }\n        return false;\n    }\n    static get pixelRatio() {\n        return globalThis.devicePixelRatio || 1;\n    }\n    static capPixels(maxPixels, capAreaFactor) {\n        if (capAreaFactor >= 0) {\n            const winPixels = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + capAreaFactor / 100));\n            return maxPixels > 0 ? Math.min(maxPixels, winPixels) : winPixels;\n        }\n        return maxPixels;\n    }\n}\nconst SupportedImageMimeTypes = [\n    \"image/apng\",\n    \"image/avif\",\n    \"image/bmp\",\n    \"image/gif\",\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/svg+xml\",\n    \"image/webp\",\n    \"image/x-icon\"\n];\nclass ColorScheme {\n    static get isDarkMode() {\n        return shadow(this, \"isDarkMode\", !!window?.matchMedia?.(\"(prefers-color-scheme: dark)\").matches);\n    }\n}\nclass CSSConstants {\n    static get commentForegroundColor() {\n        const element = document.createElement(\"span\");\n        element.classList.add(\"comment\", \"sidebar\");\n        const { style } = element;\n        style.width = style.height = \"0\";\n        style.display = \"none\";\n        style.color = \"var(--comment-fg-color)\";\n        document.body.append(element);\n        const { color } = window.getComputedStyle(element);\n        element.remove();\n        return shadow(this, \"commentForegroundColor\", getRGB(color));\n    }\n}\nfunction applyOpacity(r, g, b, opacity) {\n    opacity = Math.min(Math.max(opacity ?? 1, 0), 1);\n    const white = 255 * (1 - opacity);\n    r = Math.round(r * opacity + white);\n    g = Math.round(g * opacity + white);\n    b = Math.round(b * opacity + white);\n    return [\n        r,\n        g,\n        b\n    ];\n}\nfunction RGBToHSL(rgb, output) {\n    const r = rgb[0] / 255;\n    const g = rgb[1] / 255;\n    const b = rgb[2] / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = (max + min) / 2;\n    if (max === min) {\n        output[0] = output[1] = 0;\n    } else {\n        const d = max - min;\n        output[1] = l < 0.5 ? d / (max + min) : d / (2 - max - min);\n        switch(max){\n            case r:\n                output[0] = ((g - b) / d + (g < b ? 6 : 0)) * 60;\n                break;\n            case g:\n                output[0] = ((b - r) / d + 2) * 60;\n                break;\n            case b:\n                output[0] = ((r - g) / d + 4) * 60;\n                break;\n        }\n    }\n    output[2] = l;\n}\nfunction HSLToRGB(hsl, output) {\n    const h = hsl[0];\n    const s = hsl[1];\n    const l = hsl[2];\n    const c = (1 - Math.abs(2 * l - 1)) * s;\n    const x = c * (1 - Math.abs(h / 60 % 2 - 1));\n    const m = l - c / 2;\n    switch(Math.floor(h / 60)){\n        case 0:\n            output[0] = c + m;\n            output[1] = x + m;\n            output[2] = m;\n            break;\n        case 1:\n            output[0] = x + m;\n            output[1] = c + m;\n            output[2] = m;\n            break;\n        case 2:\n            output[0] = m;\n            output[1] = c + m;\n            output[2] = x + m;\n            break;\n        case 3:\n            output[0] = m;\n            output[1] = x + m;\n            output[2] = c + m;\n            break;\n        case 4:\n            output[0] = x + m;\n            output[1] = m;\n            output[2] = c + m;\n            break;\n        case 5:\n        case 6:\n            output[0] = c + m;\n            output[1] = m;\n            output[2] = x + m;\n            break;\n    }\n}\nfunction computeLuminance(x) {\n    return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n}\nfunction contrastRatio(hsl1, hsl2, output) {\n    HSLToRGB(hsl1, output);\n    output.map(computeLuminance);\n    const lum1 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];\n    HSLToRGB(hsl2, output);\n    output.map(computeLuminance);\n    const lum2 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];\n    return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);\n}\nconst contrastCache = new Map();\nfunction findContrastColor(baseColor, fixedColor) {\n    const key = baseColor[0] + baseColor[1] * 0x100 + baseColor[2] * 0x10000 + fixedColor[0] * 0x1000000 + fixedColor[1] * 0x100000000 + fixedColor[2] * 0x10000000000;\n    let cachedValue = contrastCache.get(key);\n    if (cachedValue) {\n        return cachedValue;\n    }\n    const array = new Float32Array(9);\n    const output = array.subarray(0, 3);\n    const baseHSL = array.subarray(3, 6);\n    RGBToHSL(baseColor, baseHSL);\n    const fixedHSL = array.subarray(6, 9);\n    RGBToHSL(fixedColor, fixedHSL);\n    const isFixedColorDark = fixedHSL[2] < 0.5;\n    const minContrast = isFixedColorDark ? 12 : 4.5;\n    baseHSL[2] = isFixedColorDark ? Math.sqrt(baseHSL[2]) : 1 - Math.sqrt(1 - baseHSL[2]);\n    if (contrastRatio(baseHSL, fixedHSL, output) < minContrast) {\n        let start, end;\n        if (isFixedColorDark) {\n            start = baseHSL[2];\n            end = 1;\n        } else {\n            start = 0;\n            end = baseHSL[2];\n        }\n        const PRECISION = 0.005;\n        while(end - start > PRECISION){\n            const mid = baseHSL[2] = (start + end) / 2;\n            if (isFixedColorDark === contrastRatio(baseHSL, fixedHSL, output) < minContrast) {\n                start = mid;\n            } else {\n                end = mid;\n            }\n        }\n        baseHSL[2] = isFixedColorDark ? end : start;\n    }\n    HSLToRGB(baseHSL, output);\n    cachedValue = Util.makeHexColor(Math.round(output[0] * 255), Math.round(output[1] * 255), Math.round(output[2] * 255));\n    contrastCache.set(key, cachedValue);\n    return cachedValue;\n}\nfunction renderRichText({ html, dir, className }, container) {\n    const fragment = document.createDocumentFragment();\n    if (typeof html === \"string\") {\n        const p = document.createElement(\"p\");\n        p.dir = dir || \"auto\";\n        const lines = html.split(/(?:\\r\\n?|\\n)/);\n        for(let i = 0, ii = lines.length; i < ii; ++i){\n            const line = lines[i];\n            p.append(document.createTextNode(line));\n            if (i < ii - 1) {\n                p.append(document.createElement(\"br\"));\n            }\n        }\n        fragment.append(p);\n    } else {\n        XfaLayer.render({\n            xfaHtml: html,\n            div: fragment,\n            intent: \"richText\"\n        });\n    }\n    fragment.firstChild.classList.add(\"richText\", className);\n    container.append(fragment);\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.take.js\nvar es_iterator_take = __nested_webpack_require_216482__(4972);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.promise.with-resolvers.js\nvar es_promise_with_resolvers = __nested_webpack_require_216482__(4628);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.difference.v2.js\nvar es_set_difference_v2 = __nested_webpack_require_216482__(7642);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.intersection.v2.js\nvar es_set_intersection_v2 = __nested_webpack_require_216482__(8004);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.is-disjoint-from.v2.js\nvar es_set_is_disjoint_from_v2 = __nested_webpack_require_216482__(3853);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.is-subset-of.v2.js\nvar es_set_is_subset_of_v2 = __nested_webpack_require_216482__(5876);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.is-superset-of.v2.js\nvar es_set_is_superset_of_v2 = __nested_webpack_require_216482__(2475);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.symmetric-difference.v2.js\nvar es_set_symmetric_difference_v2 = __nested_webpack_require_216482__(5024);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.union.v2.js\nvar es_set_union_v2 = __nested_webpack_require_216482__(1698);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.drop.js\nvar es_iterator_drop = __nested_webpack_require_216482__(9314);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.every.js\nvar es_iterator_every = __nested_webpack_require_216482__(1148);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.some.js\nvar es_iterator_some = __nested_webpack_require_216482__(3579);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.json.parse.js\nvar esnext_json_parse = __nested_webpack_require_216482__(8335);\n; // ./src/display/editor/toolbar.js\nclass EditorToolbar {\n    #toolbar;\n    #colorPicker;\n    #editor;\n    #buttons;\n    #altText;\n    #comment;\n    #commentButtonDivider;\n    #signatureDescriptionButton;\n    static #l10nRemove = null;\n    constructor(editor){\n        this.#toolbar = null;\n        this.#colorPicker = null;\n        this.#buttons = null;\n        this.#altText = null;\n        this.#comment = null;\n        this.#commentButtonDivider = null;\n        this.#signatureDescriptionButton = null;\n        this.#editor = editor;\n        EditorToolbar.#l10nRemove ||= Object.freeze({\n            freetext: \"pdfjs-editor-remove-freetext-button\",\n            highlight: \"pdfjs-editor-remove-highlight-button\",\n            ink: \"pdfjs-editor-remove-ink-button\",\n            stamp: \"pdfjs-editor-remove-stamp-button\",\n            signature: \"pdfjs-editor-remove-signature-button\"\n        });\n    }\n    render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.classList.add(\"editToolbar\", \"hidden\");\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        const signal = this.#editor._uiManager._signal;\n        if (signal instanceof AbortSignal && !signal.aborted) {\n            editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            editToolbar.addEventListener(\"pointerdown\", EditorToolbar.#pointerDown, {\n                signal\n            });\n        }\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        const position = this.#editor.toolbarPosition;\n        if (position) {\n            const { style } = editToolbar;\n            const x = this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0];\n            style.insetInlineEnd = `${100 * x}%`;\n            style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;\n        }\n        return editToolbar;\n    }\n    get div() {\n        return this.#toolbar;\n    }\n    static #pointerDown(e) {\n        e.stopPropagation();\n    }\n    #focusIn(e) {\n        this.#editor._focusEventsAllowed = false;\n        stopEvent(e);\n    }\n    #focusOut(e) {\n        this.#editor._focusEventsAllowed = true;\n        stopEvent(e);\n    }\n    #addListenersToElement(element) {\n        const signal = this.#editor._uiManager._signal;\n        if (!(signal instanceof AbortSignal) || signal.aborted) {\n            return false;\n        }\n        element.addEventListener(\"focusin\", this.#focusIn.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"focusout\", this.#focusOut.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        return true;\n    }\n    hide() {\n        this.#toolbar.classList.add(\"hidden\");\n        this.#colorPicker?.hideDropdown();\n    }\n    show() {\n        this.#toolbar.classList.remove(\"hidden\");\n        this.#altText?.shown();\n        this.#comment?.shown();\n    }\n    addDeleteButton() {\n        const { editorType, _uiManager } = this.#editor;\n        const button = document.createElement(\"button\");\n        button.classList.add(\"basic\", \"deleteButton\");\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", EditorToolbar.#l10nRemove[editorType]);\n        if (this.#addListenersToElement(button)) {\n            button.addEventListener(\"click\", (e)=>{\n                _uiManager.delete();\n            }, {\n                signal: _uiManager._signal\n            });\n        }\n        this.#buttons.append(button);\n    }\n    get #divider() {\n        const divider = document.createElement(\"div\");\n        divider.className = \"divider\";\n        return divider;\n    }\n    async addAltText(altText) {\n        const button = await altText.render();\n        this.#addListenersToElement(button);\n        this.#buttons.append(button, this.#divider);\n        this.#altText = altText;\n    }\n    addComment(comment, beforeElement = null) {\n        if (this.#comment) {\n            return;\n        }\n        const button = comment.renderForToolbar();\n        if (!button) {\n            return;\n        }\n        this.#addListenersToElement(button);\n        const divider = this.#commentButtonDivider = this.#divider;\n        if (!beforeElement) {\n            this.#buttons.append(button, divider);\n        } else {\n            this.#buttons.insertBefore(button, beforeElement);\n            this.#buttons.insertBefore(divider, beforeElement);\n        }\n        this.#comment = comment;\n        comment.toolbar = this;\n    }\n    addColorPicker(colorPicker) {\n        if (this.#colorPicker) {\n            return;\n        }\n        this.#colorPicker = colorPicker;\n        const button = colorPicker.renderButton();\n        this.#addListenersToElement(button);\n        this.#buttons.append(button, this.#divider);\n    }\n    async addEditSignatureButton(signatureManager) {\n        const button = this.#signatureDescriptionButton = await signatureManager.renderEditButton(this.#editor);\n        this.#addListenersToElement(button);\n        this.#buttons.append(button, this.#divider);\n    }\n    removeButton(name) {\n        switch(name){\n            case \"comment\":\n                this.#comment?.removeToolbarCommentButton();\n                this.#comment = null;\n                this.#commentButtonDivider?.remove();\n                this.#commentButtonDivider = null;\n                break;\n        }\n    }\n    async addButton(name, tool) {\n        switch(name){\n            case \"colorPicker\":\n                this.addColorPicker(tool);\n                break;\n            case \"altText\":\n                await this.addAltText(tool);\n                break;\n            case \"editSignature\":\n                await this.addEditSignatureButton(tool);\n                break;\n            case \"delete\":\n                this.addDeleteButton();\n                break;\n            case \"comment\":\n                this.addComment(tool);\n                break;\n        }\n    }\n    async addButtonBefore(name, tool, beforeSelector) {\n        const beforeElement = this.#buttons.querySelector(beforeSelector);\n        if (!beforeElement) {\n            return;\n        }\n        if (name === \"comment\") {\n            this.addComment(tool, beforeElement);\n        }\n    }\n    updateEditSignatureButton(description) {\n        if (this.#signatureDescriptionButton) {\n            this.#signatureDescriptionButton.title = description;\n        }\n    }\n    remove() {\n        this.#toolbar.remove();\n        this.#colorPicker?.destroy();\n        this.#colorPicker = null;\n    }\n}\nclass FloatingToolbar {\n    #buttons;\n    #toolbar;\n    #uiManager;\n    constructor(uiManager){\n        this.#buttons = null;\n        this.#toolbar = null;\n        this.#uiManager = uiManager;\n    }\n    #render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.className = \"editToolbar\";\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        const signal = this.#uiManager._signal;\n        if (signal instanceof AbortSignal && !signal.aborted) {\n            editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n        }\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        if (this.#uiManager.hasCommentManager()) {\n            this.#makeButton(\"commentButton\", `pdfjs-comment-floating-button`, \"pdfjs-comment-floating-button-label\", ()=>{\n                this.#uiManager.commentSelection(\"floating_button\");\n            });\n        }\n        this.#makeButton(\"highlightButton\", `pdfjs-highlight-floating-button1`, \"pdfjs-highlight-floating-button-label\", ()=>{\n            this.#uiManager.highlightSelection(\"floating_button\");\n        });\n        return editToolbar;\n    }\n    #getLastPoint(boxes, isLTR) {\n        let lastY = 0;\n        let lastX = 0;\n        for (const box of boxes){\n            const y = box.y + box.height;\n            if (y < lastY) {\n                continue;\n            }\n            const x = box.x + (isLTR ? box.width : 0);\n            if (y > lastY) {\n                lastX = x;\n                lastY = y;\n                continue;\n            }\n            if (isLTR) {\n                if (x > lastX) {\n                    lastX = x;\n                }\n            } else if (x < lastX) {\n                lastX = x;\n            }\n        }\n        return [\n            isLTR ? 1 - lastX : lastX,\n            lastY\n        ];\n    }\n    show(parent, boxes, isLTR) {\n        const [x, y] = this.#getLastPoint(boxes, isLTR);\n        const { style } = this.#toolbar ||= this.#render();\n        parent.append(this.#toolbar);\n        style.insetInlineEnd = `${100 * x}%`;\n        style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;\n    }\n    hide() {\n        this.#toolbar.remove();\n    }\n    #makeButton(buttonClass, l10nId, labelL10nId, clickHandler) {\n        const button = document.createElement(\"button\");\n        button.classList.add(\"basic\", buttonClass);\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", l10nId);\n        const span = document.createElement(\"span\");\n        button.append(span);\n        span.className = \"visuallyHidden\";\n        span.setAttribute(\"data-l10n-id\", labelL10nId);\n        const signal = this.#uiManager._signal;\n        if (signal instanceof AbortSignal && !signal.aborted) {\n            button.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            button.addEventListener(\"click\", clickHandler, {\n                signal\n            });\n        }\n        this.#buttons.append(button);\n    }\n}\n; // ./src/display/editor/tools.js\nfunction bindEvents(obj, element, names) {\n    for (const name of names){\n        element.addEventListener(name, obj[name].bind(obj));\n    }\n}\nclass IdManager {\n    #id;\n    get id() {\n        return `${AnnotationEditorPrefix}${this.#id++}`;\n    }\n    constructor(){\n        this.#id = 0;\n    }\n}\nclass ImageManager {\n    #baseId;\n    #id;\n    #cache;\n    static get _isSVGFittingCanvas() {\n        const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n        const canvas = new OffscreenCanvas(1, 3);\n        const ctx = canvas.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        const image = new Image();\n        image.src = svg;\n        const promise = image.decode().then(()=>{\n            ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n            return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n        });\n        return shadow(this, \"_isSVGFittingCanvas\", promise);\n    }\n    async #get(key, rawData) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(key);\n        if (data === null) {\n            return null;\n        }\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        try {\n            data ||= {\n                bitmap: null,\n                id: `image_${this.#baseId}_${this.#id++}`,\n                refCounter: 0,\n                isSvg: false\n            };\n            let image;\n            if (typeof rawData === \"string\") {\n                data.url = rawData;\n                image = await fetchData(rawData, \"blob\");\n            } else if (rawData instanceof File) {\n                image = data.file = rawData;\n            } else if (rawData instanceof Blob) {\n                image = rawData;\n            }\n            if (image.type === \"image/svg+xml\") {\n                const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n                const fileReader = new FileReader();\n                const imageElement = new Image();\n                const imagePromise = new Promise((resolve, reject)=>{\n                    imageElement.onload = ()=>{\n                        data.bitmap = imageElement;\n                        data.isSvg = true;\n                        resolve();\n                    };\n                    fileReader.onload = async ()=>{\n                        const url = data.svgUrl = fileReader.result;\n                        imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;\n                    };\n                    imageElement.onerror = fileReader.onerror = reject;\n                });\n                fileReader.readAsDataURL(image);\n                await imagePromise;\n            } else {\n                data.bitmap = await createImageBitmap(image);\n            }\n            data.refCounter = 1;\n        } catch (e) {\n            warn(e);\n            data = null;\n        }\n        this.#cache.set(key, data);\n        if (data) {\n            this.#cache.set(data.id, data);\n        }\n        return data;\n    }\n    async getFromFile(file) {\n        const { lastModified, name, size, type } = file;\n        return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n    }\n    async getFromUrl(url) {\n        return this.#get(url, url);\n    }\n    async getFromBlob(id, blobPromise) {\n        const blob = await blobPromise;\n        return this.#get(id, blob);\n    }\n    async getFromId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return null;\n        }\n        if (data.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        if (data.file) {\n            return this.getFromFile(data.file);\n        }\n        if (data.blobPromise) {\n            const { blobPromise } = data;\n            delete data.blobPromise;\n            return this.getFromBlob(data.id, blobPromise);\n        }\n        return this.getFromUrl(data.url);\n    }\n    getFromCanvas(id, canvas) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(id);\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        const offscreen = new OffscreenCanvas(canvas.width, canvas.height);\n        const ctx = offscreen.getContext(\"2d\");\n        ctx.drawImage(canvas, 0, 0);\n        data = {\n            bitmap: offscreen.transferToImageBitmap(),\n            id: `image_${this.#baseId}_${this.#id++}`,\n            refCounter: 1,\n            isSvg: false\n        };\n        this.#cache.set(id, data);\n        this.#cache.set(data.id, data);\n        return data;\n    }\n    getSvgUrl(id) {\n        const data = this.#cache.get(id);\n        if (!data?.isSvg) {\n            return null;\n        }\n        return data.svgUrl;\n    }\n    deleteId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return;\n        }\n        data.refCounter -= 1;\n        if (data.refCounter !== 0) {\n            return;\n        }\n        const { bitmap } = data;\n        if (!data.url && !data.file) {\n            const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n            const ctx = canvas.getContext(\"bitmaprenderer\");\n            ctx.transferFromImageBitmap(bitmap);\n            data.blobPromise = canvas.convertToBlob();\n        }\n        bitmap.close?.();\n        data.bitmap = null;\n    }\n    isValidId(id) {\n        return id.startsWith(`image_${this.#baseId}_`);\n    }\n    constructor(){\n        this.#baseId = getUuid();\n        this.#id = 0;\n        this.#cache = null;\n    }\n}\nclass CommandManager {\n    #commands;\n    #locked;\n    #maxSize;\n    #position;\n    constructor(maxSize = 128){\n        this.#commands = [];\n        this.#locked = false;\n        this.#position = -1;\n        this.#maxSize = maxSize;\n    }\n    add({ cmd, undo, post, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) {\n        if (mustExec) {\n            cmd();\n        }\n        if (this.#locked) {\n            return;\n        }\n        const save = {\n            cmd,\n            undo,\n            post,\n            type\n        };\n        if (this.#position === -1) {\n            if (this.#commands.length > 0) {\n                this.#commands.length = 0;\n            }\n            this.#position = 0;\n            this.#commands.push(save);\n            return;\n        }\n        if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n            if (keepUndo) {\n                save.undo = this.#commands[this.#position].undo;\n            }\n            this.#commands[this.#position] = save;\n            return;\n        }\n        const next = this.#position + 1;\n        if (next === this.#maxSize) {\n            this.#commands.splice(0, 1);\n        } else {\n            this.#position = next;\n            if (next < this.#commands.length) {\n                this.#commands.splice(next);\n            }\n        }\n        this.#commands.push(save);\n    }\n    undo() {\n        if (this.#position === -1) {\n            return;\n        }\n        this.#locked = true;\n        const { undo, post } = this.#commands[this.#position];\n        undo();\n        post?.();\n        this.#locked = false;\n        this.#position -= 1;\n    }\n    redo() {\n        if (this.#position < this.#commands.length - 1) {\n            this.#position += 1;\n            this.#locked = true;\n            const { cmd, post } = this.#commands[this.#position];\n            cmd();\n            post?.();\n            this.#locked = false;\n        }\n    }\n    hasSomethingToUndo() {\n        return this.#position !== -1;\n    }\n    hasSomethingToRedo() {\n        return this.#position < this.#commands.length - 1;\n    }\n    cleanType(type) {\n        if (this.#position === -1) {\n            return;\n        }\n        for(let i = this.#position; i >= 0; i--){\n            if (this.#commands[i].type !== type) {\n                this.#commands.splice(i + 1, this.#position - i);\n                this.#position = i;\n                return;\n            }\n        }\n        this.#commands.length = 0;\n        this.#position = -1;\n    }\n    destroy() {\n        this.#commands = null;\n    }\n}\nclass KeyboardManager {\n    constructor(callbacks){\n        this.buffer = [];\n        this.callbacks = new Map();\n        this.allKeys = new Set();\n        const { isMac } = util_FeatureTest.platform;\n        for (const [keys, callback, options = {}] of callbacks){\n            for (const key of keys){\n                const isMacKey = key.startsWith(\"mac+\");\n                if (isMac && isMacKey) {\n                    this.callbacks.set(key.slice(4), {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                } else if (!isMac && !isMacKey) {\n                    this.callbacks.set(key, {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                }\n            }\n        }\n    }\n    #serialize(event) {\n        if (event.altKey) {\n            this.buffer.push(\"alt\");\n        }\n        if (event.ctrlKey) {\n            this.buffer.push(\"ctrl\");\n        }\n        if (event.metaKey) {\n            this.buffer.push(\"meta\");\n        }\n        if (event.shiftKey) {\n            this.buffer.push(\"shift\");\n        }\n        this.buffer.push(event.key);\n        const str = this.buffer.join(\"+\");\n        this.buffer.length = 0;\n        return str;\n    }\n    exec(self1, event) {\n        if (!this.allKeys.has(event.key)) {\n            return;\n        }\n        const info = this.callbacks.get(this.#serialize(event));\n        if (!info) {\n            return;\n        }\n        const { callback, options: { bubbles = false, args = [], checker = null } } = info;\n        if (checker && !checker(self1, event)) {\n            return;\n        }\n        callback.bind(self1, ...args, event)();\n        if (!bubbles) {\n            stopEvent(event);\n        }\n    }\n}\nclass ColorManager {\n    static{\n        this._colorsMapping = new Map([\n            [\n                \"CanvasText\",\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            [\n                \"Canvas\",\n                [\n                    255,\n                    255,\n                    255\n                ]\n            ]\n        ]);\n    }\n    get _colors() {\n        const colors = new Map([\n            [\n                \"CanvasText\",\n                null\n            ],\n            [\n                \"Canvas\",\n                null\n            ]\n        ]);\n        getColorValues(colors);\n        return shadow(this, \"_colors\", colors);\n    }\n    convert(color) {\n        const rgb = getRGB(color);\n        if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n            return rgb;\n        }\n        for (const [name, RGB] of this._colors){\n            if (RGB.every((x, i)=>x === rgb[i])) {\n                return ColorManager._colorsMapping.get(name);\n            }\n        }\n        return rgb;\n    }\n    getHexCode(name) {\n        const rgb = this._colors.get(name);\n        if (!rgb) {\n            return name;\n        }\n        return Util.makeHexColor(...rgb);\n    }\n}\nclass AnnotationEditorUIManager {\n    #abortController;\n    #activeEditor;\n    #allEditableAnnotations;\n    #allEditors;\n    #allLayers;\n    #altTextManager;\n    #annotationStorage;\n    #changedExistingAnnotations;\n    #commandManager;\n    #commentManager;\n    #copyPasteAC;\n    #currentDrawingSession;\n    #currentPageIndex;\n    #deletedAnnotationsElementIds;\n    #draggingEditors;\n    #editorTypes;\n    #editorsToRescale;\n    #enableHighlightFloatingButton;\n    #enableUpdatedAddImage;\n    #enableNewAltTextWhenAddingImage;\n    #filterFactory;\n    #focusMainContainerTimeoutId;\n    #focusManagerAC;\n    #highlightColors;\n    #highlightWhenShiftUp;\n    #floatingToolbar;\n    #idManager;\n    #isEnabled;\n    #isPointerDown;\n    #isWaiting;\n    #keyboardManagerAC;\n    #lastActiveElement;\n    #mainHighlightColorPicker;\n    #missingCanvases;\n    #mlManager;\n    #mode;\n    #selectedEditors;\n    #selectedTextNode;\n    #signatureManager;\n    #pageColors;\n    #showAllStates;\n    #pdfDocument;\n    #previousStates;\n    #translation;\n    #translationTimeoutId;\n    #container;\n    #viewer;\n    #viewerAlert;\n    #updateModeCapability;\n    static{\n        this.TRANSLATE_SMALL = 1;\n    }\n    static{\n        this.TRANSLATE_BIG = 10;\n    }\n    static get _keyboardManager() {\n        const proto = AnnotationEditorUIManager.prototype;\n        const arrowChecker = (self1)=>self1.#container.contains(document.activeElement) && document.activeElement.tagName !== \"BUTTON\" && self1.hasSomethingToControl();\n        const textInputChecker = (_self, { target: el })=>{\n            if (el instanceof HTMLInputElement) {\n                const { type } = el;\n                return type !== \"text\" && type !== \"number\";\n            }\n            return true;\n        };\n        const small = this.TRANSLATE_SMALL;\n        const big = this.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+a\",\n                    \"mac+meta+a\"\n                ],\n                proto.selectAll,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+z\",\n                    \"mac+meta+z\"\n                ],\n                proto.undo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+y\",\n                    \"ctrl+shift+z\",\n                    \"mac+meta+shift+z\",\n                    \"ctrl+shift+Z\",\n                    \"mac+meta+shift+Z\"\n                ],\n                proto.redo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Backspace\",\n                    \"alt+Backspace\",\n                    \"ctrl+Backspace\",\n                    \"shift+Backspace\",\n                    \"mac+Backspace\",\n                    \"mac+alt+Backspace\",\n                    \"mac+ctrl+Backspace\",\n                    \"Delete\",\n                    \"ctrl+Delete\",\n                    \"shift+Delete\",\n                    \"mac+Delete\"\n                ],\n                proto.delete,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Enter\",\n                    \"mac+Enter\"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self1, { target: el })=>!(el instanceof HTMLButtonElement) && self1.#container.contains(el) && !self1.isEnterHandled\n                }\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self1, { target: el })=>!(el instanceof HTMLButtonElement) && self1.#container.contains(document.activeElement)\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.unselectAll\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    constructor(container, viewer, viewerAlert, altTextManager, commentManager, signatureManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom){\n        this.#abortController = new AbortController();\n        this.#activeEditor = null;\n        this.#allEditableAnnotations = null;\n        this.#allEditors = new Map();\n        this.#allLayers = new Map();\n        this.#altTextManager = null;\n        this.#annotationStorage = null;\n        this.#changedExistingAnnotations = null;\n        this.#commandManager = new CommandManager();\n        this.#commentManager = null;\n        this.#copyPasteAC = null;\n        this.#currentDrawingSession = null;\n        this.#currentPageIndex = 0;\n        this.#deletedAnnotationsElementIds = new Set();\n        this.#draggingEditors = null;\n        this.#editorTypes = null;\n        this.#editorsToRescale = new Set();\n        this._editorUndoBar = null;\n        this.#enableHighlightFloatingButton = false;\n        this.#enableUpdatedAddImage = false;\n        this.#enableNewAltTextWhenAddingImage = false;\n        this.#filterFactory = null;\n        this.#focusMainContainerTimeoutId = null;\n        this.#focusManagerAC = null;\n        this.#highlightColors = null;\n        this.#highlightWhenShiftUp = false;\n        this.#floatingToolbar = null;\n        this.#idManager = new IdManager();\n        this.#isEnabled = false;\n        this.#isPointerDown = false;\n        this.#isWaiting = false;\n        this.#keyboardManagerAC = null;\n        this.#lastActiveElement = null;\n        this.#mainHighlightColorPicker = null;\n        this.#missingCanvases = null;\n        this.#mlManager = null;\n        this.#mode = AnnotationEditorType.NONE;\n        this.#selectedEditors = new Set();\n        this.#selectedTextNode = null;\n        this.#signatureManager = null;\n        this.#pageColors = null;\n        this.#showAllStates = null;\n        this.#pdfDocument = null;\n        this.#previousStates = {\n            isEditing: false,\n            isEmpty: true,\n            hasSomethingToUndo: false,\n            hasSomethingToRedo: false,\n            hasSelectedEditor: false,\n            hasSelectedText: false\n        };\n        this.#translation = [\n            0,\n            0\n        ];\n        this.#translationTimeoutId = null;\n        this.#container = null;\n        this.#viewer = null;\n        this.#viewerAlert = null;\n        this.#updateModeCapability = null;\n        const signal = this._signal = this.#abortController.signal;\n        this.#container = container;\n        this.#viewer = viewer;\n        this.#viewerAlert = viewerAlert;\n        this.#altTextManager = altTextManager;\n        this.#commentManager = commentManager;\n        this.#signatureManager = signatureManager;\n        this.#pdfDocument = pdfDocument;\n        this._eventBus = eventBus;\n        eventBus._on(\"editingaction\", this.onEditingAction.bind(this), {\n            signal\n        });\n        eventBus._on(\"pagechanging\", this.onPageChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"scalechanging\", this.onScaleChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"rotationchanging\", this.onRotationChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"setpreference\", this.onSetPreference.bind(this), {\n            signal\n        });\n        eventBus._on(\"switchannotationeditorparams\", (evt)=>this.updateParams(evt.type, evt.value), {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", ()=>{\n            this.#isPointerDown = true;\n        }, {\n            capture: true,\n            signal\n        });\n        window.addEventListener(\"pointerup\", ()=>{\n            this.#isPointerDown = false;\n        }, {\n            capture: true,\n            signal\n        });\n        this.#addSelectionListener();\n        this.#addDragAndDropListeners();\n        this.#addKeyboardManager();\n        this.#annotationStorage = pdfDocument.annotationStorage;\n        this.#filterFactory = pdfDocument.filterFactory;\n        this.#pageColors = pageColors;\n        this.#highlightColors = highlightColors || null;\n        this.#enableHighlightFloatingButton = enableHighlightFloatingButton;\n        this.#enableUpdatedAddImage = enableUpdatedAddImage;\n        this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;\n        this.#mlManager = mlManager || null;\n        this.viewParameters = {\n            realScale: PixelsPerInch.PDF_TO_CSS_UNITS,\n            rotation: 0\n        };\n        this.isShiftKeyDown = false;\n        this._editorUndoBar = editorUndoBar || null;\n        this._supportsPinchToZoom = supportsPinchToZoom !== false;\n        commentManager?.setSidebarUiManager(this);\n    }\n    destroy() {\n        this.#updateModeCapability?.resolve();\n        this.#updateModeCapability = null;\n        this.#abortController?.abort();\n        this.#abortController = null;\n        this._signal = null;\n        for (const layer of this.#allLayers.values()){\n            layer.destroy();\n        }\n        this.#allLayers.clear();\n        this.#allEditors.clear();\n        this.#editorsToRescale.clear();\n        this.#missingCanvases?.clear();\n        this.#activeEditor = null;\n        this.#selectedEditors.clear();\n        this.#commandManager.destroy();\n        this.#altTextManager?.destroy();\n        this.#commentManager?.destroy();\n        this.#signatureManager?.destroy();\n        this.#floatingToolbar?.hide();\n        this.#floatingToolbar = null;\n        this.#mainHighlightColorPicker?.destroy();\n        this.#mainHighlightColorPicker = null;\n        this.#allEditableAnnotations = null;\n        if (this.#focusMainContainerTimeoutId) {\n            clearTimeout(this.#focusMainContainerTimeoutId);\n            this.#focusMainContainerTimeoutId = null;\n        }\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n            this.#translationTimeoutId = null;\n        }\n        this._editorUndoBar?.destroy();\n        this.#pdfDocument = null;\n    }\n    combinedSignal(ac) {\n        return AbortSignal.any([\n            this._signal,\n            ac.signal\n        ]);\n    }\n    get mlManager() {\n        return this.#mlManager;\n    }\n    get useNewAltTextFlow() {\n        return this.#enableUpdatedAddImage;\n    }\n    get useNewAltTextWhenAddingImage() {\n        return this.#enableNewAltTextWhenAddingImage;\n    }\n    get hcmFilter() {\n        return shadow(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n    }\n    get direction() {\n        return shadow(this, \"direction\", getComputedStyle(this.#container).direction);\n    }\n    get _highlightColors() {\n        return shadow(this, \"_highlightColors\", this.#highlightColors ? new Map(this.#highlightColors.split(\",\").map((pair)=>{\n            pair = pair.split(\"=\").map((x)=>x.trim());\n            pair[1] = pair[1].toUpperCase();\n            return pair;\n        })) : null);\n    }\n    get highlightColors() {\n        const { _highlightColors } = this;\n        if (!_highlightColors) {\n            return shadow(this, \"highlightColors\", null);\n        }\n        const map = new Map();\n        const hasHCM = !!this.#pageColors;\n        for (const [name, color] of _highlightColors){\n            const isNameForHCM = name.endsWith(\"_HCM\");\n            if (hasHCM && isNameForHCM) {\n                map.set(name.replace(\"_HCM\", \"\"), color);\n                continue;\n            }\n            if (!hasHCM && !isNameForHCM) {\n                map.set(name, color);\n            }\n        }\n        return shadow(this, \"highlightColors\", map);\n    }\n    get highlightColorNames() {\n        return shadow(this, \"highlightColorNames\", this.highlightColors ? new Map(Array.from(this.highlightColors, (e)=>e.reverse())) : null);\n    }\n    getNonHCMColor(color) {\n        if (!this._highlightColors) {\n            return color;\n        }\n        const colorName = this.highlightColorNames.get(color);\n        return this._highlightColors.get(colorName) || color;\n    }\n    getNonHCMColorName(color) {\n        return this.highlightColorNames.get(color) || color;\n    }\n    setCurrentDrawingSession(layer) {\n        if (layer) {\n            this.unselectAll();\n            this.disableUserSelect(true);\n        } else {\n            this.disableUserSelect(false);\n        }\n        this.#currentDrawingSession = layer;\n    }\n    setMainHighlightColorPicker(colorPicker) {\n        this.#mainHighlightColorPicker = colorPicker;\n    }\n    editAltText(editor, firstTime = false) {\n        this.#altTextManager?.editAltText(this, editor, firstTime);\n    }\n    hasCommentManager() {\n        return !!this.#commentManager;\n    }\n    editComment(editor, posX, posY, options) {\n        this.#commentManager?.showDialog(this, editor, posX, posY, options);\n    }\n    selectComment(pageIndex, uid) {\n        const layer = this.#allLayers.get(pageIndex);\n        const editor = layer?.getEditorByUID(uid);\n        editor?.toggleComment(true, true);\n    }\n    updateComment(editor) {\n        this.#commentManager?.updateComment(editor.getData());\n    }\n    updatePopupColor(editor) {\n        this.#commentManager?.updatePopupColor(editor);\n    }\n    removeComment(editor) {\n        this.#commentManager?.removeComments([\n            editor.uid\n        ]);\n    }\n    toggleComment(editor, isSelected, visibility = undefined) {\n        this.#commentManager?.toggleCommentPopup(editor, isSelected, visibility);\n    }\n    makeCommentColor(color, opacity) {\n        return color && this.#commentManager?.makeCommentColor(color, opacity) || null;\n    }\n    getCommentDialogElement() {\n        return this.#commentManager?.dialogElement || null;\n    }\n    async waitForEditorsRendered(pageNumber) {\n        if (this.#allLayers.has(pageNumber - 1)) {\n            return;\n        }\n        const { resolve, promise } = Promise.withResolvers();\n        const onEditorsRendered = (evt)=>{\n            if (evt.pageNumber === pageNumber) {\n                this._eventBus._off(\"editorsrendered\", onEditorsRendered);\n                resolve();\n            }\n        };\n        this._eventBus.on(\"editorsrendered\", onEditorsRendered);\n        await promise;\n    }\n    getSignature(editor) {\n        this.#signatureManager?.getSignature({\n            uiManager: this,\n            editor\n        });\n    }\n    get signatureManager() {\n        return this.#signatureManager;\n    }\n    switchToMode(mode, callback) {\n        this._eventBus.on(\"annotationeditormodechanged\", callback, {\n            once: true,\n            signal: this._signal\n        });\n        this._eventBus.dispatch(\"showannotationeditorui\", {\n            source: this,\n            mode\n        });\n    }\n    setPreference(name, value) {\n        this._eventBus.dispatch(\"setpreference\", {\n            source: this,\n            name,\n            value\n        });\n    }\n    onSetPreference({ name, value }) {\n        switch(name){\n            case \"enableNewAltTextWhenAddingImage\":\n                this.#enableNewAltTextWhenAddingImage = value;\n                break;\n        }\n    }\n    onPageChanging({ pageNumber }) {\n        this.#currentPageIndex = pageNumber - 1;\n    }\n    focusMainContainer() {\n        this.#container.focus();\n    }\n    findParent(x, y) {\n        for (const layer of this.#allLayers.values()){\n            const { x: layerX, y: layerY, width, height } = layer.div.getBoundingClientRect();\n            if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    disableUserSelect(value = false) {\n        this.#viewer.classList.toggle(\"noUserSelect\", value);\n    }\n    addShouldRescale(editor) {\n        this.#editorsToRescale.add(editor);\n    }\n    removeShouldRescale(editor) {\n        this.#editorsToRescale.delete(editor);\n    }\n    onScaleChanging({ scale }) {\n        this.commitOrRemove();\n        this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;\n        for (const editor of this.#editorsToRescale){\n            editor.onScaleChanging();\n        }\n        this.#currentDrawingSession?.onScaleChanging();\n    }\n    onRotationChanging({ pagesRotation }) {\n        this.commitOrRemove();\n        this.viewParameters.rotation = pagesRotation;\n    }\n    #getAnchorElementForSelection({ anchorNode }) {\n        return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;\n    }\n    #getLayerForTextLayer(textLayer) {\n        const { currentLayer } = this;\n        if (currentLayer.hasTextLayer(textLayer)) {\n            return currentLayer;\n        }\n        for (const layer of this.#allLayers.values()){\n            if (layer.hasTextLayer(textLayer)) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    highlightSelection(methodOfCreation = \"\", comment = false) {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;\n        const text = selection.toString();\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        selection.empty();\n        const layer = this.#getLayerForTextLayer(textLayer);\n        const isNoneMode = this.#mode === AnnotationEditorType.NONE;\n        const callback = ()=>{\n            const editor = layer?.createAndAddNewEditor({\n                x: 0,\n                y: 0\n            }, false, {\n                methodOfCreation,\n                boxes,\n                anchorNode,\n                anchorOffset,\n                focusNode,\n                focusOffset,\n                text\n            });\n            if (isNoneMode) {\n                this.showAllEditors(\"highlight\", true, true);\n            }\n            if (comment) {\n                editor?.editComment();\n            }\n        };\n        if (isNoneMode) {\n            this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);\n            return;\n        }\n        callback();\n    }\n    commentSelection(methodOfCreation = \"\") {\n        this.highlightSelection(methodOfCreation, true);\n    }\n    #displayFloatingToolbar() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        this.#floatingToolbar ||= new FloatingToolbar(this);\n        this.#floatingToolbar.show(textLayer, boxes, this.direction === \"ltr\");\n    }\n    getAndRemoveDataFromAnnotationStorage(annotationId) {\n        if (!this.#annotationStorage) {\n            return null;\n        }\n        const key = `${AnnotationEditorPrefix}${annotationId}`;\n        const storedValue = this.#annotationStorage.getRawValue(key);\n        if (storedValue) {\n            this.#annotationStorage.remove(key);\n        }\n        return storedValue;\n    }\n    addToAnnotationStorage(editor) {\n        if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n            this.#annotationStorage.setValue(editor.id, editor);\n        }\n    }\n    a11yAlert(messageId, args = null) {\n        const viewerAlert = this.#viewerAlert;\n        if (!viewerAlert) {\n            return;\n        }\n        viewerAlert.setAttribute(\"data-l10n-id\", messageId);\n        if (args) {\n            viewerAlert.setAttribute(\"data-l10n-args\", JSON.stringify(args));\n        } else {\n            viewerAlert.removeAttribute(\"data-l10n-args\");\n        }\n    }\n    #selectionChange() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            if (this.#selectedTextNode) {\n                this.#floatingToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        const { anchorNode } = selection;\n        if (anchorNode === this.#selectedTextNode) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        if (!textLayer) {\n            if (this.#selectedTextNode) {\n                this.#floatingToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        this.#floatingToolbar?.hide();\n        this.#selectedTextNode = anchorNode;\n        this.#dispatchUpdateStates({\n            hasSelectedText: true\n        });\n        if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.showAllEditors(\"highlight\", true, true);\n        }\n        this.#highlightWhenShiftUp = this.isShiftKeyDown;\n        if (!this.isShiftKeyDown) {\n            const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;\n            activeLayer?.toggleDrawing();\n            if (this.#isPointerDown) {\n                const ac = new AbortController();\n                const signal = this.combinedSignal(ac);\n                const pointerup = (e)=>{\n                    if (e.type === \"pointerup\" && e.button !== 0) {\n                        return;\n                    }\n                    ac.abort();\n                    activeLayer?.toggleDrawing(true);\n                    if (e.type === \"pointerup\") {\n                        this.#onSelectEnd(\"main_toolbar\");\n                    }\n                };\n                window.addEventListener(\"pointerup\", pointerup, {\n                    signal\n                });\n                window.addEventListener(\"blur\", pointerup, {\n                    signal\n                });\n            } else {\n                activeLayer?.toggleDrawing(true);\n                this.#onSelectEnd(\"main_toolbar\");\n            }\n        }\n    }\n    #onSelectEnd(methodOfCreation = \"\") {\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.highlightSelection(methodOfCreation);\n        } else if (this.#enableHighlightFloatingButton) {\n            this.#displayFloatingToolbar();\n        }\n    }\n    #addSelectionListener() {\n        document.addEventListener(\"selectionchange\", this.#selectionChange.bind(this), {\n            signal: this._signal\n        });\n    }\n    #addFocusManager() {\n        if (this.#focusManagerAC) {\n            return;\n        }\n        this.#focusManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#focusManagerAC);\n        window.addEventListener(\"focus\", this.focus.bind(this), {\n            signal\n        });\n        window.addEventListener(\"blur\", this.blur.bind(this), {\n            signal\n        });\n    }\n    #removeFocusManager() {\n        this.#focusManagerAC?.abort();\n        this.#focusManagerAC = null;\n    }\n    blur() {\n        this.isShiftKeyDown = false;\n        if (this.#highlightWhenShiftUp) {\n            this.#highlightWhenShiftUp = false;\n            this.#onSelectEnd(\"main_toolbar\");\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        const { activeElement } = document;\n        for (const editor of this.#selectedEditors){\n            if (editor.div.contains(activeElement)) {\n                this.#lastActiveElement = [\n                    editor,\n                    activeElement\n                ];\n                editor._focusEventsAllowed = false;\n                break;\n            }\n        }\n    }\n    focus() {\n        if (!this.#lastActiveElement) {\n            return;\n        }\n        const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n        this.#lastActiveElement = null;\n        lastActiveElement.addEventListener(\"focusin\", ()=>{\n            lastEditor._focusEventsAllowed = true;\n        }, {\n            once: true,\n            signal: this._signal\n        });\n        lastActiveElement.focus();\n    }\n    #addKeyboardManager() {\n        if (this.#keyboardManagerAC) {\n            return;\n        }\n        this.#keyboardManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#keyboardManagerAC);\n        window.addEventListener(\"keydown\", this.keydown.bind(this), {\n            signal\n        });\n        window.addEventListener(\"keyup\", this.keyup.bind(this), {\n            signal\n        });\n    }\n    #removeKeyboardManager() {\n        this.#keyboardManagerAC?.abort();\n        this.#keyboardManagerAC = null;\n    }\n    #addCopyPasteListeners() {\n        if (this.#copyPasteAC) {\n            return;\n        }\n        this.#copyPasteAC = new AbortController();\n        const signal = this.combinedSignal(this.#copyPasteAC);\n        document.addEventListener(\"copy\", this.copy.bind(this), {\n            signal\n        });\n        document.addEventListener(\"cut\", this.cut.bind(this), {\n            signal\n        });\n        document.addEventListener(\"paste\", this.paste.bind(this), {\n            signal\n        });\n    }\n    #removeCopyPasteListeners() {\n        this.#copyPasteAC?.abort();\n        this.#copyPasteAC = null;\n    }\n    #addDragAndDropListeners() {\n        const signal = this._signal;\n        document.addEventListener(\"dragover\", this.dragOver.bind(this), {\n            signal\n        });\n        document.addEventListener(\"drop\", this.drop.bind(this), {\n            signal\n        });\n    }\n    addEditListeners() {\n        this.#addKeyboardManager();\n        this.#addCopyPasteListeners();\n    }\n    removeEditListeners() {\n        this.#removeKeyboardManager();\n        this.#removeCopyPasteListeners();\n    }\n    dragOver(event) {\n        for (const { type } of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(type)) {\n                    event.dataTransfer.dropEffect = \"copy\";\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    drop(event) {\n        for (const item of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    copy(event) {\n        event.preventDefault();\n        this.#activeEditor?.commitOrRemove();\n        if (!this.hasSelection) {\n            return;\n        }\n        const editors = [];\n        for (const editor of this.#selectedEditors){\n            const serialized = editor.serialize(true);\n            if (serialized) {\n                editors.push(serialized);\n            }\n        }\n        if (editors.length === 0) {\n            return;\n        }\n        event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n    }\n    cut(event) {\n        this.copy(event);\n        this.delete();\n    }\n    async paste(event) {\n        event.preventDefault();\n        const { clipboardData } = event;\n        for (const item of clipboardData.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    return;\n                }\n            }\n        }\n        let data = clipboardData.getData(\"application/pdfjs\");\n        if (!data) {\n            return;\n        }\n        try {\n            data = JSON.parse(data);\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n            return;\n        }\n        if (!Array.isArray(data)) {\n            return;\n        }\n        this.unselectAll();\n        const layer = this.currentLayer;\n        try {\n            const newEditors = [];\n            for (const editor of data){\n                const deserializedEditor = await layer.deserialize(editor);\n                if (!deserializedEditor) {\n                    return;\n                }\n                newEditors.push(deserializedEditor);\n            }\n            const cmd = ()=>{\n                for (const editor of newEditors){\n                    this.#addEditorToLayer(editor);\n                }\n                this.#selectEditors(newEditors);\n            };\n            const undo = ()=>{\n                for (const editor of newEditors){\n                    editor.remove();\n                }\n            };\n            this.addCommands({\n                cmd,\n                undo,\n                mustExec: true\n            });\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n        }\n    }\n    keydown(event) {\n        if (!this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = true;\n        }\n        if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {\n            AnnotationEditorUIManager._keyboardManager.exec(this, event);\n        }\n    }\n    keyup(event) {\n        if (this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = false;\n            if (this.#highlightWhenShiftUp) {\n                this.#highlightWhenShiftUp = false;\n                this.#onSelectEnd(\"main_toolbar\");\n            }\n        }\n    }\n    onEditingAction({ name }) {\n        switch(name){\n            case \"undo\":\n            case \"redo\":\n            case \"delete\":\n            case \"selectAll\":\n                this[name]();\n                break;\n            case \"highlightSelection\":\n                this.highlightSelection(\"context_menu\");\n                break;\n            case \"commentSelection\":\n                this.commentSelection(\"context_menu\");\n                break;\n        }\n    }\n    #dispatchUpdateStates(details) {\n        const hasChanged = Object.entries(details).some(([key, value])=>this.#previousStates[key] !== value);\n        if (hasChanged) {\n            this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n                source: this,\n                details: Object.assign(this.#previousStates, details)\n            });\n            if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {\n                this.#dispatchUpdateUI([\n                    [\n                        AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                        true\n                    ]\n                ]);\n            }\n        }\n    }\n    #dispatchUpdateUI(details) {\n        this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n            source: this,\n            details\n        });\n    }\n    setEditingState(isEditing) {\n        if (isEditing) {\n            this.#addFocusManager();\n            this.#addCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: this.#mode !== AnnotationEditorType.NONE,\n                isEmpty: this.#isEmpty(),\n                hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                hasSelectedEditor: false\n            });\n        } else {\n            this.#removeFocusManager();\n            this.#removeCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: false\n            });\n            this.disableUserSelect(false);\n        }\n    }\n    registerEditorTypes(types) {\n        if (this.#editorTypes) {\n            return;\n        }\n        this.#editorTypes = types;\n        for (const editorType of this.#editorTypes){\n            this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n        }\n    }\n    getId() {\n        return this.#idManager.id;\n    }\n    get currentLayer() {\n        return this.#allLayers.get(this.#currentPageIndex);\n    }\n    getLayer(pageIndex) {\n        return this.#allLayers.get(pageIndex);\n    }\n    get currentPageIndex() {\n        return this.#currentPageIndex;\n    }\n    addLayer(layer) {\n        this.#allLayers.set(layer.pageIndex, layer);\n        if (this.#isEnabled) {\n            layer.enable();\n        } else {\n            layer.disable();\n        }\n    }\n    removeLayer(layer) {\n        this.#allLayers.delete(layer.pageIndex);\n    }\n    async updateMode(mode, editId = null, isFromKeyboard = false, mustEnterInEditMode = false, editComment = false) {\n        if (this.#mode === mode) {\n            return;\n        }\n        if (this.#updateModeCapability) {\n            await this.#updateModeCapability.promise;\n            if (!this.#updateModeCapability) {\n                return;\n            }\n        }\n        this.#updateModeCapability = Promise.withResolvers();\n        this.#currentDrawingSession?.commitOrRemove();\n        if (this.#mode === AnnotationEditorType.POPUP) {\n            this.#commentManager?.hideSidebar();\n        }\n        this.#commentManager?.destroyPopup();\n        this.#mode = mode;\n        if (mode === AnnotationEditorType.NONE) {\n            this.setEditingState(false);\n            this.#disableAll();\n            for (const editor of this.#allEditors.values()){\n                editor.hideStandaloneCommentButton();\n            }\n            this._editorUndoBar?.hide();\n            this.toggleComment(null);\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        for (const editor of this.#allEditors.values()){\n            editor.addStandaloneCommentButton();\n        }\n        if (mode === AnnotationEditorType.SIGNATURE) {\n            await this.#signatureManager?.loadSignatures();\n        }\n        this.setEditingState(true);\n        await this.#enableAll();\n        this.unselectAll();\n        for (const layer of this.#allLayers.values()){\n            layer.updateMode(mode);\n        }\n        if (mode === AnnotationEditorType.POPUP) {\n            this.#allEditableAnnotations ||= await this.#pdfDocument.getAnnotationsByType(new Set(this.#editorTypes.map((editorClass)=>editorClass._editorType)));\n            const elementIds = new Set();\n            const allComments = [];\n            for (const editor of this.#allEditors.values()){\n                const { annotationElementId, hasComment, deleted } = editor;\n                if (annotationElementId) {\n                    elementIds.add(annotationElementId);\n                }\n                if (hasComment && !deleted) {\n                    allComments.push(editor.getData());\n                }\n            }\n            for (const annotation of this.#allEditableAnnotations){\n                const { id, popupRef, contentsObj } = annotation;\n                if (popupRef && contentsObj?.str && !elementIds.has(id) && !this.#deletedAnnotationsElementIds.has(id)) {\n                    allComments.push(annotation);\n                }\n            }\n            this.#commentManager?.showSidebar(allComments);\n        }\n        if (!editId) {\n            if (isFromKeyboard) {\n                this.addNewEditorFromKeyboard();\n            }\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        for (const editor of this.#allEditors.values()){\n            if (editor.uid === editId) {\n                this.setSelected(editor);\n                if (editComment) {\n                    editor.editComment();\n                } else if (mustEnterInEditMode) {\n                    editor.enterInEditMode();\n                } else {\n                    editor.focus();\n                }\n            } else {\n                editor.unselect();\n            }\n        }\n        this.#updateModeCapability.resolve();\n    }\n    addNewEditorFromKeyboard() {\n        if (this.currentLayer.canCreateNewEmptyEditor()) {\n            this.currentLayer.addNewEditor();\n        }\n    }\n    updateToolbar(options) {\n        if (options.mode === this.#mode) {\n            return;\n        }\n        this._eventBus.dispatch(\"switchannotationeditormode\", {\n            source: this,\n            ...options\n        });\n    }\n    updateParams(type, value) {\n        if (!this.#editorTypes) {\n            return;\n        }\n        switch(type){\n            case AnnotationEditorParamsType.CREATE:\n                this.currentLayer.addNewEditor(value);\n                return;\n            case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:\n                this._eventBus.dispatch(\"reporttelemetry\", {\n                    source: this,\n                    details: {\n                        type: \"editing\",\n                        data: {\n                            type: \"highlight\",\n                            action: \"toggle_visibility\"\n                        }\n                    }\n                });\n                (this.#showAllStates ||= new Map()).set(type, value);\n                this.showAllEditors(\"highlight\", value);\n                break;\n        }\n        if (this.hasSelection) {\n            for (const editor of this.#selectedEditors){\n                editor.updateParams(type, value);\n            }\n        } else {\n            for (const editorType of this.#editorTypes){\n                editorType.updateDefaultParams(type, value);\n            }\n        }\n    }\n    showAllEditors(type, visible, updateButton = false) {\n        for (const editor of this.#allEditors.values()){\n            if (editor.editorType === type) {\n                editor.show(visible);\n            }\n        }\n        const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;\n        if (state !== visible) {\n            this.#dispatchUpdateUI([\n                [\n                    AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL,\n                    visible\n                ]\n            ]);\n        }\n    }\n    enableWaiting(mustWait = false) {\n        if (this.#isWaiting === mustWait) {\n            return;\n        }\n        this.#isWaiting = mustWait;\n        for (const layer of this.#allLayers.values()){\n            if (mustWait) {\n                layer.disableClick();\n            } else {\n                layer.enableClick();\n            }\n            layer.div.classList.toggle(\"waiting\", mustWait);\n        }\n    }\n    async #enableAll() {\n        if (!this.#isEnabled) {\n            this.#isEnabled = true;\n            const promises = [];\n            for (const layer of this.#allLayers.values()){\n                promises.push(layer.enable());\n            }\n            await Promise.all(promises);\n            for (const editor of this.#allEditors.values()){\n                editor.enable();\n            }\n        }\n    }\n    #disableAll() {\n        this.unselectAll();\n        if (this.#isEnabled) {\n            this.#isEnabled = false;\n            for (const layer of this.#allLayers.values()){\n                layer.disable();\n            }\n            for (const editor of this.#allEditors.values()){\n                editor.disable();\n            }\n        }\n    }\n    *getEditors(pageIndex) {\n        for (const editor of this.#allEditors.values()){\n            if (editor.pageIndex === pageIndex) {\n                yield editor;\n            }\n        }\n    }\n    getEditor(id) {\n        return this.#allEditors.get(id);\n    }\n    addEditor(editor) {\n        this.#allEditors.set(editor.id, editor);\n    }\n    removeEditor(editor) {\n        if (editor.div.contains(document.activeElement)) {\n            if (this.#focusMainContainerTimeoutId) {\n                clearTimeout(this.#focusMainContainerTimeoutId);\n            }\n            this.#focusMainContainerTimeoutId = setTimeout(()=>{\n                this.focusMainContainer();\n                this.#focusMainContainerTimeoutId = null;\n            }, 0);\n        }\n        this.#allEditors.delete(editor.id);\n        if (editor.annotationElementId) {\n            this.#missingCanvases?.delete(editor.annotationElementId);\n        }\n        this.unselect(editor);\n        if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n            this.#annotationStorage?.remove(editor.id);\n        }\n    }\n    addDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n        this.addChangedExistingAnnotation(editor);\n        editor.deleted = true;\n    }\n    isDeletedAnnotationElement(annotationElementId) {\n        return this.#deletedAnnotationsElementIds.has(annotationElementId);\n    }\n    removeDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n        this.removeChangedExistingAnnotation(editor);\n        editor.deleted = false;\n    }\n    #addEditorToLayer(editor) {\n        const layer = this.#allLayers.get(editor.pageIndex);\n        if (layer) {\n            layer.addOrRebuild(editor);\n        } else {\n            this.addEditor(editor);\n            this.addToAnnotationStorage(editor);\n        }\n    }\n    setActiveEditor(editor) {\n        if (this.#activeEditor === editor) {\n            return;\n        }\n        this.#activeEditor = editor;\n        if (editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    get #lastSelectedEditor() {\n        let ed = null;\n        for (ed of this.#selectedEditors){}\n        return ed;\n    }\n    updateUI(editor) {\n        if (this.#lastSelectedEditor === editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    updateUIForDefaultProperties(editorType) {\n        this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n    toggleSelected(editor) {\n        if (this.#selectedEditors.has(editor)) {\n            this.#selectedEditors.delete(editor);\n            editor.unselect();\n            this.#dispatchUpdateStates({\n                hasSelectedEditor: this.hasSelection\n            });\n            return;\n        }\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    setSelected(editor) {\n        this.updateToolbar({\n            mode: editor.mode,\n            editId: editor.id\n        });\n        this.#currentDrawingSession?.commitOrRemove();\n        for (const ed of this.#selectedEditors){\n            if (ed !== editor) {\n                ed.unselect();\n            }\n        }\n        this.#selectedEditors.clear();\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    isSelected(editor) {\n        return this.#selectedEditors.has(editor);\n    }\n    get firstSelectedEditor() {\n        return this.#selectedEditors.values().next().value;\n    }\n    unselect(editor) {\n        editor.unselect();\n        this.#selectedEditors.delete(editor);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    get hasSelection() {\n        return this.#selectedEditors.size !== 0;\n    }\n    get isEnterHandled() {\n        return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;\n    }\n    undo() {\n        this.#commandManager.undo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n            hasSomethingToRedo: true,\n            isEmpty: this.#isEmpty()\n        });\n        this._editorUndoBar?.hide();\n    }\n    redo() {\n        this.#commandManager.redo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n            isEmpty: this.#isEmpty()\n        });\n    }\n    addCommands(params) {\n        this.#commandManager.add(params);\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: false,\n            isEmpty: this.#isEmpty()\n        });\n    }\n    cleanUndoStack(type) {\n        this.#commandManager.cleanType(type);\n    }\n    #isEmpty() {\n        if (this.#allEditors.size === 0) {\n            return true;\n        }\n        if (this.#allEditors.size === 1) {\n            for (const editor of this.#allEditors.values()){\n                return editor.isEmpty();\n            }\n        }\n        return false;\n    }\n    delete() {\n        this.commitOrRemove();\n        const drawingEditor = this.currentLayer?.endDrawingSession(true);\n        if (!this.hasSelection && !drawingEditor) {\n            return;\n        }\n        const editors = drawingEditor ? [\n            drawingEditor\n        ] : [\n            ...this.#selectedEditors\n        ];\n        const cmd = ()=>{\n            this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);\n            for (const editor of editors){\n                editor.remove();\n            }\n        };\n        const undo = ()=>{\n            for (const editor of editors){\n                this.#addEditorToLayer(editor);\n            }\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: true\n        });\n    }\n    commitOrRemove() {\n        this.#activeEditor?.commitOrRemove();\n    }\n    hasSomethingToControl() {\n        return this.#activeEditor || this.hasSelection;\n    }\n    #selectEditors(editors) {\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        for (const editor of editors){\n            if (editor.isEmpty()) {\n                continue;\n            }\n            this.#selectedEditors.add(editor);\n            editor.select();\n        }\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    selectAll() {\n        for (const editor of this.#selectedEditors){\n            editor.commit();\n        }\n        this.#selectEditors(this.#allEditors.values());\n    }\n    unselectAll() {\n        if (this.#activeEditor) {\n            this.#activeEditor.commitOrRemove();\n            if (this.#mode !== AnnotationEditorType.NONE) {\n                return;\n            }\n        }\n        if (this.#currentDrawingSession?.commitOrRemove()) {\n            return;\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: false\n        });\n    }\n    translateSelectedEditors(x, y, noCommit = false) {\n        if (!noCommit) {\n            this.commitOrRemove();\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        this.#translation[0] += x;\n        this.#translation[1] += y;\n        const [totalX, totalY] = this.#translation;\n        const editors = [\n            ...this.#selectedEditors\n        ];\n        const TIME_TO_WAIT = 1000;\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n        }\n        this.#translationTimeoutId = setTimeout(()=>{\n            this.#translationTimeoutId = null;\n            this.#translation[0] = this.#translation[1] = 0;\n            this.addCommands({\n                cmd: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(totalX, totalY);\n                            editor.translationDone();\n                        }\n                    }\n                },\n                undo: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(-totalX, -totalY);\n                            editor.translationDone();\n                        }\n                    }\n                },\n                mustExec: false\n            });\n        }, TIME_TO_WAIT);\n        for (const editor of editors){\n            editor.translateInPage(x, y);\n            editor.translationDone();\n        }\n    }\n    setUpDragSession() {\n        if (!this.hasSelection) {\n            return;\n        }\n        this.disableUserSelect(true);\n        this.#draggingEditors = new Map();\n        for (const editor of this.#selectedEditors){\n            this.#draggingEditors.set(editor, {\n                savedX: editor.x,\n                savedY: editor.y,\n                savedPageIndex: editor.pageIndex,\n                newX: 0,\n                newY: 0,\n                newPageIndex: -1\n            });\n        }\n    }\n    endDragSession() {\n        if (!this.#draggingEditors) {\n            return false;\n        }\n        this.disableUserSelect(false);\n        const map = this.#draggingEditors;\n        this.#draggingEditors = null;\n        let mustBeAddedInUndoStack = false;\n        for (const [{ x, y, pageIndex }, value] of map){\n            value.newX = x;\n            value.newY = y;\n            value.newPageIndex = pageIndex;\n            mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n        }\n        if (!mustBeAddedInUndoStack) {\n            return false;\n        }\n        const move = (editor, x, y, pageIndex)=>{\n            if (this.#allEditors.has(editor.id)) {\n                const parent = this.#allLayers.get(pageIndex);\n                if (parent) {\n                    editor._setParentAndPosition(parent, x, y);\n                } else {\n                    editor.pageIndex = pageIndex;\n                    editor.x = x;\n                    editor.y = y;\n                }\n            }\n        };\n        this.addCommands({\n            cmd: ()=>{\n                for (const [editor, { newX, newY, newPageIndex }] of map){\n                    move(editor, newX, newY, newPageIndex);\n                }\n            },\n            undo: ()=>{\n                for (const [editor, { savedX, savedY, savedPageIndex }] of map){\n                    move(editor, savedX, savedY, savedPageIndex);\n                }\n            },\n            mustExec: true\n        });\n        return true;\n    }\n    dragSelectedEditors(tx, ty) {\n        if (!this.#draggingEditors) {\n            return;\n        }\n        for (const editor of this.#draggingEditors.keys()){\n            editor.drag(tx, ty);\n        }\n    }\n    rebuild(editor) {\n        if (editor.parent === null) {\n            const parent = this.getLayer(editor.pageIndex);\n            if (parent) {\n                parent.changeParent(editor);\n                parent.addOrRebuild(editor);\n            } else {\n                this.addEditor(editor);\n                this.addToAnnotationStorage(editor);\n                editor.rebuild();\n            }\n        } else {\n            editor.parent.addOrRebuild(editor);\n        }\n    }\n    get isEditorHandlingKeyboard() {\n        return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();\n    }\n    isActive(editor) {\n        return this.#activeEditor === editor;\n    }\n    getActive() {\n        return this.#activeEditor;\n    }\n    getMode() {\n        return this.#mode;\n    }\n    isEditingMode() {\n        return this.#mode !== AnnotationEditorType.NONE;\n    }\n    get imageManager() {\n        return shadow(this, \"imageManager\", new ImageManager());\n    }\n    getSelectionBoxes(textLayer) {\n        if (!textLayer) {\n            return null;\n        }\n        const selection = document.getSelection();\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {\n                return null;\n            }\n        }\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        let rotator;\n        switch(textLayer.getAttribute(\"data-main-rotation\")){\n            case \"90\":\n                rotator = (x, y, w, h)=>({\n                        x: (y - layerY) / parentHeight,\n                        y: 1 - (x + w - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            case \"180\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (x + w - layerX) / parentWidth,\n                        y: 1 - (y + h - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n            case \"270\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (y + h - layerY) / parentHeight,\n                        y: (x - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            default:\n                rotator = (x, y, w, h)=>({\n                        x: (x - layerX) / parentWidth,\n                        y: (y - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n        }\n        const boxes = [];\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            const range = selection.getRangeAt(i);\n            if (range.collapsed) {\n                continue;\n            }\n            for (const { x, y, width, height } of range.getClientRects()){\n                if (width === 0 || height === 0) {\n                    continue;\n                }\n                boxes.push(rotator(x, y, width, height));\n            }\n        }\n        return boxes.length === 0 ? null : boxes;\n    }\n    addChangedExistingAnnotation({ annotationElementId, id }) {\n        (this.#changedExistingAnnotations ||= new Map()).set(annotationElementId, id);\n    }\n    removeChangedExistingAnnotation({ annotationElementId }) {\n        this.#changedExistingAnnotations?.delete(annotationElementId);\n    }\n    renderAnnotationElement(annotation) {\n        const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);\n        if (!editorId) {\n            return;\n        }\n        const editor = this.#annotationStorage.getRawValue(editorId);\n        if (!editor) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {\n            return;\n        }\n        editor.renderAnnotationElement(annotation);\n    }\n    setMissingCanvas(annotationId, annotationElementId, canvas) {\n        const editor = this.#missingCanvases?.get(annotationId);\n        if (!editor) {\n            return;\n        }\n        editor.setCanvas(annotationElementId, canvas);\n        this.#missingCanvases.delete(annotationId);\n    }\n    addMissingCanvas(annotationId, editor) {\n        (this.#missingCanvases ||= new Map()).set(annotationId, editor);\n    }\n}\n; // ./src/display/editor/alt_text.js\nclass AltText {\n    #altText;\n    #altTextDecorative;\n    #altTextButton;\n    #altTextButtonLabel;\n    #altTextTooltip;\n    #altTextTooltipTimeout;\n    #altTextWasFromKeyBoard;\n    #badge;\n    #editor;\n    #guessedText;\n    #textWithDisclaimer;\n    #useNewAltTextFlow;\n    static #l10nNewButton = null;\n    static{\n        this._l10n = null;\n    }\n    constructor(editor){\n        this.#altText = null;\n        this.#altTextDecorative = false;\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#altTextTooltipTimeout = null;\n        this.#altTextWasFromKeyBoard = false;\n        this.#badge = null;\n        this.#editor = null;\n        this.#guessedText = null;\n        this.#textWithDisclaimer = null;\n        this.#useNewAltTextFlow = false;\n        this.#editor = editor;\n        this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;\n        AltText.#l10nNewButton ||= Object.freeze({\n            added: \"pdfjs-editor-new-alt-text-added-button\",\n            \"added-label\": \"pdfjs-editor-new-alt-text-added-button-label\",\n            missing: \"pdfjs-editor-new-alt-text-missing-button\",\n            \"missing-label\": \"pdfjs-editor-new-alt-text-missing-button-label\",\n            review: \"pdfjs-editor-new-alt-text-to-review-button\",\n            \"review-label\": \"pdfjs-editor-new-alt-text-to-review-button-label\"\n        });\n    }\n    static initialize(l10n) {\n        AltText._l10n ??= l10n;\n    }\n    async render() {\n        const altText = this.#altTextButton = document.createElement(\"button\");\n        altText.className = \"altText\";\n        altText.tabIndex = \"0\";\n        const label = this.#altTextButtonLabel = document.createElement(\"span\");\n        altText.append(label);\n        if (this.#useNewAltTextFlow) {\n            altText.classList.add(\"new\");\n            altText.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton.missing);\n            label.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[\"missing-label\"]);\n        } else {\n            altText.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button\");\n            label.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button-label\");\n        }\n        const signal = this.#editor._uiManager._signal;\n        altText.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        altText.addEventListener(\"pointerdown\", (event)=>event.stopPropagation(), {\n            signal\n        });\n        const onClick = (event)=>{\n            event.preventDefault();\n            this.#editor._uiManager.editAltText(this.#editor);\n            if (this.#useNewAltTextFlow) {\n                this.#editor._reportTelemetry({\n                    action: \"pdfjs.image.alt_text.image_status_label_clicked\",\n                    data: {\n                        label: this.#label\n                    }\n                });\n            }\n        };\n        altText.addEventListener(\"click\", onClick, {\n            capture: true,\n            signal\n        });\n        altText.addEventListener(\"keydown\", (event)=>{\n            if (event.target === altText && event.key === \"Enter\") {\n                this.#altTextWasFromKeyBoard = true;\n                onClick(event);\n            }\n        }, {\n            signal\n        });\n        await this.#setState();\n        return altText;\n    }\n    get #label() {\n        return this.#altText && \"added\" || this.#altText === null && this.guessedText && \"review\" || \"missing\";\n    }\n    finish() {\n        if (!this.#altTextButton) {\n            return;\n        }\n        this.#altTextButton.focus({\n            focusVisible: this.#altTextWasFromKeyBoard\n        });\n        this.#altTextWasFromKeyBoard = false;\n    }\n    isEmpty() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText === null;\n        }\n        return !this.#altText && !this.#altTextDecorative;\n    }\n    hasData() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText !== null || !!this.#guessedText;\n        }\n        return this.isEmpty();\n    }\n    get guessedText() {\n        return this.#guessedText;\n    }\n    async setGuessedText(guessedText) {\n        if (this.#altText !== null) {\n            return;\n        }\n        this.#guessedText = guessedText;\n        this.#textWithDisclaimer = await AltText._l10n.get(\"pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer\", {\n            generatedAltText: guessedText\n        });\n        this.#setState();\n    }\n    toggleAltTextBadge(visibility = false) {\n        if (!this.#useNewAltTextFlow || this.#altText) {\n            this.#badge?.remove();\n            this.#badge = null;\n            return;\n        }\n        if (!this.#badge) {\n            const badge = this.#badge = document.createElement(\"div\");\n            badge.className = \"noAltTextBadge\";\n            this.#editor.div.append(badge);\n        }\n        this.#badge.classList.toggle(\"hidden\", !visibility);\n    }\n    serialize(isForCopying) {\n        let altText = this.#altText;\n        if (!isForCopying && this.#guessedText === altText) {\n            altText = this.#textWithDisclaimer;\n        }\n        return {\n            altText,\n            decorative: this.#altTextDecorative,\n            guessedText: this.#guessedText,\n            textWithDisclaimer: this.#textWithDisclaimer\n        };\n    }\n    get data() {\n        return {\n            altText: this.#altText,\n            decorative: this.#altTextDecorative\n        };\n    }\n    set data({ altText, decorative, guessedText, textWithDisclaimer, cancel = false }) {\n        if (guessedText) {\n            this.#guessedText = guessedText;\n            this.#textWithDisclaimer = textWithDisclaimer;\n        }\n        if (this.#altText === altText && this.#altTextDecorative === decorative) {\n            return;\n        }\n        if (!cancel) {\n            this.#altText = altText;\n            this.#altTextDecorative = decorative;\n        }\n        this.#setState();\n    }\n    toggle(enabled = false) {\n        if (!this.#altTextButton) {\n            return;\n        }\n        if (!enabled && this.#altTextTooltipTimeout) {\n            clearTimeout(this.#altTextTooltipTimeout);\n            this.#altTextTooltipTimeout = null;\n        }\n        this.#altTextButton.disabled = !enabled;\n    }\n    shown() {\n        this.#editor._reportTelemetry({\n            action: \"pdfjs.image.alt_text.image_status_label_displayed\",\n            data: {\n                label: this.#label\n            }\n        });\n    }\n    destroy() {\n        this.#altTextButton?.remove();\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#badge?.remove();\n        this.#badge = null;\n    }\n    async #setState() {\n        const button = this.#altTextButton;\n        if (!button) {\n            return;\n        }\n        if (this.#useNewAltTextFlow) {\n            button.classList.toggle(\"done\", !!this.#altText);\n            button.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[this.#label]);\n            this.#altTextButtonLabel?.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[`${this.#label}-label`]);\n            if (!this.#altText) {\n                this.#altTextTooltip?.remove();\n                return;\n            }\n        } else {\n            if (!this.#altText && !this.#altTextDecorative) {\n                button.classList.remove(\"done\");\n                this.#altTextTooltip?.remove();\n                return;\n            }\n            button.classList.add(\"done\");\n            button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-edit-button\");\n        }\n        let tooltip = this.#altTextTooltip;\n        if (!tooltip) {\n            this.#altTextTooltip = tooltip = document.createElement(\"span\");\n            tooltip.className = \"tooltip\";\n            tooltip.setAttribute(\"role\", \"tooltip\");\n            tooltip.id = `alt-text-tooltip-${this.#editor.id}`;\n            const DELAY_TO_SHOW_TOOLTIP = 100;\n            const signal = this.#editor._uiManager._signal;\n            signal.addEventListener(\"abort\", ()=>{\n                clearTimeout(this.#altTextTooltipTimeout);\n                this.#altTextTooltipTimeout = null;\n            }, {\n                once: true\n            });\n            button.addEventListener(\"mouseenter\", ()=>{\n                this.#altTextTooltipTimeout = setTimeout(()=>{\n                    this.#altTextTooltipTimeout = null;\n                    this.#altTextTooltip.classList.add(\"show\");\n                    this.#editor._reportTelemetry({\n                        action: \"alt_text_tooltip\"\n                    });\n                }, DELAY_TO_SHOW_TOOLTIP);\n            }, {\n                signal\n            });\n            button.addEventListener(\"mouseleave\", ()=>{\n                if (this.#altTextTooltipTimeout) {\n                    clearTimeout(this.#altTextTooltipTimeout);\n                    this.#altTextTooltipTimeout = null;\n                }\n                this.#altTextTooltip?.classList.remove(\"show\");\n            }, {\n                signal\n            });\n        }\n        if (this.#altTextDecorative) {\n            tooltip.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-decorative-tooltip\");\n        } else {\n            tooltip.removeAttribute(\"data-l10n-id\");\n            tooltip.textContent = this.#altText;\n        }\n        if (!tooltip.parentNode) {\n            button.append(tooltip);\n        }\n        const element = this.#editor.getElementForAltText();\n        element?.setAttribute(\"aria-describedby\", tooltip.id);\n    }\n}\n; // ./src/display/editor/comment.js\nclass Comment {\n    #commentStandaloneButton;\n    #commentToolbarButton;\n    #commentWasFromKeyBoard;\n    #editor;\n    #initialText;\n    #richText;\n    #text;\n    #date;\n    #deleted;\n    #popupPosition;\n    constructor(editor){\n        this.#commentStandaloneButton = null;\n        this.#commentToolbarButton = null;\n        this.#commentWasFromKeyBoard = false;\n        this.#editor = null;\n        this.#initialText = null;\n        this.#richText = null;\n        this.#text = null;\n        this.#date = null;\n        this.#deleted = false;\n        this.#popupPosition = null;\n        this.#editor = editor;\n    }\n    renderForToolbar() {\n        const button = this.#commentToolbarButton = document.createElement(\"button\");\n        button.className = \"comment\";\n        return this.#render(button, false);\n    }\n    renderForStandalone() {\n        const button = this.#commentStandaloneButton = document.createElement(\"button\");\n        button.className = \"annotationCommentButton\";\n        const position = this.#editor.commentButtonPosition;\n        if (position) {\n            const { style } = button;\n            style.insetInlineEnd = `calc(${100 * (this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0])}% - var(--comment-button-dim))`;\n            style.top = `calc(${100 * position[1]}% - var(--comment-button-dim))`;\n            const color = this.#editor.commentButtonColor;\n            if (color) {\n                style.backgroundColor = color;\n            }\n        }\n        return this.#render(button, true);\n    }\n    focusButton() {\n        setTimeout(()=>{\n            (this.#commentStandaloneButton ?? this.#commentToolbarButton)?.focus();\n        }, 0);\n    }\n    onUpdatedColor() {\n        if (!this.#commentStandaloneButton) {\n            return;\n        }\n        const color = this.#editor.commentButtonColor;\n        if (color) {\n            this.#commentStandaloneButton.style.backgroundColor = color;\n        }\n        this.#editor._uiManager.updatePopupColor(this.#editor);\n    }\n    get commentButtonWidth() {\n        return (this.#commentStandaloneButton?.getBoundingClientRect().width ?? 0) / this.#editor.parent.boundingClientRect.width;\n    }\n    get commentPopupPositionInLayer() {\n        if (this.#popupPosition) {\n            return this.#popupPosition;\n        }\n        if (!this.#commentStandaloneButton) {\n            return null;\n        }\n        const { x, y, height } = this.#commentStandaloneButton.getBoundingClientRect();\n        const { x: parentX, y: parentY, width: parentWidth, height: parentHeight } = this.#editor.parent.boundingClientRect;\n        return [\n            (x - parentX) / parentWidth,\n            (y + height - parentY) / parentHeight\n        ];\n    }\n    set commentPopupPositionInLayer(pos) {\n        this.#popupPosition = pos;\n    }\n    hasDefaultPopupPosition() {\n        return this.#popupPosition === null;\n    }\n    removeStandaloneCommentButton() {\n        this.#commentStandaloneButton?.remove();\n        this.#commentStandaloneButton = null;\n    }\n    removeToolbarCommentButton() {\n        this.#commentToolbarButton?.remove();\n        this.#commentToolbarButton = null;\n    }\n    setCommentButtonStates({ selected, hasPopup }) {\n        if (!this.#commentStandaloneButton) {\n            return;\n        }\n        this.#commentStandaloneButton.classList.toggle(\"selected\", selected);\n        this.#commentStandaloneButton.ariaExpanded = hasPopup;\n    }\n    #render(comment, isStandalone) {\n        if (!this.#editor._uiManager.hasCommentManager()) {\n            return null;\n        }\n        comment.tabIndex = \"0\";\n        comment.ariaHasPopup = \"dialog\";\n        if (isStandalone) {\n            comment.ariaControls = \"commentPopup\";\n            comment.setAttribute(\"data-l10n-id\", \"pdfjs-show-comment-button\");\n        } else {\n            comment.ariaControlsElements = [\n                this.#editor._uiManager.getCommentDialogElement()\n            ];\n            comment.setAttribute(\"data-l10n-id\", \"pdfjs-editor-edit-comment-button\");\n        }\n        const signal = this.#editor._uiManager._signal;\n        if (!(signal instanceof AbortSignal) || signal.aborted) {\n            return comment;\n        }\n        comment.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        if (isStandalone) {\n            comment.addEventListener(\"focusin\", (e)=>{\n                this.#editor._focusEventsAllowed = false;\n                stopEvent(e);\n            }, {\n                capture: true,\n                signal\n            });\n            comment.addEventListener(\"focusout\", (e)=>{\n                this.#editor._focusEventsAllowed = true;\n                stopEvent(e);\n            }, {\n                capture: true,\n                signal\n            });\n        }\n        comment.addEventListener(\"pointerdown\", (event)=>event.stopPropagation(), {\n            signal\n        });\n        const onClick = (event)=>{\n            event.preventDefault();\n            if (comment === this.#commentToolbarButton) {\n                this.edit();\n            } else {\n                this.#editor.toggleComment(true);\n            }\n        };\n        comment.addEventListener(\"click\", onClick, {\n            capture: true,\n            signal\n        });\n        comment.addEventListener(\"keydown\", (event)=>{\n            if (event.target === comment && event.key === \"Enter\") {\n                this.#commentWasFromKeyBoard = true;\n                onClick(event);\n            }\n        }, {\n            signal\n        });\n        comment.addEventListener(\"pointerenter\", ()=>{\n            this.#editor.toggleComment(false, true);\n        }, {\n            signal\n        });\n        comment.addEventListener(\"pointerleave\", ()=>{\n            this.#editor.toggleComment(false, false);\n        }, {\n            signal\n        });\n        return comment;\n    }\n    edit(options) {\n        const position = this.commentPopupPositionInLayer;\n        let posX, posY;\n        if (position) {\n            [posX, posY] = position;\n        } else {\n            [posX, posY] = this.#editor.commentButtonPosition;\n            const { width, height, x, y } = this.#editor;\n            posX = x + posX * width;\n            posY = y + posY * height;\n        }\n        const parentDimensions = this.#editor.parent.boundingClientRect;\n        const { x: parentX, y: parentY, width: parentWidth, height: parentHeight } = parentDimensions;\n        this.#editor._uiManager.editComment(this.#editor, parentX + posX * parentWidth, parentY + posY * parentHeight, {\n            ...options,\n            parentDimensions\n        });\n    }\n    finish() {\n        if (!this.#commentToolbarButton) {\n            return;\n        }\n        this.#commentToolbarButton.focus({\n            focusVisible: this.#commentWasFromKeyBoard\n        });\n        this.#commentWasFromKeyBoard = false;\n    }\n    isDeleted() {\n        return this.#deleted || this.#text === \"\";\n    }\n    isEmpty() {\n        return this.#text === null;\n    }\n    hasBeenEdited() {\n        return this.isDeleted() || this.#text !== this.#initialText;\n    }\n    serialize() {\n        return this.data;\n    }\n    get data() {\n        return {\n            text: this.#text,\n            richText: this.#richText,\n            date: this.#date,\n            deleted: this.isDeleted()\n        };\n    }\n    set data(text) {\n        if (text !== this.#text) {\n            this.#richText = null;\n        }\n        if (text === null) {\n            this.#text = \"\";\n            this.#deleted = true;\n            return;\n        }\n        this.#text = text;\n        this.#date = new Date();\n        this.#deleted = false;\n    }\n    setInitialText(text, richText = null) {\n        this.#initialText = text;\n        this.data = text;\n        this.#date = null;\n        this.#richText = richText;\n    }\n    shown() {}\n    destroy() {\n        this.#commentToolbarButton?.remove();\n        this.#commentToolbarButton = null;\n        this.#commentStandaloneButton?.remove();\n        this.#commentStandaloneButton = null;\n        this.#text = \"\";\n        this.#richText = null;\n        this.#date = null;\n        this.#editor = null;\n        this.#commentWasFromKeyBoard = false;\n        this.#deleted = false;\n    }\n}\n; // ./src/display/touch_manager.js\nclass TouchManager {\n    #container;\n    #isPinching;\n    #isPinchingStopped;\n    #isPinchingDisabled;\n    #onPinchStart;\n    #onPinching;\n    #onPinchEnd;\n    #pointerDownAC;\n    #signal;\n    #touchInfo;\n    #touchManagerAC;\n    #touchMoveAC;\n    constructor({ container, isPinchingDisabled = null, isPinchingStopped = null, onPinchStart = null, onPinching = null, onPinchEnd = null, signal }){\n        this.#isPinching = false;\n        this.#isPinchingStopped = null;\n        this.#pointerDownAC = null;\n        this.#touchInfo = null;\n        this.#touchMoveAC = null;\n        this.#container = container;\n        this.#isPinchingStopped = isPinchingStopped;\n        this.#isPinchingDisabled = isPinchingDisabled;\n        this.#onPinchStart = onPinchStart;\n        this.#onPinching = onPinching;\n        this.#onPinchEnd = onPinchEnd;\n        this.#touchManagerAC = new AbortController();\n        this.#signal = AbortSignal.any([\n            signal,\n            this.#touchManagerAC.signal\n        ]);\n        container.addEventListener(\"touchstart\", this.#onTouchStart.bind(this), {\n            passive: false,\n            signal: this.#signal\n        });\n    }\n    get MIN_TOUCH_DISTANCE_TO_PINCH() {\n        return 35 / OutputScale.pixelRatio;\n    }\n    #onTouchStart(evt) {\n        if (this.#isPinchingDisabled?.()) {\n            return;\n        }\n        if (evt.touches.length === 1) {\n            if (this.#pointerDownAC) {\n                return;\n            }\n            const pointerDownAC = this.#pointerDownAC = new AbortController();\n            const signal = AbortSignal.any([\n                this.#signal,\n                pointerDownAC.signal\n            ]);\n            const container = this.#container;\n            const opts = {\n                capture: true,\n                signal,\n                passive: false\n            };\n            const cancelPointerDown = (e)=>{\n                if (e.pointerType === \"touch\") {\n                    this.#pointerDownAC?.abort();\n                    this.#pointerDownAC = null;\n                }\n            };\n            container.addEventListener(\"pointerdown\", (e)=>{\n                if (e.pointerType === \"touch\") {\n                    stopEvent(e);\n                    cancelPointerDown(e);\n                }\n            }, opts);\n            container.addEventListener(\"pointerup\", cancelPointerDown, opts);\n            container.addEventListener(\"pointercancel\", cancelPointerDown, opts);\n            return;\n        }\n        if (!this.#touchMoveAC) {\n            this.#touchMoveAC = new AbortController();\n            const signal = AbortSignal.any([\n                this.#signal,\n                this.#touchMoveAC.signal\n            ]);\n            const container = this.#container;\n            const opt = {\n                signal,\n                capture: false,\n                passive: false\n            };\n            container.addEventListener(\"touchmove\", this.#onTouchMove.bind(this), opt);\n            const onTouchEnd = this.#onTouchEnd.bind(this);\n            container.addEventListener(\"touchend\", onTouchEnd, opt);\n            container.addEventListener(\"touchcancel\", onTouchEnd, opt);\n            opt.capture = true;\n            container.addEventListener(\"pointerdown\", stopEvent, opt);\n            container.addEventListener(\"pointermove\", stopEvent, opt);\n            container.addEventListener(\"pointercancel\", stopEvent, opt);\n            container.addEventListener(\"pointerup\", stopEvent, opt);\n            this.#onPinchStart?.();\n        }\n        stopEvent(evt);\n        if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {\n            this.#touchInfo = null;\n            return;\n        }\n        let [touch0, touch1] = evt.touches;\n        if (touch0.identifier > touch1.identifier) {\n            [touch0, touch1] = [\n                touch1,\n                touch0\n            ];\n        }\n        this.#touchInfo = {\n            touch0X: touch0.screenX,\n            touch0Y: touch0.screenY,\n            touch1X: touch1.screenX,\n            touch1Y: touch1.screenY\n        };\n    }\n    #onTouchMove(evt) {\n        if (!this.#touchInfo || evt.touches.length !== 2) {\n            return;\n        }\n        stopEvent(evt);\n        let [touch0, touch1] = evt.touches;\n        if (touch0.identifier > touch1.identifier) {\n            [touch0, touch1] = [\n                touch1,\n                touch0\n            ];\n        }\n        const { screenX: screen0X, screenY: screen0Y } = touch0;\n        const { screenX: screen1X, screenY: screen1Y } = touch1;\n        const touchInfo = this.#touchInfo;\n        const { touch0X: pTouch0X, touch0Y: pTouch0Y, touch1X: pTouch1X, touch1Y: pTouch1Y } = touchInfo;\n        const prevGapX = pTouch1X - pTouch0X;\n        const prevGapY = pTouch1Y - pTouch0Y;\n        const currGapX = screen1X - screen0X;\n        const currGapY = screen1Y - screen0Y;\n        const distance = Math.hypot(currGapX, currGapY) || 1;\n        const pDistance = Math.hypot(prevGapX, prevGapY) || 1;\n        if (!this.#isPinching && Math.abs(pDistance - distance) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {\n            return;\n        }\n        touchInfo.touch0X = screen0X;\n        touchInfo.touch0Y = screen0Y;\n        touchInfo.touch1X = screen1X;\n        touchInfo.touch1Y = screen1Y;\n        if (!this.#isPinching) {\n            this.#isPinching = true;\n            return;\n        }\n        const origin = [\n            (screen0X + screen1X) / 2,\n            (screen0Y + screen1Y) / 2\n        ];\n        this.#onPinching?.(origin, pDistance, distance);\n    }\n    #onTouchEnd(evt) {\n        if (evt.touches.length >= 2) {\n            return;\n        }\n        if (this.#touchMoveAC) {\n            this.#touchMoveAC.abort();\n            this.#touchMoveAC = null;\n            this.#onPinchEnd?.();\n        }\n        if (!this.#touchInfo) {\n            return;\n        }\n        stopEvent(evt);\n        this.#touchInfo = null;\n        this.#isPinching = false;\n    }\n    destroy() {\n        this.#touchManagerAC?.abort();\n        this.#touchManagerAC = null;\n        this.#pointerDownAC?.abort();\n        this.#pointerDownAC = null;\n    }\n}\n; // ./src/display/editor/editor.js\nclass AnnotationEditor {\n    #accessibilityData;\n    #allResizerDivs;\n    #altText;\n    #comment;\n    #commentStandaloneButton;\n    #disabled;\n    #dragPointerId;\n    #dragPointerType;\n    #resizersDiv;\n    #lastPointerCoords;\n    #savedDimensions;\n    #fakeAnnotation;\n    #focusAC;\n    #focusedResizerName;\n    #hasBeenClicked;\n    #initialRect;\n    #isEditing;\n    #isInEditMode;\n    #isResizerEnabledForKeyboard;\n    #moveInDOMTimeout;\n    #prevDragX;\n    #prevDragY;\n    #telemetryTimeouts;\n    #touchManager;\n    static{\n        this._l10n = null;\n    }\n    static{\n        this._l10nResizer = null;\n    }\n    #isDraggable;\n    #zIndex;\n    static{\n        this._borderLineWidth = -1;\n    }\n    static{\n        this._colorManager = new ColorManager();\n    }\n    static{\n        this._zIndex = 1;\n    }\n    static{\n        this._telemetryTimeout = 1000;\n    }\n    static get _resizerKeyboardManager() {\n        const resize = AnnotationEditor.prototype._resizeWithKeyboard;\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_resizerKeyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                AnnotationEditor.prototype._stopResizingWithKeyboard\n            ]\n        ]));\n    }\n    constructor(parameters){\n        this.#accessibilityData = null;\n        this.#allResizerDivs = null;\n        this.#altText = null;\n        this.#comment = null;\n        this.#commentStandaloneButton = null;\n        this.#disabled = false;\n        this.#dragPointerId = null;\n        this.#dragPointerType = \"\";\n        this.#resizersDiv = null;\n        this.#lastPointerCoords = null;\n        this.#savedDimensions = null;\n        this.#fakeAnnotation = null;\n        this.#focusAC = null;\n        this.#focusedResizerName = \"\";\n        this.#hasBeenClicked = false;\n        this.#initialRect = null;\n        this.#isEditing = false;\n        this.#isInEditMode = false;\n        this.#isResizerEnabledForKeyboard = false;\n        this.#moveInDOMTimeout = null;\n        this.#prevDragX = 0;\n        this.#prevDragY = 0;\n        this.#telemetryTimeouts = null;\n        this.#touchManager = null;\n        this.isSelected = false;\n        this._isCopy = false;\n        this._editToolbar = null;\n        this._initialOptions = Object.create(null);\n        this._initialData = null;\n        this._isVisible = true;\n        this._uiManager = null;\n        this._focusEventsAllowed = true;\n        this.#isDraggable = false;\n        this.#zIndex = AnnotationEditor._zIndex++;\n        this.parent = parameters.parent;\n        this.id = parameters.id;\n        this.width = this.height = null;\n        this.pageIndex = parameters.parent.pageIndex;\n        this.name = parameters.name;\n        this.div = null;\n        this._uiManager = parameters.uiManager;\n        this.annotationElementId = null;\n        this._willKeepAspectRatio = false;\n        this._initialOptions.isCentered = parameters.isCentered;\n        this._structTreeParentId = null;\n        this.annotationElementId = parameters.annotationElementId || null;\n        this.creationDate = parameters.creationDate || new Date();\n        this.modificationDate = parameters.modificationDate || null;\n        const { rotation, rawDims: { pageWidth, pageHeight, pageX, pageY } } = this.parent.viewport;\n        this.rotation = rotation;\n        this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n        this.pageDimensions = [\n            pageWidth,\n            pageHeight\n        ];\n        this.pageTranslation = [\n            pageX,\n            pageY\n        ];\n        const [width, height] = this.parentDimensions;\n        this.x = parameters.x / width;\n        this.y = parameters.y / height;\n        this.isAttachedToDOM = false;\n        this.deleted = false;\n    }\n    get editorType() {\n        return Object.getPrototypeOf(this).constructor._type;\n    }\n    get mode() {\n        return Object.getPrototypeOf(this).constructor._editorType;\n    }\n    static get isDrawer() {\n        return false;\n    }\n    static get _defaultLineColor() {\n        return shadow(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n    }\n    static deleteAnnotationElement(editor) {\n        const fakeEditor = new FakeEditor({\n            id: editor.parent.getNextId(),\n            parent: editor.parent,\n            uiManager: editor._uiManager\n        });\n        fakeEditor.annotationElementId = editor.annotationElementId;\n        fakeEditor.deleted = true;\n        fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n    }\n    static initialize(l10n, _uiManager) {\n        AnnotationEditor._l10n ??= l10n;\n        AnnotationEditor._l10nResizer ||= Object.freeze({\n            topLeft: \"pdfjs-editor-resizer-top-left\",\n            topMiddle: \"pdfjs-editor-resizer-top-middle\",\n            topRight: \"pdfjs-editor-resizer-top-right\",\n            middleRight: \"pdfjs-editor-resizer-middle-right\",\n            bottomRight: \"pdfjs-editor-resizer-bottom-right\",\n            bottomMiddle: \"pdfjs-editor-resizer-bottom-middle\",\n            bottomLeft: \"pdfjs-editor-resizer-bottom-left\",\n            middleLeft: \"pdfjs-editor-resizer-middle-left\"\n        });\n        if (AnnotationEditor._borderLineWidth !== -1) {\n            return;\n        }\n        const style = getComputedStyle(document.documentElement);\n        AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n    }\n    static updateDefaultParams(_type, _value) {}\n    static get defaultPropertiesToUpdate() {\n        return [];\n    }\n    static isHandlingMimeForPasting(mime) {\n        return false;\n    }\n    static paste(item, parent) {\n        unreachable(\"Not implemented\");\n    }\n    get propertiesToUpdate() {\n        return [];\n    }\n    get _isDraggable() {\n        return this.#isDraggable;\n    }\n    set _isDraggable(value) {\n        this.#isDraggable = value;\n        this.div?.classList.toggle(\"draggable\", value);\n    }\n    get uid() {\n        return this.annotationElementId || this.id;\n    }\n    get isEnterHandled() {\n        return true;\n    }\n    center() {\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        switch(this.parentRotation){\n            case 90:\n                this.x -= this.height * pageHeight / (pageWidth * 2);\n                this.y += this.width * pageWidth / (pageHeight * 2);\n                break;\n            case 180:\n                this.x += this.width / 2;\n                this.y += this.height / 2;\n                break;\n            case 270:\n                this.x += this.height * pageHeight / (pageWidth * 2);\n                this.y -= this.width * pageWidth / (pageHeight * 2);\n                break;\n            default:\n                this.x -= this.width / 2;\n                this.y -= this.height / 2;\n                break;\n        }\n        this.fixAndSetPosition();\n    }\n    addCommands(params) {\n        this._uiManager.addCommands(params);\n    }\n    get currentLayer() {\n        return this._uiManager.currentLayer;\n    }\n    setInBackground() {\n        this.div.style.zIndex = 0;\n    }\n    setInForeground() {\n        this.div.style.zIndex = this.#zIndex;\n    }\n    setParent(parent) {\n        if (parent !== null) {\n            this.pageIndex = parent.pageIndex;\n            this.pageDimensions = parent.pageDimensions;\n        } else {\n            this.#stopResizing();\n            this.#fakeAnnotation?.remove();\n            this.#fakeAnnotation = null;\n        }\n        this.parent = parent;\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.#hasBeenClicked) {\n            this.parent.setSelected(this);\n        } else {\n            this.#hasBeenClicked = false;\n        }\n    }\n    focusout(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            return;\n        }\n        const target = event.relatedTarget;\n        if (target?.closest(`#${this.id}`)) {\n            return;\n        }\n        event.preventDefault();\n        if (!this.parent?.isMultipleSelection) {\n            this.commitOrRemove();\n        }\n    }\n    commitOrRemove() {\n        if (this.isEmpty()) {\n            this.remove();\n        } else {\n            this.commit();\n        }\n    }\n    commit() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        this.addToAnnotationStorage();\n    }\n    addToAnnotationStorage() {\n        this._uiManager.addToAnnotationStorage(this);\n    }\n    setAt(x, y, tx, ty) {\n        const [width, height] = this.parentDimensions;\n        [tx, ty] = this.screenToPageTranslation(tx, ty);\n        this.x = (x + tx) / width;\n        this.y = (y + ty) / height;\n        this.fixAndSetPosition();\n    }\n    _moveAfterPaste(baseX, baseY) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n        this._onTranslated();\n    }\n    #translate([width, height], x, y) {\n        [x, y] = this.screenToPageTranslation(x, y);\n        this.x += x / width;\n        this.y += y / height;\n        this._onTranslating(this.x, this.y);\n        this.fixAndSetPosition();\n    }\n    translate(x, y) {\n        this.#translate(this.parentDimensions, x, y);\n    }\n    translateInPage(x, y) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.#translate(this.pageDimensions, x, y);\n        this.div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    translationDone() {\n        this._onTranslated(this.x, this.y);\n    }\n    drag(tx, ty) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        const { div, parentDimensions: [parentWidth, parentHeight] } = this;\n        this.x += tx / parentWidth;\n        this.y += ty / parentHeight;\n        if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n            const { x, y } = this.div.getBoundingClientRect();\n            if (this.parent.findNewParent(this, x, y)) {\n                this.x -= Math.floor(this.x);\n                this.y -= Math.floor(this.y);\n            }\n        }\n        let { x, y } = this;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        const { style } = div;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this._onTranslating(x, y);\n        div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    _onTranslating(x, y) {}\n    _onTranslated(x, y) {}\n    get _hasBeenMoved() {\n        return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);\n    }\n    get _hasBeenResized() {\n        return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);\n    }\n    getBaseTranslation() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { _borderLineWidth } = AnnotationEditor;\n        const x = _borderLineWidth / parentWidth;\n        const y = _borderLineWidth / parentHeight;\n        switch(this.rotation){\n            case 90:\n                return [\n                    -x,\n                    y\n                ];\n            case 180:\n                return [\n                    x,\n                    y\n                ];\n            case 270:\n                return [\n                    x,\n                    -y\n                ];\n            default:\n                return [\n                    -x,\n                    -y\n                ];\n        }\n    }\n    get _mustFixPosition() {\n        return true;\n    }\n    fixAndSetPosition(rotation = this.rotation) {\n        const { div: { style }, pageDimensions: [pageWidth, pageHeight] } = this;\n        let { x, y, width, height } = this;\n        width *= pageWidth;\n        height *= pageHeight;\n        x *= pageWidth;\n        y *= pageHeight;\n        if (this._mustFixPosition) {\n            switch(rotation){\n                case 0:\n                    x = MathClamp(x, 0, pageWidth - width);\n                    y = MathClamp(y, 0, pageHeight - height);\n                    break;\n                case 90:\n                    x = MathClamp(x, 0, pageWidth - height);\n                    y = MathClamp(y, width, pageHeight);\n                    break;\n                case 180:\n                    x = MathClamp(x, width, pageWidth);\n                    y = MathClamp(y, height, pageHeight);\n                    break;\n                case 270:\n                    x = MathClamp(x, height, pageWidth);\n                    y = MathClamp(y, 0, pageHeight - width);\n                    break;\n            }\n        }\n        this.x = x /= pageWidth;\n        this.y = y /= pageHeight;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this.moveInDOM();\n    }\n    static #rotatePoint(x, y, angle) {\n        switch(angle){\n            case 90:\n                return [\n                    y,\n                    -x\n                ];\n            case 180:\n                return [\n                    -x,\n                    -y\n                ];\n            case 270:\n                return [\n                    -y,\n                    x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    screenToPageTranslation(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n    }\n    pageTranslationToScreen(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n    }\n    #getRotationMatrix(rotation) {\n        switch(rotation){\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        -pageWidth / pageHeight,\n                        pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            case 180:\n                return [\n                    -1,\n                    0,\n                    0,\n                    -1\n                ];\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        pageWidth / pageHeight,\n                        -pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            default:\n                return [\n                    1,\n                    0,\n                    0,\n                    1\n                ];\n        }\n    }\n    get parentScale() {\n        return this._uiManager.viewParameters.realScale;\n    }\n    get parentRotation() {\n        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n    }\n    get parentDimensions() {\n        const { parentScale, pageDimensions: [pageWidth, pageHeight] } = this;\n        return [\n            pageWidth * parentScale,\n            pageHeight * parentScale\n        ];\n    }\n    setDims() {\n        const { div: { style }, width, height } = this;\n        style.width = `${(100 * width).toFixed(2)}%`;\n        style.height = `${(100 * height).toFixed(2)}%`;\n    }\n    getInitialTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    #createResizers() {\n        if (this.#resizersDiv) {\n            return;\n        }\n        this.#resizersDiv = document.createElement(\"div\");\n        this.#resizersDiv.classList.add(\"resizers\");\n        const classes = this._willKeepAspectRatio ? [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomRight\",\n            \"bottomLeft\"\n        ] : [\n            \"topLeft\",\n            \"topMiddle\",\n            \"topRight\",\n            \"middleRight\",\n            \"bottomRight\",\n            \"bottomMiddle\",\n            \"bottomLeft\",\n            \"middleLeft\"\n        ];\n        const signal = this._uiManager._signal;\n        for (const name of classes){\n            const div = document.createElement(\"div\");\n            this.#resizersDiv.append(div);\n            div.classList.add(\"resizer\", name);\n            div.setAttribute(\"data-resizer-name\", name);\n            div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name), {\n                signal\n            });\n            div.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            div.tabIndex = -1;\n        }\n        this.div.prepend(this.#resizersDiv);\n    }\n    #resizerPointerdown(name, event) {\n        event.preventDefault();\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        this.#altText?.toggle(false);\n        const savedDraggable = this._isDraggable;\n        this._isDraggable = false;\n        this.#lastPointerCoords = [\n            event.screenX,\n            event.screenY\n        ];\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        this.parent.togglePointerEvents(false);\n        window.addEventListener(\"pointermove\", this.#resizerPointermove.bind(this, name), {\n            passive: true,\n            capture: true,\n            signal\n        });\n        window.addEventListener(\"touchmove\", stopEvent, {\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const savedParentCursor = this.parent.div.style.cursor;\n        const savedCursor = this.div.style.cursor;\n        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n        const pointerUpCallback = ()=>{\n            ac.abort();\n            this.parent.togglePointerEvents(true);\n            this.#altText?.toggle(true);\n            this._isDraggable = savedDraggable;\n            this.parent.div.style.cursor = savedParentCursor;\n            this.div.style.cursor = savedCursor;\n            this.#addResizeToUndoStack();\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    #resize(x, y, width, height) {\n        this.width = width;\n        this.height = height;\n        this.x = x;\n        this.y = y;\n        this.setDims();\n        this.fixAndSetPosition();\n        this._onResized();\n    }\n    _onResized() {}\n    #addResizeToUndoStack() {\n        if (!this.#savedDimensions) {\n            return;\n        }\n        const { savedX, savedY, savedWidth, savedHeight } = this.#savedDimensions;\n        this.#savedDimensions = null;\n        const newX = this.x;\n        const newY = this.y;\n        const newWidth = this.width;\n        const newHeight = this.height;\n        if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.addCommands({\n            cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),\n            undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),\n            mustExec: true\n        });\n    }\n    static _round(x) {\n        return Math.round(x * 10000) / 10000;\n    }\n    #resizerPointermove(name, event) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n        const invTransf = (x, y)=>[\n                invRotationMatrix[0] * x + invRotationMatrix[2] * y,\n                invRotationMatrix[1] * x + invRotationMatrix[3] * y\n            ];\n        let getPoint;\n        let getOpposite;\n        let isDiagonal = false;\n        let isHorizontal = false;\n        switch(name){\n            case \"topLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h\n                    ];\n                break;\n            case \"topMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                break;\n            case \"topRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h\n                    ];\n                break;\n            case \"middleRight\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                break;\n            case \"bottomRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        0\n                    ];\n                break;\n            case \"bottomMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                break;\n            case \"bottomLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        0\n                    ];\n                break;\n            case \"middleLeft\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                break;\n        }\n        const point = getPoint(savedWidth, savedHeight);\n        const oppositePoint = getOpposite(savedWidth, savedHeight);\n        let transfOppositePoint = transf(...oppositePoint);\n        const oppositeX = AnnotationEditor._round(savedX + transfOppositePoint[0]);\n        const oppositeY = AnnotationEditor._round(savedY + transfOppositePoint[1]);\n        let ratioX = 1;\n        let ratioY = 1;\n        let deltaX, deltaY;\n        if (!event.fromKeyboard) {\n            const { screenX, screenY } = event;\n            const [lastScreenX, lastScreenY] = this.#lastPointerCoords;\n            [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);\n            this.#lastPointerCoords[0] = screenX;\n            this.#lastPointerCoords[1] = screenY;\n        } else {\n            ({ deltaX, deltaY } = event);\n        }\n        [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n        if (isDiagonal) {\n            const oldDiag = Math.hypot(savedWidth, savedHeight);\n            ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        } else if (isHorizontal) {\n            ratioX = MathClamp(Math.abs(oppositePoint[0] - point[0] - deltaX), minWidth, 1) / savedWidth;\n        } else {\n            ratioY = MathClamp(Math.abs(oppositePoint[1] - point[1] - deltaY), minHeight, 1) / savedHeight;\n        }\n        const newWidth = AnnotationEditor._round(savedWidth * ratioX);\n        const newHeight = AnnotationEditor._round(savedHeight * ratioY);\n        transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n        const newX = oppositeX - transfOppositePoint[0];\n        const newY = oppositeY - transfOppositePoint[1];\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.x = newX;\n        this.y = newY;\n        this.setDims();\n        this.fixAndSetPosition();\n        this._onResizing();\n    }\n    _onResizing() {}\n    altTextFinish() {\n        this.#altText?.finish();\n    }\n    get toolbarButtons() {\n        return null;\n    }\n    async addEditToolbar() {\n        if (this._editToolbar || this.#isInEditMode) {\n            return this._editToolbar;\n        }\n        this._editToolbar = new EditorToolbar(this);\n        this.div.append(this._editToolbar.render());\n        const { toolbarButtons } = this;\n        if (toolbarButtons) {\n            for (const [name, tool] of toolbarButtons){\n                await this._editToolbar.addButton(name, tool);\n            }\n        }\n        if (!this.hasComment) {\n            this._editToolbar.addButton(\"comment\", this.addCommentButton());\n        }\n        this._editToolbar.addButton(\"delete\");\n        return this._editToolbar;\n    }\n    addCommentButtonInToolbar() {\n        this._editToolbar?.addButtonBefore(\"comment\", this.addCommentButton(), \".deleteButton\");\n    }\n    removeCommentButtonFromToolbar() {\n        this._editToolbar?.removeButton(\"comment\");\n    }\n    removeEditToolbar() {\n        this._editToolbar?.remove();\n        this._editToolbar = null;\n        this.#altText?.destroy();\n    }\n    addContainer(container) {\n        const editToolbarDiv = this._editToolbar?.div;\n        if (editToolbarDiv) {\n            editToolbarDiv.before(container);\n        } else {\n            this.div.append(container);\n        }\n    }\n    getClientDimensions() {\n        return this.div.getBoundingClientRect();\n    }\n    createAltText() {\n        if (!this.#altText) {\n            AltText.initialize(AnnotationEditor._l10n);\n            this.#altText = new AltText(this);\n            if (this.#accessibilityData) {\n                this.#altText.data = this.#accessibilityData;\n                this.#accessibilityData = null;\n            }\n        }\n        return this.#altText;\n    }\n    get altTextData() {\n        return this.#altText?.data;\n    }\n    set altTextData(data) {\n        if (!this.#altText) {\n            return;\n        }\n        this.#altText.data = data;\n    }\n    get guessedAltText() {\n        return this.#altText?.guessedText;\n    }\n    async setGuessedAltText(text) {\n        await this.#altText?.setGuessedText(text);\n    }\n    serializeAltText(isForCopying) {\n        return this.#altText?.serialize(isForCopying);\n    }\n    hasAltText() {\n        return !!this.#altText && !this.#altText.isEmpty();\n    }\n    hasAltTextData() {\n        return this.#altText?.hasData() ?? false;\n    }\n    focusCommentButton() {\n        this.#comment?.focusButton();\n    }\n    addCommentButton() {\n        return this.#comment ||= new Comment(this);\n    }\n    addStandaloneCommentButton() {\n        if (this.#commentStandaloneButton) {\n            if (this._uiManager.isEditingMode()) {\n                this.#commentStandaloneButton.classList.remove(\"hidden\");\n            }\n            return;\n        }\n        if (!this.hasComment) {\n            return;\n        }\n        this.#commentStandaloneButton = this.#comment.renderForStandalone();\n        this.div.append(this.#commentStandaloneButton);\n    }\n    removeStandaloneCommentButton() {\n        this.#comment.removeStandaloneCommentButton();\n        this.#commentStandaloneButton = null;\n    }\n    hideStandaloneCommentButton() {\n        this.#commentStandaloneButton?.classList.add(\"hidden\");\n    }\n    get comment() {\n        const { data: { richText, text, date, deleted } } = this.#comment;\n        return {\n            text,\n            richText,\n            date,\n            deleted,\n            color: this.getNonHCMColor(),\n            opacity: this.opacity ?? 1\n        };\n    }\n    set comment(text) {\n        this.#comment ||= new Comment(this);\n        this.#comment.data = text;\n        if (this.hasComment) {\n            this.removeCommentButtonFromToolbar();\n            this.addStandaloneCommentButton();\n            this._uiManager.updateComment(this);\n        } else {\n            this.addCommentButtonInToolbar();\n            this.removeStandaloneCommentButton();\n            this._uiManager.removeComment(this);\n        }\n    }\n    setCommentData({ comment, popupRef, richText }) {\n        if (!popupRef) {\n            return;\n        }\n        this.#comment ||= new Comment(this);\n        this.#comment.setInitialText(comment, richText);\n        if (!this.annotationElementId) {\n            return;\n        }\n        const storedData = this._uiManager.getAndRemoveDataFromAnnotationStorage(this.annotationElementId);\n        if (storedData) {\n            this.updateFromAnnotationLayer(storedData);\n        }\n    }\n    get hasEditedComment() {\n        return this.#comment?.hasBeenEdited();\n    }\n    get hasDeletedComment() {\n        return this.#comment?.isDeleted();\n    }\n    get hasComment() {\n        return !!this.#comment && !this.#comment.isEmpty() && !this.#comment.isDeleted();\n    }\n    async editComment(options) {\n        this.#comment ||= new Comment(this);\n        this.#comment.edit(options);\n    }\n    toggleComment(isSelected, visibility = undefined) {\n        if (this.hasComment) {\n            this._uiManager.toggleComment(this, isSelected, visibility);\n        }\n    }\n    setSelectedCommentButton(selected) {\n        this.#comment.setSelectedButton(selected);\n    }\n    addComment(serialized) {\n        if (this.hasEditedComment) {\n            const DEFAULT_POPUP_WIDTH = 180;\n            const DEFAULT_POPUP_HEIGHT = 100;\n            const [, , , trY] = serialized.rect;\n            const [pageWidth] = this.pageDimensions;\n            const [pageX] = this.pageTranslation;\n            const blX = pageX + pageWidth + 1;\n            const blY = trY - DEFAULT_POPUP_HEIGHT;\n            const trX = blX + DEFAULT_POPUP_WIDTH;\n            serialized.popup = {\n                contents: this.comment.text,\n                deleted: this.comment.deleted,\n                rect: [\n                    blX,\n                    blY,\n                    trX,\n                    trY\n                ]\n            };\n        }\n    }\n    updateFromAnnotationLayer({ popup: { contents, deleted } }) {\n        this.#comment.data = deleted ? null : contents;\n    }\n    get parentBoundingClientRect() {\n        return this.parent.boundingClientRect;\n    }\n    render() {\n        const div = this.div = document.createElement(\"div\");\n        div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n        div.className = this.name;\n        div.setAttribute(\"id\", this.id);\n        div.tabIndex = this.#disabled ? -1 : 0;\n        div.setAttribute(\"role\", \"application\");\n        if (this.defaultL10nId) {\n            div.setAttribute(\"data-l10n-id\", this.defaultL10nId);\n        }\n        if (!this._isVisible) {\n            div.classList.add(\"hidden\");\n        }\n        this.setInForeground();\n        this.#addFocusListeners();\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        if (this.parentRotation % 180 !== 0) {\n            div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n            div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n        }\n        const [tx, ty] = this.getInitialTranslation();\n        this.translate(tx, ty);\n        bindEvents(this, div, [\n            \"keydown\",\n            \"pointerdown\",\n            \"dblclick\"\n        ]);\n        if (this.isResizable && this._uiManager._supportsPinchToZoom) {\n            this.#touchManager ||= new TouchManager({\n                container: div,\n                isPinchingDisabled: ()=>!this.isSelected,\n                onPinchStart: this.#touchPinchStartCallback.bind(this),\n                onPinching: this.#touchPinchCallback.bind(this),\n                onPinchEnd: this.#touchPinchEndCallback.bind(this),\n                signal: this._uiManager._signal\n            });\n        }\n        this.addStandaloneCommentButton();\n        this._uiManager._editorUndoBar?.hide();\n        return div;\n    }\n    #touchPinchStartCallback() {\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        this.#altText?.toggle(false);\n        this.parent.togglePointerEvents(false);\n    }\n    #touchPinchCallback(_origin, prevDistance, distance) {\n        const slowDownFactor = 0.7;\n        let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;\n        if (factor === 1) {\n            return;\n        }\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        const newWidth = AnnotationEditor._round(savedWidth * factor);\n        const newHeight = AnnotationEditor._round(savedHeight * factor);\n        if (newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.#initialRect ||= [\n            savedX,\n            savedY,\n            savedWidth,\n            savedHeight\n        ];\n        const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);\n        const centerX = AnnotationEditor._round(savedX + transfCenterPoint[0]);\n        const centerY = AnnotationEditor._round(savedY + transfCenterPoint[1]);\n        const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);\n        this.x = centerX - newTransfCenterPoint[0];\n        this.y = centerY - newTransfCenterPoint[1];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.setDims();\n        this.fixAndSetPosition();\n        this._onResizing();\n    }\n    #touchPinchEndCallback() {\n        this.#altText?.toggle(true);\n        this.parent.togglePointerEvents(true);\n        this.#addResizeToUndoStack();\n    }\n    pointerdown(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            event.preventDefault();\n            return;\n        }\n        this.#hasBeenClicked = true;\n        if (this._isDraggable) {\n            this.#setUpDragSession(event);\n            return;\n        }\n        this.#selectOnPointerEvent(event);\n    }\n    #selectOnPointerEvent(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n            this.parent.toggleSelected(this);\n        } else {\n            this.parent.setSelected(this);\n        }\n    }\n    #setUpDragSession(event) {\n        const { isSelected } = this;\n        this._uiManager.setUpDragSession();\n        let hasDraggingStarted = false;\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        const opts = {\n            capture: true,\n            passive: false,\n            signal\n        };\n        const cancelDrag = (e)=>{\n            ac.abort();\n            this.#dragPointerId = null;\n            this.#hasBeenClicked = false;\n            if (!this._uiManager.endDragSession()) {\n                this.#selectOnPointerEvent(e);\n            }\n            if (hasDraggingStarted) {\n                this._onStopDragging();\n            }\n        };\n        if (isSelected) {\n            this.#prevDragX = event.clientX;\n            this.#prevDragY = event.clientY;\n            this.#dragPointerId = event.pointerId;\n            this.#dragPointerType = event.pointerType;\n            window.addEventListener(\"pointermove\", (e)=>{\n                if (!hasDraggingStarted) {\n                    hasDraggingStarted = true;\n                    this._uiManager.toggleComment(this, true, false);\n                    this._onStartDragging();\n                }\n                const { clientX: x, clientY: y, pointerId } = e;\n                if (pointerId !== this.#dragPointerId) {\n                    stopEvent(e);\n                    return;\n                }\n                const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);\n                this.#prevDragX = x;\n                this.#prevDragY = y;\n                this._uiManager.dragSelectedEditors(tx, ty);\n            }, opts);\n            window.addEventListener(\"touchmove\", stopEvent, opts);\n            window.addEventListener(\"pointerdown\", (e)=>{\n                if (e.pointerType === this.#dragPointerType) {\n                    if (this.#touchManager || e.isPrimary) {\n                        cancelDrag(e);\n                    }\n                }\n                stopEvent(e);\n            }, opts);\n        }\n        const pointerUpCallback = (e)=>{\n            if (!this.#dragPointerId || this.#dragPointerId === e.pointerId) {\n                cancelDrag(e);\n                return;\n            }\n            stopEvent(e);\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    _onStartDragging() {}\n    _onStopDragging() {}\n    moveInDOM() {\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n        }\n        this.#moveInDOMTimeout = setTimeout(()=>{\n            this.#moveInDOMTimeout = null;\n            this.parent?.moveEditorInDOM(this);\n        }, 0);\n    }\n    _setParentAndPosition(parent, x, y) {\n        parent.changeParent(this);\n        this.x = x;\n        this.y = y;\n        this.fixAndSetPosition();\n        this._onTranslated();\n    }\n    getRect(tx, ty, rotation = this.rotation) {\n        const scale = this.parentScale;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const shiftX = tx / scale;\n        const shiftY = ty / scale;\n        const x = this.x * pageWidth;\n        const y = this.y * pageHeight;\n        const width = this.width * pageWidth;\n        const height = this.height * pageHeight;\n        switch(rotation){\n            case 0:\n                return [\n                    x + shiftX + pageX,\n                    pageHeight - y - shiftY - height + pageY,\n                    x + shiftX + width + pageX,\n                    pageHeight - y - shiftY + pageY\n                ];\n            case 90:\n                return [\n                    x + shiftY + pageX,\n                    pageHeight - y + shiftX + pageY,\n                    x + shiftY + height + pageX,\n                    pageHeight - y + shiftX + width + pageY\n                ];\n            case 180:\n                return [\n                    x - shiftX - width + pageX,\n                    pageHeight - y + shiftY + pageY,\n                    x - shiftX + pageX,\n                    pageHeight - y + shiftY + height + pageY\n                ];\n            case 270:\n                return [\n                    x - shiftY - height + pageX,\n                    pageHeight - y - shiftX - width + pageY,\n                    x - shiftY + pageX,\n                    pageHeight - y - shiftX + pageY\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    getRectInCurrentCoords(rect, pageHeight) {\n        const [x1, y1, x2, y2] = rect;\n        const width = x2 - x1;\n        const height = y2 - y1;\n        switch(this.rotation){\n            case 0:\n                return [\n                    x1,\n                    pageHeight - y2,\n                    width,\n                    height\n                ];\n            case 90:\n                return [\n                    x1,\n                    pageHeight - y1,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    x2,\n                    pageHeight - y1,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    x2,\n                    pageHeight - y2,\n                    height,\n                    width\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    getPDFRect() {\n        return this.getRect(0, 0);\n    }\n    getNonHCMColor() {\n        return this.color && AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));\n    }\n    onUpdatedColor() {\n        this.#comment?.onUpdatedColor();\n    }\n    getData() {\n        const { comment: { text: str, color, date, opacity, deleted, richText }, uid: id, pageIndex, creationDate, modificationDate } = this;\n        return {\n            id,\n            pageIndex,\n            rect: this.getPDFRect(),\n            richText,\n            contentsObj: {\n                str\n            },\n            creationDate,\n            modificationDate: date || modificationDate,\n            popupRef: !deleted,\n            color,\n            opacity\n        };\n    }\n    onceAdded(focus) {}\n    isEmpty() {\n        return false;\n    }\n    enableEditMode() {\n        if (this.isInEditMode()) {\n            return false;\n        }\n        this.parent.setEditingState(false);\n        this.#isInEditMode = true;\n        return true;\n    }\n    disableEditMode() {\n        if (!this.isInEditMode()) {\n            return false;\n        }\n        this.parent.setEditingState(true);\n        this.#isInEditMode = false;\n        return true;\n    }\n    isInEditMode() {\n        return this.#isInEditMode;\n    }\n    shouldGetKeyboardEvents() {\n        return this.#isResizerEnabledForKeyboard;\n    }\n    needsToBeRebuilt() {\n        return this.div && !this.isAttachedToDOM;\n    }\n    get isOnScreen() {\n        const { top, left, bottom, right } = this.getClientDimensions();\n        const { innerHeight, innerWidth } = window;\n        return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;\n    }\n    #addFocusListeners() {\n        if (this.#focusAC || !this.div) {\n            return;\n        }\n        this.#focusAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#focusAC);\n        this.div.addEventListener(\"focusin\", this.focusin.bind(this), {\n            signal\n        });\n        this.div.addEventListener(\"focusout\", this.focusout.bind(this), {\n            signal\n        });\n    }\n    rebuild() {\n        this.#addFocusListeners();\n    }\n    rotate(_angle) {}\n    resize() {}\n    serializeDeleted() {\n        return {\n            id: this.annotationElementId,\n            deleted: true,\n            pageIndex: this.pageIndex,\n            popupRef: this._initialData?.popupRef || \"\"\n        };\n    }\n    serialize(isForCopying = false, context = null) {\n        return {\n            annotationType: this.mode,\n            pageIndex: this.pageIndex,\n            rect: this.getPDFRect(),\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId,\n            popupRef: this._initialData?.popupRef || \"\"\n        };\n    }\n    static async deserialize(data, parent, uiManager) {\n        const editor = new this.prototype.constructor({\n            parent,\n            id: parent.getNextId(),\n            uiManager,\n            annotationElementId: data.annotationElementId,\n            creationDate: data.creationDate,\n            modificationDate: data.modificationDate\n        });\n        editor.rotation = data.rotation;\n        editor.#accessibilityData = data.accessibilityData;\n        editor._isCopy = data.isCopy || false;\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n        editor.x = x / pageWidth;\n        editor.y = y / pageHeight;\n        editor.width = width / pageWidth;\n        editor.height = height / pageHeight;\n        return editor;\n    }\n    get hasBeenModified() {\n        return !!this.annotationElementId && (this.deleted || this.serialize() !== null);\n    }\n    remove() {\n        this.#focusAC?.abort();\n        this.#focusAC = null;\n        if (!this.isEmpty()) {\n            this.commit();\n        }\n        if (this.parent) {\n            this.parent.remove(this);\n        } else {\n            this._uiManager.removeEditor(this);\n        }\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n            this.#moveInDOMTimeout = null;\n        }\n        this.#stopResizing();\n        this.removeEditToolbar();\n        if (this.#telemetryTimeouts) {\n            for (const timeout of this.#telemetryTimeouts.values()){\n                clearTimeout(timeout);\n            }\n            this.#telemetryTimeouts = null;\n        }\n        this.parent = null;\n        this.#touchManager?.destroy();\n        this.#touchManager = null;\n    }\n    get isResizable() {\n        return false;\n    }\n    makeResizable() {\n        if (this.isResizable) {\n            this.#createResizers();\n            this.#resizersDiv.classList.remove(\"hidden\");\n        }\n    }\n    get toolbarPosition() {\n        return null;\n    }\n    get commentButtonPosition() {\n        return this._uiManager.direction === \"ltr\" ? [\n            1,\n            0\n        ] : [\n            0,\n            0\n        ];\n    }\n    get commentButtonPositionInPage() {\n        const { commentButtonPosition: [posX, posY] } = this;\n        const [blX, blY, trX, trY] = this.getPDFRect();\n        return [\n            AnnotationEditor._round(blX + (trX - blX) * posX),\n            AnnotationEditor._round(blY + (trY - blY) * (1 - posY))\n        ];\n    }\n    get commentButtonColor() {\n        return this._uiManager.makeCommentColor(this.getNonHCMColor(), this.opacity);\n    }\n    get commentPopupPosition() {\n        return this.#comment.commentPopupPositionInLayer;\n    }\n    set commentPopupPosition(pos) {\n        this.#comment.commentPopupPositionInLayer = pos;\n    }\n    hasDefaultPopupPosition() {\n        return this.#comment.hasDefaultPopupPosition();\n    }\n    get commentButtonWidth() {\n        return this.#comment.commentButtonWidth;\n    }\n    get elementBeforePopup() {\n        return this.div;\n    }\n    setCommentButtonStates(options) {\n        this.#comment.setCommentButtonStates(options);\n    }\n    keydown(event) {\n        if (!this.isResizable || event.target !== this.div || event.key !== \"Enter\") {\n            return;\n        }\n        this._uiManager.setSelected(this);\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const children = this.#resizersDiv.children;\n        if (!this.#allResizerDivs) {\n            this.#allResizerDivs = Array.from(children);\n            const boundResizerKeydown = this.#resizerKeydown.bind(this);\n            const boundResizerBlur = this.#resizerBlur.bind(this);\n            const signal = this._uiManager._signal;\n            for (const div of this.#allResizerDivs){\n                const name = div.getAttribute(\"data-resizer-name\");\n                div.setAttribute(\"role\", \"spinbutton\");\n                div.addEventListener(\"keydown\", boundResizerKeydown, {\n                    signal\n                });\n                div.addEventListener(\"blur\", boundResizerBlur, {\n                    signal\n                });\n                div.addEventListener(\"focus\", this.#resizerFocus.bind(this, name), {\n                    signal\n                });\n                div.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        const first = this.#allResizerDivs[0];\n        let firstPosition = 0;\n        for (const div of children){\n            if (div === first) {\n                break;\n            }\n            firstPosition++;\n        }\n        const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);\n        if (nextFirstPosition !== firstPosition) {\n            if (nextFirstPosition < firstPosition) {\n                for(let i = 0; i < firstPosition - nextFirstPosition; i++){\n                    this.#resizersDiv.append(this.#resizersDiv.firstChild);\n                }\n            } else if (nextFirstPosition > firstPosition) {\n                for(let i = 0; i < nextFirstPosition - firstPosition; i++){\n                    this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);\n                }\n            }\n            let i = 0;\n            for (const child of children){\n                const div = this.#allResizerDivs[i++];\n                const name = div.getAttribute(\"data-resizer-name\");\n                child.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        this.#setResizerTabIndex(0);\n        this.#isResizerEnabledForKeyboard = true;\n        this.#resizersDiv.firstChild.focus({\n            focusVisible: true\n        });\n        event.preventDefault();\n        event.stopImmediatePropagation();\n    }\n    #resizerKeydown(event) {\n        AnnotationEditor._resizerKeyboardManager.exec(this, event);\n    }\n    #resizerBlur(event) {\n        if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {\n            this.#stopResizing();\n        }\n    }\n    #resizerFocus(name) {\n        this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : \"\";\n    }\n    #setResizerTabIndex(value) {\n        if (!this.#allResizerDivs) {\n            return;\n        }\n        for (const div of this.#allResizerDivs){\n            div.tabIndex = value;\n        }\n    }\n    _resizeWithKeyboard(x, y) {\n        if (!this.#isResizerEnabledForKeyboard) {\n            return;\n        }\n        this.#resizerPointermove(this.#focusedResizerName, {\n            deltaX: x,\n            deltaY: y,\n            fromKeyboard: true\n        });\n    }\n    #stopResizing() {\n        this.#isResizerEnabledForKeyboard = false;\n        this.#setResizerTabIndex(-1);\n        this.#addResizeToUndoStack();\n    }\n    _stopResizingWithKeyboard() {\n        this.#stopResizing();\n        this.div.focus();\n    }\n    select() {\n        if (this.isSelected && this._editToolbar) {\n            this._editToolbar.show();\n            return;\n        }\n        this.isSelected = true;\n        this.makeResizable();\n        this.div?.classList.add(\"selectedEditor\");\n        if (!this._editToolbar) {\n            this.addEditToolbar().then(()=>{\n                if (this.div?.classList.contains(\"selectedEditor\")) {\n                    this._editToolbar?.show();\n                }\n            });\n            return;\n        }\n        this._editToolbar?.show();\n        this.#altText?.toggleAltTextBadge(false);\n    }\n    focus() {\n        if (this.div && !this.div.contains(document.activeElement)) {\n            setTimeout(()=>this.div?.focus({\n                    preventScroll: true\n                }), 0);\n        }\n    }\n    unselect() {\n        if (!this.isSelected) {\n            return;\n        }\n        this.isSelected = false;\n        this.#resizersDiv?.classList.add(\"hidden\");\n        this.div?.classList.remove(\"selectedEditor\");\n        if (this.div?.contains(document.activeElement)) {\n            this._uiManager.currentLayer.div.focus({\n                preventScroll: true\n            });\n        }\n        this._editToolbar?.hide();\n        this.#altText?.toggleAltTextBadge(true);\n        if (this.hasComment) {\n            this._uiManager.toggleComment(this, false, false);\n        }\n    }\n    updateParams(type, value) {}\n    disableEditing() {}\n    enableEditing() {}\n    get canChangeContent() {\n        return false;\n    }\n    enterInEditMode() {\n        if (!this.canChangeContent) {\n            return;\n        }\n        this.enableEditMode();\n        this.div.focus();\n    }\n    dblclick(event) {\n        if (event.target.nodeName === \"BUTTON\") {\n            return;\n        }\n        this.enterInEditMode();\n        this.parent.updateToolbar({\n            mode: this.constructor._editorType,\n            editId: this.id\n        });\n    }\n    getElementForAltText() {\n        return this.div;\n    }\n    get contentDiv() {\n        return this.div;\n    }\n    get isEditing() {\n        return this.#isEditing;\n    }\n    set isEditing(value) {\n        this.#isEditing = value;\n        if (!this.parent) {\n            return;\n        }\n        if (value) {\n            this.parent.setSelected(this);\n            this.parent.setActiveEditor(this);\n        } else {\n            this.parent.setActiveEditor(null);\n        }\n    }\n    static get MIN_SIZE() {\n        return 16;\n    }\n    static canCreateNewEmptyEditor() {\n        return true;\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\"\n        };\n    }\n    get telemetryFinalData() {\n        return null;\n    }\n    _reportTelemetry(data, mustWait = false) {\n        if (mustWait) {\n            this.#telemetryTimeouts ||= new Map();\n            const { action } = data;\n            let timeout = this.#telemetryTimeouts.get(action);\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n            timeout = setTimeout(()=>{\n                this._reportTelemetry(data);\n                this.#telemetryTimeouts.delete(action);\n                if (this.#telemetryTimeouts.size === 0) {\n                    this.#telemetryTimeouts = null;\n                }\n            }, AnnotationEditor._telemetryTimeout);\n            this.#telemetryTimeouts.set(action, timeout);\n            return;\n        }\n        data.type ||= this.editorType;\n        this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n            source: this,\n            details: {\n                type: \"editing\",\n                data\n            }\n        });\n    }\n    show(visible = this._isVisible) {\n        this.div.classList.toggle(\"hidden\", !visible);\n        this._isVisible = visible;\n    }\n    enable() {\n        if (this.div) {\n            this.div.tabIndex = 0;\n        }\n        this.#disabled = false;\n    }\n    disable() {\n        if (this.div) {\n            this.div.tabIndex = -1;\n        }\n        this.#disabled = true;\n    }\n    updateFakeAnnotationElement(annotationLayer) {\n        if (!this.#fakeAnnotation && !this.deleted) {\n            this.#fakeAnnotation = annotationLayer.addFakeAnnotation(this);\n            return;\n        }\n        if (this.deleted) {\n            this.#fakeAnnotation.remove();\n            this.#fakeAnnotation = null;\n            return;\n        }\n        if (this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized) {\n            this.#fakeAnnotation.updateEdited({\n                rect: this.getPDFRect(),\n                popup: this.comment\n            });\n        }\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        let content = annotation.container.querySelector(\".annotationContent\");\n        if (!content) {\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            annotation.container.prepend(content);\n        } else if (content.nodeName === \"CANVAS\") {\n            const canvas = content;\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            canvas.before(content);\n        }\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        const { firstChild } = annotation.container;\n        if (firstChild?.nodeName === \"DIV\" && firstChild.classList.contains(\"annotationContent\")) {\n            firstChild.remove();\n        }\n    }\n}\nclass FakeEditor extends AnnotationEditor {\n    constructor(params){\n        super(params);\n        this.annotationElementId = params.annotationElementId;\n        this.deleted = true;\n    }\n    serialize() {\n        return this.serializeDeleted();\n    }\n}\n; // ./src/shared/murmurhash3.js\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\nclass MurmurHash3_64 {\n    constructor(seed){\n        this.h1 = seed ? seed & 0xffffffff : SEED;\n        this.h2 = seed ? seed & 0xffffffff : SEED;\n    }\n    update(input) {\n        let data, length;\n        if (typeof input === \"string\") {\n            data = new Uint8Array(input.length * 2);\n            length = 0;\n            for(let i = 0, ii = input.length; i < ii; i++){\n                const code = input.charCodeAt(i);\n                if (code <= 0xff) {\n                    data[length++] = code;\n                } else {\n                    data[length++] = code >>> 8;\n                    data[length++] = code & 0xff;\n                }\n            }\n        } else if (ArrayBuffer.isView(input)) {\n            data = input.slice();\n            length = data.byteLength;\n        } else {\n            throw new Error(\"Invalid data format, must be a string or TypedArray.\");\n        }\n        const blockCounts = length >> 2;\n        const tailLength = length - blockCounts * 4;\n        const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n        let k1 = 0, k2 = 0;\n        let h1 = this.h1, h2 = this.h2;\n        const C1 = 0xcc9e2d51, C2 = 0x1b873593;\n        const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;\n        for(let i = 0; i < blockCounts; i++){\n            if (i & 1) {\n                k1 = dataUint32[i];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                h1 ^= k1;\n                h1 = h1 << 13 | h1 >>> 19;\n                h1 = h1 * 5 + 0xe6546b64;\n            } else {\n                k2 = dataUint32[i];\n                k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n                k2 = k2 << 15 | k2 >>> 17;\n                k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n                h2 ^= k2;\n                h2 = h2 << 13 | h2 >>> 19;\n                h2 = h2 * 5 + 0xe6546b64;\n            }\n        }\n        k1 = 0;\n        switch(tailLength){\n            case 3:\n                k1 ^= data[blockCounts * 4 + 2] << 16;\n            case 2:\n                k1 ^= data[blockCounts * 4 + 1] << 8;\n            case 1:\n                k1 ^= data[blockCounts * 4];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                if (blockCounts & 1) {\n                    h1 ^= k1;\n                } else {\n                    h2 ^= k1;\n                }\n        }\n        this.h1 = h1;\n        this.h2 = h2;\n    }\n    hexdigest() {\n        let h1 = this.h1, h2 = this.h2;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n        h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n        h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n    }\n}\n; // ./src/display/annotation_storage.js\nconst SerializableEmpty = Object.freeze({\n    map: null,\n    hash: \"\",\n    transfer: undefined\n});\nclass AnnotationStorage {\n    #modified;\n    #modifiedIds;\n    #editorsMap;\n    #storage;\n    constructor(){\n        this.#modified = false;\n        this.#modifiedIds = null;\n        this.#editorsMap = null;\n        this.#storage = new Map();\n        this.onSetModified = null;\n        this.onResetModified = null;\n        this.onAnnotationEditor = null;\n    }\n    getValue(key, defaultValue) {\n        const value = this.#storage.get(key);\n        if (value === undefined) {\n            return defaultValue;\n        }\n        return Object.assign(defaultValue, value);\n    }\n    getRawValue(key) {\n        return this.#storage.get(key);\n    }\n    remove(key) {\n        const storedValue = this.#storage.get(key);\n        if (storedValue === undefined) {\n            return;\n        }\n        if (storedValue instanceof AnnotationEditor) {\n            this.#editorsMap.delete(storedValue.annotationElementId);\n        }\n        this.#storage.delete(key);\n        if (this.#storage.size === 0) {\n            this.resetModified();\n        }\n        if (typeof this.onAnnotationEditor === \"function\") {\n            for (const value of this.#storage.values()){\n                if (value instanceof AnnotationEditor) {\n                    return;\n                }\n            }\n            this.onAnnotationEditor(null);\n        }\n    }\n    setValue(key, value) {\n        const obj = this.#storage.get(key);\n        let modified = false;\n        if (obj !== undefined) {\n            for (const [entry, val] of Object.entries(value)){\n                if (obj[entry] !== val) {\n                    modified = true;\n                    obj[entry] = val;\n                }\n            }\n        } else {\n            modified = true;\n            this.#storage.set(key, value);\n        }\n        if (modified) {\n            this.#setModified();\n        }\n        if (value instanceof AnnotationEditor) {\n            (this.#editorsMap ||= new Map()).set(value.annotationElementId, value);\n            if (typeof this.onAnnotationEditor === \"function\") {\n                this.onAnnotationEditor(value.constructor._type);\n            }\n        }\n    }\n    has(key) {\n        return this.#storage.has(key);\n    }\n    get size() {\n        return this.#storage.size;\n    }\n    #setModified() {\n        if (!this.#modified) {\n            this.#modified = true;\n            if (typeof this.onSetModified === \"function\") {\n                this.onSetModified();\n            }\n        }\n    }\n    resetModified() {\n        if (this.#modified) {\n            this.#modified = false;\n            if (typeof this.onResetModified === \"function\") {\n                this.onResetModified();\n            }\n        }\n    }\n    get print() {\n        return new PrintAnnotationStorage(this);\n    }\n    get serializable() {\n        if (this.#storage.size === 0) {\n            return SerializableEmpty;\n        }\n        const map = new Map(), hash = new MurmurHash3_64(), transfer = [];\n        const context = Object.create(null);\n        let hasBitmap = false;\n        for (const [key, val] of this.#storage){\n            const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;\n            if (serialized) {\n                map.set(key, serialized);\n                hash.update(`${key}:${JSON.stringify(serialized)}`);\n                hasBitmap ||= !!serialized.bitmap;\n            }\n        }\n        if (hasBitmap) {\n            for (const value of map.values()){\n                if (value.bitmap) {\n                    transfer.push(value.bitmap);\n                }\n            }\n        }\n        return map.size > 0 ? {\n            map,\n            hash: hash.hexdigest(),\n            transfer\n        } : SerializableEmpty;\n    }\n    get editorStats() {\n        let stats = null;\n        const typeToEditor = new Map();\n        let numberOfEditedComments = 0;\n        let numberOfDeletedComments = 0;\n        for (const value of this.#storage.values()){\n            if (!(value instanceof AnnotationEditor)) {\n                if (value.popup) {\n                    if (value.popup.deleted) {\n                        numberOfDeletedComments += 1;\n                    } else {\n                        numberOfEditedComments += 1;\n                    }\n                }\n                continue;\n            }\n            if (value.isCommentDeleted) {\n                numberOfDeletedComments += 1;\n            } else if (value.hasEditedComment) {\n                numberOfEditedComments += 1;\n            }\n            const editorStats = value.telemetryFinalData;\n            if (!editorStats) {\n                continue;\n            }\n            const { type } = editorStats;\n            if (!typeToEditor.has(type)) {\n                typeToEditor.set(type, Object.getPrototypeOf(value).constructor);\n            }\n            stats ||= Object.create(null);\n            const map = stats[type] ||= new Map();\n            for (const [key, val] of Object.entries(editorStats)){\n                if (key === \"type\") {\n                    continue;\n                }\n                let counters = map.get(key);\n                if (!counters) {\n                    counters = new Map();\n                    map.set(key, counters);\n                }\n                const count = counters.get(val) ?? 0;\n                counters.set(val, count + 1);\n            }\n        }\n        if (numberOfDeletedComments > 0 || numberOfEditedComments > 0) {\n            stats ||= Object.create(null);\n            stats.comments = {\n                deleted: numberOfDeletedComments,\n                edited: numberOfEditedComments\n            };\n        }\n        if (!stats) {\n            return null;\n        }\n        for (const [type, editor] of typeToEditor){\n            stats[type] = editor.computeTelemetryFinalData(stats[type]);\n        }\n        return stats;\n    }\n    resetModifiedIds() {\n        this.#modifiedIds = null;\n    }\n    updateEditor(annotationId, data) {\n        const value = this.#editorsMap?.get(annotationId);\n        if (value) {\n            value.updateFromAnnotationLayer(data);\n            return true;\n        }\n        return false;\n    }\n    getEditor(annotationId) {\n        return this.#editorsMap?.get(annotationId) || null;\n    }\n    get modifiedIds() {\n        if (this.#modifiedIds) {\n            return this.#modifiedIds;\n        }\n        const ids = [];\n        if (this.#editorsMap) {\n            for (const value of this.#editorsMap.values()){\n                if (!value.serialize()) {\n                    continue;\n                }\n                ids.push(value.annotationElementId);\n            }\n        }\n        return this.#modifiedIds = {\n            ids: new Set(ids),\n            hash: ids.join(\",\")\n        };\n    }\n    [Symbol.iterator]() {\n        return this.#storage.entries();\n    }\n}\nclass PrintAnnotationStorage extends AnnotationStorage {\n    #serializable;\n    constructor(parent){\n        super();\n        const { map, hash, transfer } = parent.serializable;\n        const clone = structuredClone(map, transfer ? {\n            transfer\n        } : null);\n        this.#serializable = {\n            map: clone,\n            hash,\n            transfer\n        };\n    }\n    get print() {\n        unreachable(\"Should not call PrintAnnotationStorage.print\");\n    }\n    get serializable() {\n        return this.#serializable;\n    }\n    get modifiedIds() {\n        return shadow(this, \"modifiedIds\", {\n            ids: new Set(),\n            hash: \"\"\n        });\n    }\n}\n; // ./src/display/font_loader.js\nclass FontLoader {\n    #systemFonts;\n    constructor({ ownerDocument = globalThis.document, styleElement = null }){\n        this.#systemFonts = new Set();\n        this._document = ownerDocument;\n        this.nativeFontFaces = new Set();\n        this.styleElement = null;\n        this.loadingRequests = [];\n        this.loadTestFontId = 0;\n    }\n    addNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.add(nativeFontFace);\n        this._document.fonts.add(nativeFontFace);\n    }\n    removeNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.delete(nativeFontFace);\n        this._document.fonts.delete(nativeFontFace);\n    }\n    insertRule(rule) {\n        if (!this.styleElement) {\n            this.styleElement = this._document.createElement(\"style\");\n            this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n        }\n        const styleSheet = this.styleElement.sheet;\n        styleSheet.insertRule(rule, styleSheet.cssRules.length);\n    }\n    clear() {\n        for (const nativeFontFace of this.nativeFontFaces){\n            this._document.fonts.delete(nativeFontFace);\n        }\n        this.nativeFontFaces.clear();\n        this.#systemFonts.clear();\n        if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n        }\n    }\n    async loadSystemFont({ systemFontInfo: info, disableFontFace, _inspectFont }) {\n        if (!info || this.#systemFonts.has(info.loadedName)) {\n            return;\n        }\n        assert(!disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n        if (this.isFontLoadingAPISupported) {\n            const { loadedName, src, style } = info;\n            const fontFace = new FontFace(loadedName, src, style);\n            this.addNativeFontFace(fontFace);\n            try {\n                await fontFace.load();\n                this.#systemFonts.add(loadedName);\n                _inspectFont?.(info);\n            } catch  {\n                warn(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n                this.removeNativeFontFace(fontFace);\n            }\n            return;\n        }\n        unreachable(\"Not implemented: loadSystemFont without the Font Loading API.\");\n    }\n    async bind(font) {\n        if (font.attached || font.missingFile && !font.systemFontInfo) {\n            return;\n        }\n        font.attached = true;\n        if (font.systemFontInfo) {\n            await this.loadSystemFont(font);\n            return;\n        }\n        if (this.isFontLoadingAPISupported) {\n            const nativeFontFace = font.createNativeFontFace();\n            if (nativeFontFace) {\n                this.addNativeFontFace(nativeFontFace);\n                try {\n                    await nativeFontFace.loaded;\n                } catch (ex) {\n                    warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n                    font.disableFontFace = true;\n                    throw ex;\n                }\n            }\n            return;\n        }\n        const rule = font.createFontFaceRule();\n        if (rule) {\n            this.insertRule(rule);\n            if (this.isSyncFontLoadingSupported) {\n                return;\n            }\n            await new Promise((resolve)=>{\n                const request = this._queueLoadingCallback(resolve);\n                this._prepareFontLoadEvent(font, request);\n            });\n        }\n    }\n    get isFontLoadingAPISupported() {\n        const hasFonts = !!this._document?.fonts;\n        return shadow(this, \"isFontLoadingAPISupported\", hasFonts);\n    }\n    get isSyncFontLoadingSupported() {\n        return shadow(this, \"isSyncFontLoadingSupported\", isNodeJS || util_FeatureTest.platform.isFirefox);\n    }\n    _queueLoadingCallback(callback) {\n        function completeRequest() {\n            assert(!request.done, \"completeRequest() cannot be called twice.\");\n            request.done = true;\n            while(loadingRequests.length > 0 && loadingRequests[0].done){\n                const otherRequest = loadingRequests.shift();\n                setTimeout(otherRequest.callback, 0);\n            }\n        }\n        const { loadingRequests } = this;\n        const request = {\n            done: false,\n            complete: completeRequest,\n            callback\n        };\n        loadingRequests.push(request);\n        return request;\n    }\n    get _loadTestFont() {\n        const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n        return shadow(this, \"_loadTestFont\", testFont);\n    }\n    _prepareFontLoadEvent(font, request) {\n        function int32(data, offset) {\n            return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n        }\n        function spliceString(s, offset, remove, insert) {\n            const chunk1 = s.substring(0, offset);\n            const chunk2 = s.substring(offset + remove);\n            return chunk1 + insert + chunk2;\n        }\n        let i, ii;\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = 1;\n        canvas.height = 1;\n        const ctx = canvas.getContext(\"2d\");\n        let called = 0;\n        function isFontReady(name, callback) {\n            if (++called > 30) {\n                warn(\"Load test font never loaded.\");\n                callback();\n                return;\n            }\n            ctx.font = \"30px \" + name;\n            ctx.fillText(\".\", 0, 20);\n            const imageData = ctx.getImageData(0, 0, 1, 1);\n            if (imageData.data[3] > 0) {\n                callback();\n                return;\n            }\n            setTimeout(isFontReady.bind(null, name, callback));\n        }\n        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n        let data = this._loadTestFont;\n        const COMMENT_OFFSET = 976;\n        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n        const CFF_CHECKSUM_OFFSET = 16;\n        const XXXX_VALUE = 0x58585858;\n        let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n        for(i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4){\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n        }\n        if (i < loadTestFontId.length) {\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n        }\n        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n        const url = `url(data:font/opentype;base64,${btoa(data)});`;\n        const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n        this.insertRule(rule);\n        const div = this._document.createElement(\"div\");\n        div.style.visibility = \"hidden\";\n        div.style.width = div.style.height = \"10px\";\n        div.style.position = \"absolute\";\n        div.style.top = div.style.left = \"0px\";\n        for (const name of [\n            font.loadedName,\n            loadTestFontId\n        ]){\n            const span = this._document.createElement(\"span\");\n            span.textContent = \"Hi\";\n            span.style.fontFamily = name;\n            div.append(span);\n        }\n        this._document.body.append(div);\n        isFontReady(loadTestFontId, ()=>{\n            div.remove();\n            request.complete();\n        });\n    }\n}\nclass FontFaceObject {\n    #fontData;\n    constructor(translatedData, inspectFont = null, extra, charProcOperatorList){\n        this.compiledGlyphs = Object.create(null);\n        this.#fontData = translatedData;\n        this._inspectFont = inspectFont;\n        if (extra) {\n            Object.assign(this, extra);\n        }\n        if (charProcOperatorList) {\n            this.charProcOperatorList = charProcOperatorList;\n        }\n    }\n    createNativeFontFace() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        let nativeFontFace;\n        if (!this.cssFontInfo) {\n            nativeFontFace = new FontFace(this.loadedName, this.data, {});\n        } else {\n            const css = {\n                weight: this.cssFontInfo.fontWeight\n            };\n            if (this.cssFontInfo.italicAngle) {\n                css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n            }\n            nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n        }\n        this._inspectFont?.(this);\n        return nativeFontFace;\n    }\n    createFontFaceRule() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;\n        let rule;\n        if (!this.cssFontInfo) {\n            rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n        } else {\n            let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n            if (this.cssFontInfo.italicAngle) {\n                css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n            }\n            rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n        }\n        this._inspectFont?.(this, url);\n        return rule;\n    }\n    getPathGenerator(objs, character) {\n        if (this.compiledGlyphs[character] !== undefined) {\n            return this.compiledGlyphs[character];\n        }\n        const objId = this.loadedName + \"_path_\" + character;\n        let cmds;\n        try {\n            cmds = objs.get(objId);\n        } catch (ex) {\n            warn(`getPathGenerator - ignoring character: \"${ex}\".`);\n        }\n        const path = new Path2D(cmds || \"\");\n        if (!this.fontExtraProperties) {\n            objs.delete(objId);\n        }\n        return this.compiledGlyphs[character] = path;\n    }\n    get black() {\n        return this.#fontData.black;\n    }\n    get bold() {\n        return this.#fontData.bold;\n    }\n    get disableFontFace() {\n        return this.#fontData.disableFontFace ?? false;\n    }\n    get fontExtraProperties() {\n        return this.#fontData.fontExtraProperties ?? false;\n    }\n    get isInvalidPDFjsFont() {\n        return this.#fontData.isInvalidPDFjsFont;\n    }\n    get isType3Font() {\n        return this.#fontData.isType3Font;\n    }\n    get italic() {\n        return this.#fontData.italic;\n    }\n    get missingFile() {\n        return this.#fontData.missingFile;\n    }\n    get remeasure() {\n        return this.#fontData.remeasure;\n    }\n    get vertical() {\n        return this.#fontData.vertical;\n    }\n    get ascent() {\n        return this.#fontData.ascent;\n    }\n    get defaultWidth() {\n        return this.#fontData.defaultWidth;\n    }\n    get descent() {\n        return this.#fontData.descent;\n    }\n    get bbox() {\n        return this.#fontData.bbox;\n    }\n    get fontMatrix() {\n        return this.#fontData.fontMatrix;\n    }\n    get fallbackName() {\n        return this.#fontData.fallbackName;\n    }\n    get loadedName() {\n        return this.#fontData.loadedName;\n    }\n    get mimetype() {\n        return this.#fontData.mimetype;\n    }\n    get name() {\n        return this.#fontData.name;\n    }\n    get data() {\n        return this.#fontData.data;\n    }\n    clearData() {\n        this.#fontData.clearData();\n    }\n    get cssFontInfo() {\n        return this.#fontData.cssFontInfo;\n    }\n    get systemFontInfo() {\n        return this.#fontData.systemFontInfo;\n    }\n    get defaultVMetrics() {\n        return this.#fontData.defaultVMetrics;\n    }\n}\n; // ./src/display/api_utils.js\nfunction getUrlProp(val) {\n    if (val instanceof URL) {\n        return val.href;\n    }\n    if (typeof val === \"string\") {\n        if (isNodeJS) {\n            return val;\n        }\n        const url = URL.parse(val, window.location);\n        if (url) {\n            return url.href;\n        }\n    }\n    throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n}\nfunction getDataProp(val) {\n    if (isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n        throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n    }\n    if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n        return val;\n    }\n    if (typeof val === \"string\") {\n        return stringToBytes(val);\n    }\n    if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === \"object\" && !isNaN(val?.length)) {\n        return new Uint8Array(val);\n    }\n    throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n}\nfunction getFactoryUrlProp(val) {\n    if (typeof val !== \"string\") {\n        return null;\n    }\n    if (val.endsWith(\"/\")) {\n        return val;\n    }\n    throw new Error(`Invalid factory url: \"${val}\" must include trailing slash.`);\n}\nconst isRefProxy = (v)=>typeof v === \"object\" && Number.isInteger(v?.num) && v.num >= 0 && Number.isInteger(v?.gen) && v.gen >= 0;\nconst isNameProxy = (v)=>typeof v === \"object\" && typeof v?.name === \"string\";\nconst isValidExplicitDest = _isValidExplicitDest.bind(null, isRefProxy, isNameProxy);\nclass LoopbackPort {\n    #listeners;\n    #deferred;\n    postMessage(obj, transfer) {\n        const event = {\n            data: structuredClone(obj, transfer ? {\n                transfer\n            } : null)\n        };\n        this.#deferred.then(()=>{\n            for (const [listener] of this.#listeners){\n                listener.call(this, event);\n            }\n        });\n    }\n    addEventListener(name, listener, options = null) {\n        let rmAbort = null;\n        if (options?.signal instanceof AbortSignal) {\n            const { signal } = options;\n            if (signal.aborted) {\n                warn(\"LoopbackPort - cannot use an `aborted` signal.\");\n                return;\n            }\n            const onAbort = ()=>this.removeEventListener(name, listener);\n            rmAbort = ()=>signal.removeEventListener(\"abort\", onAbort);\n            signal.addEventListener(\"abort\", onAbort);\n        }\n        this.#listeners.set(listener, rmAbort);\n    }\n    removeEventListener(name, listener) {\n        const rmAbort = this.#listeners.get(listener);\n        rmAbort?.();\n        this.#listeners.delete(listener);\n    }\n    terminate() {\n        for (const [, rmAbort] of this.#listeners){\n            rmAbort?.();\n        }\n        this.#listeners.clear();\n    }\n    constructor(){\n        this.#listeners = new Map();\n        this.#deferred = Promise.resolve();\n    }\n}\n; // ./src/shared/message_handler.js\nconst CallbackKind = {\n    DATA: 1,\n    ERROR: 2\n};\nconst StreamKind = {\n    CANCEL: 1,\n    CANCEL_COMPLETE: 2,\n    CLOSE: 3,\n    ENQUEUE: 4,\n    ERROR: 5,\n    PULL: 6,\n    PULL_COMPLETE: 7,\n    START_COMPLETE: 8\n};\nfunction onFn() {}\nfunction wrapReason(ex) {\n    if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof PasswordException || ex instanceof ResponseException || ex instanceof UnknownErrorException) {\n        return ex;\n    }\n    if (!(ex instanceof Error || typeof ex === \"object\" && ex !== null)) {\n        unreachable('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n    }\n    switch(ex.name){\n        case \"AbortException\":\n            return new AbortException(ex.message);\n        case \"InvalidPDFException\":\n            return new InvalidPDFException(ex.message);\n        case \"PasswordException\":\n            return new PasswordException(ex.message, ex.code);\n        case \"ResponseException\":\n            return new ResponseException(ex.message, ex.status, ex.missing);\n        case \"UnknownErrorException\":\n            return new UnknownErrorException(ex.message, ex.details);\n    }\n    return new UnknownErrorException(ex.message, ex.toString());\n}\nclass MessageHandler {\n    #messageAC;\n    constructor(sourceName, targetName, comObj){\n        this.#messageAC = new AbortController();\n        this.sourceName = sourceName;\n        this.targetName = targetName;\n        this.comObj = comObj;\n        this.callbackId = 1;\n        this.streamId = 1;\n        this.streamSinks = Object.create(null);\n        this.streamControllers = Object.create(null);\n        this.callbackCapabilities = Object.create(null);\n        this.actionHandler = Object.create(null);\n        comObj.addEventListener(\"message\", this.#onMessage.bind(this), {\n            signal: this.#messageAC.signal\n        });\n    }\n    #onMessage({ data }) {\n        if (data.targetName !== this.sourceName) {\n            return;\n        }\n        if (data.stream) {\n            this.#processStreamMessage(data);\n            return;\n        }\n        if (data.callback) {\n            const callbackId = data.callbackId;\n            const capability = this.callbackCapabilities[callbackId];\n            if (!capability) {\n                throw new Error(`Cannot resolve callback ${callbackId}`);\n            }\n            delete this.callbackCapabilities[callbackId];\n            if (data.callback === CallbackKind.DATA) {\n                capability.resolve(data.data);\n            } else if (data.callback === CallbackKind.ERROR) {\n                capability.reject(wrapReason(data.reason));\n            } else {\n                throw new Error(\"Unexpected callback case\");\n            }\n            return;\n        }\n        const action = this.actionHandler[data.action];\n        if (!action) {\n            throw new Error(`Unknown action from worker: ${data.action}`);\n        }\n        if (data.callbackId) {\n            const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n            Promise.try(action, data.data).then(function(result) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.DATA,\n                    callbackId: data.callbackId,\n                    data: result\n                });\n            }, function(reason) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.ERROR,\n                    callbackId: data.callbackId,\n                    reason: wrapReason(reason)\n                });\n            });\n            return;\n        }\n        if (data.streamId) {\n            this.#createStreamSink(data);\n            return;\n        }\n        action(data.data);\n    }\n    on(actionName, handler) {\n        const ah = this.actionHandler;\n        if (ah[actionName]) {\n            throw new Error(`There is already an actionName called \"${actionName}\"`);\n        }\n        ah[actionName] = handler;\n    }\n    send(actionName, data, transfers) {\n        this.comObj.postMessage({\n            sourceName: this.sourceName,\n            targetName: this.targetName,\n            action: actionName,\n            data\n        }, transfers);\n    }\n    sendWithPromise(actionName, data, transfers) {\n        const callbackId = this.callbackId++;\n        const capability = Promise.withResolvers();\n        this.callbackCapabilities[callbackId] = capability;\n        try {\n            this.comObj.postMessage({\n                sourceName: this.sourceName,\n                targetName: this.targetName,\n                action: actionName,\n                callbackId,\n                data\n            }, transfers);\n        } catch (ex) {\n            capability.reject(ex);\n        }\n        return capability.promise;\n    }\n    sendWithStream(actionName, data, queueingStrategy, transfers) {\n        const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;\n        return new ReadableStream({\n            start: (controller)=>{\n                const startCapability = Promise.withResolvers();\n                this.streamControllers[streamId] = {\n                    controller,\n                    startCall: startCapability,\n                    pullCall: null,\n                    cancelCall: null,\n                    isClosed: false\n                };\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    action: actionName,\n                    streamId,\n                    data,\n                    desiredSize: controller.desiredSize\n                }, transfers);\n                return startCapability.promise;\n            },\n            pull: (controller)=>{\n                const pullCapability = Promise.withResolvers();\n                this.streamControllers[streamId].pullCall = pullCapability;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.PULL,\n                    streamId,\n                    desiredSize: controller.desiredSize\n                });\n                return pullCapability.promise;\n            },\n            cancel: (reason)=>{\n                assert(reason instanceof Error, \"cancel must have a valid reason\");\n                const cancelCapability = Promise.withResolvers();\n                this.streamControllers[streamId].cancelCall = cancelCapability;\n                this.streamControllers[streamId].isClosed = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CANCEL,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n                return cancelCapability.promise;\n            }\n        }, queueingStrategy);\n    }\n    #createStreamSink(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const self1 = this, action = this.actionHandler[data.action];\n        const streamSink = {\n            enqueue (chunk, size = 1, transfers) {\n                if (this.isCancelled) {\n                    return;\n                }\n                const lastDesiredSize = this.desiredSize;\n                this.desiredSize -= size;\n                if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n                    this.sinkCapability = Promise.withResolvers();\n                    this.ready = this.sinkCapability.promise;\n                }\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ENQUEUE,\n                    streamId,\n                    chunk\n                }, transfers);\n            },\n            close () {\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CLOSE,\n                    streamId\n                });\n                delete self1.streamSinks[streamId];\n            },\n            error (reason) {\n                assert(reason instanceof Error, \"error must have a valid reason\");\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ERROR,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n            },\n            sinkCapability: Promise.withResolvers(),\n            onPull: null,\n            onCancel: null,\n            isCancelled: false,\n            desiredSize: data.desiredSize,\n            ready: null\n        };\n        streamSink.sinkCapability.resolve();\n        streamSink.ready = streamSink.sinkCapability.promise;\n        this.streamSinks[streamId] = streamSink;\n        Promise.try(action, data.data, streamSink).then(function() {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                success: true\n            });\n        }, function(reason) {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                reason: wrapReason(reason)\n            });\n        });\n    }\n    #processStreamMessage(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];\n        switch(data.stream){\n            case StreamKind.START_COMPLETE:\n                if (data.success) {\n                    streamController.startCall.resolve();\n                } else {\n                    streamController.startCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL_COMPLETE:\n                if (data.success) {\n                    streamController.pullCall.resolve();\n                } else {\n                    streamController.pullCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL:\n                if (!streamSink) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                    break;\n                }\n                if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n                    streamSink.sinkCapability.resolve();\n                }\n                streamSink.desiredSize = data.desiredSize;\n                Promise.try(streamSink.onPull || onFn).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                break;\n            case StreamKind.ENQUEUE:\n                assert(streamController, \"enqueue should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.controller.enqueue(data.chunk);\n                break;\n            case StreamKind.CLOSE:\n                assert(streamController, \"close should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.isClosed = true;\n                streamController.controller.close();\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.ERROR:\n                assert(streamController, \"error should have stream controller\");\n                streamController.controller.error(wrapReason(data.reason));\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL_COMPLETE:\n                if (data.success) {\n                    streamController.cancelCall.resolve();\n                } else {\n                    streamController.cancelCall.reject(wrapReason(data.reason));\n                }\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL:\n                if (!streamSink) {\n                    break;\n                }\n                const dataReason = wrapReason(data.reason);\n                Promise.try(streamSink.onCancel || onFn, dataReason).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                streamSink.sinkCapability.reject(dataReason);\n                streamSink.isCancelled = true;\n                delete this.streamSinks[streamId];\n                break;\n            default:\n                throw new Error(\"Unexpected stream case\");\n        }\n    }\n    async #deleteStreamController(streamController, streamId) {\n        await Promise.allSettled([\n            streamController.startCall?.promise,\n            streamController.pullCall?.promise,\n            streamController.cancelCall?.promise\n        ]);\n        delete this.streamControllers[streamId];\n    }\n    destroy() {\n        this.#messageAC?.abort();\n        this.#messageAC = null;\n    }\n}\n; // ./src/display/canvas_factory.js\nclass BaseCanvasFactory {\n    #enableHWA;\n    constructor({ enableHWA = false }){\n        this.#enableHWA = false;\n        this.#enableHWA = enableHWA;\n    }\n    create(width, height) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        const canvas = this._createCanvas(width, height);\n        return {\n            canvas,\n            context: canvas.getContext(\"2d\", {\n                willReadFrequently: !this.#enableHWA\n            })\n        };\n    }\n    reset(canvasAndContext, width, height) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        canvasAndContext.canvas.width = width;\n        canvasAndContext.canvas.height = height;\n    }\n    destroy(canvasAndContext) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        canvasAndContext.canvas.width = 0;\n        canvasAndContext.canvas.height = 0;\n        canvasAndContext.canvas = null;\n        canvasAndContext.context = null;\n    }\n    _createCanvas(width, height) {\n        unreachable(\"Abstract method `_createCanvas` called.\");\n    }\n}\nclass DOMCanvasFactory extends BaseCanvasFactory {\n    constructor({ ownerDocument = globalThis.document, enableHWA = false }){\n        super({\n            enableHWA\n        });\n        this._document = ownerDocument;\n    }\n    _createCanvas(width, height) {\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n}\n; // ./src/display/cmap_reader_factory.js\nclass BaseCMapReaderFactory {\n    constructor({ baseUrl = null, isCompressed = true }){\n        this.baseUrl = baseUrl;\n        this.isCompressed = isCompressed;\n    }\n    async fetch({ name }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.\");\n        }\n        if (!name) {\n            throw new Error(\"CMap name must be specified.\");\n        }\n        const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n        return this._fetch(url).then((cMapData)=>({\n                cMapData,\n                isCompressed: this.isCompressed\n            })).catch((reason)=>{\n            throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, this.isCompressed ? \"arraybuffer\" : \"text\");\n        return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);\n    }\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.filter.js\nvar es_iterator_filter = __nested_webpack_require_216482__(2489);\n; // ./src/display/filter_factory.js\nclass BaseFilterFactory {\n    addFilter(maps) {\n        return \"none\";\n    }\n    addHCMFilter(fgColor, bgColor) {\n        return \"none\";\n    }\n    addAlphaFilter(map) {\n        return \"none\";\n    }\n    addLuminosityFilter(map) {\n        return \"none\";\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        return \"none\";\n    }\n    destroy(keepHCM = false) {}\n}\nclass DOMFilterFactory extends BaseFilterFactory {\n    #baseUrl;\n    #_cache;\n    #_defs;\n    #docId;\n    #document;\n    #_hcmCache;\n    #id;\n    constructor({ docId, ownerDocument = globalThis.document }){\n        super();\n        this.#id = 0;\n        this.#docId = docId;\n        this.#document = ownerDocument;\n    }\n    get #cache() {\n        return this.#_cache ||= new Map();\n    }\n    get #hcmCache() {\n        return this.#_hcmCache ||= new Map();\n    }\n    get #defs() {\n        if (!this.#_defs) {\n            const div = this.#document.createElement(\"div\");\n            const { style } = div;\n            style.visibility = \"hidden\";\n            style.contain = \"strict\";\n            style.width = style.height = 0;\n            style.position = \"absolute\";\n            style.top = style.left = 0;\n            style.zIndex = -1;\n            const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n            svg.setAttribute(\"width\", 0);\n            svg.setAttribute(\"height\", 0);\n            this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n            div.append(svg);\n            svg.append(this.#_defs);\n            this.#document.body.append(div);\n        }\n        return this.#_defs;\n    }\n    #createTables(maps) {\n        if (maps.length === 1) {\n            const mapR = maps[0];\n            const buffer = new Array(256);\n            for(let i = 0; i < 256; i++){\n                buffer[i] = mapR[i] / 255;\n            }\n            const table = buffer.join(\",\");\n            return [\n                table,\n                table,\n                table\n            ];\n        }\n        const [mapR, mapG, mapB] = maps;\n        const bufferR = new Array(256);\n        const bufferG = new Array(256);\n        const bufferB = new Array(256);\n        for(let i = 0; i < 256; i++){\n            bufferR[i] = mapR[i] / 255;\n            bufferG[i] = mapG[i] / 255;\n            bufferB[i] = mapB[i] / 255;\n        }\n        return [\n            bufferR.join(\",\"),\n            bufferG.join(\",\"),\n            bufferB.join(\",\")\n        ];\n    }\n    #createUrl(id) {\n        if (this.#baseUrl === undefined) {\n            this.#baseUrl = \"\";\n            const url = this.#document.URL;\n            if (url !== this.#document.baseURI) {\n                if (isDataScheme(url)) {\n                    warn('#createUrl: ignore \"data:\"-URL for performance reasons.');\n                } else {\n                    this.#baseUrl = updateUrlHash(url, \"\");\n                }\n            }\n        }\n        return `url(${this.#baseUrl}#${id})`;\n    }\n    addFilter(maps) {\n        if (!maps) {\n            return \"none\";\n        }\n        let value = this.#cache.get(maps);\n        if (value) {\n            return value;\n        }\n        const [tableR, tableG, tableB] = this.#createTables(maps);\n        const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(maps, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(maps, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n        return url;\n    }\n    addHCMFilter(fgColor, bgColor) {\n        const key = `${fgColor}-${bgColor}`;\n        const filterName = \"base\";\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const fgRGB = this.#getRGB(fgColor);\n        fgColor = Util.makeHexColor(...fgRGB);\n        const bgRGB = this.#getRGB(bgColor);\n        bgColor = Util.makeHexColor(...bgRGB);\n        this.#defs.style.color = \"\";\n        if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n            return info.url;\n        }\n        const map = new Array(256);\n        for(let i = 0; i <= 255; i++){\n            const x = i / 255;\n            map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n        }\n        const table = map.join(\",\");\n        const id = `g_${this.#docId}_hcm_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addTransferMapConversion(table, table, table, filter);\n        this.#addGrayConversion(filter);\n        const getSteps = (c, n)=>{\n            const start = fgRGB[c] / 255;\n            const end = bgRGB[c] / 255;\n            const arr = new Array(n + 1);\n            for(let i = 0; i <= n; i++){\n                arr[i] = start + i / n * (end - start);\n            }\n            return arr.join(\",\");\n        };\n        this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    addAlphaFilter(map) {\n        let value = this.#cache.get(map);\n        if (value) {\n            return value;\n        }\n        const [tableA] = this.#createTables([\n            map\n        ]);\n        const key = `alpha_${tableA}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_alpha_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapAlphaConversion(tableA, filter);\n        return url;\n    }\n    addLuminosityFilter(map) {\n        let value = this.#cache.get(map || \"luminosity\");\n        if (value) {\n            return value;\n        }\n        let tableA, key;\n        if (map) {\n            [tableA] = this.#createTables([\n                map\n            ]);\n            key = `luminosity_${tableA}`;\n        } else {\n            key = \"luminosity\";\n        }\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addLuminosityConversion(filter);\n        if (map) {\n            this.#addTransferMapAlphaConversion(tableA, filter);\n        }\n        return url;\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const [fgRGB, bgRGB] = [\n            fgColor,\n            bgColor\n        ].map(this.#getRGB.bind(this));\n        let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n        let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n        let [newFgRGB, newBgRGB] = [\n            newFgColor,\n            newBgColor\n        ].map(this.#getRGB.bind(this));\n        if (bgGray < fgGray) {\n            [fgGray, bgGray, newFgRGB, newBgRGB] = [\n                bgGray,\n                fgGray,\n                newBgRGB,\n                newFgRGB\n            ];\n        }\n        this.#defs.style.color = \"\";\n        const getSteps = (fg, bg, n)=>{\n            const arr = new Array(256);\n            const step = (bgGray - fgGray) / n;\n            const newStart = fg / 255;\n            const newStep = (bg - fg) / (255 * n);\n            let prev = 0;\n            for(let i = 0; i <= n; i++){\n                const k = Math.round(fgGray + i * step);\n                const value = newStart + i * newStep;\n                for(let j = prev; j <= k; j++){\n                    arr[j] = value;\n                }\n                prev = k + 1;\n            }\n            for(let i = prev; i < 256; i++){\n                arr[i] = arr[prev - 1];\n            }\n            return arr.join(\",\");\n        };\n        const id = `g_${this.#docId}_hcm_${filterName}_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addGrayConversion(filter);\n        this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    destroy(keepHCM = false) {\n        if (keepHCM && this.#_hcmCache?.size) {\n            return;\n        }\n        this.#_defs?.parentNode.parentNode.remove();\n        this.#_defs = null;\n        this.#_cache?.clear();\n        this.#_cache = null;\n        this.#_hcmCache?.clear();\n        this.#_hcmCache = null;\n        this.#id = 0;\n    }\n    #addLuminosityConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0\");\n        filter.append(feColorMatrix);\n    }\n    #addGrayConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n        filter.append(feColorMatrix);\n    }\n    #createFilter(id) {\n        const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n        filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        filter.setAttribute(\"id\", id);\n        this.#defs.append(filter);\n        return filter;\n    }\n    #appendFeFunc(feComponentTransfer, func, table) {\n        const feFunc = this.#document.createElementNS(SVG_NS, func);\n        feFunc.setAttribute(\"type\", \"discrete\");\n        feFunc.setAttribute(\"tableValues\", table);\n        feComponentTransfer.append(feFunc);\n    }\n    #addTransferMapConversion(rTable, gTable, bTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n    }\n    #addTransferMapAlphaConversion(aTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncA\", aTable);\n    }\n    #getRGB(color) {\n        this.#defs.style.color = color;\n        return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n    }\n}\n; // ./src/display/standard_fontdata_factory.js\nclass BaseStandardFontDataFactory {\n    constructor({ baseUrl = null }){\n        this.baseUrl = baseUrl;\n    }\n    async fetch({ filename }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `standardFontDataUrl` API parameter is provided.\");\n        }\n        if (!filename) {\n            throw new Error(\"Font filename must be specified.\");\n        }\n        const url = `${this.baseUrl}${filename}`;\n        return this._fetch(url).catch((reason)=>{\n            throw new Error(`Unable to load font data at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, \"arraybuffer\");\n        return new Uint8Array(data);\n    }\n}\n; // ./src/display/wasm_factory.js\nclass BaseWasmFactory {\n    constructor({ baseUrl = null }){\n        this.baseUrl = baseUrl;\n    }\n    async fetch({ filename }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `wasmUrl` API parameter is provided.\");\n        }\n        if (!filename) {\n            throw new Error(\"Wasm filename must be specified.\");\n        }\n        const url = `${this.baseUrl}${filename}`;\n        return this._fetch(url).catch((reason)=>{\n            throw new Error(`Unable to load wasm data at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMWasmFactory extends BaseWasmFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, \"arraybuffer\");\n        return new Uint8Array(data);\n    }\n}\n; // ./src/display/node_utils.js\nif (isNodeJS) {\n    let canvas;\n    try {\n        const require = process.getBuiltinModule(\"module\").createRequire(\"file:///D:/github/c/frontend/node_modules/pdf-parse/node_modules/pdfjs-dist/legacy/build/pdf.mjs\");\n        try {\n            canvas = require(\"@napi-rs/canvas\");\n        } catch (ex) {\n            warn(`Cannot load \"@napi-rs/canvas\" package: \"${ex}\".`);\n        }\n    } catch (ex) {\n        warn(`Cannot access the \\`require\\` function: \"${ex}\".`);\n    }\n    if (!globalThis.DOMMatrix) {\n        if (canvas?.DOMMatrix) {\n            globalThis.DOMMatrix = canvas.DOMMatrix;\n        } else {\n            warn(\"Cannot polyfill `DOMMatrix`, rendering may be broken.\");\n        }\n    }\n    if (!globalThis.ImageData) {\n        if (canvas?.ImageData) {\n            globalThis.ImageData = canvas.ImageData;\n        } else {\n            warn(\"Cannot polyfill `ImageData`, rendering may be broken.\");\n        }\n    }\n    if (!globalThis.Path2D) {\n        if (canvas?.Path2D) {\n            globalThis.Path2D = canvas.Path2D;\n        } else {\n            warn(\"Cannot polyfill `Path2D`, rendering may be broken.\");\n        }\n    }\n    if (!globalThis.navigator?.language) {\n        globalThis.navigator = {\n            language: \"en-US\",\n            platform: \"\",\n            userAgent: \"\"\n        };\n    }\n}\nasync function node_utils_fetchData(url) {\n    const fs = process.getBuiltinModule(\"fs\");\n    const data = await fs.promises.readFile(url);\n    return new Uint8Array(data);\n}\nclass NodeFilterFactory extends BaseFilterFactory {\n}\nclass NodeCanvasFactory extends BaseCanvasFactory {\n    _createCanvas(width, height) {\n        const require = process.getBuiltinModule(\"module\").createRequire(\"file:///D:/github/c/frontend/node_modules/pdf-parse/node_modules/pdfjs-dist/legacy/build/pdf.mjs\");\n        const canvas = require(\"@napi-rs/canvas\");\n        return canvas.createCanvas(width, height);\n    }\n}\nclass NodeCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\nclass NodeStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\nclass NodeWasmFactory extends BaseWasmFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.for-each.js\nvar es_iterator_for_each = __nested_webpack_require_216482__(7588);\n; // ./src/display/canvas_dependency_tracker.js\nconst FORCED_DEPENDENCY_LABEL = \"__forcedDependency\";\nconst { floor, ceil } = Math;\nfunction expandBBox(array, index, minX, minY, maxX, maxY) {\n    array[index * 4 + 0] = Math.min(array[index * 4 + 0], minX);\n    array[index * 4 + 1] = Math.min(array[index * 4 + 1], minY);\n    array[index * 4 + 2] = Math.max(array[index * 4 + 2], maxX);\n    array[index * 4 + 3] = Math.max(array[index * 4 + 3], maxY);\n}\nconst EMPTY_BBOX = new Uint32Array(new Uint8Array([\n    255,\n    255,\n    0,\n    0\n]).buffer)[0];\nclass BBoxReader {\n    #bboxes;\n    #coords;\n    constructor(bboxes, coords){\n        this.#bboxes = bboxes;\n        this.#coords = coords;\n    }\n    get length() {\n        return this.#bboxes.length;\n    }\n    isEmpty(i) {\n        return this.#bboxes[i] === EMPTY_BBOX;\n    }\n    minX(i) {\n        return this.#coords[i * 4 + 0] / 256;\n    }\n    minY(i) {\n        return this.#coords[i * 4 + 1] / 256;\n    }\n    maxX(i) {\n        return (this.#coords[i * 4 + 2] + 1) / 256;\n    }\n    maxY(i) {\n        return (this.#coords[i * 4 + 3] + 1) / 256;\n    }\n}\nconst ensureDebugMetadata = (map, key)=>{\n    if (!map) {\n        return undefined;\n    }\n    let value = map.get(key);\n    if (!value) {\n        value = {\n            dependencies: new Set(),\n            isRenderingOperation: false\n        };\n        map.set(key, value);\n    }\n    return value;\n};\nclass CanvasDependencyTracker {\n    #simple;\n    #incremental;\n    #namedDependencies;\n    #savesStack;\n    #markedContentStack;\n    #baseTransformStack;\n    #clipBox;\n    #pendingBBox;\n    #pendingBBoxIdx;\n    #pendingDependencies;\n    #operations;\n    #fontBBoxTrustworthy;\n    #canvasWidth;\n    #canvasHeight;\n    #bboxesCoords;\n    #bboxes;\n    #debugMetadata;\n    constructor(canvas, operationsCount, recordDebugMetadata = false){\n        this.#simple = {\n            __proto__: null\n        };\n        this.#incremental = {\n            __proto__: null,\n            transform: [],\n            moveText: [],\n            sameLineText: [],\n            [FORCED_DEPENDENCY_LABEL]: []\n        };\n        this.#namedDependencies = new Map();\n        this.#savesStack = [];\n        this.#markedContentStack = [];\n        this.#baseTransformStack = [\n            [\n                1,\n                0,\n                0,\n                1,\n                0,\n                0\n            ]\n        ];\n        this.#clipBox = [\n            -Infinity,\n            -Infinity,\n            Infinity,\n            Infinity\n        ];\n        this.#pendingBBox = new Float64Array([\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ]);\n        this.#pendingBBoxIdx = -1;\n        this.#pendingDependencies = new Set();\n        this.#operations = new Map();\n        this.#fontBBoxTrustworthy = new Map();\n        this.#canvasWidth = canvas.width;\n        this.#canvasHeight = canvas.height;\n        this.#initializeBBoxes(operationsCount);\n        if (recordDebugMetadata) {\n            this.#debugMetadata = new Map();\n        }\n    }\n    growOperationsCount(operationsCount) {\n        if (operationsCount >= this.#bboxes.length) {\n            this.#initializeBBoxes(operationsCount, this.#bboxes);\n        }\n    }\n    #initializeBBoxes(operationsCount, oldBBoxes) {\n        const buffer = new ArrayBuffer(operationsCount * 4);\n        this.#bboxesCoords = new Uint8ClampedArray(buffer);\n        this.#bboxes = new Uint32Array(buffer);\n        if (oldBBoxes && oldBBoxes.length > 0) {\n            this.#bboxes.set(oldBBoxes);\n            this.#bboxes.fill(EMPTY_BBOX, oldBBoxes.length);\n        } else {\n            this.#bboxes.fill(EMPTY_BBOX);\n        }\n    }\n    save(opIdx) {\n        this.#simple = {\n            __proto__: this.#simple\n        };\n        this.#incremental = {\n            __proto__: this.#incremental,\n            transform: {\n                __proto__: this.#incremental.transform\n            },\n            moveText: {\n                __proto__: this.#incremental.moveText\n            },\n            sameLineText: {\n                __proto__: this.#incremental.sameLineText\n            },\n            [FORCED_DEPENDENCY_LABEL]: {\n                __proto__: this.#incremental[FORCED_DEPENDENCY_LABEL]\n            }\n        };\n        this.#clipBox = {\n            __proto__: this.#clipBox\n        };\n        this.#savesStack.push(opIdx);\n        return this;\n    }\n    restore(opIdx) {\n        const previous = Object.getPrototypeOf(this.#simple);\n        if (previous === null) {\n            return this;\n        }\n        this.#simple = previous;\n        this.#incremental = Object.getPrototypeOf(this.#incremental);\n        this.#clipBox = Object.getPrototypeOf(this.#clipBox);\n        const lastSave = this.#savesStack.pop();\n        if (lastSave !== undefined) {\n            ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);\n            this.#bboxes[opIdx] = this.#bboxes[lastSave];\n        }\n        return this;\n    }\n    recordOpenMarker(idx) {\n        this.#savesStack.push(idx);\n        return this;\n    }\n    getOpenMarker() {\n        if (this.#savesStack.length === 0) {\n            return null;\n        }\n        return this.#savesStack.at(-1);\n    }\n    recordCloseMarker(opIdx) {\n        const lastSave = this.#savesStack.pop();\n        if (lastSave !== undefined) {\n            ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);\n            this.#bboxes[opIdx] = this.#bboxes[lastSave];\n        }\n        return this;\n    }\n    beginMarkedContent(opIdx) {\n        this.#markedContentStack.push(opIdx);\n        return this;\n    }\n    endMarkedContent(opIdx) {\n        const lastSave = this.#markedContentStack.pop();\n        if (lastSave !== undefined) {\n            ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);\n            this.#bboxes[opIdx] = this.#bboxes[lastSave];\n        }\n        return this;\n    }\n    pushBaseTransform(ctx) {\n        this.#baseTransformStack.push(Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform()));\n        return this;\n    }\n    popBaseTransform() {\n        if (this.#baseTransformStack.length > 1) {\n            this.#baseTransformStack.pop();\n        }\n        return this;\n    }\n    recordSimpleData(name, idx) {\n        this.#simple[name] = idx;\n        return this;\n    }\n    recordIncrementalData(name, idx) {\n        this.#incremental[name].push(idx);\n        return this;\n    }\n    resetIncrementalData(name, idx) {\n        this.#incremental[name].length = 0;\n        return this;\n    }\n    recordNamedData(name, idx) {\n        this.#namedDependencies.set(name, idx);\n        return this;\n    }\n    recordSimpleDataFromNamed(name, depName, fallbackIdx) {\n        this.#simple[name] = this.#namedDependencies.get(depName) ?? fallbackIdx;\n    }\n    recordFutureForcedDependency(name, idx) {\n        this.recordIncrementalData(FORCED_DEPENDENCY_LABEL, idx);\n        return this;\n    }\n    inheritSimpleDataAsFutureForcedDependencies(names) {\n        for (const name of names){\n            if (name in this.#simple) {\n                this.recordFutureForcedDependency(name, this.#simple[name]);\n            }\n        }\n        return this;\n    }\n    inheritPendingDependenciesAsFutureForcedDependencies() {\n        for (const dep of this.#pendingDependencies){\n            this.recordFutureForcedDependency(FORCED_DEPENDENCY_LABEL, dep);\n        }\n        return this;\n    }\n    resetBBox(idx) {\n        if (this.#pendingBBoxIdx !== idx) {\n            this.#pendingBBoxIdx = idx;\n            this.#pendingBBox[0] = Infinity;\n            this.#pendingBBox[1] = Infinity;\n            this.#pendingBBox[2] = -Infinity;\n            this.#pendingBBox[3] = -Infinity;\n        }\n        return this;\n    }\n    recordClipBox(idx, ctx, minX, maxX, minY, maxY) {\n        const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());\n        const clipBox = [\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ];\n        Util.axialAlignedBoundingBox([\n            minX,\n            minY,\n            maxX,\n            maxY\n        ], transform, clipBox);\n        const intersection = Util.intersect(this.#clipBox, clipBox);\n        if (intersection) {\n            this.#clipBox[0] = intersection[0];\n            this.#clipBox[1] = intersection[1];\n            this.#clipBox[2] = intersection[2];\n            this.#clipBox[3] = intersection[3];\n        } else {\n            this.#clipBox[0] = this.#clipBox[1] = Infinity;\n            this.#clipBox[2] = this.#clipBox[3] = -Infinity;\n        }\n        return this;\n    }\n    recordBBox(idx, ctx, minX, maxX, minY, maxY) {\n        const clipBox = this.#clipBox;\n        if (clipBox[0] === Infinity) {\n            return this;\n        }\n        const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());\n        if (clipBox[0] === -Infinity) {\n            Util.axialAlignedBoundingBox([\n                minX,\n                minY,\n                maxX,\n                maxY\n            ], transform, this.#pendingBBox);\n            return this;\n        }\n        const bbox = [\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ];\n        Util.axialAlignedBoundingBox([\n            minX,\n            minY,\n            maxX,\n            maxY\n        ], transform, bbox);\n        this.#pendingBBox[0] = Math.min(this.#pendingBBox[0], Math.max(bbox[0], clipBox[0]));\n        this.#pendingBBox[1] = Math.min(this.#pendingBBox[1], Math.max(bbox[1], clipBox[1]));\n        this.#pendingBBox[2] = Math.max(this.#pendingBBox[2], Math.min(bbox[2], clipBox[2]));\n        this.#pendingBBox[3] = Math.max(this.#pendingBBox[3], Math.min(bbox[3], clipBox[3]));\n        return this;\n    }\n    recordCharacterBBox(idx, ctx, font, scale = 1, x = 0, y = 0, getMeasure) {\n        const fontBBox = font.bbox;\n        let isBBoxTrustworthy;\n        let computedBBox;\n        if (fontBBox) {\n            isBBoxTrustworthy = fontBBox[2] !== fontBBox[0] && fontBBox[3] !== fontBBox[1] && this.#fontBBoxTrustworthy.get(font);\n            if (isBBoxTrustworthy !== false) {\n                computedBBox = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                Util.axialAlignedBoundingBox(fontBBox, font.fontMatrix, computedBBox);\n                if (scale !== 1 || x !== 0 || y !== 0) {\n                    Util.scaleMinMax([\n                        scale,\n                        0,\n                        0,\n                        -scale,\n                        x,\n                        y\n                    ], computedBBox);\n                }\n                if (isBBoxTrustworthy) {\n                    return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);\n                }\n            }\n        }\n        if (!getMeasure) {\n            return this.recordFullPageBBox(idx);\n        }\n        const measure = getMeasure();\n        if (fontBBox && computedBBox && isBBoxTrustworthy === undefined) {\n            isBBoxTrustworthy = computedBBox[0] <= x - measure.actualBoundingBoxLeft && computedBBox[2] >= x + measure.actualBoundingBoxRight && computedBBox[1] <= y - measure.actualBoundingBoxAscent && computedBBox[3] >= y + measure.actualBoundingBoxDescent;\n            this.#fontBBoxTrustworthy.set(font, isBBoxTrustworthy);\n            if (isBBoxTrustworthy) {\n                return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);\n            }\n        }\n        return this.recordBBox(idx, ctx, x - measure.actualBoundingBoxLeft, x + measure.actualBoundingBoxRight, y - measure.actualBoundingBoxAscent, y + measure.actualBoundingBoxDescent);\n    }\n    recordFullPageBBox(idx) {\n        this.#pendingBBox[0] = Math.max(0, this.#clipBox[0]);\n        this.#pendingBBox[1] = Math.max(0, this.#clipBox[1]);\n        this.#pendingBBox[2] = Math.min(this.#canvasWidth, this.#clipBox[2]);\n        this.#pendingBBox[3] = Math.min(this.#canvasHeight, this.#clipBox[3]);\n        return this;\n    }\n    getSimpleIndex(dependencyName) {\n        return this.#simple[dependencyName];\n    }\n    recordDependencies(idx, dependencyNames) {\n        const pendingDependencies = this.#pendingDependencies;\n        const simple = this.#simple;\n        const incremental = this.#incremental;\n        for (const name of dependencyNames){\n            if (name in this.#simple) {\n                pendingDependencies.add(simple[name]);\n            } else if (name in incremental) {\n                incremental[name].forEach(pendingDependencies.add, pendingDependencies);\n            }\n        }\n        return this;\n    }\n    recordNamedDependency(idx, name) {\n        if (this.#namedDependencies.has(name)) {\n            this.#pendingDependencies.add(this.#namedDependencies.get(name));\n        }\n        return this;\n    }\n    recordOperation(idx, preserve = false) {\n        this.recordDependencies(idx, [\n            FORCED_DEPENDENCY_LABEL\n        ]);\n        if (this.#debugMetadata) {\n            const metadata = ensureDebugMetadata(this.#debugMetadata, idx);\n            const { dependencies } = metadata;\n            this.#pendingDependencies.forEach(dependencies.add, dependencies);\n            this.#savesStack.forEach(dependencies.add, dependencies);\n            this.#markedContentStack.forEach(dependencies.add, dependencies);\n            dependencies.delete(idx);\n            metadata.isRenderingOperation = true;\n        }\n        if (this.#pendingBBoxIdx === idx) {\n            const minX = floor(this.#pendingBBox[0] * 256 / this.#canvasWidth);\n            const minY = floor(this.#pendingBBox[1] * 256 / this.#canvasHeight);\n            const maxX = ceil(this.#pendingBBox[2] * 256 / this.#canvasWidth);\n            const maxY = ceil(this.#pendingBBox[3] * 256 / this.#canvasHeight);\n            expandBBox(this.#bboxesCoords, idx, minX, minY, maxX, maxY);\n            for (const depIdx of this.#pendingDependencies){\n                if (depIdx !== idx) {\n                    expandBBox(this.#bboxesCoords, depIdx, minX, minY, maxX, maxY);\n                }\n            }\n            for (const saveIdx of this.#savesStack){\n                if (saveIdx !== idx) {\n                    expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);\n                }\n            }\n            for (const saveIdx of this.#markedContentStack){\n                if (saveIdx !== idx) {\n                    expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);\n                }\n            }\n            if (!preserve) {\n                this.#pendingDependencies.clear();\n                this.#pendingBBoxIdx = -1;\n            }\n        }\n        return this;\n    }\n    recordShowTextOperation(idx, preserve = false) {\n        const deps = Array.from(this.#pendingDependencies);\n        this.recordOperation(idx, preserve);\n        this.recordIncrementalData(\"sameLineText\", idx);\n        for (const dep of deps){\n            this.recordIncrementalData(\"sameLineText\", dep);\n        }\n        return this;\n    }\n    bboxToClipBoxDropOperation(idx, preserve = false) {\n        if (this.#pendingBBoxIdx === idx) {\n            this.#pendingBBoxIdx = -1;\n            this.#clipBox[0] = Math.max(this.#clipBox[0], this.#pendingBBox[0]);\n            this.#clipBox[1] = Math.max(this.#clipBox[1], this.#pendingBBox[1]);\n            this.#clipBox[2] = Math.min(this.#clipBox[2], this.#pendingBBox[2]);\n            this.#clipBox[3] = Math.min(this.#clipBox[3], this.#pendingBBox[3]);\n            if (!preserve) {\n                this.#pendingDependencies.clear();\n            }\n        }\n        return this;\n    }\n    _takePendingDependencies() {\n        const pendingDependencies = this.#pendingDependencies;\n        this.#pendingDependencies = new Set();\n        return pendingDependencies;\n    }\n    _extractOperation(idx) {\n        const operation = this.#operations.get(idx);\n        this.#operations.delete(idx);\n        return operation;\n    }\n    _pushPendingDependencies(dependencies) {\n        for (const dep of dependencies){\n            this.#pendingDependencies.add(dep);\n        }\n    }\n    take() {\n        this.#fontBBoxTrustworthy.clear();\n        return new BBoxReader(this.#bboxes, this.#bboxesCoords);\n    }\n    takeDebugMetadata() {\n        return this.#debugMetadata;\n    }\n}\nclass CanvasNestedDependencyTracker {\n    #dependencyTracker;\n    #opIdx;\n    #ignoreBBoxes;\n    #nestingLevel;\n    #savesLevel;\n    constructor(dependencyTracker, opIdx, ignoreBBoxes){\n        this.#nestingLevel = 0;\n        this.#savesLevel = 0;\n        if (dependencyTracker instanceof CanvasNestedDependencyTracker && dependencyTracker.#ignoreBBoxes === !!ignoreBBoxes) {\n            return dependencyTracker;\n        }\n        this.#dependencyTracker = dependencyTracker;\n        this.#opIdx = opIdx;\n        this.#ignoreBBoxes = !!ignoreBBoxes;\n    }\n    growOperationsCount() {\n        throw new Error(\"Unreachable\");\n    }\n    save(opIdx) {\n        this.#savesLevel++;\n        this.#dependencyTracker.save(this.#opIdx);\n        return this;\n    }\n    restore(opIdx) {\n        if (this.#savesLevel > 0) {\n            this.#dependencyTracker.restore(this.#opIdx);\n            this.#savesLevel--;\n        }\n        return this;\n    }\n    recordOpenMarker(idx) {\n        this.#nestingLevel++;\n        return this;\n    }\n    getOpenMarker() {\n        return this.#nestingLevel > 0 ? this.#opIdx : this.#dependencyTracker.getOpenMarker();\n    }\n    recordCloseMarker(idx) {\n        this.#nestingLevel--;\n        return this;\n    }\n    beginMarkedContent(opIdx) {\n        return this;\n    }\n    endMarkedContent(opIdx) {\n        return this;\n    }\n    pushBaseTransform(ctx) {\n        this.#dependencyTracker.pushBaseTransform(ctx);\n        return this;\n    }\n    popBaseTransform() {\n        this.#dependencyTracker.popBaseTransform();\n        return this;\n    }\n    recordSimpleData(name, idx) {\n        this.#dependencyTracker.recordSimpleData(name, this.#opIdx);\n        return this;\n    }\n    recordIncrementalData(name, idx) {\n        this.#dependencyTracker.recordIncrementalData(name, this.#opIdx);\n        return this;\n    }\n    resetIncrementalData(name, idx) {\n        this.#dependencyTracker.resetIncrementalData(name, this.#opIdx);\n        return this;\n    }\n    recordNamedData(name, idx) {\n        return this;\n    }\n    recordSimpleDataFromNamed(name, depName, fallbackIdx) {\n        this.#dependencyTracker.recordSimpleDataFromNamed(name, depName, this.#opIdx);\n        return this;\n    }\n    recordFutureForcedDependency(name, idx) {\n        this.#dependencyTracker.recordFutureForcedDependency(name, this.#opIdx);\n        return this;\n    }\n    inheritSimpleDataAsFutureForcedDependencies(names) {\n        this.#dependencyTracker.inheritSimpleDataAsFutureForcedDependencies(names);\n        return this;\n    }\n    inheritPendingDependenciesAsFutureForcedDependencies() {\n        this.#dependencyTracker.inheritPendingDependenciesAsFutureForcedDependencies();\n        return this;\n    }\n    resetBBox(idx) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.resetBBox(this.#opIdx);\n        }\n        return this;\n    }\n    recordClipBox(idx, ctx, minX, maxX, minY, maxY) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.recordClipBox(this.#opIdx, ctx, minX, maxX, minY, maxY);\n        }\n        return this;\n    }\n    recordBBox(idx, ctx, minX, maxX, minY, maxY) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.recordBBox(this.#opIdx, ctx, minX, maxX, minY, maxY);\n        }\n        return this;\n    }\n    recordCharacterBBox(idx, ctx, font, scale, x, y, getMeasure) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.recordCharacterBBox(this.#opIdx, ctx, font, scale, x, y, getMeasure);\n        }\n        return this;\n    }\n    recordFullPageBBox(idx) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.recordFullPageBBox(this.#opIdx);\n        }\n        return this;\n    }\n    getSimpleIndex(dependencyName) {\n        return this.#dependencyTracker.getSimpleIndex(dependencyName);\n    }\n    recordDependencies(idx, dependencyNames) {\n        this.#dependencyTracker.recordDependencies(this.#opIdx, dependencyNames);\n        return this;\n    }\n    recordNamedDependency(idx, name) {\n        this.#dependencyTracker.recordNamedDependency(this.#opIdx, name);\n        return this;\n    }\n    recordOperation(idx) {\n        this.#dependencyTracker.recordOperation(this.#opIdx, true);\n        return this;\n    }\n    recordShowTextOperation(idx) {\n        this.#dependencyTracker.recordShowTextOperation(this.#opIdx, true);\n        return this;\n    }\n    bboxToClipBoxDropOperation(idx) {\n        if (!this.#ignoreBBoxes) {\n            this.#dependencyTracker.bboxToClipBoxDropOperation(this.#opIdx, true);\n        }\n        return this;\n    }\n    take() {\n        throw new Error(\"Unreachable\");\n    }\n    takeDebugMetadata() {\n        throw new Error(\"Unreachable\");\n    }\n}\nconst Dependencies = {\n    stroke: [\n        \"path\",\n        \"transform\",\n        \"filter\",\n        \"strokeColor\",\n        \"strokeAlpha\",\n        \"lineWidth\",\n        \"lineCap\",\n        \"lineJoin\",\n        \"miterLimit\",\n        \"dash\"\n    ],\n    fill: [\n        \"path\",\n        \"transform\",\n        \"filter\",\n        \"fillColor\",\n        \"fillAlpha\",\n        \"globalCompositeOperation\",\n        \"SMask\"\n    ],\n    imageXObject: [\n        \"transform\",\n        \"SMask\",\n        \"filter\",\n        \"fillAlpha\",\n        \"strokeAlpha\",\n        \"globalCompositeOperation\"\n    ],\n    rawFillPath: [\n        \"filter\",\n        \"fillColor\",\n        \"fillAlpha\"\n    ],\n    showText: [\n        \"transform\",\n        \"leading\",\n        \"charSpacing\",\n        \"wordSpacing\",\n        \"hScale\",\n        \"textRise\",\n        \"moveText\",\n        \"textMatrix\",\n        \"font\",\n        \"fontObj\",\n        \"filter\",\n        \"fillColor\",\n        \"textRenderingMode\",\n        \"SMask\",\n        \"fillAlpha\",\n        \"strokeAlpha\",\n        \"globalCompositeOperation\",\n        \"sameLineText\"\n    ],\n    transform: [\n        \"transform\"\n    ],\n    transformAndFill: [\n        \"transform\",\n        \"fillColor\"\n    ]\n};\n; // ./src/display/pattern_helper.js\nconst PathType = {\n    FILL: \"Fill\",\n    STROKE: \"Stroke\",\n    SHADING: \"Shading\"\n};\nfunction applyBoundingBox(ctx, bbox) {\n    if (!bbox) {\n        return;\n    }\n    const width = bbox[2] - bbox[0];\n    const height = bbox[3] - bbox[1];\n    const region = new Path2D();\n    region.rect(bbox[0], bbox[1], width, height);\n    ctx.clip(region);\n}\nclass BaseShadingPattern {\n    isModifyingCurrentTransform() {\n        return false;\n    }\n    getPattern() {\n        unreachable(\"Abstract method `getPattern` called.\");\n    }\n}\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._type = IR[1];\n        this._bbox = IR[2];\n        this._colorStops = IR[3];\n        this._p0 = IR[4];\n        this._p1 = IR[5];\n        this._r0 = IR[6];\n        this._r1 = IR[7];\n        this.matrix = null;\n    }\n    _createGradient(ctx) {\n        let grad;\n        if (this._type === \"axial\") {\n            grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n        } else if (this._type === \"radial\") {\n            grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n        }\n        for (const colorStop of this._colorStops){\n            grad.addColorStop(colorStop[0], colorStop[1]);\n        }\n        return grad;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        let pattern;\n        if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n            const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [\n                0,\n                0,\n                0,\n                0\n            ];\n            const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n            const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n            const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.beginPath();\n            tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n            inverse = Util.transform(inverse, [\n                1,\n                0,\n                0,\n                1,\n                ownerBBox[0],\n                ownerBBox[1]\n            ]);\n            tmpCtx.transform(...owner.baseTransform);\n            if (this.matrix) {\n                tmpCtx.transform(...this.matrix);\n            }\n            applyBoundingBox(tmpCtx, this._bbox);\n            tmpCtx.fillStyle = this._createGradient(tmpCtx);\n            tmpCtx.fill();\n            pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n            const domMatrix = new DOMMatrix(inverse);\n            pattern.setTransform(domMatrix);\n        } else {\n            applyBoundingBox(ctx, this._bbox);\n            pattern = this._createGradient(ctx);\n        }\n        return pattern;\n    }\n}\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n    const coords = context.coords, colors = context.colors;\n    const bytes = data.data, rowSize = data.width * 4;\n    let tmp;\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    if (coords[p2 + 1] > coords[p3 + 1]) {\n        tmp = p2;\n        p2 = p3;\n        p3 = tmp;\n        tmp = c2;\n        c2 = c3;\n        c3 = tmp;\n    }\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n    const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n    const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n    if (y1 >= y3) {\n        return;\n    }\n    const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];\n    const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];\n    const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];\n    const minY = Math.round(y1), maxY = Math.round(y3);\n    let xa, car, cag, cab;\n    let xb, cbr, cbg, cbb;\n    for(let y = minY; y <= maxY; y++){\n        if (y < y2) {\n            const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n            xa = x1 - (x1 - x2) * k;\n            car = c1r - (c1r - c2r) * k;\n            cag = c1g - (c1g - c2g) * k;\n            cab = c1b - (c1b - c2b) * k;\n        } else {\n            let k;\n            if (y > y3) {\n                k = 1;\n            } else if (y2 === y3) {\n                k = 0;\n            } else {\n                k = (y2 - y) / (y2 - y3);\n            }\n            xa = x2 - (x2 - x3) * k;\n            car = c2r - (c2r - c3r) * k;\n            cag = c2g - (c2g - c3g) * k;\n            cab = c2b - (c2b - c3b) * k;\n        }\n        let k;\n        if (y < y1) {\n            k = 0;\n        } else if (y > y3) {\n            k = 1;\n        } else {\n            k = (y1 - y) / (y1 - y3);\n        }\n        xb = x1 - (x1 - x3) * k;\n        cbr = c1r - (c1r - c3r) * k;\n        cbg = c1g - (c1g - c3g) * k;\n        cbb = c1b - (c1b - c3b) * k;\n        const x1_ = Math.round(Math.min(xa, xb));\n        const x2_ = Math.round(Math.max(xa, xb));\n        let j = rowSize * y + x1_ * 4;\n        for(let x = x1_; x <= x2_; x++){\n            k = (xa - x) / (xa - xb);\n            if (k < 0) {\n                k = 0;\n            } else if (k > 1) {\n                k = 1;\n            }\n            bytes[j++] = car - (car - cbr) * k | 0;\n            bytes[j++] = cag - (cag - cbg) * k | 0;\n            bytes[j++] = cab - (cab - cbb) * k | 0;\n            bytes[j++] = 255;\n        }\n    }\n}\nfunction drawFigure(data, figure, context) {\n    const ps = figure.coords;\n    const cs = figure.colors;\n    let i, ii;\n    switch(figure.type){\n        case \"lattice\":\n            const verticesPerRow = figure.verticesPerRow;\n            const rows = Math.floor(ps.length / verticesPerRow) - 1;\n            const cols = verticesPerRow - 1;\n            for(i = 0; i < rows; i++){\n                let q = i * verticesPerRow;\n                for(let j = 0; j < cols; j++, q++){\n                    drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                    drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n                }\n            }\n            break;\n        case \"triangles\":\n            for(i = 0, ii = ps.length; i < ii; i += 3){\n                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n            }\n            break;\n        default:\n            throw new Error(\"illegal figure\");\n    }\n}\nclass MeshShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._coords = IR[2];\n        this._colors = IR[3];\n        this._figures = IR[4];\n        this._bounds = IR[5];\n        this._bbox = IR[6];\n        this._background = IR[7];\n        this.matrix = null;\n    }\n    _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n        const EXPECTED_SCALE = 1.1;\n        const MAX_PATTERN_SIZE = 3000;\n        const BORDER_SIZE = 2;\n        const offsetX = Math.floor(this._bounds[0]);\n        const offsetY = Math.floor(this._bounds[1]);\n        const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n        const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n        const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const scaleX = boundsWidth / width;\n        const scaleY = boundsHeight / height;\n        const context = {\n            coords: this._coords,\n            colors: this._colors,\n            offsetX: -offsetX,\n            offsetY: -offsetY,\n            scaleX: 1 / scaleX,\n            scaleY: 1 / scaleY\n        };\n        const paddedWidth = width + BORDER_SIZE * 2;\n        const paddedHeight = height + BORDER_SIZE * 2;\n        const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight);\n        const tmpCtx = tmpCanvas.context;\n        const data = tmpCtx.createImageData(width, height);\n        if (backgroundColor) {\n            const bytes = data.data;\n            for(let i = 0, ii = bytes.length; i < ii; i += 4){\n                bytes[i] = backgroundColor[0];\n                bytes[i + 1] = backgroundColor[1];\n                bytes[i + 2] = backgroundColor[2];\n                bytes[i + 3] = 255;\n            }\n        }\n        for (const figure of this._figures){\n            drawFigure(data, figure, context);\n        }\n        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n        const canvas = tmpCanvas.canvas;\n        return {\n            canvas,\n            offsetX: offsetX - BORDER_SIZE * scaleX,\n            offsetY: offsetY - BORDER_SIZE * scaleY,\n            scaleX,\n            scaleY\n        };\n    }\n    isModifyingCurrentTransform() {\n        return true;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        applyBoundingBox(ctx, this._bbox);\n        const scale = new Float32Array(2);\n        if (pathType === PathType.SHADING) {\n            Util.singularValueDecompose2dScale(getCurrentTransform(ctx), scale);\n        } else if (this.matrix) {\n            Util.singularValueDecompose2dScale(this.matrix, scale);\n            const [matrixScaleX, matrixScaleY] = scale;\n            Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n            scale[0] *= matrixScaleX;\n            scale[1] *= matrixScaleY;\n        } else {\n            Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n        }\n        const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n        if (pathType !== PathType.SHADING) {\n            ctx.setTransform(...owner.baseTransform);\n            if (this.matrix) {\n                ctx.transform(...this.matrix);\n            }\n        }\n        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n        return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n    }\n}\nclass DummyShadingPattern extends BaseShadingPattern {\n    getPattern() {\n        return \"hotpink\";\n    }\n}\nfunction getShadingPattern(IR) {\n    switch(IR[0]){\n        case \"RadialAxial\":\n            return new RadialAxialShadingPattern(IR);\n        case \"Mesh\":\n            return new MeshShadingPattern(IR);\n        case \"Dummy\":\n            return new DummyShadingPattern();\n    }\n    throw new Error(`Unknown IR type: ${IR[0]}`);\n}\nconst PaintType = {\n    COLORED: 1,\n    UNCOLORED: 2\n};\nclass TilingPattern {\n    static{\n        this.MAX_PATTERN_SIZE = 3000;\n    }\n    constructor(IR, ctx, canvasGraphicsFactory, baseTransform){\n        this.color = IR[1];\n        this.operatorList = IR[2];\n        this.matrix = IR[3];\n        this.bbox = IR[4];\n        this.xstep = IR[5];\n        this.ystep = IR[6];\n        this.paintType = IR[7];\n        this.tilingType = IR[8];\n        this.ctx = ctx;\n        this.canvasGraphicsFactory = canvasGraphicsFactory;\n        this.baseTransform = baseTransform;\n    }\n    createPatternCanvas(owner, opIdx) {\n        const { bbox, operatorList, paintType, tilingType, color, canvasGraphicsFactory } = this;\n        let { xstep, ystep } = this;\n        xstep = Math.abs(xstep);\n        ystep = Math.abs(ystep);\n        info(\"TilingType: \" + tilingType);\n        const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];\n        const width = x1 - x0;\n        const height = y1 - y0;\n        const scale = new Float32Array(2);\n        Util.singularValueDecompose2dScale(this.matrix, scale);\n        const [matrixScaleX, matrixScaleY] = scale;\n        Util.singularValueDecompose2dScale(this.baseTransform, scale);\n        const combinedScaleX = matrixScaleX * scale[0];\n        const combinedScaleY = matrixScaleY * scale[1];\n        let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;\n        const xScaledStep = Math.ceil(xstep * combinedScaleX);\n        const yScaledStep = Math.ceil(ystep * combinedScaleY);\n        const xScaledWidth = Math.ceil(width * combinedScaleX);\n        const yScaledHeight = Math.ceil(height * combinedScaleY);\n        if (xScaledStep >= xScaledWidth) {\n            canvasWidth = xstep;\n        } else {\n            redrawHorizontally = true;\n        }\n        if (yScaledStep >= yScaledHeight) {\n            canvasHeight = ystep;\n        } else {\n            redrawVertically = true;\n        }\n        const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n        const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n        const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size);\n        const tmpCtx = tmpCanvas.context;\n        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx, opIdx);\n        graphics.groupLevel = owner.groupLevel;\n        this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n        tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);\n        graphics.transform(0, dimx.scale, 0, 0, dimy.scale, 0, 0);\n        tmpCtx.save();\n        graphics.dependencyTracker?.save();\n        this.clipBbox(graphics, x0, y0, x1, y1);\n        graphics.baseTransform = getCurrentTransform(graphics.ctx);\n        graphics.executeOperatorList(operatorList);\n        graphics.endDrawing();\n        graphics.dependencyTracker?.restore();\n        tmpCtx.restore();\n        if (redrawHorizontally || redrawVertically) {\n            const image = tmpCanvas.canvas;\n            if (redrawHorizontally) {\n                canvasWidth = xstep;\n            }\n            if (redrawVertically) {\n                canvasHeight = ystep;\n            }\n            const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n            const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n            const xSize = dimx2.size;\n            const ySize = dimy2.size;\n            const tmpCanvas2 = owner.cachedCanvases.getCanvas(\"pattern-workaround\", xSize, ySize);\n            const tmpCtx2 = tmpCanvas2.context;\n            const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;\n            const jj = redrawVertically ? Math.floor(height / ystep) : 0;\n            for(let i = 0; i <= ii; i++){\n                for(let j = 0; j <= jj; j++){\n                    tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);\n                }\n            }\n            return {\n                canvas: tmpCanvas2.canvas,\n                scaleX: dimx2.scale,\n                scaleY: dimy2.scale,\n                offsetX: x0,\n                offsetY: y0\n            };\n        }\n        return {\n            canvas: tmpCanvas.canvas,\n            scaleX: dimx.scale,\n            scaleY: dimy.scale,\n            offsetX: x0,\n            offsetY: y0\n        };\n    }\n    getSizeAndScale(step, realOutputSize, scale) {\n        const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n        let size = Math.ceil(step * scale);\n        if (size >= maxSize) {\n            size = maxSize;\n        } else {\n            scale = size / step;\n        }\n        return {\n            scale,\n            size\n        };\n    }\n    clipBbox(graphics, x0, y0, x1, y1) {\n        const bboxWidth = x1 - x0;\n        const bboxHeight = y1 - y0;\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n        Util.axialAlignedBoundingBox([\n            x0,\n            y0,\n            x1,\n            y1\n        ], getCurrentTransform(graphics.ctx), graphics.current.minMax);\n        graphics.clip();\n        graphics.endPath();\n    }\n    setFillAndStrokeStyleToContext(graphics, paintType, color) {\n        const context = graphics.ctx, current = graphics.current;\n        switch(paintType){\n            case PaintType.COLORED:\n                const { fillStyle, strokeStyle } = this.ctx;\n                context.fillStyle = current.fillColor = fillStyle;\n                context.strokeStyle = current.strokeColor = strokeStyle;\n                break;\n            case PaintType.UNCOLORED:\n                context.fillStyle = context.strokeStyle = color;\n                current.fillColor = current.strokeColor = color;\n                break;\n            default:\n                throw new FormatError(`Unsupported paint type: ${paintType}`);\n        }\n    }\n    isModifyingCurrentTransform() {\n        return false;\n    }\n    getPattern(ctx, owner, inverse, pathType, opIdx) {\n        let matrix = inverse;\n        if (pathType !== PathType.SHADING) {\n            matrix = Util.transform(matrix, owner.baseTransform);\n            if (this.matrix) {\n                matrix = Util.transform(matrix, this.matrix);\n            }\n        }\n        const temporaryPatternCanvas = this.createPatternCanvas(owner, opIdx);\n        let domMatrix = new DOMMatrix(matrix);\n        domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n        const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n        pattern.setTransform(domMatrix);\n        return pattern;\n    }\n}\n; // ./src/shared/image_utils.js\nfunction convertToRGBA(params) {\n    switch(params.kind){\n        case ImageKind.GRAYSCALE_1BPP:\n            return convertBlackAndWhiteToRGBA(params);\n        case ImageKind.RGB_24BPP:\n            return convertRGBToRGBA(params);\n    }\n    return null;\n}\nfunction convertBlackAndWhiteToRGBA({ src, srcPos = 0, dest, width, height, nonBlackColor = 0xffffffff, inverseDecode = false }) {\n    const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n    const [zeroMapping, oneMapping] = inverseDecode ? [\n        nonBlackColor,\n        black\n    ] : [\n        black,\n        nonBlackColor\n    ];\n    const widthInSource = width >> 3;\n    const widthRemainder = width & 7;\n    const srcLength = src.length;\n    dest = new Uint32Array(dest.buffer);\n    let destPos = 0;\n    for(let i = 0; i < height; i++){\n        for(const max = srcPos + widthInSource; srcPos < max; srcPos++){\n            const elem = srcPos < srcLength ? src[srcPos] : 255;\n            dest[destPos++] = elem & 128 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 64 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 32 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 16 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 8 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 4 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 2 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 1 ? oneMapping : zeroMapping;\n        }\n        if (widthRemainder === 0) {\n            continue;\n        }\n        const elem = srcPos < srcLength ? src[srcPos++] : 255;\n        for(let j = 0; j < widthRemainder; j++){\n            dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n        }\n    }\n    return {\n        srcPos,\n        destPos\n    };\n}\nfunction convertRGBToRGBA({ src, srcPos = 0, dest, destPos = 0, width, height }) {\n    let i = 0;\n    const len = width * height * 3;\n    const len32 = len >> 2;\n    const src32 = new Uint32Array(src.buffer, srcPos, len32);\n    if (FeatureTest.isLittleEndian) {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff000000;\n            dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n            dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n            dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n        }\n        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3){\n            dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n        }\n    } else {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff;\n            dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n            dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n            dest[destPos + 3] = s3 << 8 | 0xff;\n        }\n        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3){\n            dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n        }\n    }\n    return {\n        srcPos: srcPos + len,\n        destPos\n    };\n}\nfunction grayToRGBA(src, dest) {\n    if (FeatureTest.isLittleEndian) {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x10101 | 0xff000000;\n        }\n    } else {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x1010100 | 0x000000ff;\n        }\n    }\n}\n; // ./src/display/canvas.js\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst FULL_CHUNK_HEIGHT = 16;\nconst SCALE_MATRIX = new DOMMatrix();\nconst XY = new Float32Array(2);\nconst MIN_MAX_INIT = new Float32Array([\n    Infinity,\n    Infinity,\n    -Infinity,\n    -Infinity\n]);\nfunction mirrorContextOperations(ctx, destCtx) {\n    if (ctx._removeMirroring) {\n        throw new Error(\"Context is already forwarding operations.\");\n    }\n    ctx.__originalSave = ctx.save;\n    ctx.__originalRestore = ctx.restore;\n    ctx.__originalRotate = ctx.rotate;\n    ctx.__originalScale = ctx.scale;\n    ctx.__originalTranslate = ctx.translate;\n    ctx.__originalTransform = ctx.transform;\n    ctx.__originalSetTransform = ctx.setTransform;\n    ctx.__originalResetTransform = ctx.resetTransform;\n    ctx.__originalClip = ctx.clip;\n    ctx.__originalMoveTo = ctx.moveTo;\n    ctx.__originalLineTo = ctx.lineTo;\n    ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n    ctx.__originalRect = ctx.rect;\n    ctx.__originalClosePath = ctx.closePath;\n    ctx.__originalBeginPath = ctx.beginPath;\n    ctx._removeMirroring = ()=>{\n        ctx.save = ctx.__originalSave;\n        ctx.restore = ctx.__originalRestore;\n        ctx.rotate = ctx.__originalRotate;\n        ctx.scale = ctx.__originalScale;\n        ctx.translate = ctx.__originalTranslate;\n        ctx.transform = ctx.__originalTransform;\n        ctx.setTransform = ctx.__originalSetTransform;\n        ctx.resetTransform = ctx.__originalResetTransform;\n        ctx.clip = ctx.__originalClip;\n        ctx.moveTo = ctx.__originalMoveTo;\n        ctx.lineTo = ctx.__originalLineTo;\n        ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n        ctx.rect = ctx.__originalRect;\n        ctx.closePath = ctx.__originalClosePath;\n        ctx.beginPath = ctx.__originalBeginPath;\n        delete ctx._removeMirroring;\n    };\n    ctx.save = function() {\n        destCtx.save();\n        this.__originalSave();\n    };\n    ctx.restore = function() {\n        destCtx.restore();\n        this.__originalRestore();\n    };\n    ctx.translate = function(x, y) {\n        destCtx.translate(x, y);\n        this.__originalTranslate(x, y);\n    };\n    ctx.scale = function(x, y) {\n        destCtx.scale(x, y);\n        this.__originalScale(x, y);\n    };\n    ctx.transform = function(a, b, c, d, e, f) {\n        destCtx.transform(a, b, c, d, e, f);\n        this.__originalTransform(a, b, c, d, e, f);\n    };\n    ctx.setTransform = function(a, b, c, d, e, f) {\n        destCtx.setTransform(a, b, c, d, e, f);\n        this.__originalSetTransform(a, b, c, d, e, f);\n    };\n    ctx.resetTransform = function() {\n        destCtx.resetTransform();\n        this.__originalResetTransform();\n    };\n    ctx.rotate = function(angle) {\n        destCtx.rotate(angle);\n        this.__originalRotate(angle);\n    };\n    ctx.clip = function(rule) {\n        destCtx.clip(rule);\n        this.__originalClip(rule);\n    };\n    ctx.moveTo = function(x, y) {\n        destCtx.moveTo(x, y);\n        this.__originalMoveTo(x, y);\n    };\n    ctx.lineTo = function(x, y) {\n        destCtx.lineTo(x, y);\n        this.__originalLineTo(x, y);\n    };\n    ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n        destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n        this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    };\n    ctx.rect = function(x, y, width, height) {\n        destCtx.rect(x, y, width, height);\n        this.__originalRect(x, y, width, height);\n    };\n    ctx.closePath = function() {\n        destCtx.closePath();\n        this.__originalClosePath();\n    };\n    ctx.beginPath = function() {\n        destCtx.beginPath();\n        this.__originalBeginPath();\n    };\n}\nclass CachedCanvases {\n    constructor(canvasFactory){\n        this.canvasFactory = canvasFactory;\n        this.cache = Object.create(null);\n    }\n    getCanvas(id, width, height) {\n        let canvasEntry;\n        if (this.cache[id] !== undefined) {\n            canvasEntry = this.cache[id];\n            this.canvasFactory.reset(canvasEntry, width, height);\n        } else {\n            canvasEntry = this.canvasFactory.create(width, height);\n            this.cache[id] = canvasEntry;\n        }\n        return canvasEntry;\n    }\n    delete(id) {\n        delete this.cache[id];\n    }\n    clear() {\n        for(const id in this.cache){\n            const canvasEntry = this.cache[id];\n            this.canvasFactory.destroy(canvasEntry);\n            delete this.cache[id];\n        }\n    }\n}\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n    const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);\n    if (b === 0 && c === 0) {\n        const tlX = destX * a + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destY * d + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destX + destW) * a + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destY + destH) * d + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rWidth,\n            rHeight\n        ];\n    }\n    if (a === 0 && d === 0) {\n        const tlX = destY * c + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destX * b + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destY + destH) * c + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destX + destW) * b + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rHeight,\n            rWidth\n        ];\n    }\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n    const scaleX = Math.hypot(a, b);\n    const scaleY = Math.hypot(c, d);\n    return [\n        scaleX * destW,\n        scaleY * destH\n    ];\n}\nclass CanvasExtraState {\n    constructor(width, height, preInit){\n        this.alphaIsShape = false;\n        this.fontSize = 0;\n        this.fontSizeScale = 1;\n        this.textMatrix = null;\n        this.textMatrixScale = 1;\n        this.fontMatrix = FONT_IDENTITY_MATRIX;\n        this.leading = 0;\n        this.x = 0;\n        this.y = 0;\n        this.lineX = 0;\n        this.lineY = 0;\n        this.charSpacing = 0;\n        this.wordSpacing = 0;\n        this.textHScale = 1;\n        this.textRenderingMode = TextRenderingMode.FILL;\n        this.textRise = 0;\n        this.fillColor = \"#000000\";\n        this.strokeColor = \"#000000\";\n        this.patternFill = false;\n        this.patternStroke = false;\n        this.fillAlpha = 1;\n        this.strokeAlpha = 1;\n        this.lineWidth = 1;\n        this.activeSMask = null;\n        this.transferMaps = \"none\";\n        preInit?.(this);\n        this.clipBox = new Float32Array([\n            0,\n            0,\n            width,\n            height\n        ]);\n        this.minMax = MIN_MAX_INIT.slice();\n    }\n    clone() {\n        const clone = Object.create(this);\n        clone.clipBox = this.clipBox.slice();\n        clone.minMax = this.minMax.slice();\n        return clone;\n    }\n    getPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        const box = this.minMax.slice();\n        if (pathType === PathType.STROKE) {\n            if (!transform) {\n                unreachable(\"Stroke bounding box must include transform.\");\n            }\n            Util.singularValueDecompose2dScale(transform, XY);\n            const xStrokePad = XY[0] * this.lineWidth / 2;\n            const yStrokePad = XY[1] * this.lineWidth / 2;\n            box[0] -= xStrokePad;\n            box[1] -= yStrokePad;\n            box[2] += xStrokePad;\n            box[3] += yStrokePad;\n        }\n        return box;\n    }\n    updateClipFromPath() {\n        const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());\n        this.startNewPathAndClipBox(intersect || [\n            0,\n            0,\n            0,\n            0\n        ]);\n    }\n    isEmptyClip() {\n        return this.minMax[0] === Infinity;\n    }\n    startNewPathAndClipBox(box) {\n        this.clipBox.set(box, 0);\n        this.minMax.set(MIN_MAX_INIT, 0);\n    }\n    getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n    }\n}\nfunction putBinaryImageData(ctx, imgData) {\n    if (imgData instanceof ImageData) {\n        ctx.putImageData(imgData, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0, destPos;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    let i, j, thisChunkHeight, elemsInThisChunk;\n    if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {\n        const srcLength = src.byteLength;\n        const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n        const dest32DataLength = dest32.length;\n        const fullSrcDiff = width + 7 >> 3;\n        const white = 0xffffffff;\n        const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n        for(i = 0; i < totalChunks; i++){\n            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n            destPos = 0;\n            for(j = 0; j < thisChunkHeight; j++){\n                const srcDiff = srcLength - srcPos;\n                let k = 0;\n                const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n                const kEndUnrolled = kEnd & ~7;\n                let mask = 0;\n                let srcByte = 0;\n                for(; k < kEndUnrolled; k += 8){\n                    srcByte = src[srcPos++];\n                    dest32[destPos++] = srcByte & 128 ? white : black;\n                    dest32[destPos++] = srcByte & 64 ? white : black;\n                    dest32[destPos++] = srcByte & 32 ? white : black;\n                    dest32[destPos++] = srcByte & 16 ? white : black;\n                    dest32[destPos++] = srcByte & 8 ? white : black;\n                    dest32[destPos++] = srcByte & 4 ? white : black;\n                    dest32[destPos++] = srcByte & 2 ? white : black;\n                    dest32[destPos++] = srcByte & 1 ? white : black;\n                }\n                for(; k < kEnd; k++){\n                    if (mask === 0) {\n                        srcByte = src[srcPos++];\n                        mask = 128;\n                    }\n                    dest32[destPos++] = srcByte & mask ? white : black;\n                    mask >>= 1;\n                }\n            }\n            while(destPos < dest32DataLength){\n                dest32[destPos++] = 0;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {\n        j = 0;\n        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n        for(i = 0; i < fullChunks; i++){\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            srcPos += elemsInThisChunk;\n            ctx.putImageData(chunkImgData, 0, j);\n            j += FULL_CHUNK_HEIGHT;\n        }\n        if (i < totalChunks) {\n            elemsInThisChunk = width * partialChunkHeight * 4;\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            ctx.putImageData(chunkImgData, 0, j);\n        }\n    } else if (imgData.kind === util_ImageKind.RGB_24BPP) {\n        thisChunkHeight = FULL_CHUNK_HEIGHT;\n        elemsInThisChunk = width * thisChunkHeight;\n        for(i = 0; i < totalChunks; i++){\n            if (i >= fullChunks) {\n                thisChunkHeight = partialChunkHeight;\n                elemsInThisChunk = width * thisChunkHeight;\n            }\n            destPos = 0;\n            for(j = elemsInThisChunk; j--;){\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = 255;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else {\n        throw new Error(`bad image kind: ${imgData.kind}`);\n    }\n}\nfunction putBinaryImageMask(ctx, imgData) {\n    if (imgData.bitmap) {\n        ctx.drawImage(imgData.bitmap, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    for(let i = 0; i < totalChunks; i++){\n        const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n        ({ srcPos } = convertBlackAndWhiteToRGBA({\n            src,\n            srcPos,\n            dest,\n            width,\n            height: thisChunkHeight,\n            nonBlackColor: 0\n        }));\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n}\nfunction copyCtxState(sourceCtx, destCtx) {\n    const properties = [\n        \"strokeStyle\",\n        \"fillStyle\",\n        \"fillRule\",\n        \"globalAlpha\",\n        \"lineWidth\",\n        \"lineCap\",\n        \"lineJoin\",\n        \"miterLimit\",\n        \"globalCompositeOperation\",\n        \"font\",\n        \"filter\"\n    ];\n    for (const property of properties){\n        if (sourceCtx[property] !== undefined) {\n            destCtx[property] = sourceCtx[property];\n        }\n    }\n    if (sourceCtx.setLineDash !== undefined) {\n        destCtx.setLineDash(sourceCtx.getLineDash());\n        destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n    }\n}\nfunction resetCtxToDefault(ctx) {\n    ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n    ctx.fillRule = \"nonzero\";\n    ctx.globalAlpha = 1;\n    ctx.lineWidth = 1;\n    ctx.lineCap = \"butt\";\n    ctx.lineJoin = \"miter\";\n    ctx.miterLimit = 10;\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.font = \"10px sans-serif\";\n    if (ctx.setLineDash !== undefined) {\n        ctx.setLineDash([]);\n        ctx.lineDashOffset = 0;\n    }\n    const { filter } = ctx;\n    if (filter !== \"none\" && filter !== \"\") {\n        ctx.filter = \"none\";\n    }\n}\nfunction getImageSmoothingEnabled(transform, interpolate) {\n    if (interpolate) {\n        return true;\n    }\n    Util.singularValueDecompose2dScale(transform, XY);\n    const actualScale = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n    return XY[0] <= actualScale && XY[1] <= actualScale;\n}\nconst LINE_CAP_STYLES = [\n    \"butt\",\n    \"round\",\n    \"square\"\n];\nconst LINE_JOIN_STYLES = [\n    \"miter\",\n    \"round\",\n    \"bevel\"\n];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\nclass CanvasGraphics {\n    constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, { optionalContentConfig, markedContentStack = null }, annotationCanvasMap, pageColors, dependencyTracker){\n        this.ctx = canvasCtx;\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.stateStack = [];\n        this.pendingClip = null;\n        this.pendingEOFill = false;\n        this.res = null;\n        this.xobjs = null;\n        this.commonObjs = commonObjs;\n        this.objs = objs;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this.groupStack = [];\n        this.baseTransform = null;\n        this.baseTransformStack = [];\n        this.groupLevel = 0;\n        this.smaskStack = [];\n        this.smaskCounter = 0;\n        this.tempSMask = null;\n        this.suspendedCtx = null;\n        this.contentVisible = true;\n        this.markedContentStack = markedContentStack || [];\n        this.optionalContentConfig = optionalContentConfig;\n        this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n        this.cachedPatterns = new Map();\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.viewportScale = 1;\n        this.outputScaleX = 1;\n        this.outputScaleY = 1;\n        this.pageColors = pageColors;\n        this._cachedScaleForStroking = [\n            -1,\n            0\n        ];\n        this._cachedGetSinglePixelWidth = null;\n        this._cachedBitmapsMap = new Map();\n        this.dependencyTracker = dependencyTracker ?? null;\n    }\n    getObject(opIdx, data, fallback = null) {\n        if (typeof data === \"string\") {\n            this.dependencyTracker?.recordNamedDependency(opIdx, data);\n            return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n        }\n        return fallback;\n    }\n    beginDrawing({ transform, viewport, transparency = false, background = null }) {\n        const width = this.ctx.canvas.width;\n        const height = this.ctx.canvas.height;\n        const savedFillStyle = this.ctx.fillStyle;\n        this.ctx.fillStyle = background || \"#ffffff\";\n        this.ctx.fillRect(0, 0, width, height);\n        this.ctx.fillStyle = savedFillStyle;\n        if (transparency) {\n            const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n            this.compositeCtx = this.ctx;\n            this.transparentCanvas = transparentCanvas.canvas;\n            this.ctx = transparentCanvas.context;\n            this.ctx.save();\n            this.ctx.transform(...getCurrentTransform(this.compositeCtx));\n        }\n        this.ctx.save();\n        resetCtxToDefault(this.ctx);\n        if (transform) {\n            this.ctx.transform(...transform);\n            this.outputScaleX = transform[0];\n            this.outputScaleY = transform[0];\n        }\n        this.ctx.transform(...viewport.transform);\n        this.viewportScale = viewport.scale;\n        this.baseTransform = getCurrentTransform(this.ctx);\n    }\n    executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper, operationsFilter) {\n        const argsArray = operatorList.argsArray;\n        const fnArray = operatorList.fnArray;\n        let i = executionStartIdx || 0;\n        const argsArrayLen = argsArray.length;\n        if (argsArrayLen === i) {\n            return i;\n        }\n        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n        let steps = 0;\n        const commonObjs = this.commonObjs;\n        const objs = this.objs;\n        let fnId, fnArgs;\n        while(true){\n            if (stepper !== undefined && i === stepper.nextBreakPoint) {\n                stepper.breakIt(i, continueCallback);\n                return i;\n            }\n            if (!operationsFilter || operationsFilter(i)) {\n                fnId = fnArray[i];\n                fnArgs = argsArray[i] ?? null;\n                if (fnId !== OPS.dependency) {\n                    if (fnArgs === null) {\n                        this[fnId](i);\n                    } else {\n                        this[fnId](i, ...fnArgs);\n                    }\n                } else {\n                    for (const depObjId of fnArgs){\n                        this.dependencyTracker?.recordNamedData(depObjId, i);\n                        const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n                        if (!objsPool.has(depObjId)) {\n                            objsPool.get(depObjId, continueCallback);\n                            return i;\n                        }\n                    }\n                }\n            }\n            i++;\n            if (i === argsArrayLen) {\n                return i;\n            }\n            if (chunkOperations && ++steps > EXECUTION_STEPS) {\n                if (Date.now() > endTime) {\n                    continueCallback();\n                    return i;\n                }\n                steps = 0;\n            }\n        }\n    }\n    #restoreInitialState() {\n        while(this.stateStack.length || this.inSMaskMode){\n            this.restore();\n        }\n        this.current.activeSMask = null;\n        this.ctx.restore();\n        if (this.transparentCanvas) {\n            this.ctx = this.compositeCtx;\n            this.ctx.save();\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            this.ctx.drawImage(this.transparentCanvas, 0, 0);\n            this.ctx.restore();\n            this.transparentCanvas = null;\n        }\n    }\n    endDrawing() {\n        this.#restoreInitialState();\n        this.cachedCanvases.clear();\n        this.cachedPatterns.clear();\n        for (const cache of this._cachedBitmapsMap.values()){\n            for (const canvas of cache.values()){\n                if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n                    canvas.width = canvas.height = 0;\n                }\n            }\n            cache.clear();\n        }\n        this._cachedBitmapsMap.clear();\n        this.#drawFilter();\n    }\n    #drawFilter() {\n        if (this.pageColors) {\n            const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n            if (hcmFilterId !== \"none\") {\n                const savedFilter = this.ctx.filter;\n                this.ctx.filter = hcmFilterId;\n                this.ctx.drawImage(this.ctx.canvas, 0, 0);\n                this.ctx.filter = savedFilter;\n            }\n        }\n    }\n    _scaleImage(img, inverseTransform) {\n        const width = img.width ?? img.displayWidth;\n        const height = img.height ?? img.displayHeight;\n        let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n        let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n        let paintWidth = width, paintHeight = height;\n        let tmpCanvasId = \"prescale1\";\n        let tmpCanvas, tmpCtx;\n        while(widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1){\n            let newWidth = paintWidth, newHeight = paintHeight;\n            if (widthScale > 2 && paintWidth > 1) {\n                newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n                widthScale /= paintWidth / newWidth;\n            }\n            if (heightScale > 2 && paintHeight > 1) {\n                newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n                heightScale /= paintHeight / newHeight;\n            }\n            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n            tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, newWidth, newHeight);\n            tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n            img = tmpCanvas.canvas;\n            paintWidth = newWidth;\n            paintHeight = newHeight;\n            tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n        }\n        return {\n            img,\n            paintWidth,\n            paintHeight\n        };\n    }\n    _createMaskCanvas(opIdx, img) {\n        const ctx = this.ctx;\n        const { width, height } = img;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        const currentTransform = getCurrentTransform(ctx);\n        let cache, cacheKey, scaled, maskCanvas;\n        if ((img.bitmap || img.data) && img.count > 1) {\n            const mainKey = img.bitmap || img.data.buffer;\n            cacheKey = JSON.stringify(isPatternFill ? currentTransform : [\n                currentTransform.slice(0, 4),\n                fillColor\n            ]);\n            cache = this._cachedBitmapsMap.get(mainKey);\n            if (!cache) {\n                cache = new Map();\n                this._cachedBitmapsMap.set(mainKey, cache);\n            }\n            const cachedImage = cache.get(cacheKey);\n            if (cachedImage && !isPatternFill) {\n                const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n                const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n                this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);\n                return {\n                    canvas: cachedImage,\n                    offsetX,\n                    offsetY\n                };\n            }\n            scaled = cachedImage;\n        }\n        if (!scaled) {\n            maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            putBinaryImageMask(maskCanvas.context, img);\n        }\n        let maskToCanvas = Util.transform(currentTransform, [\n            1 / width,\n            0,\n            0,\n            -1 / height,\n            0,\n            0\n        ]);\n        maskToCanvas = Util.transform(maskToCanvas, [\n            1,\n            0,\n            0,\n            1,\n            0,\n            -height\n        ]);\n        const minMax = MIN_MAX_INIT.slice();\n        Util.axialAlignedBoundingBox([\n            0,\n            0,\n            width,\n            height\n        ], maskToCanvas, minMax);\n        const [minX, minY, maxX, maxY] = minMax;\n        const drawnWidth = Math.round(maxX - minX) || 1;\n        const drawnHeight = Math.round(maxY - minY) || 1;\n        const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n        const fillCtx = fillCanvas.context;\n        const offsetX = minX;\n        const offsetY = minY;\n        fillCtx.translate(-offsetX, -offsetY);\n        fillCtx.transform(...maskToCanvas);\n        if (!scaled) {\n            scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));\n            scaled = scaled.img;\n            if (cache && isPatternFill) {\n                cache.set(cacheKey, scaled);\n            }\n        }\n        fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);\n        drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n        fillCtx.globalCompositeOperation = \"source-in\";\n        const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [\n            1,\n            0,\n            0,\n            1,\n            -offsetX,\n            -offsetY\n        ]);\n        fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL, opIdx) : fillColor;\n        fillCtx.fillRect(0, 0, width, height);\n        if (cache && !isPatternFill) {\n            this.cachedCanvases.delete(\"fillCanvas\");\n            cache.set(cacheKey, fillCanvas.canvas);\n        }\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);\n        return {\n            canvas: fillCanvas.canvas,\n            offsetX: Math.round(offsetX),\n            offsetY: Math.round(offsetY)\n        };\n    }\n    setLineWidth(opIdx, width) {\n        this.dependencyTracker?.recordSimpleData(\"lineWidth\", opIdx);\n        if (width !== this.current.lineWidth) {\n            this._cachedScaleForStroking[0] = -1;\n        }\n        this.current.lineWidth = width;\n        this.ctx.lineWidth = width;\n    }\n    setLineCap(opIdx, style) {\n        this.dependencyTracker?.recordSimpleData(\"lineCap\", opIdx);\n        this.ctx.lineCap = LINE_CAP_STYLES[style];\n    }\n    setLineJoin(opIdx, style) {\n        this.dependencyTracker?.recordSimpleData(\"lineJoin\", opIdx);\n        this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n    }\n    setMiterLimit(opIdx, limit) {\n        this.dependencyTracker?.recordSimpleData(\"miterLimit\", opIdx);\n        this.ctx.miterLimit = limit;\n    }\n    setDash(opIdx, dashArray, dashPhase) {\n        this.dependencyTracker?.recordSimpleData(\"dash\", opIdx);\n        const ctx = this.ctx;\n        if (ctx.setLineDash !== undefined) {\n            ctx.setLineDash(dashArray);\n            ctx.lineDashOffset = dashPhase;\n        }\n    }\n    setRenderingIntent(opIdx, intent) {}\n    setFlatness(opIdx, flatness) {}\n    setGState(opIdx, states) {\n        for (const [key, value] of states){\n            switch(key){\n                case \"LW\":\n                    this.setLineWidth(opIdx, value);\n                    break;\n                case \"LC\":\n                    this.setLineCap(opIdx, value);\n                    break;\n                case \"LJ\":\n                    this.setLineJoin(opIdx, value);\n                    break;\n                case \"ML\":\n                    this.setMiterLimit(opIdx, value);\n                    break;\n                case \"D\":\n                    this.setDash(opIdx, value[0], value[1]);\n                    break;\n                case \"RI\":\n                    this.setRenderingIntent(opIdx, value);\n                    break;\n                case \"FL\":\n                    this.setFlatness(opIdx, value);\n                    break;\n                case \"Font\":\n                    this.setFont(opIdx, value[0], value[1]);\n                    break;\n                case \"CA\":\n                    this.dependencyTracker?.recordSimpleData(\"strokeAlpha\", opIdx);\n                    this.current.strokeAlpha = value;\n                    break;\n                case \"ca\":\n                    this.dependencyTracker?.recordSimpleData(\"fillAlpha\", opIdx);\n                    this.ctx.globalAlpha = this.current.fillAlpha = value;\n                    break;\n                case \"BM\":\n                    this.dependencyTracker?.recordSimpleData(\"globalCompositeOperation\", opIdx);\n                    this.ctx.globalCompositeOperation = value;\n                    break;\n                case \"SMask\":\n                    this.dependencyTracker?.recordSimpleData(\"SMask\", opIdx);\n                    this.current.activeSMask = value ? this.tempSMask : null;\n                    this.tempSMask = null;\n                    this.checkSMaskState();\n                    break;\n                case \"TR\":\n                    this.dependencyTracker?.recordSimpleData(\"filter\", opIdx);\n                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n                    break;\n            }\n        }\n    }\n    get inSMaskMode() {\n        return !!this.suspendedCtx;\n    }\n    checkSMaskState() {\n        const inSMaskMode = this.inSMaskMode;\n        if (this.current.activeSMask && !inSMaskMode) {\n            this.beginSMaskMode();\n        } else if (!this.current.activeSMask && inSMaskMode) {\n            this.endSMaskMode();\n        }\n    }\n    beginSMaskMode(opIdx) {\n        if (this.inSMaskMode) {\n            throw new Error(\"beginSMaskMode called while already in smask mode\");\n        }\n        const drawnWidth = this.ctx.canvas.width;\n        const drawnHeight = this.ctx.canvas.height;\n        const cacheId = \"smaskGroupAt\" + this.groupLevel;\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        this.suspendedCtx = this.ctx;\n        const ctx = this.ctx = scratchCanvas.context;\n        ctx.setTransform(this.suspendedCtx.getTransform());\n        copyCtxState(this.suspendedCtx, ctx);\n        mirrorContextOperations(ctx, this.suspendedCtx);\n        this.setGState(opIdx, [\n            [\n                \"BM\",\n                \"source-over\"\n            ]\n        ]);\n    }\n    endSMaskMode() {\n        if (!this.inSMaskMode) {\n            throw new Error(\"endSMaskMode called while not in smask mode\");\n        }\n        this.ctx._removeMirroring();\n        copyCtxState(this.ctx, this.suspendedCtx);\n        this.ctx = this.suspendedCtx;\n        this.suspendedCtx = null;\n    }\n    compose(dirtyBox) {\n        if (!this.current.activeSMask) {\n            return;\n        }\n        if (!dirtyBox) {\n            dirtyBox = [\n                0,\n                0,\n                this.ctx.canvas.width,\n                this.ctx.canvas.height\n            ];\n        } else {\n            dirtyBox[0] = Math.floor(dirtyBox[0]);\n            dirtyBox[1] = Math.floor(dirtyBox[1]);\n            dirtyBox[2] = Math.ceil(dirtyBox[2]);\n            dirtyBox[3] = Math.ceil(dirtyBox[3]);\n        }\n        const smask = this.current.activeSMask;\n        const suspendedCtx = this.suspendedCtx;\n        this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n        this.ctx.save();\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n        this.ctx.restore();\n    }\n    composeSMask(ctx, smask, layerCtx, layerBox) {\n        const layerOffsetX = layerBox[0];\n        const layerOffsetY = layerBox[1];\n        const layerWidth = layerBox[2] - layerOffsetX;\n        const layerHeight = layerBox[3] - layerOffsetY;\n        if (layerWidth === 0 || layerHeight === 0) {\n            return;\n        }\n        this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n        ctx.save();\n        ctx.globalAlpha = 1;\n        ctx.globalCompositeOperation = \"source-over\";\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(layerCtx.canvas, 0, 0);\n        ctx.restore();\n    }\n    genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n        let maskCanvas = maskCtx.canvas;\n        let maskX = layerOffsetX - maskOffsetX;\n        let maskY = layerOffsetY - maskOffsetY;\n        if (backdrop) {\n            if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {\n                const canvas = this.cachedCanvases.getCanvas(\"maskExtension\", width, height);\n                const ctx = canvas.context;\n                ctx.drawImage(maskCanvas, -maskX, -maskY);\n                ctx.globalCompositeOperation = \"destination-atop\";\n                ctx.fillStyle = backdrop;\n                ctx.fillRect(0, 0, width, height);\n                ctx.globalCompositeOperation = \"source-over\";\n                maskCanvas = canvas.canvas;\n                maskX = maskY = 0;\n            } else {\n                maskCtx.save();\n                maskCtx.globalAlpha = 1;\n                maskCtx.setTransform(1, 0, 0, 1, 0, 0);\n                const clip = new Path2D();\n                clip.rect(maskX, maskY, width, height);\n                maskCtx.clip(clip);\n                maskCtx.globalCompositeOperation = \"destination-atop\";\n                maskCtx.fillStyle = backdrop;\n                maskCtx.fillRect(maskX, maskY, width, height);\n                maskCtx.restore();\n            }\n        }\n        layerCtx.save();\n        layerCtx.globalAlpha = 1;\n        layerCtx.setTransform(1, 0, 0, 1, 0, 0);\n        if (subtype === \"Alpha\" && transferMap) {\n            layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);\n        } else if (subtype === \"Luminosity\") {\n            layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);\n        }\n        const clip = new Path2D();\n        clip.rect(layerOffsetX, layerOffsetY, width, height);\n        layerCtx.clip(clip);\n        layerCtx.globalCompositeOperation = \"destination-in\";\n        layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);\n        layerCtx.restore();\n    }\n    save(opIdx) {\n        if (this.inSMaskMode) {\n            copyCtxState(this.ctx, this.suspendedCtx);\n        }\n        this.ctx.save();\n        const old = this.current;\n        this.stateStack.push(old);\n        this.current = old.clone();\n        this.dependencyTracker?.save(opIdx);\n    }\n    restore(opIdx) {\n        this.dependencyTracker?.restore(opIdx);\n        if (this.stateStack.length === 0) {\n            if (this.inSMaskMode) {\n                this.endSMaskMode();\n            }\n            return;\n        }\n        this.current = this.stateStack.pop();\n        this.ctx.restore();\n        if (this.inSMaskMode) {\n            copyCtxState(this.suspendedCtx, this.ctx);\n        }\n        this.checkSMaskState();\n        this.pendingClip = null;\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n    }\n    transform(opIdx, a, b, c, d, e, f) {\n        this.dependencyTracker?.recordIncrementalData(\"transform\", opIdx);\n        this.ctx.transform(a, b, c, d, e, f);\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n    }\n    constructPath(opIdx, op, data, minMax) {\n        let [path] = data;\n        if (!minMax) {\n            path ||= data[0] = new Path2D();\n            this[op](opIdx, path);\n            return;\n        }\n        if (this.dependencyTracker !== null) {\n            const outerExtraSize = op === OPS.stroke ? this.current.lineWidth / 2 : 0;\n            this.dependencyTracker.resetBBox(opIdx).recordBBox(opIdx, this.ctx, minMax[0] - outerExtraSize, minMax[2] + outerExtraSize, minMax[1] - outerExtraSize, minMax[3] + outerExtraSize).recordDependencies(opIdx, [\n                \"transform\"\n            ]);\n        }\n        if (!(path instanceof Path2D)) {\n            const path2d = data[0] = new Path2D();\n            for(let i = 0, ii = path.length; i < ii;){\n                switch(path[i++]){\n                    case DrawOPS.moveTo:\n                        path2d.moveTo(path[i++], path[i++]);\n                        break;\n                    case DrawOPS.lineTo:\n                        path2d.lineTo(path[i++], path[i++]);\n                        break;\n                    case DrawOPS.curveTo:\n                        path2d.bezierCurveTo(path[i++], path[i++], path[i++], path[i++], path[i++], path[i++]);\n                        break;\n                    case DrawOPS.closePath:\n                        path2d.closePath();\n                        break;\n                    default:\n                        warn(`Unrecognized drawing path operator: ${path[i - 1]}`);\n                        break;\n                }\n            }\n            path = path2d;\n        }\n        Util.axialAlignedBoundingBox(minMax, getCurrentTransform(this.ctx), this.current.minMax);\n        this[op](opIdx, path);\n        this._pathStartIdx = opIdx;\n    }\n    closePath(opIdx) {\n        this.ctx.closePath();\n    }\n    stroke(opIdx, path, consumePath = true) {\n        const ctx = this.ctx;\n        const strokeColor = this.current.strokeColor;\n        ctx.globalAlpha = this.current.strokeAlpha;\n        if (this.contentVisible) {\n            if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n                const baseTransform = strokeColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n                ctx.save();\n                ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);\n                if (baseTransform) {\n                    const newPath = new Path2D();\n                    newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n                    path = newPath;\n                }\n                this.rescaleAndStroke(path, false);\n                ctx.restore();\n            } else {\n                this.rescaleAndStroke(path, true);\n            }\n        }\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.stroke);\n        if (consumePath) {\n            this.consumePath(opIdx, path, this.current.getClippedPathBoundingBox(PathType.STROKE, getCurrentTransform(this.ctx)));\n        }\n        ctx.globalAlpha = this.current.fillAlpha;\n    }\n    closeStroke(opIdx, path) {\n        this.stroke(opIdx, path);\n    }\n    fill(opIdx, path, consumePath = true) {\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        let needRestore = false;\n        if (isPatternFill) {\n            const baseTransform = fillColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n            this.dependencyTracker?.save(opIdx);\n            ctx.save();\n            ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);\n            if (baseTransform) {\n                const newPath = new Path2D();\n                newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n                path = newPath;\n            }\n            needRestore = true;\n        }\n        const intersect = this.current.getClippedPathBoundingBox();\n        if (this.contentVisible && intersect !== null) {\n            if (this.pendingEOFill) {\n                ctx.fill(path, \"evenodd\");\n                this.pendingEOFill = false;\n            } else {\n                ctx.fill(path);\n            }\n        }\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.fill);\n        if (needRestore) {\n            ctx.restore();\n            this.dependencyTracker?.restore(opIdx);\n        }\n        if (consumePath) {\n            this.consumePath(opIdx, path, intersect);\n        }\n    }\n    eoFill(opIdx, path) {\n        this.pendingEOFill = true;\n        this.fill(opIdx, path);\n    }\n    fillStroke(opIdx, path) {\n        this.fill(opIdx, path, false);\n        this.stroke(opIdx, path, false);\n        this.consumePath(opIdx, path);\n    }\n    eoFillStroke(opIdx, path) {\n        this.pendingEOFill = true;\n        this.fillStroke(opIdx, path);\n    }\n    closeFillStroke(opIdx, path) {\n        this.fillStroke(opIdx, path);\n    }\n    closeEOFillStroke(opIdx, path) {\n        this.pendingEOFill = true;\n        this.fillStroke(opIdx, path);\n    }\n    endPath(opIdx, path) {\n        this.consumePath(opIdx, path);\n    }\n    rawFillPath(opIdx, path) {\n        this.ctx.fill(path);\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.rawFillPath).recordOperation(opIdx);\n    }\n    clip(opIdx) {\n        this.dependencyTracker?.recordFutureForcedDependency(\"clipMode\", opIdx);\n        this.pendingClip = NORMAL_CLIP;\n    }\n    eoClip(opIdx) {\n        this.dependencyTracker?.recordFutureForcedDependency(\"clipMode\", opIdx);\n        this.pendingClip = EO_CLIP;\n    }\n    beginText(opIdx) {\n        this.current.textMatrix = null;\n        this.current.textMatrixScale = 1;\n        this.current.x = this.current.lineX = 0;\n        this.current.y = this.current.lineY = 0;\n        this.dependencyTracker?.recordOpenMarker(opIdx).resetIncrementalData(\"sameLineText\").resetIncrementalData(\"moveText\", opIdx);\n    }\n    endText(opIdx) {\n        const paths = this.pendingTextPaths;\n        const ctx = this.ctx;\n        if (this.dependencyTracker) {\n            const { dependencyTracker } = this;\n            if (paths !== undefined) {\n                dependencyTracker.recordFutureForcedDependency(\"textClip\", dependencyTracker.getOpenMarker()).recordFutureForcedDependency(\"textClip\", opIdx);\n            }\n            dependencyTracker.recordCloseMarker(opIdx);\n        }\n        if (paths !== undefined) {\n            const newPath = new Path2D();\n            const invTransf = ctx.getTransform().invertSelf();\n            for (const { transform, x, y, fontSize, path } of paths){\n                if (!path) {\n                    continue;\n                }\n                newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));\n            }\n            ctx.clip(newPath);\n        }\n        delete this.pendingTextPaths;\n    }\n    setCharSpacing(opIdx, spacing) {\n        this.dependencyTracker?.recordSimpleData(\"charSpacing\", opIdx);\n        this.current.charSpacing = spacing;\n    }\n    setWordSpacing(opIdx, spacing) {\n        this.dependencyTracker?.recordSimpleData(\"wordSpacing\", opIdx);\n        this.current.wordSpacing = spacing;\n    }\n    setHScale(opIdx, scale) {\n        this.dependencyTracker?.recordSimpleData(\"hScale\", opIdx);\n        this.current.textHScale = scale / 100;\n    }\n    setLeading(opIdx, leading) {\n        this.dependencyTracker?.recordSimpleData(\"leading\", opIdx);\n        this.current.leading = -leading;\n    }\n    setFont(opIdx, fontRefName, size) {\n        this.dependencyTracker?.recordSimpleData(\"font\", opIdx).recordSimpleDataFromNamed(\"fontObj\", fontRefName, opIdx);\n        const fontObj = this.commonObjs.get(fontRefName);\n        const current = this.current;\n        if (!fontObj) {\n            throw new Error(`Can't find font for ${fontRefName}`);\n        }\n        current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;\n        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n            warn(\"Invalid font matrix for font \" + fontRefName);\n        }\n        if (size < 0) {\n            size = -size;\n            current.fontDirection = -1;\n        } else {\n            current.fontDirection = 1;\n        }\n        this.current.font = fontObj;\n        this.current.fontSize = size;\n        if (fontObj.isType3Font) {\n            return;\n        }\n        const name = fontObj.loadedName || \"sans-serif\";\n        const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n        let bold = \"normal\";\n        if (fontObj.black) {\n            bold = \"900\";\n        } else if (fontObj.bold) {\n            bold = \"bold\";\n        }\n        const italic = fontObj.italic ? \"italic\" : \"normal\";\n        let browserFontSize = size;\n        if (size < MIN_FONT_SIZE) {\n            browserFontSize = MIN_FONT_SIZE;\n        } else if (size > MAX_FONT_SIZE) {\n            browserFontSize = MAX_FONT_SIZE;\n        }\n        this.current.fontSizeScale = size / browserFontSize;\n        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n    }\n    setTextRenderingMode(opIdx, mode) {\n        this.dependencyTracker?.recordSimpleData(\"textRenderingMode\", opIdx);\n        this.current.textRenderingMode = mode;\n    }\n    setTextRise(opIdx, rise) {\n        this.dependencyTracker?.recordSimpleData(\"textRise\", opIdx);\n        this.current.textRise = rise;\n    }\n    moveText(opIdx, x, y) {\n        this.dependencyTracker?.resetIncrementalData(\"sameLineText\").recordIncrementalData(\"moveText\", opIdx);\n        this.current.x = this.current.lineX += x;\n        this.current.y = this.current.lineY += y;\n    }\n    setLeadingMoveText(opIdx, x, y) {\n        this.setLeading(opIdx, -y);\n        this.moveText(opIdx, x, y);\n    }\n    setTextMatrix(opIdx, matrix) {\n        this.dependencyTracker?.recordSimpleData(\"textMatrix\", opIdx);\n        const { current } = this;\n        current.textMatrix = matrix;\n        current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);\n        current.x = current.lineX = 0;\n        current.y = current.lineY = 0;\n    }\n    nextLine(opIdx) {\n        this.moveText(opIdx, 0, this.current.leading);\n        this.dependencyTracker?.recordIncrementalData(\"moveText\", this.dependencyTracker.getSimpleIndex(\"leading\") ?? opIdx);\n    }\n    #getScaledPath(path, currentTransform, transform) {\n        const newPath = new Path2D();\n        newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));\n        return newPath;\n    }\n    paintChar(opIdx, character, x, y, patternFillTransform, patternStrokeTransform) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const textRenderingMode = current.textRenderingMode;\n        const fontSize = current.fontSize / current.fontSizeScale;\n        const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n        const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);\n        const patternFill = current.patternFill && !font.missingFile;\n        const patternStroke = current.patternStroke && !font.missingFile;\n        let path;\n        if ((font.disableFontFace || isAddToPathSet || patternFill || patternStroke) && !font.missingFile) {\n            path = font.getPathGenerator(this.commonObjs, character);\n        }\n        if (path && (font.disableFontFace || patternFill || patternStroke)) {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.scale(fontSize, -fontSize);\n            this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font);\n            let currentTransform;\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternFillTransform) {\n                    currentTransform = ctx.getTransform();\n                    ctx.setTransform(...patternFillTransform);\n                    const scaledPath = this.#getScaledPath(path, currentTransform, patternFillTransform);\n                    ctx.fill(scaledPath);\n                } else {\n                    ctx.fill(path);\n                }\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternStrokeTransform) {\n                    currentTransform ||= ctx.getTransform();\n                    ctx.setTransform(...patternStrokeTransform);\n                    const { a, b, c, d } = currentTransform;\n                    const invPatternTransform = Util.inverseTransform(patternStrokeTransform);\n                    const transf = Util.transform([\n                        a,\n                        b,\n                        c,\n                        d,\n                        0,\n                        0\n                    ], invPatternTransform);\n                    Util.singularValueDecompose2dScale(transf, XY);\n                    ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;\n                    ctx.stroke(this.#getScaledPath(path, currentTransform, patternStrokeTransform));\n                } else {\n                    ctx.lineWidth /= fontSize;\n                    ctx.stroke(path);\n                }\n            }\n            ctx.restore();\n        } else {\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.fillText(character, x, y);\n                this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, ()=>ctx.measureText(character));\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (this.dependencyTracker) {\n                    this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, ()=>ctx.measureText(character)).recordDependencies(opIdx, Dependencies.stroke);\n                }\n                ctx.strokeText(character, x, y);\n            }\n        }\n        if (isAddToPathSet) {\n            const paths = this.pendingTextPaths ||= [];\n            paths.push({\n                transform: getCurrentTransform(ctx),\n                x,\n                y,\n                fontSize,\n                path\n            });\n            this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y);\n        }\n    }\n    get isFontSubpixelAAEnabled() {\n        const { context: ctx } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n        ctx.scale(1.5, 1);\n        ctx.fillText(\"I\", 0, 10);\n        const data = ctx.getImageData(0, 0, 10, 10).data;\n        let enabled = false;\n        for(let i = 3; i < data.length; i += 4){\n            if (data[i] > 0 && data[i] < 255) {\n                enabled = true;\n                break;\n            }\n        }\n        return shadow(this, \"isFontSubpixelAAEnabled\", enabled);\n    }\n    showText(opIdx, glyphs) {\n        if (this.dependencyTracker) {\n            this.dependencyTracker.recordDependencies(opIdx, Dependencies.showText).resetBBox(opIdx);\n            if (this.current.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG) {\n                this.dependencyTracker.recordFutureForcedDependency(\"textClip\", opIdx).inheritPendingDependenciesAsFutureForcedDependencies();\n            }\n        }\n        const current = this.current;\n        const font = current.font;\n        if (font.isType3Font) {\n            this.showType3Text(opIdx, glyphs);\n            this.dependencyTracker?.recordShowTextOperation(opIdx);\n            return undefined;\n        }\n        const fontSize = current.fontSize;\n        if (fontSize === 0) {\n            this.dependencyTracker?.recordOperation(opIdx);\n            return undefined;\n        }\n        const ctx = this.ctx;\n        const fontSizeScale = current.fontSizeScale;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const fontDirection = current.fontDirection;\n        const textHScale = current.textHScale * fontDirection;\n        const glyphsLength = glyphs.length;\n        const vertical = font.vertical;\n        const spacingDir = vertical ? 1 : -1;\n        const defaultVMetrics = font.defaultVMetrics;\n        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n        const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n        ctx.save();\n        if (current.textMatrix) {\n            ctx.transform(...current.textMatrix);\n        }\n        ctx.translate(current.x, current.y + current.textRise);\n        if (fontDirection > 0) {\n            ctx.scale(textHScale, -1);\n        } else {\n            ctx.scale(textHScale, 1);\n        }\n        let patternFillTransform, patternStrokeTransform;\n        if (current.patternFill) {\n            ctx.save();\n            const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);\n            patternFillTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.fillStyle = pattern;\n        }\n        if (current.patternStroke) {\n            ctx.save();\n            const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);\n            patternStrokeTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.strokeStyle = pattern;\n        }\n        let lineWidth = current.lineWidth;\n        const scale = current.textMatrixScale;\n        if (scale === 0 || lineWidth === 0) {\n            const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                lineWidth = this.getSinglePixelWidth();\n            }\n        } else {\n            lineWidth /= scale;\n        }\n        if (fontSizeScale !== 1.0) {\n            ctx.scale(fontSizeScale, fontSizeScale);\n            lineWidth /= fontSizeScale;\n        }\n        ctx.lineWidth = lineWidth;\n        if (font.isInvalidPDFjsFont) {\n            const chars = [];\n            let width = 0;\n            for (const glyph of glyphs){\n                chars.push(glyph.unicode);\n                width += glyph.width;\n            }\n            const joinedChars = chars.join(\"\");\n            ctx.fillText(joinedChars, 0, 0);\n            if (this.dependencyTracker !== null) {\n                const measure = ctx.measureText(joinedChars);\n                this.dependencyTracker.recordBBox(opIdx, this.ctx, -measure.actualBoundingBoxLeft, measure.actualBoundingBoxRight, -measure.actualBoundingBoxAscent, measure.actualBoundingBoxDescent).recordShowTextOperation(opIdx);\n            }\n            current.x += width * widthAdvanceScale * textHScale;\n            ctx.restore();\n            this.compose();\n            return undefined;\n        }\n        let x = 0, i;\n        for(i = 0; i < glyphsLength; ++i){\n            const glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                x += spacingDir * glyph * fontSize / 1000;\n                continue;\n            }\n            let restoreNeeded = false;\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const character = glyph.fontChar;\n            const accent = glyph.accent;\n            let scaledX, scaledY;\n            let width = glyph.width;\n            if (vertical) {\n                const vmetric = glyph.vmetric || defaultVMetrics;\n                const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n                const vy = vmetric[2] * widthAdvanceScale;\n                width = vmetric ? -vmetric[0] : width;\n                scaledX = vx / fontSizeScale;\n                scaledY = (x + vy) / fontSizeScale;\n            } else {\n                scaledX = x / fontSizeScale;\n                scaledY = 0;\n            }\n            let measure;\n            if (font.remeasure && width > 0) {\n                measure = ctx.measureText(character);\n                const measuredWidth = measure.width * 1000 / fontSize * fontSizeScale;\n                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                    const characterScaleX = width / measuredWidth;\n                    restoreNeeded = true;\n                    ctx.save();\n                    ctx.scale(characterScaleX, 1);\n                    scaledX /= characterScaleX;\n                } else if (width !== measuredWidth) {\n                    scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n                }\n            }\n            if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n                if (simpleFillText && !accent) {\n                    ctx.fillText(character, scaledX, scaledY);\n                    this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, measure ? {\n                        bbox: null\n                    } : font, fontSize / fontSizeScale, scaledX, scaledY, ()=>measure ?? ctx.measureText(character));\n                } else {\n                    this.paintChar(opIdx, character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);\n                    if (accent) {\n                        const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                        const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                        this.paintChar(opIdx, accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);\n                    }\n                }\n            }\n            const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n            x += charWidth;\n            if (restoreNeeded) {\n                ctx.restore();\n            }\n        }\n        if (vertical) {\n            current.y -= x;\n        } else {\n            current.x += x * textHScale;\n        }\n        ctx.restore();\n        this.compose();\n        this.dependencyTracker?.recordShowTextOperation(opIdx);\n        return undefined;\n    }\n    showType3Text(opIdx, glyphs) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const fontSize = current.fontSize;\n        const fontDirection = current.fontDirection;\n        const spacingDir = font.vertical ? 1 : -1;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const textHScale = current.textHScale * fontDirection;\n        const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n        const glyphsLength = glyphs.length;\n        const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;\n        let i, glyph, width, spacingLength;\n        if (isTextInvisible || fontSize === 0) {\n            return;\n        }\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n        ctx.save();\n        if (current.textMatrix) {\n            ctx.transform(...current.textMatrix);\n        }\n        ctx.translate(current.x, current.y + current.textRise);\n        ctx.scale(textHScale, fontDirection);\n        const dependencyTracker = this.dependencyTracker;\n        this.dependencyTracker = dependencyTracker ? new CanvasNestedDependencyTracker(dependencyTracker, opIdx) : null;\n        for(i = 0; i < glyphsLength; ++i){\n            glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                spacingLength = spacingDir * glyph * fontSize / 1000;\n                this.ctx.translate(spacingLength, 0);\n                current.x += spacingLength * textHScale;\n                continue;\n            }\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const operatorList = font.charProcOperatorList[glyph.operatorListId];\n            if (!operatorList) {\n                warn(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n            } else if (this.contentVisible) {\n                this.save();\n                ctx.scale(fontSize, fontSize);\n                ctx.transform(...fontMatrix);\n                this.executeOperatorList(operatorList);\n                this.restore();\n            }\n            const p = [\n                glyph.width,\n                0\n            ];\n            Util.applyTransform(p, fontMatrix);\n            width = p[0] * fontSize + spacing;\n            ctx.translate(width, 0);\n            current.x += width * textHScale;\n        }\n        ctx.restore();\n        if (dependencyTracker) {\n            this.dependencyTracker = dependencyTracker;\n        }\n    }\n    setCharWidth(opIdx, xWidth, yWidth) {}\n    setCharWidthAndBounds(opIdx, xWidth, yWidth, llx, lly, urx, ury) {\n        const clip = new Path2D();\n        clip.rect(llx, lly, urx - llx, ury - lly);\n        this.ctx.clip(clip);\n        this.dependencyTracker?.recordBBox(opIdx, this.ctx, llx, urx, lly, ury).recordClipBox(opIdx, this.ctx, llx, urx, lly, ury);\n        this.endPath(opIdx);\n    }\n    getColorN_Pattern(opIdx, IR) {\n        let pattern;\n        if (IR[0] === \"TilingPattern\") {\n            const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);\n            const canvasGraphicsFactory = {\n                createCanvasGraphics: (ctx, renderingOpIdx)=>new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                        optionalContentConfig: this.optionalContentConfig,\n                        markedContentStack: this.markedContentStack\n                    }, undefined, undefined, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, renderingOpIdx, true) : null)\n            };\n            pattern = new TilingPattern(IR, this.ctx, canvasGraphicsFactory, baseTransform);\n        } else {\n            pattern = this._getPattern(opIdx, IR[1], IR[2]);\n        }\n        return pattern;\n    }\n    setStrokeColorN(opIdx, ...args) {\n        this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n        this.current.strokeColor = this.getColorN_Pattern(opIdx, args);\n        this.current.patternStroke = true;\n    }\n    setFillColorN(opIdx, ...args) {\n        this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n        this.current.fillColor = this.getColorN_Pattern(opIdx, args);\n        this.current.patternFill = true;\n    }\n    setStrokeRGBColor(opIdx, color) {\n        this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n        this.ctx.strokeStyle = this.current.strokeColor = color;\n        this.current.patternStroke = false;\n    }\n    setStrokeTransparent(opIdx) {\n        this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n        this.ctx.strokeStyle = this.current.strokeColor = \"transparent\";\n        this.current.patternStroke = false;\n    }\n    setFillRGBColor(opIdx, color) {\n        this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n        this.ctx.fillStyle = this.current.fillColor = color;\n        this.current.patternFill = false;\n    }\n    setFillTransparent(opIdx) {\n        this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n        this.ctx.fillStyle = this.current.fillColor = \"transparent\";\n        this.current.patternFill = false;\n    }\n    _getPattern(opIdx, objId, matrix = null) {\n        let pattern;\n        if (this.cachedPatterns.has(objId)) {\n            pattern = this.cachedPatterns.get(objId);\n        } else {\n            pattern = getShadingPattern(this.getObject(opIdx, objId));\n            this.cachedPatterns.set(objId, pattern);\n        }\n        if (matrix) {\n            pattern.matrix = matrix;\n        }\n        return pattern;\n    }\n    shadingFill(opIdx, objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        this.save(opIdx);\n        const pattern = this._getPattern(opIdx, objId);\n        ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING, opIdx);\n        const inv = getCurrentTransformInverse(ctx);\n        if (inv) {\n            const { width, height } = ctx.canvas;\n            const minMax = MIN_MAX_INIT.slice();\n            Util.axialAlignedBoundingBox([\n                0,\n                0,\n                width,\n                height\n            ], inv, minMax);\n            const [x0, y0, x1, y1] = minMax;\n            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n        } else {\n            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n        }\n        this.dependencyTracker?.resetBBox(opIdx).recordFullPageBBox(opIdx).recordDependencies(opIdx, Dependencies.transform).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);\n        this.compose(this.current.getClippedPathBoundingBox());\n        this.restore(opIdx);\n    }\n    beginInlineImage() {\n        unreachable(\"Should not call beginInlineImage\");\n    }\n    beginImageData() {\n        unreachable(\"Should not call beginImageData\");\n    }\n    paintFormXObjectBegin(opIdx, matrix, bbox) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save(opIdx);\n        this.baseTransformStack.push(this.baseTransform);\n        if (matrix) {\n            this.transform(opIdx, ...matrix);\n        }\n        this.baseTransform = getCurrentTransform(this.ctx);\n        if (bbox) {\n            Util.axialAlignedBoundingBox(bbox, this.baseTransform, this.current.minMax);\n            const [x0, y0, x1, y1] = bbox;\n            const clip = new Path2D();\n            clip.rect(x0, y0, x1 - x0, y1 - y0);\n            this.ctx.clip(clip);\n            this.dependencyTracker?.recordClipBox(opIdx, this.ctx, x0, x1, y0, y1);\n            this.endPath(opIdx);\n        }\n    }\n    paintFormXObjectEnd(opIdx) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.restore(opIdx);\n        this.baseTransform = this.baseTransformStack.pop();\n    }\n    beginGroup(opIdx, group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save(opIdx);\n        if (this.inSMaskMode) {\n            this.endSMaskMode();\n            this.current.activeSMask = null;\n        }\n        const currentCtx = this.ctx;\n        if (!group.isolated) {\n            info(\"TODO: Support non-isolated groups.\");\n        }\n        if (group.knockout) {\n            warn(\"Knockout groups not supported.\");\n        }\n        const currentTransform = getCurrentTransform(currentCtx);\n        if (group.matrix) {\n            currentCtx.transform(...group.matrix);\n        }\n        if (!group.bbox) {\n            throw new Error(\"Bounding box is required.\");\n        }\n        let bounds = MIN_MAX_INIT.slice();\n        Util.axialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx), bounds);\n        const canvasBounds = [\n            0,\n            0,\n            currentCtx.canvas.width,\n            currentCtx.canvas.height\n        ];\n        bounds = Util.intersect(bounds, canvasBounds) || [\n            0,\n            0,\n            0,\n            0\n        ];\n        const offsetX = Math.floor(bounds[0]);\n        const offsetY = Math.floor(bounds[1]);\n        const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n        const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n        this.current.startNewPathAndClipBox([\n            0,\n            0,\n            drawnWidth,\n            drawnHeight\n        ]);\n        let cacheId = \"groupAt\" + this.groupLevel;\n        if (group.smask) {\n            cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n        }\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        const groupCtx = scratchCanvas.context;\n        groupCtx.translate(-offsetX, -offsetY);\n        groupCtx.transform(...currentTransform);\n        let clip = new Path2D();\n        const [x0, y0, x1, y1] = group.bbox;\n        clip.rect(x0, y0, x1 - x0, y1 - y0);\n        if (group.matrix) {\n            const path = new Path2D();\n            path.addPath(clip, new DOMMatrix(group.matrix));\n            clip = path;\n        }\n        groupCtx.clip(clip);\n        if (group.smask) {\n            this.smaskStack.push({\n                canvas: scratchCanvas.canvas,\n                context: groupCtx,\n                offsetX,\n                offsetY,\n                subtype: group.smask.subtype,\n                backdrop: group.smask.backdrop,\n                transferMap: group.smask.transferMap || null,\n                startTransformInverse: null\n            });\n        }\n        if (!group.smask || this.dependencyTracker) {\n            currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n            currentCtx.translate(offsetX, offsetY);\n            currentCtx.save();\n        }\n        copyCtxState(currentCtx, groupCtx);\n        this.ctx = groupCtx;\n        this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies([\n            \"fillAlpha\",\n            \"strokeAlpha\",\n            \"globalCompositeOperation\"\n        ]).pushBaseTransform(currentCtx);\n        this.setGState(opIdx, [\n            [\n                \"BM\",\n                \"source-over\"\n            ],\n            [\n                \"ca\",\n                1\n            ],\n            [\n                \"CA\",\n                1\n            ]\n        ]);\n        this.groupStack.push(currentCtx);\n        this.groupLevel++;\n    }\n    endGroup(opIdx, group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.groupLevel--;\n        const groupCtx = this.ctx;\n        const ctx = this.groupStack.pop();\n        this.ctx = ctx;\n        this.ctx.imageSmoothingEnabled = false;\n        this.dependencyTracker?.popBaseTransform();\n        if (group.smask) {\n            this.tempSMask = this.smaskStack.pop();\n            this.restore(opIdx);\n            if (this.dependencyTracker) {\n                this.ctx.restore();\n            }\n        } else {\n            this.ctx.restore();\n            const currentMtx = getCurrentTransform(this.ctx);\n            this.restore(opIdx);\n            this.ctx.save();\n            this.ctx.setTransform(...currentMtx);\n            const dirtyBox = MIN_MAX_INIT.slice();\n            Util.axialAlignedBoundingBox([\n                0,\n                0,\n                groupCtx.canvas.width,\n                groupCtx.canvas.height\n            ], currentMtx, dirtyBox);\n            this.ctx.drawImage(groupCtx.canvas, 0, 0);\n            this.ctx.restore();\n            this.compose(dirtyBox);\n        }\n    }\n    beginAnnotation(opIdx, id, rect, transform, matrix, hasOwnCanvas) {\n        this.#restoreInitialState();\n        resetCtxToDefault(this.ctx);\n        this.ctx.save();\n        this.save(opIdx);\n        if (this.baseTransform) {\n            this.ctx.setTransform(...this.baseTransform);\n        }\n        if (rect) {\n            const width = rect[2] - rect[0];\n            const height = rect[3] - rect[1];\n            if (hasOwnCanvas && this.annotationCanvasMap) {\n                transform = transform.slice();\n                transform[4] -= rect[0];\n                transform[5] -= rect[1];\n                rect = rect.slice();\n                rect[0] = rect[1] = 0;\n                rect[2] = width;\n                rect[3] = height;\n                Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);\n                const { viewportScale } = this;\n                const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n                const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n                const { canvas, context } = this.annotationCanvas;\n                this.annotationCanvasMap.set(id, canvas);\n                this.annotationCanvas.savedCtx = this.ctx;\n                this.ctx = context;\n                this.ctx.save();\n                this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);\n                resetCtxToDefault(this.ctx);\n            } else {\n                resetCtxToDefault(this.ctx);\n                this.endPath(opIdx);\n                const clip = new Path2D();\n                clip.rect(rect[0], rect[1], width, height);\n                this.ctx.clip(clip);\n            }\n        }\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.transform(opIdx, ...transform);\n        this.transform(opIdx, ...matrix);\n    }\n    endAnnotation(opIdx) {\n        if (this.annotationCanvas) {\n            this.ctx.restore();\n            this.#drawFilter();\n            this.ctx = this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas;\n        }\n    }\n    paintImageMaskXObject(opIdx, img) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const count = img.count;\n        img = this.getObject(opIdx, img.data, img);\n        img.count = count;\n        const ctx = this.ctx;\n        const mask = this._createMaskCanvas(opIdx, img);\n        const maskCanvas = mask.canvas;\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, mask.offsetX, mask.offsetX + maskCanvas.width, mask.offsetY, mask.offsetY + maskCanvas.height).recordOperation(opIdx);\n        ctx.restore();\n        this.compose();\n    }\n    paintImageMaskXObjectRepeat(opIdx, img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        img = this.getObject(opIdx, img.data, img);\n        const ctx = this.ctx;\n        ctx.save();\n        const currentTransform = getCurrentTransform(ctx);\n        ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n        const mask = this._createMaskCanvas(opIdx, img);\n        ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n        this.dependencyTracker?.resetBBox(opIdx);\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            const trans = Util.transform(currentTransform, [\n                scaleX,\n                skewX,\n                skewY,\n                scaleY,\n                positions[i],\n                positions[i + 1]\n            ]);\n            ctx.drawImage(mask.canvas, trans[4], trans[5]);\n            this.dependencyTracker?.recordBBox(opIdx, this.ctx, trans[4], trans[4] + mask.canvas.width, trans[5], trans[5] + mask.canvas.height);\n        }\n        ctx.restore();\n        this.compose();\n        this.dependencyTracker?.recordOperation(opIdx);\n    }\n    paintImageMaskXObjectGroup(opIdx, images) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        this.dependencyTracker?.resetBBox(opIdx).recordDependencies(opIdx, Dependencies.transformAndFill);\n        for (const image of images){\n            const { data, width, height, transform } = image;\n            const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            const maskCtx = maskCanvas.context;\n            maskCtx.save();\n            const img = this.getObject(opIdx, data, image);\n            putBinaryImageMask(maskCtx, img);\n            maskCtx.globalCompositeOperation = \"source-in\";\n            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx) : fillColor;\n            maskCtx.fillRect(0, 0, width, height);\n            maskCtx.restore();\n            ctx.save();\n            ctx.transform(...transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n            this.dependencyTracker?.recordBBox(opIdx, ctx, 0, width, 0, height);\n            ctx.restore();\n        }\n        this.compose();\n        this.dependencyTracker?.recordOperation(opIdx);\n    }\n    paintImageXObject(opIdx, objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(opIdx, objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        this.paintInlineImageXObject(opIdx, imgData);\n    }\n    paintImageXObjectRepeat(opIdx, objId, scaleX, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(opIdx, objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const map = [];\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            map.push({\n                transform: [\n                    scaleX,\n                    0,\n                    0,\n                    scaleY,\n                    positions[i],\n                    positions[i + 1]\n                ],\n                x: 0,\n                y: 0,\n                w: width,\n                h: height\n            });\n        }\n        this.paintInlineImageXObjectGroup(opIdx, imgData, map);\n    }\n    applyTransferMapsToCanvas(ctx) {\n        if (this.current.transferMaps !== \"none\") {\n            ctx.filter = this.current.transferMaps;\n            ctx.drawImage(ctx.canvas, 0, 0);\n            ctx.filter = \"none\";\n        }\n        return ctx.canvas;\n    }\n    applyTransferMapsToBitmap(imgData) {\n        if (this.current.transferMaps === \"none\") {\n            return imgData.bitmap;\n        }\n        const { bitmap, width, height } = imgData;\n        const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n        const tmpCtx = tmpCanvas.context;\n        tmpCtx.filter = this.current.transferMaps;\n        tmpCtx.drawImage(bitmap, 0, 0);\n        tmpCtx.filter = \"none\";\n        return tmpCanvas.canvas;\n    }\n    paintInlineImageXObject(opIdx, imgData) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const ctx = this.ctx;\n        this.save(opIdx);\n        const { filter } = ctx;\n        if (filter !== \"none\" && filter !== \"\") {\n            ctx.filter = \"none\";\n        }\n        ctx.scale(1 / width, -1 / height);\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = this.applyTransferMapsToBitmap(imgData);\n        } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n            imgToPaint = imgData;\n        } else {\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));\n        ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);\n        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, ctx, 0, width, -height, 0).recordDependencies(opIdx, Dependencies.imageXObject).recordOperation(opIdx);\n        drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n        this.compose();\n        this.restore(opIdx);\n    }\n    paintInlineImageXObjectGroup(opIdx, imgData, map) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = imgData.bitmap;\n        } else {\n            const w = imgData.width;\n            const h = imgData.height;\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        this.dependencyTracker?.resetBBox(opIdx);\n        for (const entry of map){\n            ctx.save();\n            ctx.transform(...entry.transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n            this.dependencyTracker?.recordBBox(opIdx, ctx, 0, 1, -1, 0);\n            ctx.restore();\n        }\n        this.dependencyTracker?.recordOperation(opIdx);\n        this.compose();\n    }\n    paintSolidColorImageMask(opIdx) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, 0, 1, 0, 1).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);\n        this.ctx.fillRect(0, 0, 1, 1);\n        this.compose();\n    }\n    markPoint(opIdx, tag) {}\n    markPointProps(opIdx, tag, properties) {}\n    beginMarkedContent(opIdx, tag) {\n        this.dependencyTracker?.beginMarkedContent(opIdx);\n        this.markedContentStack.push({\n            visible: true\n        });\n    }\n    beginMarkedContentProps(opIdx, tag, properties) {\n        this.dependencyTracker?.beginMarkedContent(opIdx);\n        if (tag === \"OC\") {\n            this.markedContentStack.push({\n                visible: this.optionalContentConfig.isVisible(properties)\n            });\n        } else {\n            this.markedContentStack.push({\n                visible: true\n            });\n        }\n        this.contentVisible = this.isContentVisible();\n    }\n    endMarkedContent(opIdx) {\n        this.dependencyTracker?.endMarkedContent(opIdx);\n        this.markedContentStack.pop();\n        this.contentVisible = this.isContentVisible();\n    }\n    beginCompat(opIdx) {}\n    endCompat(opIdx) {}\n    consumePath(opIdx, path, clipBox) {\n        const isEmpty = this.current.isEmptyClip();\n        if (this.pendingClip) {\n            this.current.updateClipFromPath();\n        }\n        if (!this.pendingClip) {\n            this.compose(clipBox);\n        }\n        const ctx = this.ctx;\n        if (this.pendingClip) {\n            if (!isEmpty) {\n                if (this.pendingClip === EO_CLIP) {\n                    ctx.clip(path, \"evenodd\");\n                } else {\n                    ctx.clip(path);\n                }\n            }\n            this.pendingClip = null;\n            this.dependencyTracker?.bboxToClipBoxDropOperation(opIdx).recordFutureForcedDependency(\"clipPath\", opIdx);\n        } else {\n            this.dependencyTracker?.recordOperation(opIdx);\n        }\n        this.current.startNewPathAndClipBox(this.current.clipBox);\n    }\n    getSinglePixelWidth() {\n        if (!this._cachedGetSinglePixelWidth) {\n            const m = getCurrentTransform(this.ctx);\n            if (m[1] === 0 && m[2] === 0) {\n                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n            } else {\n                const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n                const normX = Math.hypot(m[0], m[2]);\n                const normY = Math.hypot(m[1], m[3]);\n                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n            }\n        }\n        return this._cachedGetSinglePixelWidth;\n    }\n    getScaleForStroking() {\n        if (this._cachedScaleForStroking[0] === -1) {\n            const { lineWidth } = this.current;\n            const { a, b, c, d } = this.ctx.getTransform();\n            let scaleX, scaleY;\n            if (b === 0 && c === 0) {\n                const normX = Math.abs(a);\n                const normY = Math.abs(d);\n                if (normX === normY) {\n                    if (lineWidth === 0) {\n                        scaleX = scaleY = 1 / normX;\n                    } else {\n                        const scaledLineWidth = normX * lineWidth;\n                        scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n                    }\n                } else if (lineWidth === 0) {\n                    scaleX = 1 / normX;\n                    scaleY = 1 / normY;\n                } else {\n                    const scaledXLineWidth = normX * lineWidth;\n                    const scaledYLineWidth = normY * lineWidth;\n                    scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n                    scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n                }\n            } else {\n                const absDet = Math.abs(a * d - b * c);\n                const normX = Math.hypot(a, b);\n                const normY = Math.hypot(c, d);\n                if (lineWidth === 0) {\n                    scaleX = normY / absDet;\n                    scaleY = normX / absDet;\n                } else {\n                    const baseArea = lineWidth * absDet;\n                    scaleX = normY > baseArea ? normY / baseArea : 1;\n                    scaleY = normX > baseArea ? normX / baseArea : 1;\n                }\n            }\n            this._cachedScaleForStroking[0] = scaleX;\n            this._cachedScaleForStroking[1] = scaleY;\n        }\n        return this._cachedScaleForStroking;\n    }\n    rescaleAndStroke(path, saveRestore) {\n        const { ctx, current: { lineWidth } } = this;\n        const [scaleX, scaleY] = this.getScaleForStroking();\n        if (scaleX === scaleY) {\n            ctx.lineWidth = (lineWidth || 1) * scaleX;\n            ctx.stroke(path);\n            return;\n        }\n        const dashes = ctx.getLineDash();\n        if (saveRestore) {\n            ctx.save();\n        }\n        ctx.scale(scaleX, scaleY);\n        SCALE_MATRIX.a = 1 / scaleX;\n        SCALE_MATRIX.d = 1 / scaleY;\n        const newPath = new Path2D();\n        newPath.addPath(path, SCALE_MATRIX);\n        if (dashes.length > 0) {\n            const scale = Math.max(scaleX, scaleY);\n            ctx.setLineDash(dashes.map((x)=>x / scale));\n            ctx.lineDashOffset /= scale;\n        }\n        ctx.lineWidth = lineWidth || 1;\n        ctx.stroke(newPath);\n        if (saveRestore) {\n            ctx.restore();\n        }\n    }\n    isContentVisible() {\n        for(let i = this.markedContentStack.length - 1; i >= 0; i--){\n            if (!this.markedContentStack[i].visible) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfor(const op in OPS){\n    if (CanvasGraphics.prototype[op] !== undefined) {\n        CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n    }\n}\n; // ./src/shared/obj-bin-transform.js\nclass CssFontInfo {\n    #buffer;\n    #view;\n    #decoder;\n    static{\n        this.strings = [\n            \"fontFamily\",\n            \"fontWeight\",\n            \"italicAngle\"\n        ];\n    }\n    static write(info) {\n        const encoder = new TextEncoder();\n        const encodedStrings = {};\n        let stringsLength = 0;\n        for (const prop of CssFontInfo.strings){\n            const encoded = encoder.encode(info[prop]);\n            encodedStrings[prop] = encoded;\n            stringsLength += 4 + encoded.length;\n        }\n        const buffer = new ArrayBuffer(stringsLength);\n        const data = new Uint8Array(buffer);\n        const view = new DataView(buffer);\n        let offset = 0;\n        for (const prop of CssFontInfo.strings){\n            const encoded = encodedStrings[prop];\n            const length = encoded.length;\n            view.setUint32(offset, length);\n            data.set(encoded, offset + 4);\n            offset += 4 + length;\n        }\n        assert(offset === buffer.byteLength, \"CssFontInfo.write: Buffer overflow\");\n        return buffer;\n    }\n    constructor(buffer){\n        this.#buffer = buffer;\n        this.#view = new DataView(this.#buffer);\n        this.#decoder = new TextDecoder();\n    }\n    #readString(index) {\n        assert(index < CssFontInfo.strings.length, \"Invalid string index\");\n        let offset = 0;\n        for(let i = 0; i < index; i++){\n            offset += this.#view.getUint32(offset) + 4;\n        }\n        const length = this.#view.getUint32(offset);\n        return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));\n    }\n    get fontFamily() {\n        return this.#readString(0);\n    }\n    get fontWeight() {\n        return this.#readString(1);\n    }\n    get italicAngle() {\n        return this.#readString(2);\n    }\n}\nclass SystemFontInfo {\n    #buffer;\n    #view;\n    #decoder;\n    static{\n        this.strings = [\n            \"css\",\n            \"loadedName\",\n            \"baseFontName\",\n            \"src\"\n        ];\n    }\n    static write(info) {\n        const encoder = new TextEncoder();\n        const encodedStrings = {};\n        let stringsLength = 0;\n        for (const prop of SystemFontInfo.strings){\n            const encoded = encoder.encode(info[prop]);\n            encodedStrings[prop] = encoded;\n            stringsLength += 4 + encoded.length;\n        }\n        stringsLength += 4;\n        let encodedStyleStyle, encodedStyleWeight, lengthEstimate = 1 + stringsLength;\n        if (info.style) {\n            encodedStyleStyle = encoder.encode(info.style.style);\n            encodedStyleWeight = encoder.encode(info.style.weight);\n            lengthEstimate += 4 + encodedStyleStyle.length + 4 + encodedStyleWeight.length;\n        }\n        const buffer = new ArrayBuffer(lengthEstimate);\n        const data = new Uint8Array(buffer);\n        const view = new DataView(buffer);\n        let offset = 0;\n        view.setUint8(offset++, info.guessFallback ? 1 : 0);\n        view.setUint32(offset, 0);\n        offset += 4;\n        stringsLength = 0;\n        for (const prop of SystemFontInfo.strings){\n            const encoded = encodedStrings[prop];\n            const length = encoded.length;\n            stringsLength += 4 + length;\n            view.setUint32(offset, length);\n            data.set(encoded, offset + 4);\n            offset += 4 + length;\n        }\n        view.setUint32(offset - stringsLength - 4, stringsLength);\n        if (info.style) {\n            view.setUint32(offset, encodedStyleStyle.length);\n            data.set(encodedStyleStyle, offset + 4);\n            offset += 4 + encodedStyleStyle.length;\n            view.setUint32(offset, encodedStyleWeight.length);\n            data.set(encodedStyleWeight, offset + 4);\n            offset += 4 + encodedStyleWeight.length;\n        }\n        assert(offset <= buffer.byteLength, \"SubstitionInfo.write: Buffer overflow\");\n        return buffer.transferToFixedLength(offset);\n    }\n    constructor(buffer){\n        this.#buffer = buffer;\n        this.#view = new DataView(this.#buffer);\n        this.#decoder = new TextDecoder();\n    }\n    get guessFallback() {\n        return this.#view.getUint8(0) !== 0;\n    }\n    #readString(index) {\n        assert(index < SystemFontInfo.strings.length, \"Invalid string index\");\n        let offset = 5;\n        for(let i = 0; i < index; i++){\n            offset += this.#view.getUint32(offset) + 4;\n        }\n        const length = this.#view.getUint32(offset);\n        return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));\n    }\n    get css() {\n        return this.#readString(0);\n    }\n    get loadedName() {\n        return this.#readString(1);\n    }\n    get baseFontName() {\n        return this.#readString(2);\n    }\n    get src() {\n        return this.#readString(3);\n    }\n    get style() {\n        let offset = 1;\n        offset += 4 + this.#view.getUint32(offset);\n        const styleLength = this.#view.getUint32(offset);\n        const style = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, styleLength));\n        offset += 4 + styleLength;\n        const weightLength = this.#view.getUint32(offset);\n        const weight = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, weightLength));\n        return {\n            style,\n            weight\n        };\n    }\n}\nclass FontInfo {\n    static{\n        this.bools = [\n            \"black\",\n            \"bold\",\n            \"disableFontFace\",\n            \"fontExtraProperties\",\n            \"isInvalidPDFjsFont\",\n            \"isType3Font\",\n            \"italic\",\n            \"missingFile\",\n            \"remeasure\",\n            \"vertical\"\n        ];\n    }\n    static{\n        this.numbers = [\n            \"ascent\",\n            \"defaultWidth\",\n            \"descent\"\n        ];\n    }\n    static{\n        this.strings = [\n            \"fallbackName\",\n            \"loadedName\",\n            \"mimetype\",\n            \"name\"\n        ];\n    }\n    static #OFFSET_NUMBERS = Math.ceil(this.bools.length * 2 / 8);\n    static #OFFSET_BBOX = this.#OFFSET_NUMBERS + this.numbers.length * 8;\n    static #OFFSET_FONT_MATRIX = this.#OFFSET_BBOX + 1 + 2 * 4;\n    static #OFFSET_DEFAULT_VMETRICS = this.#OFFSET_FONT_MATRIX + 1 + 8 * 6;\n    static #OFFSET_STRINGS = this.#OFFSET_DEFAULT_VMETRICS + 1 + 2 * 3;\n    #buffer;\n    #decoder;\n    #view;\n    constructor({ data, extra }){\n        this.#buffer = data;\n        this.#decoder = new TextDecoder();\n        this.#view = new DataView(this.#buffer);\n        if (extra) {\n            Object.assign(this, extra);\n        }\n    }\n    #readBoolean(index) {\n        assert(index < FontInfo.bools.length, \"Invalid boolean index\");\n        const byteOffset = Math.floor(index / 4);\n        const bitOffset = index * 2 % 8;\n        const value = this.#view.getUint8(byteOffset) >> bitOffset & 0x03;\n        return value === 0x00 ? undefined : value === 0x02;\n    }\n    get black() {\n        return this.#readBoolean(0);\n    }\n    get bold() {\n        return this.#readBoolean(1);\n    }\n    get disableFontFace() {\n        return this.#readBoolean(2);\n    }\n    get fontExtraProperties() {\n        return this.#readBoolean(3);\n    }\n    get isInvalidPDFjsFont() {\n        return this.#readBoolean(4);\n    }\n    get isType3Font() {\n        return this.#readBoolean(5);\n    }\n    get italic() {\n        return this.#readBoolean(6);\n    }\n    get missingFile() {\n        return this.#readBoolean(7);\n    }\n    get remeasure() {\n        return this.#readBoolean(8);\n    }\n    get vertical() {\n        return this.#readBoolean(9);\n    }\n    #readNumber(index) {\n        assert(index < FontInfo.numbers.length, \"Invalid number index\");\n        return this.#view.getFloat64(FontInfo.#OFFSET_NUMBERS + index * 8);\n    }\n    get ascent() {\n        return this.#readNumber(0);\n    }\n    get defaultWidth() {\n        return this.#readNumber(1);\n    }\n    get descent() {\n        return this.#readNumber(2);\n    }\n    get bbox() {\n        let offset = FontInfo.#OFFSET_BBOX;\n        const numCoords = this.#view.getUint8(offset);\n        if (numCoords === 0) {\n            return undefined;\n        }\n        offset += 1;\n        const bbox = [];\n        for(let i = 0; i < 4; i++){\n            bbox.push(this.#view.getInt16(offset, true));\n            offset += 2;\n        }\n        return bbox;\n    }\n    get fontMatrix() {\n        let offset = FontInfo.#OFFSET_FONT_MATRIX;\n        const numPoints = this.#view.getUint8(offset);\n        if (numPoints === 0) {\n            return undefined;\n        }\n        offset += 1;\n        const fontMatrix = [];\n        for(let i = 0; i < 6; i++){\n            fontMatrix.push(this.#view.getFloat64(offset, true));\n            offset += 8;\n        }\n        return fontMatrix;\n    }\n    get defaultVMetrics() {\n        let offset = FontInfo.#OFFSET_DEFAULT_VMETRICS;\n        const numMetrics = this.#view.getUint8(offset);\n        if (numMetrics === 0) {\n            return undefined;\n        }\n        offset += 1;\n        const defaultVMetrics = [];\n        for(let i = 0; i < 3; i++){\n            defaultVMetrics.push(this.#view.getInt16(offset, true));\n            offset += 2;\n        }\n        return defaultVMetrics;\n    }\n    #readString(index) {\n        assert(index < FontInfo.strings.length, \"Invalid string index\");\n        let offset = FontInfo.#OFFSET_STRINGS + 4;\n        for(let i = 0; i < index; i++){\n            offset += this.#view.getUint32(offset) + 4;\n        }\n        const length = this.#view.getUint32(offset);\n        const stringData = new Uint8Array(length);\n        stringData.set(new Uint8Array(this.#buffer, offset + 4, length));\n        return this.#decoder.decode(stringData);\n    }\n    get fallbackName() {\n        return this.#readString(0);\n    }\n    get loadedName() {\n        return this.#readString(1);\n    }\n    get mimetype() {\n        return this.#readString(2);\n    }\n    get name() {\n        return this.#readString(3);\n    }\n    get data() {\n        let offset = FontInfo.#OFFSET_STRINGS;\n        const stringsLength = this.#view.getUint32(offset);\n        offset += 4 + stringsLength;\n        const systemFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + systemFontInfoLength;\n        const cssFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + cssFontInfoLength;\n        const length = this.#view.getUint32(offset);\n        if (length === 0) {\n            return undefined;\n        }\n        return new Uint8Array(this.#buffer, offset + 4, length);\n    }\n    clearData() {\n        let offset = FontInfo.#OFFSET_STRINGS;\n        const stringsLength = this.#view.getUint32(offset);\n        offset += 4 + stringsLength;\n        const systemFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + systemFontInfoLength;\n        const cssFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + cssFontInfoLength;\n        const length = this.#view.getUint32(offset);\n        const data = new Uint8Array(this.#buffer, offset + 4, length);\n        data.fill(0);\n        this.#view.setUint32(offset, 0);\n    }\n    get cssFontInfo() {\n        let offset = FontInfo.#OFFSET_STRINGS;\n        const stringsLength = this.#view.getUint32(offset);\n        offset += 4 + stringsLength;\n        const systemFontInfoLength = this.#view.getUint32(offset);\n        offset += 4 + systemFontInfoLength;\n        const cssFontInfoLength = this.#view.getUint32(offset);\n        if (cssFontInfoLength === 0) {\n            return null;\n        }\n        const cssFontInfoData = new Uint8Array(cssFontInfoLength);\n        cssFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, cssFontInfoLength));\n        return new CssFontInfo(cssFontInfoData.buffer);\n    }\n    get systemFontInfo() {\n        let offset = FontInfo.#OFFSET_STRINGS;\n        const stringsLength = this.#view.getUint32(offset);\n        offset += 4 + stringsLength;\n        const systemFontInfoLength = this.#view.getUint32(offset);\n        if (systemFontInfoLength === 0) {\n            return null;\n        }\n        const systemFontInfoData = new Uint8Array(systemFontInfoLength);\n        systemFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, systemFontInfoLength));\n        return new SystemFontInfo(systemFontInfoData.buffer);\n    }\n    static write(font) {\n        const systemFontInfoBuffer = font.systemFontInfo ? SystemFontInfo.write(font.systemFontInfo) : null;\n        const cssFontInfoBuffer = font.cssFontInfo ? CssFontInfo.write(font.cssFontInfo) : null;\n        const encoder = new TextEncoder();\n        const encodedStrings = {};\n        let stringsLength = 0;\n        for (const prop of FontInfo.strings){\n            encodedStrings[prop] = encoder.encode(font[prop]);\n            stringsLength += 4 + encodedStrings[prop].length;\n        }\n        const lengthEstimate = FontInfo.#OFFSET_STRINGS + 4 + stringsLength + 4 + (systemFontInfoBuffer ? systemFontInfoBuffer.byteLength : 0) + 4 + (cssFontInfoBuffer ? cssFontInfoBuffer.byteLength : 0) + 4 + (font.data ? font.data.length : 0);\n        const buffer = new ArrayBuffer(lengthEstimate);\n        const data = new Uint8Array(buffer);\n        const view = new DataView(buffer);\n        let offset = 0;\n        const numBools = FontInfo.bools.length;\n        let boolByte = 0, boolBit = 0;\n        for(let i = 0; i < numBools; i++){\n            const value = font[FontInfo.bools[i]];\n            const bits = value === undefined ? 0x00 : value ? 0x02 : 0x01;\n            boolByte |= bits << boolBit;\n            boolBit += 2;\n            if (boolBit === 8 || i === numBools - 1) {\n                view.setUint8(offset++, boolByte);\n                boolByte = 0;\n                boolBit = 0;\n            }\n        }\n        assert(offset === FontInfo.#OFFSET_NUMBERS, \"FontInfo.write: Boolean properties offset mismatch\");\n        for (const prop of FontInfo.numbers){\n            view.setFloat64(offset, font[prop]);\n            offset += 8;\n        }\n        assert(offset === FontInfo.#OFFSET_BBOX, \"FontInfo.write: Number properties offset mismatch\");\n        if (font.bbox) {\n            view.setUint8(offset++, 4);\n            for (const coord of font.bbox){\n                view.setInt16(offset, coord, true);\n                offset += 2;\n            }\n        } else {\n            view.setUint8(offset++, 0);\n            offset += 2 * 4;\n        }\n        assert(offset === FontInfo.#OFFSET_FONT_MATRIX, \"FontInfo.write: BBox properties offset mismatch\");\n        if (font.fontMatrix) {\n            view.setUint8(offset++, 6);\n            for (const point of font.fontMatrix){\n                view.setFloat64(offset, point, true);\n                offset += 8;\n            }\n        } else {\n            view.setUint8(offset++, 0);\n            offset += 8 * 6;\n        }\n        assert(offset === FontInfo.#OFFSET_DEFAULT_VMETRICS, \"FontInfo.write: FontMatrix properties offset mismatch\");\n        if (font.defaultVMetrics) {\n            view.setUint8(offset++, 1);\n            for (const metric of font.defaultVMetrics){\n                view.setInt16(offset, metric, true);\n                offset += 2;\n            }\n        } else {\n            view.setUint8(offset++, 0);\n            offset += 3 * 2;\n        }\n        assert(offset === FontInfo.#OFFSET_STRINGS, \"FontInfo.write: DefaultVMetrics properties offset mismatch\");\n        view.setUint32(FontInfo.#OFFSET_STRINGS, 0);\n        offset += 4;\n        for (const prop of FontInfo.strings){\n            const encoded = encodedStrings[prop];\n            const length = encoded.length;\n            view.setUint32(offset, length);\n            data.set(encoded, offset + 4);\n            offset += 4 + length;\n        }\n        view.setUint32(FontInfo.#OFFSET_STRINGS, offset - FontInfo.#OFFSET_STRINGS - 4);\n        if (!systemFontInfoBuffer) {\n            view.setUint32(offset, 0);\n            offset += 4;\n        } else {\n            const length = systemFontInfoBuffer.byteLength;\n            view.setUint32(offset, length);\n            assert(offset + 4 + length <= buffer.byteLength, \"FontInfo.write: Buffer overflow at systemFontInfo\");\n            data.set(new Uint8Array(systemFontInfoBuffer), offset + 4);\n            offset += 4 + length;\n        }\n        if (!cssFontInfoBuffer) {\n            view.setUint32(offset, 0);\n            offset += 4;\n        } else {\n            const length = cssFontInfoBuffer.byteLength;\n            view.setUint32(offset, length);\n            assert(offset + 4 + length <= buffer.byteLength, \"FontInfo.write: Buffer overflow at cssFontInfo\");\n            data.set(new Uint8Array(cssFontInfoBuffer), offset + 4);\n            offset += 4 + length;\n        }\n        if (font.data === undefined) {\n            view.setUint32(offset, 0);\n            offset += 4;\n        } else {\n            view.setUint32(offset, font.data.length);\n            data.set(font.data, offset + 4);\n            offset += 4 + font.data.length;\n        }\n        assert(offset <= buffer.byteLength, \"FontInfo.write: Buffer overflow\");\n        return buffer.transferToFixedLength(offset);\n    }\n}\n; // ./src/display/worker_options.js\nclass GlobalWorkerOptions {\n    static #port = null;\n    static #src = \"\";\n    static get workerPort() {\n        return this.#port;\n    }\n    static set workerPort(val) {\n        if (!(typeof Worker !== \"undefined\" && val instanceof Worker) && val !== null) {\n            throw new Error(\"Invalid `workerPort` type.\");\n        }\n        this.#port = val;\n    }\n    static get workerSrc() {\n        return this.#src;\n    }\n    static set workerSrc(val) {\n        if (typeof val !== \"string\") {\n            throw new Error(\"Invalid `workerSrc` type.\");\n        }\n        this.#src = val;\n    }\n}\n; // ./src/display/metadata.js\nclass Metadata {\n    #map;\n    #data;\n    constructor({ parsedData, rawData }){\n        this.#map = parsedData;\n        this.#data = rawData;\n    }\n    getRaw() {\n        return this.#data;\n    }\n    get(name) {\n        return this.#map.get(name) ?? null;\n    }\n    [Symbol.iterator]() {\n        return this.#map.entries();\n    }\n}\n; // ./src/display/optional_content_config.js\nconst INTERNAL = Symbol(\"INTERNAL\");\nclass OptionalContentGroup {\n    #isDisplay;\n    #isPrint;\n    #userSet;\n    #visible;\n    constructor(renderingIntent, { name, intent, usage, rbGroups }){\n        this.#isDisplay = false;\n        this.#isPrint = false;\n        this.#userSet = false;\n        this.#visible = true;\n        this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);\n        this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        this.name = name;\n        this.intent = intent;\n        this.usage = usage;\n        this.rbGroups = rbGroups;\n    }\n    get visible() {\n        if (this.#userSet) {\n            return this.#visible;\n        }\n        if (!this.#visible) {\n            return false;\n        }\n        const { print, view } = this.usage;\n        if (this.#isDisplay) {\n            return view?.viewState !== \"OFF\";\n        } else if (this.#isPrint) {\n            return print?.printState !== \"OFF\";\n        }\n        return true;\n    }\n    _setVisible(internal, visible, userSet = false) {\n        if (internal !== INTERNAL) {\n            unreachable(\"Internal method `_setVisible` called.\");\n        }\n        this.#userSet = userSet;\n        this.#visible = visible;\n    }\n}\nclass OptionalContentConfig {\n    #cachedGetHash;\n    #groups;\n    #initialHash;\n    #order;\n    constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY){\n        this.#cachedGetHash = null;\n        this.#groups = new Map();\n        this.#initialHash = null;\n        this.#order = null;\n        this.renderingIntent = renderingIntent;\n        this.name = null;\n        this.creator = null;\n        if (data === null) {\n            return;\n        }\n        this.name = data.name;\n        this.creator = data.creator;\n        this.#order = data.order;\n        for (const group of data.groups){\n            this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));\n        }\n        if (data.baseState === \"OFF\") {\n            for (const group of this.#groups.values()){\n                group._setVisible(INTERNAL, false);\n            }\n        }\n        for (const on of data.on){\n            this.#groups.get(on)._setVisible(INTERNAL, true);\n        }\n        for (const off of data.off){\n            this.#groups.get(off)._setVisible(INTERNAL, false);\n        }\n        this.#initialHash = this.getHash();\n    }\n    #evaluateVisibilityExpression(array) {\n        const length = array.length;\n        if (length < 2) {\n            return true;\n        }\n        const operator = array[0];\n        for(let i = 1; i < length; i++){\n            const element = array[i];\n            let state;\n            if (Array.isArray(element)) {\n                state = this.#evaluateVisibilityExpression(element);\n            } else if (this.#groups.has(element)) {\n                state = this.#groups.get(element).visible;\n            } else {\n                warn(`Optional content group not found: ${element}`);\n                return true;\n            }\n            switch(operator){\n                case \"And\":\n                    if (!state) {\n                        return false;\n                    }\n                    break;\n                case \"Or\":\n                    if (state) {\n                        return true;\n                    }\n                    break;\n                case \"Not\":\n                    return !state;\n                default:\n                    return true;\n            }\n        }\n        return operator === \"And\";\n    }\n    isVisible(group) {\n        if (this.#groups.size === 0) {\n            return true;\n        }\n        if (!group) {\n            info(\"Optional content group not defined.\");\n            return true;\n        }\n        if (group.type === \"OCG\") {\n            if (!this.#groups.has(group.id)) {\n                warn(`Optional content group not found: ${group.id}`);\n                return true;\n            }\n            return this.#groups.get(group.id).visible;\n        } else if (group.type === \"OCMD\") {\n            if (group.expression) {\n                return this.#evaluateVisibilityExpression(group.expression);\n            }\n            if (!group.policy || group.policy === \"AnyOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            } else if (group.policy === \"AnyOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            warn(`Unknown optional content policy ${group.policy}.`);\n            return true;\n        }\n        warn(`Unknown group type ${group.type}.`);\n        return true;\n    }\n    setVisibility(id, visible = true, preserveRB = true) {\n        const group = this.#groups.get(id);\n        if (!group) {\n            warn(`Optional content group not found: ${id}`);\n            return;\n        }\n        if (preserveRB && visible && group.rbGroups.length) {\n            for (const rbGroup of group.rbGroups){\n                for (const otherId of rbGroup){\n                    if (otherId !== id) {\n                        this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);\n                    }\n                }\n            }\n        }\n        group._setVisible(INTERNAL, !!visible, true);\n        this.#cachedGetHash = null;\n    }\n    setOCGState({ state, preserveRB }) {\n        let operator;\n        for (const elem of state){\n            switch(elem){\n                case \"ON\":\n                case \"OFF\":\n                case \"Toggle\":\n                    operator = elem;\n                    continue;\n            }\n            const group = this.#groups.get(elem);\n            if (!group) {\n                continue;\n            }\n            switch(operator){\n                case \"ON\":\n                    this.setVisibility(elem, true, preserveRB);\n                    break;\n                case \"OFF\":\n                    this.setVisibility(elem, false, preserveRB);\n                    break;\n                case \"Toggle\":\n                    this.setVisibility(elem, !group.visible, preserveRB);\n                    break;\n            }\n        }\n        this.#cachedGetHash = null;\n    }\n    get hasInitialVisibility() {\n        return this.#initialHash === null || this.getHash() === this.#initialHash;\n    }\n    getOrder() {\n        if (!this.#groups.size) {\n            return null;\n        }\n        if (this.#order) {\n            return this.#order.slice();\n        }\n        return [\n            ...this.#groups.keys()\n        ];\n    }\n    getGroup(id) {\n        return this.#groups.get(id) || null;\n    }\n    getHash() {\n        if (this.#cachedGetHash !== null) {\n            return this.#cachedGetHash;\n        }\n        const hash = new MurmurHash3_64();\n        for (const [id, group] of this.#groups){\n            hash.update(`${id}:${group.visible}`);\n        }\n        return this.#cachedGetHash = hash.hexdigest();\n    }\n    [Symbol.iterator]() {\n        return this.#groups.entries();\n    }\n}\n; // ./src/display/transport_stream.js\nclass PDFDataTransportStream {\n    constructor(pdfDataRangeTransport, { disableRange = false, disableStream = false }){\n        assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n        const { length, initialData, progressiveDone, contentDispositionFilename } = pdfDataRangeTransport;\n        this._queuedChunks = [];\n        this._progressiveDone = progressiveDone;\n        this._contentDispositionFilename = contentDispositionFilename;\n        if (initialData?.length > 0) {\n            const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n            this._queuedChunks.push(buffer);\n        }\n        this._pdfDataRangeTransport = pdfDataRangeTransport;\n        this._isStreamingSupported = !disableStream;\n        this._isRangeSupported = !disableRange;\n        this._contentLength = length;\n        this._fullRequestReader = null;\n        this._rangeReaders = [];\n        pdfDataRangeTransport.addRangeListener((begin, chunk)=>{\n            this._onReceiveData({\n                begin,\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressListener((loaded, total)=>{\n            this._onProgress({\n                loaded,\n                total\n            });\n        });\n        pdfDataRangeTransport.addProgressiveReadListener((chunk)=>{\n            this._onReceiveData({\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressiveDoneListener(()=>{\n            this._onProgressiveDone();\n        });\n        pdfDataRangeTransport.transportReady();\n    }\n    _onReceiveData({ begin, chunk }) {\n        const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n        if (begin === undefined) {\n            if (this._fullRequestReader) {\n                this._fullRequestReader._enqueue(buffer);\n            } else {\n                this._queuedChunks.push(buffer);\n            }\n        } else {\n            const found = this._rangeReaders.some(function(rangeReader) {\n                if (rangeReader._begin !== begin) {\n                    return false;\n                }\n                rangeReader._enqueue(buffer);\n                return true;\n            });\n            assert(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n        }\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    _onProgress(evt) {\n        if (evt.total === undefined) {\n            this._rangeReaders[0]?.onProgress?.({\n                loaded: evt.loaded\n            });\n        } else {\n            this._fullRequestReader?.onProgress?.({\n                loaded: evt.loaded,\n                total: evt.total\n            });\n        }\n    }\n    _onProgressiveDone() {\n        this._fullRequestReader?.progressiveDone();\n        this._progressiveDone = true;\n    }\n    _removeRangeReader(reader) {\n        const i = this._rangeReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n        const queuedChunks = this._queuedChunks;\n        this._queuedChunks = null;\n        return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n        this._pdfDataRangeTransport.requestDataRange(begin, end);\n        this._rangeReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeReaders.slice(0)){\n            reader.cancel(reason);\n        }\n        this._pdfDataRangeTransport.abort();\n    }\n}\nclass PDFDataTransportStreamReader {\n    constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null){\n        this._stream = stream;\n        this._done = progressiveDone || false;\n        this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;\n        this._queuedChunks = queuedChunks || [];\n        this._loaded = 0;\n        for (const chunk of this._queuedChunks){\n            this._loaded += chunk.byteLength;\n        }\n        this._requests = [];\n        this._headersReady = Promise.resolve();\n        stream._fullRequestReader = this;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunks.push(chunk);\n        }\n        this._loaded += chunk.byteLength;\n    }\n    get headersReady() {\n        return this._headersReady;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._stream._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._stream._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._stream._contentLength;\n    }\n    async read() {\n        if (this._queuedChunks.length > 0) {\n            const chunk = this._queuedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    progressiveDone() {\n        if (this._done) {\n            return;\n        }\n        this._done = true;\n    }\n}\nclass PDFDataTransportStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._begin = begin;\n        this._end = end;\n        this._queuedChunk = null;\n        this._requests = [];\n        this._done = false;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length === 0) {\n            this._queuedChunk = chunk;\n        } else {\n            const requestsCapability = this._requests.shift();\n            requestsCapability.resolve({\n                value: chunk,\n                done: false\n            });\n            for (const requestCapability of this._requests){\n                requestCapability.resolve({\n                    value: undefined,\n                    done: true\n                });\n            }\n            this._requests.length = 0;\n        }\n        this._done = true;\n        this._stream._removeRangeReader(this);\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._queuedChunk) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._stream._removeRangeReader(this);\n    }\n}\n; // ./src/display/content_disposition.js\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n    let needsEncodingFixup = true;\n    let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = unescape(filename);\n        filename = rfc5987decode(filename);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    tmp = rfc2231getparam(contentDisposition);\n    if (tmp) {\n        const filename = rfc2047decode(tmp);\n        return fixupEncoding(filename);\n    }\n    tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    function toParamRegExp(attributePattern, flags) {\n        return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n    }\n    function textdecode(encoding, value) {\n        if (encoding) {\n            if (!/^[\\x00-\\xFF]+$/.test(value)) {\n                return value;\n            }\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(value);\n                value = decoder.decode(buffer);\n                needsEncodingFixup = false;\n            } catch  {}\n        }\n        return value;\n    }\n    function fixupEncoding(value) {\n        if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n            value = textdecode(\"utf-8\", value);\n            if (needsEncodingFixup) {\n                value = textdecode(\"iso-8859-1\", value);\n            }\n        }\n        return value;\n    }\n    function rfc2231getparam(contentDispositionStr) {\n        const matches = [];\n        let match;\n        const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n        while((match = iter.exec(contentDispositionStr)) !== null){\n            let [, n, quot, part] = match;\n            n = parseInt(n, 10);\n            if (n in matches) {\n                if (n === 0) {\n                    break;\n                }\n                continue;\n            }\n            matches[n] = [\n                quot,\n                part\n            ];\n        }\n        const parts = [];\n        for(let n = 0; n < matches.length; ++n){\n            if (!(n in matches)) {\n                break;\n            }\n            let [quot, part] = matches[n];\n            part = rfc2616unquote(part);\n            if (quot) {\n                part = unescape(part);\n                if (n === 0) {\n                    part = rfc5987decode(part);\n                }\n            }\n            parts.push(part);\n        }\n        return parts.join(\"\");\n    }\n    function rfc2616unquote(value) {\n        if (value.startsWith('\"')) {\n            const parts = value.slice(1).split('\\\\\"');\n            for(let i = 0; i < parts.length; ++i){\n                const quotindex = parts[i].indexOf('\"');\n                if (quotindex !== -1) {\n                    parts[i] = parts[i].slice(0, quotindex);\n                    parts.length = i + 1;\n                }\n                parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n            }\n            value = parts.join('\"');\n        }\n        return value;\n    }\n    function rfc5987decode(extvalue) {\n        const encodingend = extvalue.indexOf(\"'\");\n        if (encodingend === -1) {\n            return extvalue;\n        }\n        const encoding = extvalue.slice(0, encodingend);\n        const langvalue = extvalue.slice(encodingend + 1);\n        const value = langvalue.replace(/^[^']*'/, \"\");\n        return textdecode(encoding, value);\n    }\n    function rfc2047decode(value) {\n        if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n            return value;\n        }\n        return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function(matches, charset, encoding, text) {\n            if (encoding === \"q\" || encoding === \"Q\") {\n                text = text.replaceAll(\"_\", \" \");\n                text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {\n                    return String.fromCharCode(parseInt(hex, 16));\n                });\n                return textdecode(charset, text);\n            }\n            try {\n                text = atob(text);\n            } catch  {}\n            return textdecode(charset, text);\n        });\n    }\n    return \"\";\n}\n; // ./src/display/network_utils.js\nfunction createHeaders(isHttp, httpHeaders) {\n    const headers = new Headers();\n    if (!isHttp || !httpHeaders || typeof httpHeaders !== \"object\") {\n        return headers;\n    }\n    for(const key in httpHeaders){\n        const val = httpHeaders[key];\n        if (val !== undefined) {\n            headers.append(key, val);\n        }\n    }\n    return headers;\n}\nfunction getResponseOrigin(url) {\n    return URL.parse(url)?.origin ?? null;\n}\nfunction validateRangeRequestCapabilities({ responseHeaders, isHttp, rangeChunkSize, disableRange }) {\n    const returnValues = {\n        allowRangeRequests: false,\n        suggestedLength: undefined\n    };\n    const length = parseInt(responseHeaders.get(\"Content-Length\"), 10);\n    if (!Number.isInteger(length)) {\n        return returnValues;\n    }\n    returnValues.suggestedLength = length;\n    if (length <= 2 * rangeChunkSize) {\n        return returnValues;\n    }\n    if (disableRange || !isHttp) {\n        return returnValues;\n    }\n    if (responseHeaders.get(\"Accept-Ranges\") !== \"bytes\") {\n        return returnValues;\n    }\n    const contentEncoding = responseHeaders.get(\"Content-Encoding\") || \"identity\";\n    if (contentEncoding !== \"identity\") {\n        return returnValues;\n    }\n    returnValues.allowRangeRequests = true;\n    return returnValues;\n}\nfunction extractFilenameFromHeader(responseHeaders) {\n    const contentDisposition = responseHeaders.get(\"Content-Disposition\");\n    if (contentDisposition) {\n        let filename = getFilenameFromContentDispositionHeader(contentDisposition);\n        if (filename.includes(\"%\")) {\n            try {\n                filename = decodeURIComponent(filename);\n            } catch  {}\n        }\n        if (isPdfFile(filename)) {\n            return filename;\n        }\n    }\n    return null;\n}\nfunction createResponseError(status, url) {\n    return new ResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status, status === 404 || status === 0 && url.startsWith(\"file:\"));\n}\nfunction validateResponseStatus(status) {\n    return status === 200 || status === 206;\n}\n; // ./src/display/fetch_stream.js\nfunction createFetchOptions(headers, withCredentials, abortController) {\n    return {\n        method: \"GET\",\n        headers,\n        signal: abortController.signal,\n        mode: \"cors\",\n        credentials: withCredentials ? \"include\" : \"same-origin\",\n        redirect: \"follow\"\n    };\n}\nfunction getArrayBuffer(val) {\n    if (val instanceof Uint8Array) {\n        return val.buffer;\n    }\n    if (val instanceof ArrayBuffer) {\n        return val;\n    }\n    warn(`getArrayBuffer - unexpected data format: ${val}`);\n    return new Uint8Array(val).buffer;\n}\nclass PDFFetchStream {\n    constructor(source){\n        this._responseOrigin = null;\n        this.source = source;\n        this.isHttp = /^https?:/i.test(source.url);\n        this.headers = createHeaders(this.isHttp, source.httpHeaders);\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFFetchStreamReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFFetchStreamRangeReader(this, begin, end);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFFetchStreamReader {\n    constructor(stream){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        this._filename = null;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._contentLength = source.length;\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._abortController = new AbortController();\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        const headers = new Headers(stream.headers);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            stream._responseOrigin = getResponseOrigin(response.url);\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseError(response.status, url);\n            }\n            this._reader = response.body.getReader();\n            this._headersCapability.resolve();\n            const responseHeaders = response.headers;\n            const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n                responseHeaders,\n                isHttp: stream.isHttp,\n                rangeChunkSize: this._rangeChunkSize,\n                disableRange: this._disableRange\n            });\n            this._isRangeSupported = allowRangeRequests;\n            this._contentLength = suggestedLength || this._contentLength;\n            this._filename = extractFilenameFromHeader(responseHeaders);\n            if (!this._isStreamingSupported && this._isRangeSupported) {\n                this.cancel(new AbortException(\"Streaming is disabled.\"));\n            }\n        }).catch(this._headersCapability.reject);\n        this.onProgress = null;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\nclass PDFFetchStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._readCapability = Promise.withResolvers();\n        this._isStreamingSupported = !source.disableStream;\n        this._abortController = new AbortController();\n        const headers = new Headers(stream.headers);\n        headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            const responseOrigin = getResponseOrigin(response.url);\n            if (responseOrigin !== stream._responseOrigin) {\n                throw new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${stream._responseOrigin}\".`);\n            }\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseError(response.status, url);\n            }\n            this._readCapability.resolve();\n            this._reader = response.body.getReader();\n        }).catch(this._readCapability.reject);\n        this.onProgress = null;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\n; // ./src/display/network.js\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\nfunction network_getArrayBuffer(xhr) {\n    const data = xhr.response;\n    if (typeof data !== \"string\") {\n        return data;\n    }\n    return stringToBytes(data).buffer;\n}\nclass NetworkManager {\n    constructor({ url, httpHeaders, withCredentials }){\n        this._responseOrigin = null;\n        this.url = url;\n        this.isHttp = /^https?:/i.test(url);\n        this.headers = createHeaders(this.isHttp, httpHeaders);\n        this.withCredentials = withCredentials || false;\n        this.currXhrId = 0;\n        this.pendingRequests = Object.create(null);\n    }\n    request(args) {\n        const xhr = new XMLHttpRequest();\n        const xhrId = this.currXhrId++;\n        const pendingRequest = this.pendingRequests[xhrId] = {\n            xhr\n        };\n        xhr.open(\"GET\", this.url);\n        xhr.withCredentials = this.withCredentials;\n        for (const [key, val] of this.headers){\n            xhr.setRequestHeader(key, val);\n        }\n        if (this.isHttp && \"begin\" in args && \"end\" in args) {\n            xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n            pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n        } else {\n            pendingRequest.expectedStatus = OK_RESPONSE;\n        }\n        xhr.responseType = \"arraybuffer\";\n        assert(args.onError, \"Expected `onError` callback to be provided.\");\n        xhr.onerror = ()=>{\n            args.onError(xhr.status);\n        };\n        xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n        xhr.onprogress = this.onProgress.bind(this, xhrId);\n        pendingRequest.onHeadersReceived = args.onHeadersReceived;\n        pendingRequest.onDone = args.onDone;\n        pendingRequest.onError = args.onError;\n        pendingRequest.onProgress = args.onProgress;\n        xhr.send(null);\n        return xhrId;\n    }\n    onProgress(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        pendingRequest.onProgress?.(evt);\n    }\n    onStateChange(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        const xhr = pendingRequest.xhr;\n        if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n            pendingRequest.onHeadersReceived();\n            delete pendingRequest.onHeadersReceived;\n        }\n        if (xhr.readyState !== 4) {\n            return;\n        }\n        if (!(xhrId in this.pendingRequests)) {\n            return;\n        }\n        delete this.pendingRequests[xhrId];\n        if (xhr.status === 0 && this.isHttp) {\n            pendingRequest.onError(xhr.status);\n            return;\n        }\n        const xhrStatus = xhr.status || OK_RESPONSE;\n        const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n        if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n            pendingRequest.onError(xhr.status);\n            return;\n        }\n        const chunk = network_getArrayBuffer(xhr);\n        if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n            const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n            const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n            if (matches) {\n                pendingRequest.onDone({\n                    begin: parseInt(matches[1], 10),\n                    chunk\n                });\n            } else {\n                warn(`Missing or invalid \"Content-Range\" header.`);\n                pendingRequest.onError(0);\n            }\n        } else if (chunk) {\n            pendingRequest.onDone({\n                begin: 0,\n                chunk\n            });\n        } else {\n            pendingRequest.onError(xhr.status);\n        }\n    }\n    getRequestXhr(xhrId) {\n        return this.pendingRequests[xhrId].xhr;\n    }\n    isPendingRequest(xhrId) {\n        return xhrId in this.pendingRequests;\n    }\n    abortRequest(xhrId) {\n        const xhr = this.pendingRequests[xhrId].xhr;\n        delete this.pendingRequests[xhrId];\n        xhr.abort();\n    }\n}\nclass PDFNetworkStream {\n    constructor(source){\n        this._source = source;\n        this._manager = new NetworkManager(source);\n        this._rangeChunkSize = source.rangeChunkSize;\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    _onRangeRequestReaderClosed(reader) {\n        const i = this._rangeRequestReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeRequestReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n        reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNetworkStreamFullRequestReader {\n    constructor(manager, source){\n        this._manager = manager;\n        this._url = source.url;\n        this._fullRequestId = manager.request({\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        });\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._contentLength = source.length;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = false;\n        this._isRangeSupported = false;\n        this._cachedChunks = [];\n        this._requests = [];\n        this._done = false;\n        this._storedError = undefined;\n        this._filename = null;\n        this.onProgress = null;\n    }\n    _onHeadersReceived() {\n        const fullRequestXhrId = this._fullRequestId;\n        const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n        this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);\n        const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();\n        const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\\S ]+$/, \"\").split(/[\\r\\n]+/).map((x)=>{\n            const [key, ...val] = x.split(\": \");\n            return [\n                key,\n                val.join(\": \")\n            ];\n        }) : []);\n        const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n            responseHeaders,\n            isHttp: this._manager.isHttp,\n            rangeChunkSize: this._rangeChunkSize,\n            disableRange: this._disableRange\n        });\n        if (allowRangeRequests) {\n            this._isRangeSupported = true;\n        }\n        this._contentLength = suggestedLength || this._contentLength;\n        this._filename = extractFilenameFromHeader(responseHeaders);\n        if (this._isRangeSupported) {\n            this._manager.abortRequest(fullRequestXhrId);\n        }\n        this._headersCapability.resolve();\n    }\n    _onDone(data) {\n        if (data) {\n            if (this._requests.length > 0) {\n                const requestCapability = this._requests.shift();\n                requestCapability.resolve({\n                    value: data.chunk,\n                    done: false\n                });\n            } else {\n                this._cachedChunks.push(data.chunk);\n            }\n        }\n        this._done = true;\n        if (this._cachedChunks.length > 0) {\n            return;\n        }\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    _onError(status) {\n        this._storedError = createResponseError(status, this._url);\n        this._headersCapability.reject(this._storedError);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._cachedChunks.length = 0;\n    }\n    _onProgress(evt) {\n        this.onProgress?.({\n            loaded: evt.loaded,\n            total: evt.lengthComputable ? evt.total : this._contentLength\n        });\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._cachedChunks.length > 0) {\n            const chunk = this._cachedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        this._headersCapability.reject(reason);\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._fullRequestId)) {\n            this._manager.abortRequest(this._fullRequestId);\n        }\n        this._fullRequestReader = null;\n    }\n}\nclass PDFNetworkStreamRangeRequestReader {\n    constructor(manager, begin, end){\n        this._manager = manager;\n        this._url = manager.url;\n        this._requestId = manager.request({\n            begin,\n            end,\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        });\n        this._requests = [];\n        this._queuedChunk = null;\n        this._done = false;\n        this._storedError = undefined;\n        this.onProgress = null;\n        this.onClosed = null;\n    }\n    _onHeadersReceived() {\n        const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);\n        if (responseOrigin !== this._manager._responseOrigin) {\n            this._storedError = new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${this._manager._responseOrigin}\".`);\n            this._onError(0);\n        }\n    }\n    _close() {\n        this.onClosed?.(this);\n    }\n    _onDone(data) {\n        const chunk = data.chunk;\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunk = chunk;\n        }\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._close();\n    }\n    _onError(status) {\n        this._storedError ??= createResponseError(status, this._url);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._queuedChunk = null;\n    }\n    _onProgress(evt) {\n        if (!this.isStreamingSupported) {\n            this.onProgress?.({\n                loaded: evt.loaded\n            });\n        }\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._queuedChunk !== null) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._requestId)) {\n            this._manager.abortRequest(this._requestId);\n        }\n        this._close();\n    }\n}\n; // ./src/display/node_stream.js\nconst urlRegex = /^[a-z][a-z0-9\\-+.]+:/i;\nfunction parseUrlOrPath(sourceUrl) {\n    if (urlRegex.test(sourceUrl)) {\n        return new URL(sourceUrl);\n    }\n    const url = process.getBuiltinModule(\"url\");\n    return new URL(url.pathToFileURL(sourceUrl));\n}\nclass PDFNodeStream {\n    constructor(source){\n        this.source = source;\n        this.url = parseUrlOrPath(source.url);\n        assert(this.url.protocol === \"file:\", \"PDFNodeStream only supports file:// URLs.\");\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNodeStreamFsFullReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(start, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);\n        this._rangeRequestReaders.push(rangeReader);\n        return rangeReader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNodeStreamFsFullReader {\n    constructor(stream){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        const source = stream.source;\n        this._contentLength = source.length;\n        this._loaded = 0;\n        this._filename = null;\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        this._headersCapability = Promise.withResolvers();\n        const fs = process.getBuiltinModule(\"fs\");\n        fs.promises.lstat(this._url).then((stat)=>{\n            this._contentLength = stat.size;\n            this._setReadableStream(fs.createReadStream(this._url));\n            this._headersCapability.resolve();\n        }, (error)=>{\n            if (error.code === \"ENOENT\") {\n                error = createResponseError(0, this._url.href);\n            }\n            this._storedError = error;\n            this._headersCapability.reject(error);\n        });\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (!this._isStreamingSupported && this._isRangeSupported) {\n            this._error(new AbortException(\"streaming is disabled\"));\n        }\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\nclass PDFNodeStreamFsRangeReader {\n    constructor(stream, start, end){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        this._loaded = 0;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        const source = stream.source;\n        this._isStreamingSupported = !source.disableStream;\n        const fs = process.getBuiltinModule(\"fs\");\n        this._setReadableStream(fs.createReadStream(this._url, {\n            start,\n            end: end - 1\n        }));\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\n; // ./src/display/pdf_objects.js\nconst INITIAL_DATA = Symbol(\"INITIAL_DATA\");\nclass PDFObjects {\n    #objs;\n    #ensureObj(objId) {\n        return this.#objs[objId] ||= {\n            ...Promise.withResolvers(),\n            data: INITIAL_DATA\n        };\n    }\n    get(objId, callback = null) {\n        if (callback) {\n            const obj = this.#ensureObj(objId);\n            obj.promise.then(()=>callback(obj.data));\n            return null;\n        }\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n        }\n        return obj.data;\n    }\n    has(objId) {\n        const obj = this.#objs[objId];\n        return !!obj && obj.data !== INITIAL_DATA;\n    }\n    delete(objId) {\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            return false;\n        }\n        delete this.#objs[objId];\n        return true;\n    }\n    resolve(objId, data = null) {\n        const obj = this.#ensureObj(objId);\n        obj.data = data;\n        obj.resolve();\n    }\n    clear() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            data?.bitmap?.close();\n        }\n        this.#objs = Object.create(null);\n    }\n    *[Symbol.iterator]() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            if (data === INITIAL_DATA) {\n                continue;\n            }\n            yield [\n                objId,\n                data\n            ];\n        }\n    }\n    constructor(){\n        this.#objs = Object.create(null);\n    }\n}\n; // ./src/display/text_layer.js\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nclass TextLayer {\n    #capability;\n    #container;\n    #disableProcessItems;\n    #fontInspectorEnabled;\n    #lang;\n    #layoutTextParams;\n    #pageHeight;\n    #pageWidth;\n    #reader;\n    #rootContainer;\n    #rotation;\n    #scale;\n    #styleCache;\n    #textContentItemsStr;\n    #textContentSource;\n    #textDivs;\n    #textDivProperties;\n    #transform;\n    static #ascentCache = new Map();\n    static #canvasContexts = new Map();\n    static #canvasCtxFonts = new WeakMap();\n    static #minFontSize = null;\n    static #pendingTextLayers = new Set();\n    constructor({ textContentSource, container, viewport }){\n        this.#capability = Promise.withResolvers();\n        this.#container = null;\n        this.#disableProcessItems = false;\n        this.#fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n        this.#lang = null;\n        this.#layoutTextParams = null;\n        this.#pageHeight = 0;\n        this.#pageWidth = 0;\n        this.#reader = null;\n        this.#rootContainer = null;\n        this.#rotation = 0;\n        this.#scale = 0;\n        this.#styleCache = Object.create(null);\n        this.#textContentItemsStr = [];\n        this.#textContentSource = null;\n        this.#textDivs = [];\n        this.#textDivProperties = new WeakMap();\n        this.#transform = null;\n        if (textContentSource instanceof ReadableStream) {\n            this.#textContentSource = textContentSource;\n        } else if (typeof textContentSource === \"object\") {\n            this.#textContentSource = new ReadableStream({\n                start (controller) {\n                    controller.enqueue(textContentSource);\n                    controller.close();\n                }\n            });\n        } else {\n            throw new Error('No \"textContentSource\" parameter specified.');\n        }\n        this.#container = this.#rootContainer = container;\n        this.#scale = viewport.scale * OutputScale.pixelRatio;\n        this.#rotation = viewport.rotation;\n        this.#layoutTextParams = {\n            div: null,\n            properties: null,\n            ctx: null\n        };\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        this.#transform = [\n            1,\n            0,\n            0,\n            -1,\n            -pageX,\n            pageY + pageHeight\n        ];\n        this.#pageWidth = pageWidth;\n        this.#pageHeight = pageHeight;\n        TextLayer.#ensureMinFontSizeComputed();\n        setLayerDimensions(container, viewport);\n        this.#capability.promise.finally(()=>{\n            TextLayer.#pendingTextLayers.delete(this);\n            this.#layoutTextParams = null;\n            this.#styleCache = null;\n        }).catch(()=>{});\n    }\n    static get fontFamilyMap() {\n        const { isWindows, isFirefox } = util_FeatureTest.platform;\n        return shadow(this, \"fontFamilyMap\", new Map([\n            [\n                \"sans-serif\",\n                `${isWindows && isFirefox ? \"Calibri, \" : \"\"}sans-serif`\n            ],\n            [\n                \"monospace\",\n                `${isWindows && isFirefox ? \"Lucida Console, \" : \"\"}monospace`\n            ]\n        ]));\n    }\n    render() {\n        const pump = ()=>{\n            this.#reader.read().then(({ value, done })=>{\n                if (done) {\n                    this.#capability.resolve();\n                    return;\n                }\n                this.#lang ??= value.lang;\n                Object.assign(this.#styleCache, value.styles);\n                this.#processItems(value.items);\n                pump();\n            }, this.#capability.reject);\n        };\n        this.#reader = this.#textContentSource.getReader();\n        TextLayer.#pendingTextLayers.add(this);\n        pump();\n        return this.#capability.promise;\n    }\n    update({ viewport, onBefore = null }) {\n        const scale = viewport.scale * OutputScale.pixelRatio;\n        const rotation = viewport.rotation;\n        if (rotation !== this.#rotation) {\n            onBefore?.();\n            this.#rotation = rotation;\n            setLayerDimensions(this.#rootContainer, {\n                rotation\n            });\n        }\n        if (scale !== this.#scale) {\n            onBefore?.();\n            this.#scale = scale;\n            const params = {\n                div: null,\n                properties: null,\n                ctx: TextLayer.#getCtx(this.#lang)\n            };\n            for (const div of this.#textDivs){\n                params.properties = this.#textDivProperties.get(div);\n                params.div = div;\n                this.#layout(params);\n            }\n        }\n    }\n    cancel() {\n        const abortEx = new AbortException(\"TextLayer task cancelled.\");\n        this.#reader?.cancel(abortEx).catch(()=>{});\n        this.#reader = null;\n        this.#capability.reject(abortEx);\n    }\n    get textDivs() {\n        return this.#textDivs;\n    }\n    get textContentItemsStr() {\n        return this.#textContentItemsStr;\n    }\n    #processItems(items) {\n        if (this.#disableProcessItems) {\n            return;\n        }\n        this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);\n        const textDivs = this.#textDivs, textContentItemsStr = this.#textContentItemsStr;\n        for (const item of items){\n            if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {\n                warn(\"Ignoring additional textDivs for performance reasons.\");\n                this.#disableProcessItems = true;\n                return;\n            }\n            if (item.str === undefined) {\n                if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n                    const parent = this.#container;\n                    this.#container = document.createElement(\"span\");\n                    this.#container.classList.add(\"markedContent\");\n                    if (item.id) {\n                        this.#container.setAttribute(\"id\", `${item.id}`);\n                    }\n                    parent.append(this.#container);\n                } else if (item.type === \"endMarkedContent\") {\n                    this.#container = this.#container.parentNode;\n                }\n                continue;\n            }\n            textContentItemsStr.push(item.str);\n            this.#appendText(item);\n        }\n    }\n    #appendText(geom) {\n        const textDiv = document.createElement(\"span\");\n        const textDivProperties = {\n            angle: 0,\n            canvasWidth: 0,\n            hasText: geom.str !== \"\",\n            hasEOL: geom.hasEOL,\n            fontSize: 0\n        };\n        this.#textDivs.push(textDiv);\n        const tx = Util.transform(this.#transform, geom.transform);\n        let angle = Math.atan2(tx[1], tx[0]);\n        const style = this.#styleCache[geom.fontName];\n        if (style.vertical) {\n            angle += Math.PI / 2;\n        }\n        let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;\n        fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n        const fontHeight = Math.hypot(tx[2], tx[3]);\n        const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, style, this.#lang);\n        let left, top;\n        if (angle === 0) {\n            left = tx[4];\n            top = tx[5] - fontAscent;\n        } else {\n            left = tx[4] + fontAscent * Math.sin(angle);\n            top = tx[5] - fontAscent * Math.cos(angle);\n        }\n        const scaleFactorStr = \"calc(var(--total-scale-factor) *\";\n        const divStyle = textDiv.style;\n        if (this.#container === this.#rootContainer) {\n            divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;\n            divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;\n        } else {\n            divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n            divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n        }\n        divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;\n        divStyle.fontFamily = fontFamily;\n        textDivProperties.fontSize = fontHeight;\n        textDiv.setAttribute(\"role\", \"presentation\");\n        textDiv.textContent = geom.str;\n        textDiv.dir = geom.dir;\n        if (this.#fontInspectorEnabled) {\n            textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;\n        }\n        if (angle !== 0) {\n            textDivProperties.angle = angle * (180 / Math.PI);\n        }\n        let shouldScaleText = false;\n        if (geom.str.length > 1) {\n            shouldScaleText = true;\n        } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n            const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);\n            if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n                shouldScaleText = true;\n            }\n        }\n        if (shouldScaleText) {\n            textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n        }\n        this.#textDivProperties.set(textDiv, textDivProperties);\n        this.#layoutTextParams.div = textDiv;\n        this.#layoutTextParams.properties = textDivProperties;\n        this.#layout(this.#layoutTextParams);\n        if (textDivProperties.hasText) {\n            this.#container.append(textDiv);\n        }\n        if (textDivProperties.hasEOL) {\n            const br = document.createElement(\"br\");\n            br.setAttribute(\"role\", \"presentation\");\n            this.#container.append(br);\n        }\n    }\n    #layout(params) {\n        const { div, properties, ctx } = params;\n        const { style } = div;\n        let transform = \"\";\n        if (TextLayer.#minFontSize > 1) {\n            transform = `scale(${1 / TextLayer.#minFontSize})`;\n        }\n        if (properties.canvasWidth !== 0 && properties.hasText) {\n            const { fontFamily } = style;\n            const { canvasWidth, fontSize } = properties;\n            TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);\n            const { width } = ctx.measureText(div.textContent);\n            if (width > 0) {\n                transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;\n            }\n        }\n        if (properties.angle !== 0) {\n            transform = `rotate(${properties.angle}deg) ${transform}`;\n        }\n        if (transform.length > 0) {\n            style.transform = transform;\n        }\n    }\n    static cleanup() {\n        if (this.#pendingTextLayers.size > 0) {\n            return;\n        }\n        this.#ascentCache.clear();\n        for (const { canvas } of this.#canvasContexts.values()){\n            canvas.remove();\n        }\n        this.#canvasContexts.clear();\n    }\n    static #getCtx(lang = null) {\n        let ctx = this.#canvasContexts.get(lang ||= \"\");\n        if (!ctx) {\n            const canvas = document.createElement(\"canvas\");\n            canvas.className = \"hiddenCanvasElement\";\n            canvas.lang = lang;\n            document.body.append(canvas);\n            ctx = canvas.getContext(\"2d\", {\n                alpha: false,\n                willReadFrequently: true\n            });\n            this.#canvasContexts.set(lang, ctx);\n            this.#canvasCtxFonts.set(ctx, {\n                size: 0,\n                family: \"\"\n            });\n        }\n        return ctx;\n    }\n    static #ensureCtxFont(ctx, size, family) {\n        const cached = this.#canvasCtxFonts.get(ctx);\n        if (size === cached.size && family === cached.family) {\n            return;\n        }\n        ctx.font = `${size}px ${family}`;\n        cached.size = size;\n        cached.family = family;\n    }\n    static #ensureMinFontSizeComputed() {\n        if (this.#minFontSize !== null) {\n            return;\n        }\n        const div = document.createElement(\"div\");\n        div.style.opacity = 0;\n        div.style.lineHeight = 1;\n        div.style.fontSize = \"1px\";\n        div.style.position = \"absolute\";\n        div.textContent = \"X\";\n        document.body.append(div);\n        this.#minFontSize = div.getBoundingClientRect().height;\n        div.remove();\n    }\n    static #getAscent(fontFamily, style, lang) {\n        const cachedAscent = this.#ascentCache.get(fontFamily);\n        if (cachedAscent) {\n            return cachedAscent;\n        }\n        const ctx = this.#getCtx(lang);\n        ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;\n        this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);\n        const metrics = ctx.measureText(\"\");\n        const ascent = metrics.fontBoundingBoxAscent;\n        const descent = Math.abs(metrics.fontBoundingBoxDescent);\n        ctx.canvas.width = ctx.canvas.height = 0;\n        let ratio = 0.8;\n        if (ascent) {\n            ratio = ascent / (ascent + descent);\n        } else {\n            if (util_FeatureTest.platform.isFirefox) {\n                warn(\"Enable the `dom.textMetrics.fontBoundingBox.enabled` preference \" + \"in `about:config` to improve TextLayer rendering.\");\n            }\n            if (style.ascent) {\n                ratio = style.ascent;\n            } else if (style.descent) {\n                ratio = 1 + style.descent;\n            }\n        }\n        this.#ascentCache.set(fontFamily, ratio);\n        return ratio;\n    }\n}\n; // ./src/display/api.js\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nfunction getDocument(src = {}) {\n    if (typeof src === \"string\" || src instanceof URL) {\n        src = {\n            url: src\n        };\n    } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {\n        src = {\n            data: src\n        };\n    }\n    const task = new PDFDocumentLoadingTask();\n    const { docId } = task;\n    const url = src.url ? getUrlProp(src.url) : null;\n    const data = src.data ? getDataProp(src.data) : null;\n    const httpHeaders = src.httpHeaders || null;\n    const withCredentials = src.withCredentials === true;\n    const password = src.password ?? null;\n    const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n    const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : 2 ** 16;\n    let worker = src.worker instanceof PDFWorker ? src.worker : null;\n    const verbosity = src.verbosity;\n    const docBaseUrl = typeof src.docBaseUrl === \"string\" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;\n    const cMapUrl = getFactoryUrlProp(src.cMapUrl);\n    const cMapPacked = src.cMapPacked !== false;\n    const CMapReaderFactory = src.CMapReaderFactory || (isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory);\n    const iccUrl = getFactoryUrlProp(src.iccUrl);\n    const standardFontDataUrl = getFactoryUrlProp(src.standardFontDataUrl);\n    const StandardFontDataFactory = src.StandardFontDataFactory || (isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory);\n    const wasmUrl = getFactoryUrlProp(src.wasmUrl);\n    const WasmFactory = src.WasmFactory || (isNodeJS ? NodeWasmFactory : DOMWasmFactory);\n    const ignoreErrors = src.stopAtErrors !== true;\n    const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n    const isEvalSupported = src.isEvalSupported !== false;\n    const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !isNodeJS;\n    const isImageDecoderSupported = typeof src.isImageDecoderSupported === \"boolean\" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);\n    const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n    const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : isNodeJS;\n    const fontExtraProperties = src.fontExtraProperties === true;\n    const enableXfa = src.enableXfa === true;\n    const ownerDocument = src.ownerDocument || globalThis.document;\n    const disableRange = src.disableRange === true;\n    const disableStream = src.disableStream === true;\n    const disableAutoFetch = src.disableAutoFetch === true;\n    const pdfBug = src.pdfBug === true;\n    const CanvasFactory = src.CanvasFactory || (isNodeJS ? NodeCanvasFactory : DOMCanvasFactory);\n    const FilterFactory = src.FilterFactory || (isNodeJS ? NodeFilterFactory : DOMFilterFactory);\n    const enableHWA = src.enableHWA === true;\n    const useWasm = src.useWasm !== false;\n    const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n    const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !isNodeJS && !disableFontFace;\n    const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : !!(CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && WasmFactory === DOMWasmFactory && cMapUrl && standardFontDataUrl && wasmUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI) && isValidFetchUrl(wasmUrl, document.baseURI));\n    const styleElement = null;\n    setVerbosityLevel(verbosity);\n    const transportFactory = {\n        canvasFactory: new CanvasFactory({\n            ownerDocument,\n            enableHWA\n        }),\n        filterFactory: new FilterFactory({\n            docId,\n            ownerDocument\n        }),\n        cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({\n            baseUrl: cMapUrl,\n            isCompressed: cMapPacked\n        }),\n        standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({\n            baseUrl: standardFontDataUrl\n        }),\n        wasmFactory: useWorkerFetch ? null : new WasmFactory({\n            baseUrl: wasmUrl\n        })\n    };\n    if (!worker) {\n        worker = PDFWorker.create({\n            verbosity,\n            port: GlobalWorkerOptions.workerPort\n        });\n        task._worker = worker;\n    }\n    const docParams = {\n        docId,\n        apiVersion: \"5.4.296\",\n        data,\n        password,\n        disableAutoFetch,\n        rangeChunkSize,\n        length,\n        docBaseUrl,\n        enableXfa,\n        evaluatorOptions: {\n            maxImageSize,\n            disableFontFace,\n            ignoreErrors,\n            isEvalSupported,\n            isOffscreenCanvasSupported,\n            isImageDecoderSupported,\n            canvasMaxAreaInBytes,\n            fontExtraProperties,\n            useSystemFonts,\n            useWasm,\n            useWorkerFetch,\n            cMapUrl,\n            iccUrl,\n            standardFontDataUrl,\n            wasmUrl\n        }\n    };\n    const transportParams = {\n        ownerDocument,\n        pdfBug,\n        styleElement,\n        loadingParams: {\n            disableAutoFetch,\n            enableXfa\n        }\n    };\n    worker.promise.then(function() {\n        if (task.destroyed) {\n            throw new Error(\"Loading aborted\");\n        }\n        if (worker.destroyed) {\n            throw new Error(\"Worker was destroyed\");\n        }\n        const workerIdPromise = worker.messageHandler.sendWithPromise(\"GetDocRequest\", docParams, data ? [\n            data.buffer\n        ] : null);\n        let networkStream;\n        if (rangeTransport) {\n            networkStream = new PDFDataTransportStream(rangeTransport, {\n                disableRange,\n                disableStream\n            });\n        } else if (!data) {\n            if (!url) {\n                throw new Error(\"getDocument - no `url` parameter provided.\");\n            }\n            const NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : isNodeJS ? PDFNodeStream : PDFNetworkStream;\n            networkStream = new NetworkStream({\n                url,\n                length,\n                httpHeaders,\n                withCredentials,\n                rangeChunkSize,\n                disableRange,\n                disableStream\n            });\n        }\n        return workerIdPromise.then((workerId)=>{\n            if (task.destroyed) {\n                throw new Error(\"Loading aborted\");\n            }\n            if (worker.destroyed) {\n                throw new Error(\"Worker was destroyed\");\n            }\n            const messageHandler = new MessageHandler(docId, workerId, worker.port);\n            const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory, enableHWA);\n            task._transport = transport;\n            messageHandler.send(\"Ready\", null);\n        });\n    }).catch(task._capability.reject);\n    return task;\n}\nclass PDFDocumentLoadingTask {\n    static #docId = 0;\n    get promise() {\n        return this._capability.promise;\n    }\n    async destroy() {\n        this.destroyed = true;\n        try {\n            if (this._worker?.port) {\n                this._worker._pendingDestroy = true;\n            }\n            await this._transport?.destroy();\n        } catch (ex) {\n            if (this._worker?.port) {\n                delete this._worker._pendingDestroy;\n            }\n            throw ex;\n        }\n        this._transport = null;\n        this._worker?.destroy();\n        this._worker = null;\n    }\n    async getData() {\n        return this._transport.getData();\n    }\n    constructor(){\n        this._capability = Promise.withResolvers();\n        this._transport = null;\n        this._worker = null;\n        this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n        this.destroyed = false;\n        this.onPassword = null;\n        this.onProgress = null;\n    }\n}\nclass PDFDataRangeTransport {\n    #capability;\n    #progressiveDoneListeners;\n    #progressiveReadListeners;\n    #progressListeners;\n    #rangeListeners;\n    constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null){\n        this.#capability = Promise.withResolvers();\n        this.#progressiveDoneListeners = [];\n        this.#progressiveReadListeners = [];\n        this.#progressListeners = [];\n        this.#rangeListeners = [];\n        this.length = length;\n        this.initialData = initialData;\n        this.progressiveDone = progressiveDone;\n        this.contentDispositionFilename = contentDispositionFilename;\n    }\n    addRangeListener(listener) {\n        this.#rangeListeners.push(listener);\n    }\n    addProgressListener(listener) {\n        this.#progressListeners.push(listener);\n    }\n    addProgressiveReadListener(listener) {\n        this.#progressiveReadListeners.push(listener);\n    }\n    addProgressiveDoneListener(listener) {\n        this.#progressiveDoneListeners.push(listener);\n    }\n    onDataRange(begin, chunk) {\n        for (const listener of this.#rangeListeners){\n            listener(begin, chunk);\n        }\n    }\n    onDataProgress(loaded, total) {\n        this.#capability.promise.then(()=>{\n            for (const listener of this.#progressListeners){\n                listener(loaded, total);\n            }\n        });\n    }\n    onDataProgressiveRead(chunk) {\n        this.#capability.promise.then(()=>{\n            for (const listener of this.#progressiveReadListeners){\n                listener(chunk);\n            }\n        });\n    }\n    onDataProgressiveDone() {\n        this.#capability.promise.then(()=>{\n            for (const listener of this.#progressiveDoneListeners){\n                listener();\n            }\n        });\n    }\n    transportReady() {\n        this.#capability.resolve();\n    }\n    requestDataRange(begin, end) {\n        unreachable(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n    }\n    abort() {}\n}\nclass PDFDocumentProxy {\n    constructor(pdfInfo, transport){\n        this._pdfInfo = pdfInfo;\n        this._transport = transport;\n    }\n    get annotationStorage() {\n        return this._transport.annotationStorage;\n    }\n    get canvasFactory() {\n        return this._transport.canvasFactory;\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get numPages() {\n        return this._pdfInfo.numPages;\n    }\n    get fingerprints() {\n        return this._pdfInfo.fingerprints;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    get allXfaHtml() {\n        return this._transport._htmlForXfa;\n    }\n    getPage(pageNumber) {\n        return this._transport.getPage(pageNumber);\n    }\n    getPageIndex(ref) {\n        return this._transport.getPageIndex(ref);\n    }\n    getDestinations() {\n        return this._transport.getDestinations();\n    }\n    getDestination(id) {\n        return this._transport.getDestination(id);\n    }\n    getPageLabels() {\n        return this._transport.getPageLabels();\n    }\n    getPageLayout() {\n        return this._transport.getPageLayout();\n    }\n    getPageMode() {\n        return this._transport.getPageMode();\n    }\n    getViewerPreferences() {\n        return this._transport.getViewerPreferences();\n    }\n    getOpenAction() {\n        return this._transport.getOpenAction();\n    }\n    getAttachments() {\n        return this._transport.getAttachments();\n    }\n    getAnnotationsByType(types, pageIndexesToSkip) {\n        return this._transport.getAnnotationsByType(types, pageIndexesToSkip);\n    }\n    getJSActions() {\n        return this._transport.getDocJSActions();\n    }\n    getOutline() {\n        return this._transport.getOutline();\n    }\n    getOptionalContentConfig({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getOptionalContentConfig(renderingIntent);\n    }\n    getPermissions() {\n        return this._transport.getPermissions();\n    }\n    getMetadata() {\n        return this._transport.getMetadata();\n    }\n    getMarkInfo() {\n        return this._transport.getMarkInfo();\n    }\n    getData() {\n        return this._transport.getData();\n    }\n    saveDocument() {\n        return this._transport.saveDocument();\n    }\n    getDownloadInfo() {\n        return this._transport.downloadInfoCapability.promise;\n    }\n    cleanup(keepLoadedFonts = false) {\n        return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n    }\n    destroy() {\n        return this.loadingTask.destroy();\n    }\n    cachedPageNumber(ref) {\n        return this._transport.cachedPageNumber(ref);\n    }\n    get loadingParams() {\n        return this._transport.loadingParams;\n    }\n    get loadingTask() {\n        return this._transport.loadingTask;\n    }\n    getFieldObjects() {\n        return this._transport.getFieldObjects();\n    }\n    hasJSActions() {\n        return this._transport.hasJSActions();\n    }\n    getCalculationOrderIds() {\n        return this._transport.getCalculationOrderIds();\n    }\n}\nclass PDFPageProxy {\n    #pendingCleanup;\n    constructor(pageIndex, pageInfo, transport, pdfBug = false){\n        this.#pendingCleanup = false;\n        this._pageIndex = pageIndex;\n        this._pageInfo = pageInfo;\n        this._transport = transport;\n        this._stats = pdfBug ? new StatTimer() : null;\n        this._pdfBug = pdfBug;\n        this.commonObjs = transport.commonObjs;\n        this.objs = new PDFObjects();\n        this._intentStates = new Map();\n        this.destroyed = false;\n        this.recordedBBoxes = null;\n    }\n    get pageNumber() {\n        return this._pageIndex + 1;\n    }\n    get rotate() {\n        return this._pageInfo.rotate;\n    }\n    get ref() {\n        return this._pageInfo.ref;\n    }\n    get userUnit() {\n        return this._pageInfo.userUnit;\n    }\n    get view() {\n        return this._pageInfo.view;\n    }\n    getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.view,\n            userUnit: this.userUnit,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    getAnnotations({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getAnnotations(this._pageIndex, renderingIntent);\n    }\n    getJSActions() {\n        return this._transport.getPageJSActions(this._pageIndex);\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    async getXfa() {\n        return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n    }\n    render({ canvasContext, canvas = canvasContext.canvas, viewport, intent = \"display\", annotationMode = AnnotationMode.ENABLE, transform = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null, isEditing = false, recordOperations = false, operationsFilter = null }) {\n        this._stats?.time(\"Overall\");\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);\n        const { renderingIntent, cacheKey } = intentArgs;\n        this.#pendingCleanup = false;\n        optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);\n        let intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(cacheKey, intentState);\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        if (!intentState.displayReadyCapability) {\n            intentState.displayReadyCapability = Promise.withResolvers();\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        const recordForDebugger = Boolean(this._pdfBug && globalThis.StepperManager?.enabled);\n        const shouldRecordOperations = !this.recordedBBoxes && (recordOperations || recordForDebugger);\n        const complete = (error)=>{\n            intentState.renderTasks.delete(internalRenderTask);\n            if (shouldRecordOperations) {\n                const recordedBBoxes = internalRenderTask.gfx?.dependencyTracker.take();\n                if (recordedBBoxes) {\n                    if (internalRenderTask.stepper) {\n                        internalRenderTask.stepper.setOperatorBBoxes(recordedBBoxes, internalRenderTask.gfx.dependencyTracker.takeDebugMetadata());\n                    }\n                    if (recordOperations) {\n                        this.recordedBBoxes = recordedBBoxes;\n                    }\n                }\n            }\n            if (intentPrint) {\n                this.#pendingCleanup = true;\n            }\n            this.#tryCleanup();\n            if (error) {\n                internalRenderTask.capability.reject(error);\n                this._abortOperatorList({\n                    intentState,\n                    reason: error instanceof Error ? error : new Error(error)\n                });\n            } else {\n                internalRenderTask.capability.resolve();\n            }\n            if (this._stats) {\n                this._stats.timeEnd(\"Rendering\");\n                this._stats.timeEnd(\"Overall\");\n                if (globalThis.Stats?.enabled) {\n                    globalThis.Stats.add(this.pageNumber, this._stats);\n                }\n            }\n        };\n        const internalRenderTask = new InternalRenderTask({\n            callback: complete,\n            params: {\n                canvas,\n                canvasContext,\n                dependencyTracker: shouldRecordOperations ? new CanvasDependencyTracker(canvas, intentState.operatorList.length, recordForDebugger) : null,\n                viewport,\n                transform,\n                background\n            },\n            objs: this.objs,\n            commonObjs: this.commonObjs,\n            annotationCanvasMap,\n            operatorList: intentState.operatorList,\n            pageIndex: this._pageIndex,\n            canvasFactory: this._transport.canvasFactory,\n            filterFactory: this._transport.filterFactory,\n            useRequestAnimationFrame: !intentPrint,\n            pdfBug: this._pdfBug,\n            pageColors,\n            enableHWA: this._transport.enableHWA,\n            operationsFilter\n        });\n        (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n        const renderTask = internalRenderTask.task;\n        Promise.all([\n            intentState.displayReadyCapability.promise,\n            optionalContentConfigPromise\n        ]).then(([transparency, optionalContentConfig])=>{\n            if (this.destroyed) {\n                complete();\n                return;\n            }\n            this._stats?.time(\"Rendering\");\n            if (!(optionalContentConfig.renderingIntent & renderingIntent)) {\n                throw new Error(\"Must use the same `intent`-argument when calling the `PDFPageProxy.render` \" + \"and `PDFDocumentProxy.getOptionalContentConfig` methods.\");\n            }\n            internalRenderTask.initializeGraphics({\n                transparency,\n                optionalContentConfig\n            });\n            internalRenderTask.operatorListChanged();\n        }).catch(complete);\n        return renderTask;\n    }\n    getOperatorList({ intent = \"display\", annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false } = {}) {\n        function operatorListChanged() {\n            if (intentState.operatorList.lastChunk) {\n                intentState.opListReadCapability.resolve(intentState.operatorList);\n                intentState.renderTasks.delete(opListTask);\n            }\n        }\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);\n        let intentState = this._intentStates.get(intentArgs.cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(intentArgs.cacheKey, intentState);\n        }\n        let opListTask;\n        if (!intentState.opListReadCapability) {\n            opListTask = Object.create(null);\n            opListTask.operatorListChanged = operatorListChanged;\n            intentState.opListReadCapability = Promise.withResolvers();\n            (intentState.renderTasks ||= new Set()).add(opListTask);\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        return intentState.opListReadCapability.promise;\n    }\n    streamTextContent({ includeMarkedContent = false, disableNormalization = false } = {}) {\n        const TEXT_CONTENT_CHUNK_SIZE = 100;\n        return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n            pageIndex: this._pageIndex,\n            includeMarkedContent: includeMarkedContent === true,\n            disableNormalization: disableNormalization === true\n        }, {\n            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n            size (textContent) {\n                return textContent.items.length;\n            }\n        });\n    }\n    getTextContent(params = {}) {\n        if (this._transport._htmlForXfa) {\n            return this.getXfa().then((xfa)=>XfaText.textContent(xfa));\n        }\n        const readableStream = this.streamTextContent(params);\n        return new Promise(function(resolve, reject) {\n            function pump() {\n                reader.read().then(function({ value, done }) {\n                    if (done) {\n                        resolve(textContent);\n                        return;\n                    }\n                    textContent.lang ??= value.lang;\n                    Object.assign(textContent.styles, value.styles);\n                    textContent.items.push(...value.items);\n                    pump();\n                }, reject);\n            }\n            const reader = readableStream.getReader();\n            const textContent = {\n                items: [],\n                styles: Object.create(null),\n                lang: null\n            };\n            pump();\n        });\n    }\n    getStructTree() {\n        return this._transport.getStructTree(this._pageIndex);\n    }\n    _destroy() {\n        this.destroyed = true;\n        const waitOn = [];\n        for (const intentState of this._intentStates.values()){\n            this._abortOperatorList({\n                intentState,\n                reason: new Error(\"Page was destroyed.\"),\n                force: true\n            });\n            if (intentState.opListReadCapability) {\n                continue;\n            }\n            for (const internalRenderTask of intentState.renderTasks){\n                waitOn.push(internalRenderTask.completed);\n                internalRenderTask.cancel();\n            }\n        }\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        return Promise.all(waitOn);\n    }\n    cleanup(resetStats = false) {\n        this.#pendingCleanup = true;\n        const success = this.#tryCleanup();\n        if (resetStats && success) {\n            this._stats &&= new StatTimer();\n        }\n        return success;\n    }\n    #tryCleanup() {\n        if (!this.#pendingCleanup || this.destroyed) {\n            return false;\n        }\n        for (const { renderTasks, operatorList } of this._intentStates.values()){\n            if (renderTasks.size > 0 || !operatorList.lastChunk) {\n                return false;\n            }\n        }\n        this._intentStates.clear();\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        return true;\n    }\n    _startRenderPage(transparency, cacheKey) {\n        const intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            return;\n        }\n        this._stats?.timeEnd(\"Page Request\");\n        intentState.displayReadyCapability?.resolve(transparency);\n    }\n    _renderPageChunk(operatorListChunk, intentState) {\n        for(let i = 0, ii = operatorListChunk.length; i < ii; i++){\n            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n        }\n        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n        intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n        for (const internalRenderTask of intentState.renderTasks){\n            internalRenderTask.operatorListChanged();\n        }\n        if (operatorListChunk.lastChunk) {\n            this.#tryCleanup();\n        }\n    }\n    _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageSerializable, modifiedIds }) {\n        const { map, transfer } = annotationStorageSerializable;\n        const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n            pageIndex: this._pageIndex,\n            intent: renderingIntent,\n            cacheKey,\n            annotationStorage: map,\n            modifiedIds\n        }, transfer);\n        const reader = readableStream.getReader();\n        const intentState = this._intentStates.get(cacheKey);\n        intentState.streamReader = reader;\n        const pump = ()=>{\n            reader.read().then(({ value, done })=>{\n                if (done) {\n                    intentState.streamReader = null;\n                    return;\n                }\n                if (this._transport.destroyed) {\n                    return;\n                }\n                this._renderPageChunk(value, intentState);\n                pump();\n            }, (reason)=>{\n                intentState.streamReader = null;\n                if (this._transport.destroyed) {\n                    return;\n                }\n                if (intentState.operatorList) {\n                    intentState.operatorList.lastChunk = true;\n                    for (const internalRenderTask of intentState.renderTasks){\n                        internalRenderTask.operatorListChanged();\n                    }\n                    this.#tryCleanup();\n                }\n                if (intentState.displayReadyCapability) {\n                    intentState.displayReadyCapability.reject(reason);\n                } else if (intentState.opListReadCapability) {\n                    intentState.opListReadCapability.reject(reason);\n                } else {\n                    throw reason;\n                }\n            });\n        };\n        pump();\n    }\n    _abortOperatorList({ intentState, reason, force = false }) {\n        if (!intentState.streamReader) {\n            return;\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        if (!force) {\n            if (intentState.renderTasks.size > 0) {\n                return;\n            }\n            if (reason instanceof RenderingCancelledException) {\n                let delay = RENDERING_CANCELLED_TIMEOUT;\n                if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n                    delay += reason.extraDelay;\n                }\n                intentState.streamReaderCancelTimeout = setTimeout(()=>{\n                    intentState.streamReaderCancelTimeout = null;\n                    this._abortOperatorList({\n                        intentState,\n                        reason,\n                        force: true\n                    });\n                }, delay);\n                return;\n            }\n        }\n        intentState.streamReader.cancel(new AbortException(reason.message)).catch(()=>{});\n        intentState.streamReader = null;\n        if (this._transport.destroyed) {\n            return;\n        }\n        for (const [curCacheKey, curIntentState] of this._intentStates){\n            if (curIntentState === intentState) {\n                this._intentStates.delete(curCacheKey);\n                break;\n            }\n        }\n        this.cleanup();\n    }\n    get stats() {\n        return this._stats;\n    }\n}\nclass PDFWorker {\n    #capability;\n    #messageHandler;\n    #port;\n    #webWorker;\n    static #fakeWorkerId = 0;\n    static #isWorkerDisabled = false;\n    static #workerPorts = new WeakMap();\n    static{\n        if (isNodeJS) {\n            this.#isWorkerDisabled = true;\n            GlobalWorkerOptions.workerSrc ||= \"./pdf.worker.mjs\";\n        }\n        this._isSameOrigin = (baseUrl, otherUrl)=>{\n            const base = URL.parse(baseUrl);\n            if (!base?.origin || base.origin === \"null\") {\n                return false;\n            }\n            const other = new URL(otherUrl, base);\n            return base.origin === other.origin;\n        };\n        this._createCDNWrapper = (url)=>{\n            const wrapper = `await import(\"${url}\");`;\n            return URL.createObjectURL(new Blob([\n                wrapper\n            ], {\n                type: \"text/javascript\"\n            }));\n        };\n        this.fromPort = (params)=>{\n            deprecated(\"`PDFWorker.fromPort` - please use `PDFWorker.create` instead.\");\n            if (!params?.port) {\n                throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n            }\n            return this.create(params);\n        };\n    }\n    constructor({ name = null, port = null, verbosity = getVerbosityLevel() } = {}){\n        this.#capability = Promise.withResolvers();\n        this.#messageHandler = null;\n        this.#port = null;\n        this.#webWorker = null;\n        this.name = name;\n        this.destroyed = false;\n        this.verbosity = verbosity;\n        if (port) {\n            if (PDFWorker.#workerPorts.has(port)) {\n                throw new Error(\"Cannot use more than one PDFWorker per port.\");\n            }\n            PDFWorker.#workerPorts.set(port, this);\n            this.#initializeFromPort(port);\n        } else {\n            this.#initialize();\n        }\n    }\n    get promise() {\n        return this.#capability.promise;\n    }\n    #resolve() {\n        this.#capability.resolve();\n        this.#messageHandler.send(\"configure\", {\n            verbosity: this.verbosity\n        });\n    }\n    get port() {\n        return this.#port;\n    }\n    get messageHandler() {\n        return this.#messageHandler;\n    }\n    #initializeFromPort(port) {\n        this.#port = port;\n        this.#messageHandler = new MessageHandler(\"main\", \"worker\", port);\n        this.#messageHandler.on(\"ready\", ()=>{});\n        this.#resolve();\n    }\n    #initialize() {\n        if (PDFWorker.#isWorkerDisabled || PDFWorker.#mainThreadWorkerMessageHandler) {\n            this.#setupFakeWorker();\n            return;\n        }\n        let { workerSrc } = PDFWorker;\n        try {\n            if (!PDFWorker._isSameOrigin(window.location, workerSrc)) {\n                workerSrc = PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);\n            }\n            const worker = new Worker(workerSrc, {\n                type: \"module\"\n            });\n            const messageHandler = new MessageHandler(\"main\", \"worker\", worker);\n            const terminateEarly = ()=>{\n                ac.abort();\n                messageHandler.destroy();\n                worker.terminate();\n                if (this.destroyed) {\n                    this.#capability.reject(new Error(\"Worker was destroyed\"));\n                } else {\n                    this.#setupFakeWorker();\n                }\n            };\n            const ac = new AbortController();\n            worker.addEventListener(\"error\", ()=>{\n                if (!this.#webWorker) {\n                    terminateEarly();\n                }\n            }, {\n                signal: ac.signal\n            });\n            messageHandler.on(\"test\", (data)=>{\n                ac.abort();\n                if (this.destroyed || !data) {\n                    terminateEarly();\n                    return;\n                }\n                this.#messageHandler = messageHandler;\n                this.#port = worker;\n                this.#webWorker = worker;\n                this.#resolve();\n            });\n            messageHandler.on(\"ready\", (data)=>{\n                ac.abort();\n                if (this.destroyed) {\n                    terminateEarly();\n                    return;\n                }\n                try {\n                    sendTest();\n                } catch  {\n                    this.#setupFakeWorker();\n                }\n            });\n            const sendTest = ()=>{\n                const testObj = new Uint8Array();\n                messageHandler.send(\"test\", testObj, [\n                    testObj.buffer\n                ]);\n            };\n            sendTest();\n            return;\n        } catch  {\n            info(\"The worker has been disabled.\");\n        }\n        this.#setupFakeWorker();\n    }\n    #setupFakeWorker() {\n        if (!PDFWorker.#isWorkerDisabled) {\n            warn(\"Setting up fake worker.\");\n            PDFWorker.#isWorkerDisabled = true;\n        }\n        PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler)=>{\n            if (this.destroyed) {\n                this.#capability.reject(new Error(\"Worker was destroyed\"));\n                return;\n            }\n            const port = new LoopbackPort();\n            this.#port = port;\n            const id = `fake${PDFWorker.#fakeWorkerId++}`;\n            const workerHandler = new MessageHandler(id + \"_worker\", id, port);\n            WorkerMessageHandler.setup(workerHandler, port);\n            this.#messageHandler = new MessageHandler(id, id + \"_worker\", port);\n            this.#resolve();\n        }).catch((reason)=>{\n            this.#capability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n        });\n    }\n    destroy() {\n        this.destroyed = true;\n        this.#webWorker?.terminate();\n        this.#webWorker = null;\n        PDFWorker.#workerPorts.delete(this.#port);\n        this.#port = null;\n        this.#messageHandler?.destroy();\n        this.#messageHandler = null;\n    }\n    static create(params) {\n        const cachedPort = this.#workerPorts.get(params?.port);\n        if (cachedPort) {\n            if (cachedPort._pendingDestroy) {\n                throw new Error(\"PDFWorker.create - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n            }\n            return cachedPort;\n        }\n        return new PDFWorker(params);\n    }\n    static get workerSrc() {\n        if (GlobalWorkerOptions.workerSrc) {\n            return GlobalWorkerOptions.workerSrc;\n        }\n        throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n    }\n    static get #mainThreadWorkerMessageHandler() {\n        try {\n            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n        } catch  {\n            return null;\n        }\n    }\n    static get _setupFakeWorkerGlobal() {\n        const loader = async ()=>{\n            if (this.#mainThreadWorkerMessageHandler) {\n                return this.#mainThreadWorkerMessageHandler;\n            }\n            const worker = await import(/*webpackIgnore: true*/ /*@vite-ignore*/ this.workerSrc);\n            return worker.WorkerMessageHandler;\n        };\n        return shadow(this, \"_setupFakeWorkerGlobal\", loader());\n    }\n}\nclass WorkerTransport {\n    #methodPromises;\n    #pageCache;\n    #pagePromises;\n    #pageRefCache;\n    #passwordCapability;\n    constructor(messageHandler, loadingTask, networkStream, params, factory, enableHWA){\n        this.#methodPromises = new Map();\n        this.#pageCache = new Map();\n        this.#pagePromises = new Map();\n        this.#pageRefCache = new Map();\n        this.#passwordCapability = null;\n        this.messageHandler = messageHandler;\n        this.loadingTask = loadingTask;\n        this.commonObjs = new PDFObjects();\n        this.fontLoader = new FontLoader({\n            ownerDocument: params.ownerDocument,\n            styleElement: params.styleElement\n        });\n        this.loadingParams = params.loadingParams;\n        this._params = params;\n        this.canvasFactory = factory.canvasFactory;\n        this.filterFactory = factory.filterFactory;\n        this.cMapReaderFactory = factory.cMapReaderFactory;\n        this.standardFontDataFactory = factory.standardFontDataFactory;\n        this.wasmFactory = factory.wasmFactory;\n        this.destroyed = false;\n        this.destroyCapability = null;\n        this._networkStream = networkStream;\n        this._fullReader = null;\n        this._lastProgress = null;\n        this.downloadInfoCapability = Promise.withResolvers();\n        this.enableHWA = enableHWA;\n        this.setupMessageHandler();\n    }\n    #cacheSimpleMethod(name, data = null) {\n        const cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, data);\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    get annotationStorage() {\n        return shadow(this, \"annotationStorage\", new AnnotationStorage());\n    }\n    getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {\n        let renderingIntent = RenderingIntentFlag.DISPLAY;\n        let annotationStorageSerializable = SerializableEmpty;\n        switch(intent){\n            case \"any\":\n                renderingIntent = RenderingIntentFlag.ANY;\n                break;\n            case \"display\":\n                break;\n            case \"print\":\n                renderingIntent = RenderingIntentFlag.PRINT;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid intent: ${intent}`);\n        }\n        const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n        switch(annotationMode){\n            case AnnotationMode.DISABLE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;\n                break;\n            case AnnotationMode.ENABLE:\n                break;\n            case AnnotationMode.ENABLE_FORMS:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;\n                break;\n            case AnnotationMode.ENABLE_STORAGE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;\n                annotationStorageSerializable = annotationStorage.serializable;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n        }\n        if (isEditing) {\n            renderingIntent += RenderingIntentFlag.IS_EDITING;\n        }\n        if (isOpList) {\n            renderingIntent += RenderingIntentFlag.OPLIST;\n        }\n        const { ids: modifiedIds, hash: modifiedIdsHash } = annotationStorage.modifiedIds;\n        const cacheKeyBuf = [\n            renderingIntent,\n            annotationStorageSerializable.hash,\n            modifiedIdsHash\n        ];\n        return {\n            renderingIntent,\n            cacheKey: cacheKeyBuf.join(\"_\"),\n            annotationStorageSerializable,\n            modifiedIds\n        };\n    }\n    destroy() {\n        if (this.destroyCapability) {\n            return this.destroyCapability.promise;\n        }\n        this.destroyed = true;\n        this.destroyCapability = Promise.withResolvers();\n        this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n        const waitOn = [];\n        for (const page of this.#pageCache.values()){\n            waitOn.push(page._destroy());\n        }\n        this.#pageCache.clear();\n        this.#pagePromises.clear();\n        this.#pageRefCache.clear();\n        if (this.hasOwnProperty(\"annotationStorage\")) {\n            this.annotationStorage.resetModified();\n        }\n        const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n        waitOn.push(terminated);\n        Promise.all(waitOn).then(()=>{\n            this.commonObjs.clear();\n            this.fontLoader.clear();\n            this.#methodPromises.clear();\n            this.filterFactory.destroy();\n            TextLayer.cleanup();\n            this._networkStream?.cancelAllRequests(new AbortException(\"Worker was terminated.\"));\n            this.messageHandler?.destroy();\n            this.messageHandler = null;\n            this.destroyCapability.resolve();\n        }, this.destroyCapability.reject);\n        return this.destroyCapability.promise;\n    }\n    setupMessageHandler() {\n        const { messageHandler, loadingTask } = this;\n        messageHandler.on(\"GetReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n            this._fullReader = this._networkStream.getFullReader();\n            this._fullReader.onProgress = (evt)=>{\n                this._lastProgress = {\n                    loaded: evt.loaded,\n                    total: evt.total\n                };\n            };\n            sink.onPull = ()=>{\n                this._fullReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                this._fullReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"ReaderHeadersReady\", async (data)=>{\n            await this._fullReader.headersReady;\n            const { isStreamingSupported, isRangeSupported, contentLength } = this._fullReader;\n            if (!isStreamingSupported || !isRangeSupported) {\n                if (this._lastProgress) {\n                    loadingTask.onProgress?.(this._lastProgress);\n                }\n                this._fullReader.onProgress = (evt)=>{\n                    loadingTask.onProgress?.({\n                        loaded: evt.loaded,\n                        total: evt.total\n                    });\n                };\n            }\n            return {\n                isStreamingSupported,\n                isRangeSupported,\n                contentLength\n            };\n        });\n        messageHandler.on(\"GetRangeReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n            if (!rangeReader) {\n                sink.close();\n                return;\n            }\n            sink.onPull = ()=>{\n                rangeReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                rangeReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"GetDoc\", ({ pdfInfo })=>{\n            this._numPages = pdfInfo.numPages;\n            this._htmlForXfa = pdfInfo.htmlForXfa;\n            delete pdfInfo.htmlForXfa;\n            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n        });\n        messageHandler.on(\"DocException\", (ex)=>{\n            loadingTask._capability.reject(wrapReason(ex));\n        });\n        messageHandler.on(\"PasswordRequest\", (ex)=>{\n            this.#passwordCapability = Promise.withResolvers();\n            try {\n                if (!loadingTask.onPassword) {\n                    throw wrapReason(ex);\n                }\n                const updatePassword = (password)=>{\n                    if (password instanceof Error) {\n                        this.#passwordCapability.reject(password);\n                    } else {\n                        this.#passwordCapability.resolve({\n                            password\n                        });\n                    }\n                };\n                loadingTask.onPassword(updatePassword, ex.code);\n            } catch (err) {\n                this.#passwordCapability.reject(err);\n            }\n            return this.#passwordCapability.promise;\n        });\n        messageHandler.on(\"DataLoaded\", (data)=>{\n            loadingTask.onProgress?.({\n                loaded: data.length,\n                total: data.length\n            });\n            this.downloadInfoCapability.resolve(data);\n        });\n        messageHandler.on(\"StartRenderPage\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            const page = this.#pageCache.get(data.pageIndex);\n            page._startRenderPage(data.transparency, data.cacheKey);\n        });\n        messageHandler.on(\"commonobj\", ([id, type, exportedData])=>{\n            if (this.destroyed) {\n                return null;\n            }\n            if (this.commonObjs.has(id)) {\n                return null;\n            }\n            switch(type){\n                case \"Font\":\n                    if (\"error\" in exportedData) {\n                        const exportedError = exportedData.error;\n                        warn(`Error during font loading: ${exportedError}`);\n                        this.commonObjs.resolve(id, exportedError);\n                        break;\n                    }\n                    const fontData = new FontInfo(exportedData);\n                    const inspectFont = this._params.pdfBug && globalThis.FontInspector?.enabled ? (font, url)=>globalThis.FontInspector.fontAdded(font, url) : null;\n                    const font = new FontFaceObject(fontData, inspectFont, exportedData.extra, exportedData.charProcOperatorList);\n                    this.fontLoader.bind(font).catch(()=>messageHandler.sendWithPromise(\"FontFallback\", {\n                            id\n                        })).finally(()=>{\n                        if (!font.fontExtraProperties && font.data) {\n                            font.clearData();\n                        }\n                        this.commonObjs.resolve(id, font);\n                    });\n                    break;\n                case \"CopyLocalImage\":\n                    const { imageRef } = exportedData;\n                    assert(imageRef, \"The imageRef must be defined.\");\n                    for (const pageProxy of this.#pageCache.values()){\n                        for (const [, data] of pageProxy.objs){\n                            if (data?.ref !== imageRef) {\n                                continue;\n                            }\n                            if (!data.dataLen) {\n                                return null;\n                            }\n                            this.commonObjs.resolve(id, structuredClone(data));\n                            return data.dataLen;\n                        }\n                    }\n                    break;\n                case \"FontPath\":\n                case \"Image\":\n                case \"Pattern\":\n                    this.commonObjs.resolve(id, exportedData);\n                    break;\n                default:\n                    throw new Error(`Got unknown common object type ${type}`);\n            }\n            return null;\n        });\n        messageHandler.on(\"obj\", ([id, pageIndex, type, imageData])=>{\n            if (this.destroyed) {\n                return;\n            }\n            const pageProxy = this.#pageCache.get(pageIndex);\n            if (pageProxy.objs.has(id)) {\n                return;\n            }\n            if (pageProxy._intentStates.size === 0) {\n                imageData?.bitmap?.close();\n                return;\n            }\n            switch(type){\n                case \"Image\":\n                case \"Pattern\":\n                    pageProxy.objs.resolve(id, imageData);\n                    break;\n                default:\n                    throw new Error(`Got unknown object type ${type}`);\n            }\n        });\n        messageHandler.on(\"DocProgress\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            loadingTask.onProgress?.({\n                loaded: data.loaded,\n                total: data.total\n            });\n        });\n        messageHandler.on(\"FetchBinaryData\", async (data)=>{\n            if (this.destroyed) {\n                throw new Error(\"Worker was destroyed.\");\n            }\n            const factory = this[data.type];\n            if (!factory) {\n                throw new Error(`${data.type} not initialized, see the \\`useWorkerFetch\\` parameter.`);\n            }\n            return factory.fetch(data);\n        });\n    }\n    getData() {\n        return this.messageHandler.sendWithPromise(\"GetData\", null);\n    }\n    saveDocument() {\n        if (this.annotationStorage.size <= 0) {\n            warn(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n        }\n        const { map, transfer } = this.annotationStorage.serializable;\n        return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n            isPureXfa: !!this._htmlForXfa,\n            numPages: this._numPages,\n            annotationStorage: map,\n            filename: this._fullReader?.filename ?? null\n        }, transfer).finally(()=>{\n            this.annotationStorage.resetModified();\n        });\n    }\n    getPage(pageNumber) {\n        if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n            return Promise.reject(new Error(\"Invalid page request.\"));\n        }\n        const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n            pageIndex\n        }).then((pageInfo)=>{\n            if (this.destroyed) {\n                throw new Error(\"Transport destroyed\");\n            }\n            if (pageInfo.refStr) {\n                this.#pageRefCache.set(pageInfo.refStr, pageNumber);\n            }\n            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n            this.#pageCache.set(pageIndex, page);\n            return page;\n        });\n        this.#pagePromises.set(pageIndex, promise);\n        return promise;\n    }\n    getPageIndex(ref) {\n        if (!isRefProxy(ref)) {\n            return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n            num: ref.num,\n            gen: ref.gen\n        });\n    }\n    getAnnotations(pageIndex, intent) {\n        return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n            pageIndex,\n            intent\n        });\n    }\n    getFieldObjects() {\n        return this.#cacheSimpleMethod(\"GetFieldObjects\");\n    }\n    hasJSActions() {\n        return this.#cacheSimpleMethod(\"HasJSActions\");\n    }\n    getCalculationOrderIds() {\n        return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n    }\n    getDestinations() {\n        return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n    }\n    getDestination(id) {\n        if (typeof id !== \"string\") {\n            return Promise.reject(new Error(\"Invalid destination request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetDestination\", {\n            id\n        });\n    }\n    getPageLabels() {\n        return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n    }\n    getPageLayout() {\n        return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n    }\n    getPageMode() {\n        return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n    }\n    getViewerPreferences() {\n        return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n    }\n    getOpenAction() {\n        return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n    }\n    getAttachments() {\n        return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n    }\n    getAnnotationsByType(types, pageIndexesToSkip) {\n        return this.messageHandler.sendWithPromise(\"GetAnnotationsByType\", {\n            types,\n            pageIndexesToSkip\n        });\n    }\n    getDocJSActions() {\n        return this.#cacheSimpleMethod(\"GetDocJSActions\");\n    }\n    getPageJSActions(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n            pageIndex\n        });\n    }\n    getStructTree(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n            pageIndex\n        });\n    }\n    getOutline() {\n        return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n    }\n    getOptionalContentConfig(renderingIntent) {\n        return this.#cacheSimpleMethod(\"GetOptionalContentConfig\").then((data)=>new OptionalContentConfig(data, renderingIntent));\n    }\n    getPermissions() {\n        return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n    }\n    getMetadata() {\n        const name = \"GetMetadata\", cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, null).then((results)=>({\n                info: results[0],\n                metadata: results[1] ? new Metadata(results[1]) : null,\n                contentDispositionFilename: this._fullReader?.filename ?? null,\n                contentLength: this._fullReader?.contentLength ?? null\n            }));\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    getMarkInfo() {\n        return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n    }\n    async startCleanup(keepLoadedFonts = false) {\n        if (this.destroyed) {\n            return;\n        }\n        await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n        for (const page of this.#pageCache.values()){\n            const cleanupSuccessful = page.cleanup();\n            if (!cleanupSuccessful) {\n                throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n            }\n        }\n        this.commonObjs.clear();\n        if (!keepLoadedFonts) {\n            this.fontLoader.clear();\n        }\n        this.#methodPromises.clear();\n        this.filterFactory.destroy(true);\n        TextLayer.cleanup();\n    }\n    cachedPageNumber(ref) {\n        if (!isRefProxy(ref)) {\n            return null;\n        }\n        const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;\n        return this.#pageRefCache.get(refStr) ?? null;\n    }\n}\nclass RenderTask {\n    #internalRenderTask;\n    constructor(internalRenderTask){\n        this.#internalRenderTask = null;\n        this.onContinue = null;\n        this.onError = null;\n        this.#internalRenderTask = internalRenderTask;\n    }\n    get promise() {\n        return this.#internalRenderTask.capability.promise;\n    }\n    cancel(extraDelay = 0) {\n        this.#internalRenderTask.cancel(null, extraDelay);\n    }\n    get separateAnnots() {\n        const { separateAnnots } = this.#internalRenderTask.operatorList;\n        if (!separateAnnots) {\n            return false;\n        }\n        const { annotationCanvasMap } = this.#internalRenderTask;\n        return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n    }\n}\nclass InternalRenderTask {\n    #rAF;\n    static #canvasInUse = new WeakSet();\n    constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, filterFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null, enableHWA = false, operationsFilter = null }){\n        this.#rAF = null;\n        this.callback = callback;\n        this.params = params;\n        this.objs = objs;\n        this.commonObjs = commonObjs;\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.operatorListIdx = null;\n        this.operatorList = operatorList;\n        this._pageIndex = pageIndex;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this._pdfBug = pdfBug;\n        this.pageColors = pageColors;\n        this.running = false;\n        this.graphicsReadyCallback = null;\n        this.graphicsReady = false;\n        this._useRequestAnimationFrame = useRequestAnimationFrame === true && \"undefined\" !== \"undefined\";\n        this.cancelled = false;\n        this.capability = Promise.withResolvers();\n        this.task = new RenderTask(this);\n        this._cancelBound = this.cancel.bind(this);\n        this._continueBound = this._continue.bind(this);\n        this._scheduleNextBound = this._scheduleNext.bind(this);\n        this._nextBound = this._next.bind(this);\n        this._canvas = params.canvas;\n        this._canvasContext = params.canvas ? null : params.canvasContext;\n        this._enableHWA = enableHWA;\n        this._dependencyTracker = params.dependencyTracker;\n        this._operationsFilter = operationsFilter;\n    }\n    get completed() {\n        return this.capability.promise.catch(function() {});\n    }\n    initializeGraphics({ transparency = false, optionalContentConfig }) {\n        if (this.cancelled) {\n            return;\n        }\n        if (this._canvas) {\n            if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n                throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n            }\n            InternalRenderTask.#canvasInUse.add(this._canvas);\n        }\n        if (this._pdfBug && globalThis.StepperManager?.enabled) {\n            this.stepper = globalThis.StepperManager.create(this._pageIndex);\n            this.stepper.init(this.operatorList);\n            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n        }\n        const { viewport, transform, background, dependencyTracker } = this.params;\n        const canvasContext = this._canvasContext || this._canvas.getContext(\"2d\", {\n            alpha: false,\n            willReadFrequently: !this._enableHWA\n        });\n        this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n            optionalContentConfig\n        }, this.annotationCanvasMap, this.pageColors, dependencyTracker);\n        this.gfx.beginDrawing({\n            transform,\n            viewport,\n            transparency,\n            background\n        });\n        this.operatorListIdx = 0;\n        this.graphicsReady = true;\n        this.graphicsReadyCallback?.();\n    }\n    cancel(error = null, extraDelay = 0) {\n        this.running = false;\n        this.cancelled = true;\n        this.gfx?.endDrawing();\n        if (this.#rAF) {\n            window.cancelAnimationFrame(this.#rAF);\n            this.#rAF = null;\n        }\n        InternalRenderTask.#canvasInUse.delete(this._canvas);\n        error ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay);\n        this.callback(error);\n        this.task.onError?.(error);\n    }\n    operatorListChanged() {\n        if (!this.graphicsReady) {\n            this.graphicsReadyCallback ||= this._continueBound;\n            return;\n        }\n        this.gfx.dependencyTracker?.growOperationsCount(this.operatorList.fnArray.length);\n        this.stepper?.updateOperatorList(this.operatorList);\n        if (this.running) {\n            return;\n        }\n        this._continue();\n    }\n    _continue() {\n        this.running = true;\n        if (this.cancelled) {\n            return;\n        }\n        if (this.task.onContinue) {\n            this.task.onContinue(this._scheduleNextBound);\n        } else {\n            this._scheduleNext();\n        }\n    }\n    _scheduleNext() {\n        if (this._useRequestAnimationFrame) {\n            this.#rAF = window.requestAnimationFrame(()=>{\n                this.#rAF = null;\n                this._nextBound().catch(this._cancelBound);\n            });\n        } else {\n            Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n        }\n    }\n    async _next() {\n        if (this.cancelled) {\n            return;\n        }\n        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._operationsFilter);\n        if (this.operatorListIdx === this.operatorList.argsArray.length) {\n            this.running = false;\n            if (this.operatorList.lastChunk) {\n                this.gfx.endDrawing();\n                InternalRenderTask.#canvasInUse.delete(this._canvas);\n                this.callback();\n            }\n        }\n    }\n}\nconst version = \"5.4.296\";\nconst build = \"f56dc8601\";\n; // ./src/display/editor/color_picker.js\nclass ColorPicker {\n    #button;\n    #buttonSwatch;\n    #defaultColor;\n    #dropdown;\n    #dropdownWasFromKeyboard;\n    #isMainColorPicker;\n    #editor;\n    #eventBus;\n    #openDropdownAC;\n    #uiManager;\n    static #l10nColor = null;\n    static get _keyboardManager() {\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                ColorPicker.prototype._hideDropdownFromKeyboard\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                ColorPicker.prototype._colorSelectFromKeyboard\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"ArrowRight\",\n                    \"mac+ArrowDown\",\n                    \"mac+ArrowRight\"\n                ],\n                ColorPicker.prototype._moveToNext\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"ArrowLeft\",\n                    \"mac+ArrowUp\",\n                    \"mac+ArrowLeft\"\n                ],\n                ColorPicker.prototype._moveToPrevious\n            ],\n            [\n                [\n                    \"Home\",\n                    \"mac+Home\"\n                ],\n                ColorPicker.prototype._moveToBeginning\n            ],\n            [\n                [\n                    \"End\",\n                    \"mac+End\"\n                ],\n                ColorPicker.prototype._moveToEnd\n            ]\n        ]));\n    }\n    constructor({ editor = null, uiManager = null }){\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown = null;\n        this.#dropdownWasFromKeyboard = false;\n        this.#isMainColorPicker = false;\n        this.#editor = null;\n        this.#openDropdownAC = null;\n        this.#uiManager = null;\n        if (editor) {\n            this.#isMainColorPicker = false;\n            this.#editor = editor;\n        } else {\n            this.#isMainColorPicker = true;\n        }\n        this.#uiManager = editor?._uiManager || uiManager;\n        this.#eventBus = this.#uiManager._eventBus;\n        this.#defaultColor = editor?.color?.toUpperCase() || this.#uiManager?.highlightColors.values().next().value || \"#FFFF98\";\n        ColorPicker.#l10nColor ||= Object.freeze({\n            blue: \"pdfjs-editor-colorpicker-blue\",\n            green: \"pdfjs-editor-colorpicker-green\",\n            pink: \"pdfjs-editor-colorpicker-pink\",\n            red: \"pdfjs-editor-colorpicker-red\",\n            yellow: \"pdfjs-editor-colorpicker-yellow\"\n        });\n    }\n    renderButton() {\n        const button = this.#button = document.createElement(\"button\");\n        button.className = \"colorPicker\";\n        button.tabIndex = \"0\";\n        button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-button\");\n        button.ariaHasPopup = \"true\";\n        if (this.#editor) {\n            button.ariaControls = `${this.#editor.id}_colorpicker_dropdown`;\n        }\n        const signal = this.#uiManager._signal;\n        button.addEventListener(\"click\", this.#openDropdown.bind(this), {\n            signal\n        });\n        button.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        const swatch = this.#buttonSwatch = document.createElement(\"span\");\n        swatch.className = \"swatch\";\n        swatch.ariaHidden = \"true\";\n        swatch.style.backgroundColor = this.#defaultColor;\n        button.append(swatch);\n        return button;\n    }\n    renderMainDropdown() {\n        const dropdown = this.#dropdown = this.#getDropdownRoot();\n        dropdown.ariaOrientation = \"horizontal\";\n        dropdown.ariaLabelledBy = \"highlightColorPickerLabel\";\n        return dropdown;\n    }\n    #getDropdownRoot() {\n        const div = document.createElement(\"div\");\n        const signal = this.#uiManager._signal;\n        div.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        div.className = \"dropdown\";\n        div.role = \"listbox\";\n        div.ariaMultiSelectable = \"false\";\n        div.ariaOrientation = \"vertical\";\n        div.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-dropdown\");\n        if (this.#editor) {\n            div.id = `${this.#editor.id}_colorpicker_dropdown`;\n        }\n        for (const [name, color] of this.#uiManager.highlightColors){\n            const button = document.createElement(\"button\");\n            button.tabIndex = \"0\";\n            button.role = \"option\";\n            button.setAttribute(\"data-color\", color);\n            button.title = name;\n            button.setAttribute(\"data-l10n-id\", ColorPicker.#l10nColor[name]);\n            const swatch = document.createElement(\"span\");\n            button.append(swatch);\n            swatch.className = \"swatch\";\n            swatch.style.backgroundColor = color;\n            button.ariaSelected = color === this.#defaultColor;\n            button.addEventListener(\"click\", this.#colorSelect.bind(this, color), {\n                signal\n            });\n            div.append(button);\n        }\n        div.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        return div;\n    }\n    #colorSelect(color, event) {\n        event.stopPropagation();\n        this.#eventBus.dispatch(\"switchannotationeditorparams\", {\n            source: this,\n            type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n            value: color\n        });\n        this.updateColor(color);\n    }\n    _colorSelectFromKeyboard(event) {\n        if (event.target === this.#button) {\n            this.#openDropdown(event);\n            return;\n        }\n        const color = event.target.getAttribute(\"data-color\");\n        if (!color) {\n            return;\n        }\n        this.#colorSelect(color, event);\n    }\n    _moveToNext(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        if (event.target === this.#button) {\n            this.#dropdown.firstChild?.focus();\n            return;\n        }\n        event.target.nextSibling?.focus();\n    }\n    _moveToPrevious(event) {\n        if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {\n            if (this.#isDropdownVisible) {\n                this._hideDropdownFromKeyboard();\n            }\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n        }\n        event.target.previousSibling?.focus();\n    }\n    _moveToBeginning(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.firstChild?.focus();\n    }\n    _moveToEnd(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.lastChild?.focus();\n    }\n    #keyDown(event) {\n        ColorPicker._keyboardManager.exec(this, event);\n    }\n    #openDropdown(event) {\n        if (this.#isDropdownVisible) {\n            this.hideDropdown();\n            return;\n        }\n        this.#dropdownWasFromKeyboard = event.detail === 0;\n        if (!this.#openDropdownAC) {\n            this.#openDropdownAC = new AbortController();\n            window.addEventListener(\"pointerdown\", this.#pointerDown.bind(this), {\n                signal: this.#uiManager.combinedSignal(this.#openDropdownAC)\n            });\n        }\n        this.#button.ariaExpanded = \"true\";\n        if (this.#dropdown) {\n            this.#dropdown.classList.remove(\"hidden\");\n            return;\n        }\n        const root = this.#dropdown = this.#getDropdownRoot();\n        this.#button.append(root);\n    }\n    #pointerDown(event) {\n        if (this.#dropdown?.contains(event.target)) {\n            return;\n        }\n        this.hideDropdown();\n    }\n    hideDropdown() {\n        this.#dropdown?.classList.add(\"hidden\");\n        this.#button.ariaExpanded = \"false\";\n        this.#openDropdownAC?.abort();\n        this.#openDropdownAC = null;\n    }\n    get #isDropdownVisible() {\n        return this.#dropdown && !this.#dropdown.classList.contains(\"hidden\");\n    }\n    _hideDropdownFromKeyboard() {\n        if (this.#isMainColorPicker) {\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#editor?.unselect();\n            return;\n        }\n        this.hideDropdown();\n        this.#button.focus({\n            preventScroll: true,\n            focusVisible: this.#dropdownWasFromKeyboard\n        });\n    }\n    updateColor(color) {\n        if (this.#buttonSwatch) {\n            this.#buttonSwatch.style.backgroundColor = color;\n        }\n        if (!this.#dropdown) {\n            return;\n        }\n        const i = this.#uiManager.highlightColors.values();\n        for (const child of this.#dropdown.children){\n            child.ariaSelected = i.next().value === color.toUpperCase();\n        }\n    }\n    destroy() {\n        this.#button?.remove();\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown?.remove();\n        this.#dropdown = null;\n    }\n}\nclass BasicColorPicker {\n    #input;\n    #editor;\n    #uiManager;\n    static #l10nColor = null;\n    constructor(editor){\n        this.#input = null;\n        this.#editor = null;\n        this.#uiManager = null;\n        this.#editor = editor;\n        this.#uiManager = editor._uiManager;\n        BasicColorPicker.#l10nColor ||= Object.freeze({\n            freetext: \"pdfjs-editor-color-picker-free-text-input\",\n            ink: \"pdfjs-editor-color-picker-ink-input\"\n        });\n    }\n    renderButton() {\n        if (this.#input) {\n            return this.#input;\n        }\n        const { editorType, colorType, colorValue } = this.#editor;\n        const input = this.#input = document.createElement(\"input\");\n        input.type = \"color\";\n        input.value = colorValue || \"#000000\";\n        input.className = \"basicColorPicker\";\n        input.tabIndex = 0;\n        input.setAttribute(\"data-l10n-id\", BasicColorPicker.#l10nColor[editorType]);\n        input.addEventListener(\"input\", ()=>{\n            this.#uiManager.updateParams(colorType, input.value);\n        }, {\n            signal: this.#uiManager._signal\n        });\n        return input;\n    }\n    update(value) {\n        if (!this.#input) {\n            return;\n        }\n        this.#input.value = value;\n    }\n    destroy() {\n        this.#input?.remove();\n        this.#input = null;\n    }\n    hideDropdown() {}\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.find.js\nvar es_iterator_find = __nested_webpack_require_216482__(116);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.iterator.flat-map.js\nvar es_iterator_flat_map = __nested_webpack_require_216482__(531);\n; // ./src/shared/scripting_utils.js\nfunction makeColorComp(n) {\n    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\nfunction scaleAndClamp(x) {\n    return Math.max(0, Math.min(255, 255 * x));\n}\nclass ColorConverters {\n    static CMYK_G([c, y, m, k]) {\n        return [\n            \"G\",\n            1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)\n        ];\n    }\n    static G_CMYK([g]) {\n        return [\n            \"CMYK\",\n            0,\n            0,\n            0,\n            1 - g\n        ];\n    }\n    static G_RGB([g]) {\n        return [\n            \"RGB\",\n            g,\n            g,\n            g\n        ];\n    }\n    static G_rgb([g]) {\n        g = scaleAndClamp(g);\n        return [\n            g,\n            g,\n            g\n        ];\n    }\n    static G_HTML([g]) {\n        const G = makeColorComp(g);\n        return `#${G}${G}${G}`;\n    }\n    static RGB_G([r, g, b]) {\n        return [\n            \"G\",\n            0.3 * r + 0.59 * g + 0.11 * b\n        ];\n    }\n    static RGB_rgb(color) {\n        return color.map(scaleAndClamp);\n    }\n    static RGB_HTML(color) {\n        return `#${color.map(makeColorComp).join(\"\")}`;\n    }\n    static T_HTML() {\n        return \"#00000000\";\n    }\n    static T_rgb() {\n        return [\n            null\n        ];\n    }\n    static CMYK_RGB([c, y, m, k]) {\n        return [\n            \"RGB\",\n            1 - Math.min(1, c + k),\n            1 - Math.min(1, m + k),\n            1 - Math.min(1, y + k)\n        ];\n    }\n    static CMYK_rgb([c, y, m, k]) {\n        return [\n            scaleAndClamp(1 - Math.min(1, c + k)),\n            scaleAndClamp(1 - Math.min(1, m + k)),\n            scaleAndClamp(1 - Math.min(1, y + k))\n        ];\n    }\n    static CMYK_HTML(components) {\n        const rgb = this.CMYK_RGB(components).slice(1);\n        return this.RGB_HTML(rgb);\n    }\n    static RGB_CMYK([r, g, b]) {\n        const c = 1 - r;\n        const m = 1 - g;\n        const y = 1 - b;\n        const k = Math.min(c, m, y);\n        return [\n            \"CMYK\",\n            c,\n            m,\n            y,\n            k\n        ];\n    }\n}\nconst DateFormats = /* unused pure expression or super */ null && 0;\nconst TimeFormats = /* unused pure expression or super */ null && 0;\n; // ./src/display/svg_factory.js\nclass BaseSVGFactory {\n    create(width, height, skipDimensions = false) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid SVG dimensions\");\n        }\n        const svg = this._createSVG(\"svg:svg\");\n        svg.setAttribute(\"version\", \"1.1\");\n        if (!skipDimensions) {\n            svg.setAttribute(\"width\", `${width}px`);\n            svg.setAttribute(\"height\", `${height}px`);\n        }\n        svg.setAttribute(\"preserveAspectRatio\", \"none\");\n        svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n        return svg;\n    }\n    createElement(type) {\n        if (typeof type !== \"string\") {\n            throw new Error(\"Invalid SVG element type\");\n        }\n        return this._createSVG(type);\n    }\n    _createSVG(type) {\n        unreachable(\"Abstract method `_createSVG` called.\");\n    }\n}\nclass DOMSVGFactory extends BaseSVGFactory {\n    _createSVG(type) {\n        return document.createElementNS(SVG_NS, type);\n    }\n}\n; // ./src/display/annotation_layer.js\nconst annotation_layer_DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\nconst TIMEZONE_OFFSET = new Date().getTimezoneOffset() * 60 * 1000;\nclass AnnotationElementFactory {\n    static create(parameters) {\n        const subtype = parameters.data.annotationType;\n        switch(subtype){\n            case AnnotationType.LINK:\n                return new LinkAnnotationElement(parameters);\n            case AnnotationType.TEXT:\n                return new TextAnnotationElement(parameters);\n            case AnnotationType.WIDGET:\n                const fieldType = parameters.data.fieldType;\n                switch(fieldType){\n                    case \"Tx\":\n                        return new TextWidgetAnnotationElement(parameters);\n                    case \"Btn\":\n                        if (parameters.data.radioButton) {\n                            return new RadioButtonWidgetAnnotationElement(parameters);\n                        } else if (parameters.data.checkBox) {\n                            return new CheckboxWidgetAnnotationElement(parameters);\n                        }\n                        return new PushButtonWidgetAnnotationElement(parameters);\n                    case \"Ch\":\n                        return new ChoiceWidgetAnnotationElement(parameters);\n                    case \"Sig\":\n                        return new SignatureWidgetAnnotationElement(parameters);\n                }\n                return new WidgetAnnotationElement(parameters);\n            case AnnotationType.POPUP:\n                return new PopupAnnotationElement(parameters);\n            case AnnotationType.FREETEXT:\n                return new FreeTextAnnotationElement(parameters);\n            case AnnotationType.LINE:\n                return new LineAnnotationElement(parameters);\n            case AnnotationType.SQUARE:\n                return new SquareAnnotationElement(parameters);\n            case AnnotationType.CIRCLE:\n                return new CircleAnnotationElement(parameters);\n            case AnnotationType.POLYLINE:\n                return new PolylineAnnotationElement(parameters);\n            case AnnotationType.CARET:\n                return new CaretAnnotationElement(parameters);\n            case AnnotationType.INK:\n                return new InkAnnotationElement(parameters);\n            case AnnotationType.POLYGON:\n                return new PolygonAnnotationElement(parameters);\n            case AnnotationType.HIGHLIGHT:\n                return new HighlightAnnotationElement(parameters);\n            case AnnotationType.UNDERLINE:\n                return new UnderlineAnnotationElement(parameters);\n            case AnnotationType.SQUIGGLY:\n                return new SquigglyAnnotationElement(parameters);\n            case AnnotationType.STRIKEOUT:\n                return new StrikeOutAnnotationElement(parameters);\n            case AnnotationType.STAMP:\n                return new StampAnnotationElement(parameters);\n            case AnnotationType.FILEATTACHMENT:\n                return new FileAttachmentAnnotationElement(parameters);\n            default:\n                return new AnnotationElement(parameters);\n        }\n    }\n}\nclass AnnotationElement {\n    #updates;\n    #hasBorder;\n    #popupElement;\n    constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}){\n        this.#updates = null;\n        this.#hasBorder = false;\n        this.#popupElement = null;\n        this.isRenderable = isRenderable;\n        this.data = parameters.data;\n        this.layer = parameters.layer;\n        this.linkService = parameters.linkService;\n        this.downloadManager = parameters.downloadManager;\n        this.imageResourcesPath = parameters.imageResourcesPath;\n        this.renderForms = parameters.renderForms;\n        this.svgFactory = parameters.svgFactory;\n        this.annotationStorage = parameters.annotationStorage;\n        this.enableComment = parameters.enableComment;\n        this.enableScripting = parameters.enableScripting;\n        this.hasJSActions = parameters.hasJSActions;\n        this._fieldObjects = parameters.fieldObjects;\n        this.parent = parameters.parent;\n        if (isRenderable) {\n            this.container = this._createContainer(ignoreBorder);\n        }\n        if (createQuadrilaterals) {\n            this._createQuadrilaterals();\n        }\n    }\n    static _hasPopupData({ contentsObj, richText }) {\n        return !!(contentsObj?.str || richText?.str);\n    }\n    get _isEditable() {\n        return this.data.isEditable;\n    }\n    get hasPopupData() {\n        return AnnotationElement._hasPopupData(this.data) || this.enableComment && !!this.commentText;\n    }\n    get commentData() {\n        const { data } = this;\n        const editor = this.annotationStorage?.getEditor(data.id);\n        if (editor) {\n            return editor.getData();\n        }\n        return data;\n    }\n    get hasCommentButton() {\n        return this.enableComment && this.hasPopupElement;\n    }\n    get commentButtonPosition() {\n        const editor = this.annotationStorage?.getEditor(this.data.id);\n        if (editor) {\n            return editor.commentButtonPositionInPage;\n        }\n        const { quadPoints, inkLists, rect } = this.data;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        if (quadPoints?.length >= 8) {\n            for(let i = 0; i < quadPoints.length; i += 8){\n                if (quadPoints[i + 1] > maxY) {\n                    maxY = quadPoints[i + 1];\n                    maxX = quadPoints[i + 2];\n                } else if (quadPoints[i + 1] === maxY) {\n                    maxX = Math.max(maxX, quadPoints[i + 2]);\n                }\n            }\n            return [\n                maxX,\n                maxY\n            ];\n        }\n        if (inkLists?.length >= 1) {\n            for (const inkList of inkLists){\n                for(let i = 0, ii = inkList.length; i < ii; i += 2){\n                    if (inkList[i + 1] > maxY) {\n                        maxY = inkList[i + 1];\n                        maxX = inkList[i];\n                    } else if (inkList[i + 1] === maxY) {\n                        maxX = Math.max(maxX, inkList[i]);\n                    }\n                }\n            }\n            if (maxX !== Infinity) {\n                return [\n                    maxX,\n                    maxY\n                ];\n            }\n        }\n        if (rect) {\n            return [\n                rect[2],\n                rect[3]\n            ];\n        }\n        return null;\n    }\n    _normalizePoint(point) {\n        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.parent;\n        point[1] = view[3] - point[1] + view[1];\n        point[0] = 100 * (point[0] - pageX) / pageWidth;\n        point[1] = 100 * (point[1] - pageY) / pageHeight;\n        return point;\n    }\n    get commentText() {\n        const { data } = this;\n        return this.annotationStorage.getRawValue(`${AnnotationEditorPrefix}${data.id}`)?.popup?.contents || data.contentsObj?.str || \"\";\n    }\n    set commentText(text) {\n        const { data } = this;\n        const popup = {\n            deleted: !text,\n            contents: text || \"\"\n        };\n        if (!this.annotationStorage.updateEditor(data.id, {\n            popup\n        })) {\n            this.annotationStorage.setValue(`${AnnotationEditorPrefix}${data.id}`, {\n                id: data.id,\n                annotationType: data.annotationType,\n                pageIndex: this.parent.page._pageIndex,\n                popup,\n                popupRef: data.popupRef,\n                modificationDate: new Date()\n            });\n        }\n        if (!text) {\n            this.removePopup();\n        }\n    }\n    removePopup() {\n        (this.#popupElement?.popup || this.popup)?.remove();\n        this.#popupElement = this.popup = null;\n    }\n    updateEdited(params) {\n        if (!this.container) {\n            return;\n        }\n        if (params.rect) {\n            this.#updates ||= {\n                rect: this.data.rect.slice(0)\n            };\n        }\n        const { rect, popup: newPopup } = params;\n        if (rect) {\n            this.#setRectEdited(rect);\n        }\n        let popup = this.#popupElement?.popup || this.popup;\n        if (!popup && newPopup?.text) {\n            this._createPopup(newPopup);\n            popup = this.#popupElement.popup;\n        }\n        if (!popup) {\n            return;\n        }\n        popup.updateEdited(params);\n        if (newPopup?.deleted) {\n            popup.remove();\n            this.#popupElement = null;\n            this.popup = null;\n        }\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        this.#setRectEdited(this.#updates.rect);\n        this.#popupElement?.popup.resetEdited();\n        this.#updates = null;\n    }\n    #setRectEdited(rect) {\n        const { container: { style }, data: { rect: currentRect, rotation }, parent: { viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } } = this;\n        currentRect?.splice(0, 4, ...rect);\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;\n        if (rotation === 0) {\n            style.width = `${100 * (rect[2] - rect[0]) / pageWidth}%`;\n            style.height = `${100 * (rect[3] - rect[1]) / pageHeight}%`;\n        } else {\n            this.setRotation(rotation);\n        }\n    }\n    _createContainer(ignoreBorder) {\n        const { data, parent: { page, viewport } } = this;\n        const container = document.createElement(\"section\");\n        container.setAttribute(\"data-annotation-id\", data.id);\n        if (!(this instanceof WidgetAnnotationElement) && !(this instanceof LinkAnnotationElement)) {\n            container.tabIndex = 0;\n        }\n        const { style } = container;\n        style.zIndex = this.parent.zIndex;\n        this.parent.zIndex += 2;\n        if (data.alternativeText) {\n            container.title = data.alternativeText;\n        }\n        if (data.noRotate) {\n            container.classList.add(\"norotate\");\n        }\n        if (!data.rect || this instanceof PopupAnnotationElement) {\n            const { rotation } = data;\n            if (!data.hasOwnCanvas && rotation !== 0) {\n                this.setRotation(rotation, container);\n            }\n            return container;\n        }\n        const { width, height } = this;\n        if (!ignoreBorder && data.borderStyle.width > 0) {\n            style.borderWidth = `${data.borderStyle.width}px`;\n            const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n            const verticalRadius = data.borderStyle.verticalCornerRadius;\n            if (horizontalRadius > 0 || verticalRadius > 0) {\n                const radius = `calc(${horizontalRadius}px * var(--total-scale-factor)) / calc(${verticalRadius}px * var(--total-scale-factor))`;\n                style.borderRadius = radius;\n            } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n                const radius = `calc(${width}px * var(--total-scale-factor)) / calc(${height}px * var(--total-scale-factor))`;\n                style.borderRadius = radius;\n            }\n            switch(data.borderStyle.style){\n                case AnnotationBorderStyleType.SOLID:\n                    style.borderStyle = \"solid\";\n                    break;\n                case AnnotationBorderStyleType.DASHED:\n                    style.borderStyle = \"dashed\";\n                    break;\n                case AnnotationBorderStyleType.BEVELED:\n                    warn(\"Unimplemented border style: beveled\");\n                    break;\n                case AnnotationBorderStyleType.INSET:\n                    warn(\"Unimplemented border style: inset\");\n                    break;\n                case AnnotationBorderStyleType.UNDERLINE:\n                    style.borderBottomStyle = \"solid\";\n                    break;\n                default:\n                    break;\n            }\n            const borderColor = data.borderColor || null;\n            if (borderColor) {\n                this.#hasBorder = true;\n                style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n            } else {\n                style.borderWidth = 0;\n            }\n        }\n        const rect = Util.normalizeRect([\n            data.rect[0],\n            page.view[3] - data.rect[1] + page.view[1],\n            data.rect[2],\n            page.view[3] - data.rect[3] + page.view[1]\n        ]);\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n        const { rotation } = data;\n        if (data.hasOwnCanvas || rotation === 0) {\n            style.width = `${100 * width / pageWidth}%`;\n            style.height = `${100 * height / pageHeight}%`;\n        } else {\n            this.setRotation(rotation, container);\n        }\n        return container;\n    }\n    setRotation(angle, container = this.container) {\n        if (!this.data.rect) {\n            return;\n        }\n        const { pageWidth, pageHeight } = this.parent.viewport.rawDims;\n        let { width, height } = this;\n        if (angle % 180 !== 0) {\n            [width, height] = [\n                height,\n                width\n            ];\n        }\n        container.style.width = `${100 * width / pageWidth}%`;\n        container.style.height = `${100 * height / pageHeight}%`;\n        container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n    }\n    get _commonActions() {\n        const setColor = (jsName, styleName, event)=>{\n            const color = event.detail[jsName];\n            const colorType = color[0];\n            const colorArray = color.slice(1);\n            event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);\n            this.annotationStorage.setValue(this.data.id, {\n                [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)\n            });\n        };\n        return shadow(this, \"_commonActions\", {\n            display: (event)=>{\n                const { display } = event.detail;\n                const hidden = display % 2 === 1;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noView: hidden,\n                    noPrint: display === 1 || display === 2\n                });\n            },\n            print: (event)=>{\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: !event.detail.print\n                });\n            },\n            hidden: (event)=>{\n                const { hidden } = event.detail;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: hidden,\n                    noView: hidden\n                });\n            },\n            focus: (event)=>{\n                setTimeout(()=>event.target.focus({\n                        preventScroll: false\n                    }), 0);\n            },\n            userName: (event)=>{\n                event.target.title = event.detail.userName;\n            },\n            readonly: (event)=>{\n                event.target.disabled = event.detail.readonly;\n            },\n            required: (event)=>{\n                this._setRequired(event.target, event.detail.required);\n            },\n            bgColor: (event)=>{\n                setColor(\"bgColor\", \"backgroundColor\", event);\n            },\n            fillColor: (event)=>{\n                setColor(\"fillColor\", \"backgroundColor\", event);\n            },\n            fgColor: (event)=>{\n                setColor(\"fgColor\", \"color\", event);\n            },\n            textColor: (event)=>{\n                setColor(\"textColor\", \"color\", event);\n            },\n            borderColor: (event)=>{\n                setColor(\"borderColor\", \"borderColor\", event);\n            },\n            strokeColor: (event)=>{\n                setColor(\"strokeColor\", \"borderColor\", event);\n            },\n            rotation: (event)=>{\n                const angle = event.detail.rotation;\n                this.setRotation(angle);\n                this.annotationStorage.setValue(this.data.id, {\n                    rotation: angle\n                });\n            }\n        });\n    }\n    _dispatchEventFromSandbox(actions, jsEvent) {\n        const commonActions = this._commonActions;\n        for (const name of Object.keys(jsEvent.detail)){\n            const action = actions[name] || commonActions[name];\n            action?.(jsEvent);\n        }\n    }\n    _setDefaultPropertiesFromJS(element) {\n        if (!this.enableScripting) {\n            return;\n        }\n        const storedData = this.annotationStorage.getRawValue(this.data.id);\n        if (!storedData) {\n            return;\n        }\n        const commonActions = this._commonActions;\n        for (const [actionName, detail] of Object.entries(storedData)){\n            const action = commonActions[actionName];\n            if (action) {\n                const eventProxy = {\n                    detail: {\n                        [actionName]: detail\n                    },\n                    target: element\n                };\n                action(eventProxy);\n                delete storedData[actionName];\n            }\n        }\n    }\n    _createQuadrilaterals() {\n        if (!this.container) {\n            return;\n        }\n        const { quadPoints } = this.data;\n        if (!quadPoints) {\n            return;\n        }\n        const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x)=>Math.fround(x));\n        if (quadPoints.length === 8) {\n            const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);\n            if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n                return;\n            }\n        }\n        const { style } = this.container;\n        let svgBuffer;\n        if (this.#hasBorder) {\n            const { borderColor, borderWidth } = style;\n            style.borderWidth = 0;\n            svgBuffer = [\n                \"url('data:image/svg+xml;utf8,\",\n                `<svg xmlns=\"http://www.w3.org/2000/svg\"`,\n                ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`,\n                `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`\n            ];\n            this.container.classList.add(\"hasBorder\");\n        }\n        const width = rectTrX - rectBlX;\n        const height = rectTrY - rectBlY;\n        const { svgFactory } = this;\n        const svg = svgFactory.createElement(\"svg\");\n        svg.classList.add(\"quadrilateralsContainer\");\n        svg.setAttribute(\"width\", 0);\n        svg.setAttribute(\"height\", 0);\n        svg.role = \"none\";\n        const defs = svgFactory.createElement(\"defs\");\n        svg.append(defs);\n        const clipPath = svgFactory.createElement(\"clipPath\");\n        const id = `clippath_${this.data.id}`;\n        clipPath.setAttribute(\"id\", id);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        defs.append(clipPath);\n        for(let i = 2, ii = quadPoints.length; i < ii; i += 8){\n            const trX = quadPoints[i];\n            const trY = quadPoints[i + 1];\n            const blX = quadPoints[i + 2];\n            const blY = quadPoints[i + 3];\n            const rect = svgFactory.createElement(\"rect\");\n            const x = (blX - rectBlX) / width;\n            const y = (rectTrY - trY) / height;\n            const rectWidth = (trX - blX) / width;\n            const rectHeight = (trY - blY) / height;\n            rect.setAttribute(\"x\", x);\n            rect.setAttribute(\"y\", y);\n            rect.setAttribute(\"width\", rectWidth);\n            rect.setAttribute(\"height\", rectHeight);\n            clipPath.append(rect);\n            svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n        }\n        if (this.#hasBorder) {\n            svgBuffer.push(`</g></svg>')`);\n            style.backgroundImage = svgBuffer.join(\"\");\n        }\n        this.container.append(svg);\n        this.container.style.clipPath = `url(#${id})`;\n    }\n    _createPopup(popupData = null) {\n        const { data } = this;\n        let contentsObj, modificationDate;\n        if (popupData) {\n            contentsObj = {\n                str: popupData.text\n            };\n            modificationDate = popupData.date;\n        } else {\n            contentsObj = data.contentsObj;\n            modificationDate = data.modificationDate;\n        }\n        const popup = this.#popupElement = new PopupAnnotationElement({\n            data: {\n                color: data.color,\n                titleObj: data.titleObj,\n                modificationDate,\n                contentsObj,\n                richText: data.richText,\n                parentRect: data.rect,\n                borderStyle: 0,\n                id: `popup_${data.id}`,\n                rotation: data.rotation,\n                noRotate: true\n            },\n            linkService: this.linkService,\n            parent: this.parent,\n            elements: [\n                this\n            ]\n        });\n        if (!this.parent._commentManager) {\n            this.parent.div.append(popup.render());\n        }\n    }\n    get hasPopupElement() {\n        return !!(this.#popupElement || this.popup || this.data.popupRef);\n    }\n    get extraPopupElement() {\n        return this.#popupElement;\n    }\n    render() {\n        unreachable(\"Abstract method `AnnotationElement.render` called\");\n    }\n    _getElementsByName(name, skipId = null) {\n        const fields = [];\n        if (this._fieldObjects) {\n            const fieldObj = this._fieldObjects[name];\n            if (fieldObj) {\n                for (const { page, id, exportValues } of fieldObj){\n                    if (page === -1) {\n                        continue;\n                    }\n                    if (id === skipId) {\n                        continue;\n                    }\n                    const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n                    const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                    if (domElement && !GetElementsByNameSet.has(domElement)) {\n                        warn(`_getElementsByName - element not allowed: ${id}`);\n                        continue;\n                    }\n                    fields.push({\n                        id,\n                        exportValue,\n                        domElement\n                    });\n                }\n            }\n            return fields;\n        }\n        for (const domElement of document.getElementsByName(name)){\n            const { exportValue } = domElement;\n            const id = domElement.getAttribute(\"data-element-id\");\n            if (id === skipId) {\n                continue;\n            }\n            if (!GetElementsByNameSet.has(domElement)) {\n                continue;\n            }\n            fields.push({\n                id,\n                exportValue,\n                domElement\n            });\n        }\n        return fields;\n    }\n    show() {\n        if (this.container) {\n            this.container.hidden = false;\n        }\n        this.popup?.maybeShow();\n    }\n    hide() {\n        if (this.container) {\n            this.container.hidden = true;\n        }\n        this.popup?.forceHide();\n    }\n    getElementsToTriggerPopup() {\n        return this.container;\n    }\n    addHighlightArea() {\n        const triggers = this.getElementsToTriggerPopup();\n        if (Array.isArray(triggers)) {\n            for (const element of triggers){\n                element.classList.add(\"highlightArea\");\n            }\n        } else {\n            triggers.classList.add(\"highlightArea\");\n        }\n    }\n    _editOnDoubleClick() {\n        if (!this._isEditable) {\n            return;\n        }\n        const { annotationEditorType: mode, data: { id: editId } } = this;\n        this.container.addEventListener(\"dblclick\", ()=>{\n            this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n                source: this,\n                mode,\n                editId,\n                mustEnterInEditMode: true\n            });\n        });\n    }\n    get width() {\n        return this.data.rect[2] - this.data.rect[0];\n    }\n    get height() {\n        return this.data.rect[3] - this.data.rect[1];\n    }\n}\nclass EditorAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.editor = parameters.editor;\n    }\n    render() {\n        this.container.className = \"editorAnnotation\";\n        return this.container;\n    }\n    createOrUpdatePopup() {\n        const { editor } = this;\n        if (!editor.hasComment) {\n            return;\n        }\n        this._createPopup(editor.comment);\n        this.extraPopupElement.popup.renderCommentButton();\n    }\n    get hasCommentButton() {\n        return this.enableComment && this.editor.hasComment;\n    }\n    get commentButtonPosition() {\n        return this.editor.commentButtonPositionInPage;\n    }\n    get commentText() {\n        return this.editor.comment.text;\n    }\n    set commentText(text) {\n        this.editor.comment = text;\n        if (!text) {\n            this.removePopup();\n        }\n    }\n    get commentData() {\n        return this.editor.getData();\n    }\n    remove() {\n        this.container.remove();\n        this.container = null;\n        this.removePopup();\n    }\n}\nclass LinkAnnotationElement extends AnnotationElement {\n    constructor(parameters, options = null){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: !!options?.ignoreBorder,\n            createQuadrilaterals: true\n        });\n        this.isTooltipOnly = parameters.data.isTooltipOnly;\n    }\n    render() {\n        const { data, linkService } = this;\n        const link = document.createElement(\"a\");\n        link.setAttribute(\"data-element-id\", data.id);\n        let isBound = false;\n        if (data.url) {\n            linkService.addLinkAttributes(link, data.url, data.newWindow);\n            isBound = true;\n        } else if (data.action) {\n            this._bindNamedAction(link, data.action, data.overlaidText);\n            isBound = true;\n        } else if (data.attachment) {\n            this.#bindAttachment(link, data.attachment, data.overlaidText, data.attachmentDest);\n            isBound = true;\n        } else if (data.setOCGState) {\n            this.#bindSetOCGState(link, data.setOCGState, data.overlaidText);\n            isBound = true;\n        } else if (data.dest) {\n            this._bindLink(link, data.dest, data.overlaidText);\n            isBound = true;\n        } else {\n            if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n                this._bindJSAction(link, data);\n                isBound = true;\n            }\n            if (data.resetForm) {\n                this._bindResetFormAction(link, data.resetForm);\n                isBound = true;\n            } else if (this.isTooltipOnly && !isBound) {\n                this._bindLink(link, \"\");\n                isBound = true;\n            }\n        }\n        this.container.classList.add(\"linkAnnotation\");\n        if (isBound) {\n            this.container.append(link);\n        }\n        return this.container;\n    }\n    #setInternalLink() {\n        this.container.setAttribute(\"data-internal-link\", \"\");\n    }\n    _bindLink(link, destination, overlaidText = \"\") {\n        link.href = this.linkService.getDestinationHash(destination);\n        link.onclick = ()=>{\n            if (destination) {\n                this.linkService.goToDestination(destination);\n            }\n            return false;\n        };\n        if (destination || destination === \"\") {\n            this.#setInternalLink();\n        }\n        if (overlaidText) {\n            link.title = overlaidText;\n        }\n    }\n    _bindNamedAction(link, action, overlaidText = \"\") {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeNamedAction(action);\n            return false;\n        };\n        if (overlaidText) {\n            link.title = overlaidText;\n        }\n        this.#setInternalLink();\n    }\n    #bindAttachment(link, attachment, overlaidText = \"\", dest = null) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        if (attachment.description) {\n            link.title = attachment.description;\n        } else if (overlaidText) {\n            link.title = overlaidText;\n        }\n        link.onclick = ()=>{\n            this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    #bindSetOCGState(link, action, overlaidText = \"\") {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeSetOCGState(action);\n            return false;\n        };\n        if (overlaidText) {\n            link.title = overlaidText;\n        }\n        this.#setInternalLink();\n    }\n    _bindJSAction(link, data) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        const map = new Map([\n            [\n                \"Action\",\n                \"onclick\"\n            ],\n            [\n                \"Mouse Up\",\n                \"onmouseup\"\n            ],\n            [\n                \"Mouse Down\",\n                \"onmousedown\"\n            ]\n        ]);\n        for (const name of Object.keys(data.actions)){\n            const jsName = map.get(name);\n            if (!jsName) {\n                continue;\n            }\n            link[jsName] = ()=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: data.id,\n                        name\n                    }\n                });\n                return false;\n            };\n        }\n        if (data.overlaidText) {\n            link.title = data.overlaidText;\n        }\n        if (!link.onclick) {\n            link.onclick = ()=>false;\n        }\n        this.#setInternalLink();\n    }\n    _bindResetFormAction(link, resetForm) {\n        const otherClickAction = link.onclick;\n        if (!otherClickAction) {\n            link.href = this.linkService.getAnchorUrl(\"\");\n        }\n        this.#setInternalLink();\n        if (!this._fieldObjects) {\n            warn(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n            if (!otherClickAction) {\n                link.onclick = ()=>false;\n            }\n            return;\n        }\n        link.onclick = ()=>{\n            otherClickAction?.();\n            const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm;\n            const allFields = [];\n            if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n                const fieldIds = new Set(resetFormRefs);\n                for (const fieldName of resetFormFields){\n                    const fields = this._fieldObjects[fieldName] || [];\n                    for (const { id } of fields){\n                        fieldIds.add(id);\n                    }\n                }\n                for (const fields of Object.values(this._fieldObjects)){\n                    for (const field of fields){\n                        if (fieldIds.has(field.id) === include) {\n                            allFields.push(field);\n                        }\n                    }\n                }\n            } else {\n                for (const fields of Object.values(this._fieldObjects)){\n                    allFields.push(...fields);\n                }\n            }\n            const storage = this.annotationStorage;\n            const allIds = [];\n            for (const field of allFields){\n                const { id } = field;\n                allIds.push(id);\n                switch(field.type){\n                    case \"text\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"checkbox\":\n                    case \"radiobutton\":\n                        {\n                            const value = field.defaultValue === field.exportValues;\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"combobox\":\n                    case \"listbox\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    default:\n                        continue;\n                }\n                const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                if (!domElement) {\n                    continue;\n                } else if (!GetElementsByNameSet.has(domElement)) {\n                    warn(`_bindResetFormAction - element not allowed: ${id}`);\n                    continue;\n                }\n                domElement.dispatchEvent(new Event(\"resetform\"));\n            }\n            if (this.enableScripting) {\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: \"app\",\n                        ids: allIds,\n                        name: \"ResetForm\"\n                    }\n                });\n            }\n            return false;\n        };\n    }\n}\nclass TextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"textAnnotation\");\n        const image = document.createElement(\"img\");\n        image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n        image.setAttribute(\"data-l10n-id\", \"pdfjs-text-annotation-type\");\n        image.setAttribute(\"data-l10n-args\", JSON.stringify({\n            type: this.data.name\n        }));\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(image);\n        return this.container;\n    }\n}\nclass WidgetAnnotationElement extends AnnotationElement {\n    render() {\n        return this.container;\n    }\n    showElementAndHideCanvas(element) {\n        if (this.data.hasOwnCanvas) {\n            if (element.previousSibling?.nodeName === \"CANVAS\") {\n                element.previousSibling.hidden = true;\n            }\n            element.hidden = false;\n        }\n    }\n    _getKeyModifier(event) {\n        return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;\n    }\n    _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n        if (baseName.includes(\"mouse\")) {\n            element.addEventListener(baseName, (event)=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event),\n                        shift: event.shiftKey,\n                        modifier: this._getKeyModifier(event)\n                    }\n                });\n            });\n        } else {\n            element.addEventListener(baseName, (event)=>{\n                if (baseName === \"blur\") {\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    elementData.focused = false;\n                } else if (baseName === \"focus\") {\n                    if (elementData.focused) {\n                        return;\n                    }\n                    elementData.focused = true;\n                }\n                if (!valueGetter) {\n                    return;\n                }\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event)\n                    }\n                });\n            });\n        }\n    }\n    _setEventListeners(element, elementData, names, getter) {\n        for (const [baseName, eventName] of names){\n            if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n                if (eventName === \"Focus\" || eventName === \"Blur\") {\n                    elementData ||= {\n                        focused: false\n                    };\n                }\n                this._setEventListener(element, elementData, baseName, eventName, getter);\n                if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n                    this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n                } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n                    this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n                }\n            }\n        }\n    }\n    _setBackgroundColor(element) {\n        const color = this.data.backgroundColor || null;\n        element.style.backgroundColor = color === null ? \"transparent\" : Util.makeHexColor(color[0], color[1], color[2]);\n    }\n    _setTextStyle(element) {\n        const TEXT_ALIGNMENT = [\n            \"left\",\n            \"center\",\n            \"right\"\n        ];\n        const { fontColor } = this.data.defaultAppearanceData;\n        const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;\n        const style = element.style;\n        let computedFontSize;\n        const BORDER_SIZE = 2;\n        const roundToOneDecimal = (x)=>Math.round(10 * x) / 10;\n        if (this.data.multiLine) {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;\n            const lineHeight = height / numberOfLines;\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));\n        } else {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));\n        }\n        style.fontSize = `calc(${computedFontSize}px * var(--total-scale-factor))`;\n        style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n        if (this.data.textAlignment !== null) {\n            style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n        }\n    }\n    _setRequired(element, isRequired) {\n        if (isRequired) {\n            element.setAttribute(\"required\", true);\n        } else {\n            element.removeAttribute(\"required\");\n        }\n        element.setAttribute(\"aria-required\", isRequired);\n    }\n}\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n        super(parameters, {\n            isRenderable\n        });\n    }\n    setPropertyOnSiblings(base, key, value, keyInStorage) {\n        const storage = this.annotationStorage;\n        for (const element of this._getElementsByName(base.name, base.id)){\n            if (element.domElement) {\n                element.domElement[key] = value;\n            }\n            storage.setValue(element.id, {\n                [keyInStorage]: value\n            });\n        }\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        this.container.classList.add(\"textWidgetAnnotation\");\n        let element = null;\n        if (this.renderForms) {\n            const storedData = storage.getValue(id, {\n                value: this.data.fieldValue\n            });\n            let textContent = storedData.value || \"\";\n            const maxLen = storage.getValue(id, {\n                charLimit: this.data.maxLen\n            }).charLimit;\n            if (maxLen && textContent.length > maxLen) {\n                textContent = textContent.slice(0, maxLen);\n            }\n            let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n            if (fieldFormattedValues && this.data.comb) {\n                fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n            }\n            const elementData = {\n                userValue: textContent,\n                formattedValue: fieldFormattedValues,\n                lastCommittedValue: null,\n                commitKey: 1,\n                focused: false\n            };\n            if (this.data.multiLine) {\n                element = document.createElement(\"textarea\");\n                element.textContent = fieldFormattedValues ?? textContent;\n                if (this.data.doNotScroll) {\n                    element.style.overflowY = \"hidden\";\n                }\n            } else {\n                element = document.createElement(\"input\");\n                element.type = this.data.password ? \"password\" : \"text\";\n                element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n                if (this.data.doNotScroll) {\n                    element.style.overflowX = \"hidden\";\n                }\n            }\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n            GetElementsByNameSet.add(element);\n            element.setAttribute(\"data-element-id\", id);\n            element.disabled = this.data.readOnly;\n            element.name = this.data.fieldName;\n            element.tabIndex = 0;\n            const { datetimeFormat, datetimeType, timeStep } = this.data;\n            const hasDateOrTime = !!datetimeType && this.enableScripting;\n            if (datetimeFormat) {\n                element.title = datetimeFormat;\n            }\n            this._setRequired(element, this.data.required);\n            if (maxLen) {\n                element.maxLength = maxLen;\n            }\n            element.addEventListener(\"input\", (event)=>{\n                storage.setValue(id, {\n                    value: event.target.value\n                });\n                this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n                elementData.formattedValue = null;\n            });\n            element.addEventListener(\"resetform\", (event)=>{\n                const defaultValue = this.data.defaultFieldValue ?? \"\";\n                element.value = elementData.userValue = defaultValue;\n                elementData.formattedValue = null;\n            });\n            let blurListener = (event)=>{\n                const { formattedValue } = elementData;\n                if (formattedValue !== null && formattedValue !== undefined) {\n                    event.target.value = formattedValue;\n                }\n                event.target.scrollLeft = 0;\n            };\n            if (this.enableScripting && this.hasJSActions) {\n                element.addEventListener(\"focus\", (event)=>{\n                    if (elementData.focused) {\n                        return;\n                    }\n                    const { target } = event;\n                    if (hasDateOrTime) {\n                        target.type = datetimeType;\n                        if (timeStep) {\n                            target.step = timeStep;\n                        }\n                    }\n                    if (elementData.userValue) {\n                        const value = elementData.userValue;\n                        if (hasDateOrTime) {\n                            if (datetimeType === \"time\") {\n                                const date = new Date(value);\n                                const parts = [\n                                    date.getHours(),\n                                    date.getMinutes(),\n                                    date.getSeconds()\n                                ];\n                                target.value = parts.map((v)=>v.toString().padStart(2, \"0\")).join(\":\");\n                            } else {\n                                target.value = new Date(value - TIMEZONE_OFFSET).toISOString().split(datetimeType === \"date\" ? \"T\" : \".\", 1)[0];\n                            }\n                        } else {\n                            target.value = value;\n                        }\n                    }\n                    elementData.lastCommittedValue = target.value;\n                    elementData.commitKey = 1;\n                    if (!this.data.actions?.Focus) {\n                        elementData.focused = true;\n                    }\n                });\n                element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                    this.showElementAndHideCanvas(jsEvent.target);\n                    const actions = {\n                        value (event) {\n                            elementData.userValue = event.detail.value ?? \"\";\n                            if (!hasDateOrTime) {\n                                storage.setValue(id, {\n                                    value: elementData.userValue.toString()\n                                });\n                            }\n                            event.target.value = elementData.userValue;\n                        },\n                        formattedValue (event) {\n                            const { formattedValue } = event.detail;\n                            elementData.formattedValue = formattedValue;\n                            if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                                event.target.value = formattedValue;\n                            }\n                            const data = {\n                                formattedValue\n                            };\n                            if (hasDateOrTime) {\n                                data.value = formattedValue;\n                            }\n                            storage.setValue(id, data);\n                        },\n                        selRange (event) {\n                            event.target.setSelectionRange(...event.detail.selRange);\n                        },\n                        charLimit: (event)=>{\n                            const { charLimit } = event.detail;\n                            const { target } = event;\n                            if (charLimit === 0) {\n                                target.removeAttribute(\"maxLength\");\n                                return;\n                            }\n                            target.setAttribute(\"maxLength\", charLimit);\n                            let value = elementData.userValue;\n                            if (!value || value.length <= charLimit) {\n                                return;\n                            }\n                            value = value.slice(0, charLimit);\n                            target.value = elementData.userValue = value;\n                            storage.setValue(id, {\n                                value\n                            });\n                            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                source: this,\n                                detail: {\n                                    id,\n                                    name: \"Keystroke\",\n                                    value,\n                                    willCommit: true,\n                                    commitKey: 1,\n                                    selStart: target.selectionStart,\n                                    selEnd: target.selectionEnd\n                                }\n                            });\n                        }\n                    };\n                    this._dispatchEventFromSandbox(actions, jsEvent);\n                });\n                element.addEventListener(\"keydown\", (event)=>{\n                    elementData.commitKey = 1;\n                    let commitKey = -1;\n                    if (event.key === \"Escape\") {\n                        commitKey = 0;\n                    } else if (event.key === \"Enter\" && !this.data.multiLine) {\n                        commitKey = 2;\n                    } else if (event.key === \"Tab\") {\n                        elementData.commitKey = 3;\n                    }\n                    if (commitKey === -1) {\n                        return;\n                    }\n                    const { value } = event.target;\n                    if (elementData.lastCommittedValue === value) {\n                        return;\n                    }\n                    elementData.lastCommittedValue = value;\n                    elementData.userValue = value;\n                    this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                        source: this,\n                        detail: {\n                            id,\n                            name: \"Keystroke\",\n                            value,\n                            willCommit: true,\n                            commitKey,\n                            selStart: event.target.selectionStart,\n                            selEnd: event.target.selectionEnd\n                        }\n                    });\n                });\n                const _blurListener = blurListener;\n                blurListener = null;\n                element.addEventListener(\"blur\", (event)=>{\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    if (!this.data.actions?.Blur) {\n                        elementData.focused = false;\n                    }\n                    const { target } = event;\n                    let { value } = target;\n                    if (hasDateOrTime) {\n                        if (value && datetimeType === \"time\") {\n                            const parts = value.split(\":\").map((v)=>parseInt(v, 10));\n                            value = new Date(2000, 0, 1, parts[0], parts[1], parts[2] || 0).valueOf();\n                            target.step = \"\";\n                        } else {\n                            if (!value.includes(\"T\")) {\n                                value = `${value}T00:00`;\n                            }\n                            value = new Date(value).valueOf();\n                        }\n                        target.type = \"text\";\n                    }\n                    elementData.userValue = value;\n                    if (elementData.lastCommittedValue !== value) {\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                willCommit: true,\n                                commitKey: elementData.commitKey,\n                                selStart: event.target.selectionStart,\n                                selEnd: event.target.selectionEnd\n                            }\n                        });\n                    }\n                    _blurListener(event);\n                });\n                if (this.data.actions?.Keystroke) {\n                    element.addEventListener(\"beforeinput\", (event)=>{\n                        elementData.lastCommittedValue = null;\n                        const { data, target } = event;\n                        const { value, selectionStart, selectionEnd } = target;\n                        let selStart = selectionStart, selEnd = selectionEnd;\n                        switch(event.inputType){\n                            case \"deleteWordBackward\":\n                                {\n                                    const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                                    if (match) {\n                                        selStart -= match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteWordForward\":\n                                {\n                                    const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                                    if (match) {\n                                        selEnd += match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteContentBackward\":\n                                if (selectionStart === selectionEnd) {\n                                    selStart -= 1;\n                                }\n                                break;\n                            case \"deleteContentForward\":\n                                if (selectionStart === selectionEnd) {\n                                    selEnd += 1;\n                                }\n                                break;\n                        }\n                        event.preventDefault();\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                change: data || \"\",\n                                willCommit: false,\n                                selStart,\n                                selEnd\n                            }\n                        });\n                    });\n                }\n                this._setEventListeners(element, elementData, [\n                    [\n                        \"focus\",\n                        \"Focus\"\n                    ],\n                    [\n                        \"blur\",\n                        \"Blur\"\n                    ],\n                    [\n                        \"mousedown\",\n                        \"Mouse Down\"\n                    ],\n                    [\n                        \"mouseenter\",\n                        \"Mouse Enter\"\n                    ],\n                    [\n                        \"mouseleave\",\n                        \"Mouse Exit\"\n                    ],\n                    [\n                        \"mouseup\",\n                        \"Mouse Up\"\n                    ]\n                ], (event)=>event.target.value);\n            }\n            if (blurListener) {\n                element.addEventListener(\"blur\", blurListener);\n            }\n            if (this.data.comb) {\n                const fieldWidth = this.data.rect[2] - this.data.rect[0];\n                const combWidth = fieldWidth / maxLen;\n                element.classList.add(\"comb\");\n                element.style.letterSpacing = `calc(${combWidth}px * var(--total-scale-factor) - 1ch)`;\n            }\n        } else {\n            element = document.createElement(\"div\");\n            element.textContent = this.data.fieldValue;\n            element.style.verticalAlign = \"middle\";\n            element.style.display = \"table-cell\";\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n        }\n        this._setTextStyle(element);\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: !!parameters.data.hasOwnCanvas\n        });\n    }\n}\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.exportValue === data.fieldValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== \"Off\";\n            storage.setValue(id, {\n                value\n            });\n        }\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"checkbox\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.setAttribute(\"exportValue\", data.exportValue);\n        element.tabIndex = 0;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const checkbox of this._getElementsByName(name, id)){\n                const curChecked = checked && checkbox.exportValue === data.exportValue;\n                if (checkbox.domElement) {\n                    checkbox.domElement.checked = curChecked;\n                }\n                storage.setValue(checkbox.id, {\n                    value: curChecked\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue || \"Off\";\n            event.target.checked = defaultValue === data.exportValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        event.target.checked = event.detail.value !== \"Off\";\n                        storage.setValue(id, {\n                            value: event.target.checked\n                        });\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.fieldValue === data.buttonValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== data.buttonValue;\n            storage.setValue(id, {\n                value\n            });\n        }\n        if (value) {\n            for (const radio of this._getElementsByName(data.fieldName, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n        }\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"radio\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.tabIndex = 0;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const radio of this._getElementsByName(name, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue;\n            event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            const pdfButtonValue = data.buttonValue;\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value: (event)=>{\n                        const checked = pdfButtonValue === event.detail.value;\n                        for (const radio of this._getElementsByName(event.target.name)){\n                            const curChecked = checked && radio.id === id;\n                            if (radio.domElement) {\n                                radio.domElement.checked = curChecked;\n                            }\n                            storage.setValue(radio.id, {\n                                value: curChecked\n                            });\n                        }\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            ignoreBorder: parameters.data.hasAppearance\n        });\n    }\n    render() {\n        const container = super.render();\n        container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n        const linkElement = container.lastChild;\n        if (this.enableScripting && this.hasJSActions && linkElement) {\n            this._setDefaultPropertiesFromJS(linkElement);\n            linkElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                this._dispatchEventFromSandbox({}, jsEvent);\n            });\n        }\n        return container;\n    }\n}\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"choiceWidgetAnnotation\");\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        const storedData = storage.getValue(id, {\n            value: this.data.fieldValue\n        });\n        const selectElement = document.createElement(\"select\");\n        GetElementsByNameSet.add(selectElement);\n        selectElement.setAttribute(\"data-element-id\", id);\n        selectElement.disabled = this.data.readOnly;\n        this._setRequired(selectElement, this.data.required);\n        selectElement.name = this.data.fieldName;\n        selectElement.tabIndex = 0;\n        let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n        if (!this.data.combo) {\n            selectElement.size = this.data.options.length;\n            if (this.data.multiSelect) {\n                selectElement.multiple = true;\n            }\n        }\n        selectElement.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = this.data.defaultFieldValue;\n            for (const option of selectElement.options){\n                option.selected = option.value === defaultValue;\n            }\n        });\n        for (const option of this.data.options){\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = option.displayValue;\n            optionElement.value = option.exportValue;\n            if (storedData.value.includes(option.exportValue)) {\n                optionElement.setAttribute(\"selected\", true);\n                addAnEmptyEntry = false;\n            }\n            selectElement.append(optionElement);\n        }\n        let removeEmptyEntry = null;\n        if (addAnEmptyEntry) {\n            const noneOptionElement = document.createElement(\"option\");\n            noneOptionElement.value = \" \";\n            noneOptionElement.setAttribute(\"hidden\", true);\n            noneOptionElement.setAttribute(\"selected\", true);\n            selectElement.prepend(noneOptionElement);\n            removeEmptyEntry = ()=>{\n                noneOptionElement.remove();\n                selectElement.removeEventListener(\"input\", removeEmptyEntry);\n                removeEmptyEntry = null;\n            };\n            selectElement.addEventListener(\"input\", removeEmptyEntry);\n        }\n        const getValue = (isExport)=>{\n            const name = isExport ? \"value\" : \"textContent\";\n            const { options, multiple } = selectElement;\n            if (!multiple) {\n                return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n            }\n            return Array.prototype.filter.call(options, (option)=>option.selected).map((option)=>option[name]);\n        };\n        let selectedValues = getValue(false);\n        const getItems = (event)=>{\n            const options = event.target.options;\n            return Array.prototype.map.call(options, (option)=>({\n                    displayValue: option.textContent,\n                    exportValue: option.value\n                }));\n        };\n        if (this.enableScripting && this.hasJSActions) {\n            selectElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        removeEmptyEntry?.();\n                        const value = event.detail.value;\n                        const values = new Set(Array.isArray(value) ? value : [\n                            value\n                        ]);\n                        for (const option of selectElement.options){\n                            option.selected = values.has(option.value);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    multipleSelection (event) {\n                        selectElement.multiple = true;\n                    },\n                    remove (event) {\n                        const options = selectElement.options;\n                        const index = event.detail.remove;\n                        options[index].selected = false;\n                        selectElement.remove(index);\n                        if (options.length > 0) {\n                            const i = Array.prototype.findIndex.call(options, (option)=>option.selected);\n                            if (i === -1) {\n                                options[0].selected = true;\n                            }\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    clear (event) {\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        storage.setValue(id, {\n                            value: null,\n                            items: []\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    insert (event) {\n                        const { index, displayValue, exportValue } = event.detail.insert;\n                        const selectChild = selectElement.children[index];\n                        const optionElement = document.createElement(\"option\");\n                        optionElement.textContent = displayValue;\n                        optionElement.value = exportValue;\n                        if (selectChild) {\n                            selectChild.before(optionElement);\n                        } else {\n                            selectElement.append(optionElement);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    items (event) {\n                        const { items } = event.detail;\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        for (const item of items){\n                            const { displayValue, exportValue } = item;\n                            const optionElement = document.createElement(\"option\");\n                            optionElement.textContent = displayValue;\n                            optionElement.value = exportValue;\n                            selectElement.append(optionElement);\n                        }\n                        if (selectElement.options.length > 0) {\n                            selectElement.options[0].selected = true;\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    indices (event) {\n                        const indices = new Set(event.detail.indices);\n                        for (const option of event.target.options){\n                            option.selected = indices.has(option.index);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    editable (event) {\n                        event.target.disabled = !event.detail.editable;\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            selectElement.addEventListener(\"input\", (event)=>{\n                const exportValue = getValue(true);\n                const change = getValue(false);\n                storage.setValue(id, {\n                    value: exportValue\n                });\n                event.preventDefault();\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id,\n                        name: \"Keystroke\",\n                        value: selectedValues,\n                        change,\n                        changeEx: exportValue,\n                        willCommit: false,\n                        commitKey: 1,\n                        keyDown: false\n                    }\n                });\n            });\n            this._setEventListeners(selectElement, null, [\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ],\n                [\n                    \"input\",\n                    \"Action\"\n                ],\n                [\n                    \"input\",\n                    \"Validate\"\n                ]\n            ], (event)=>event.target.value);\n        } else {\n            selectElement.addEventListener(\"input\", function(event) {\n                storage.setValue(id, {\n                    value: getValue(true)\n                });\n            });\n        }\n        if (this.data.combo) {\n            this._setTextStyle(selectElement);\n        } else {}\n        this._setBackgroundColor(selectElement);\n        this._setDefaultPropertiesFromJS(selectElement);\n        this.container.append(selectElement);\n        return this.container;\n    }\n}\nclass PopupAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        const { data, elements, parent } = parameters;\n        const hasCommentManager = !!parent._commentManager;\n        super(parameters, {\n            isRenderable: !hasCommentManager && AnnotationElement._hasPopupData(data)\n        });\n        this.elements = elements;\n        if (hasCommentManager && AnnotationElement._hasPopupData(data)) {\n            const popup = this.popup = this.#createPopup();\n            for (const element of elements){\n                element.popup = popup;\n            }\n        } else {\n            this.popup = null;\n        }\n    }\n    #createPopup() {\n        return new PopupElement({\n            container: this.container,\n            color: this.data.color,\n            titleObj: this.data.titleObj,\n            modificationDate: this.data.modificationDate || this.data.creationDate,\n            contentsObj: this.data.contentsObj,\n            richText: this.data.richText,\n            rect: this.data.rect,\n            parentRect: this.data.parentRect || null,\n            parent: this.parent,\n            elements: this.elements,\n            open: this.data.open,\n            commentManager: this.parent._commentManager\n        });\n    }\n    render() {\n        const { container } = this;\n        container.classList.add(\"popupAnnotation\");\n        container.role = \"comment\";\n        const popup = this.popup = this.#createPopup();\n        const elementIds = [];\n        for (const element of this.elements){\n            element.popup = popup;\n            element.container.ariaHasPopup = \"dialog\";\n            elementIds.push(element.data.id);\n            element.addHighlightArea();\n        }\n        this.container.setAttribute(\"aria-controls\", elementIds.map((id)=>`${AnnotationPrefix}${id}`).join(\",\"));\n        return this.container;\n    }\n}\nclass PopupElement {\n    #commentManager;\n    #boundKeyDown;\n    #boundHide;\n    #boundShow;\n    #boundToggle;\n    #color;\n    #container;\n    #contentsObj;\n    #dateObj;\n    #elements;\n    #parent;\n    #parentRect;\n    #pinned;\n    #popup;\n    #popupAbortController;\n    #position;\n    #commentButton;\n    #commentButtonPosition;\n    #popupPosition;\n    #rect;\n    #richText;\n    #titleObj;\n    #updates;\n    #wasVisible;\n    #firstElement;\n    #commentText;\n    constructor({ container, color, elements, titleObj, modificationDate, contentsObj, richText, parent, rect, parentRect, open, commentManager = null }){\n        this.#commentManager = null;\n        this.#boundKeyDown = this.#keyDown.bind(this);\n        this.#boundHide = this.#hide.bind(this);\n        this.#boundShow = this.#show.bind(this);\n        this.#boundToggle = this.#toggle.bind(this);\n        this.#color = null;\n        this.#container = null;\n        this.#contentsObj = null;\n        this.#dateObj = null;\n        this.#elements = null;\n        this.#parent = null;\n        this.#parentRect = null;\n        this.#pinned = false;\n        this.#popup = null;\n        this.#popupAbortController = null;\n        this.#position = null;\n        this.#commentButton = null;\n        this.#commentButtonPosition = null;\n        this.#popupPosition = null;\n        this.#rect = null;\n        this.#richText = null;\n        this.#titleObj = null;\n        this.#updates = null;\n        this.#wasVisible = false;\n        this.#firstElement = null;\n        this.#commentText = null;\n        this.#container = container;\n        this.#titleObj = titleObj;\n        this.#contentsObj = contentsObj;\n        this.#richText = richText;\n        this.#parent = parent;\n        this.#color = color;\n        this.#rect = rect;\n        this.#parentRect = parentRect;\n        this.#elements = elements;\n        this.#commentManager = commentManager;\n        this.#firstElement = elements[0];\n        this.#dateObj = PDFDateString.toDateObject(modificationDate);\n        this.trigger = elements.flatMap((e)=>e.getElementsToTriggerPopup());\n        if (commentManager) {\n            this.renderCommentButton();\n        } else {\n            this.#addEventListeners();\n            this.#container.hidden = true;\n            if (open) {\n                this.#toggle();\n            }\n        }\n    }\n    #addEventListeners() {\n        if (this.#popupAbortController) {\n            return;\n        }\n        this.#popupAbortController = new AbortController();\n        const { signal } = this.#popupAbortController;\n        for (const element of this.trigger){\n            element.addEventListener(\"click\", this.#boundToggle, {\n                signal\n            });\n            element.addEventListener(\"pointerenter\", this.#boundShow, {\n                signal\n            });\n            element.addEventListener(\"pointerleave\", this.#boundHide, {\n                signal\n            });\n            element.classList.add(\"popupTriggerArea\");\n        }\n        for (const element of this.#elements){\n            element.container?.addEventListener(\"keydown\", this.#boundKeyDown, {\n                signal\n            });\n        }\n    }\n    #setCommentButtonPosition() {\n        const element = this.#elements.find((e)=>e.hasCommentButton);\n        if (!element) {\n            return;\n        }\n        this.#commentButtonPosition = element._normalizePoint(element.commentButtonPosition);\n    }\n    renderCommentButton() {\n        if (this.#commentButton) {\n            return;\n        }\n        if (!this.#commentButtonPosition) {\n            this.#setCommentButtonPosition();\n        }\n        if (!this.#commentButtonPosition) {\n            return;\n        }\n        const { signal } = this.#popupAbortController = new AbortController();\n        const hasOwnButton = !!this.#firstElement.extraPopupElement;\n        const togglePopup = ()=>{\n            this.#commentManager.toggleCommentPopup(this, true, undefined, !hasOwnButton);\n        };\n        const showPopup = ()=>{\n            this.#commentManager.toggleCommentPopup(this, false, true, !hasOwnButton);\n        };\n        const hidePopup = ()=>{\n            this.#commentManager.toggleCommentPopup(this, false, false);\n        };\n        if (!hasOwnButton) {\n            const button = this.#commentButton = document.createElement(\"button\");\n            button.className = \"annotationCommentButton\";\n            const parentContainer = this.#firstElement.container;\n            button.style.zIndex = parentContainer.style.zIndex + 1;\n            button.tabIndex = 0;\n            button.ariaHasPopup = \"dialog\";\n            button.ariaControls = \"commentPopup\";\n            button.setAttribute(\"data-l10n-id\", \"pdfjs-show-comment-button\");\n            this.#updateColor();\n            this.#updateCommentButtonPosition();\n            button.addEventListener(\"keydown\", this.#boundKeyDown, {\n                signal\n            });\n            button.addEventListener(\"click\", togglePopup, {\n                signal\n            });\n            button.addEventListener(\"pointerenter\", showPopup, {\n                signal\n            });\n            button.addEventListener(\"pointerleave\", hidePopup, {\n                signal\n            });\n            parentContainer.after(button);\n        } else {\n            this.#commentButton = this.#firstElement.container;\n            for (const element of this.trigger){\n                element.ariaHasPopup = \"dialog\";\n                element.ariaControls = \"commentPopup\";\n                element.addEventListener(\"keydown\", this.#boundKeyDown, {\n                    signal\n                });\n                element.addEventListener(\"click\", togglePopup, {\n                    signal\n                });\n                element.addEventListener(\"pointerenter\", showPopup, {\n                    signal\n                });\n                element.addEventListener(\"pointerleave\", hidePopup, {\n                    signal\n                });\n                element.classList.add(\"popupTriggerArea\");\n            }\n        }\n    }\n    #updateCommentButtonPosition() {\n        if (this.#firstElement.extraPopupElement && !this.#firstElement.editor) {\n            return;\n        }\n        this.renderCommentButton();\n        const [x, y] = this.#commentButtonPosition;\n        const { style } = this.#commentButton;\n        style.left = `calc(${x}%)`;\n        style.top = `calc(${y}% - var(--comment-button-dim))`;\n    }\n    #updateColor() {\n        if (this.#firstElement.extraPopupElement) {\n            return;\n        }\n        this.renderCommentButton();\n        this.#commentButton.style.backgroundColor = this.commentButtonColor || \"\";\n    }\n    get commentButtonColor() {\n        const { color, opacity } = this.#firstElement.commentData;\n        if (!color) {\n            return null;\n        }\n        return this.#parent._commentManager.makeCommentColor(color, opacity);\n    }\n    focusCommentButton() {\n        setTimeout(()=>{\n            this.#commentButton?.focus();\n        }, 0);\n    }\n    getData() {\n        const { richText, color, opacity, creationDate, modificationDate } = this.#firstElement.commentData;\n        return {\n            contentsObj: {\n                str: this.comment\n            },\n            richText,\n            color,\n            opacity,\n            creationDate,\n            modificationDate\n        };\n    }\n    get elementBeforePopup() {\n        return this.#commentButton;\n    }\n    get comment() {\n        this.#commentText ||= this.#firstElement.commentText;\n        return this.#commentText;\n    }\n    set comment(text) {\n        if (text === this.comment) {\n            return;\n        }\n        this.#firstElement.commentText = this.#commentText = text;\n    }\n    get parentBoundingClientRect() {\n        return this.#firstElement.layer.getBoundingClientRect();\n    }\n    setCommentButtonStates({ selected, hasPopup }) {\n        if (!this.#commentButton) {\n            return;\n        }\n        this.#commentButton.classList.toggle(\"selected\", selected);\n        this.#commentButton.ariaExpanded = hasPopup;\n    }\n    setSelectedCommentButton(selected) {\n        this.#commentButton.classList.toggle(\"selected\", selected);\n    }\n    get commentPopupPosition() {\n        if (this.#popupPosition) {\n            return this.#popupPosition;\n        }\n        const { x, y, height } = this.#commentButton.getBoundingClientRect();\n        const { x: parentX, y: parentY, width: parentWidth, height: parentHeight } = this.#firstElement.layer.getBoundingClientRect();\n        return [\n            (x - parentX) / parentWidth,\n            (y + height - parentY) / parentHeight\n        ];\n    }\n    set commentPopupPosition(pos) {\n        this.#popupPosition = pos;\n    }\n    hasDefaultPopupPosition() {\n        return this.#popupPosition === null;\n    }\n    get commentButtonPosition() {\n        return this.#commentButtonPosition;\n    }\n    get commentButtonWidth() {\n        return this.#commentButton.getBoundingClientRect().width / this.parentBoundingClientRect.width;\n    }\n    editComment(options) {\n        const [posX, posY] = this.#popupPosition || this.commentButtonPosition.map((x)=>x / 100);\n        const parentDimensions = this.parentBoundingClientRect;\n        const { x: parentX, y: parentY, width: parentWidth, height: parentHeight } = parentDimensions;\n        this.#commentManager.showDialog(null, this, parentX + posX * parentWidth, parentY + posY * parentHeight, {\n            ...options,\n            parentDimensions\n        });\n    }\n    render() {\n        if (this.#popup) {\n            return;\n        }\n        const popup = this.#popup = document.createElement(\"div\");\n        popup.className = \"popup\";\n        if (this.#color) {\n            const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);\n            popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n        }\n        const header = document.createElement(\"span\");\n        header.className = \"header\";\n        if (this.#titleObj?.str) {\n            const title = document.createElement(\"span\");\n            title.className = \"title\";\n            header.append(title);\n            ({ dir: title.dir, str: title.textContent } = this.#titleObj);\n        }\n        popup.append(header);\n        if (this.#dateObj) {\n            const modificationDate = document.createElement(\"time\");\n            modificationDate.className = \"popupDate\";\n            modificationDate.setAttribute(\"data-l10n-id\", \"pdfjs-annotation-date-time-string\");\n            modificationDate.setAttribute(\"data-l10n-args\", JSON.stringify({\n                dateObj: this.#dateObj.valueOf()\n            }));\n            modificationDate.dateTime = this.#dateObj.toISOString();\n            header.append(modificationDate);\n        }\n        renderRichText({\n            html: this.#html || this.#contentsObj.str,\n            dir: this.#contentsObj?.dir,\n            className: \"popupContent\"\n        }, popup);\n        this.#container.append(popup);\n    }\n    get #html() {\n        const richText = this.#richText;\n        const contentsObj = this.#contentsObj;\n        if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n            return this.#richText.html || null;\n        }\n        return null;\n    }\n    get #fontSize() {\n        return this.#html?.attributes?.style?.fontSize || 0;\n    }\n    get #fontColor() {\n        return this.#html?.attributes?.style?.color || null;\n    }\n    #makePopupContent(text) {\n        const popupLines = [];\n        const popupContent = {\n            str: text,\n            html: {\n                name: \"div\",\n                attributes: {\n                    dir: \"auto\"\n                },\n                children: [\n                    {\n                        name: \"p\",\n                        children: popupLines\n                    }\n                ]\n            }\n        };\n        const lineAttributes = {\n            style: {\n                color: this.#fontColor,\n                fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--total-scale-factor))` : \"\"\n            }\n        };\n        for (const line of text.split(\"\\n\")){\n            popupLines.push({\n                name: \"span\",\n                value: line,\n                attributes: lineAttributes\n            });\n        }\n        return popupContent;\n    }\n    #keyDown(event) {\n        if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n            return;\n        }\n        if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n            this.#toggle();\n        }\n    }\n    updateEdited({ rect, popup, deleted }) {\n        if (this.#commentManager) {\n            if (deleted) {\n                this.remove();\n                this.#commentText = null;\n            } else if (popup) {\n                if (popup.deleted) {\n                    this.remove();\n                } else {\n                    this.#updateColor();\n                    this.#commentText = popup.text;\n                }\n            }\n            if (rect) {\n                this.#commentButtonPosition = null;\n                this.#setCommentButtonPosition();\n                this.#updateCommentButtonPosition();\n            }\n            return;\n        }\n        if (deleted || popup?.deleted) {\n            this.remove();\n            return;\n        }\n        this.#addEventListeners();\n        this.#updates ||= {\n            contentsObj: this.#contentsObj,\n            richText: this.#richText\n        };\n        if (rect) {\n            this.#position = null;\n        }\n        if (popup && popup.text) {\n            this.#richText = this.#makePopupContent(popup.text);\n            this.#dateObj = PDFDateString.toDateObject(popup.date);\n            this.#contentsObj = null;\n        }\n        this.#popup?.remove();\n        this.#popup = null;\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        ({ contentsObj: this.#contentsObj, richText: this.#richText } = this.#updates);\n        this.#updates = null;\n        this.#popup?.remove();\n        this.#popup = null;\n        this.#position = null;\n    }\n    remove() {\n        this.#popupAbortController?.abort();\n        this.#popupAbortController = null;\n        this.#popup?.remove();\n        this.#popup = null;\n        this.#wasVisible = false;\n        this.#pinned = false;\n        this.#commentButton?.remove();\n        this.#commentButton = null;\n        if (this.trigger) {\n            for (const element of this.trigger){\n                element.classList.remove(\"popupTriggerArea\");\n            }\n        }\n    }\n    #setPosition() {\n        if (this.#position !== null) {\n            return;\n        }\n        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.#parent;\n        let useParentRect = !!this.#parentRect;\n        let rect = useParentRect ? this.#parentRect : this.#rect;\n        for (const element of this.#elements){\n            if (!rect || Util.intersect(element.data.rect, rect) !== null) {\n                rect = element.data.rect;\n                useParentRect = true;\n                break;\n            }\n        }\n        const normalizedRect = Util.normalizeRect([\n            rect[0],\n            view[3] - rect[1] + view[1],\n            rect[2],\n            view[3] - rect[3] + view[1]\n        ]);\n        const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n        const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n        const popupLeft = normalizedRect[0] + parentWidth;\n        const popupTop = normalizedRect[1];\n        this.#position = [\n            100 * (popupLeft - pageX) / pageWidth,\n            100 * (popupTop - pageY) / pageHeight\n        ];\n        const { style } = this.#container;\n        style.left = `${this.#position[0]}%`;\n        style.top = `${this.#position[1]}%`;\n    }\n    #toggle() {\n        if (this.#commentManager) {\n            this.#commentManager.toggleCommentPopup(this, false);\n            return;\n        }\n        this.#pinned = !this.#pinned;\n        if (this.#pinned) {\n            this.#show();\n            this.#container.addEventListener(\"click\", this.#boundToggle);\n            this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n        } else {\n            this.#hide();\n            this.#container.removeEventListener(\"click\", this.#boundToggle);\n            this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n        }\n    }\n    #show() {\n        if (!this.#popup) {\n            this.render();\n        }\n        if (!this.isVisible) {\n            this.#setPosition();\n            this.#container.hidden = false;\n            this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n        } else if (this.#pinned) {\n            this.#container.classList.add(\"focused\");\n        }\n    }\n    #hide() {\n        this.#container.classList.remove(\"focused\");\n        if (this.#pinned || !this.isVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n    }\n    forceHide() {\n        this.#wasVisible = this.isVisible;\n        if (!this.#wasVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n    }\n    maybeShow() {\n        if (this.#commentManager) {\n            return;\n        }\n        this.#addEventListeners();\n        if (!this.#wasVisible) {\n            return;\n        }\n        if (!this.#popup) {\n            this.#show();\n        }\n        this.#wasVisible = false;\n        this.#container.hidden = false;\n    }\n    get isVisible() {\n        if (this.#commentManager) {\n            return false;\n        }\n        return this.#container.hidden === false;\n    }\n}\nclass FreeTextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.textContent = parameters.data.textContent;\n        this.textPosition = parameters.data.textPosition;\n        this.annotationEditorType = AnnotationEditorType.FREETEXT;\n    }\n    render() {\n        this.container.classList.add(\"freeTextAnnotation\");\n        if (this.textContent) {\n            const content = document.createElement(\"div\");\n            content.classList.add(\"annotationTextContent\");\n            content.setAttribute(\"role\", \"comment\");\n            for (const line of this.textContent){\n                const lineSpan = document.createElement(\"span\");\n                lineSpan.textContent = line;\n                content.append(lineSpan);\n            }\n            this.container.append(content);\n        }\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass LineAnnotationElement extends AnnotationElement {\n    #line;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#line = null;\n    }\n    render() {\n        this.container.classList.add(\"lineAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n        line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n        line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n        line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n        line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n        line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n        line.setAttribute(\"stroke\", \"transparent\");\n        line.setAttribute(\"fill\", \"transparent\");\n        svg.append(line);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#line;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass SquareAnnotationElement extends AnnotationElement {\n    #square;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#square = null;\n    }\n    render() {\n        this.container.classList.add(\"squareAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n        square.setAttribute(\"x\", borderWidth / 2);\n        square.setAttribute(\"y\", borderWidth / 2);\n        square.setAttribute(\"width\", width - borderWidth);\n        square.setAttribute(\"height\", height - borderWidth);\n        square.setAttribute(\"stroke-width\", borderWidth || 1);\n        square.setAttribute(\"stroke\", \"transparent\");\n        square.setAttribute(\"fill\", \"transparent\");\n        svg.append(square);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#square;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass CircleAnnotationElement extends AnnotationElement {\n    #circle;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#circle = null;\n    }\n    render() {\n        this.container.classList.add(\"circleAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n        circle.setAttribute(\"cx\", width / 2);\n        circle.setAttribute(\"cy\", height / 2);\n        circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n        circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n        circle.setAttribute(\"stroke-width\", borderWidth || 1);\n        circle.setAttribute(\"stroke\", \"transparent\");\n        circle.setAttribute(\"fill\", \"transparent\");\n        svg.append(circle);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#circle;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolylineAnnotationElement extends AnnotationElement {\n    #polyline;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polyline = null;\n        this.containerClassName = \"polylineAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, vertices, borderStyle, popupRef }, width, height } = this;\n        if (!vertices) {\n            return this.container;\n        }\n        const svg = this.svgFactory.create(width, height, true);\n        let points = [];\n        for(let i = 0, ii = vertices.length; i < ii; i += 2){\n            const x = vertices[i] - rect[0];\n            const y = rect[3] - vertices[i + 1];\n            points.push(`${x},${y}`);\n        }\n        points = points.join(\" \");\n        const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n        polyline.setAttribute(\"points\", points);\n        polyline.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        polyline.setAttribute(\"stroke\", \"transparent\");\n        polyline.setAttribute(\"fill\", \"transparent\");\n        svg.append(polyline);\n        this.container.append(svg);\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#polyline;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n    constructor(parameters){\n        super(parameters);\n        this.containerClassName = \"polygonAnnotation\";\n        this.svgElementName = \"svg:polygon\";\n    }\n}\nclass CaretAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"caretAnnotation\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n}\nclass InkAnnotationElement extends AnnotationElement {\n    #polylinesGroupElement;\n    #polylines;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polylinesGroupElement = null;\n        this.#polylines = [];\n        this.containerClassName = \"inkAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n        this.annotationEditorType = this.data.it === \"InkHighlight\" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;\n    }\n    #getTransform(rotation, rect) {\n        switch(rotation){\n            case 90:\n                return {\n                    transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            case 180:\n                return {\n                    transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n            case 270:\n                return {\n                    transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            default:\n                return {\n                    transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n        }\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, rotation, inkLists, borderStyle, popupRef } } = this;\n        const { transform, width, height } = this.#getTransform(rotation, rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const g = this.#polylinesGroupElement = this.svgFactory.createElement(\"svg:g\");\n        svg.append(g);\n        g.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        g.setAttribute(\"stroke-linecap\", \"round\");\n        g.setAttribute(\"stroke-linejoin\", \"round\");\n        g.setAttribute(\"stroke-miterlimit\", 10);\n        g.setAttribute(\"stroke\", \"transparent\");\n        g.setAttribute(\"fill\", \"transparent\");\n        g.setAttribute(\"transform\", transform);\n        for(let i = 0, ii = inkLists.length; i < ii; i++){\n            const polyline = this.svgFactory.createElement(this.svgElementName);\n            this.#polylines.push(polyline);\n            polyline.setAttribute(\"points\", inkLists[i].join(\",\"));\n            g.append(polyline);\n        }\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(svg);\n        this._editOnDoubleClick();\n        return this.container;\n    }\n    updateEdited(params) {\n        super.updateEdited(params);\n        const { thickness, points, rect } = params;\n        const g = this.#polylinesGroupElement;\n        if (thickness >= 0) {\n            g.setAttribute(\"stroke-width\", thickness || 1);\n        }\n        if (points) {\n            for(let i = 0, ii = this.#polylines.length; i < ii; i++){\n                this.#polylines[i].setAttribute(\"points\", points[i].join(\",\"));\n            }\n        }\n        if (rect) {\n            const { transform, width, height } = this.#getTransform(this.data.rotation, rect);\n            const root = g.parentElement;\n            root.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n            g.setAttribute(\"transform\", transform);\n        }\n    }\n    getElementsToTriggerPopup() {\n        return this.#polylines;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass HighlightAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n        this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"highlightAnnotation\");\n        this._editOnDoubleClick();\n        if (overlaidText) {\n            const mark = document.createElement(\"mark\");\n            mark.classList.add(\"overlaidText\");\n            mark.textContent = overlaidText;\n            this.container.append(mark);\n        }\n        return this.container;\n    }\n}\nclass UnderlineAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"underlineAnnotation\");\n        if (overlaidText) {\n            const underline = document.createElement(\"u\");\n            underline.classList.add(\"overlaidText\");\n            underline.textContent = overlaidText;\n            this.container.append(underline);\n        }\n        return this.container;\n    }\n}\nclass SquigglyAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"squigglyAnnotation\");\n        if (overlaidText) {\n            const underline = document.createElement(\"u\");\n            underline.classList.add(\"overlaidText\");\n            underline.textContent = overlaidText;\n            this.container.append(underline);\n        }\n        return this.container;\n    }\n}\nclass StrikeOutAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        const { data: { overlaidText, popupRef } } = this;\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"strikeoutAnnotation\");\n        if (overlaidText) {\n            const strikeout = document.createElement(\"s\");\n            strikeout.classList.add(\"overlaidText\");\n            strikeout.textContent = overlaidText;\n            this.container.append(strikeout);\n        }\n        return this.container;\n    }\n}\nclass StampAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.annotationEditorType = AnnotationEditorType.STAMP;\n    }\n    render() {\n        this.container.classList.add(\"stampAnnotation\");\n        this.container.setAttribute(\"role\", \"img\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n    #trigger;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n        this.#trigger = null;\n        const { file } = this.data;\n        this.filename = file.filename;\n        this.content = file.content;\n        this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n            source: this,\n            ...file\n        });\n    }\n    render() {\n        this.container.classList.add(\"fileAttachmentAnnotation\");\n        const { container, data } = this;\n        let trigger;\n        if (data.hasAppearance || data.fillAlpha === 0) {\n            trigger = document.createElement(\"div\");\n        } else {\n            trigger = document.createElement(\"img\");\n            trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n            if (data.fillAlpha && data.fillAlpha < 1) {\n                trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n            }\n        }\n        trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n        this.#trigger = trigger;\n        const { isMac } = util_FeatureTest.platform;\n        container.addEventListener(\"keydown\", (evt)=>{\n            if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n                this.#download();\n            }\n        });\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        } else {\n            trigger.classList.add(\"popupTriggerArea\");\n        }\n        container.append(trigger);\n        return container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#trigger;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n    #download() {\n        this.downloadManager?.openOrDownloadData(this.content, this.filename);\n    }\n}\nclass AnnotationLayer {\n    #accessibilityManager;\n    #annotationCanvasMap;\n    #annotationStorage;\n    #editableAnnotations;\n    #structTreeLayer;\n    #linkService;\n    constructor({ div, accessibilityManager, annotationCanvasMap, annotationEditorUIManager, page, viewport, structTreeLayer, commentManager, linkService, annotationStorage }){\n        this.#accessibilityManager = null;\n        this.#annotationCanvasMap = null;\n        this.#annotationStorage = null;\n        this.#editableAnnotations = new Map();\n        this.#structTreeLayer = null;\n        this.#linkService = null;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationCanvasMap = annotationCanvasMap;\n        this.#structTreeLayer = structTreeLayer || null;\n        this.#linkService = linkService || null;\n        this.#annotationStorage = annotationStorage || new AnnotationStorage();\n        this.page = page;\n        this.viewport = viewport;\n        this.zIndex = 0;\n        this._annotationEditorUIManager = annotationEditorUIManager;\n        this._commentManager = commentManager || null;\n    }\n    hasEditableAnnotations() {\n        return this.#editableAnnotations.size > 0;\n    }\n    async #appendElement(element, id, popupElements) {\n        const contentElement = element.firstChild || element;\n        const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;\n        const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);\n        if (ariaAttributes) {\n            for (const [key, value] of ariaAttributes){\n                contentElement.setAttribute(key, value);\n            }\n        }\n        if (popupElements) {\n            popupElements.at(-1).container.after(element);\n        } else {\n            this.div.append(element);\n            this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n        }\n    }\n    async render(params) {\n        const { annotations } = params;\n        const layer = this.div;\n        setLayerDimensions(layer, this.viewport);\n        const popupToElements = new Map();\n        const elementParams = {\n            data: null,\n            layer,\n            linkService: this.#linkService,\n            downloadManager: params.downloadManager,\n            imageResourcesPath: params.imageResourcesPath || \"\",\n            renderForms: params.renderForms !== false,\n            svgFactory: new DOMSVGFactory(),\n            annotationStorage: this.#annotationStorage,\n            enableComment: params.enableComment === true,\n            enableScripting: params.enableScripting === true,\n            hasJSActions: params.hasJSActions,\n            fieldObjects: params.fieldObjects,\n            parent: this,\n            elements: null\n        };\n        for (const data of annotations){\n            if (data.noHTML) {\n                continue;\n            }\n            const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;\n            if (!isPopupAnnotation) {\n                if (data.rect[2] === data.rect[0] || data.rect[3] === data.rect[1]) {\n                    continue;\n                }\n            } else {\n                const elements = popupToElements.get(data.id);\n                if (!elements) {\n                    continue;\n                }\n                elementParams.elements = elements;\n            }\n            elementParams.data = data;\n            const element = AnnotationElementFactory.create(elementParams);\n            if (!element.isRenderable) {\n                continue;\n            }\n            if (!isPopupAnnotation && data.popupRef) {\n                const elements = popupToElements.get(data.popupRef);\n                if (!elements) {\n                    popupToElements.set(data.popupRef, [\n                        element\n                    ]);\n                } else {\n                    elements.push(element);\n                }\n            }\n            const rendered = element.render();\n            if (data.hidden) {\n                rendered.style.visibility = \"hidden\";\n            }\n            await this.#appendElement(rendered, data.id, elementParams.elements);\n            element.extraPopupElement?.popup?.renderCommentButton();\n            if (element._isEditable) {\n                this.#editableAnnotations.set(element.data.id, element);\n                this._annotationEditorUIManager?.renderAnnotationElement(element);\n            }\n        }\n        this.#setAnnotationCanvasMap();\n    }\n    async addLinkAnnotations(annotations) {\n        const elementParams = {\n            data: null,\n            layer: this.div,\n            linkService: this.#linkService,\n            svgFactory: new DOMSVGFactory(),\n            parent: this\n        };\n        for (const data of annotations){\n            data.borderStyle ||= AnnotationLayer._defaultBorderStyle;\n            elementParams.data = data;\n            const element = AnnotationElementFactory.create(elementParams);\n            if (!element.isRenderable) {\n                continue;\n            }\n            const rendered = element.render();\n            await this.#appendElement(rendered, data.id, null);\n        }\n    }\n    update({ viewport }) {\n        const layer = this.div;\n        this.viewport = viewport;\n        setLayerDimensions(layer, {\n            rotation: viewport.rotation\n        });\n        this.#setAnnotationCanvasMap();\n        layer.hidden = false;\n    }\n    #setAnnotationCanvasMap() {\n        if (!this.#annotationCanvasMap) {\n            return;\n        }\n        const layer = this.div;\n        for (const [id, canvas] of this.#annotationCanvasMap){\n            const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n            if (!element) {\n                continue;\n            }\n            canvas.className = \"annotationContent\";\n            const { firstChild } = element;\n            if (!firstChild) {\n                element.append(canvas);\n            } else if (firstChild.nodeName === \"CANVAS\") {\n                firstChild.replaceWith(canvas);\n            } else if (!firstChild.classList.contains(\"annotationContent\")) {\n                firstChild.before(canvas);\n            } else {\n                firstChild.after(canvas);\n            }\n            const editableAnnotation = this.#editableAnnotations.get(id);\n            if (!editableAnnotation) {\n                continue;\n            }\n            if (editableAnnotation._hasNoCanvas) {\n                this._annotationEditorUIManager?.setMissingCanvas(id, element.id, canvas);\n                editableAnnotation._hasNoCanvas = false;\n            } else {\n                editableAnnotation.canvas = canvas;\n            }\n        }\n        this.#annotationCanvasMap.clear();\n    }\n    getEditableAnnotations() {\n        return Array.from(this.#editableAnnotations.values());\n    }\n    getEditableAnnotation(id) {\n        return this.#editableAnnotations.get(id);\n    }\n    addFakeAnnotation(editor) {\n        const { div } = this;\n        const { id, rotation } = editor;\n        const element = new EditorAnnotationElement({\n            data: {\n                id,\n                rect: editor.getPDFRect(),\n                rotation\n            },\n            editor,\n            layer: div,\n            parent: this,\n            enableComment: !!this._commentManager,\n            linkService: this.#linkService,\n            annotationStorage: this.#annotationStorage\n        });\n        const htmlElement = element.render();\n        div.append(htmlElement);\n        this.#accessibilityManager?.moveElementInDOM(div, htmlElement, htmlElement, false);\n        element.createOrUpdatePopup();\n        return element;\n    }\n    static get _defaultBorderStyle() {\n        return shadow(this, \"_defaultBorderStyle\", Object.freeze({\n            width: 1,\n            rawWidth: 1,\n            style: AnnotationBorderStyleType.SOLID,\n            dashArray: [\n                3\n            ],\n            horizontalCornerRadius: 0,\n            verticalCornerRadius: 0\n        }));\n    }\n}\n; // ./src/display/editor/freetext.js\nconst EOL_PATTERN = /\\r\\n?|\\n/g;\nclass FreeTextEditor extends AnnotationEditor {\n    #content;\n    #editorDivId;\n    #editModeAC;\n    #fontSize;\n    static{\n        this._freeTextDefaultContent = \"\";\n    }\n    static{\n        this._internalPadding = 0;\n    }\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultFontSize = 10;\n    }\n    static get _keyboardManager() {\n        const proto = FreeTextEditor.prototype;\n        const arrowChecker = (self1)=>self1.isEmpty();\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+s\",\n                    \"mac+meta+s\",\n                    \"ctrl+p\",\n                    \"mac+meta+p\"\n                ],\n                proto.commitOrRemove,\n                {\n                    bubbles: true\n                }\n            ],\n            [\n                [\n                    \"ctrl+Enter\",\n                    \"mac+meta+Enter\",\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.commitOrRemove\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    static{\n        this._type = \"freetext\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.FREETEXT;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"freeTextEditor\"\n        });\n        this.#content = \"\";\n        this.#editorDivId = `${this.id}-editor`;\n        this.#editModeAC = null;\n        this._colorPicker = null;\n        this.color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;\n        this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(\"pdfjs-editor-freetext-added-alert\");\n        }\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        const style = getComputedStyle(document.documentElement);\n        this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                FreeTextEditor._defaultFontSize = value;\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                FreeTextEditor._defaultColor = value;\n                break;\n        }\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                this.#updateFontSize(value);\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                this.#updateColor(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                FreeTextEditor._defaultFontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                this.#fontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                this.color\n            ]\n        ];\n    }\n    get toolbarButtons() {\n        this._colorPicker ||= new BasicColorPicker(this);\n        return [\n            [\n                \"colorPicker\",\n                this._colorPicker\n            ]\n        ];\n    }\n    get colorType() {\n        return AnnotationEditorParamsType.FREETEXT_COLOR;\n    }\n    #updateFontSize(fontSize) {\n        const setFontsize = (size)=>{\n            this.editorDiv.style.fontSize = `calc(${size}px * var(--total-scale-factor))`;\n            this.translate(0, -(size - this.#fontSize) * this.parentScale);\n            this.#fontSize = size;\n            this.#setEditorDimensions();\n        };\n        const savedFontsize = this.#fontSize;\n        this.addCommands({\n            cmd: setFontsize.bind(this, fontSize),\n            undo: setFontsize.bind(this, savedFontsize),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_SIZE,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    onUpdatedColor() {\n        this.editorDiv.style.color = this.color;\n        this._colorPicker?.update(this.color);\n        super.onUpdatedColor();\n    }\n    #updateColor(color) {\n        const setColor = (col)=>{\n            this.color = col;\n            this.onUpdatedColor();\n        };\n        const savedColor = this.color;\n        this.addCommands({\n            cmd: setColor.bind(this, color),\n            undo: setColor.bind(this, savedColor),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _translateEmpty(x, y) {\n        this._uiManager.translateSelectedEditors(x, y, true);\n    }\n    getInitialTranslation() {\n        const scale = this.parentScale;\n        return [\n            -FreeTextEditor._internalPadding * scale,\n            -(FreeTextEditor._internalPadding + this.#fontSize) * scale\n        ];\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    enableEditMode() {\n        if (!super.enableEditMode()) {\n            return false;\n        }\n        this.overlayDiv.classList.remove(\"enabled\");\n        this.editorDiv.contentEditable = true;\n        this._isDraggable = false;\n        this.div.removeAttribute(\"aria-activedescendant\");\n        this.#editModeAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#editModeAC);\n        this.editorDiv.addEventListener(\"keydown\", this.editorDivKeydown.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"focus\", this.editorDivFocus.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"blur\", this.editorDivBlur.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"input\", this.editorDivInput.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"paste\", this.editorDivPaste.bind(this), {\n            signal\n        });\n        return true;\n    }\n    disableEditMode() {\n        if (!super.disableEditMode()) {\n            return false;\n        }\n        this.overlayDiv.classList.add(\"enabled\");\n        this.editorDiv.contentEditable = false;\n        this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n        this._isDraggable = true;\n        this.#editModeAC?.abort();\n        this.#editModeAC = null;\n        this.div.focus({\n            preventScroll: true\n        });\n        this.isEditing = false;\n        this.parent.div.classList.add(\"freetextEditing\");\n        return true;\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        super.focusin(event);\n        if (event.target !== this.editorDiv) {\n            this.editorDiv.focus();\n        }\n    }\n    onceAdded(focus) {\n        if (this.width) {\n            return;\n        }\n        this.enableEditMode();\n        if (focus) {\n            this.editorDiv.focus();\n        }\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        }\n        this._initialOptions = null;\n    }\n    isEmpty() {\n        return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n    }\n    remove() {\n        this.isEditing = false;\n        if (this.parent) {\n            this.parent.setEditingState(true);\n            this.parent.div.classList.add(\"freetextEditing\");\n        }\n        super.remove();\n    }\n    #extractText() {\n        const buffer = [];\n        this.editorDiv.normalize();\n        let prevChild = null;\n        for (const child of this.editorDiv.childNodes){\n            if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === \"BR\") {\n                continue;\n            }\n            buffer.push(FreeTextEditor.#getNodeContent(child));\n            prevChild = child;\n        }\n        return buffer.join(\"\\n\");\n    }\n    #setEditorDimensions() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        let rect;\n        if (this.isAttachedToDOM) {\n            rect = this.div.getBoundingClientRect();\n        } else {\n            const { currentLayer, div } = this;\n            const savedDisplay = div.style.display;\n            const savedVisibility = div.classList.contains(\"hidden\");\n            div.classList.remove(\"hidden\");\n            div.style.display = \"hidden\";\n            currentLayer.div.append(this.div);\n            rect = div.getBoundingClientRect();\n            div.remove();\n            div.style.display = savedDisplay;\n            div.classList.toggle(\"hidden\", savedVisibility);\n        }\n        if (this.rotation % 180 === this.parentRotation % 180) {\n            this.width = rect.width / parentWidth;\n            this.height = rect.height / parentHeight;\n        } else {\n            this.width = rect.height / parentWidth;\n            this.height = rect.width / parentHeight;\n        }\n        this.fixAndSetPosition();\n    }\n    commit() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        super.commit();\n        this.disableEditMode();\n        const savedText = this.#content;\n        const newText = this.#content = this.#extractText().trimEnd();\n        if (savedText === newText) {\n            return;\n        }\n        const setText = (text)=>{\n            this.#content = text;\n            if (!text) {\n                this.remove();\n                return;\n            }\n            this.#setContent();\n            this._uiManager.rebuild(this);\n            this.#setEditorDimensions();\n        };\n        this.addCommands({\n            cmd: ()=>{\n                setText(newText);\n            },\n            undo: ()=>{\n                setText(savedText);\n            },\n            mustExec: false\n        });\n        this.#setEditorDimensions();\n    }\n    shouldGetKeyboardEvents() {\n        return this.isInEditMode();\n    }\n    enterInEditMode() {\n        this.enableEditMode();\n        this.editorDiv.focus();\n    }\n    keydown(event) {\n        if (event.target === this.div && event.key === \"Enter\") {\n            this.enterInEditMode();\n            event.preventDefault();\n        }\n    }\n    editorDivKeydown(event) {\n        FreeTextEditor._keyboardManager.exec(this, event);\n    }\n    editorDivFocus(event) {\n        this.isEditing = true;\n    }\n    editorDivBlur(event) {\n        this.isEditing = false;\n    }\n    editorDivInput(event) {\n        this.parent.div.classList.toggle(\"freetextEditing\", this.isEmpty());\n    }\n    disableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"comment\");\n        this.editorDiv.removeAttribute(\"aria-multiline\");\n    }\n    enableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"textbox\");\n        this.editorDiv.setAttribute(\"aria-multiline\", true);\n    }\n    get canChangeContent() {\n        return true;\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy || this.annotationElementId) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.editorDiv = document.createElement(\"div\");\n        this.editorDiv.className = \"internal\";\n        this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n        this.editorDiv.setAttribute(\"data-l10n-id\", \"pdfjs-free-text2\");\n        this.editorDiv.setAttribute(\"data-l10n-attrs\", \"default-content\");\n        this.enableEditing();\n        this.editorDiv.contentEditable = true;\n        const { style } = this.editorDiv;\n        style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n        style.color = this.color;\n        this.div.append(this.editorDiv);\n        this.overlayDiv = document.createElement(\"div\");\n        this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n        this.div.append(this.overlayDiv);\n        if (this._isCopy || this.annotationElementId) {\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            if (this.annotationElementId) {\n                const { position } = this._initialData;\n                let [tx, ty] = this.getInitialTranslation();\n                [tx, ty] = this.pageTranslationToScreen(tx, ty);\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                const [pageX, pageY] = this.pageTranslation;\n                let posX, posY;\n                switch(this.rotation){\n                    case 0:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n                        break;\n                    case 90:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            ty,\n                            -tx\n                        ];\n                        break;\n                    case 180:\n                        posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            -tx,\n                            -ty\n                        ];\n                        break;\n                    case 270:\n                        posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n                        posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n                        [tx, ty] = [\n                            -ty,\n                            tx\n                        ];\n                        break;\n                }\n                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n            } else {\n                this._moveAfterPaste(baseX, baseY);\n            }\n            this.#setContent();\n            this._isDraggable = true;\n            this.editorDiv.contentEditable = false;\n        } else {\n            this._isDraggable = false;\n            this.editorDiv.contentEditable = true;\n        }\n        return this.div;\n    }\n    static #getNodeContent(node) {\n        return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, \"\");\n    }\n    editorDivPaste(event) {\n        const clipboardData = event.clipboardData || window.clipboardData;\n        const { types } = clipboardData;\n        if (types.length === 1 && types[0] === \"text/plain\") {\n            return;\n        }\n        event.preventDefault();\n        const paste = FreeTextEditor.#deserializeContent(clipboardData.getData(\"text\") || \"\").replaceAll(EOL_PATTERN, \"\\n\");\n        if (!paste) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (!selection.rangeCount) {\n            return;\n        }\n        this.editorDiv.normalize();\n        selection.deleteFromDocument();\n        const range = selection.getRangeAt(0);\n        if (!paste.includes(\"\\n\")) {\n            range.insertNode(document.createTextNode(paste));\n            this.editorDiv.normalize();\n            selection.collapseToStart();\n            return;\n        }\n        const { startContainer, startOffset } = range;\n        const bufferBefore = [];\n        const bufferAfter = [];\n        if (startContainer.nodeType === Node.TEXT_NODE) {\n            const parent = startContainer.parentElement;\n            bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, \"\"));\n            if (parent !== this.editorDiv) {\n                let buffer = bufferBefore;\n                for (const child of this.editorDiv.childNodes){\n                    if (child === parent) {\n                        buffer = bufferAfter;\n                        continue;\n                    }\n                    buffer.push(FreeTextEditor.#getNodeContent(child));\n                }\n            }\n            bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, \"\"));\n        } else if (startContainer === this.editorDiv) {\n            let buffer = bufferBefore;\n            let i = 0;\n            for (const child of this.editorDiv.childNodes){\n                if (i++ === startOffset) {\n                    buffer = bufferAfter;\n                }\n                buffer.push(FreeTextEditor.#getNodeContent(child));\n            }\n        }\n        this.#content = `${bufferBefore.join(\"\\n\")}${paste}${bufferAfter.join(\"\\n\")}`;\n        this.#setContent();\n        const newRange = new Range();\n        let beforeLength = Math.sumPrecise(bufferBefore.map((line)=>line.length));\n        for (const { firstChild } of this.editorDiv.childNodes){\n            if (firstChild.nodeType === Node.TEXT_NODE) {\n                const length = firstChild.nodeValue.length;\n                if (beforeLength <= length) {\n                    newRange.setStart(firstChild, beforeLength);\n                    newRange.setEnd(firstChild, beforeLength);\n                    break;\n                }\n                beforeLength -= length;\n            }\n        }\n        selection.removeAllRanges();\n        selection.addRange(newRange);\n    }\n    #setContent() {\n        this.editorDiv.replaceChildren();\n        if (!this.#content) {\n            return;\n        }\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            this.editorDiv.append(div);\n        }\n    }\n    #serializeContent() {\n        return this.#content.replaceAll(\"\\xa0\", \" \");\n    }\n    static #deserializeContent(content) {\n        return content.replaceAll(\" \", \"\\xa0\");\n    }\n    get contentDiv() {\n        return this.editorDiv;\n    }\n    getPDFRect() {\n        const padding = FreeTextEditor._internalPadding * this.parentScale;\n        return this.getRect(padding, padding);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof FreeTextAnnotationElement) {\n            const { data: { defaultAppearanceData: { fontSize, fontColor }, rect, rotation, id, popupRef, richText, contentsObj, creationDate, modificationDate }, textContent, textPosition, parent: { page: { pageNumber } } } = data;\n            if (!textContent || textContent.length === 0) {\n                return null;\n            }\n            initialData = data = {\n                annotationType: AnnotationEditorType.FREETEXT,\n                color: Array.from(fontColor),\n                fontSize,\n                value: textContent.join(\"\\n\"),\n                position: textPosition,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                comment: contentsObj?.str || null,\n                richText,\n                creationDate,\n                modificationDate\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.#fontSize = data.fontSize;\n        editor.color = Util.makeHexColor(...data.color);\n        editor.#content = FreeTextEditor.#deserializeContent(data.value);\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data);\n        }\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.color);\n        const serialized = Object.assign(super.serialize(isForCopying), {\n            color,\n            fontSize: this.#fontSize,\n            value: this.#serializeContent()\n        });\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.isCopy = true;\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { value, fontSize, color, pageIndex } = this._initialData;\n        return this.hasEditedComment || this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i)=>c !== color[i]) || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        const content = super.renderAnnotationElement(annotation);\n        if (!content) {\n            return null;\n        }\n        const { style } = content;\n        style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n        style.color = this.color;\n        content.replaceChildren();\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            content.append(div);\n        }\n        annotation.updateEdited({\n            rect: this.getPDFRect(),\n            popup: this._uiManager.hasCommentManager() || this.hasEditedComment ? this.comment : {\n                text: this.#content\n            }\n        });\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        super.resetAnnotationElement(annotation);\n        annotation.resetEdited();\n    }\n}\n; // ./src/display/editor/drawers/outline.js\nclass Outline {\n    static{\n        this.PRECISION = 1e-4;\n    }\n    toSVGPath() {\n        unreachable(\"Abstract method `toSVGPath` must be implemented.\");\n    }\n    get box() {\n        unreachable(\"Abstract getter `box` must be implemented.\");\n    }\n    serialize(_bbox, _rotation) {\n        unreachable(\"Abstract method `serialize` must be implemented.\");\n    }\n    static _rescale(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i] * sx;\n            dest[i + 1] = ty + src[i + 1] * sy;\n        }\n        return dest;\n    }\n    static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i + 1] * sx;\n            dest[i + 1] = ty + src[i] * sy;\n        }\n        return dest;\n    }\n    static _translate(src, tx, ty, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i];\n            dest[i + 1] = ty + src[i + 1];\n        }\n        return dest;\n    }\n    static svgRound(x) {\n        return Math.round(x * 10000);\n    }\n    static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y / parentWidth,\n                    x / parentHeight\n                ];\n            case 180:\n                return [\n                    1 - x / parentWidth,\n                    1 - y / parentHeight\n                ];\n            case 270:\n                return [\n                    y / parentWidth,\n                    1 - x / parentHeight\n                ];\n            default:\n                return [\n                    x / parentWidth,\n                    y / parentHeight\n                ];\n        }\n    }\n    static _normalizePagePoint(x, y, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    static createBezierPoints(x1, y1, x2, y2, x3, y3) {\n        return [\n            (x1 + 5 * x2) / 6,\n            (y1 + 5 * y2) / 6,\n            (5 * x2 + x3) / 6,\n            (5 * y2 + y3) / 6,\n            (x2 + x3) / 2,\n            (y2 + y3) / 2\n        ];\n    }\n}\n; // ./src/display/editor/drawers/freedraw.js\nclass FreeDrawOutliner {\n    #box;\n    #bottom;\n    #innerMargin;\n    #isLTR;\n    #top;\n    #last;\n    #lastX;\n    #lastY;\n    #min;\n    #min_dist;\n    #scaleFactor;\n    #thickness;\n    #points;\n    static #MIN_DIST = 8;\n    static #MIN_DIFF = 2;\n    static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;\n    constructor({ x, y }, box, scaleFactor, thickness, isLTR, innerMargin = 0){\n        this.#bottom = [];\n        this.#top = [];\n        this.#last = new Float32Array(18);\n        this.#points = [];\n        this.#box = box;\n        this.#thickness = thickness * scaleFactor;\n        this.#isLTR = isLTR;\n        this.#last.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ], 6);\n        this.#innerMargin = innerMargin;\n        this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;\n        this.#min = FreeDrawOutliner.#MIN * scaleFactor;\n        this.#scaleFactor = scaleFactor;\n        this.#points.push(x, y);\n    }\n    isEmpty() {\n        return isNaN(this.#last[8]);\n    }\n    #getLastCoords() {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [x, y, width, height] = this.#box;\n        return [\n            (this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width,\n            (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height,\n            (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width,\n            (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height\n        ];\n    }\n    add({ x, y }) {\n        this.#lastX = x;\n        this.#lastY = y;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        let [x1, y1, x2, y2] = this.#last.subarray(8, 12);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(diffX, diffY);\n        if (d < this.#min) {\n            return false;\n        }\n        const diffD = d - this.#min_dist;\n        const K = diffD / d;\n        const shiftX = K * diffX;\n        const shiftY = K * diffY;\n        let x0 = x1;\n        let y0 = y1;\n        x1 = x2;\n        y1 = y2;\n        x2 += shiftX;\n        y2 += shiftY;\n        this.#points?.push(x, y);\n        const nX = -shiftY / diffD;\n        const nY = shiftX / diffD;\n        const thX = nX * this.#thickness;\n        const thY = nY * this.#thickness;\n        this.#last.set(this.#last.subarray(2, 8), 0);\n        this.#last.set([\n            x2 + thX,\n            y2 + thY\n        ], 4);\n        this.#last.set(this.#last.subarray(14, 18), 12);\n        this.#last.set([\n            x2 - thX,\n            y2 - thY\n        ], 16);\n        if (isNaN(this.#last[6])) {\n            if (this.#top.length === 0) {\n                this.#last.set([\n                    x1 + thX,\n                    y1 + thY\n                ], 2);\n                this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);\n                this.#last.set([\n                    x1 - thX,\n                    y1 - thY\n                ], 14);\n                this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);\n            }\n            this.#last.set([\n                x0,\n                y0,\n                x1,\n                y1,\n                x2,\n                y2\n            ], 6);\n            return !this.isEmpty();\n        }\n        this.#last.set([\n            x0,\n            y0,\n            x1,\n            y1,\n            x2,\n            y2\n        ], 6);\n        const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));\n        if (angle < Math.PI / 2) {\n            [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n            this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n            [x1, y1, x0, y0] = this.#last.subarray(14, 18);\n            this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);\n            return true;\n        }\n        [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);\n        this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);\n        this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        return true;\n    }\n    toSVGPath() {\n        if (this.isEmpty()) {\n            return \"\";\n        }\n        const top = this.#top;\n        const bottom = this.#bottom;\n        if (isNaN(this.#last[6]) && !this.isEmpty()) {\n            return this.#toSVGPathTwoPoints();\n        }\n        const buffer = [];\n        buffer.push(`M${top[4]} ${top[5]}`);\n        for(let i = 6; i < top.length; i += 6){\n            if (isNaN(top[i])) {\n                buffer.push(`L${top[i + 4]} ${top[i + 5]}`);\n            } else {\n                buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);\n            }\n        }\n        this.#toSVGPathEnd(buffer);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            if (isNaN(bottom[i])) {\n                buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);\n            } else {\n                buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);\n            }\n        }\n        this.#toSVGPathStart(buffer);\n        return buffer.join(\" \");\n    }\n    #toSVGPathTwoPoints() {\n        const [x, y, width, height] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;\n    }\n    #toSVGPathStart(buffer) {\n        const bottom = this.#bottom;\n        buffer.push(`L${bottom[4]} ${bottom[5]} Z`);\n    }\n    #toSVGPathEnd(buffer) {\n        const [x, y, width, height] = this.#box;\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);\n    }\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n    getOutlines() {\n        const top = this.#top;\n        const bottom = this.#bottom;\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const points = new Float32Array((this.#points?.length ?? 0) + 2);\n        for(let i = 0, ii = points.length - 2; i < ii; i += 2){\n            points[i] = (this.#points[i] - layerX) / layerWidth;\n            points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;\n        }\n        points[points.length - 2] = (this.#lastX - layerX) / layerWidth;\n        points[points.length - 1] = (this.#lastY - layerY) / layerHeight;\n        if (isNaN(last[6]) && !this.isEmpty()) {\n            return this.#getOutlineTwoPoints(points);\n        }\n        const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);\n        let N = top.length;\n        for(let i = 0; i < N; i += 2){\n            if (isNaN(top[i])) {\n                outline[i] = outline[i + 1] = NaN;\n                continue;\n            }\n            outline[i] = top[i];\n            outline[i + 1] = top[i + 1];\n        }\n        N = this.#getOutlineEnd(outline, N);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            for(let j = 0; j < 6; j += 2){\n                if (isNaN(bottom[i + j])) {\n                    outline[N] = outline[N + 1] = NaN;\n                    N += 2;\n                    continue;\n                }\n                outline[N] = bottom[i + j];\n                outline[N + 1] = bottom[i + j + 1];\n                N += 2;\n            }\n        }\n        this.#getOutlineStart(outline, N);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineTwoPoints(points) {\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        const outline = new Float32Array(36);\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[2] - layerX) / layerWidth,\n            (last[3] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[4] - layerX) / layerWidth,\n            (last[5] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[16] - layerX) / layerWidth,\n            (last[17] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[14] - layerX) / layerWidth,\n            (last[15] - layerY) / layerHeight\n        ], 0);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineStart(outline, pos) {\n        const bottom = this.#bottom;\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            bottom[4],\n            bottom[5]\n        ], pos);\n        return pos += 6;\n    }\n    #getOutlineEnd(outline, pos) {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastTop[0] - layerX) / layerWidth,\n            (lastTop[1] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastBottom[0] - layerX) / layerWidth,\n            (lastBottom[1] - layerY) / layerHeight\n        ], pos);\n        return pos += 24;\n    }\n}\nclass FreeDrawOutline extends Outline {\n    #box;\n    #bbox;\n    #innerMargin;\n    #isLTR;\n    #points;\n    #scaleFactor;\n    #outline;\n    constructor(outline, points, box, scaleFactor, innerMargin, isLTR){\n        super();\n        this.#bbox = new Float32Array(4);\n        this.#outline = outline;\n        this.#points = points;\n        this.#box = box;\n        this.#scaleFactor = scaleFactor;\n        this.#innerMargin = innerMargin;\n        this.#isLTR = isLTR;\n        this.firstPoint = [\n            NaN,\n            NaN\n        ];\n        this.lastPoint = [\n            NaN,\n            NaN\n        ];\n        this.#computeMinMax(isLTR);\n        const [x, y, width, height] = this.#bbox;\n        for(let i = 0, ii = outline.length; i < ii; i += 2){\n            outline[i] = (outline[i] - x) / width;\n            outline[i + 1] = (outline[i + 1] - y) / height;\n        }\n        for(let i = 0, ii = points.length; i < ii; i += 2){\n            points[i] = (points[i] - x) / width;\n            points[i + 1] = (points[i + 1] - y) / height;\n        }\n    }\n    toSVGPath() {\n        const buffer = [\n            `M${this.#outline[4]} ${this.#outline[5]}`\n        ];\n        for(let i = 6, ii = this.#outline.length; i < ii; i += 6){\n            if (isNaN(this.#outline[i])) {\n                buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n                continue;\n            }\n            buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n        }\n        buffer.push(\"Z\");\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], rotation) {\n        const width = trX - blX;\n        const height = trY - blY;\n        let outline;\n        let points;\n        switch(rotation){\n            case 0:\n                outline = Outline._rescale(this.#outline, blX, trY, width, -height);\n                points = Outline._rescale(this.#points, blX, trY, width, -height);\n                break;\n            case 90:\n                outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);\n                points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);\n                break;\n            case 180:\n                outline = Outline._rescale(this.#outline, trX, blY, -width, height);\n                points = Outline._rescale(this.#points, trX, blY, -width, height);\n                break;\n            case 270:\n                outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);\n                points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);\n                break;\n        }\n        return {\n            outline: Array.from(outline),\n            points: [\n                Array.from(points)\n            ]\n        };\n    }\n    #computeMinMax(isLTR) {\n        const outline = this.#outline;\n        let lastX = outline[4];\n        let lastY = outline[5];\n        const minMax = [\n            lastX,\n            lastY,\n            lastX,\n            lastY\n        ];\n        let firstPointX = lastX;\n        let firstPointY = lastY;\n        let lastPointX = lastX;\n        let lastPointY = lastY;\n        const ltrCallback = isLTR ? Math.max : Math.min;\n        const bezierBbox = new Float32Array(4);\n        for(let i = 6, ii = outline.length; i < ii; i += 6){\n            const x = outline[i + 4], y = outline[i + 5];\n            if (isNaN(outline[i])) {\n                Util.pointBoundingBox(x, y, minMax);\n                if (firstPointY > y) {\n                    firstPointX = x;\n                    firstPointY = y;\n                } else if (firstPointY === y) {\n                    firstPointX = ltrCallback(firstPointX, x);\n                }\n                if (lastPointY < y) {\n                    lastPointX = x;\n                    lastPointY = y;\n                } else if (lastPointY === y) {\n                    lastPointX = ltrCallback(lastPointX, x);\n                }\n            } else {\n                bezierBbox[0] = bezierBbox[1] = Infinity;\n                bezierBbox[2] = bezierBbox[3] = -Infinity;\n                Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6), bezierBbox);\n                Util.rectBoundingBox(bezierBbox[0], bezierBbox[1], bezierBbox[2], bezierBbox[3], minMax);\n                if (firstPointY > bezierBbox[1]) {\n                    firstPointX = bezierBbox[0];\n                    firstPointY = bezierBbox[1];\n                } else if (firstPointY === bezierBbox[1]) {\n                    firstPointX = ltrCallback(firstPointX, bezierBbox[0]);\n                }\n                if (lastPointY < bezierBbox[3]) {\n                    lastPointX = bezierBbox[2];\n                    lastPointY = bezierBbox[3];\n                } else if (lastPointY === bezierBbox[3]) {\n                    lastPointX = ltrCallback(lastPointX, bezierBbox[2]);\n                }\n            }\n            lastX = x;\n            lastY = y;\n        }\n        const bbox = this.#bbox;\n        bbox[0] = minMax[0] - this.#innerMargin;\n        bbox[1] = minMax[1] - this.#innerMargin;\n        bbox[2] = minMax[2] - minMax[0] + 2 * this.#innerMargin;\n        bbox[3] = minMax[3] - minMax[1] + 2 * this.#innerMargin;\n        this.firstPoint = [\n            firstPointX,\n            firstPointY\n        ];\n        this.lastPoint = [\n            lastPointX,\n            lastPointY\n        ];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n    getNewOutline(thickness, innerMargin) {\n        const [x, y, width, height] = this.#bbox;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const sx = width * layerWidth;\n        const sy = height * layerHeight;\n        const tx = x * layerWidth + layerX;\n        const ty = y * layerHeight + layerY;\n        const outliner = this.newOutliner({\n            x: this.#points[0] * sx + tx,\n            y: this.#points[1] * sy + ty\n        }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);\n        for(let i = 2; i < this.#points.length; i += 2){\n            outliner.add({\n                x: this.#points[i] * sx + tx,\n                y: this.#points[i + 1] * sy + ty\n            });\n        }\n        return outliner.getOutlines();\n    }\n}\n; // ./src/display/editor/drawers/highlight.js\nclass HighlightOutliner {\n    #box;\n    #firstPoint;\n    #lastPoint;\n    #verticalEdges;\n    #intervals;\n    constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true){\n        this.#verticalEdges = [];\n        this.#intervals = [];\n        const minMax = [\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ];\n        const NUMBER_OF_DIGITS = 4;\n        const EPSILON = 10 ** -NUMBER_OF_DIGITS;\n        for (const { x, y, width, height } of boxes){\n            const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;\n            const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;\n            const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;\n            const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;\n            const left = [\n                x1,\n                y1,\n                y2,\n                true\n            ];\n            const right = [\n                x2,\n                y1,\n                y2,\n                false\n            ];\n            this.#verticalEdges.push(left, right);\n            Util.rectBoundingBox(x1, y1, x2, y2, minMax);\n        }\n        const bboxWidth = minMax[2] - minMax[0] + 2 * innerMargin;\n        const bboxHeight = minMax[3] - minMax[1] + 2 * innerMargin;\n        const shiftedMinX = minMax[0] - innerMargin;\n        const shiftedMinY = minMax[1] - innerMargin;\n        let firstPointX = isLTR ? -Infinity : Infinity;\n        let firstPointY = Infinity;\n        const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);\n        const lastPoint = [\n            lastEdge[0],\n            lastEdge[2]\n        ];\n        for (const edge of this.#verticalEdges){\n            const [x, y1, y2, left] = edge;\n            if (!left && isLTR) {\n                if (y1 < firstPointY) {\n                    firstPointY = y1;\n                    firstPointX = x;\n                } else if (y1 === firstPointY) {\n                    firstPointX = Math.max(firstPointX, x);\n                }\n            } else if (left && !isLTR) {\n                if (y1 < firstPointY) {\n                    firstPointY = y1;\n                    firstPointX = x;\n                } else if (y1 === firstPointY) {\n                    firstPointX = Math.min(firstPointX, x);\n                }\n            }\n            edge[0] = (x - shiftedMinX) / bboxWidth;\n            edge[1] = (y1 - shiftedMinY) / bboxHeight;\n            edge[2] = (y2 - shiftedMinY) / bboxHeight;\n        }\n        this.#box = new Float32Array([\n            shiftedMinX,\n            shiftedMinY,\n            bboxWidth,\n            bboxHeight\n        ]);\n        this.#firstPoint = [\n            firstPointX,\n            firstPointY\n        ];\n        this.#lastPoint = lastPoint;\n    }\n    getOutlines() {\n        this.#verticalEdges.sort((a, b)=>a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);\n        const outlineVerticalEdges = [];\n        for (const edge of this.#verticalEdges){\n            if (edge[3]) {\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n                this.#insert(edge);\n            } else {\n                this.#remove(edge);\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n            }\n        }\n        return this.#getOutlines(outlineVerticalEdges);\n    }\n    #getOutlines(outlineVerticalEdges) {\n        const edges = [];\n        const allEdges = new Set();\n        for (const edge of outlineVerticalEdges){\n            const [x, y1, y2] = edge;\n            edges.push([\n                x,\n                y1,\n                edge\n            ], [\n                x,\n                y2,\n                edge\n            ]);\n        }\n        edges.sort((a, b)=>a[1] - b[1] || a[0] - b[0]);\n        for(let i = 0, ii = edges.length; i < ii; i += 2){\n            const edge1 = edges[i][2];\n            const edge2 = edges[i + 1][2];\n            edge1.push(edge2);\n            edge2.push(edge1);\n            allEdges.add(edge1);\n            allEdges.add(edge2);\n        }\n        const outlines = [];\n        let outline;\n        while(allEdges.size > 0){\n            const edge = allEdges.values().next().value;\n            let [x, y1, y2, edge1, edge2] = edge;\n            allEdges.delete(edge);\n            let lastPointX = x;\n            let lastPointY = y1;\n            outline = [\n                x,\n                y2\n            ];\n            outlines.push(outline);\n            while(true){\n                let e;\n                if (allEdges.has(edge1)) {\n                    e = edge1;\n                } else if (allEdges.has(edge2)) {\n                    e = edge2;\n                } else {\n                    break;\n                }\n                allEdges.delete(e);\n                [x, y1, y2, edge1, edge2] = e;\n                if (lastPointX !== x) {\n                    outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);\n                    lastPointX = x;\n                }\n                lastPointY = lastPointY === y1 ? y2 : y1;\n            }\n            outline.push(lastPointX, lastPointY);\n        }\n        return new HighlightOutline(outlines, this.#box, this.#firstPoint, this.#lastPoint);\n    }\n    #binarySearch(y) {\n        const array = this.#intervals;\n        let start = 0;\n        let end = array.length - 1;\n        while(start <= end){\n            const middle = start + end >> 1;\n            const y1 = array[middle][0];\n            if (y1 === y) {\n                return middle;\n            }\n            if (y1 < y) {\n                start = middle + 1;\n            } else {\n                end = middle - 1;\n            }\n        }\n        return end + 1;\n    }\n    #insert([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        this.#intervals.splice(index, 0, [\n            y1,\n            y2\n        ]);\n    }\n    #remove([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        for(let i = index; i < this.#intervals.length; i++){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n        for(let i = index - 1; i >= 0; i--){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n    }\n    #breakEdge(edge) {\n        const [x, y1, y2] = edge;\n        const results = [\n            [\n                x,\n                y1,\n                y2\n            ]\n        ];\n        const index = this.#binarySearch(y2);\n        for(let i = 0; i < index; i++){\n            const [start, end] = this.#intervals[i];\n            for(let j = 0, jj = results.length; j < jj; j++){\n                const [, y3, y4] = results[j];\n                if (end <= y3 || y4 <= start) {\n                    continue;\n                }\n                if (y3 >= start) {\n                    if (y4 > end) {\n                        results[j][1] = end;\n                    } else {\n                        if (jj === 1) {\n                            return [];\n                        }\n                        results.splice(j, 1);\n                        j--;\n                        jj--;\n                    }\n                    continue;\n                }\n                results[j][2] = start;\n                if (y4 > end) {\n                    results.push([\n                        x,\n                        end,\n                        y4\n                    ]);\n                }\n            }\n        }\n        return results;\n    }\n}\nclass HighlightOutline extends Outline {\n    #box;\n    #outlines;\n    constructor(outlines, box, firstPoint, lastPoint){\n        super();\n        this.#outlines = outlines;\n        this.#box = box;\n        this.firstPoint = firstPoint;\n        this.lastPoint = lastPoint;\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const polygon of this.#outlines){\n            let [prevX, prevY] = polygon;\n            buffer.push(`M${prevX} ${prevY}`);\n            for(let i = 2; i < polygon.length; i += 2){\n                const x = polygon[i];\n                const y = polygon[i + 1];\n                if (x === prevX) {\n                    buffer.push(`V${y}`);\n                    prevY = y;\n                } else if (y === prevY) {\n                    buffer.push(`H${x}`);\n                    prevX = x;\n                }\n            }\n            buffer.push(\"Z\");\n        }\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], _rotation) {\n        const outlines = [];\n        const width = trX - blX;\n        const height = trY - blY;\n        for (const outline of this.#outlines){\n            const points = new Array(outline.length);\n            for(let i = 0; i < outline.length; i += 2){\n                points[i] = blX + outline[i] * width;\n                points[i + 1] = trY - outline[i + 1] * height;\n            }\n            outlines.push(points);\n        }\n        return outlines;\n    }\n    get box() {\n        return this.#box;\n    }\n    get classNamesForOutlining() {\n        return [\n            \"highlightOutline\"\n        ];\n    }\n}\nclass FreeHighlightOutliner extends FreeDrawOutliner {\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n}\nclass FreeHighlightOutline extends FreeDrawOutline {\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n}\n; // ./src/display/editor/highlight.js\nclass HighlightEditor extends AnnotationEditor {\n    #anchorNode;\n    #anchorOffset;\n    #boxes;\n    #clipPathId;\n    #colorPicker;\n    #focusOutlines;\n    #focusNode;\n    #focusOffset;\n    #highlightDiv;\n    #highlightOutlines;\n    #id;\n    #isFreeHighlight;\n    #firstPoint;\n    #lastPoint;\n    #outlineId;\n    #text;\n    #thickness;\n    #methodOfCreation;\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultOpacity = 1;\n    }\n    static{\n        this._defaultThickness = 12;\n    }\n    static{\n        this._type = \"highlight\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    static{\n        this._freeHighlightId = -1;\n    }\n    static{\n        this._freeHighlight = null;\n    }\n    static{\n        this._freeHighlightClipId = \"\";\n    }\n    static get _keyboardManager() {\n        const proto = HighlightEditor.prototype;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        1\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        2\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        3\n                    ]\n                }\n            ]\n        ]));\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"highlightEditor\"\n        });\n        this.#anchorNode = null;\n        this.#anchorOffset = 0;\n        this.#clipPathId = null;\n        this.#colorPicker = null;\n        this.#focusOutlines = null;\n        this.#focusNode = null;\n        this.#focusOffset = 0;\n        this.#highlightDiv = null;\n        this.#highlightOutlines = null;\n        this.#id = null;\n        this.#isFreeHighlight = false;\n        this.#firstPoint = null;\n        this.#lastPoint = null;\n        this.#outlineId = null;\n        this.#text = \"\";\n        this.#methodOfCreation = \"\";\n        this.color = params.color || HighlightEditor._defaultColor;\n        this.#thickness = params.thickness || HighlightEditor._defaultThickness;\n        this.opacity = params.opacity || HighlightEditor._defaultOpacity;\n        this.#boxes = params.boxes || null;\n        this.#methodOfCreation = params.methodOfCreation || \"\";\n        this.#text = params.text || \"\";\n        this._isDraggable = false;\n        this.defaultL10nId = \"pdfjs-editor-highlight-editor\";\n        if (params.highlightId > -1) {\n            this.#isFreeHighlight = true;\n            this.#createFreeOutlines(params);\n            this.#addToDrawLayer();\n        } else if (this.#boxes) {\n            this.#anchorNode = params.anchorNode;\n            this.#anchorOffset = params.anchorOffset;\n            this.#focusNode = params.focusNode;\n            this.#focusOffset = params.focusOffset;\n            this.#createOutlines();\n            this.#addToDrawLayer();\n            this.rotate(this.rotation);\n        }\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(\"pdfjs-editor-highlight-added-alert\");\n        }\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\",\n            type: this.#isFreeHighlight ? \"free_highlight\" : \"highlight\",\n            color: this._uiManager.getNonHCMColorName(this.color),\n            thickness: this.#thickness,\n            methodOfCreation: this.#methodOfCreation\n        };\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"highlight\",\n            color: this._uiManager.getNonHCMColorName(this.color)\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        return {\n            numberOfColors: data.get(\"color\").size\n        };\n    }\n    #createOutlines() {\n        const outliner = new HighlightOutliner(this.#boxes, 0.001);\n        this.#highlightOutlines = outliner.getOutlines();\n        [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;\n        const outlinerForOutline = new HighlightOutliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === \"ltr\");\n        this.#focusOutlines = outlinerForOutline.getOutlines();\n        const { firstPoint } = this.#highlightOutlines;\n        this.#firstPoint = [\n            (firstPoint[0] - this.x) / this.width,\n            (firstPoint[1] - this.y) / this.height\n        ];\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - this.x) / this.width,\n            (lastPoint[1] - this.y) / this.height\n        ];\n    }\n    #createFreeOutlines({ highlightOutlines, highlightId, clipPathId }) {\n        this.#highlightOutlines = highlightOutlines;\n        const extraThickness = 1.5;\n        this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 0.0025);\n        if (highlightId >= 0) {\n            this.#id = highlightId;\n            this.#clipPathId = clipPathId;\n            this.parent.drawLayer.finalizeDraw(highlightId, {\n                bbox: highlightOutlines.box,\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.#outlineId = this.parent.drawLayer.drawOutline({\n                rootClass: {\n                    highlightOutline: true,\n                    free: true\n                },\n                bbox: this.#focusOutlines.box,\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            }, true);\n        } else if (this.parent) {\n            const angle = this.parent.viewport.rotation;\n            this.parent.drawLayer.updateProperties(this.#id, {\n                bbox: HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            });\n        }\n        const [x, y, width, height] = highlightOutlines.box;\n        switch(this.rotation){\n            case 0:\n                this.x = x;\n                this.y = y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = y;\n                    this.y = 1 - x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n            case 180:\n                this.x = 1 - x;\n                this.y = 1 - y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = 1 - y;\n                    this.y = x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n        }\n        const { firstPoint } = highlightOutlines;\n        this.#firstPoint = [\n            (firstPoint[0] - x) / width,\n            (firstPoint[1] - y) / height\n        ];\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - x) / width,\n            (lastPoint[1] - y) / height\n        ];\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || \"#fff066\";\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n                HighlightEditor._defaultColor = value;\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                HighlightEditor._defaultThickness = value;\n                break;\n        }\n    }\n    translateInPage(x, y) {}\n    get toolbarPosition() {\n        return this.#lastPoint;\n    }\n    get commentButtonPosition() {\n        return this.#firstPoint;\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n                this.#updateColor(value);\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                this.#updateThickness(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                HighlightEditor._defaultThickness\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                this.color || HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                this.#thickness || HighlightEditor._defaultThickness\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                this.#isFreeHighlight\n            ]\n        ];\n    }\n    onUpdatedColor() {\n        this.parent?.drawLayer.updateProperties(this.#id, {\n            root: {\n                fill: this.color,\n                \"fill-opacity\": this.opacity\n            }\n        });\n        this.#colorPicker?.updateColor(this.color);\n        super.onUpdatedColor();\n    }\n    #updateColor(color) {\n        const setColorAndOpacity = (col, opa)=>{\n            this.color = col;\n            this.opacity = opa;\n            this.onUpdatedColor();\n        };\n        const savedColor = this.color;\n        const savedOpacity = this.opacity;\n        this.addCommands({\n            cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),\n            undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"color_changed\",\n            color: this._uiManager.getNonHCMColorName(color)\n        }, true);\n    }\n    #updateThickness(thickness) {\n        const savedThickness = this.#thickness;\n        const setThickness = (th)=>{\n            this.#thickness = th;\n            this.#changeThickness(th);\n        };\n        this.addCommands({\n            cmd: setThickness.bind(this, thickness),\n            undo: setThickness.bind(this, savedThickness),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.INK_THICKNESS,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"thickness_changed\",\n            thickness\n        }, true);\n    }\n    get toolbarButtons() {\n        if (this._uiManager.highlightColors) {\n            const colorPicker = this.#colorPicker = new ColorPicker({\n                editor: this\n            });\n            return [\n                [\n                    \"colorPicker\",\n                    colorPicker\n                ]\n            ];\n        }\n        return super.toolbarButtons;\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    fixAndSetPosition() {\n        return super.fixAndSetPosition(this.#getRotation());\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    getRect(tx, ty) {\n        return super.getRect(tx, ty, this.#getRotation());\n    }\n    onceAdded(focus) {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        if (focus) {\n            this.div.focus();\n        }\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        this._reportTelemetry({\n            action: \"deleted\"\n        });\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        this.show(this._isVisible);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #changeThickness(thickness) {\n        if (!this.#isFreeHighlight) {\n            return;\n        }\n        this.#createFreeOutlines({\n            highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)\n        });\n        this.fixAndSetPosition();\n        this.setDims(this.width, this.height);\n    }\n    #cleanDrawLayer() {\n        if (this.#id === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this.#id);\n        this.#id = null;\n        this.parent.drawLayer.remove(this.#outlineId);\n        this.#outlineId = null;\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this.#id !== null) {\n            return;\n        }\n        ({ id: this.#id, clipPathId: this.#clipPathId } = parent.drawLayer.draw({\n            bbox: this.#highlightOutlines.box,\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this.color,\n                \"fill-opacity\": this.opacity\n            },\n            rootClass: {\n                highlight: true,\n                free: this.#isFreeHighlight\n            },\n            path: {\n                d: this.#highlightOutlines.toSVGPath()\n            }\n        }, false, true));\n        this.#outlineId = parent.drawLayer.drawOutline({\n            rootClass: {\n                highlightOutline: true,\n                free: this.#isFreeHighlight\n            },\n            bbox: this.#focusOutlines.box,\n            path: {\n                d: this.#focusOutlines.toSVGPath()\n            }\n        }, this.#isFreeHighlight);\n        if (this.#highlightDiv) {\n            this.#highlightDiv.style.clipPath = this.#clipPathId;\n        }\n    }\n    static #rotateBbox([x, y, width, height], angle) {\n        switch(angle){\n            case 90:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n        }\n        return [\n            x,\n            y,\n            width,\n            height\n        ];\n    }\n    rotate(angle) {\n        const { drawLayer } = this.parent;\n        let box;\n        if (this.#isFreeHighlight) {\n            angle = (angle - this.rotation + 360) % 360;\n            box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);\n        } else {\n            box = HighlightEditor.#rotateBbox([\n                this.x,\n                this.y,\n                this.width,\n                this.height\n            ], angle);\n        }\n        drawLayer.updateProperties(this.#id, {\n            bbox: box,\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n        drawLayer.updateProperties(this.#outlineId, {\n            bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        const div = super.render();\n        if (this.#text) {\n            div.setAttribute(\"aria-label\", this.#text);\n            div.setAttribute(\"role\", \"mark\");\n        }\n        if (this.#isFreeHighlight) {\n            div.classList.add(\"free\");\n        } else {\n            this.div.addEventListener(\"keydown\", this.#keydown.bind(this), {\n                signal: this._uiManager._signal\n            });\n        }\n        const highlightDiv = this.#highlightDiv = document.createElement(\"div\");\n        div.append(highlightDiv);\n        highlightDiv.setAttribute(\"aria-hidden\", \"true\");\n        highlightDiv.className = \"internal\";\n        highlightDiv.style.clipPath = this.#clipPathId;\n        this.setDims(this.width, this.height);\n        bindEvents(this, this.#highlightDiv, [\n            \"pointerover\",\n            \"pointerleave\"\n        ]);\n        this.enableEditing();\n        return div;\n    }\n    pointerover() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: true\n                }\n            });\n        }\n    }\n    pointerleave() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: false\n                }\n            });\n        }\n    }\n    #keydown(event) {\n        HighlightEditor._keyboardManager.exec(this, event);\n    }\n    _moveCaret(direction) {\n        this.parent.unselect(this);\n        switch(direction){\n            case 0:\n            case 2:\n                this.#setCaret(true);\n                break;\n            case 1:\n            case 3:\n                this.#setCaret(false);\n                break;\n        }\n    }\n    #setCaret(start) {\n        if (!this.#anchorNode) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (start) {\n            selection.setPosition(this.#anchorNode, this.#anchorOffset);\n        } else {\n            selection.setPosition(this.#focusNode, this.#focusOffset);\n        }\n    }\n    select() {\n        super.select();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                hovered: false,\n                selected: true\n            }\n        });\n    }\n    unselect() {\n        super.unselect();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                selected: false\n            }\n        });\n        if (!this.#isFreeHighlight) {\n            this.#setCaret(false);\n        }\n    }\n    get _mustFixPosition() {\n        return !this.#isFreeHighlight;\n    }\n    show(visible = this._isVisible) {\n        super.show(visible);\n        if (this.parent) {\n            this.parent.drawLayer.updateProperties(this.#id, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n        }\n    }\n    #getRotation() {\n        return this.#isFreeHighlight ? this.rotation : 0;\n    }\n    #serializeBoxes() {\n        if (this.#isFreeHighlight) {\n            return null;\n        }\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const boxes = this.#boxes;\n        const quadPoints = new Float32Array(boxes.length * 8);\n        let i = 0;\n        for (const { x, y, width, height } of boxes){\n            const sx = x * pageWidth + pageX;\n            const sy = (1 - y) * pageHeight + pageY;\n            quadPoints[i] = quadPoints[i + 4] = sx;\n            quadPoints[i + 1] = quadPoints[i + 3] = sy;\n            quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;\n            quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;\n            i += 8;\n        }\n        return quadPoints;\n    }\n    #serializeOutlines(rect) {\n        return this.#highlightOutlines.serialize(rect, this.#getRotation());\n    }\n    static startHighlighting(parent, isLTR, { target: textLayer, x, y }) {\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        const ac = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        const pointerUpCallback = (e)=>{\n            ac.abort();\n            this.#endHighlight(parent, e);\n        };\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", stopEvent, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        textLayer.addEventListener(\"pointermove\", this.#highlightMove.bind(this, parent), {\n            signal\n        });\n        this._freeHighlight = new FreeHighlightOutliner({\n            x,\n            y\n        }, [\n            layerX,\n            layerY,\n            parentWidth,\n            parentHeight\n        ], parent.scale, this._defaultThickness / 2, isLTR, 0.001);\n        ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = parent.drawLayer.draw({\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ],\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this._defaultColor,\n                \"fill-opacity\": this._defaultOpacity\n            },\n            rootClass: {\n                highlight: true,\n                free: true\n            },\n            path: {\n                d: this._freeHighlight.toSVGPath()\n            }\n        }, true, true));\n    }\n    static #highlightMove(parent, event) {\n        if (this._freeHighlight.add(event)) {\n            parent.drawLayer.updateProperties(this._freeHighlightId, {\n                path: {\n                    d: this._freeHighlight.toSVGPath()\n                }\n            });\n        }\n    }\n    static #endHighlight(parent, event) {\n        if (!this._freeHighlight.isEmpty()) {\n            parent.createAndAddNewEditor(event, false, {\n                highlightId: this._freeHighlightId,\n                highlightOutlines: this._freeHighlight.getOutlines(),\n                clipPathId: this._freeHighlightClipId,\n                methodOfCreation: \"main_toolbar\"\n            });\n        } else {\n            parent.drawLayer.remove(this._freeHighlightId);\n        }\n        this._freeHighlightId = -1;\n        this._freeHighlight = null;\n        this._freeHighlightClipId = \"\";\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof HighlightAnnotationElement) {\n            const { data: { quadPoints, rect, rotation, id, color, opacity, popupRef, richText, contentsObj, creationDate, modificationDate }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                opacity,\n                quadPoints,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                richText,\n                comment: contentsObj?.str || null,\n                creationDate,\n                modificationDate\n            };\n        } else if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, borderStyle: { rawWidth: thickness }, popupRef, richText, contentsObj, creationDate, modificationDate }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                thickness,\n                inkLists,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                richText,\n                comment: contentsObj?.str || null,\n                creationDate,\n                modificationDate\n            };\n        }\n        const { color, quadPoints, inkLists, opacity } = data;\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.color = Util.makeHexColor(...color);\n        editor.opacity = opacity || 1;\n        if (inkLists) {\n            editor.#thickness = data.thickness;\n        }\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data);\n        }\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [pageX, pageY] = editor.pageTranslation;\n        if (quadPoints) {\n            const boxes = editor.#boxes = [];\n            for(let i = 0; i < quadPoints.length; i += 8){\n                boxes.push({\n                    x: (quadPoints[i] - pageX) / pageWidth,\n                    y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,\n                    width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,\n                    height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight\n                });\n            }\n            editor.#createOutlines();\n            editor.#addToDrawLayer();\n            editor.rotate(editor.rotation);\n        } else if (inkLists) {\n            editor.#isFreeHighlight = true;\n            const points = inkLists[0];\n            const point = {\n                x: points[0] - pageX,\n                y: pageHeight - (points[1] - pageY)\n            };\n            const outliner = new FreeHighlightOutliner(point, [\n                0,\n                0,\n                pageWidth,\n                pageHeight\n            ], 1, editor.#thickness / 2, true, 0.001);\n            for(let i = 0, ii = points.length; i < ii; i += 2){\n                point.x = points[i] - pageX;\n                point.y = pageHeight - (points[i + 1] - pageY);\n                outliner.add(point);\n            }\n            const { id, clipPathId } = parent.drawLayer.draw({\n                bbox: [\n                    0,\n                    0,\n                    1,\n                    1\n                ],\n                root: {\n                    viewBox: \"0 0 1 1\",\n                    fill: editor.color,\n                    \"fill-opacity\": editor._defaultOpacity\n                },\n                rootClass: {\n                    highlight: true,\n                    free: true\n                },\n                path: {\n                    d: outliner.toSVGPath()\n                }\n            }, true, true);\n            editor.#createFreeOutlines({\n                highlightOutlines: outliner.getOutlines(),\n                highlightId: id,\n                clipPathId\n            });\n            editor.#addToDrawLayer();\n            editor.rotate(editor.parentRotation);\n        }\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty() || isForCopying) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const color = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));\n        const serialized = super.serialize(isForCopying);\n        Object.assign(serialized, {\n            color,\n            opacity: this.opacity,\n            thickness: this.#thickness,\n            quadPoints: this.#serializeBoxes(),\n            outlines: this.#serializeOutlines(serialized.rect)\n        });\n        this.addComment(serialized);\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color } = this._initialData;\n        return this.hasEditedComment || serialized.color.some((c, i)=>c !== color[i]);\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        annotation.updateEdited({\n            rect: this.getPDFRect(),\n            popup: this.comment\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\n; // ./src/display/editor/draw.js\nclass DrawingOptions {\n    #svgProperties;\n    updateProperty(name, value) {\n        this[name] = value;\n        this.updateSVGProperty(name, value);\n    }\n    updateProperties(properties) {\n        if (!properties) {\n            return;\n        }\n        for (const [name, value] of Object.entries(properties)){\n            if (!name.startsWith(\"_\")) {\n                this.updateProperty(name, value);\n            }\n        }\n    }\n    updateSVGProperty(name, value) {\n        this.#svgProperties[name] = value;\n    }\n    toSVGProperties() {\n        const root = this.#svgProperties;\n        this.#svgProperties = Object.create(null);\n        return {\n            root\n        };\n    }\n    reset() {\n        this.#svgProperties = Object.create(null);\n    }\n    updateAll(options = this) {\n        this.updateProperties(options);\n    }\n    clone() {\n        unreachable(\"Not implemented\");\n    }\n    constructor(){\n        this.#svgProperties = Object.create(null);\n    }\n}\nclass DrawingEditor extends AnnotationEditor {\n    #drawOutlines;\n    #mustBeCommitted;\n    static{\n        this._currentDrawId = -1;\n    }\n    static{\n        this._currentParent = null;\n    }\n    static #currentDraw = null;\n    static #currentDrawingAC = null;\n    static #currentDrawingOptions = null;\n    static #currentPointerId = NaN;\n    static #currentPointerType = null;\n    static #currentPointerIds = null;\n    static #currentMoveTimestamp = NaN;\n    static{\n        this._INNER_MARGIN = 3;\n    }\n    constructor(params){\n        super(params);\n        this.#drawOutlines = null;\n        this._colorPicker = null;\n        this._drawId = null;\n        this.#mustBeCommitted = params.mustBeCommitted || false;\n        this._addOutlines(params);\n    }\n    onUpdatedColor() {\n        this._colorPicker?.update(this.color);\n        super.onUpdatedColor();\n    }\n    _addOutlines(params) {\n        if (params.drawOutlines) {\n            this.#createDrawOutlines(params);\n            this.#addToDrawLayer();\n        }\n    }\n    #createDrawOutlines({ drawOutlines, drawId, drawingOptions }) {\n        this.#drawOutlines = drawOutlines;\n        this._drawingOptions ||= drawingOptions;\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`);\n        }\n        if (drawId >= 0) {\n            this._drawId = drawId;\n            this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);\n        } else {\n            this._drawId = this.#createDrawing(drawOutlines, this.parent);\n        }\n        this.#updateBbox(drawOutlines.box);\n    }\n    #createDrawing(drawOutlines, parent) {\n        const { id } = parent.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);\n        return id;\n    }\n    static _mergeSVGProperties(p1, p2) {\n        const p1Keys = new Set(Object.keys(p1));\n        for (const [key, value] of Object.entries(p2)){\n            if (p1Keys.has(key)) {\n                Object.assign(p1[key], value);\n            } else {\n                p1[key] = value;\n            }\n        }\n        return p1;\n    }\n    static getDefaultDrawingOptions(_options) {\n        unreachable(\"Not implemented\");\n    }\n    static get typesMap() {\n        unreachable(\"Not implemented\");\n    }\n    static get isDrawer() {\n        return true;\n    }\n    static get supportMultipleDrawings() {\n        return false;\n    }\n    static updateDefaultParams(type, value) {\n        const propertyName = this.typesMap.get(type);\n        if (propertyName) {\n            this._defaultDrawingOptions.updateProperty(propertyName, value);\n        }\n        if (this._currentParent) {\n            DrawingEditor.#currentDraw.updateProperty(propertyName, value);\n            this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n        }\n    }\n    updateParams(type, value) {\n        const propertyName = this.constructor.typesMap.get(type);\n        if (propertyName) {\n            this._updateProperty(type, propertyName, value);\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        const properties = [];\n        const options = this._defaultDrawingOptions;\n        for (const [type, name] of this.typesMap){\n            properties.push([\n                type,\n                options[name]\n            ]);\n        }\n        return properties;\n    }\n    get propertiesToUpdate() {\n        const properties = [];\n        const { _drawingOptions } = this;\n        for (const [type, name] of this.constructor.typesMap){\n            properties.push([\n                type,\n                _drawingOptions[name]\n            ]);\n        }\n        return properties;\n    }\n    _updateProperty(type, name, value) {\n        const options = this._drawingOptions;\n        const savedValue = options[name];\n        const setter = (val)=>{\n            options.updateProperty(name, val);\n            const bbox = this.#drawOutlines.updateProperty(name, val);\n            if (bbox) {\n                this.#updateBbox(bbox);\n            }\n            this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());\n            if (type === this.colorType) {\n                this.onUpdatedColor();\n            }\n        };\n        this.addCommands({\n            cmd: setter.bind(this, value),\n            undo: setter.bind(this, savedValue),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _onResizing() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onResized() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onTranslating(_x, _y) {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            bbox: this.#rotateBox()\n        });\n    }\n    _onTranslated() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onStartDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: true\n            }\n        });\n    }\n    _onStopDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: false\n            }\n        });\n    }\n    commit() {\n        super.commit();\n        this.disableEditMode();\n        this.disableEditing();\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    get isResizable() {\n        return true;\n    }\n    onceAdded(focus) {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        this._isDraggable = true;\n        if (this.#mustBeCommitted) {\n            this.#mustBeCommitted = false;\n            this.commit();\n            this.parent.setSelected(this);\n            if (focus && this.isOnScreen) {\n                this.div.focus();\n            }\n        }\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        this.#updateBbox(this.#drawOutlines.box);\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this._uiManager.removeShouldRescale(this);\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this._uiManager.addShouldRescale(this);\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #cleanDrawLayer() {\n        if (this._drawId === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this._drawId);\n        this._drawId = null;\n        this._drawingOptions.reset();\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this._drawId !== null && this.parent === parent) {\n            return;\n        }\n        if (this._drawId !== null) {\n            this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);\n            return;\n        }\n        this._drawingOptions.updateAll();\n        this._drawId = this.#createDrawing(this.#drawOutlines, parent);\n    }\n    #convertToParentSpace([x, y, width, height]) {\n        const { parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    y,\n                    1 - x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    1 - y,\n                    x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #convertToDrawSpace() {\n        const { x, y, width, height, parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #updateBbox(bbox) {\n        [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);\n        if (this.div) {\n            this.fixAndSetPosition();\n            this.setDims();\n        }\n        this._onResized();\n    }\n    #rotateBox() {\n        const { x, y, width, height, rotation, parentRotation, parentDimensions: [pW, pH] } = this;\n        switch((rotation * 4 + parentRotation) / 90){\n            case 1:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 2:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 3:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n            case 4:\n                return [\n                    x,\n                    y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 5:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 6:\n                return [\n                    1 - x - height * (pH / pW),\n                    1 - y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 7:\n                return [\n                    y - width * (pW / pH),\n                    1 - x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 8:\n                return [\n                    x - width,\n                    y - height,\n                    width,\n                    height\n                ];\n            case 9:\n                return [\n                    1 - y,\n                    x - width,\n                    height,\n                    width\n                ];\n            case 10:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 11:\n                return [\n                    y - height,\n                    1 - x,\n                    height,\n                    width\n                ];\n            case 12:\n                return [\n                    x - height * (pH / pW),\n                    y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 13:\n                return [\n                    1 - y - width * (pW / pH),\n                    x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 14:\n                return [\n                    1 - x,\n                    1 - y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 15:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    rotate() {\n        if (!this.parent) {\n            return;\n        }\n        this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({\n            bbox: this.#rotateBox()\n        }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));\n    }\n    static onScaleChangingWhenDrawing() {}\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        const div = super.render();\n        div.classList.add(\"draw\");\n        const drawDiv = document.createElement(\"div\");\n        div.append(drawDiv);\n        drawDiv.setAttribute(\"aria-hidden\", \"true\");\n        drawDiv.className = \"internal\";\n        this.setDims();\n        this._uiManager.addShouldRescale(this);\n        this.disableEditing();\n        if (this._isCopy) {\n            this._moveAfterPaste(baseX, baseY);\n        }\n        return div;\n    }\n    static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {\n        unreachable(\"Not implemented\");\n    }\n    static startDrawing(parent, uiManager, _isLTR, event) {\n        const { target, offsetX: x, offsetY: y, pointerId, pointerType } = event;\n        if (DrawingEditor.#currentPointerType && DrawingEditor.#currentPointerType !== pointerType) {\n            return;\n        }\n        const { viewport: { rotation } } = parent;\n        const { width: parentWidth, height: parentHeight } = target.getBoundingClientRect();\n        const ac = DrawingEditor.#currentDrawingAC = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        DrawingEditor.#currentPointerId ||= pointerId;\n        DrawingEditor.#currentPointerType ??= pointerType;\n        window.addEventListener(\"pointerup\", (e)=>{\n            if (DrawingEditor.#currentPointerId === e.pointerId) {\n                this._endDraw(e);\n            } else {\n                DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n            }\n        }, {\n            signal\n        });\n        window.addEventListener(\"pointercancel\", (e)=>{\n            if (DrawingEditor.#currentPointerId === e.pointerId) {\n                this._currentParent.endDrawingSession();\n            } else {\n                DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n            }\n        }, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", (e)=>{\n            if (DrawingEditor.#currentPointerType !== e.pointerType) {\n                return;\n            }\n            (DrawingEditor.#currentPointerIds ||= new Set()).add(e.pointerId);\n            if (DrawingEditor.#currentDraw.isCancellable()) {\n                DrawingEditor.#currentDraw.removeLastElement();\n                if (DrawingEditor.#currentDraw.isEmpty()) {\n                    this._currentParent.endDrawingSession(true);\n                } else {\n                    this._endDraw(null);\n                }\n            }\n        }, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        target.addEventListener(\"pointermove\", this._drawMove.bind(this), {\n            signal\n        });\n        target.addEventListener(\"touchmove\", (e)=>{\n            if (e.timeStamp === DrawingEditor.#currentMoveTimestamp) {\n                stopEvent(e);\n            }\n        }, {\n            signal\n        });\n        parent.toggleDrawing();\n        uiManager._editorUndoBar?.hide();\n        if (DrawingEditor.#currentDraw) {\n            parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.startNew(x, y, parentWidth, parentHeight, rotation));\n            return;\n        }\n        uiManager.updateUIForDefaultProperties(this);\n        DrawingEditor.#currentDraw = this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation);\n        DrawingEditor.#currentDrawingOptions = this.getDefaultDrawingOptions();\n        this._currentParent = parent;\n        ({ id: this._currentDrawId } = parent.drawLayer.draw(this._mergeSVGProperties(DrawingEditor.#currentDrawingOptions.toSVGProperties(), DrawingEditor.#currentDraw.defaultSVGProperties), true, false));\n    }\n    static _drawMove(event) {\n        DrawingEditor.#currentMoveTimestamp = -1;\n        if (!DrawingEditor.#currentDraw) {\n            return;\n        }\n        const { offsetX, offsetY, pointerId } = event;\n        if (DrawingEditor.#currentPointerId !== pointerId) {\n            return;\n        }\n        if (DrawingEditor.#currentPointerIds?.size >= 1) {\n            this._endDraw(event);\n            return;\n        }\n        this._currentParent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.add(offsetX, offsetY));\n        DrawingEditor.#currentMoveTimestamp = event.timeStamp;\n        stopEvent(event);\n    }\n    static _cleanup(all) {\n        if (all) {\n            this._currentDrawId = -1;\n            this._currentParent = null;\n            DrawingEditor.#currentDraw = null;\n            DrawingEditor.#currentDrawingOptions = null;\n            DrawingEditor.#currentPointerType = null;\n            DrawingEditor.#currentMoveTimestamp = NaN;\n        }\n        if (DrawingEditor.#currentDrawingAC) {\n            DrawingEditor.#currentDrawingAC.abort();\n            DrawingEditor.#currentDrawingAC = null;\n            DrawingEditor.#currentPointerId = NaN;\n            DrawingEditor.#currentPointerIds = null;\n        }\n    }\n    static _endDraw(event) {\n        const parent = this._currentParent;\n        if (!parent) {\n            return;\n        }\n        parent.toggleDrawing(true);\n        this._cleanup(false);\n        if (event?.target === parent.div) {\n            parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.end(event.offsetX, event.offsetY));\n        }\n        if (this.supportMultipleDrawings) {\n            const draw = DrawingEditor.#currentDraw;\n            const drawId = this._currentDrawId;\n            const lastElement = draw.getLastElement();\n            parent.addCommands({\n                cmd: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));\n                },\n                undo: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.removeLastElement());\n                },\n                mustExec: false,\n                type: AnnotationEditorParamsType.DRAW_STEP\n            });\n            return;\n        }\n        this.endDrawing(false);\n    }\n    static endDrawing(isAborted) {\n        const parent = this._currentParent;\n        if (!parent) {\n            return null;\n        }\n        parent.toggleDrawing(true);\n        parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);\n        if (!DrawingEditor.#currentDraw.isEmpty()) {\n            const { pageDimensions: [pageWidth, pageHeight], scale } = parent;\n            const editor = parent.createAndAddNewEditor({\n                offsetX: 0,\n                offsetY: 0\n            }, false, {\n                drawId: this._currentDrawId,\n                drawOutlines: DrawingEditor.#currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),\n                drawingOptions: DrawingEditor.#currentDrawingOptions,\n                mustBeCommitted: !isAborted\n            });\n            this._cleanup(true);\n            return editor;\n        }\n        parent.drawLayer.remove(this._currentDrawId);\n        this._cleanup(true);\n        return null;\n    }\n    createDrawingOptions(_data) {}\n    static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {\n        unreachable(\"Not implemented\");\n    }\n    static async deserialize(data, parent, uiManager) {\n        const { rawDims: { pageWidth, pageHeight, pageX, pageY } } = parent.viewport;\n        const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.createDrawingOptions(data);\n        editor.#createDrawOutlines({\n            drawOutlines\n        });\n        editor.#addToDrawLayer();\n        editor.onScaleChanging();\n        editor.rotate();\n        return editor;\n    }\n    serializeDraw(isForCopying) {\n        const [pageX, pageY] = this.pageTranslation;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        return this.#drawOutlines.serialize([\n            pageX,\n            pageY,\n            pageWidth,\n            pageHeight\n        ], isForCopying);\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getPDFRect()\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\n; // ./src/display/editor/drawers/inkdraw.js\nclass InkDrawOutliner {\n    #last;\n    #line;\n    #lines;\n    #rotation;\n    #thickness;\n    #points;\n    #lastSVGPath;\n    #lastIndex;\n    #outlines;\n    #parentWidth;\n    #parentHeight;\n    constructor(x, y, parentWidth, parentHeight, rotation, thickness){\n        this.#last = new Float64Array(6);\n        this.#lastSVGPath = \"\";\n        this.#lastIndex = 0;\n        this.#outlines = new InkDrawOutline();\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        this.#lines = [\n            {\n                line,\n                points: this.#points\n            }\n        ];\n        this.#last.set(line, 0);\n    }\n    updateProperty(name, value) {\n        if (name === \"stroke-width\") {\n            this.#thickness = value;\n        }\n    }\n    #normalizePoint(x, y) {\n        return Outline._normalizePoint(x, y, this.#parentWidth, this.#parentHeight, this.#rotation);\n    }\n    isEmpty() {\n        return !this.#lines || this.#lines.length === 0;\n    }\n    isCancellable() {\n        return this.#points.length <= 10;\n    }\n    add(x, y) {\n        [x, y] = this.#normalizePoint(x, y);\n        const [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);\n        if (d <= 2) {\n            return null;\n        }\n        this.#points.push(x, y);\n        if (isNaN(x1)) {\n            this.#last.set([\n                x2,\n                y2,\n                x,\n                y\n            ], 2);\n            this.#line.push(NaN, NaN, NaN, NaN, x, y);\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        if (isNaN(this.#last[0])) {\n            this.#line.splice(6, 6);\n        }\n        this.#last.set([\n            x1,\n            y1,\n            x2,\n            y2,\n            x,\n            y\n        ], 0);\n        this.#line.push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    end(x, y) {\n        const change = this.add(x, y);\n        if (change) {\n            return change;\n        }\n        if (this.#points.length === 2) {\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        return null;\n    }\n    startNew(x, y, parentWidth, parentHeight, rotation) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        const last = this.#lines.at(-1);\n        if (last) {\n            last.line = new Float32Array(last.line);\n            last.points = new Float32Array(last.points);\n        }\n        this.#lines.push({\n            line,\n            points: this.#points\n        });\n        this.#last.set(line, 0);\n        this.#lastIndex = 0;\n        this.toSVGPath();\n        return null;\n    }\n    getLastElement() {\n        return this.#lines.at(-1);\n    }\n    setLastElement(element) {\n        if (!this.#lines) {\n            return this.#outlines.setLastElement(element);\n        }\n        this.#lines.push(element);\n        this.#line = element.line;\n        this.#points = element.points;\n        this.#lastIndex = 0;\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        if (!this.#lines) {\n            return this.#outlines.removeLastElement();\n        }\n        this.#lines.pop();\n        this.#lastSVGPath = \"\";\n        for(let i = 0, ii = this.#lines.length; i < ii; i++){\n            const { line, points } = this.#lines[i];\n            this.#line = line;\n            this.#points = points;\n            this.#lastIndex = 0;\n            this.toSVGPath();\n        }\n        return {\n            path: {\n                d: this.#lastSVGPath\n            }\n        };\n    }\n    toSVGPath() {\n        const firstX = Outline.svgRound(this.#line[4]);\n        const firstY = Outline.svgRound(this.#line[5]);\n        if (this.#points.length === 2) {\n            this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;\n            return this.#lastSVGPath;\n        }\n        if (this.#points.length <= 6) {\n            const i = this.#lastSVGPath.lastIndexOf(\"M\");\n            this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i)} M ${firstX} ${firstY}`;\n            this.#lastIndex = 6;\n        }\n        if (this.#points.length === 4) {\n            const secondX = Outline.svgRound(this.#line[10]);\n            const secondY = Outline.svgRound(this.#line[11]);\n            this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;\n            this.#lastIndex = 12;\n            return this.#lastSVGPath;\n        }\n        const buffer = [];\n        if (this.#lastIndex === 0) {\n            buffer.push(`M ${firstX} ${firstY}`);\n            this.#lastIndex = 6;\n        }\n        for(let i = this.#lastIndex, ii = this.#line.length; i < ii; i += 6){\n            const [c1x, c1y, c2x, c2y, x, y] = this.#line.slice(i, i + 6).map(Outline.svgRound);\n            buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n        }\n        this.#lastSVGPath += buffer.join(\" \");\n        this.#lastIndex = this.#line.length;\n        return this.#lastSVGPath;\n    }\n    getOutlines(parentWidth, parentHeight, scale, innerMargin) {\n        const last = this.#lines.at(-1);\n        last.line = new Float32Array(last.line);\n        last.points = new Float32Array(last.points);\n        this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);\n        this.#last = null;\n        this.#line = null;\n        this.#lines = null;\n        this.#lastSVGPath = null;\n        return this.#outlines;\n    }\n    get defaultSVGProperties() {\n        return {\n            root: {\n                viewBox: \"0 0 10000 10000\"\n            },\n            rootClass: {\n                draw: true\n            },\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ]\n        };\n    }\n}\nclass InkDrawOutline extends Outline {\n    #bbox;\n    #currentRotation;\n    #innerMargin;\n    #lines;\n    #parentWidth;\n    #parentHeight;\n    #parentScale;\n    #rotation;\n    #thickness;\n    build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#parentScale = parentScale;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        this.#innerMargin = innerMargin ?? 0;\n        this.#lines = lines;\n        this.#computeBbox();\n    }\n    get thickness() {\n        return this.#thickness;\n    }\n    setLastElement(element) {\n        this.#lines.push(element);\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        this.#lines.pop();\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const { line } of this.#lines){\n            buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);\n            if (line.length === 6) {\n                buffer.push(\"Z\");\n                continue;\n            }\n            if (line.length === 12 && isNaN(line[6])) {\n                buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);\n                continue;\n            }\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);\n                buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n            }\n        }\n        return buffer.join(\"\");\n    }\n    serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {\n        const serializedLines = [];\n        const serializedPoints = [];\n        const [x, y, width, height] = this.#getBBoxWithNoMargin();\n        let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;\n        switch(this.#rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = pageX;\n                ty = pageY + pageHeight;\n                sx = pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + x * pageWidth;\n                y1 = pageY + (1 - y - height) * pageHeight;\n                x2 = pageX + (x + width) * pageWidth;\n                y2 = pageY + (1 - y) * pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX;\n                ty = pageY;\n                sx = pageWidth;\n                sy = pageHeight;\n                x1 = pageX + y * pageWidth;\n                y1 = pageY + x * pageHeight;\n                x2 = pageX + (y + height) * pageWidth;\n                y2 = pageY + (x + width) * pageHeight;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX + pageWidth;\n                ty = pageY;\n                sx = -pageWidth;\n                sy = pageHeight;\n                x1 = pageX + (1 - x - width) * pageWidth;\n                y1 = pageY + y * pageHeight;\n                x2 = pageX + (1 - x) * pageWidth;\n                y2 = pageY + (y + height) * pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX + pageWidth;\n                ty = pageY + pageHeight;\n                sx = -pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + (1 - y - height) * pageWidth;\n                y1 = pageY + (1 - x - width) * pageHeight;\n                x2 = pageX + (1 - y) * pageWidth;\n                y2 = pageY + (1 - x) * pageHeight;\n                break;\n        }\n        for (const { line, points } of this.#lines){\n            serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));\n            serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));\n        }\n        return {\n            lines: serializedLines,\n            points: serializedPoints,\n            rect: [\n                x1,\n                y1,\n                x2,\n                y2\n            ]\n        };\n    }\n    static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, { paths: { lines, points }, rotation, thickness }) {\n        const newLines = [];\n        let tx, ty, sx, sy, rescaleFn;\n        switch(rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = -pageX / pageWidth;\n                ty = pageY / pageHeight + 1;\n                sx = 1 / pageWidth;\n                sy = -1 / pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = -pageY / pageHeight;\n                ty = -pageX / pageWidth;\n                sx = 1 / pageHeight;\n                sy = 1 / pageWidth;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX / pageWidth + 1;\n                ty = -pageY / pageHeight;\n                sx = -1 / pageWidth;\n                sy = 1 / pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageY / pageHeight + 1;\n                ty = pageX / pageWidth + 1;\n                sx = -1 / pageHeight;\n                sy = -1 / pageWidth;\n                break;\n        }\n        if (!lines) {\n            lines = [];\n            for (const point of points){\n                const len = point.length;\n                if (len === 2) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1]\n                    ]));\n                    continue;\n                }\n                if (len === 4) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1],\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[2],\n                        point[3]\n                    ]));\n                    continue;\n                }\n                const line = new Float32Array(3 * (len - 2));\n                lines.push(line);\n                let [x1, y1, x2, y2] = point.subarray(0, 4);\n                line.set([\n                    NaN,\n                    NaN,\n                    NaN,\n                    NaN,\n                    x1,\n                    y1\n                ], 0);\n                for(let i = 4; i < len; i += 2){\n                    const x = point[i];\n                    const y = point[i + 1];\n                    line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n                    [x1, y1, x2, y2] = [\n                        x2,\n                        y2,\n                        x,\n                        y\n                    ];\n                }\n            }\n        }\n        for(let i = 0, ii = lines.length; i < ii; i++){\n            newLines.push({\n                line: rescaleFn(lines[i].map((x)=>x ?? NaN), tx, ty, sx, sy),\n                points: rescaleFn(points[i].map((x)=>x ?? NaN), tx, ty, sx, sy)\n            });\n        }\n        const outlines = new this.prototype.constructor();\n        outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);\n        return outlines;\n    }\n    #getMarginComponents(thickness = this.#thickness) {\n        const margin = this.#innerMargin + thickness / 2 * this.#parentScale;\n        return this.#rotation % 180 === 0 ? [\n            margin / this.#parentWidth,\n            margin / this.#parentHeight\n        ] : [\n            margin / this.#parentHeight,\n            margin / this.#parentWidth\n        ];\n    }\n    #getBBoxWithNoMargin() {\n        const [x, y, width, height] = this.#bbox;\n        const [marginX, marginY] = this.#getMarginComponents(0);\n        return [\n            x + marginX,\n            y + marginY,\n            width - 2 * marginX,\n            height - 2 * marginY\n        ];\n    }\n    #computeBbox() {\n        const bbox = this.#bbox = new Float32Array([\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ]);\n        for (const { line } of this.#lines){\n            if (line.length <= 12) {\n                for(let i = 4, ii = line.length; i < ii; i += 6){\n                    Util.pointBoundingBox(line[i], line[i + 1], bbox);\n                }\n                continue;\n            }\n            let lastX = line[4], lastY = line[5];\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);\n                Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);\n                lastX = x;\n                lastY = y;\n            }\n        }\n        const [marginX, marginY] = this.#getMarginComponents();\n        bbox[0] = MathClamp(bbox[0] - marginX, 0, 1);\n        bbox[1] = MathClamp(bbox[1] - marginY, 0, 1);\n        bbox[2] = MathClamp(bbox[2] + marginX, 0, 1);\n        bbox[3] = MathClamp(bbox[3] + marginY, 0, 1);\n        bbox[2] -= bbox[0];\n        bbox[3] -= bbox[1];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    updateProperty(name, value) {\n        if (name === \"stroke-width\") {\n            return this.#updateThickness(value);\n        }\n        return null;\n    }\n    #updateThickness(thickness) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#thickness = thickness;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const [diffMarginX, diffMarginY] = [\n            newMarginX - oldMarginX,\n            newMarginY - oldMarginY\n        ];\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateParentDimensions([width, height], scale) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#parentWidth = width;\n        this.#parentHeight = height;\n        this.#parentScale = scale;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const diffMarginX = newMarginX - oldMarginX;\n        const diffMarginY = newMarginY - oldMarginY;\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateRotation(rotation) {\n        this.#currentRotation = rotation;\n        return {\n            path: {\n                transform: this.rotationTransform\n            }\n        };\n    }\n    get viewBox() {\n        return this.#bbox.map(Outline.svgRound).join(\" \");\n    }\n    get defaultProperties() {\n        const [x, y] = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`\n            }\n        };\n    }\n    get rotationTransform() {\n        const [, , width, height] = this.#bbox;\n        let a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;\n        switch(this.#currentRotation){\n            case 90:\n                b = height / width;\n                c = -width / height;\n                e = width;\n                break;\n            case 180:\n                a = -1;\n                d = -1;\n                e = width;\n                f = height;\n                break;\n            case 270:\n                b = -height / width;\n                c = width / height;\n                f = height;\n                break;\n            default:\n                return \"\";\n        }\n        return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;\n    }\n    getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const [x, y, width, height] = this.#bbox;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx = newX + newWidth / 2 - (x + width / 2);\n            const ty = newY + newHeight / 2 - (y + height / 2);\n            return {\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: `${this.rotationTransform} translate(${tx} ${ty})`\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const s2x = width / newWidth;\n        const s2y = height / newHeight;\n        return {\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,\n                transform: `${this.rotationTransform} scale(${s2x} ${s2y}) ` + `translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) ` + `translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`\n            }\n        };\n    }\n    getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const bbox = this.#bbox;\n        const [x, y, width, height] = bbox;\n        bbox[0] = newX;\n        bbox[1] = newY;\n        bbox[2] = newWidth;\n        bbox[3] = newHeight;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx = newX + newWidth / 2 - (x + width / 2);\n            const ty = newY + newHeight / 2 - (y + height / 2);\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx, ty, line);\n                Outline._translate(points, tx, ty, points);\n            }\n            return {\n                root: {\n                    viewBox: this.viewBox\n                },\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: this.rotationTransform || null,\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const tx = -s1x * (x + marginX) + newX + marginX;\n        const ty = -s1y * (y + marginY) + newY + marginY;\n        if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, s1x, s1y, line);\n                Outline._rescale(points, tx, ty, s1x, s1y, points);\n            }\n        }\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                transform: this.rotationTransform || null,\n                d: this.toSVGPath()\n            }\n        };\n    }\n    getPathTranslatedSVGProperties([newX, newY], parentDimensions) {\n        const [newParentWidth, newParentHeight] = parentDimensions;\n        const bbox = this.#bbox;\n        const tx = newX - bbox[0];\n        const ty = newY - bbox[1];\n        if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) {\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx, ty, line);\n                Outline._translate(points, tx, ty, points);\n            }\n        } else {\n            const sx = this.#parentWidth / newParentWidth;\n            const sy = this.#parentHeight / newParentHeight;\n            this.#parentWidth = newParentWidth;\n            this.#parentHeight = newParentHeight;\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, sx, sy, line);\n                Outline._rescale(points, tx, ty, sx, sy, points);\n            }\n            bbox[2] *= sx;\n            bbox[3] *= sy;\n        }\n        bbox[0] = newX;\n        bbox[1] = newY;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`\n            }\n        };\n    }\n    get defaultSVGProperties() {\n        const bbox = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            rootClass: {\n                draw: true\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,\n                transform: this.rotationTransform || null\n            },\n            bbox\n        };\n    }\n    constructor(...args){\n        super(...args);\n        this.#currentRotation = 0;\n    }\n}\n; // ./src/display/editor/ink.js\nclass InkDrawingOptions extends DrawingOptions {\n    constructor(viewerParameters){\n        super();\n        this._viewParameters = viewerParameters;\n        super.updateProperties({\n            fill: \"none\",\n            stroke: AnnotationEditor._defaultLineColor,\n            \"stroke-opacity\": 1,\n            \"stroke-width\": 1,\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"round\",\n            \"stroke-miterlimit\": 10\n        });\n    }\n    updateSVGProperty(name, value) {\n        if (name === \"stroke-width\") {\n            value ??= this[\"stroke-width\"];\n            value *= this._viewParameters.realScale;\n        }\n        super.updateSVGProperty(name, value);\n    }\n    clone() {\n        const clone = new InkDrawingOptions(this._viewParameters);\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass InkEditor extends DrawingEditor {\n    static{\n        this._type = \"ink\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.INK;\n    }\n    static{\n        this._defaultDrawingOptions = null;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"inkEditor\"\n        });\n        this._willKeepAspectRatio = true;\n        this.defaultL10nId = \"pdfjs-editor-ink-editor\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);\n    }\n    static getDefaultDrawingOptions(options) {\n        const clone = this._defaultDrawingOptions.clone();\n        clone.updateProperties(options);\n        return clone;\n    }\n    static get supportMultipleDrawings() {\n        return true;\n    }\n    static get typesMap() {\n        return shadow(this, \"typesMap\", new Map([\n            [\n                AnnotationEditorParamsType.INK_THICKNESS,\n                \"stroke-width\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_COLOR,\n                \"stroke\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_OPACITY,\n                \"stroke-opacity\"\n            ]\n        ]));\n    }\n    static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {\n        return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions[\"stroke-width\"]);\n    }\n    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, opacity, borderStyle: { rawWidth: thickness }, popupRef, richText, contentsObj, creationDate, modificationDate }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.INK,\n                color: Array.from(color),\n                thickness,\n                opacity,\n                paths: {\n                    points: inkLists\n                },\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                popupRef,\n                richText,\n                comment: contentsObj?.str || null,\n                creationDate,\n                modificationDate\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data);\n        }\n        return editor;\n    }\n    get toolbarButtons() {\n        this._colorPicker ||= new BasicColorPicker(this);\n        return [\n            [\n                \"colorPicker\",\n                this._colorPicker\n            ]\n        ];\n    }\n    get colorType() {\n        return AnnotationEditorParamsType.INK_COLOR;\n    }\n    get color() {\n        return this._drawingOptions.stroke;\n    }\n    get opacity() {\n        return this._drawingOptions[\"stroke-opacity\"];\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        super.onScaleChanging();\n        const { _drawId, _drawingOptions, parent } = this;\n        _drawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());\n    }\n    static onScaleChangingWhenDrawing() {\n        const parent = this._currentParent;\n        if (!parent) {\n            return;\n        }\n        super.onScaleChangingWhenDrawing();\n        this._defaultDrawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n    }\n    createDrawingOptions({ color, thickness, opacity }) {\n        this._drawingOptions = InkEditor.getDefaultDrawingOptions({\n            stroke: Util.makeHexColor(...color),\n            \"stroke-width\": thickness,\n            \"stroke-opacity\": opacity\n        });\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const { lines, points } = this.serializeDraw(isForCopying);\n        const { _drawingOptions: { stroke, \"stroke-opacity\": opacity, \"stroke-width\": thickness } } = this;\n        const serialized = Object.assign(super.serialize(isForCopying), {\n            color: AnnotationEditor._colorManager.convert(stroke),\n            opacity,\n            thickness,\n            paths: {\n                lines,\n                points\n            }\n        });\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.isCopy = true;\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color, thickness, opacity, pageIndex } = this._initialData;\n        return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i)=>c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        const { points, rect } = this.serializeDraw(false);\n        annotation.updateEdited({\n            rect,\n            thickness: this._drawingOptions[\"stroke-width\"],\n            points,\n            popup: this.comment\n        });\n        return null;\n    }\n}\n; // ./src/display/editor/drawers/contour.js\nclass ContourDrawOutline extends InkDrawOutline {\n    toSVGPath() {\n        let path = super.toSVGPath();\n        if (!path.endsWith(\"Z\")) {\n            path += \"Z\";\n        }\n        return path;\n    }\n}\n; // ./src/display/editor/drawers/signaturedraw.js\nconst BASE_HEADER_LENGTH = 8;\nconst POINTS_PROPERTIES_NUMBER = 3;\nclass SignatureExtractor {\n    static #PARAMETERS = {\n        maxDim: 512,\n        sigmaSFactor: 0.02,\n        sigmaR: 25,\n        kernelSize: 16\n    };\n    static #neighborIndexToId(i0, j0, i, j) {\n        i -= i0;\n        j -= j0;\n        if (i === 0) {\n            return j > 0 ? 0 : 4;\n        }\n        if (i === 1) {\n            return j + 6;\n        }\n        return 2 - j;\n    }\n    static #neighborIdToIndex = new Int32Array([\n        0,\n        1,\n        -1,\n        1,\n        -1,\n        0,\n        -1,\n        -1,\n        0,\n        -1,\n        1,\n        -1,\n        1,\n        0,\n        1,\n        1\n    ]);\n    static #clockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n        const id = this.#neighborIndexToId(i0, j0, i, j);\n        for(let k = 0; k < 8; k++){\n            const kk = (-k + id - offset + 16) % 8;\n            const shiftI = this.#neighborIdToIndex[2 * kk];\n            const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n            if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n                return kk;\n            }\n        }\n        return -1;\n    }\n    static #counterClockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n        const id = this.#neighborIndexToId(i0, j0, i, j);\n        for(let k = 0; k < 8; k++){\n            const kk = (k + id + offset + 16) % 8;\n            const shiftI = this.#neighborIdToIndex[2 * kk];\n            const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n            if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n                return kk;\n            }\n        }\n        return -1;\n    }\n    static #findContours(buf, width, height, threshold) {\n        const N = buf.length;\n        const types = new Int32Array(N);\n        for(let i = 0; i < N; i++){\n            types[i] = buf[i] <= threshold ? 1 : 0;\n        }\n        for(let i = 1; i < height - 1; i++){\n            types[i * width] = types[i * width + width - 1] = 0;\n        }\n        for(let i = 0; i < width; i++){\n            types[i] = types[width * height - 1 - i] = 0;\n        }\n        let nbd = 1;\n        let lnbd;\n        const contours = [];\n        for(let i = 1; i < height - 1; i++){\n            lnbd = 1;\n            for(let j = 1; j < width - 1; j++){\n                const ij = i * width + j;\n                const pix = types[ij];\n                if (pix === 0) {\n                    continue;\n                }\n                let i2 = i;\n                let j2 = j;\n                if (pix === 1 && types[ij - 1] === 0) {\n                    nbd += 1;\n                    j2 -= 1;\n                } else if (pix >= 1 && types[ij + 1] === 0) {\n                    nbd += 1;\n                    j2 += 1;\n                    if (pix > 1) {\n                        lnbd = pix;\n                    }\n                } else {\n                    if (pix !== 1) {\n                        lnbd = Math.abs(pix);\n                    }\n                    continue;\n                }\n                const points = [\n                    j,\n                    i\n                ];\n                const isHole = j2 === j + 1;\n                const contour = {\n                    isHole,\n                    points,\n                    id: nbd,\n                    parent: 0\n                };\n                contours.push(contour);\n                let contour0;\n                for (const c of contours){\n                    if (c.id === lnbd) {\n                        contour0 = c;\n                        break;\n                    }\n                }\n                if (!contour0) {\n                    contour.parent = isHole ? lnbd : 0;\n                } else if (contour0.isHole) {\n                    contour.parent = isHole ? contour0.parent : lnbd;\n                } else {\n                    contour.parent = isHole ? lnbd : contour0.parent;\n                }\n                const k = this.#clockwiseNonZero(types, width, i, j, i2, j2, 0);\n                if (k === -1) {\n                    types[ij] = -nbd;\n                    if (types[ij] !== 1) {\n                        lnbd = Math.abs(types[ij]);\n                    }\n                    continue;\n                }\n                let shiftI = this.#neighborIdToIndex[2 * k];\n                let shiftJ = this.#neighborIdToIndex[2 * k + 1];\n                const i1 = i + shiftI;\n                const j1 = j + shiftJ;\n                i2 = i1;\n                j2 = j1;\n                let i3 = i;\n                let j3 = j;\n                while(true){\n                    const kk = this.#counterClockwiseNonZero(types, width, i3, j3, i2, j2, 1);\n                    shiftI = this.#neighborIdToIndex[2 * kk];\n                    shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n                    const i4 = i3 + shiftI;\n                    const j4 = j3 + shiftJ;\n                    points.push(j4, i4);\n                    const ij3 = i3 * width + j3;\n                    if (types[ij3 + 1] === 0) {\n                        types[ij3] = -nbd;\n                    } else if (types[ij3] === 1) {\n                        types[ij3] = nbd;\n                    }\n                    if (i4 === i && j4 === j && i3 === i1 && j3 === j1) {\n                        if (types[ij] !== 1) {\n                            lnbd = Math.abs(types[ij]);\n                        }\n                        break;\n                    } else {\n                        i2 = i3;\n                        j2 = j3;\n                        i3 = i4;\n                        j3 = j4;\n                    }\n                }\n            }\n        }\n        return contours;\n    }\n    static #douglasPeuckerHelper(points, start, end, output) {\n        if (end - start <= 4) {\n            for(let i = start; i < end - 2; i += 2){\n                output.push(points[i], points[i + 1]);\n            }\n            return;\n        }\n        const ax = points[start];\n        const ay = points[start + 1];\n        const abx = points[end - 4] - ax;\n        const aby = points[end - 3] - ay;\n        const dist = Math.hypot(abx, aby);\n        const nabx = abx / dist;\n        const naby = aby / dist;\n        const aa = nabx * ay - naby * ax;\n        const m = aby / abx;\n        const invS = 1 / dist;\n        const phi = Math.atan(m);\n        const cosPhi = Math.cos(phi);\n        const sinPhi = Math.sin(phi);\n        const tmax = invS * (Math.abs(cosPhi) + Math.abs(sinPhi));\n        const poly = invS * (1 - tmax + tmax ** 2);\n        const partialPhi = Math.max(Math.atan(Math.abs(sinPhi + cosPhi) * poly), Math.atan(Math.abs(sinPhi - cosPhi) * poly));\n        let dmax = 0;\n        let index = start;\n        for(let i = start + 2; i < end - 2; i += 2){\n            const d = Math.abs(aa - nabx * points[i + 1] + naby * points[i]);\n            if (d > dmax) {\n                index = i;\n                dmax = d;\n            }\n        }\n        if (dmax > (dist * partialPhi) ** 2) {\n            this.#douglasPeuckerHelper(points, start, index + 2, output);\n            this.#douglasPeuckerHelper(points, index, end, output);\n        } else {\n            output.push(ax, ay);\n        }\n    }\n    static #douglasPeucker(points) {\n        const output = [];\n        const len = points.length;\n        this.#douglasPeuckerHelper(points, 0, len, output);\n        output.push(points[len - 2], points[len - 1]);\n        return output.length <= 4 ? null : output;\n    }\n    static #bilateralFilter(buf, width, height, sigmaS, sigmaR, kernelSize) {\n        const kernel = new Float32Array(kernelSize ** 2);\n        const sigmaS2 = -2 * sigmaS ** 2;\n        const halfSize = kernelSize >> 1;\n        for(let i = 0; i < kernelSize; i++){\n            const x = (i - halfSize) ** 2;\n            for(let j = 0; j < kernelSize; j++){\n                kernel[i * kernelSize + j] = Math.exp((x + (j - halfSize) ** 2) / sigmaS2);\n            }\n        }\n        const rangeValues = new Float32Array(256);\n        const sigmaR2 = -2 * sigmaR ** 2;\n        for(let i = 0; i < 256; i++){\n            rangeValues[i] = Math.exp(i ** 2 / sigmaR2);\n        }\n        const N = buf.length;\n        const out = new Uint8Array(N);\n        const histogram = new Uint32Array(256);\n        for(let i = 0; i < height; i++){\n            for(let j = 0; j < width; j++){\n                const ij = i * width + j;\n                const center = buf[ij];\n                let sum = 0;\n                let norm = 0;\n                for(let k = 0; k < kernelSize; k++){\n                    const y = i + k - halfSize;\n                    if (y < 0 || y >= height) {\n                        continue;\n                    }\n                    for(let l = 0; l < kernelSize; l++){\n                        const x = j + l - halfSize;\n                        if (x < 0 || x >= width) {\n                            continue;\n                        }\n                        const neighbour = buf[y * width + x];\n                        const w = kernel[k * kernelSize + l] * rangeValues[Math.abs(neighbour - center)];\n                        sum += neighbour * w;\n                        norm += w;\n                    }\n                }\n                const pix = out[ij] = Math.round(sum / norm);\n                histogram[pix]++;\n            }\n        }\n        return [\n            out,\n            histogram\n        ];\n    }\n    static #getHistogram(buf) {\n        const histogram = new Uint32Array(256);\n        for (const g of buf){\n            histogram[g]++;\n        }\n        return histogram;\n    }\n    static #toUint8(buf) {\n        const N = buf.length;\n        const out = new Uint8ClampedArray(N >> 2);\n        let max = -Infinity;\n        let min = Infinity;\n        for(let i = 0, ii = out.length; i < ii; i++){\n            const pix = out[i] = buf[i << 2];\n            max = Math.max(max, pix);\n            min = Math.min(min, pix);\n        }\n        const ratio = 255 / (max - min);\n        for(let i = 0, ii = out.length; i < ii; i++){\n            out[i] = (out[i] - min) * ratio;\n        }\n        return out;\n    }\n    static #guessThreshold(histogram) {\n        let i;\n        let M = -Infinity;\n        let L = -Infinity;\n        const min = histogram.findIndex((v)=>v !== 0);\n        let pos = min;\n        let spos = min;\n        for(i = min; i < 256; i++){\n            const v = histogram[i];\n            if (v > M) {\n                if (i - pos > L) {\n                    L = i - pos;\n                    spos = i - 1;\n                }\n                M = v;\n                pos = i;\n            }\n        }\n        for(i = spos - 1; i >= 0; i--){\n            if (histogram[i] > histogram[i + 1]) {\n                break;\n            }\n        }\n        return i;\n    }\n    static #getGrayPixels(bitmap) {\n        const originalBitmap = bitmap;\n        const { width, height } = bitmap;\n        const { maxDim } = this.#PARAMETERS;\n        let newWidth = width;\n        let newHeight = height;\n        if (width > maxDim || height > maxDim) {\n            let prevWidth = width;\n            let prevHeight = height;\n            let steps = Math.log2(Math.max(width, height) / maxDim);\n            const isteps = Math.floor(steps);\n            steps = steps === isteps ? isteps - 1 : isteps;\n            for(let i = 0; i < steps; i++){\n                newWidth = Math.ceil(prevWidth / 2);\n                newHeight = Math.ceil(prevHeight / 2);\n                const offscreen = new OffscreenCanvas(newWidth, newHeight);\n                const ctx = offscreen.getContext(\"2d\");\n                ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n                prevWidth = newWidth;\n                prevHeight = newHeight;\n                if (bitmap !== originalBitmap) {\n                    bitmap.close();\n                }\n                bitmap = offscreen.transferToImageBitmap();\n            }\n            const ratio = Math.min(maxDim / newWidth, maxDim / newHeight);\n            newWidth = Math.round(newWidth * ratio);\n            newHeight = Math.round(newHeight * ratio);\n        }\n        const offscreen = new OffscreenCanvas(newWidth, newHeight);\n        const ctx = offscreen.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        ctx.fillStyle = \"white\";\n        ctx.fillRect(0, 0, newWidth, newHeight);\n        ctx.filter = \"grayscale(1)\";\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newWidth, newHeight);\n        const grayImage = ctx.getImageData(0, 0, newWidth, newHeight).data;\n        const uint8Buf = this.#toUint8(grayImage);\n        return [\n            uint8Buf,\n            newWidth,\n            newHeight\n        ];\n    }\n    static extractContoursFromText(text, { fontFamily, fontStyle, fontWeight }, pageWidth, pageHeight, rotation, innerMargin) {\n        let canvas = new OffscreenCanvas(1, 1);\n        let ctx = canvas.getContext(\"2d\", {\n            alpha: false\n        });\n        const fontSize = 200;\n        const font = ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n        const { actualBoundingBoxLeft, actualBoundingBoxRight, actualBoundingBoxAscent, actualBoundingBoxDescent, fontBoundingBoxAscent, fontBoundingBoxDescent, width } = ctx.measureText(text);\n        const SCALE = 1.5;\n        const canvasWidth = Math.ceil(Math.max(Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) || 0, width) * SCALE);\n        const canvasHeight = Math.ceil(Math.max(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent) || fontSize, Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || fontSize) * SCALE);\n        canvas = new OffscreenCanvas(canvasWidth, canvasHeight);\n        ctx = canvas.getContext(\"2d\", {\n            alpha: true,\n            willReadFrequently: true\n        });\n        ctx.font = font;\n        ctx.filter = \"grayscale(1)\";\n        ctx.fillStyle = \"white\";\n        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n        ctx.fillStyle = \"black\";\n        ctx.fillText(text, canvasWidth * (SCALE - 1) / 2, canvasHeight * (3 - SCALE) / 2);\n        const uint8Buf = this.#toUint8(ctx.getImageData(0, 0, canvasWidth, canvasHeight).data);\n        const histogram = this.#getHistogram(uint8Buf);\n        const threshold = this.#guessThreshold(histogram);\n        const contourList = this.#findContours(uint8Buf, canvasWidth, canvasHeight, threshold);\n        return this.processDrawnLines({\n            lines: {\n                curves: contourList,\n                width: canvasWidth,\n                height: canvasHeight\n            },\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin,\n            mustSmooth: true,\n            areContours: true\n        });\n    }\n    static process(bitmap, pageWidth, pageHeight, rotation, innerMargin) {\n        const [uint8Buf, width, height] = this.#getGrayPixels(bitmap);\n        const [buffer, histogram] = this.#bilateralFilter(uint8Buf, width, height, Math.hypot(width, height) * this.#PARAMETERS.sigmaSFactor, this.#PARAMETERS.sigmaR, this.#PARAMETERS.kernelSize);\n        const threshold = this.#guessThreshold(histogram);\n        const contourList = this.#findContours(buffer, width, height, threshold);\n        return this.processDrawnLines({\n            lines: {\n                curves: contourList,\n                width,\n                height\n            },\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin,\n            mustSmooth: true,\n            areContours: true\n        });\n    }\n    static processDrawnLines({ lines, pageWidth, pageHeight, rotation, innerMargin, mustSmooth, areContours }) {\n        if (rotation % 180 !== 0) {\n            [pageWidth, pageHeight] = [\n                pageHeight,\n                pageWidth\n            ];\n        }\n        const { curves, width, height } = lines;\n        const thickness = lines.thickness ?? 0;\n        const linesAndPoints = [];\n        const ratio = Math.min(pageWidth / width, pageHeight / height);\n        const xScale = ratio / pageWidth;\n        const yScale = ratio / pageHeight;\n        const newCurves = [];\n        for (const { points } of curves){\n            const reducedPoints = mustSmooth ? this.#douglasPeucker(points) : points;\n            if (!reducedPoints) {\n                continue;\n            }\n            newCurves.push(reducedPoints);\n            const len = reducedPoints.length;\n            const newPoints = new Float32Array(len);\n            const line = new Float32Array(3 * (len === 2 ? 2 : len - 2));\n            linesAndPoints.push({\n                line,\n                points: newPoints\n            });\n            if (len === 2) {\n                newPoints[0] = reducedPoints[0] * xScale;\n                newPoints[1] = reducedPoints[1] * yScale;\n                line.set([\n                    NaN,\n                    NaN,\n                    NaN,\n                    NaN,\n                    newPoints[0],\n                    newPoints[1]\n                ], 0);\n                continue;\n            }\n            let [x1, y1, x2, y2] = reducedPoints;\n            x1 *= xScale;\n            y1 *= yScale;\n            x2 *= xScale;\n            y2 *= yScale;\n            newPoints.set([\n                x1,\n                y1,\n                x2,\n                y2\n            ], 0);\n            line.set([\n                NaN,\n                NaN,\n                NaN,\n                NaN,\n                x1,\n                y1\n            ], 0);\n            for(let i = 4; i < len; i += 2){\n                const x = newPoints[i] = reducedPoints[i] * xScale;\n                const y = newPoints[i + 1] = reducedPoints[i + 1] * yScale;\n                line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n                [x1, y1, x2, y2] = [\n                    x2,\n                    y2,\n                    x,\n                    y\n                ];\n            }\n        }\n        if (linesAndPoints.length === 0) {\n            return null;\n        }\n        const outline = areContours ? new ContourDrawOutline() : new InkDrawOutline();\n        outline.build(linesAndPoints, pageWidth, pageHeight, 1, rotation, areContours ? 0 : thickness, innerMargin);\n        return {\n            outline,\n            newCurves,\n            areContours,\n            thickness,\n            width,\n            height\n        };\n    }\n    static async compressSignature({ outlines, areContours, thickness, width, height }) {\n        let minDiff = Infinity;\n        let maxDiff = -Infinity;\n        let outlinesLength = 0;\n        for (const points of outlines){\n            outlinesLength += points.length;\n            for(let i = 2, ii = points.length; i < ii; i++){\n                const dx = points[i] - points[i - 2];\n                minDiff = Math.min(minDiff, dx);\n                maxDiff = Math.max(maxDiff, dx);\n            }\n        }\n        let bufferType;\n        if (minDiff >= -128 && maxDiff <= 127) {\n            bufferType = Int8Array;\n        } else if (minDiff >= -32768 && maxDiff <= 32767) {\n            bufferType = Int16Array;\n        } else {\n            bufferType = Int32Array;\n        }\n        const len = outlines.length;\n        const headerLength = BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * len;\n        const header = new Uint32Array(headerLength);\n        let offset = 0;\n        header[offset++] = headerLength * Uint32Array.BYTES_PER_ELEMENT + (outlinesLength - 2 * len) * bufferType.BYTES_PER_ELEMENT;\n        header[offset++] = 0;\n        header[offset++] = width;\n        header[offset++] = height;\n        header[offset++] = areContours ? 0 : 1;\n        header[offset++] = Math.max(0, Math.floor(thickness ?? 0));\n        header[offset++] = len;\n        header[offset++] = bufferType.BYTES_PER_ELEMENT;\n        for (const points of outlines){\n            header[offset++] = points.length - 2;\n            header[offset++] = points[0];\n            header[offset++] = points[1];\n        }\n        const cs = new CompressionStream(\"deflate-raw\");\n        const writer = cs.writable.getWriter();\n        await writer.ready;\n        writer.write(header);\n        const BufferCtor = bufferType.prototype.constructor;\n        for (const points of outlines){\n            const diffs = new BufferCtor(points.length - 2);\n            for(let i = 2, ii = points.length; i < ii; i++){\n                diffs[i - 2] = points[i] - points[i - 2];\n            }\n            writer.write(diffs);\n        }\n        writer.close();\n        const buf = await new Response(cs.readable).arrayBuffer();\n        const bytes = new Uint8Array(buf);\n        return toBase64Util(bytes);\n    }\n    static async decompressSignature(signatureData) {\n        try {\n            const bytes = fromBase64Util(signatureData);\n            const { readable, writable } = new DecompressionStream(\"deflate-raw\");\n            const writer = writable.getWriter();\n            await writer.ready;\n            writer.write(bytes).then(async ()=>{\n                await writer.ready;\n                await writer.close();\n            }).catch(()=>{});\n            let data = null;\n            let offset = 0;\n            for await (const chunk of readable){\n                data ||= new Uint8Array(new Uint32Array(chunk.buffer, 0, 4)[0]);\n                data.set(chunk, offset);\n                offset += chunk.length;\n            }\n            const header = new Uint32Array(data.buffer, 0, data.length >> 2);\n            const version = header[1];\n            if (version !== 0) {\n                throw new Error(`Invalid version: ${version}`);\n            }\n            const width = header[2];\n            const height = header[3];\n            const areContours = header[4] === 0;\n            const thickness = header[5];\n            const numberOfDrawings = header[6];\n            const bufferType = header[7];\n            const outlines = [];\n            const diffsOffset = (BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * numberOfDrawings) * Uint32Array.BYTES_PER_ELEMENT;\n            let diffs;\n            switch(bufferType){\n                case Int8Array.BYTES_PER_ELEMENT:\n                    diffs = new Int8Array(data.buffer, diffsOffset);\n                    break;\n                case Int16Array.BYTES_PER_ELEMENT:\n                    diffs = new Int16Array(data.buffer, diffsOffset);\n                    break;\n                case Int32Array.BYTES_PER_ELEMENT:\n                    diffs = new Int32Array(data.buffer, diffsOffset);\n                    break;\n            }\n            offset = 0;\n            for(let i = 0; i < numberOfDrawings; i++){\n                const len = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH];\n                const points = new Float32Array(len + 2);\n                outlines.push(points);\n                for(let j = 0; j < POINTS_PROPERTIES_NUMBER - 1; j++){\n                    points[j] = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH + j + 1];\n                }\n                for(let j = 0; j < len; j++){\n                    points[j + 2] = points[j] + diffs[offset++];\n                }\n            }\n            return {\n                areContours,\n                thickness,\n                outlines,\n                width,\n                height\n            };\n        } catch (e) {\n            warn(`decompressSignature: ${e}`);\n            return null;\n        }\n    }\n}\n; // ./src/display/editor/signature.js\nclass SignatureOptions extends DrawingOptions {\n    constructor(){\n        super();\n        super.updateProperties({\n            fill: AnnotationEditor._defaultLineColor,\n            \"stroke-width\": 0\n        });\n    }\n    clone() {\n        const clone = new SignatureOptions();\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass DrawnSignatureOptions extends InkDrawingOptions {\n    constructor(viewerParameters){\n        super(viewerParameters);\n        super.updateProperties({\n            stroke: AnnotationEditor._defaultLineColor,\n            \"stroke-width\": 1\n        });\n    }\n    clone() {\n        const clone = new DrawnSignatureOptions(this._viewParameters);\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass SignatureEditor extends DrawingEditor {\n    #isExtracted;\n    #description;\n    #signatureData;\n    #signatureUUID;\n    static{\n        this._type = \"signature\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.SIGNATURE;\n    }\n    static{\n        this._defaultDrawingOptions = null;\n    }\n    constructor(params){\n        super({\n            ...params,\n            mustBeCommitted: true,\n            name: \"signatureEditor\"\n        });\n        this.#isExtracted = false;\n        this.#description = null;\n        this.#signatureData = null;\n        this.#signatureUUID = null;\n        this._willKeepAspectRatio = true;\n        this.#signatureData = params.signatureData || null;\n        this.#description = null;\n        this.defaultL10nId = \"pdfjs-editor-signature-editor1\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        this._defaultDrawingOptions = new SignatureOptions();\n        this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(uiManager.viewParameters);\n    }\n    static getDefaultDrawingOptions(options) {\n        const clone = this._defaultDrawingOptions.clone();\n        clone.updateProperties(options);\n        return clone;\n    }\n    static get supportMultipleDrawings() {\n        return false;\n    }\n    static get typesMap() {\n        return shadow(this, \"typesMap\", new Map());\n    }\n    static get isDrawer() {\n        return false;\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"signature\",\n            hasDescription: !!this.#description\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        const hasDescriptionStats = data.get(\"hasDescription\");\n        return {\n            hasAltText: hasDescriptionStats.get(true) ?? 0,\n            hasNoAltText: hasDescriptionStats.get(false) ?? 0\n        };\n    }\n    get isResizable() {\n        return true;\n    }\n    onScaleChanging() {\n        if (this._drawId === null) {\n            return;\n        }\n        super.onScaleChanging();\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        const { _isCopy } = this;\n        if (_isCopy) {\n            this._isCopy = false;\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        if (this._drawId === null) {\n            if (this.#signatureData) {\n                const { lines, mustSmooth, areContours, description, uuid, heightInPage } = this.#signatureData;\n                const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n                const outline = SignatureExtractor.processDrawnLines({\n                    lines,\n                    pageWidth,\n                    pageHeight,\n                    rotation,\n                    innerMargin: SignatureEditor._INNER_MARGIN,\n                    mustSmooth,\n                    areContours\n                });\n                this.addSignature(outline, heightInPage, description, uuid);\n            } else {\n                this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n                    description: \"\"\n                }));\n                this.div.hidden = true;\n                this._uiManager.getSignature(this);\n            }\n        } else {\n            this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n                description: this.#description || \"\"\n            }));\n        }\n        if (_isCopy) {\n            this._isCopy = true;\n            this._moveAfterPaste(baseX, baseY);\n        }\n        return this.div;\n    }\n    setUuid(uuid) {\n        this.#signatureUUID = uuid;\n        this.addEditToolbar();\n    }\n    getUuid() {\n        return this.#signatureUUID;\n    }\n    get description() {\n        return this.#description;\n    }\n    set description(description) {\n        this.#description = description;\n        if (!this.div) {\n            return;\n        }\n        this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n            description\n        }));\n        super.addEditToolbar().then((toolbar)=>{\n            toolbar?.updateEditSignatureButton(description);\n        });\n    }\n    getSignaturePreview() {\n        const { newCurves, areContours, thickness, width, height } = this.#signatureData;\n        const maxDim = Math.max(width, height);\n        const outlineData = SignatureExtractor.processDrawnLines({\n            lines: {\n                curves: newCurves.map((points)=>({\n                        points\n                    })),\n                thickness,\n                width,\n                height\n            },\n            pageWidth: maxDim,\n            pageHeight: maxDim,\n            rotation: 0,\n            innerMargin: 0,\n            mustSmooth: false,\n            areContours\n        });\n        return {\n            areContours,\n            outline: outlineData.outline\n        };\n    }\n    get toolbarButtons() {\n        if (this._uiManager.signatureManager) {\n            return [\n                [\n                    \"editSignature\",\n                    this._uiManager.signatureManager\n                ]\n            ];\n        }\n        return super.toolbarButtons;\n    }\n    addSignature(data, heightInPage, description, uuid) {\n        const { x: savedX, y: savedY } = this;\n        const { outline } = this.#signatureData = data;\n        this.#isExtracted = outline instanceof ContourDrawOutline;\n        this.description = description;\n        let drawingOptions;\n        if (this.#isExtracted) {\n            drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n        } else {\n            drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n            drawingOptions.updateProperties({\n                \"stroke-width\": outline.thickness\n            });\n        }\n        this._addOutlines({\n            drawOutlines: outline,\n            drawingOptions\n        });\n        const [, pageHeight] = this.pageDimensions;\n        let newHeight = heightInPage / pageHeight;\n        newHeight = newHeight >= 1 ? 0.5 : newHeight;\n        this.width *= newHeight / this.height;\n        if (this.width >= 1) {\n            newHeight *= 0.9 / this.width;\n            this.width = 0.9;\n        }\n        this.height = newHeight;\n        this.setDims();\n        this.x = savedX;\n        this.y = savedY;\n        this.center();\n        this._onResized();\n        this.onScaleChanging();\n        this.rotate();\n        this._uiManager.addToAnnotationStorage(this);\n        this.setUuid(uuid);\n        this._reportTelemetry({\n            action: \"pdfjs.signature.inserted\",\n            data: {\n                hasBeenSaved: !!uuid,\n                hasDescription: !!description\n            }\n        });\n        this.div.hidden = false;\n    }\n    getFromImage(bitmap) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.process(bitmap, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n    }\n    getFromText(text, fontInfo) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.extractContoursFromText(text, fontInfo, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n    }\n    getDrawnSignature(curves) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.processDrawnLines({\n            lines: curves,\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin: SignatureEditor._INNER_MARGIN,\n            mustSmooth: false,\n            areContours: false\n        });\n    }\n    createDrawingOptions({ areContours, thickness }) {\n        if (areContours) {\n            this._drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n        } else {\n            this._drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n            this._drawingOptions.updateProperties({\n                \"stroke-width\": thickness\n            });\n        }\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        const { lines, points } = this.serializeDraw(isForCopying);\n        const { _drawingOptions: { \"stroke-width\": thickness } } = this;\n        const serialized = Object.assign(super.serialize(isForCopying), {\n            isSignature: true,\n            areContours: this.#isExtracted,\n            color: [\n                0,\n                0,\n                0\n            ],\n            thickness: this.#isExtracted ? 0 : thickness\n        });\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.paths = {\n                lines,\n                points\n            };\n            serialized.uuid = this.#signatureUUID;\n            serialized.isCopy = true;\n        } else {\n            serialized.lines = lines;\n        }\n        if (this.#description) {\n            serialized.accessibilityData = {\n                type: \"Figure\",\n                alt: this.#description\n            };\n        }\n        return serialized;\n    }\n    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n        if (data.areContours) {\n            return ContourDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n        }\n        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    static async deserialize(data, parent, uiManager) {\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.#isExtracted = data.areContours;\n        editor.description = data.accessibilityData?.alt || \"\";\n        editor.#signatureUUID = data.uuid;\n        return editor;\n    }\n}\n; // ./src/display/editor/stamp.js\nclass StampEditor extends AnnotationEditor {\n    #bitmap;\n    #bitmapId;\n    #bitmapPromise;\n    #bitmapUrl;\n    #bitmapFile;\n    #bitmapFileName;\n    #canvas;\n    #missingCanvas;\n    #resizeTimeoutId;\n    #isSvg;\n    #hasBeenAddedInUndoStack;\n    static{\n        this._type = \"stamp\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.STAMP;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"stampEditor\"\n        });\n        this.#bitmap = null;\n        this.#bitmapId = null;\n        this.#bitmapPromise = null;\n        this.#bitmapUrl = null;\n        this.#bitmapFile = null;\n        this.#bitmapFileName = \"\";\n        this.#canvas = null;\n        this.#missingCanvas = false;\n        this.#resizeTimeoutId = null;\n        this.#isSvg = false;\n        this.#hasBeenAddedInUndoStack = false;\n        this.#bitmapUrl = params.bitmapUrl;\n        this.#bitmapFile = params.bitmapFile;\n        this.defaultL10nId = \"pdfjs-editor-stamp-editor\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n    }\n    static isHandlingMimeForPasting(mime) {\n        return SupportedImageMimeTypes.includes(mime);\n    }\n    static paste(item, parent) {\n        parent.pasteEditor({\n            mode: AnnotationEditorType.STAMP\n        }, {\n            bitmapFile: item.getAsFile()\n        });\n    }\n    altTextFinish() {\n        if (this._uiManager.useNewAltTextFlow) {\n            this.div.hidden = false;\n        }\n        super.altTextFinish();\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"stamp\",\n            hasAltText: !!this.altTextData?.altText\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        const hasAltTextStats = data.get(\"hasAltText\");\n        return {\n            hasAltText: hasAltTextStats.get(true) ?? 0,\n            hasNoAltText: hasAltTextStats.get(false) ?? 0\n        };\n    }\n    #getBitmapFetched(data, fromId = false) {\n        if (!data) {\n            this.remove();\n            return;\n        }\n        this.#bitmap = data.bitmap;\n        if (!fromId) {\n            this.#bitmapId = data.id;\n            this.#isSvg = data.isSvg;\n        }\n        if (data.file) {\n            this.#bitmapFileName = data.file.name;\n        }\n        this.#createCanvas();\n    }\n    #getBitmapDone() {\n        this.#bitmapPromise = null;\n        this._uiManager.enableWaiting(false);\n        if (!this.#canvas) {\n            return;\n        }\n        if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this.addEditToolbar().then(()=>{\n                this._editToolbar.hide();\n                this._uiManager.editAltText(this, true);\n            });\n            return;\n        }\n        if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this._reportTelemetry({\n                action: \"pdfjs.image.image_added\",\n                data: {\n                    alt_text_modal: false,\n                    alt_text_type: \"empty\"\n                }\n            });\n            try {\n                this.mlGuessAltText();\n            } catch  {}\n        }\n        this.div.focus();\n    }\n    async mlGuessAltText(imageData = null, updateAltTextData = true) {\n        if (this.hasAltTextData()) {\n            return null;\n        }\n        const { mlManager } = this._uiManager;\n        if (!mlManager) {\n            throw new Error(\"No ML.\");\n        }\n        if (!await mlManager.isEnabledFor(\"altText\")) {\n            throw new Error(\"ML isn't enabled for alt text.\");\n        }\n        const { data, width, height } = imageData || this.copyCanvas(null, null, true).imageData;\n        const response = await mlManager.guess({\n            name: \"altText\",\n            request: {\n                data,\n                width,\n                height,\n                channels: data.length / (width * height)\n            }\n        });\n        if (!response) {\n            throw new Error(\"No response from the AI service.\");\n        }\n        if (response.error) {\n            throw new Error(\"Error from the AI service.\");\n        }\n        if (response.cancel) {\n            return null;\n        }\n        if (!response.output) {\n            throw new Error(\"No valid response from the AI service.\");\n        }\n        const altText = response.output;\n        await this.setGuessedAltText(altText);\n        if (updateAltTextData && !this.hasAltTextData()) {\n            this.altTextData = {\n                alt: altText,\n                decorative: false\n            };\n        }\n        return altText;\n    }\n    #getBitmap() {\n        if (this.#bitmapId) {\n            this._uiManager.enableWaiting(true);\n            this._uiManager.imageManager.getFromId(this.#bitmapId).then((data)=>this.#getBitmapFetched(data, true)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapUrl) {\n            const url = this.#bitmapUrl;\n            this.#bitmapUrl = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapFile) {\n            const file = this.#bitmapFile;\n            this.#bitmapFile = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        const input = document.createElement(\"input\");\n        input.type = \"file\";\n        input.accept = SupportedImageMimeTypes.join(\",\");\n        const signal = this._uiManager._signal;\n        this.#bitmapPromise = new Promise((resolve)=>{\n            input.addEventListener(\"change\", async ()=>{\n                if (!input.files || input.files.length === 0) {\n                    this.remove();\n                } else {\n                    this._uiManager.enableWaiting(true);\n                    const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n                    this._reportTelemetry({\n                        action: \"pdfjs.image.image_selected\",\n                        data: {\n                            alt_text_modal: this._uiManager.useNewAltTextFlow\n                        }\n                    });\n                    this.#getBitmapFetched(data);\n                }\n                resolve();\n            }, {\n                signal\n            });\n            input.addEventListener(\"cancel\", ()=>{\n                this.remove();\n                resolve();\n            }, {\n                signal\n            });\n        }).finally(()=>this.#getBitmapDone());\n        input.click();\n    }\n    remove() {\n        if (this.#bitmapId) {\n            this.#bitmap = null;\n            this._uiManager.imageManager.deleteId(this.#bitmapId);\n            this.#canvas?.remove();\n            this.#canvas = null;\n            if (this.#resizeTimeoutId) {\n                clearTimeout(this.#resizeTimeoutId);\n                this.#resizeTimeoutId = null;\n            }\n        }\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            if (this.#bitmapId) {\n                this.#getBitmap();\n            }\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (this.#bitmapId && this.#canvas === null) {\n            this.#getBitmap();\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    onceAdded(focus) {\n        this._isDraggable = true;\n        if (focus) {\n            this.div.focus();\n        }\n    }\n    isEmpty() {\n        return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId || this.#missingCanvas);\n    }\n    get toolbarButtons() {\n        return [\n            [\n                \"altText\",\n                this.createAltText()\n            ]\n        ];\n    }\n    get isResizable() {\n        return true;\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.div.hidden = true;\n        this.createAltText();\n        if (!this.#missingCanvas) {\n            if (this.#bitmap) {\n                this.#createCanvas();\n            } else {\n                this.#getBitmap();\n            }\n        }\n        if (this._isCopy) {\n            this._moveAfterPaste(baseX, baseY);\n        }\n        this._uiManager.addShouldRescale(this);\n        return this.div;\n    }\n    setCanvas(annotationElementId, canvas) {\n        const { id: bitmapId, bitmap } = this._uiManager.imageManager.getFromCanvas(annotationElementId, canvas);\n        canvas.remove();\n        if (bitmapId && this._uiManager.imageManager.isValidId(bitmapId)) {\n            this.#bitmapId = bitmapId;\n            if (bitmap) {\n                this.#bitmap = bitmap;\n            }\n            this.#missingCanvas = false;\n            this.#createCanvas();\n        }\n    }\n    _onResized() {\n        this.onScaleChanging();\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        if (this.#resizeTimeoutId !== null) {\n            clearTimeout(this.#resizeTimeoutId);\n        }\n        const TIME_TO_WAIT = 200;\n        this.#resizeTimeoutId = setTimeout(()=>{\n            this.#resizeTimeoutId = null;\n            this.#drawBitmap();\n        }, TIME_TO_WAIT);\n    }\n    #createCanvas() {\n        const { div } = this;\n        let { width, height } = this.#bitmap;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const MAX_RATIO = 0.75;\n        if (this.width) {\n            width = this.width * pageWidth;\n            height = this.height * pageHeight;\n        } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n            const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n            width *= factor;\n            height *= factor;\n        }\n        this._uiManager.enableWaiting(false);\n        const canvas = this.#canvas = document.createElement(\"canvas\");\n        canvas.setAttribute(\"role\", \"img\");\n        this.addContainer(canvas);\n        this.width = width / pageWidth;\n        this.height = height / pageHeight;\n        this.setDims();\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        } else {\n            this.fixAndSetPosition();\n        }\n        this._initialOptions = null;\n        if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {\n            div.hidden = false;\n        }\n        this.#drawBitmap();\n        if (!this.#hasBeenAddedInUndoStack) {\n            this.parent.addUndoableEditor(this);\n            this.#hasBeenAddedInUndoStack = true;\n        }\n        this._reportTelemetry({\n            action: \"inserted_image\"\n        });\n        if (this.#bitmapFileName) {\n            this.div.setAttribute(\"aria-description\", this.#bitmapFileName);\n        }\n        if (!this.annotationElementId) {\n            this._uiManager.a11yAlert(\"pdfjs-editor-stamp-added-alert\");\n        }\n    }\n    copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {\n        if (!maxDataDimension) {\n            maxDataDimension = 224;\n        }\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        const outputScale = new OutputScale();\n        let bitmap = this.#bitmap;\n        let width = bitmapWidth, height = bitmapHeight;\n        let canvas = null;\n        if (maxPreviewDimension) {\n            if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {\n                const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);\n                width = Math.floor(bitmapWidth * ratio);\n                height = Math.floor(bitmapHeight * ratio);\n            }\n            canvas = document.createElement(\"canvas\");\n            const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);\n            const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);\n            if (!this.#isSvg) {\n                bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);\n            }\n            const ctx = canvas.getContext(\"2d\");\n            ctx.filter = this._uiManager.hcmFilter;\n            let white = \"white\", black = \"#cfcfd8\";\n            if (this._uiManager.hcmFilter !== \"none\") {\n                black = \"black\";\n            } else if (ColorScheme.isDarkMode) {\n                white = \"#8f8f9d\";\n                black = \"#42414d\";\n            }\n            const boxDim = 15;\n            const boxDimWidth = boxDim * outputScale.sx;\n            const boxDimHeight = boxDim * outputScale.sy;\n            const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);\n            const patternCtx = pattern.getContext(\"2d\");\n            patternCtx.fillStyle = white;\n            patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);\n            patternCtx.fillStyle = black;\n            patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);\n            patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);\n            ctx.fillStyle = ctx.createPattern(pattern, \"repeat\");\n            ctx.fillRect(0, 0, scaledWidth, scaledHeight);\n            ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n        }\n        let imageData = null;\n        if (createImageData) {\n            let dataWidth, dataHeight;\n            if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {\n                dataWidth = bitmap.width;\n                dataHeight = bitmap.height;\n            } else {\n                bitmap = this.#bitmap;\n                if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {\n                    const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);\n                    dataWidth = Math.floor(bitmapWidth * ratio);\n                    dataHeight = Math.floor(bitmapHeight * ratio);\n                    if (!this.#isSvg) {\n                        bitmap = this.#scaleBitmap(dataWidth, dataHeight);\n                    }\n                }\n            }\n            const offscreen = new OffscreenCanvas(dataWidth, dataHeight);\n            const offscreenCtx = offscreen.getContext(\"2d\", {\n                willReadFrequently: true\n            });\n            offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);\n            imageData = {\n                width: dataWidth,\n                height: dataHeight,\n                data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data\n            };\n        }\n        return {\n            canvas,\n            width,\n            height,\n            imageData\n        };\n    }\n    #scaleBitmap(width, height) {\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        let newWidth = bitmapWidth;\n        let newHeight = bitmapHeight;\n        let bitmap = this.#bitmap;\n        while(newWidth > 2 * width || newHeight > 2 * height){\n            const prevWidth = newWidth;\n            const prevHeight = newHeight;\n            if (newWidth > 2 * width) {\n                newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n            }\n            if (newHeight > 2 * height) {\n                newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n            }\n            const offscreen = new OffscreenCanvas(newWidth, newHeight);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n            bitmap = offscreen.transferToImageBitmap();\n        }\n        return bitmap;\n    }\n    #drawBitmap() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { width, height } = this;\n        const outputScale = new OutputScale();\n        const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);\n        const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);\n        const canvas = this.#canvas;\n        if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {\n            return;\n        }\n        canvas.width = scaledWidth;\n        canvas.height = scaledHeight;\n        const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);\n        const ctx = canvas.getContext(\"2d\");\n        ctx.filter = this._uiManager.hcmFilter;\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n    }\n    #serializeBitmap(toUrl) {\n        if (toUrl) {\n            if (this.#isSvg) {\n                const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n                if (url) {\n                    return url;\n                }\n            }\n            const canvas = document.createElement(\"canvas\");\n            ({ width: canvas.width, height: canvas.height } = this.#bitmap);\n            const ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0);\n            return canvas.toDataURL();\n        }\n        if (this.#isSvg) {\n            const [pageWidth, pageHeight] = this.pageDimensions;\n            const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const offscreen = new OffscreenCanvas(width, height);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n            return offscreen.transferToImageBitmap();\n        }\n        return structuredClone(this.#bitmap);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        let missingCanvas = false;\n        if (data instanceof StampAnnotationElement) {\n            const { data: { rect, rotation, id, structParent, popupRef, richText, contentsObj, creationDate, modificationDate }, container, parent: { page: { pageNumber } }, canvas } = data;\n            let bitmapId, bitmap;\n            if (canvas) {\n                delete data.canvas;\n                ({ id: bitmapId, bitmap } = uiManager.imageManager.getFromCanvas(container.id, canvas));\n                canvas.remove();\n            } else {\n                missingCanvas = true;\n                data._hasNoCanvas = true;\n            }\n            const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get(\"aria-label\") || \"\";\n            initialData = data = {\n                annotationType: AnnotationEditorType.STAMP,\n                bitmapId,\n                bitmap,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                annotationElementId: id,\n                id,\n                deleted: false,\n                accessibilityData: {\n                    decorative: false,\n                    altText\n                },\n                isSvg: false,\n                structParent,\n                popupRef,\n                richText,\n                comment: contentsObj?.str || null,\n                creationDate,\n                modificationDate\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        const { rect, bitmap, bitmapUrl, bitmapId, isSvg, accessibilityData } = data;\n        if (missingCanvas) {\n            uiManager.addMissingCanvas(data.id, editor);\n            editor.#missingCanvas = true;\n        } else if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n            editor.#bitmapId = bitmapId;\n            if (bitmap) {\n                editor.#bitmap = bitmap;\n            }\n        } else {\n            editor.#bitmapUrl = bitmapUrl;\n        }\n        editor.#isSvg = isSvg;\n        const [parentWidth, parentHeight] = editor.pageDimensions;\n        editor.width = (rect[2] - rect[0]) / parentWidth;\n        editor.height = (rect[3] - rect[1]) / parentHeight;\n        if (accessibilityData) {\n            editor.altTextData = accessibilityData;\n        }\n        editor._initialData = initialData;\n        if (data.comment) {\n            editor.setCommentData(data);\n        }\n        editor.#hasBeenAddedInUndoStack = !!initialData;\n        return editor;\n    }\n    serialize(isForCopying = false, context = null) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const serialized = Object.assign(super.serialize(isForCopying), {\n            bitmapId: this.#bitmapId,\n            isSvg: this.#isSvg\n        });\n        this.addComment(serialized);\n        if (isForCopying) {\n            serialized.bitmapUrl = this.#serializeBitmap(true);\n            serialized.accessibilityData = this.serializeAltText(true);\n            serialized.isCopy = true;\n            return serialized;\n        }\n        const { decorative, altText } = this.serializeAltText(false);\n        if (!decorative && altText) {\n            serialized.accessibilityData = {\n                type: \"Figure\",\n                alt: altText\n            };\n        }\n        if (this.annotationElementId) {\n            const changes = this.#hasElementChanged(serialized);\n            if (changes.isSame) {\n                return null;\n            }\n            if (changes.isSameAltText) {\n                delete serialized.accessibilityData;\n            } else {\n                serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;\n            }\n            serialized.id = this.annotationElementId;\n            delete serialized.bitmapId;\n            return serialized;\n        }\n        if (context === null) {\n            return serialized;\n        }\n        context.stamps ||= new Map();\n        const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n        if (!context.stamps.has(this.#bitmapId)) {\n            context.stamps.set(this.#bitmapId, {\n                area,\n                serialized\n            });\n            serialized.bitmap = this.#serializeBitmap(false);\n        } else if (this.#isSvg) {\n            const prevData = context.stamps.get(this.#bitmapId);\n            if (area > prevData.area) {\n                prevData.area = area;\n                prevData.serialized.bitmap.close();\n                prevData.serialized.bitmap = this.#serializeBitmap(false);\n            }\n        }\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { pageIndex, accessibilityData: { altText } } = this._initialData;\n        const isSamePageIndex = serialized.pageIndex === pageIndex;\n        const isSameAltText = (serialized.accessibilityData?.alt || \"\") === altText;\n        return {\n            isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,\n            isSameAltText\n        };\n    }\n    renderAnnotationElement(annotation) {\n        if (this.deleted) {\n            annotation.hide();\n            return null;\n        }\n        annotation.updateEdited({\n            rect: this.getPDFRect(),\n            popup: this.comment\n        });\n        return null;\n    }\n}\n; // ./src/display/editor/annotation_editor_layer.js\nclass AnnotationEditorLayer {\n    #accessibilityManager;\n    #allowClick;\n    #annotationLayer;\n    #clickAC;\n    #editorFocusTimeoutId;\n    #editors;\n    #hadPointerDown;\n    #isDisabling;\n    #isEnabling;\n    #drawingAC;\n    #focusedElement;\n    #textLayer;\n    #textSelectionAC;\n    #textLayerDblClickAC;\n    #lastPointerDownTimestamp;\n    #uiManager;\n    static{\n        this._initialized = false;\n    }\n    static #editorTypes = new Map([\n        FreeTextEditor,\n        InkEditor,\n        StampEditor,\n        HighlightEditor,\n        SignatureEditor\n    ].map((type)=>[\n            type._editorType,\n            type\n        ]));\n    constructor({ uiManager, pageIndex, div, structTreeLayer, accessibilityManager, annotationLayer, drawLayer, textLayer, viewport, l10n }){\n        this.#allowClick = false;\n        this.#annotationLayer = null;\n        this.#clickAC = null;\n        this.#editorFocusTimeoutId = null;\n        this.#editors = new Map();\n        this.#hadPointerDown = false;\n        this.#isDisabling = false;\n        this.#isEnabling = false;\n        this.#drawingAC = null;\n        this.#focusedElement = null;\n        this.#textLayer = null;\n        this.#textSelectionAC = null;\n        this.#textLayerDblClickAC = null;\n        this.#lastPointerDownTimestamp = -1;\n        const editorTypes = [\n            ...AnnotationEditorLayer.#editorTypes.values()\n        ];\n        if (!AnnotationEditorLayer._initialized) {\n            AnnotationEditorLayer._initialized = true;\n            for (const editorType of editorTypes){\n                editorType.initialize(l10n, uiManager);\n            }\n        }\n        uiManager.registerEditorTypes(editorTypes);\n        this.#uiManager = uiManager;\n        this.pageIndex = pageIndex;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationLayer = annotationLayer;\n        this.viewport = viewport;\n        this.#textLayer = textLayer;\n        this.drawLayer = drawLayer;\n        this._structTree = structTreeLayer;\n        this.#uiManager.addLayer(this);\n    }\n    get isEmpty() {\n        return this.#editors.size === 0;\n    }\n    get isInvisible() {\n        return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;\n    }\n    updateToolbar(options) {\n        this.#uiManager.updateToolbar(options);\n    }\n    updateMode(mode = this.#uiManager.getMode()) {\n        this.#cleanup();\n        switch(mode){\n            case AnnotationEditorType.NONE:\n                this.div.classList.toggle(\"nonEditing\", true);\n                this.disableTextSelection();\n                this.togglePointerEvents(false);\n                this.toggleAnnotationLayerPointerEvents(true);\n                this.disableClick();\n                return;\n            case AnnotationEditorType.INK:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n                break;\n            case AnnotationEditorType.HIGHLIGHT:\n                this.enableTextSelection();\n                this.togglePointerEvents(false);\n                this.disableClick();\n                break;\n            default:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n        }\n        this.toggleAnnotationLayerPointerEvents(false);\n        const { classList } = this.div;\n        classList.toggle(\"nonEditing\", false);\n        if (mode === AnnotationEditorType.POPUP) {\n            classList.toggle(\"commentEditing\", true);\n        } else {\n            classList.toggle(\"commentEditing\", false);\n            for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n                classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);\n            }\n        }\n        this.div.hidden = false;\n    }\n    hasTextLayer(textLayer) {\n        return textLayer === this.#textLayer?.div;\n    }\n    setEditingState(isEditing) {\n        this.#uiManager.setEditingState(isEditing);\n    }\n    addCommands(params) {\n        this.#uiManager.addCommands(params);\n    }\n    cleanUndoStack(type) {\n        this.#uiManager.cleanUndoStack(type);\n    }\n    toggleDrawing(enabled = false) {\n        this.div.classList.toggle(\"drawing\", !enabled);\n    }\n    togglePointerEvents(enabled = false) {\n        this.div.classList.toggle(\"disabled\", !enabled);\n    }\n    toggleAnnotationLayerPointerEvents(enabled = false) {\n        this.#annotationLayer?.div.classList.toggle(\"disabled\", !enabled);\n    }\n    get #allEditorsIterator() {\n        return this.#editors.size !== 0 ? this.#editors.values() : this.#uiManager.getEditors(this.pageIndex);\n    }\n    async enable() {\n        this.#isEnabling = true;\n        this.div.tabIndex = 0;\n        this.togglePointerEvents(true);\n        this.div.classList.toggle(\"nonEditing\", false);\n        this.#textLayerDblClickAC?.abort();\n        this.#textLayerDblClickAC = null;\n        const annotationElementIds = new Set();\n        for (const editor of this.#allEditorsIterator){\n            editor.enableEditing();\n            editor.show(true);\n            if (editor.annotationElementId) {\n                this.#uiManager.removeChangedExistingAnnotation(editor);\n                annotationElementIds.add(editor.annotationElementId);\n            }\n        }\n        const annotationLayer = this.#annotationLayer;\n        if (annotationLayer) {\n            for (const editable of annotationLayer.getEditableAnnotations()){\n                editable.hide();\n                if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n                    continue;\n                }\n                if (annotationElementIds.has(editable.data.id)) {\n                    continue;\n                }\n                const editor = await this.deserialize(editable);\n                if (!editor) {\n                    continue;\n                }\n                this.addOrRebuild(editor);\n                editor.enableEditing();\n            }\n        }\n        this.#isEnabling = false;\n        this.#uiManager._eventBus.dispatch(\"editorsrendered\", {\n            source: this,\n            pageNumber: this.pageIndex + 1\n        });\n    }\n    disable() {\n        this.#isDisabling = true;\n        this.div.tabIndex = -1;\n        this.togglePointerEvents(false);\n        this.div.classList.toggle(\"nonEditing\", true);\n        if (this.#textLayer && !this.#textLayerDblClickAC) {\n            this.#textLayerDblClickAC = new AbortController();\n            const signal = this.#uiManager.combinedSignal(this.#textLayerDblClickAC);\n            this.#textLayer.div.addEventListener(\"pointerdown\", (e)=>{\n                const DBL_CLICK_THRESHOLD = 500;\n                const { clientX, clientY, timeStamp } = e;\n                const lastPointerDownTimestamp = this.#lastPointerDownTimestamp;\n                if (timeStamp - lastPointerDownTimestamp > DBL_CLICK_THRESHOLD) {\n                    this.#lastPointerDownTimestamp = timeStamp;\n                    return;\n                }\n                this.#lastPointerDownTimestamp = -1;\n                const { classList } = this.div;\n                classList.toggle(\"getElements\", true);\n                const elements = document.elementsFromPoint(clientX, clientY);\n                classList.toggle(\"getElements\", false);\n                if (!this.div.contains(elements[0])) {\n                    return;\n                }\n                let id;\n                const regex = new RegExp(`^${AnnotationEditorPrefix}[0-9]+$`);\n                for (const element of elements){\n                    if (regex.test(element.id)) {\n                        id = element.id;\n                        break;\n                    }\n                }\n                if (!id) {\n                    return;\n                }\n                const editor = this.#editors.get(id);\n                if (editor?.annotationElementId === null) {\n                    e.stopPropagation();\n                    e.preventDefault();\n                    editor.dblclick(e);\n                }\n            }, {\n                signal,\n                capture: true\n            });\n        }\n        const annotationLayer = this.#annotationLayer;\n        if (annotationLayer) {\n            const changedAnnotations = new Map();\n            const resetAnnotations = new Map();\n            for (const editor of this.#allEditorsIterator){\n                editor.disableEditing();\n                if (!editor.annotationElementId) {\n                    editor.updateFakeAnnotationElement(annotationLayer);\n                    continue;\n                }\n                if (editor.serialize() !== null) {\n                    changedAnnotations.set(editor.annotationElementId, editor);\n                    continue;\n                } else {\n                    resetAnnotations.set(editor.annotationElementId, editor);\n                }\n                this.getEditableAnnotation(editor.annotationElementId)?.show();\n                editor.remove();\n            }\n            const editables = annotationLayer.getEditableAnnotations();\n            for (const editable of editables){\n                const { id } = editable.data;\n                if (this.#uiManager.isDeletedAnnotationElement(id)) {\n                    editable.updateEdited({\n                        deleted: true\n                    });\n                    continue;\n                }\n                let editor = resetAnnotations.get(id);\n                if (editor) {\n                    editor.resetAnnotationElement(editable);\n                    editor.show(false);\n                    editable.show();\n                    continue;\n                }\n                editor = changedAnnotations.get(id);\n                if (editor) {\n                    this.#uiManager.addChangedExistingAnnotation(editor);\n                    if (editor.renderAnnotationElement(editable)) {\n                        editor.show(false);\n                    }\n                }\n                editable.show();\n            }\n        }\n        this.#cleanup();\n        if (this.isEmpty) {\n            this.div.hidden = true;\n        }\n        const { classList } = this.div;\n        for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n            classList.remove(`${editorType._type}Editing`);\n        }\n        this.disableTextSelection();\n        this.toggleAnnotationLayerPointerEvents(true);\n        this.#isDisabling = false;\n    }\n    getEditableAnnotation(id) {\n        return this.#annotationLayer?.getEditableAnnotation(id) || null;\n    }\n    setActiveEditor(editor) {\n        const currentActive = this.#uiManager.getActive();\n        if (currentActive === editor) {\n            return;\n        }\n        this.#uiManager.setActiveEditor(editor);\n    }\n    enableTextSelection() {\n        this.div.tabIndex = -1;\n        if (this.#textLayer?.div && !this.#textSelectionAC) {\n            this.#textSelectionAC = new AbortController();\n            const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);\n            this.#textLayer.div.addEventListener(\"pointerdown\", this.#textLayerPointerDown.bind(this), {\n                signal\n            });\n            this.#textLayer.div.classList.add(\"highlighting\");\n        }\n    }\n    disableTextSelection() {\n        this.div.tabIndex = 0;\n        if (this.#textLayer?.div && this.#textSelectionAC) {\n            this.#textSelectionAC.abort();\n            this.#textSelectionAC = null;\n            this.#textLayer.div.classList.remove(\"highlighting\");\n        }\n    }\n    #textLayerPointerDown(event) {\n        this.#uiManager.unselectAll();\n        const { target } = event;\n        if (target === this.#textLayer.div || (target.getAttribute(\"role\") === \"img\" || target.classList.contains(\"endOfContent\")) && this.#textLayer.div.contains(target)) {\n            const { isMac } = util_FeatureTest.platform;\n            if (event.button !== 0 || event.ctrlKey && isMac) {\n                return;\n            }\n            this.#uiManager.showAllEditors(\"highlight\", true, true);\n            this.#textLayer.div.classList.add(\"free\");\n            this.toggleDrawing();\n            HighlightEditor.startHighlighting(this, this.#uiManager.direction === \"ltr\", {\n                target: this.#textLayer.div,\n                x: event.x,\n                y: event.y\n            });\n            this.#textLayer.div.addEventListener(\"pointerup\", ()=>{\n                this.#textLayer.div.classList.remove(\"free\");\n                this.toggleDrawing(true);\n            }, {\n                once: true,\n                signal: this.#uiManager._signal\n            });\n            event.preventDefault();\n        }\n    }\n    enableClick() {\n        if (this.#clickAC) {\n            return;\n        }\n        this.#clickAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#clickAC);\n        this.div.addEventListener(\"pointerdown\", this.pointerdown.bind(this), {\n            signal\n        });\n        const pointerup = this.pointerup.bind(this);\n        this.div.addEventListener(\"pointerup\", pointerup, {\n            signal\n        });\n        this.div.addEventListener(\"pointercancel\", pointerup, {\n            signal\n        });\n    }\n    disableClick() {\n        this.#clickAC?.abort();\n        this.#clickAC = null;\n    }\n    attach(editor) {\n        this.#editors.set(editor.id, editor);\n        const { annotationElementId } = editor;\n        if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n            this.#uiManager.removeDeletedAnnotationElement(editor);\n        }\n    }\n    detach(editor) {\n        this.#editors.delete(editor.id);\n        this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n        if (!this.#isDisabling && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor);\n        }\n    }\n    remove(editor) {\n        this.detach(editor);\n        this.#uiManager.removeEditor(editor);\n        editor.div.remove();\n        editor.isAttachedToDOM = false;\n    }\n    changeParent(editor) {\n        if (editor.parent === this) {\n            return;\n        }\n        if (editor.parent && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n            AnnotationEditor.deleteAnnotationElement(editor);\n            editor.annotationElementId = null;\n        }\n        this.attach(editor);\n        editor.parent?.detach(editor);\n        editor.setParent(this);\n        if (editor.div && editor.isAttachedToDOM) {\n            editor.div.remove();\n            this.div.append(editor.div);\n        }\n    }\n    add(editor) {\n        if (editor.parent === this && editor.isAttachedToDOM) {\n            return;\n        }\n        this.changeParent(editor);\n        this.#uiManager.addEditor(editor);\n        this.attach(editor);\n        if (!editor.isAttachedToDOM) {\n            const div = editor.render();\n            this.div.append(div);\n            editor.isAttachedToDOM = true;\n        }\n        editor.fixAndSetPosition();\n        editor.onceAdded(!this.#isEnabling);\n        this.#uiManager.addToAnnotationStorage(editor);\n        editor._reportTelemetry(editor.telemetryInitialData);\n    }\n    moveEditorInDOM(editor) {\n        if (!editor.isAttachedToDOM) {\n            return;\n        }\n        const { activeElement } = document;\n        if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {\n            editor._focusEventsAllowed = false;\n            this.#editorFocusTimeoutId = setTimeout(()=>{\n                this.#editorFocusTimeoutId = null;\n                if (!editor.div.contains(document.activeElement)) {\n                    editor.div.addEventListener(\"focusin\", ()=>{\n                        editor._focusEventsAllowed = true;\n                    }, {\n                        once: true,\n                        signal: this.#uiManager._signal\n                    });\n                    activeElement.focus();\n                } else {\n                    editor._focusEventsAllowed = true;\n                }\n            }, 0);\n        }\n        editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n    }\n    addOrRebuild(editor) {\n        if (editor.needsToBeRebuilt()) {\n            editor.parent ||= this;\n            editor.rebuild();\n            editor.show();\n        } else {\n            this.add(editor);\n        }\n    }\n    addUndoableEditor(editor) {\n        const cmd = ()=>editor._uiManager.rebuild(editor);\n        const undo = ()=>{\n            editor.remove();\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: false\n        });\n    }\n    getEditorByUID(uid) {\n        for (const editor of this.#editors.values()){\n            if (editor.uid === uid) {\n                return editor;\n            }\n        }\n        return null;\n    }\n    getNextId() {\n        return this.#uiManager.getId();\n    }\n    get #currentEditorType() {\n        return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());\n    }\n    combinedSignal(ac) {\n        return this.#uiManager.combinedSignal(ac);\n    }\n    #createNewEditor(params) {\n        const editorType = this.#currentEditorType;\n        return editorType ? new editorType.prototype.constructor(params) : null;\n    }\n    canCreateNewEmptyEditor() {\n        return this.#currentEditorType?.canCreateNewEmptyEditor();\n    }\n    async pasteEditor(options, params) {\n        this.updateToolbar(options);\n        await this.#uiManager.updateMode(options.mode);\n        const { offsetX, offsetY } = this.#getCenterPoint();\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: offsetX,\n            y: offsetY,\n            uiManager: this.#uiManager,\n            isCentered: true,\n            ...params\n        });\n        if (editor) {\n            this.add(editor);\n        }\n    }\n    async deserialize(data) {\n        return await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;\n    }\n    createAndAddNewEditor(event, isCentered, data = {}) {\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: event.offsetX,\n            y: event.offsetY,\n            uiManager: this.#uiManager,\n            isCentered,\n            ...data\n        });\n        if (editor) {\n            this.add(editor);\n        }\n        return editor;\n    }\n    get boundingClientRect() {\n        return this.div.getBoundingClientRect();\n    }\n    #getCenterPoint() {\n        const { x, y, width, height } = this.boundingClientRect;\n        const tlX = Math.max(0, x);\n        const tlY = Math.max(0, y);\n        const brX = Math.min(window.innerWidth, x + width);\n        const brY = Math.min(window.innerHeight, y + height);\n        const centerX = (tlX + brX) / 2 - x;\n        const centerY = (tlY + brY) / 2 - y;\n        const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [\n            centerX,\n            centerY\n        ] : [\n            centerY,\n            centerX\n        ];\n        return {\n            offsetX,\n            offsetY\n        };\n    }\n    addNewEditor(data = {}) {\n        this.createAndAddNewEditor(this.#getCenterPoint(), true, data);\n    }\n    setSelected(editor) {\n        this.#uiManager.setSelected(editor);\n    }\n    toggleSelected(editor) {\n        this.#uiManager.toggleSelected(editor);\n    }\n    unselect(editor) {\n        this.#uiManager.unselect(editor);\n    }\n    pointerup(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        if (!this.#hadPointerDown) {\n            return;\n        }\n        this.#hadPointerDown = false;\n        if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) {\n            return;\n        }\n        if (!this.#allowClick) {\n            this.#allowClick = true;\n            return;\n        }\n        const currentMode = this.#uiManager.getMode();\n        if (currentMode === AnnotationEditorType.STAMP || currentMode === AnnotationEditorType.SIGNATURE) {\n            this.#uiManager.unselectAll();\n            return;\n        }\n        this.createAndAddNewEditor(event, false);\n    }\n    pointerdown(event) {\n        if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {\n            this.enableTextSelection();\n        }\n        if (this.#hadPointerDown) {\n            this.#hadPointerDown = false;\n            return;\n        }\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        this.#hadPointerDown = true;\n        if (this.#currentEditorType?.isDrawer) {\n            this.startDrawingSession(event);\n            return;\n        }\n        const editor = this.#uiManager.getActive();\n        this.#allowClick = !editor || editor.isEmpty();\n    }\n    startDrawingSession(event) {\n        this.div.focus({\n            preventScroll: true\n        });\n        if (this.#drawingAC) {\n            this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n            return;\n        }\n        this.#uiManager.setCurrentDrawingSession(this);\n        this.#drawingAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#drawingAC);\n        this.div.addEventListener(\"blur\", ({ relatedTarget })=>{\n            if (relatedTarget && !this.div.contains(relatedTarget)) {\n                this.#focusedElement = null;\n                this.commitOrRemove();\n            }\n        }, {\n            signal\n        });\n        this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n    }\n    pause(on) {\n        if (on) {\n            const { activeElement } = document;\n            if (this.div.contains(activeElement)) {\n                this.#focusedElement = activeElement;\n            }\n            return;\n        }\n        if (this.#focusedElement) {\n            setTimeout(()=>{\n                this.#focusedElement?.focus();\n                this.#focusedElement = null;\n            }, 0);\n        }\n    }\n    endDrawingSession(isAborted = false) {\n        if (!this.#drawingAC) {\n            return null;\n        }\n        this.#uiManager.setCurrentDrawingSession(null);\n        this.#drawingAC.abort();\n        this.#drawingAC = null;\n        this.#focusedElement = null;\n        return this.#currentEditorType.endDrawing(isAborted);\n    }\n    findNewParent(editor, x, y) {\n        const layer = this.#uiManager.findParent(x, y);\n        if (layer === null || layer === this) {\n            return false;\n        }\n        layer.changeParent(editor);\n        return true;\n    }\n    commitOrRemove() {\n        if (this.#drawingAC) {\n            this.endDrawingSession();\n            return true;\n        }\n        return false;\n    }\n    onScaleChanging() {\n        if (!this.#drawingAC) {\n            return;\n        }\n        this.#currentEditorType.onScaleChangingWhenDrawing(this);\n    }\n    destroy() {\n        this.commitOrRemove();\n        if (this.#uiManager.getActive()?.parent === this) {\n            this.#uiManager.commitOrRemove();\n            this.#uiManager.setActiveEditor(null);\n        }\n        if (this.#editorFocusTimeoutId) {\n            clearTimeout(this.#editorFocusTimeoutId);\n            this.#editorFocusTimeoutId = null;\n        }\n        for (const editor of this.#editors.values()){\n            this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n            editor.setParent(null);\n            editor.isAttachedToDOM = false;\n            editor.div.remove();\n        }\n        this.div = null;\n        this.#editors.clear();\n        this.#uiManager.removeLayer(this);\n    }\n    #cleanup() {\n        for (const editor of this.#editors.values()){\n            if (editor.isEmpty()) {\n                editor.remove();\n            }\n        }\n    }\n    render({ viewport }) {\n        this.viewport = viewport;\n        setLayerDimensions(this.div, viewport);\n        for (const editor of this.#uiManager.getEditors(this.pageIndex)){\n            this.add(editor);\n            editor.rebuild();\n        }\n        this.updateMode();\n    }\n    update({ viewport }) {\n        this.#uiManager.commitOrRemove();\n        this.#cleanup();\n        const oldRotation = this.viewport.rotation;\n        const rotation = viewport.rotation;\n        this.viewport = viewport;\n        setLayerDimensions(this.div, {\n            rotation\n        });\n        if (oldRotation !== rotation) {\n            for (const editor of this.#editors.values()){\n                editor.rotate(rotation);\n            }\n        }\n    }\n    get pageDimensions() {\n        const { pageWidth, pageHeight } = this.viewport.rawDims;\n        return [\n            pageWidth,\n            pageHeight\n        ];\n    }\n    get scale() {\n        return this.#uiManager.viewParameters.realScale;\n    }\n}\n; // ./src/display/draw_layer.js\nclass DrawLayer {\n    #parent;\n    #mapping;\n    #toUpdate;\n    static #id = 0;\n    constructor({ pageIndex }){\n        this.#parent = null;\n        this.#mapping = new Map();\n        this.#toUpdate = new Map();\n        this.pageIndex = pageIndex;\n    }\n    setParent(parent) {\n        if (!this.#parent) {\n            this.#parent = parent;\n            return;\n        }\n        if (this.#parent !== parent) {\n            if (this.#mapping.size > 0) {\n                for (const root of this.#mapping.values()){\n                    root.remove();\n                    parent.append(root);\n                }\n            }\n            this.#parent = parent;\n        }\n    }\n    static get _svgFactory() {\n        return shadow(this, \"_svgFactory\", new DOMSVGFactory());\n    }\n    static #setBox(element, [x, y, width, height]) {\n        const { style } = element;\n        style.top = `${100 * y}%`;\n        style.left = `${100 * x}%`;\n        style.width = `${100 * width}%`;\n        style.height = `${100 * height}%`;\n    }\n    #createSVG() {\n        const svg = DrawLayer._svgFactory.create(1, 1, true);\n        this.#parent.append(svg);\n        svg.setAttribute(\"aria-hidden\", true);\n        return svg;\n    }\n    #createClipPath(defs, pathId) {\n        const clipPath = DrawLayer._svgFactory.createElement(\"clipPath\");\n        defs.append(clipPath);\n        const clipPathId = `clip_${pathId}`;\n        clipPath.setAttribute(\"id\", clipPathId);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        const clipPathUse = DrawLayer._svgFactory.createElement(\"use\");\n        clipPath.append(clipPathUse);\n        clipPathUse.setAttribute(\"href\", `#${pathId}`);\n        clipPathUse.classList.add(\"clip\");\n        return clipPathId;\n    }\n    #updateProperties(element, properties) {\n        for (const [key, value] of Object.entries(properties)){\n            if (value === null) {\n                element.removeAttribute(key);\n            } else {\n                element.setAttribute(key, value);\n            }\n        }\n    }\n    draw(properties, isPathUpdatable = false, hasClip = false) {\n        const id = DrawLayer.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        if (isPathUpdatable) {\n            this.#toUpdate.set(id, path);\n        }\n        const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;\n        const use = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use);\n        use.setAttribute(\"href\", `#${pathId}`);\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return {\n            id,\n            clipPathId: `url(#${clipPathId})`\n        };\n    }\n    drawOutline(properties, mustRemoveSelfIntersections) {\n        const id = DrawLayer.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        let maskId;\n        if (mustRemoveSelfIntersections) {\n            const mask = DrawLayer._svgFactory.createElement(\"mask\");\n            defs.append(mask);\n            maskId = `mask_p${this.pageIndex}_${id}`;\n            mask.setAttribute(\"id\", maskId);\n            mask.setAttribute(\"maskUnits\", \"objectBoundingBox\");\n            const rect = DrawLayer._svgFactory.createElement(\"rect\");\n            mask.append(rect);\n            rect.setAttribute(\"width\", \"1\");\n            rect.setAttribute(\"height\", \"1\");\n            rect.setAttribute(\"fill\", \"white\");\n            const use = DrawLayer._svgFactory.createElement(\"use\");\n            mask.append(use);\n            use.setAttribute(\"href\", `#${pathId}`);\n            use.setAttribute(\"stroke\", \"none\");\n            use.setAttribute(\"fill\", \"black\");\n            use.setAttribute(\"fill-rule\", \"nonzero\");\n            use.classList.add(\"mask\");\n        }\n        const use1 = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use1);\n        use1.setAttribute(\"href\", `#${pathId}`);\n        if (maskId) {\n            use1.setAttribute(\"mask\", `url(#${maskId})`);\n        }\n        const use2 = use1.cloneNode();\n        root.append(use2);\n        use1.classList.add(\"mainOutline\");\n        use2.classList.add(\"secondaryOutline\");\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return id;\n    }\n    finalizeDraw(id, properties) {\n        this.#toUpdate.delete(id);\n        this.updateProperties(id, properties);\n    }\n    updateProperties(elementOrId, properties) {\n        if (!properties) {\n            return;\n        }\n        const { root, bbox, rootClass, path } = properties;\n        const element = typeof elementOrId === \"number\" ? this.#mapping.get(elementOrId) : elementOrId;\n        if (!element) {\n            return;\n        }\n        if (root) {\n            this.#updateProperties(element, root);\n        }\n        if (bbox) {\n            DrawLayer.#setBox(element, bbox);\n        }\n        if (rootClass) {\n            const { classList } = element;\n            for (const [className, value] of Object.entries(rootClass)){\n                classList.toggle(className, value);\n            }\n        }\n        if (path) {\n            const defs = element.firstChild;\n            const pathElement = defs.firstChild;\n            this.#updateProperties(pathElement, path);\n        }\n    }\n    updateParent(id, layer) {\n        if (layer === this) {\n            return;\n        }\n        const root = this.#mapping.get(id);\n        if (!root) {\n            return;\n        }\n        layer.#parent.append(root);\n        this.#mapping.delete(id);\n        layer.#mapping.set(id, root);\n    }\n    remove(id) {\n        this.#toUpdate.delete(id);\n        if (this.#parent === null) {\n            return;\n        }\n        this.#mapping.get(id).remove();\n        this.#mapping.delete(id);\n    }\n    destroy() {\n        this.#parent = null;\n        for (const root of this.#mapping.values()){\n            root.remove();\n        }\n        this.#mapping.clear();\n        this.#toUpdate.clear();\n    }\n}\n; // ./src/pdf.js\n{\n    globalThis._pdfjsTestingUtils = {\n        HighlightOutliner: HighlightOutliner\n    };\n}globalThis.pdfjsLib = {\n    AbortException: AbortException,\n    AnnotationEditorLayer: AnnotationEditorLayer,\n    AnnotationEditorParamsType: AnnotationEditorParamsType,\n    AnnotationEditorType: AnnotationEditorType,\n    AnnotationEditorUIManager: AnnotationEditorUIManager,\n    AnnotationLayer: AnnotationLayer,\n    AnnotationMode: AnnotationMode,\n    AnnotationType: AnnotationType,\n    applyOpacity: applyOpacity,\n    build: build,\n    ColorPicker: ColorPicker,\n    createValidAbsoluteUrl: createValidAbsoluteUrl,\n    CSSConstants: CSSConstants,\n    DOMSVGFactory: DOMSVGFactory,\n    DrawLayer: DrawLayer,\n    FeatureTest: util_FeatureTest,\n    fetchData: fetchData,\n    findContrastColor: findContrastColor,\n    getDocument: getDocument,\n    getFilenameFromUrl: getFilenameFromUrl,\n    getPdfFilenameFromUrl: getPdfFilenameFromUrl,\n    getRGB: getRGB,\n    getUuid: getUuid,\n    getXfaPageViewport: getXfaPageViewport,\n    GlobalWorkerOptions: GlobalWorkerOptions,\n    ImageKind: util_ImageKind,\n    InvalidPDFException: InvalidPDFException,\n    isDataScheme: isDataScheme,\n    isPdfFile: isPdfFile,\n    isValidExplicitDest: isValidExplicitDest,\n    MathClamp: MathClamp,\n    noContextMenu: noContextMenu,\n    normalizeUnicode: normalizeUnicode,\n    OPS: OPS,\n    OutputScale: OutputScale,\n    PasswordResponses: PasswordResponses,\n    PDFDataRangeTransport: PDFDataRangeTransport,\n    PDFDateString: PDFDateString,\n    PDFWorker: PDFWorker,\n    PermissionFlag: PermissionFlag,\n    PixelsPerInch: PixelsPerInch,\n    RenderingCancelledException: RenderingCancelledException,\n    renderRichText: renderRichText,\n    ResponseException: ResponseException,\n    setLayerDimensions: setLayerDimensions,\n    shadow: shadow,\n    SignatureExtractor: SignatureExtractor,\n    stopEvent: stopEvent,\n    SupportedImageMimeTypes: SupportedImageMimeTypes,\n    TextLayer: TextLayer,\n    TouchManager: TouchManager,\n    updateUrlHash: updateUrlHash,\n    Util: Util,\n    VerbosityLevel: VerbosityLevel,\n    version: version,\n    XfaLayer: XfaLayer\n};\n //# sourceMappingURL=pdf.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmLXBhcnNlL25vZGVfbW9kdWxlcy9wZGZqcy1kaXN0L2xlZ2FjeS9idWlsZC9wZGYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBRUQ7OztDQUdDLEdBQ0QsTUFBTSxHQUFHLElBQUlBLHNCQUF1QjtJQUVwQyxHQUFHLEdBQUcsSUFDTixHQUFHLEdBQUksQ0FBQ0MsUUFBUUMsMEJBQTBCQyw4QkFBbUJBO1FBRzdELElBQUlDLGFBQWFELDhCQUFtQkEsQ0FBQztRQUVyQ0YsT0FBT0ksT0FBTyxHQUFHLFNBQVVDLEVBQUU7WUFDM0IsT0FBTyxPQUFPQSxNQUFNLFdBQVdBLE9BQU8sT0FBT0YsV0FBV0U7UUFDMUQ7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsSUFDTixHQUFHLEdBQUksQ0FBQ0wsUUFBUUMsMEJBQTBCQywrQkFBbUJBO1FBRzdELElBQUlJLE9BQU9KLCtCQUFtQkEsQ0FBQztRQUMvQixJQUFJSyxZQUFZTCwrQkFBbUJBLENBQUM7UUFDcEMsSUFBSU0sV0FBV04sK0JBQW1CQSxDQUFDO1FBQ25DLElBQUlPLGNBQWNQLCtCQUFtQkEsQ0FBQztRQUN0QyxJQUFJUSxvQkFBb0JSLCtCQUFtQkEsQ0FBQztRQUU1QyxJQUFJUyxhQUFhQztRQUVqQlosT0FBT0ksT0FBTyxHQUFHLFNBQVVTLFFBQVEsRUFBRUMsYUFBYTtZQUNoRCxJQUFJQyxpQkFBaUJDLFVBQVVDLE1BQU0sR0FBRyxJQUFJUCxrQkFBa0JHLFlBQVlDO1lBQzFFLElBQUlQLFVBQVVRLGlCQUFpQixPQUFPUCxTQUFTRixLQUFLUyxnQkFBZ0JGO1lBQ3BFLE1BQU0sSUFBSUYsV0FBV0YsWUFBWUksWUFBWTtRQUMvQztJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxLQUNOLEdBQUcsR0FBSSxDQUFDSyx5QkFBeUJqQiwwQkFBMEJDLCtCQUFtQkE7UUFHOUUsSUFBSWlCLElBQUlqQiwrQkFBbUJBLENBQUM7UUFDNUIsSUFBSUksT0FBT0osK0JBQW1CQSxDQUFDO1FBQy9CLElBQUlrQixVQUFVbEIsK0JBQW1CQSxDQUFDO1FBQ2xDLElBQUlLLFlBQVlMLCtCQUFtQkEsQ0FBQztRQUNwQyxJQUFJTSxXQUFXTiwrQkFBbUJBLENBQUM7UUFDbkMsSUFBSW1CLG9CQUFvQm5CLCtCQUFtQkEsQ0FBQztRQUM1QyxJQUFJb0IsZ0JBQWdCcEIsK0JBQW1CQSxDQUFDO1FBQ3hDLElBQUlxQiwyQ0FBMkNyQiwrQkFBbUJBLENBQUM7UUFFbkUsSUFBSXNCLGlDQUFpQ0QseUNBQXlDLFFBQVFYO1FBRXRGLG1DQUFtQztRQUNuQyx1REFBdUQ7UUFDdkRPLEVBQUU7WUFBRU0sUUFBUTtZQUFZQyxPQUFPO1lBQU1DLE1BQU07WUFBTUMsUUFBUUo7UUFBK0IsR0FBRztZQUN6RkssTUFBTSxTQUFTQSxLQUFLQyxTQUFTO2dCQUMzQnRCLFNBQVMsSUFBSTtnQkFDYixJQUFJO29CQUNGRCxVQUFVdUI7Z0JBQ1osRUFBRSxPQUFPQyxPQUFPO29CQUNkVCxjQUFjLElBQUksRUFBRSxTQUFTUztnQkFDL0I7Z0JBRUEsSUFBSVAsZ0NBQWdDLE9BQU9sQixLQUFLa0IsZ0NBQWdDLElBQUksRUFBRU07Z0JBRXRGLElBQUlFLFNBQVNYLGtCQUFrQixJQUFJO2dCQUNuQyxJQUFJWSxVQUFVO2dCQUNkLE9BQU9iLFFBQVFZLFFBQVEsU0FBVUUsS0FBSyxFQUFFQyxJQUFJO29CQUMxQyxJQUFJTCxVQUFVSSxPQUFPRCxZQUFZLE9BQU9FLEtBQUtEO2dCQUMvQyxHQUFHO29CQUFFRSxXQUFXO29CQUFNQyxhQUFhO2dCQUFLLEdBQUdDLE1BQU07WUFDbkQ7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxLQUNOLEdBQUcsR0FBSSxDQUFDdEMsUUFBUUMsMEJBQTBCQywrQkFBbUJBO1FBRzdELElBQUlxQyxjQUFjckMsK0JBQW1CQSxDQUFDO1FBQ3RDLElBQUlzQyxRQUFRdEMsK0JBQW1CQSxDQUFDO1FBQ2hDLElBQUlDLGFBQWFELCtCQUFtQkEsQ0FBQztRQUNyQyxJQUFJdUMsU0FBU3ZDLCtCQUFtQkEsQ0FBQztRQUNqQyxJQUFJd0MsY0FBY3hDLCtCQUFtQkEsQ0FBQztRQUN0QyxJQUFJeUMsNkJBQThCekMsK0JBQW1CQSxDQUFDLEtBQUswQyxZQUFZO1FBQ3ZFLElBQUlDLGdCQUFnQjNDLCtCQUFtQkEsQ0FBQztRQUN4QyxJQUFJNEMsc0JBQXNCNUMsK0JBQW1CQSxDQUFDO1FBRTlDLElBQUk2Qyx1QkFBdUJELG9CQUFvQkUsT0FBTztRQUN0RCxJQUFJQyxtQkFBbUJILG9CQUFvQkksR0FBRztRQUM5QyxJQUFJQyxVQUFVQztRQUNkLCtEQUErRDtRQUMvRCxJQUFJQyxpQkFBaUJDLE9BQU9ELGNBQWM7UUFDMUMsSUFBSUUsY0FBY2hCLFlBQVksR0FBR2lCLEtBQUs7UUFDdEMsSUFBSUMsVUFBVWxCLFlBQVksR0FBR2tCLE9BQU87UUFDcEMsSUFBSUMsT0FBT25CLFlBQVksRUFBRSxDQUFDbUIsSUFBSTtRQUU5QixJQUFJQyxzQkFBc0JqQixlQUFlLENBQUNGLE1BQU07WUFDOUMsT0FBT2EsZUFBZSxZQUEwQixHQUFHLFVBQVU7Z0JBQUVuQixPQUFPO1lBQUUsR0FBR2pCLE1BQU0sS0FBSztRQUN4RjtRQUVBLElBQUkyQyxXQUFXUixPQUFPQSxRQUFRUyxLQUFLLENBQUM7UUFFcEMsSUFBSUMsY0FBYzlELE9BQU9JLE9BQU8sR0FBRyxTQUFVOEIsS0FBSyxFQUFFNkIsSUFBSSxFQUFFQyxPQUFPO1lBQy9ELElBQUlULFlBQVlKLFFBQVFZLE9BQU8sR0FBRyxPQUFPLFdBQVc7Z0JBQ2xEQSxPQUFPLE1BQU1OLFFBQVFOLFFBQVFZLE9BQU8seUJBQXlCLFFBQVE7WUFDdkU7WUFDQSxJQUFJQyxXQUFXQSxRQUFRQyxNQUFNLEVBQUVGLE9BQU8sU0FBU0E7WUFDL0MsSUFBSUMsV0FBV0EsUUFBUUUsTUFBTSxFQUFFSCxPQUFPLFNBQVNBO1lBQy9DLElBQUksQ0FBQ3RCLE9BQU9QLE9BQU8sV0FBWVMsOEJBQThCVCxNQUFNNkIsSUFBSSxLQUFLQSxNQUFPO2dCQUNqRixJQUFJckIsYUFBYVcsZUFBZW5CLE9BQU8sUUFBUTtvQkFBRUEsT0FBTzZCO29CQUFNSSxjQUFjO2dCQUFLO3FCQUM1RWpDLE1BQU02QixJQUFJLEdBQUdBO1lBQ3BCO1lBQ0EsSUFBSUosdUJBQXVCSyxXQUFXdkIsT0FBT3VCLFNBQVMsWUFBWTlCLE1BQU1qQixNQUFNLEtBQUsrQyxRQUFRSSxLQUFLLEVBQUU7Z0JBQ2hHZixlQUFlbkIsT0FBTyxVQUFVO29CQUFFQSxPQUFPOEIsUUFBUUksS0FBSztnQkFBQztZQUN6RDtZQUNBLElBQUk7Z0JBQ0YsSUFBSUosV0FBV3ZCLE9BQU91QixTQUFTLGtCQUFrQkEsUUFBUUssV0FBVyxFQUFFO29CQUNwRSxJQUFJM0IsYUFBYVcsZUFBZW5CLE9BQU8sYUFBYTt3QkFBRW9DLFVBQVU7b0JBQU07Z0JBQ3hFLGlHQUFpRztnQkFDakcsT0FBTyxJQUFJcEMsTUFBTXFDLFNBQVMsRUFBRXJDLE1BQU1xQyxTQUFTLEdBQUdDO1lBQ2hELEVBQUUsT0FBT3pDLE9BQU8sQ0FBYztZQUM5QixJQUFJMEMsUUFBUTFCLHFCQUFxQmI7WUFDakMsSUFBSSxDQUFDTyxPQUFPZ0MsT0FBTyxXQUFXO2dCQUM1QkEsTUFBTUMsTUFBTSxHQUFHaEIsS0FBS0UsVUFBVSxPQUFPRyxRQUFRLFdBQVdBLE9BQU87WUFDakU7WUFBRSxPQUFPN0I7UUFDWDtRQUVBLCtHQUErRztRQUMvRyx3REFBd0Q7UUFDeER5QyxTQUFTSixTQUFTLENBQUNLLFFBQVEsR0FBR2QsWUFBWSxTQUFTYztZQUNqRCxPQUFPekUsV0FBVyxJQUFJLEtBQUs4QyxpQkFBaUIsSUFBSSxFQUFFeUIsTUFBTSxJQUFJN0IsY0FBYyxJQUFJO1FBQ2hGLEdBQUc7SUFHSCxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsS0FDTixHQUFHLEdBQUksQ0FBQzdDLFFBQVFDLDBCQUEwQkMsK0JBQW1CQTtRQUc3RCxJQUFJd0MsY0FBY3hDLCtCQUFtQkEsQ0FBQztRQUN0QyxJQUFJdUMsU0FBU3ZDLCtCQUFtQkEsQ0FBQztRQUVqQyxJQUFJMkUsb0JBQW9CRixTQUFTSixTQUFTO1FBQzFDLHlFQUF5RTtRQUN6RSxJQUFJTyxnQkFBZ0JwQyxlQUFlWSxPQUFPeUIsd0JBQXdCO1FBRWxFLElBQUlDLFNBQVN2QyxPQUFPb0MsbUJBQW1CO1FBQ3ZDLHlFQUF5RTtRQUN6RSxJQUFJSSxTQUFTRCxVQUFVLENBQUMsU0FBU0UsYUFBMEIsR0FBR25CLElBQUksS0FBSztRQUN2RSxJQUFJbkIsZUFBZW9DLFVBQVcsRUFBQ3RDLGVBQWdCQSxlQUFlb0MsY0FBY0QsbUJBQW1CLFFBQVFWLFlBQVk7UUFFbkhuRSxPQUFPSSxPQUFPLEdBQUc7WUFDZjRFLFFBQVFBO1lBQ1JDLFFBQVFBO1lBQ1JyQyxjQUFjQTtRQUNoQjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxLQUNOLEdBQUcsR0FBSSxDQUFDNUMsUUFBUUMsMEJBQTBCQywrQkFBbUJBO1FBRzdELElBQUlpRixhQUFhakYsK0JBQW1CQSxDQUFDO1FBRXJDRixPQUFPSSxPQUFPLEdBQUcrRSxXQUFXLFlBQVk7SUFHeEMsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLEtBQ04sR0FBRyxHQUFJLENBQUNuRjtRQUdSQSxPQUFPSSxPQUFPLEdBQUcsQ0FBQztJQUdsQixHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsS0FDTixHQUFHLEdBQUksQ0FBQ2MseUJBQXlCakIsMEJBQTBCQywrQkFBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsK0JBQW1CQSxDQUFDO1FBQzVCLElBQUlrRixjQUFhbEYsK0JBQW1CQSxDQUFDO1FBQ3JDLElBQUlxQyxjQUFjckMsK0JBQW1CQSxDQUFDO1FBQ3RDLElBQUltRixlQUFlbkYsK0JBQW1CQSxDQUFDO1FBQ3ZDLElBQUlvRixjQUFjcEYsK0JBQW1CQSxDQUFDO1FBRXRDLElBQUlxRixpQkFBaUJoRCxZQUFZLElBQUlxQyxRQUFRO1FBRTdDLElBQUlZLGNBQWFKLFlBQVdJLFVBQVU7UUFFdEMsSUFBSUMsc0NBQXNDLENBQUNELGVBQWMsQ0FBQ0EsWUFBV2pCLFNBQVMsQ0FBQ21CLEtBQUssSUFBSSxDQUFDO1lBQ3ZGLElBQUk7Z0JBQ0YsSUFBSWpFLFNBQVMsSUFBSStELFlBQVc7b0JBQUM7b0JBQUs7b0JBQUs7b0JBQUs7b0JBQUs7b0JBQUs7b0JBQUs7b0JBQUs7aUJBQUk7Z0JBQ3BFLE9BQU8vRCxPQUFPaUUsS0FBSyxPQUFPO1lBQzVCLEVBQUUsT0FBTzNELE9BQU87Z0JBQ2QsT0FBTztZQUNUO1FBQ0Y7UUFFQSxzQ0FBc0M7UUFDdEMsc0RBQXNEO1FBQ3RELElBQUl5RCxhQUFZckUsRUFBRTtZQUFFTSxRQUFRO1lBQWNDLE9BQU87WUFBTUUsUUFBUTZEO1FBQW9DLEdBQUc7WUFDcEdDLE9BQU8sU0FBU0E7Z0JBQ2RMLGFBQWEsSUFBSTtnQkFDakJDLFlBQVksSUFBSSxDQUFDSyxNQUFNO2dCQUN2QixJQUFJckQsU0FBUztnQkFDYixJQUFLLElBQUlzRCxJQUFJLEdBQUczRSxTQUFTLElBQUksQ0FBQ0EsTUFBTSxFQUFFMkUsSUFBSTNFLFFBQVEyRSxJQUFLO29CQUNyRCxJQUFJQyxNQUFNTixlQUFlLElBQUksQ0FBQ0ssRUFBRSxFQUFFO29CQUNsQ3RELFVBQVV1RCxJQUFJNUUsTUFBTSxLQUFLLElBQUksTUFBTTRFLE1BQU1BO2dCQUMzQztnQkFDQSxPQUFPdkQ7WUFDVDtRQUNGO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLEtBQ04sR0FBRyxHQUFJLENBQUN0QyxRQUFRQywwQkFBMEJDLCtCQUFtQkE7UUFHN0QsSUFBSUksT0FBT0osK0JBQW1CQSxDQUFDO1FBRS9CRixPQUFPSSxPQUFPLEdBQUcsU0FBVTRCLE1BQU0sRUFBRThELEVBQUUsRUFBRUMsMEJBQTBCO1lBQy9ELElBQUlDLFdBQVdELDZCQUE2Qi9ELFNBQVNBLE9BQU9nRSxRQUFRO1lBQ3BFLElBQUlDLE9BQU9qRSxPQUFPaUUsSUFBSTtZQUN0QixJQUFJQyxNQUFNNUQ7WUFDVixNQUFPLENBQUMsQ0FBQzRELE9BQU81RixLQUFLMkYsTUFBTUQsU0FBUSxFQUFHRyxJQUFJLENBQUU7Z0JBQzFDN0QsU0FBU3dELEdBQUdJLEtBQUtoRSxLQUFLO2dCQUN0QixJQUFJSSxXQUFXa0MsV0FBVyxPQUFPbEM7WUFDbkM7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxLQUNOLEdBQUcsR0FBSSxDQUFDcEIseUJBQXlCakIsMEJBQTBCQyxnQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsZ0NBQW1CQSxDQUFDO1FBQzVCLElBQUlJLE9BQU9KLGdDQUFtQkEsQ0FBQztRQUMvQixJQUFJSyxZQUFZTCxnQ0FBbUJBLENBQUM7UUFDcEMsSUFBSU0sV0FBV04sZ0NBQW1CQSxDQUFDO1FBQ25DLElBQUltQixvQkFBb0JuQixnQ0FBbUJBLENBQUM7UUFDNUMsSUFBSWtHLHlCQUF5QmxHLGdDQUFtQkEsQ0FBQztRQUNqRCxJQUFJbUcsc0JBQXNCbkcsZ0NBQW1CQSxDQUFDO1FBQzlDLElBQUlvQixnQkFBZ0JwQixnQ0FBbUJBLENBQUM7UUFDeEMsSUFBSW9HLFVBQVVwRyxnQ0FBbUJBLENBQUM7UUFDbEMsSUFBSXFHLHdDQUF3Q3JHLGdDQUFtQkEsQ0FBQztRQUNoRSxJQUFJcUIsMkNBQTJDckIsZ0NBQW1CQSxDQUFDO1FBRW5FLElBQUlzRyxnREFBZ0QsQ0FBQ0YsV0FDaEQsQ0FBQ0Msc0NBQXNDLFdBQVcsWUFBMEI7UUFDakYsSUFBSUUsb0NBQW9DLENBQUNILFdBQVcsQ0FBQ0UsaURBQ2hEakYseUNBQXlDLFdBQVdYO1FBRXpELElBQUk4RixTQUFTSixXQUFXRSxpREFBaURDO1FBRXpFLElBQUlFLGdCQUFnQk4sb0JBQW9CO1lBQ3RDLElBQUlMLFdBQVcsSUFBSSxDQUFDQSxRQUFRO1lBQzVCLElBQUlZLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1lBQ3hCLElBQUl0RSxRQUFRdUU7WUFFWixNQUFPLEtBQU07Z0JBQ1gsSUFBSUEsUUFBUSxJQUFJLENBQUNBLEtBQUssRUFBRSxJQUFJO29CQUMxQnZFLFNBQVM5QixTQUFTRixLQUFLdUcsTUFBTVosSUFBSSxFQUFFWSxNQUFNYixRQUFRO29CQUNqRCxJQUFJLENBQUMxRCxPQUFPNkQsSUFBSSxFQUFFLE9BQU83RCxPQUFPSixLQUFLO29CQUNyQyxJQUFJLENBQUMyRSxLQUFLLEdBQUc7Z0JBQ2YsRUFBRSxPQUFPOUUsT0FBTztvQkFBRVQsY0FBYzBFLFVBQVUsU0FBU2pFO2dCQUFRO2dCQUUzRE8sU0FBUzlCLFNBQVNGLEtBQUssSUFBSSxDQUFDMkYsSUFBSSxFQUFFRDtnQkFFbEMsSUFBSSxJQUFJLENBQUNHLElBQUksR0FBRyxDQUFDLENBQUM3RCxPQUFPNkQsSUFBSSxFQUFFO2dCQUUvQixJQUFJO29CQUNGLElBQUksQ0FBQ1UsS0FBSyxHQUFHVCx1QkFBdUJRLE9BQU90RSxPQUFPSixLQUFLLEVBQUUsSUFBSSxDQUFDRCxPQUFPLEtBQUs7Z0JBQzVFLEVBQUUsT0FBT0YsT0FBTztvQkFBRVQsY0FBYzBFLFVBQVUsU0FBU2pFO2dCQUFRO1lBQzdEO1FBQ0Y7UUFFQSxzQ0FBc0M7UUFDdEMsMERBQTBEO1FBQzFEWixFQUFFO1lBQUVNLFFBQVE7WUFBWUMsT0FBTztZQUFNQyxNQUFNO1lBQU1DLFFBQVE4RTtRQUFPLEdBQUc7WUFDakVJLFNBQVMsU0FBU0EsUUFBUUYsTUFBTTtnQkFDOUJwRyxTQUFTLElBQUk7Z0JBQ2IsSUFBSTtvQkFDRkQsVUFBVXFHO2dCQUNaLEVBQUUsT0FBTzdFLE9BQU87b0JBQ2RULGNBQWMsSUFBSSxFQUFFLFNBQVNTO2dCQUMvQjtnQkFFQSxJQUFJMEUsbUNBQW1DLE9BQU9uRyxLQUFLbUcsbUNBQW1DLElBQUksRUFBRUc7Z0JBRTVGLE9BQU8sSUFBSUQsY0FBY3RGLGtCQUFrQixJQUFJLEdBQUc7b0JBQ2hEdUYsUUFBUUE7b0JBQ1JDLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLEtBQ04sR0FBRyxHQUFJLENBQUM3RyxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSXNDLFFBQVF0QyxnQ0FBbUJBLENBQUM7UUFFaENGLE9BQU9JLE9BQU8sR0FBRyxDQUFDb0MsTUFBTTtZQUN0QixpRUFBaUU7WUFDakUsSUFBSXVFLE9BQU8sQ0FBQyxZQUEwQixHQUFHQyxJQUFJO1lBQzdDLHlEQUF5RDtZQUN6RCxPQUFPLE9BQU9ELFFBQVEsY0FBY0EsS0FBS0UsY0FBYyxDQUFDO1FBQzFEO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLEtBQ04sR0FBRyxHQUFJLENBQUNqSCxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSWdILFVBQVVoSCxnQ0FBbUJBLENBQUM7UUFFbEMsSUFBSWlELFVBQVVDO1FBRWRwRCxPQUFPSSxPQUFPLEdBQUcsU0FBVVMsUUFBUTtZQUNqQyxJQUFJcUcsUUFBUXJHLGNBQWMsVUFBVSxNQUFNLElBQUlELFVBQVU7WUFDeEQsT0FBT3VDLFFBQVF0QztRQUNqQjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxLQUNOLEdBQUcsR0FBSSxDQUFDYixRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSWlILGdCQUFnQmpILGdDQUFtQkEsQ0FBQztRQUV4QyxJQUFJUyxhQUFhQztRQUVqQlosT0FBT0ksT0FBTyxHQUFHLFNBQVVDLEVBQUUsRUFBRStHLFNBQVM7WUFDdEMsSUFBSUQsY0FBY0MsV0FBVy9HLEtBQUssT0FBT0E7WUFDekMsTUFBTSxJQUFJTSxXQUFXO1FBQ3ZCO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLEtBQ04sR0FBRyxHQUFJLENBQUNYO1FBR1IsNENBQTRDO1FBQzVDLCtDQUErQztRQUMvQ0EsT0FBT0ksT0FBTyxHQUFHLFNBQVVpSCxVQUFVLEVBQUV4RyxRQUFRO1lBQzdDLGtFQUFrRTtZQUNsRSxJQUFJeUcsU0FBUyxPQUFPQyxZQUFZLGNBQWNBLFNBQVNoRCxTQUFTLENBQUM4QyxXQUFXO1lBQzVFLElBQUlDLFFBQVEsSUFBSTtnQkFDZEEsT0FBT2hILElBQUksQ0FBQztvQkFBRTJGLE1BQU07Z0JBQUssR0FBR3BGLFVBQVVvRixJQUFJO1lBQzVDLEVBQUUsT0FBT2xFLE9BQU87Z0JBQ2QsT0FBTztZQUNUO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsS0FDTixHQUFHLEdBQUksQ0FBQy9CO1FBR1IsSUFBSXdILE9BQU9DLEtBQUtELElBQUk7UUFDcEIsSUFBSUUsUUFBUUQsS0FBS0MsS0FBSztRQUV0QixzQkFBc0I7UUFDdEIsMENBQTBDO1FBQzFDLG9EQUFvRDtRQUNwRDFILE9BQU9JLE9BQU8sR0FBR3FILEtBQUtFLEtBQUssSUFBSSxTQUFTQSxNQUFNQyxDQUFDO1lBQzdDLElBQUlDLElBQUksQ0FBQ0Q7WUFDVCxPQUFPLENBQUNDLElBQUksSUFBSUgsUUFBUUYsSUFBRyxFQUFHSztRQUNoQztJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxLQUNOLEdBQUcsR0FBSSxDQUFDN0gsUUFBUUMsMEJBQTBCQyxnQ0FBbUJBO1FBRzdELElBQUlpRixhQUFhakYsZ0NBQW1CQSxDQUFDO1FBQ3JDLElBQUlDLGFBQWFELGdDQUFtQkEsQ0FBQztRQUNyQyxJQUFJaUgsZ0JBQWdCakgsZ0NBQW1CQSxDQUFDO1FBQ3hDLElBQUk0SCxvQkFBb0I1SCxnQ0FBbUJBLENBQUM7UUFFNUMsSUFBSTZILFVBQVV6RTtRQUVkdEQsT0FBT0ksT0FBTyxHQUFHMEgsb0JBQW9CLFNBQVV6SCxFQUFFO1lBQy9DLE9BQU8sT0FBT0EsTUFBTTtRQUN0QixJQUFJLFNBQVVBLEVBQUU7WUFDZCxJQUFJMkgsVUFBVTdDLFdBQVc7WUFDekIsT0FBT2hGLFdBQVc2SCxZQUFZYixjQUFjYSxRQUFRekQsU0FBUyxFQUFFd0QsUUFBUTFIO1FBQ3pFO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLEtBQ04sR0FBRyxHQUFJLENBQUNMLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJZ0gsVUFBVWhILGdDQUFtQkEsQ0FBQztRQUNsQyxJQUFJK0gsWUFBWS9ILGdDQUFtQkEsQ0FBQztRQUNwQyxJQUFJZ0ksb0JBQW9CaEksZ0NBQW1CQSxDQUFDO1FBQzVDLElBQUlpSSxZQUFZakksZ0NBQW1CQSxDQUFDO1FBQ3BDLElBQUlrSSxrQkFBa0JsSSxnQ0FBbUJBLENBQUM7UUFFMUMsSUFBSW1JLFdBQVdELGdCQUFnQjtRQUUvQnBJLE9BQU9JLE9BQU8sR0FBRyxTQUFVQyxFQUFFO1lBQzNCLElBQUksQ0FBQzZILGtCQUFrQjdILEtBQUssT0FBTzRILFVBQVU1SCxJQUFJZ0ksYUFDNUNKLFVBQVU1SCxJQUFJLGlCQUNkOEgsU0FBUyxDQUFDakIsUUFBUTdHLElBQUk7UUFDN0I7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsS0FDTixHQUFHLEdBQUksQ0FBQ0w7UUFHUixJQUFJVyxhQUFhQztRQUVqQlosT0FBT0ksT0FBTyxHQUFHLFNBQVU0RCxPQUFPO1lBQ2hDLElBQUlzRSxXQUFXdEUsV0FBV0EsUUFBUXNFLFFBQVE7WUFDMUMsSUFBSUEsYUFBYTlELGFBQWE4RCxhQUFhLFlBQVlBLGFBQWEsYUFBYSxPQUFPQSxZQUFZO1lBQ3BHLE1BQU0sSUFBSTNILFdBQVc7UUFDdkI7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ1gsUUFBUUMsMEJBQTBCQyxnQ0FBbUJBO1FBRzdELElBQUlxSSxxQkFBcUJySSxnQ0FBbUJBLENBQUM7UUFDN0MsSUFBSXNJLGNBQWN0SSxnQ0FBbUJBLENBQUM7UUFFdEMsdUJBQXVCO1FBQ3ZCLDJDQUEyQztRQUMzQyxxREFBcUQ7UUFDckRGLE9BQU9JLE9BQU8sR0FBR2tELE9BQU9tRixJQUFJLElBQUksU0FBU0EsS0FBS0MsQ0FBQztZQUM3QyxPQUFPSCxtQkFBbUJHLEdBQUdGO1FBQy9CO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUN4STtRQUdSQSxPQUFPSSxPQUFPLEdBQUcsU0FBVXVJLElBQUk7WUFDN0IsSUFBSTtnQkFDRixPQUFPO29CQUFFNUcsT0FBTztvQkFBT0csT0FBT3lHO2dCQUFPO1lBQ3ZDLEVBQUUsT0FBTzVHLE9BQU87Z0JBQ2QsT0FBTztvQkFBRUEsT0FBTztvQkFBTUcsT0FBT0g7Z0JBQU07WUFDckM7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDL0IsUUFBUUMsMEJBQTBCQyxnQ0FBbUJBO1FBRzdELElBQUlnSCxVQUFVaEgsZ0NBQW1CQSxDQUFDO1FBRWxDRixPQUFPSSxPQUFPLEdBQUcsU0FBVUMsRUFBRTtZQUMzQixJQUFJdUksUUFBUTFCLFFBQVE3RztZQUNwQixPQUFPdUksVUFBVSxtQkFBbUJBLFVBQVU7UUFDaEQ7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQzFILHlCQUF5QmpCLDBCQUEwQkMsZ0NBQW1CQTtRQUc5RSxJQUFJaUIsSUFBSWpCLGdDQUFtQkEsQ0FBQztRQUM1QixJQUFJSSxPQUFPSixnQ0FBbUJBLENBQUM7UUFDL0IsSUFBSWtCLFVBQVVsQixnQ0FBbUJBLENBQUM7UUFDbEMsSUFBSUssWUFBWUwsZ0NBQW1CQSxDQUFDO1FBQ3BDLElBQUlNLFdBQVdOLGdDQUFtQkEsQ0FBQztRQUNuQyxJQUFJbUIsb0JBQW9CbkIsZ0NBQW1CQSxDQUFDO1FBQzVDLElBQUlvQixnQkFBZ0JwQixnQ0FBbUJBLENBQUM7UUFDeEMsSUFBSXFCLDJDQUEyQ3JCLGdDQUFtQkEsQ0FBQztRQUVuRSxJQUFJMkksa0NBQWtDdEgseUNBQXlDLFNBQVNYO1FBRXhGLG9DQUFvQztRQUNwQyx3REFBd0Q7UUFDeERPLEVBQUU7WUFBRU0sUUFBUTtZQUFZQyxPQUFPO1lBQU1DLE1BQU07WUFBTUMsUUFBUWlIO1FBQWdDLEdBQUc7WUFDMUZDLE9BQU8sU0FBU0EsTUFBTWhILFNBQVM7Z0JBQzdCdEIsU0FBUyxJQUFJO2dCQUNiLElBQUk7b0JBQ0ZELFVBQVV1QjtnQkFDWixFQUFFLE9BQU9DLE9BQU87b0JBQ2RULGNBQWMsSUFBSSxFQUFFLFNBQVNTO2dCQUMvQjtnQkFFQSxJQUFJOEcsaUNBQWlDLE9BQU92SSxLQUFLdUksaUNBQWlDLElBQUksRUFBRS9HO2dCQUV4RixJQUFJRSxTQUFTWCxrQkFBa0IsSUFBSTtnQkFDbkMsSUFBSVksVUFBVTtnQkFDZCxPQUFPLENBQUNiLFFBQVFZLFFBQVEsU0FBVUUsS0FBSyxFQUFFQyxJQUFJO29CQUMzQyxJQUFJLENBQUNMLFVBQVVJLE9BQU9ELFlBQVksT0FBT0U7Z0JBQzNDLEdBQUc7b0JBQUVDLFdBQVc7b0JBQU1DLGFBQWE7Z0JBQUssR0FBRzBHLE9BQU87WUFDcEQ7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDL0ksUUFBUUMsMEJBQTBCQyxnQ0FBbUJBO1FBRzdELElBQUk4SSxrQkFBa0I5SSxnQ0FBbUJBLENBQUM7UUFDMUMsSUFBSWtGLGNBQWFsRixnQ0FBbUJBLENBQUM7UUFDckMsSUFBSStJLFdBQVcvSSxnQ0FBbUJBLENBQUM7UUFDbkMsSUFBSWdKLDhCQUE4QmhKLGdDQUFtQkEsQ0FBQztRQUN0RCxJQUFJdUMsU0FBU3ZDLGdDQUFtQkEsQ0FBQztRQUNqQyxJQUFJaUosU0FBU2pKLGdDQUFtQkEsQ0FBQztRQUNqQyxJQUFJa0osWUFBWWxKLGdDQUFtQkEsQ0FBQztRQUNwQyxJQUFJbUosYUFBYW5KLGdDQUFtQkEsQ0FBQztRQUVyQyxJQUFJb0osNkJBQTZCO1FBQ2pDLElBQUkxSSxhQUFZd0UsWUFBV3hFLFNBQVM7UUFDcEMsSUFBSTJJLFdBQVVuRSxZQUFXbUUsT0FBTztRQUNoQyxJQUFJQyxLQUFLdEcsS0FBS3VHO1FBRWQsSUFBSXpHLFVBQVUsU0FBVTNDLEVBQUU7WUFDeEIsT0FBT29KLElBQUlwSixNQUFNNkMsSUFBSTdDLE1BQU1tSixJQUFJbkosSUFBSSxDQUFDO1FBQ3RDO1FBRUEsSUFBSXFKLFlBQVksU0FBVUMsSUFBSTtZQUM1QixPQUFPLFNBQVV0SixFQUFFO2dCQUNqQixJQUFJb0U7Z0JBQ0osSUFBSSxDQUFDd0UsU0FBUzVJLE9BQU8sQ0FBQ29FLFFBQVF2QixJQUFJN0MsR0FBRSxFQUFHdUosSUFBSSxLQUFLRCxNQUFNO29CQUNwRCxNQUFNLElBQUkvSSxXQUFVLDRCQUE0QitJLE9BQU87Z0JBQ3pEO2dCQUFFLE9BQU9sRjtZQUNYO1FBQ0Y7UUFFQSxJQUFJdUUsbUJBQW1CRyxPQUFPMUUsS0FBSyxFQUFFO1lBQ25DLElBQUlvRixRQUFRVixPQUFPMUUsS0FBSyxJQUFLMEUsQ0FBQUEsT0FBTzFFLEtBQUssR0FBRyxJQUFJOEUsVUFBUTtZQUN4RCxpRUFBaUUsR0FDakVNLE1BQU0zRyxHQUFHLEdBQUcyRyxNQUFNM0csR0FBRztZQUNyQjJHLE1BQU1KLEdBQUcsR0FBR0ksTUFBTUosR0FBRztZQUNyQkksTUFBTUwsR0FBRyxHQUFHSyxNQUFNTCxHQUFHO1lBQ3JCLGdFQUFnRSxHQUNoRUEsTUFBTSxTQUFVbkosRUFBRSxFQUFFeUosUUFBUTtnQkFDMUIsSUFBSUQsTUFBTUosR0FBRyxDQUFDcEosS0FBSyxNQUFNLElBQUlPLFdBQVUwSTtnQkFDdkNRLFNBQVNDLE1BQU0sR0FBRzFKO2dCQUNsQndKLE1BQU1MLEdBQUcsQ0FBQ25KLElBQUl5SjtnQkFDZCxPQUFPQTtZQUNUO1lBQ0E1RyxNQUFNLFNBQVU3QyxFQUFFO2dCQUNoQixPQUFPd0osTUFBTTNHLEdBQUcsQ0FBQzdDLE9BQU8sQ0FBQztZQUMzQjtZQUNBb0osTUFBTSxTQUFVcEosRUFBRTtnQkFDaEIsT0FBT3dKLE1BQU1KLEdBQUcsQ0FBQ3BKO1lBQ25CO1FBQ0YsT0FBTztZQUNMLElBQUkySixRQUFRWixVQUFVO1lBQ3RCQyxVQUFVLENBQUNXLE1BQU0sR0FBRztZQUNwQlIsTUFBTSxTQUFVbkosRUFBRSxFQUFFeUosUUFBUTtnQkFDMUIsSUFBSXJILE9BQU9wQyxJQUFJMkosUUFBUSxNQUFNLElBQUlwSixXQUFVMEk7Z0JBQzNDUSxTQUFTQyxNQUFNLEdBQUcxSjtnQkFDbEI2SSw0QkFBNEI3SSxJQUFJMkosT0FBT0Y7Z0JBQ3ZDLE9BQU9BO1lBQ1Q7WUFDQTVHLE1BQU0sU0FBVTdDLEVBQUU7Z0JBQ2hCLE9BQU9vQyxPQUFPcEMsSUFBSTJKLFNBQVMzSixFQUFFLENBQUMySixNQUFNLEdBQUcsQ0FBQztZQUMxQztZQUNBUCxNQUFNLFNBQVVwSixFQUFFO2dCQUNoQixPQUFPb0MsT0FBT3BDLElBQUkySjtZQUNwQjtRQUNGO1FBRUFoSyxPQUFPSSxPQUFPLEdBQUc7WUFDZm9KLEtBQUtBO1lBQ0x0RyxLQUFLQTtZQUNMdUcsS0FBS0E7WUFDTHpHLFNBQVNBO1lBQ1QwRyxXQUFXQTtRQUNiO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUMxSixRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSXlILFFBQVF6SCxnQ0FBbUJBLENBQUM7UUFFaEMsMkNBQTJDO1FBQzNDLG1EQUFtRDtRQUNuREYsT0FBT0ksT0FBTyxHQUFHLFNBQVVTLFFBQVE7WUFDakMsSUFBSW9KLFNBQVMsQ0FBQ3BKO1lBQ2Qsd0RBQXdEO1lBQ3hELE9BQU9vSixXQUFXQSxVQUFVQSxXQUFXLElBQUksSUFBSXRDLE1BQU1zQztRQUN2RDtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDakssUUFBUUMsMEJBQTBCQyxnQ0FBbUJBO1FBRzdELElBQUlvQixnQkFBZ0JwQixnQ0FBbUJBLENBQUM7UUFFeENGLE9BQU9JLE9BQU8sR0FBRyxTQUFVOEosS0FBSyxFQUFFQyxJQUFJLEVBQUVqSSxLQUFLO1lBQzNDLElBQUssSUFBSTBELElBQUlzRSxNQUFNakosTUFBTSxHQUFHLEdBQUcyRSxLQUFLLEdBQUdBLElBQUs7Z0JBQzFDLElBQUlzRSxLQUFLLENBQUN0RSxFQUFFLEtBQUtwQixXQUFXO2dCQUM1QixJQUFJO29CQUNGdEMsUUFBUVosY0FBYzRJLEtBQUssQ0FBQ3RFLEVBQUUsQ0FBQ0ksUUFBUSxFQUFFbUUsTUFBTWpJO2dCQUNqRCxFQUFFLE9BQU9ILE9BQU87b0JBQ2RvSSxPQUFPO29CQUNQakksUUFBUUg7Z0JBQ1Y7WUFDRjtZQUNBLElBQUlvSSxTQUFTLFNBQVMsTUFBTWpJO1lBQzVCLE9BQU9BO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2xDLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJa0YsY0FBYWxGLGdDQUFtQkEsQ0FBQztRQUNyQyxJQUFJc0MsUUFBUXRDLGdDQUFtQkEsQ0FBQztRQUNoQyxJQUFJa0ssS0FBS2xLLGdDQUFtQkEsQ0FBQztRQUM3QixJQUFJbUssY0FBY25LLGdDQUFtQkEsQ0FBQztRQUV0QyxJQUFJb0ssbUJBQWtCbEYsWUFBV2tGLGVBQWU7UUFFaER0SyxPQUFPSSxPQUFPLEdBQUcsQ0FBQyxDQUFDa0ssb0JBQW1CLENBQUM5SCxNQUFNO1lBQzNDLDBGQUEwRjtZQUMxRixpREFBaUQ7WUFDakQsSUFBSSxnQkFBaUIsVUFBVTRILEtBQUssTUFBUUMsZ0JBQWdCLFVBQVVELEtBQUssTUFBUUMsZ0JBQWdCLGFBQWFELEtBQUssSUFBSyxPQUFPO1lBQ2pJLElBQUl6RSxTQUFTLElBQUk0RSxZQUFZO1lBQzdCLElBQUlDLFFBQVFGLGlCQUFnQjNFLFFBQVE7Z0JBQUU4RSxVQUFVO29CQUFDOUU7aUJBQU87WUFBQztZQUN6RCxPQUFPQSxPQUFPK0UsVUFBVSxLQUFLLEtBQUtGLE1BQU1FLFVBQVUsS0FBSztRQUN6RDtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDeEoseUJBQXlCakIsMEJBQTBCQyxnQ0FBbUJBO1FBRzlFLGdDQUFnQztRQUNoQ0EsZ0NBQW1CQSxDQUFDO0lBR3BCLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDRixRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSXFDLGNBQWNyQyxnQ0FBbUJBLENBQUM7UUFFdENGLE9BQU9JLE9BQU8sR0FBR21DLFlBQVksQ0FBQyxFQUFFNEUsYUFBYTtJQUc3QyxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2pHLHlCQUF5QmpCLDBCQUEwQkMsZ0NBQW1CQTtRQUc5RSxJQUFJaUIsSUFBSWpCLGdDQUFtQkEsQ0FBQztRQUM1QixJQUFJa0YsY0FBYWxGLGdDQUFtQkEsQ0FBQztRQUNyQyxJQUFJeUssUUFBUXpLLGdDQUFtQkEsQ0FBQztRQUNoQyxJQUFJc0QsUUFBUXRELGdDQUFtQkEsQ0FBQztRQUNoQyxJQUFJMEssNkJBQTZCMUssZ0NBQW1CQSxDQUFDO1FBQ3JELElBQUlLLFlBQVlMLGdDQUFtQkEsQ0FBQztRQUNwQyxJQUFJMkssVUFBVTNLLGdDQUFtQkEsQ0FBQztRQUVsQyxJQUFJNEssV0FBVTFGLFlBQVcwRixPQUFPO1FBRWhDLElBQUlDLG1CQUFtQjtRQUN2QiwyRUFBMkU7UUFDM0UsaURBQWlEO1FBQ2pELElBQUlyRSxTQUFTLENBQUNvRSxZQUFXLENBQUNBLFFBQU8sQ0FBQyxNQUFNLElBQUlELFFBQVE7WUFDbERDLFFBQU8sQ0FBQyxNQUFNLENBQUMsU0FBVWpLLFFBQVE7Z0JBQy9Ca0ssbUJBQW1CbEssYUFBYTtZQUNsQyxHQUFHO1FBQ0wsR0FBR2tCLEtBQUssSUFBSSxDQUFDZ0o7UUFFYix1QkFBdUI7UUFDdkIsMkNBQTJDO1FBQzNDNUosRUFBRTtZQUFFTSxRQUFRO1lBQVd1SixNQUFNO1lBQU1wSixRQUFROEU7UUFBTyxHQUFHO1lBQ25ELE9BQU8sU0FBVXVFLFdBQVcsYUFBYSxHQUFkO2dCQUN6QixJQUFJQyxPQUFPbEssVUFBVUMsTUFBTSxHQUFHLElBQUl1QyxNQUFNeEMsV0FBVyxLQUFLLEVBQUU7Z0JBQzFELElBQUltSyxvQkFBb0JQLDJCQUEyQlEsQ0FBQyxDQUFDLElBQUk7Z0JBQ3pELElBQUk5SSxTQUFTdUksUUFBUTtvQkFDbkIsT0FBT0YsTUFBTXBLLFVBQVUwSyxhQUFhekcsV0FBVzBHO2dCQUNqRDtnQkFDQzVJLENBQUFBLE9BQU9QLEtBQUssR0FBR29KLGtCQUFrQkUsTUFBTSxHQUFHRixrQkFBa0JHLE9BQU8sRUFBRWhKLE9BQU9KLEtBQUs7Z0JBQ2xGLE9BQU9pSixrQkFBa0JJLE9BQU87WUFDbEM7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDcksseUJBQXlCakIsMEJBQTBCQyxnQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsZ0NBQW1CQSxDQUFDO1FBQzVCLElBQUlzTCxRQUFRdEwsZ0NBQW1CQSxDQUFDO1FBQ2hDLElBQUl1TCxnQ0FBZ0N2TCxnQ0FBbUJBLENBQUM7UUFDeEQsSUFBSXdMLHlCQUF5QnhMLGdDQUFtQkEsQ0FBQztRQUVqRCxJQUFJd0csU0FBUyxDQUFDZ0YsdUJBQXVCLFlBQVksQ0FBQ0QsOEJBQThCO1FBRWhGLCtCQUErQjtRQUMvQixtREFBbUQ7UUFDbkR0SyxFQUFFO1lBQUVNLFFBQVE7WUFBT0MsT0FBTztZQUFNQyxNQUFNO1lBQU1DLFFBQVE4RTtRQUFPLEdBQUc7WUFDNUQ4RSxPQUFPQTtRQUNUO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUN0Syx5QkFBeUJqQiwwQkFBMEJDLGdDQUFtQkE7UUFHOUUsSUFBSWlCLElBQUlqQixnQ0FBbUJBLENBQUM7UUFDNUIsSUFBSUksT0FBT0osZ0NBQW1CQSxDQUFDO1FBQy9CLElBQUlLLFlBQVlMLGdDQUFtQkEsQ0FBQztRQUNwQyxJQUFJTSxXQUFXTixnQ0FBbUJBLENBQUM7UUFDbkMsSUFBSW1CLG9CQUFvQm5CLGdDQUFtQkEsQ0FBQztRQUM1QyxJQUFJbUcsc0JBQXNCbkcsZ0NBQW1CQSxDQUFDO1FBQzlDLElBQUl5TCwrQkFBK0J6TCxnQ0FBbUJBLENBQUM7UUFDdkQsSUFBSW9CLGdCQUFnQnBCLGdDQUFtQkEsQ0FBQztRQUN4QyxJQUFJcUcsd0NBQXdDckcsZ0NBQW1CQSxDQUFDO1FBQ2hFLElBQUlxQiwyQ0FBMkNyQixnQ0FBbUJBLENBQUM7UUFDbkUsSUFBSW9HLFVBQVVwRyxnQ0FBbUJBLENBQUM7UUFFbEMsSUFBSTBMLDJDQUEyQyxDQUFDdEYsV0FBVyxDQUFDQyxzQ0FBc0MsT0FBTyxZQUEwQjtRQUNuSSxJQUFJc0YsZ0NBQWdDLENBQUN2RixXQUFXLENBQUNzRiw0Q0FDNUNySyx5Q0FBeUMsT0FBT1g7UUFFckQsSUFBSThGLFNBQVNKLFdBQVdzRiw0Q0FBNENDO1FBRXBFLElBQUlsRixnQkFBZ0JOLG9CQUFvQjtZQUN0QyxJQUFJTCxXQUFXLElBQUksQ0FBQ0EsUUFBUTtZQUM1QixJQUFJMUQsU0FBUzlCLFNBQVNGLEtBQUssSUFBSSxDQUFDMkYsSUFBSSxFQUFFRDtZQUN0QyxJQUFJRyxPQUFPLElBQUksQ0FBQ0EsSUFBSSxHQUFHLENBQUMsQ0FBQzdELE9BQU82RCxJQUFJO1lBQ3BDLElBQUksQ0FBQ0EsTUFBTSxPQUFPd0YsNkJBQTZCM0YsVUFBVSxJQUFJLENBQUNZLE1BQU0sRUFBRTtnQkFBQ3RFLE9BQU9KLEtBQUs7Z0JBQUUsSUFBSSxDQUFDRCxPQUFPO2FBQUcsRUFBRTtRQUN4RztRQUVBLGtDQUFrQztRQUNsQyxzREFBc0Q7UUFDdERkLEVBQUU7WUFBRU0sUUFBUTtZQUFZQyxPQUFPO1lBQU1DLE1BQU07WUFBTUMsUUFBUThFO1FBQU8sR0FBRztZQUNqRW9GLEtBQUssU0FBU0EsSUFBSWxGLE1BQU07Z0JBQ3RCcEcsU0FBUyxJQUFJO2dCQUNiLElBQUk7b0JBQ0ZELFVBQVVxRztnQkFDWixFQUFFLE9BQU83RSxPQUFPO29CQUNkVCxjQUFjLElBQUksRUFBRSxTQUFTUztnQkFDL0I7Z0JBRUEsSUFBSThKLCtCQUErQixPQUFPdkwsS0FBS3VMLCtCQUErQixJQUFJLEVBQUVqRjtnQkFFcEYsT0FBTyxJQUFJRCxjQUFjdEYsa0JBQWtCLElBQUksR0FBRztvQkFDaER1RixRQUFRQTtnQkFDVjtZQUNGO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQzVHO1FBR1IsOENBQThDO1FBQzlDLGlEQUFpRDtRQUNqREEsT0FBT0ksT0FBTyxHQUFHLFNBQVUyTCxHQUFHO1lBQzVCLE9BQU87Z0JBQ0wvRixVQUFVK0Y7Z0JBQ1Y5RixNQUFNOEYsSUFBSTlGLElBQUk7Z0JBQ2RFLE1BQU07WUFDUjtRQUNGO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNuRyxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSXFDLGNBQWNyQyxnQ0FBbUJBLENBQUM7UUFDdEMsSUFBSXVDLFNBQVN2QyxnQ0FBbUJBLENBQUM7UUFDakMsSUFBSThMLGtCQUFrQjlMLGdDQUFtQkEsQ0FBQztRQUMxQyxJQUFJK0wsVUFBVy9MLGdDQUFtQkEsQ0FBQyxNQUFNK0wsT0FBTztRQUNoRCxJQUFJNUMsYUFBYW5KLGdDQUFtQkEsQ0FBQztRQUVyQyxJQUFJZ00sT0FBTzNKLFlBQVksRUFBRSxDQUFDMkosSUFBSTtRQUU5QmxNLE9BQU9JLE9BQU8sR0FBRyxTQUFVK0wsTUFBTSxFQUFFQyxLQUFLO1lBQ3RDLElBQUkxRCxJQUFJc0QsZ0JBQWdCRztZQUN4QixJQUFJdkcsSUFBSTtZQUNSLElBQUl0RCxTQUFTLEVBQUU7WUFDZixJQUFJK0o7WUFDSixJQUFLQSxPQUFPM0QsRUFBRyxDQUFDakcsT0FBTzRHLFlBQVlnRCxRQUFRNUosT0FBT2lHLEdBQUcyRCxRQUFRSCxLQUFLNUosUUFBUStKO1lBQzFFLCtCQUErQjtZQUMvQixNQUFPRCxNQUFNbkwsTUFBTSxHQUFHMkUsRUFBRyxJQUFJbkQsT0FBT2lHLEdBQUcyRCxNQUFNRCxLQUFLLENBQUN4RyxJQUFJLEdBQUc7Z0JBQ3hELENBQUNxRyxRQUFRM0osUUFBUStKLFFBQVFILEtBQUs1SixRQUFRK0o7WUFDeEM7WUFDQSxPQUFPL0o7UUFDVDtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDdEMsUUFBUUMsMEJBQTBCQyxnQ0FBbUJBO1FBRzdELElBQUk0RCxjQUFjNUQsZ0NBQW1CQSxDQUFDO1FBQ3RDLElBQUltRCxpQkFBaUJuRCxnQ0FBbUJBLENBQUM7UUFFekNGLE9BQU9JLE9BQU8sR0FBRyxTQUFVcUIsTUFBTSxFQUFFc0MsSUFBSSxFQUFFdUksVUFBVTtZQUNqRCxJQUFJQSxXQUFXcEosR0FBRyxFQUFFWSxZQUFZd0ksV0FBV3BKLEdBQUcsRUFBRWEsTUFBTTtnQkFBRUUsUUFBUTtZQUFLO1lBQ3JFLElBQUlxSSxXQUFXOUMsR0FBRyxFQUFFMUYsWUFBWXdJLFdBQVc5QyxHQUFHLEVBQUV6RixNQUFNO2dCQUFFRyxRQUFRO1lBQUs7WUFDckUsT0FBT2IsZUFBZStILENBQUMsQ0FBQzNKLFFBQVFzQyxNQUFNdUk7UUFDeEM7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3RNLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJa0ksa0JBQWtCbEksZ0NBQW1CQSxDQUFDO1FBRTFDLElBQUlxTSxnQkFBZ0JuRSxnQkFBZ0I7UUFDcEMsSUFBSXJCLE9BQU8sQ0FBQztRQUVaQSxJQUFJLENBQUN3RixjQUFjLEdBQUc7UUFFdEJ2TSxPQUFPSSxPQUFPLEdBQUdnRCxPQUFPMkQsVUFBVTtJQUdsQyxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQy9HLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJcUMsY0FBY3JDLGdDQUFtQkEsQ0FBQztRQUV0QyxJQUFJMEUsV0FBV3JDLFlBQVksQ0FBQyxFQUFFcUMsUUFBUTtRQUN0QyxJQUFJckIsY0FBY2hCLFlBQVksR0FBR2lCLEtBQUs7UUFFdEN4RCxPQUFPSSxPQUFPLEdBQUcsU0FBVUMsRUFBRTtZQUMzQixPQUFPa0QsWUFBWXFCLFNBQVN2RSxLQUFLLEdBQUcsQ0FBQztRQUN2QztJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDTCxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSXNDLFFBQVF0QyxnQ0FBbUJBLENBQUM7UUFFaENGLE9BQU9JLE9BQU8sR0FBRyxDQUFDb0MsTUFBTTtZQUN0QixTQUFTZ0ssS0FBa0I7WUFDM0JBLEVBQUVqSSxTQUFTLENBQUNGLFdBQVcsR0FBRztZQUMxQiwrRUFBK0U7WUFDL0UsT0FBT2YsT0FBT21KLGNBQWMsQ0FBQyxJQUFJRCxTQUFTQSxFQUFFakksU0FBUztRQUN2RDtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDdkUsUUFBUUMsMEJBQTBCQyxnQ0FBbUJBO1FBRzdELElBQUlrRixjQUFhbEYsZ0NBQW1CQSxDQUFDO1FBQ3JDLElBQUlxQyxjQUFjckMsZ0NBQW1CQSxDQUFDO1FBRXRDLElBQUlzRixjQUFhSixZQUFXSSxVQUFVO1FBQ3RDLElBQUlrSCxlQUFjdEgsWUFBV3NILFdBQVc7UUFDeEMsSUFBSUMsWUFBV3ZILFlBQVd1SCxRQUFRO1FBQ2xDLElBQUlDLE1BQU1uRixLQUFLbUYsR0FBRztRQUNsQixJQUFJQyxVQUFVO1FBQ2QsSUFBSWxFLE9BQU9wRyxZQUFZc0ssUUFBUWxFLElBQUk7UUFDbkMsSUFBSXBGLGNBQWNoQixZQUFZLEdBQUdpQixLQUFLO1FBRXRDeEQsT0FBT0ksT0FBTyxHQUFHLFNBQVUwTSxNQUFNLEVBQUVDLElBQUk7WUFDckMsSUFBSUMsZUFBZUYsT0FBTzdMLE1BQU07WUFDaEMsSUFBSStMLGVBQWUsTUFBTSxHQUFHLE1BQU0sSUFBSU4sYUFBWTtZQUNsRCxJQUFJTyxZQUFZRixPQUFPSCxJQUFJRyxLQUFLOUwsTUFBTSxFQUFFK0wsZUFBZSxLQUFLQSxlQUFlO1lBQzNFLElBQUlFLFFBQVFILFFBQVEsSUFBSXZILFlBQVd5SDtZQUNuQyxJQUFJRSxPQUFPO1lBQ1gsSUFBSUMsVUFBVTtZQUNkLE1BQU9BLFVBQVVILFVBQVc7Z0JBQzFCLElBQUlJLFNBQVM5SixZQUFZdUosUUFBUUssTUFBTUEsUUFBUTtnQkFDL0MsSUFBSXhFLEtBQUtrRSxTQUFTUSxTQUFTLE1BQU0sSUFBSVgsYUFBWTtnQkFDakRRLEtBQUssQ0FBQ0UsVUFBVSxHQUFHVCxVQUFTVSxRQUFRO1lBQ3RDO1lBQ0EsT0FBTztnQkFBRUgsT0FBT0E7Z0JBQU9DLE1BQU1BO1lBQUs7UUFDcEM7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ25OLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCx1Q0FBdUMsR0FDdkMsSUFBSU0sV0FBV04sZ0NBQW1CQSxDQUFDO1FBQ25DLElBQUlvTix5QkFBeUJwTixnQ0FBbUJBLENBQUM7UUFDakQsSUFBSXNJLGNBQWN0SSxnQ0FBbUJBLENBQUM7UUFDdEMsSUFBSW1KLGFBQWFuSixnQ0FBbUJBLENBQUM7UUFDckMsSUFBSXFOLE9BQU9yTixnQ0FBbUJBLENBQUM7UUFDL0IsSUFBSXNOLHdCQUF3QnROLGdDQUFtQkEsQ0FBQztRQUNoRCxJQUFJa0osWUFBWWxKLGdDQUFtQkEsQ0FBQztRQUVwQyxJQUFJdU4sS0FBSztRQUNULElBQUlDLEtBQUs7UUFDVCxJQUFJQyxZQUFZO1FBQ2hCLElBQUlDLFNBQVM7UUFDYixJQUFJQyxXQUFXekUsVUFBVTtRQUV6QixJQUFJMEUsbUJBQW1CLFlBQTBCO1FBRWpELElBQUlDLFlBQVksU0FBVUMsT0FBTztZQUMvQixPQUFPTixLQUFLRSxTQUFTSCxLQUFLTyxVQUFVTixLQUFLLE1BQU1FLFNBQVNIO1FBQzFEO1FBRUEsc0ZBQXNGO1FBQ3RGLElBQUlRLDRCQUE0QixTQUFVQyxlQUFlO1lBQ3ZEQSxnQkFBZ0JDLEtBQUssQ0FBQ0osVUFBVTtZQUNoQ0csZ0JBQWdCRSxLQUFLO1lBQ3JCLElBQUlDLE9BQU9ILGdCQUFnQkksWUFBWSxDQUFDaEwsTUFBTTtZQUM5QyxzRUFBc0U7WUFDdEU0SyxrQkFBa0I7WUFDbEIsT0FBT0c7UUFDVDtRQUVBLHFGQUFxRjtRQUNyRixJQUFJRSwyQkFBMkI7WUFDN0Isc0NBQXNDO1lBQ3RDLElBQUlDLFNBQVNoQixzQkFBc0I7WUFDbkMsSUFBSWlCLEtBQUssU0FBU2IsU0FBUztZQUMzQixJQUFJYztZQUNKRixPQUFPRyxLQUFLLENBQUNDLE9BQU8sR0FBRztZQUN2QnJCLEtBQUtzQixXQUFXLENBQUNMO1lBQ2pCLGlEQUFpRDtZQUNqREEsT0FBT00sR0FBRyxHQUFHMUwsT0FBT3FMO1lBQ3BCQyxpQkFBaUJGLE9BQU9PLGFBQWEsQ0FBQ0MsUUFBUTtZQUM5Q04sZUFBZU8sSUFBSTtZQUNuQlAsZUFBZVAsS0FBSyxDQUFDSixVQUFVO1lBQy9CVyxlQUFlTixLQUFLO1lBQ3BCLE9BQU9NLGVBQWVsQyxDQUFDO1FBQ3pCO1FBRUEsaURBQWlEO1FBQ2pELG1FQUFtRTtRQUNuRSxzREFBc0Q7UUFDdEQsNkVBQTZFO1FBQzdFLGtCQUFrQjtRQUNsQixJQUFJMEI7UUFDSixJQUFJZ0Isa0JBQWtCO1lBQ3BCLElBQUk7Z0JBQ0ZoQixrQkFBa0IsSUFBSWlCLGNBQWM7WUFDdEMsRUFBRSxPQUFPcE4sT0FBTyxDQUFlO1lBQy9CbU4sa0JBQWtCLE9BQU9GLFlBQVksY0FDakNBLFNBQVNJLE1BQU0sSUFBSWxCLGtCQUNqQkQsMEJBQTBCQyxpQkFBaUIsU0FBUztlQUNwREssNkJBQ0ZOLDBCQUEwQkMsa0JBQWtCLE1BQU07WUFDdEQsSUFBSWpOLFNBQVN1SCxZQUFZdkgsTUFBTTtZQUMvQixNQUFPQSxTQUFVLE9BQU9pTyxlQUFlLENBQUN2QixVQUFVLENBQUNuRixXQUFXLENBQUN2SCxPQUFPLENBQUM7WUFDdkUsT0FBT2lPO1FBQ1Q7UUFFQTdGLFVBQVUsQ0FBQ3dFLFNBQVMsR0FBRztRQUV2Qix5QkFBeUI7UUFDekIsNkNBQTZDO1FBQzdDLHVEQUF1RDtRQUN2RDdOLE9BQU9JLE9BQU8sR0FBR2tELE9BQU8rTCxNQUFNLElBQUksU0FBU0EsT0FBTzNHLENBQUMsRUFBRTRHLFVBQVU7WUFDN0QsSUFBSWhOO1lBQ0osSUFBSW9HLE1BQU0sTUFBTTtnQkFDZG9GLGdCQUFnQixDQUFDSCxVQUFVLEdBQUduTixTQUFTa0k7Z0JBQ3ZDcEcsU0FBUyxJQUFJd0w7Z0JBQ2JBLGdCQUFnQixDQUFDSCxVQUFVLEdBQUc7Z0JBQzlCLHFEQUFxRDtnQkFDckRyTCxNQUFNLENBQUN1TCxTQUFTLEdBQUduRjtZQUNyQixPQUFPcEcsU0FBUzRNO1lBQ2hCLE9BQU9JLGVBQWU5SyxZQUFZbEMsU0FBU2dMLHVCQUF1QmxDLENBQUMsQ0FBQzlJLFFBQVFnTjtRQUM5RTtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDcE8seUJBQXlCakIsMEJBQTBCQyxnQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsZ0NBQW1CQSxDQUFDO1FBQzVCLElBQUlxUCxlQUFlclAsZ0NBQW1CQSxDQUFDO1FBQ3ZDLElBQUl3TCx5QkFBeUJ4TCxnQ0FBbUJBLENBQUM7UUFFakQsSUFBSXNQLFlBQVksQ0FBQzlELHVCQUF1QixnQkFBZ0IsU0FBVXBKLE1BQU07WUFDdEUsT0FBTyxDQUFDQTtRQUNWO1FBRUEsc0NBQXNDO1FBQ3RDLDBEQUEwRDtRQUMxRG5CLEVBQUU7WUFBRU0sUUFBUTtZQUFPQyxPQUFPO1lBQU1DLE1BQU07WUFBTUMsUUFBUTROO1FBQVUsR0FBRztZQUMvREQsY0FBY0E7UUFDaEI7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3JPLHlCQUF5QmpCLDBCQUEwQkMsZ0NBQW1CQTtRQUc5RSxJQUFJaUIsSUFBSWpCLGdDQUFtQkEsQ0FBQztRQUM1QixJQUFJSSxPQUFPSixnQ0FBbUJBLENBQUM7UUFDL0IsSUFBSUssWUFBWUwsZ0NBQW1CQSxDQUFDO1FBQ3BDLElBQUlNLFdBQVdOLGdDQUFtQkEsQ0FBQztRQUNuQyxJQUFJbUIsb0JBQW9CbkIsZ0NBQW1CQSxDQUFDO1FBQzVDLElBQUltRyxzQkFBc0JuRyxnQ0FBbUJBLENBQUM7UUFDOUMsSUFBSXlMLCtCQUErQnpMLGdDQUFtQkEsQ0FBQztRQUN2RCxJQUFJb0csVUFBVXBHLGdDQUFtQkEsQ0FBQztRQUNsQyxJQUFJb0IsZ0JBQWdCcEIsZ0NBQW1CQSxDQUFDO1FBQ3hDLElBQUlxRyx3Q0FBd0NyRyxnQ0FBbUJBLENBQUM7UUFDaEUsSUFBSXFCLDJDQUEyQ3JCLGdDQUFtQkEsQ0FBQztRQUVuRSxJQUFJdVAsOENBQThDLENBQUNuSixXQUFXLENBQUNDLHNDQUFzQyxVQUFVLFlBQTBCO1FBQ3pJLElBQUltSixtQ0FBbUMsQ0FBQ3BKLFdBQVcsQ0FBQ21KLCtDQUMvQ2xPLHlDQUF5QyxVQUFVWDtRQUV4RCxJQUFJOEYsU0FBU0osV0FBV21KLCtDQUErQ0M7UUFFdkUsSUFBSS9JLGdCQUFnQk4sb0JBQW9CO1lBQ3RDLElBQUlMLFdBQVcsSUFBSSxDQUFDQSxRQUFRO1lBQzVCLElBQUlsRSxZQUFZLElBQUksQ0FBQ0EsU0FBUztZQUM5QixJQUFJbUUsT0FBTyxJQUFJLENBQUNBLElBQUk7WUFDcEIsSUFBSTNELFFBQVE2RCxNQUFNakU7WUFDbEIsTUFBTyxLQUFNO2dCQUNYSSxTQUFTOUIsU0FBU0YsS0FBSzJGLE1BQU1EO2dCQUM3QkcsT0FBTyxJQUFJLENBQUNBLElBQUksR0FBRyxDQUFDLENBQUM3RCxPQUFPNkQsSUFBSTtnQkFDaEMsSUFBSUEsTUFBTTtnQkFDVmpFLFFBQVFJLE9BQU9KLEtBQUs7Z0JBQ3BCLElBQUl5Siw2QkFBNkIzRixVQUFVbEUsV0FBVztvQkFBQ0k7b0JBQU8sSUFBSSxDQUFDRCxPQUFPO2lCQUFHLEVBQUUsT0FBTyxPQUFPQztZQUMvRjtRQUNGO1FBRUEscUNBQXFDO1FBQ3JDLHlEQUF5RDtRQUN6RGYsRUFBRTtZQUFFTSxRQUFRO1lBQVlDLE9BQU87WUFBTUMsTUFBTTtZQUFNQyxRQUFROEU7UUFBTyxHQUFHO1lBQ2pFaUosUUFBUSxTQUFTQSxPQUFPN04sU0FBUztnQkFDL0J0QixTQUFTLElBQUk7Z0JBQ2IsSUFBSTtvQkFDRkQsVUFBVXVCO2dCQUNaLEVBQUUsT0FBT0MsT0FBTztvQkFDZFQsY0FBYyxJQUFJLEVBQUUsU0FBU1M7Z0JBQy9CO2dCQUVBLElBQUkyTixrQ0FBa0MsT0FBT3BQLEtBQUtvUCxrQ0FBa0MsSUFBSSxFQUFFNU47Z0JBRTFGLE9BQU8sSUFBSTZFLGNBQWN0RixrQkFBa0IsSUFBSSxHQUFHO29CQUNoRFMsV0FBV0E7Z0JBQ2I7WUFDRjtRQUNGO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUM5QjtRQUdSLDhDQUE4QztRQUM5QyxzREFBc0Q7UUFDdERBLE9BQU9JLE9BQU8sR0FBRyxTQUFVOEIsS0FBSyxFQUFFaUUsSUFBSTtZQUNwQyxPQUFPO2dCQUFFakUsT0FBT0E7Z0JBQU9pRSxNQUFNQTtZQUFLO1FBQ3BDO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNuRyxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSTBFLFdBQVcxRSxnQ0FBbUJBLENBQUM7UUFFbkNGLE9BQU9JLE9BQU8sR0FBRyxTQUFVUyxRQUFRLEVBQUUrTyxRQUFRO1lBQzNDLE9BQU8vTyxhQUFhMkQsWUFBWXhELFVBQVVDLE1BQU0sR0FBRyxJQUFJLEtBQUsyTyxXQUFXaEwsU0FBUy9EO1FBQ2xGO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNiLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJOEcsT0FBTzlHLGdDQUFtQkEsQ0FBQztRQUMvQixJQUFJSSxPQUFPSixnQ0FBbUJBLENBQUM7UUFDL0IsSUFBSU0sV0FBV04sZ0NBQW1CQSxDQUFDO1FBQ25DLElBQUlPLGNBQWNQLGdDQUFtQkEsQ0FBQztRQUN0QyxJQUFJMlAsd0JBQXdCM1AsZ0NBQW1CQSxDQUFDO1FBQ2hELElBQUk0UCxvQkFBb0I1UCxnQ0FBbUJBLENBQUM7UUFDNUMsSUFBSWlILGdCQUFnQmpILGdDQUFtQkEsQ0FBQztRQUN4QyxJQUFJNlAsY0FBYzdQLGdDQUFtQkEsQ0FBQztRQUN0QyxJQUFJUSxvQkFBb0JSLGdDQUFtQkEsQ0FBQztRQUM1QyxJQUFJb0IsZ0JBQWdCcEIsZ0NBQW1CQSxDQUFDO1FBRXhDLElBQUlTLGFBQWFDO1FBRWpCLElBQUlvUCxTQUFTLFNBQVVqSCxPQUFPLEVBQUV6RyxNQUFNO1lBQ3BDLElBQUksQ0FBQ3lHLE9BQU8sR0FBR0E7WUFDZixJQUFJLENBQUN6RyxNQUFNLEdBQUdBO1FBQ2hCO1FBRUEsSUFBSTJOLGtCQUFrQkQsT0FBT3pMLFNBQVM7UUFFdEN2RSxPQUFPSSxPQUFPLEdBQUcsU0FBVThQLFFBQVEsRUFBRUMsZUFBZSxFQUFFbk0sT0FBTztZQUMzRCxJQUFJb00sT0FBT3BNLFdBQVdBLFFBQVFvTSxJQUFJO1lBQ2xDLElBQUlDLGFBQWEsQ0FBQyxDQUFFck0sQ0FBQUEsV0FBV0EsUUFBUXFNLFVBQVU7WUFDakQsSUFBSWpPLFlBQVksQ0FBQyxDQUFFNEIsQ0FBQUEsV0FBV0EsUUFBUTVCLFNBQVM7WUFDL0MsSUFBSWtPLGNBQWMsQ0FBQyxDQUFFdE0sQ0FBQUEsV0FBV0EsUUFBUXNNLFdBQVc7WUFDbkQsSUFBSWpPLGNBQWMsQ0FBQyxDQUFFMkIsQ0FBQUEsV0FBV0EsUUFBUTNCLFdBQVc7WUFDbkQsSUFBSXlELEtBQUtrQixLQUFLbUosaUJBQWlCQztZQUMvQixJQUFJcEssVUFBVXVLLFFBQVFDLE9BQU92UCxRQUFRcUIsUUFBUTJELE1BQU1DO1lBRW5ELElBQUkvRCxPQUFPLFNBQVVzTyxTQUFTO2dCQUM1QixJQUFJekssVUFBVTFFLGNBQWMwRSxVQUFVO2dCQUN0QyxPQUFPLElBQUlnSyxPQUFPLE1BQU1TO1lBQzFCO1lBRUEsSUFBSUMsU0FBUyxTQUFVeE8sS0FBSztnQkFDMUIsSUFBSW1PLFlBQVk7b0JBQ2Q3UCxTQUFTMEI7b0JBQ1QsT0FBT0csY0FBY3lELEdBQUc1RCxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxFQUFFQyxRQUFRMkQsR0FBRzVELEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFO2dCQUMzRTtnQkFBRSxPQUFPRyxjQUFjeUQsR0FBRzVELE9BQU9DLFFBQVEyRCxHQUFHNUQ7WUFDOUM7WUFFQSxJQUFJRSxXQUFXO2dCQUNiNEQsV0FBV2tLLFNBQVNsSyxRQUFRO1lBQzlCLE9BQU8sSUFBSXNLLGFBQWE7Z0JBQ3RCdEssV0FBV2tLO1lBQ2IsT0FBTztnQkFDTEssU0FBUzdQLGtCQUFrQndQO2dCQUMzQixJQUFJLENBQUNLLFFBQVEsTUFBTSxJQUFJNVAsV0FBV0YsWUFBWXlQLFlBQVk7Z0JBQzFELG1DQUFtQztnQkFDbkMsSUFBSUwsc0JBQXNCVSxTQUFTO29CQUNqQyxJQUFLQyxRQUFRLEdBQUd2UCxTQUFTNk8sa0JBQWtCSSxXQUFXalAsU0FBU3VQLE9BQU9BLFFBQVM7d0JBQzdFbE8sU0FBU29PLE9BQU9SLFFBQVEsQ0FBQ00sTUFBTTt3QkFDL0IsSUFBSWxPLFVBQVU2RSxjQUFjOEksaUJBQWlCM04sU0FBUyxPQUFPQTtvQkFDL0Q7b0JBQUUsT0FBTyxJQUFJME4sT0FBTztnQkFDdEI7Z0JBQ0FoSyxXQUFXK0osWUFBWUcsVUFBVUs7WUFDbkM7WUFFQXRLLE9BQU83RCxZQUFZOE4sU0FBU2pLLElBQUksR0FBR0QsU0FBU0MsSUFBSTtZQUNoRCxNQUFPLENBQUMsQ0FBQ0MsT0FBTzVGLEtBQUsyRixNQUFNRCxTQUFRLEVBQUdHLElBQUksQ0FBRTtnQkFDMUMsSUFBSTtvQkFDRjdELFNBQVNvTyxPQUFPeEssS0FBS2hFLEtBQUs7Z0JBQzVCLEVBQUUsT0FBT0gsT0FBTztvQkFDZFQsY0FBYzBFLFVBQVUsU0FBU2pFO2dCQUNuQztnQkFDQSxJQUFJLE9BQU9PLFVBQVUsWUFBWUEsVUFBVTZFLGNBQWM4SSxpQkFBaUIzTixTQUFTLE9BQU9BO1lBQzVGO1lBQUUsT0FBTyxJQUFJME4sT0FBTztRQUN0QjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDaFEsUUFBUUMsMEJBQTBCQyxnQ0FBbUJBO1FBRzdELElBQUlJLE9BQU9KLGdDQUFtQkEsQ0FBQztRQUMvQixJQUFJK0ksV0FBVy9JLGdDQUFtQkEsQ0FBQztRQUNuQyxJQUFJeVEsV0FBV3pRLGdDQUFtQkEsQ0FBQztRQUNuQyxJQUFJK0gsWUFBWS9ILGdDQUFtQkEsQ0FBQztRQUNwQyxJQUFJMFEsc0JBQXNCMVEsZ0NBQW1CQSxDQUFDO1FBQzlDLElBQUlrSSxrQkFBa0JsSSxnQ0FBbUJBLENBQUM7UUFFMUMsSUFBSVMsYUFBYUM7UUFDakIsSUFBSWlRLGVBQWV6SSxnQkFBZ0I7UUFFbkMsbUNBQW1DO1FBQ25DLDJDQUEyQztRQUMzQ3BJLE9BQU9JLE9BQU8sR0FBRyxTQUFVMFEsS0FBSyxFQUFFQyxJQUFJO1lBQ3BDLElBQUksQ0FBQzlILFNBQVM2SCxVQUFVSCxTQUFTRyxRQUFRLE9BQU9BO1lBQ2hELElBQUlFLGVBQWUvSSxVQUFVNkksT0FBT0Q7WUFDcEMsSUFBSXZPO1lBQ0osSUFBSTBPLGNBQWM7Z0JBQ2hCLElBQUlELFNBQVN2TSxXQUFXdU0sT0FBTztnQkFDL0J6TyxTQUFTaEMsS0FBSzBRLGNBQWNGLE9BQU9DO2dCQUNuQyxJQUFJLENBQUM5SCxTQUFTM0csV0FBV3FPLFNBQVNyTyxTQUFTLE9BQU9BO2dCQUNsRCxNQUFNLElBQUkzQixXQUFXO1lBQ3ZCO1lBQ0EsSUFBSW9RLFNBQVN2TSxXQUFXdU0sT0FBTztZQUMvQixPQUFPSCxvQkFBb0JFLE9BQU9DO1FBQ3BDO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUMvUSxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSXVDLFNBQVN2QyxnQ0FBbUJBLENBQUM7UUFDakMsSUFBSUMsYUFBYUQsZ0NBQW1CQSxDQUFDO1FBQ3JDLElBQUkrUSxXQUFXL1EsZ0NBQW1CQSxDQUFDO1FBQ25DLElBQUlrSixZQUFZbEosZ0NBQW1CQSxDQUFDO1FBQ3BDLElBQUlnUiwyQkFBMkJoUixnQ0FBbUJBLENBQUM7UUFFbkQsSUFBSTJOLFdBQVd6RSxVQUFVO1FBQ3pCLElBQUlyQixVQUFVekU7UUFDZCxJQUFJNk4sa0JBQWtCcEosUUFBUXhELFNBQVM7UUFFdkMsaUNBQWlDO1FBQ2pDLHFEQUFxRDtRQUNyRCwrREFBK0Q7UUFDL0R2RSxPQUFPSSxPQUFPLEdBQUc4USwyQkFBMkJuSixRQUFRMEUsY0FBYyxHQUFHLFNBQVUvRCxDQUFDO1lBQzlFLElBQUl5RCxTQUFTOEUsU0FBU3ZJO1lBQ3RCLElBQUlqRyxPQUFPMEosUUFBUTBCLFdBQVcsT0FBTzFCLE1BQU0sQ0FBQzBCLFNBQVM7WUFDckQsSUFBSXhKLGNBQWM4SCxPQUFPOUgsV0FBVztZQUNwQyxJQUFJbEUsV0FBV2tFLGdCQUFnQjhILGtCQUFrQjlILGFBQWE7Z0JBQzVELE9BQU9BLFlBQVlFLFNBQVM7WUFDOUI7WUFBRSxPQUFPNEgsa0JBQWtCcEUsVUFBVW9KLGtCQUFrQjtRQUN6RDtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDblIsUUFBUUMsMEJBQTBCQyxnQ0FBbUJBO1FBRzdELElBQUlzQyxRQUFRdEMsZ0NBQW1CQSxDQUFDO1FBQ2hDLElBQUlDLGFBQWFELGdDQUFtQkEsQ0FBQztRQUVyQyxJQUFJa1IsY0FBYztRQUVsQixJQUFJQyxXQUFXLFNBQVVDLE9BQU8sRUFBRUMsU0FBUztZQUN6QyxJQUFJclAsUUFBUXNQLElBQUksQ0FBQ0MsVUFBVUgsU0FBUztZQUNwQyxPQUFPcFAsVUFBVXdQLFdBQVcsT0FDeEJ4UCxVQUFVeVAsU0FBUyxRQUNuQnhSLFdBQVdvUixhQUFhL08sTUFBTStPLGFBQzlCLENBQUMsQ0FBQ0E7UUFDUjtRQUVBLElBQUlFLFlBQVlKLFNBQVNJLFNBQVMsR0FBRyxTQUFVM0UsTUFBTTtZQUNuRCxPQUFPMUosT0FBTzBKLFFBQVFySixPQUFPLENBQUMyTixhQUFhLEtBQUtRLFdBQVc7UUFDN0Q7UUFFQSxJQUFJSixPQUFPSCxTQUFTRyxJQUFJLEdBQUcsQ0FBQztRQUM1QixJQUFJRyxTQUFTTixTQUFTTSxNQUFNLEdBQUc7UUFDL0IsSUFBSUQsV0FBV0wsU0FBU0ssUUFBUSxHQUFHO1FBRW5DMVIsT0FBT0ksT0FBTyxHQUFHaVI7SUFHakIsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNyUjtRQUdSLElBQUk2UixpQkFBaUI7UUFDckIsSUFBSUMsaUJBQWlCRCxpQkFBaUI7UUFDdEMsSUFBSUUsb0JBQW9CRixpQkFBaUI7UUFFekMsSUFBSUcsVUFBVSxTQUFVQyxVQUFVO1lBQ2hDLGlEQUFpRDtZQUNqRCxJQUFJM1AsU0FBUyxDQUFDO1lBQ2QsSUFBSWtPLFFBQVE7WUFDWixNQUFPQSxRQUFRLElBQUlBLFFBQVNsTyxNQUFNLENBQUMyUCxXQUFXQyxNQUFNLENBQUMxQixPQUFPLEdBQUdBO1lBQy9ELE9BQU9sTztRQUNUO1FBRUF0QyxPQUFPSSxPQUFPLEdBQUc7WUFDZitSLEtBQUtMO1lBQ0xNLEtBQUtKLFFBQVFGO1lBQ2JPLFFBQVFOO1lBQ1JPLFFBQVFOLFFBQVFEO1FBQ2xCO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUMvUjtRQUdSLElBQUlXLGFBQWFDO1FBRWpCWixPQUFPSSxPQUFPLEdBQUcsU0FBVW1TLE1BQU0sRUFBRUMsUUFBUTtZQUN6QyxJQUFJRCxTQUFTQyxVQUFVLE1BQU0sSUFBSTdSLFdBQVc7WUFDNUMsT0FBTzRSO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3ZTLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJa0YsY0FBYWxGLGdDQUFtQkEsQ0FBQztRQUVyQyxJQUFJdVMsYUFBWXJOLFlBQVdxTixTQUFTO1FBQ3BDLElBQUlDLFlBQVlELGNBQWFBLFdBQVVDLFNBQVM7UUFFaEQxUyxPQUFPSSxPQUFPLEdBQUdzUyxZQUFZdFAsT0FBT3NQLGFBQWE7SUFHakQsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUMxUyxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsbUNBQW1DLEdBQ25DLElBQUl5UyxzQkFBc0J6UyxnQ0FBbUJBLENBQUM7UUFDOUMsSUFBSStJLFdBQVcvSSxnQ0FBbUJBLENBQUM7UUFDbkMsSUFBSTBTLHlCQUF5QjFTLGdDQUFtQkEsQ0FBQztRQUNqRCxJQUFJMlMscUJBQXFCM1MsZ0NBQW1CQSxDQUFDO1FBRTdDLGlDQUFpQztRQUNqQyxxREFBcUQ7UUFDckQsd0VBQXdFO1FBQ3hFLCtEQUErRDtRQUMvREYsT0FBT0ksT0FBTyxHQUFHa0QsT0FBT3dQLGNBQWMsSUFBSyxnQkFBZSxDQUFDLElBQUk7WUFDN0QsSUFBSUMsaUJBQWlCO1lBQ3JCLElBQUloTSxPQUFPLENBQUM7WUFDWixJQUFJN0M7WUFDSixJQUFJO2dCQUNGQSxTQUFTeU8sb0JBQW9CclAsT0FBT2lCLFNBQVMsRUFBRSxhQUFhO2dCQUM1REwsT0FBTzZDLE1BQU0sRUFBRTtnQkFDZmdNLGlCQUFpQmhNLGdCQUFnQmlNO1lBQ25DLEVBQUUsT0FBT2pSLE9BQU8sQ0FBYztZQUM5QixPQUFPLFNBQVMrUSxlQUFlcEssQ0FBQyxFQUFFaEgsS0FBSztnQkFDckNrUix1QkFBdUJsSztnQkFDdkJtSyxtQkFBbUJuUjtnQkFDbkIsSUFBSSxDQUFDdUgsU0FBU1AsSUFBSSxPQUFPQTtnQkFDekIsSUFBSXFLLGdCQUFnQjdPLE9BQU93RSxHQUFHaEg7cUJBQ3pCZ0gsRUFBRXVLLFNBQVMsR0FBR3ZSO2dCQUNuQixPQUFPZ0g7WUFDVDtRQUNGLE1BQU1sRSxTQUFRO0lBR2QsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUN0RCx5QkFBeUJqQiwwQkFBMEJDLGdDQUFtQkE7UUFHOUUsb0VBQW9FO1FBQ3BFLDZIQUE2SDtRQUM3SCxJQUFJaUIsSUFBSWpCLGdDQUFtQkEsQ0FBQztRQUM1QixJQUFJcUMsY0FBY3JDLGdDQUFtQkEsQ0FBQztRQUN0QyxJQUFJa0IsVUFBVWxCLGdDQUFtQkEsQ0FBQztRQUVsQyxJQUFJZ1QsY0FBY0M7UUFDbEIsSUFBSXhTLGFBQWFDO1FBQ2pCLElBQUl3UyxZQUFZQztRQUNoQixJQUFJQyxPQUFPQztRQUNYLElBQUlDLE1BQU0vTCxLQUFLK0wsR0FBRztRQUNsQixJQUFJQyxNQUFNaE0sS0FBS2dNLEdBQUc7UUFDbEIsSUFBSXZILE9BQU8zSixZQUFZLEVBQUUsQ0FBQzJKLElBQUk7UUFFOUIsSUFBSXdILGFBQWFELElBQUksR0FBRztRQUN4QixJQUFJRSxtQkFBbUJGLElBQUksR0FBRyxNQUFNLEdBQUcsbUNBQW1DO1FBQzFFLElBQUlHLGFBQWFDLE9BQU9DLFNBQVMsRUFBRSwrREFBK0Q7UUFDbEcsSUFBSUMsVUFBVU4sSUFBSSxHQUFHLE1BQU0sbURBQW1EO1FBRTlFLElBQUlPLGVBQWUsQ0FBQztRQUNwQixJQUFJQyxpQkFBaUIsQ0FBQztRQUN0QixJQUFJQyxnQkFBZ0IsQ0FBQztRQUNyQixJQUFJQyxhQUFhLENBQUM7UUFDbEIsSUFBSUMsU0FBUyxDQUFDO1FBRWQsaUNBQWlDO1FBQ2pDLElBQUlDLFNBQVMsU0FBVXpNLENBQUMsRUFBRTBNLENBQUM7WUFDekIsSUFBSUMsS0FBSzNNLElBQUkwTTtZQUNiLElBQUlFLEtBQUtGLElBQUtDLENBQUFBLEtBQUszTSxDQUFBQTtZQUNuQixPQUFPO2dCQUFFMk0sSUFBSUE7Z0JBQUlDLElBQUlBO1lBQUc7UUFDMUI7UUFFQSwyQkFBMkI7UUFDM0IsNENBQTRDO1FBQzVDclQsRUFBRTtZQUFFTSxRQUFRO1lBQVF1SixNQUFNO1FBQUssR0FBRztZQUNoQyxnREFBZ0Q7WUFDaER5SixZQUFZLFNBQVNBLFdBQVdDLEtBQUs7Z0JBQ25DLElBQUlDLFVBQVUsRUFBRTtnQkFDaEIsSUFBSUMsUUFBUTtnQkFDWixJQUFJblEsUUFBUTBQO2dCQUVaL1MsUUFBUXNULE9BQU8sU0FBVTdNLENBQUM7b0JBQ3hCLElBQUksRUFBRStNLFNBQVNqQixrQkFBa0IsTUFBTSxJQUFJVCxZQUFZO29CQUN2RCxJQUFJLE9BQU9yTCxLQUFLLFVBQVUsTUFBTSxJQUFJbEgsV0FBVztvQkFDL0MsSUFBSThELFVBQVV1UCxjQUFjO3dCQUMxQix3REFBd0Q7d0JBQ3hELElBQUluTSxNQUFNQSxHQUFHcEQsUUFBUXVQOzZCQUNoQixJQUFJbk0sTUFBTXVMLFdBQVczTyxRQUFRQSxVQUFVd1AsaUJBQWlCRCxlQUFlRTs2QkFDdkUsSUFBSXJNLE1BQU0sQ0FBQ3VMLFdBQVczTyxRQUFRQSxVQUFVeVAsZ0JBQWdCRixlQUFlQzs2QkFDdkUsSUFBSSxDQUFDcE0sTUFBTSxLQUFLLElBQUtBLE1BQU91TCxTQUFRLEtBQU8zTyxDQUFBQSxVQUFVMFAsY0FBYzFQLFVBQVUyUCxNQUFLLEdBQUk7NEJBQ3pGM1AsUUFBUTJQOzRCQUNSbEksS0FBS3lJLFNBQVM5TTt3QkFDaEI7b0JBQ0Y7Z0JBQ0Y7Z0JBRUEsT0FBUXBEO29CQUNOLEtBQUt1UDt3QkFBYyxPQUFPVjtvQkFDMUIsS0FBS1c7d0JBQWdCLE9BQU8sQ0FBQ2I7b0JBQzdCLEtBQUtjO3dCQUFlLE9BQU9kO29CQUMzQixLQUFLZTt3QkFBWSxPQUFPLENBQUM7Z0JBQzNCO2dCQUVBLElBQUlVLFdBQVcsRUFBRTtnQkFDakIsSUFBSUMsV0FBVyxHQUFHLHNGQUFzRjtnQkFDeEcsSUFBSWxOLEdBQUcwTSxHQUFHUyxLQUFLUixJQUFJQyxJQUFJUTtnQkFFdkIsSUFBSyxJQUFJcFAsSUFBSSxHQUFHQSxJQUFJK08sUUFBUTFULE1BQU0sRUFBRTJFLElBQUs7b0JBQ3ZDZ0MsSUFBSStNLE9BQU8sQ0FBQy9PLEVBQUU7b0JBQ2QsSUFBSXFQLHVCQUF1QjtvQkFDM0IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlMLFNBQVM1VCxNQUFNLEVBQUVpVSxJQUFLO3dCQUN4Q1osSUFBSU8sUUFBUSxDQUFDSyxFQUFFO3dCQUNmLElBQUkxQixJQUFJNUwsS0FBSzRMLElBQUljLElBQUk7NEJBQ25CVSxNQUFNcE47NEJBQ05BLElBQUkwTTs0QkFDSkEsSUFBSVU7d0JBQ047d0JBQ0FELE1BQU1WLE9BQU96TSxHQUFHME07d0JBQ2hCQyxLQUFLUSxJQUFJUixFQUFFO3dCQUNYQyxLQUFLTyxJQUFJUCxFQUFFO3dCQUNYLElBQUloQixJQUFJZSxRQUFRbkIsV0FBVzs0QkFDekIsSUFBSStCLE9BQU9aLE9BQU9uQixZQUFZLElBQUksQ0FBQzs0QkFDbkMwQixZQUFZSzs0QkFFWnZOLElBQUksSUFBTXVOLE9BQU96QixhQUFnQnlCLE9BQU96Qjs0QkFDeEMsSUFBSUYsSUFBSTVMLEtBQUs0TCxJQUFJYyxJQUFJO2dDQUNuQlUsTUFBTXBOO2dDQUNOQSxJQUFJME07Z0NBQ0pBLElBQUlVOzRCQUNOOzRCQUNBRCxNQUFNVixPQUFPek0sR0FBRzBNOzRCQUNoQkMsS0FBS1EsSUFBSVIsRUFBRTs0QkFDWEMsS0FBS08sSUFBSVAsRUFBRTt3QkFDYjt3QkFDQSxJQUFJQSxPQUFPLEdBQUdLLFFBQVEsQ0FBQ0ksdUJBQXVCLEdBQUdUO3dCQUNqRDVNLElBQUkyTTtvQkFDTjtvQkFDQU0sU0FBUzVULE1BQU0sR0FBR2dVO29CQUNsQixJQUFJck4sTUFBTSxHQUFHc0UsS0FBSzJJLFVBQVVqTjtnQkFDOUI7Z0JBRUEscUVBQXFFO2dCQUNyRSxJQUFJQyxJQUFJZ04sU0FBUzVULE1BQU0sR0FBRztnQkFDMUJzVCxLQUFLO2dCQUNMQyxLQUFLO2dCQUVMLElBQUlNLGFBQWEsR0FBRztvQkFDbEIsSUFBSTdPLE9BQU80QixLQUFLLElBQUlnTixRQUFRLENBQUNoTixFQUFFLEdBQUc7b0JBQ2xDQTtvQkFDQSxJQUFJMkwsSUFBSXNCLFlBQVksS0FBTUEsV0FBVyxLQUFLN08sT0FBTyxLQUFPNk8sV0FBVyxLQUFLN08sT0FBTyxHQUFJO3dCQUNqRixPQUFPNk8sV0FBVyxJQUFJMUIsWUFBWSxDQUFDQTtvQkFDckM7b0JBQ0EsNkNBQTZDO29CQUM3QyxzREFBc0Q7b0JBQ3RELDhCQUE4QjtvQkFDOUIyQixNQUFNVixPQUFPUyxXQUFXcEIsWUFBWXpOLE9BQU87b0JBQzNDc08sS0FBS1EsSUFBSVIsRUFBRTtvQkFDWEMsS0FBS08sSUFBSVAsRUFBRTtvQkFDWEEsTUFBTTtvQkFDTixJQUFJaEIsSUFBSSxJQUFJZSxRQUFRbkIsV0FBVzt3QkFDN0IsZ0NBQWdDO3dCQUNoQyxJQUFJbUIsS0FBSyxHQUFHOzRCQUNWLE9BQU8sT0FBUWIsY0FBY2MsT0FBTyxDQUFFVCxDQUFBQSxVQUFVLE1BQU1sTSxLQUFLLEtBQUtnTixRQUFRLENBQUNoTixFQUFFLEdBQUcsSUFBSytMLGFBQWFSO3dCQUNsRzt3QkFBRSxPQUFPLE9BQVEsQ0FBQ00sY0FBY2MsT0FBUVQsVUFBVSxLQUFNbE0sS0FBSyxLQUFLZ04sUUFBUSxDQUFDaE4sRUFBRSxHQUFHLElBQUssQ0FBQytMLGFBQWEsQ0FBQ1I7b0JBQ3RHO29CQUVBLElBQUlvQixPQUFPLEdBQUc7d0JBQ1pLLFFBQVEsQ0FBQyxFQUFFaE4sRUFBRSxHQUFHMk07d0JBQ2hCQSxLQUFLO29CQUNQO29CQUVBRCxNQUFNO2dCQUNSO2dCQUVBLE1BQU8xTSxLQUFLLEVBQUc7b0JBQ2JrTixNQUFNVixPQUFPRSxJQUFJTSxRQUFRLENBQUNoTixJQUFJO29CQUM5QjBNLEtBQUtRLElBQUlSLEVBQUU7b0JBQ1hDLEtBQUtPLElBQUlQLEVBQUU7b0JBQ1gsSUFBSUEsT0FBTyxHQUFHO2dCQUNoQjtnQkFFQSxJQUFJM00sS0FBSyxLQUFNLE1BQU0sS0FBS2dOLFFBQVEsQ0FBQ2hOLEVBQUUsR0FBRyxLQUFPMk0sS0FBSyxLQUFLSyxRQUFRLENBQUNoTixFQUFFLEdBQUcsQ0FBQyxHQUFJO29CQUMxRXlNLElBQUlFLEtBQUs7b0JBQ1Q1TSxJQUFJMk0sS0FBS0Q7b0JBQ1QsSUFBSUEsTUFBTTFNLElBQUkyTSxJQUFJQSxLQUFLM007Z0JBQ3pCO2dCQUVBLE9BQU8yTTtZQUNUO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3ZVLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJQyxhQUFhRCxnQ0FBbUJBLENBQUM7UUFDckMsSUFBSStJLFdBQVcvSSxnQ0FBbUJBLENBQUM7UUFDbkMsSUFBSTRTLGlCQUFpQjVTLGdDQUFtQkEsQ0FBQztRQUV6Qyx1REFBdUQ7UUFDdkRGLE9BQU9JLE9BQU8sR0FBRyxTQUFVZ1YsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLE9BQU87WUFDOUMsSUFBSUMsV0FBV0M7WUFDZixJQUNFLGdEQUFnRDtZQUNoRDFDLGtCQUNBLGtGQUFrRjtZQUNsRjNTLFdBQVdvVixZQUFZRixNQUFNaFIsV0FBVyxLQUN4Q2tSLGNBQWNELFdBQ2RyTSxTQUFTdU0scUJBQXFCRCxVQUFVaFIsU0FBUyxLQUNqRGlSLHVCQUF1QkYsUUFBUS9RLFNBQVMsRUFDeEN1TyxlQUFlc0MsT0FBT0k7WUFDeEIsT0FBT0o7UUFDVDtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDcFYsUUFBUUMsMEJBQTBCQyxnQ0FBbUJBO1FBRzdELElBQUlrRixjQUFhbEYsZ0NBQW1CQSxDQUFDO1FBQ3JDLElBQUl1VixzQkFBc0J2VixnQ0FBbUJBLENBQUM7UUFDOUMsSUFBSXdWLHdCQUF3QnhWLGdDQUFtQkEsQ0FBQztRQUVoRCxJQUFJeVYsWUFBV3ZRLFlBQVd1USxRQUFRO1FBRWxDM1YsT0FBT0ksT0FBTyxHQUFHLFNBQVVzSSxDQUFDO1lBQzFCLElBQUksQ0FBQytNLHVCQUF1QkMsc0JBQXNCaE4sT0FBTyxHQUFHLE9BQU87WUFDbkUsSUFBSTtnQkFDRiw2Q0FBNkM7Z0JBQzdDLElBQUlpTixVQUFTak47Z0JBQ2IsT0FBTztZQUNULEVBQUUsT0FBTzNHLE9BQU87Z0JBQ2QsT0FBTztZQUNUO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQy9CLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJcUMsY0FBY3JDLGdDQUFtQkEsQ0FBQztRQUV0QyxJQUFJMFYsS0FBSztRQUNULElBQUlDLFVBQVVwTyxLQUFLcU8sTUFBTTtRQUN6QixJQUFJbFIsV0FBV3JDLFlBQVksSUFBSXFDLFFBQVE7UUFFdkM1RSxPQUFPSSxPQUFPLEdBQUcsU0FBVWlNLEdBQUc7WUFDNUIsT0FBTyxZQUFhQSxDQUFBQSxRQUFRN0gsWUFBWSxLQUFLNkgsR0FBRSxJQUFLLE9BQU96SCxTQUFTLEVBQUVnUixLQUFLQyxTQUFTO1FBQ3RGO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUM3VixRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSTZWLE9BQU83VixnQ0FBbUJBLENBQUM7UUFDL0IsSUFBSThWLGFBQWE5VixnQ0FBbUJBLENBQUM7UUFDckMsSUFBSXNLLFFBQVF0SyxnQ0FBbUJBLENBQUM7UUFDaEMsSUFBSStWLE9BQU8vVixnQ0FBbUJBLENBQUM7UUFDL0IsSUFBSWdXLGVBQWVoVyxnQ0FBbUJBLENBQUM7UUFDdkMsSUFBSWlXLGFBQWFqVyxnQ0FBbUJBLENBQUM7UUFDckMsSUFBSWtXLGdCQUFnQmxXLGdDQUFtQkEsQ0FBQztRQUV4QyxJQUFJdUosTUFBTXVNLFdBQVd2TSxHQUFHO1FBQ3hCLElBQUk0TSxTQUFTTCxXQUFXSyxNQUFNO1FBRTlCLG9DQUFvQztRQUNwQyx3REFBd0Q7UUFDeERyVyxPQUFPSSxPQUFPLEdBQUcsU0FBU2tXLFdBQVdDLEtBQUs7WUFDeEMsSUFBSTdOLElBQUlxTixLQUFLLElBQUk7WUFDakIsSUFBSVMsV0FBV04sYUFBYUs7WUFDNUIsSUFBSWpVLFNBQVNrSSxNQUFNOUI7WUFDbkIsSUFBSXVOLEtBQUt2TixNQUFNOE4sU0FBU1AsSUFBSSxFQUFFRSxXQUFXek4sR0FBRyxTQUFVK04sQ0FBQztnQkFDckQsSUFBSUQsU0FBU0UsUUFBUSxDQUFDRCxJQUFJSixPQUFPL1QsUUFBUW1VO1lBQzNDO2lCQUNLTCxjQUFjSSxTQUFTekcsV0FBVyxJQUFJLFNBQVUwRyxDQUFDO2dCQUNwRCxJQUFJaE4sSUFBSW5ILFFBQVFtVSxJQUFJSixPQUFPL1QsUUFBUW1VO1lBQ3JDO1lBQ0EsT0FBT25VO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3RDO1FBR1IsSUFBSVcsYUFBYUM7UUFFakJaLE9BQU9JLE9BQU8sR0FBRyxTQUFVUyxRQUFRO1lBQ2pDLElBQUksT0FBT0EsWUFBWSxVQUFVLE9BQU9BO1lBQ3hDLE1BQU0sSUFBSUYsV0FBVztRQUN2QjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDWCxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSXlXLHNCQUFzQnpXLGdDQUFtQkEsQ0FBQztRQUU5QyxJQUFJaUQsVUFBVUM7UUFDZCxJQUFJekMsYUFBYUM7UUFFakJaLE9BQU9JLE9BQU8sR0FBRyxTQUFVUyxRQUFRO1lBQ2pDLElBQUk4VixvQkFBb0I5VixXQUFXLE9BQU9BO1lBQzFDLE1BQU0sSUFBSUYsV0FBVyxlQUFld0MsUUFBUXRDLFlBQVk7UUFDMUQ7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ0sseUJBQXlCakIsMEJBQTBCQyxnQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsZ0NBQW1CQSxDQUFDO1FBQzVCLElBQUlJLE9BQU9KLGdDQUFtQkEsQ0FBQztRQUMvQixJQUFJa0IsVUFBVWxCLGdDQUFtQkEsQ0FBQztRQUNsQyxJQUFJSyxZQUFZTCxnQ0FBbUJBLENBQUM7UUFDcEMsSUFBSU0sV0FBV04sZ0NBQW1CQSxDQUFDO1FBQ25DLElBQUltQixvQkFBb0JuQixnQ0FBbUJBLENBQUM7UUFDNUMsSUFBSW9CLGdCQUFnQnBCLGdDQUFtQkEsQ0FBQztRQUN4QyxJQUFJcUIsMkNBQTJDckIsZ0NBQW1CQSxDQUFDO1FBRW5FLElBQUkwVyxpQ0FBaUNyVix5Q0FBeUMsUUFBUVg7UUFFdEYsbUNBQW1DO1FBQ25DLHVEQUF1RDtRQUN2RE8sRUFBRTtZQUFFTSxRQUFRO1lBQVlDLE9BQU87WUFBTUMsTUFBTTtZQUFNQyxRQUFRZ1Y7UUFBK0IsR0FBRztZQUN6RkMsTUFBTSxTQUFTQSxLQUFLL1UsU0FBUztnQkFDM0J0QixTQUFTLElBQUk7Z0JBQ2IsSUFBSTtvQkFDRkQsVUFBVXVCO2dCQUNaLEVBQUUsT0FBT0MsT0FBTztvQkFDZFQsY0FBYyxJQUFJLEVBQUUsU0FBU1M7Z0JBQy9CO2dCQUVBLElBQUk2VSxnQ0FBZ0MsT0FBT3RXLEtBQUtzVyxnQ0FBZ0MsSUFBSSxFQUFFOVU7Z0JBRXRGLElBQUlFLFNBQVNYLGtCQUFrQixJQUFJO2dCQUNuQyxJQUFJWSxVQUFVO2dCQUNkLE9BQU9iLFFBQVFZLFFBQVEsU0FBVUUsS0FBSyxFQUFFQyxJQUFJO29CQUMxQyxJQUFJTCxVQUFVSSxPQUFPRCxZQUFZLE9BQU9FO2dCQUMxQyxHQUFHO29CQUFFQyxXQUFXO29CQUFNQyxhQUFhO2dCQUFLLEdBQUcwRyxPQUFPO1lBQ3BEO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQy9JLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJNlYsT0FBTzdWLGdDQUFtQkEsQ0FBQztRQUMvQixJQUFJOFYsYUFBYTlWLGdDQUFtQkEsQ0FBQztRQUNyQyxJQUFJc0ssUUFBUXRLLGdDQUFtQkEsQ0FBQztRQUNoQyxJQUFJZ1csZUFBZWhXLGdDQUFtQkEsQ0FBQztRQUN2QyxJQUFJa1csZ0JBQWdCbFcsZ0NBQW1CQSxDQUFDO1FBRXhDLElBQUk0VyxNQUFNZCxXQUFXYyxHQUFHO1FBQ3hCLElBQUlyTixNQUFNdU0sV0FBV3ZNLEdBQUc7UUFDeEIsSUFBSTRNLFNBQVNMLFdBQVdLLE1BQU07UUFFOUIsNkNBQTZDO1FBQzdDLGlFQUFpRTtRQUNqRXJXLE9BQU9JLE9BQU8sR0FBRyxTQUFTMlcsb0JBQW9CUixLQUFLO1lBQ2pELElBQUk3TixJQUFJcU4sS0FBSyxJQUFJO1lBQ2pCLElBQUlpQixXQUFXZCxhQUFhSyxPQUFPeEcsV0FBVztZQUM5QyxJQUFJek4sU0FBU2tJLE1BQU05QjtZQUNuQjBOLGNBQWNZLFVBQVUsU0FBVVAsQ0FBQztnQkFDakMsSUFBSWhOLElBQUlmLEdBQUcrTixJQUFJSixPQUFPL1QsUUFBUW1VO3FCQUN6QkssSUFBSXhVLFFBQVFtVTtZQUNuQjtZQUNBLE9BQU9uVTtRQUNUO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUN0QyxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSXFDLGNBQWNyQyxnQ0FBbUJBLENBQUM7UUFDdEMsSUFBSUMsYUFBYUQsZ0NBQW1CQSxDQUFDO1FBQ3JDLElBQUkySixRQUFRM0osZ0NBQW1CQSxDQUFDO1FBRWhDLElBQUkrVyxtQkFBbUIxVSxZQUFZb0MsU0FBU0MsUUFBUTtRQUVwRCwrRUFBK0U7UUFDL0UsSUFBSSxDQUFDekUsV0FBVzBKLE1BQU1oSCxhQUFhLEdBQUc7WUFDcENnSCxNQUFNaEgsYUFBYSxHQUFHLFNBQVV4QyxFQUFFO2dCQUNoQyxPQUFPNFcsaUJBQWlCNVc7WUFDMUI7UUFDRjtRQUVBTCxPQUFPSSxPQUFPLEdBQUd5SixNQUFNaEgsYUFBYTtJQUdwQyxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQzNCLHlCQUF5QmQ7UUFHakMsc0VBQXNFO1FBQ3RFQSxRQUFRZ0wsQ0FBQyxHQUFHOUgsT0FBTzRULHFCQUFxQjtJQUd4QyxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2xYLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJc0MsUUFBUXRDLGdDQUFtQkEsQ0FBQztRQUVoQyx3REFBd0Q7UUFDeERGLE9BQU9JLE9BQU8sR0FBRyxDQUFDb0MsTUFBTTtZQUN0QiwrRUFBK0U7WUFDL0UsT0FBT2MsT0FBT0QsY0FBYyxDQUFDLENBQUMsR0FBRyxHQUFHO2dCQUFFSCxLQUFLO29CQUFjLE9BQU87Z0JBQUc7WUFBRSxFQUFFLENBQUMsRUFBRSxLQUFLO1FBQ2pGO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNsRCxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSUssWUFBWUwsZ0NBQW1CQSxDQUFDO1FBQ3BDLElBQUlNLFdBQVdOLGdDQUFtQkEsQ0FBQztRQUNuQyxJQUFJSSxPQUFPSixnQ0FBbUJBLENBQUM7UUFDL0IsSUFBSWlYLHNCQUFzQmpYLGdDQUFtQkEsQ0FBQztRQUM5QyxJQUFJbUIsb0JBQW9CbkIsZ0NBQW1CQSxDQUFDO1FBRTVDLElBQUlrWCxlQUFlO1FBQ25CLElBQUlsRSxjQUFjQztRQUNsQixJQUFJeFMsYUFBYUM7UUFDakIsSUFBSXlXLE1BQU01UCxLQUFLNFAsR0FBRztRQUVsQixJQUFJQyxZQUFZLFNBQVU5TixHQUFHLEVBQUUrTixPQUFPO1lBQ3BDLElBQUksQ0FBQy9OLEdBQUcsR0FBR0E7WUFDWCxJQUFJLENBQUN5TSxJQUFJLEdBQUdvQixJQUFJRSxTQUFTO1lBQ3pCLElBQUksQ0FBQzlOLEdBQUcsR0FBR2xKLFVBQVVpSixJQUFJQyxHQUFHO1lBQzVCLElBQUksQ0FBQ2hCLElBQUksR0FBR2xJLFVBQVVpSixJQUFJZixJQUFJO1FBQ2hDO1FBRUE2TyxVQUFVL1MsU0FBUyxHQUFHO1lBQ3BCd0wsYUFBYTtnQkFDWCxPQUFPMU8sa0JBQWtCYixTQUFTRixLQUFLLElBQUksQ0FBQ21JLElBQUksRUFBRSxJQUFJLENBQUNlLEdBQUc7WUFDNUQ7WUFDQWtOLFVBQVUsU0FBVXJXLEVBQUU7Z0JBQ3BCLE9BQU9DLEtBQUssSUFBSSxDQUFDbUosR0FBRyxFQUFFLElBQUksQ0FBQ0QsR0FBRyxFQUFFbko7WUFDbEM7UUFDRjtRQUVBLG9DQUFvQztRQUNwQyx5REFBeUQ7UUFDekRMLE9BQU9JLE9BQU8sR0FBRyxTQUFVMkwsR0FBRztZQUM1QnZMLFNBQVN1TDtZQUNULElBQUl5TCxVQUFVLENBQUN6TCxJQUFJa0ssSUFBSTtZQUN2Qix1REFBdUQ7WUFDdkQsd0RBQXdEO1lBQ3hELElBQUl1QixZQUFZQSxTQUFTLE1BQU0sSUFBSTdXLFdBQVd5VztZQUM5QyxJQUFJRyxVQUFVSixvQkFBb0JLO1lBQ2xDLElBQUlELFVBQVUsR0FBRyxNQUFNLElBQUlyRSxZQUFZa0U7WUFDdkMsT0FBTyxJQUFJRSxVQUFVdkwsS0FBS3dMO1FBQzVCO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUN2WCxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSTZWLE9BQU83VixnQ0FBbUJBLENBQUM7UUFDL0IsSUFBSStWLE9BQU8vVixnQ0FBbUJBLENBQUM7UUFDL0IsSUFBSWtCLFVBQVVsQixnQ0FBbUJBLENBQUM7UUFDbEMsSUFBSWdXLGVBQWVoVyxnQ0FBbUJBLENBQUM7UUFFdkMsb0NBQW9DO1FBQ3BDLHdEQUF3RDtRQUN4REYsT0FBT0ksT0FBTyxHQUFHLFNBQVNxWCxXQUFXbEIsS0FBSztZQUN4QyxJQUFJN04sSUFBSXFOLEtBQUssSUFBSTtZQUNqQixJQUFJUyxXQUFXTixhQUFhSztZQUM1QixJQUFJTixLQUFLdk4sS0FBSzhOLFNBQVNQLElBQUksRUFBRSxPQUFPO1lBQ3BDLE9BQU83VSxRQUFRc0gsR0FBRyxTQUFVK04sQ0FBQztnQkFDM0IsSUFBSSxDQUFDRCxTQUFTRSxRQUFRLENBQUNELElBQUksT0FBTztZQUNwQyxHQUFHLFVBQVU7UUFDZjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDdlYseUJBQXlCakIsMEJBQTBCQyxnQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsZ0NBQW1CQSxDQUFDO1FBQzVCLElBQUl3WCxpQkFBaUJ4WCxnQ0FBbUJBLENBQUM7UUFDekMsSUFBSXdMLHlCQUF5QnhMLGdDQUFtQkEsQ0FBQztRQUVqRCxJQUFJc1AsWUFBWSxDQUFDOUQsdUJBQXVCLGtCQUFrQixTQUFVcEosTUFBTTtZQUN4RSxPQUFPLENBQUNBO1FBQ1Y7UUFFQSx3Q0FBd0M7UUFDeEMsNERBQTREO1FBQzVEbkIsRUFBRTtZQUFFTSxRQUFRO1lBQU9DLE9BQU87WUFBTUMsTUFBTTtZQUFNQyxRQUFRNE47UUFBVSxHQUFHO1lBQy9Ea0ksZ0JBQWdCQTtRQUNsQjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDMVgsUUFBUUMsMEJBQTBCQyxnQ0FBbUJBO1FBRzdELElBQUkrSSxXQUFXL0ksZ0NBQW1CQSxDQUFDO1FBRW5DRixPQUFPSSxPQUFPLEdBQUcsU0FBVVMsUUFBUTtZQUNqQyxPQUFPb0ksU0FBU3BJLGFBQWFBLGFBQWE7UUFDNUM7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2IsUUFBUUMsMEJBQTBCQyxnQ0FBbUJBO1FBRzdELElBQUkrSSxXQUFXL0ksZ0NBQW1CQSxDQUFDO1FBRW5DLElBQUlpRCxVQUFVQztRQUNkLElBQUl6QyxhQUFhQztRQUVqQlosT0FBT0ksT0FBTyxHQUFHLFNBQVVTLFFBQVE7WUFDakMsSUFBSUEsYUFBYTJELGFBQWF5RSxTQUFTcEksV0FBVyxPQUFPQTtZQUN6RCxNQUFNLElBQUlGLFdBQVd3QyxRQUFRdEMsWUFBWTtRQUMzQztJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDYixRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSWtGLGNBQWFsRixnQ0FBbUJBLENBQUM7UUFDckMsSUFBSStJLFdBQVcvSSxnQ0FBbUJBLENBQUM7UUFFbkMsSUFBSThPLFlBQVc1SixZQUFXNEosUUFBUTtRQUNsQyxzREFBc0Q7UUFDdEQsSUFBSWhLLFNBQVNpRSxTQUFTK0YsY0FBYS9GLFNBQVMrRixVQUFTMkksYUFBYTtRQUVsRTNYLE9BQU9JLE9BQU8sR0FBRyxTQUFVQyxFQUFFO1lBQzNCLE9BQU8yRSxTQUFTZ0ssVUFBUzJJLGFBQWEsQ0FBQ3RYLE1BQU0sQ0FBQztRQUNoRDtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDYSx5QkFBeUJqQiwwQkFBMEJDLGdDQUFtQkE7UUFHOUUsSUFBSWlCLElBQUlqQixnQ0FBbUJBLENBQUM7UUFDNUIsSUFBSStRLFdBQVcvUSxnQ0FBbUJBLENBQUM7UUFDbkMsSUFBSTRQLG9CQUFvQjVQLGdDQUFtQkEsQ0FBQztRQUM1QyxJQUFJMFgsaUJBQWlCMVgsZ0NBQW1CQSxDQUFDO1FBQ3pDLElBQUkyWCwyQkFBMkIzWCxnQ0FBbUJBLENBQUM7UUFDbkQsSUFBSXNDLFFBQVF0QyxnQ0FBbUJBLENBQUM7UUFFaEMsSUFBSTRYLHNCQUFzQnRWLE1BQU07WUFDOUIsT0FBTyxFQUFFLENBQUMwSixJQUFJLENBQUM1TCxJQUFJLENBQUM7Z0JBQUVXLFFBQVE7WUFBWSxHQUFHLE9BQU87UUFDdEQ7UUFFQSw2REFBNkQ7UUFDN0Qsd0RBQXdEO1FBQ3hELElBQUk4VyxpQ0FBaUM7WUFDbkMsSUFBSTtnQkFDRiwrREFBK0Q7Z0JBQy9EelUsT0FBT0QsY0FBYyxDQUFDLEVBQUUsRUFBRSxVQUFVO29CQUFFaUIsVUFBVTtnQkFBTSxHQUFHNEgsSUFBSTtZQUMvRCxFQUFFLE9BQU9uSyxPQUFPO2dCQUNkLE9BQU9BLGlCQUFpQm5CO1lBQzFCO1FBQ0Y7UUFFQSxJQUFJOEYsU0FBU29SLHVCQUF1QixDQUFDQztRQUVyQyxnQ0FBZ0M7UUFDaEMsb0RBQW9EO1FBQ3BENVcsRUFBRTtZQUFFTSxRQUFRO1lBQVNDLE9BQU87WUFBTTBDLE9BQU87WUFBR3hDLFFBQVE4RTtRQUFPLEdBQUc7WUFDNUQsb0VBQW9FO1lBQ3BFd0YsTUFBTSxTQUFTQSxLQUFLOEwsSUFBSTtnQkFDdEIsSUFBSXRQLElBQUl1SSxTQUFTLElBQUk7Z0JBQ3JCLElBQUlnSCxNQUFNbkksa0JBQWtCcEg7Z0JBQzVCLElBQUl3UCxXQUFXbFgsVUFBVUMsTUFBTTtnQkFDL0I0Vyx5QkFBeUJJLE1BQU1DO2dCQUMvQixJQUFLLElBQUl0UyxJQUFJLEdBQUdBLElBQUlzUyxVQUFVdFMsSUFBSztvQkFDakM4QyxDQUFDLENBQUN1UCxJQUFJLEdBQUdqWCxTQUFTLENBQUM0RSxFQUFFO29CQUNyQnFTO2dCQUNGO2dCQUNBTCxlQUFlbFAsR0FBR3VQO2dCQUNsQixPQUFPQTtZQUNUO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2pZO1FBR1Isc0VBQXNFO1FBQ3RFLDJEQUEyRDtRQUMzREEsT0FBT0ksT0FBTyxHQUFHLFNBQVVDLEVBQUU7WUFDM0IsT0FBT0EsT0FBTyxRQUFRQSxPQUFPbUU7UUFDL0I7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3hFO1FBR1IsSUFBSWtULGNBQWNDO1FBRWxCblQsT0FBT0ksT0FBTyxHQUFHLFNBQVVDLEVBQUU7WUFDM0Isd0RBQXdEO1lBQ3hELElBQUlBLE9BQU9BLElBQUksT0FBT0E7WUFDdEIsTUFBTSxJQUFJNlMsWUFBWTtRQUN4QjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDbFQsUUFBUUMsMEJBQTBCQyxnQ0FBbUJBO1FBRzdELElBQUlnSCxVQUFVaEgsZ0NBQW1CQSxDQUFDO1FBRWxDLElBQUlTLGFBQWFDO1FBRWpCLDhEQUE4RDtRQUM5RCxrRkFBa0Y7UUFDbEZaLE9BQU9JLE9BQU8sR0FBRyxTQUFVUyxRQUFRO1lBQ2pDLElBQUlxRyxRQUFRckcsY0FBYyxjQUFjLE9BQU9BO1lBQy9DLE1BQU0sSUFBSUYsV0FBVztRQUN2QjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDWCxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSTZWLE9BQU83VixnQ0FBbUJBLENBQUM7UUFDL0IsSUFBSTRXLE1BQU81VyxnQ0FBbUJBLENBQUMsTUFBTTRXLEdBQUc7UUFDeEMsSUFBSXRNLFFBQVF0SyxnQ0FBbUJBLENBQUM7UUFDaEMsSUFBSWdXLGVBQWVoVyxnQ0FBbUJBLENBQUM7UUFDdkMsSUFBSWtXLGdCQUFnQmxXLGdDQUFtQkEsQ0FBQztRQUV4QywrQkFBK0I7UUFDL0IsbURBQW1EO1FBQ25ERixPQUFPSSxPQUFPLEdBQUcsU0FBU29MLE1BQU0rSyxLQUFLO1lBQ25DLElBQUk3TixJQUFJcU4sS0FBSyxJQUFJO1lBQ2pCLElBQUlpQixXQUFXZCxhQUFhSyxPQUFPeEcsV0FBVztZQUM5QyxJQUFJek4sU0FBU2tJLE1BQU05QjtZQUNuQjBOLGNBQWNZLFVBQVUsU0FBVTNXLEVBQUU7Z0JBQ2xDeVcsSUFBSXhVLFFBQVFqQztZQUNkO1lBQ0EsT0FBT2lDO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3RDLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJa0ksa0JBQWtCbEksZ0NBQW1CQSxDQUFDO1FBQzFDLElBQUlpSSxZQUFZakksZ0NBQW1CQSxDQUFDO1FBRXBDLElBQUltSSxXQUFXRCxnQkFBZ0I7UUFDL0IsSUFBSStQLGlCQUFpQm5GLE1BQU16TyxTQUFTO1FBRXBDLGtDQUFrQztRQUNsQ3ZFLE9BQU9JLE9BQU8sR0FBRyxTQUFVQyxFQUFFO1lBQzNCLE9BQU9BLE9BQU9tRSxhQUFjMkQsQ0FBQUEsVUFBVTZLLEtBQUssS0FBSzNTLE1BQU04WCxjQUFjLENBQUM5UCxTQUFTLEtBQUtoSSxFQUFDO1FBQ3RGO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNMLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxpQ0FBaUMsR0FDakMsSUFBSWtGLGNBQWFsRixnQ0FBbUJBLENBQUM7UUFDckMsSUFBSXdTLFlBQVl4UyxnQ0FBbUJBLENBQUM7UUFDcEMsSUFBSWdILFVBQVVoSCxnQ0FBbUJBLENBQUM7UUFFbEMsSUFBSWtZLHNCQUFzQixTQUFVdEwsTUFBTTtZQUN4QyxPQUFPNEYsVUFBVWxQLEtBQUssQ0FBQyxHQUFHc0osT0FBTzdMLE1BQU0sTUFBTTZMO1FBQy9DO1FBRUE5TSxPQUFPSSxPQUFPLEdBQUc7WUFDZixJQUFJZ1ksb0JBQW9CLFNBQVMsT0FBTztZQUN4QyxJQUFJQSxvQkFBb0IsdUJBQXVCLE9BQU87WUFDdEQsSUFBSUEsb0JBQW9CLFVBQVUsT0FBTztZQUN6QyxJQUFJQSxvQkFBb0IsYUFBYSxPQUFPO1lBQzVDLElBQUloVCxZQUFXaVQsR0FBRyxJQUFJLE9BQU9BLElBQUlDLE9BQU8sSUFBSSxVQUFVLE9BQU87WUFDN0QsSUFBSWxULFlBQVdtVCxJQUFJLElBQUksT0FBT0EsS0FBS0QsT0FBTyxJQUFJLFVBQVUsT0FBTztZQUMvRCxJQUFJcFIsUUFBUTlCLFlBQVdvVCxPQUFPLE1BQU0sV0FBVyxPQUFPO1lBQ3RELElBQUlwVCxZQUFXcVQsTUFBTSxJQUFJclQsWUFBVzRKLFFBQVEsRUFBRSxPQUFPO1lBQ3JELE9BQU87UUFDVDtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDOU4seUJBQXlCakIsMEJBQTBCQyxnQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsZ0NBQW1CQSxDQUFDO1FBQzVCLElBQUlrRixjQUFhbEYsZ0NBQW1CQSxDQUFDO1FBQ3JDLElBQUl3WSxVQUFVeFksZ0NBQW1CQSxDQUFDO1FBQ2xDLElBQUltRixlQUFlbkYsZ0NBQW1CQSxDQUFDO1FBQ3ZDLElBQUlvRixjQUFjcEYsZ0NBQW1CQSxDQUFDO1FBQ3RDLElBQUl5WSxXQUFXelksZ0NBQW1CQSxDQUFDO1FBRW5DLDJDQUEyQztRQUMzQyxzREFBc0Q7UUFDdEQsSUFBSWtGLFlBQVdJLFVBQVUsRUFBRXJFLEVBQUU7WUFBRU0sUUFBUTtZQUFjQyxPQUFPO1FBQUssR0FBRztZQUNsRWtYLFlBQVksU0FBU0EsV0FBVzlMLE1BQU07Z0JBQ3BDekgsYUFBYSxJQUFJO2dCQUNqQnFULFFBQVE1TDtnQkFDUnhILFlBQVksSUFBSSxDQUFDSyxNQUFNO2dCQUN2QixJQUFJd0gsT0FBT3dMLFNBQVM3TCxRQUFRLElBQUksRUFBRUssSUFBSTtnQkFDdEMsT0FBTztvQkFBRUEsTUFBTUE7b0JBQU1DLFNBQVNELE9BQU87Z0JBQUU7WUFDekM7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDak0seUJBQXlCakIsMEJBQTBCQyxnQ0FBbUJBO1FBRzlFLGdDQUFnQztRQUNoQ0EsZ0NBQW1CQSxDQUFDO0lBR3BCLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDRixRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSUksT0FBT0osZ0NBQW1CQSxDQUFDO1FBQy9CLElBQUlDLGFBQWFELGdDQUFtQkEsQ0FBQztRQUNyQyxJQUFJK0ksV0FBVy9JLGdDQUFtQkEsQ0FBQztRQUVuQyxJQUFJUyxhQUFhQztRQUVqQiwyQ0FBMkM7UUFDM0MsbURBQW1EO1FBQ25EWixPQUFPSSxPQUFPLEdBQUcsU0FBVTBRLEtBQUssRUFBRUMsSUFBSTtZQUNwQyxJQUFJakwsSUFBSStTO1lBQ1IsSUFBSTlILFNBQVMsWUFBWTVRLFdBQVcyRixLQUFLZ0wsTUFBTWxNLFFBQVEsS0FBSyxDQUFDcUUsU0FBUzRQLE1BQU12WSxLQUFLd0YsSUFBSWdMLFNBQVMsT0FBTytIO1lBQ3JHLElBQUkxWSxXQUFXMkYsS0FBS2dMLE1BQU1nSSxPQUFPLEtBQUssQ0FBQzdQLFNBQVM0UCxNQUFNdlksS0FBS3dGLElBQUlnTCxTQUFTLE9BQU8rSDtZQUMvRSxJQUFJOUgsU0FBUyxZQUFZNVEsV0FBVzJGLEtBQUtnTCxNQUFNbE0sUUFBUSxLQUFLLENBQUNxRSxTQUFTNFAsTUFBTXZZLEtBQUt3RixJQUFJZ0wsU0FBUyxPQUFPK0g7WUFDckcsTUFBTSxJQUFJbFksV0FBVztRQUN2QjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDWCxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSWdILFVBQVVoSCxnQ0FBbUJBLENBQUM7UUFFbEMsK0JBQStCO1FBQy9CLHVDQUF1QztRQUN2Qyx1REFBdUQ7UUFDdkRGLE9BQU9JLE9BQU8sR0FBRzRTLE1BQU0rRixPQUFPLElBQUksU0FBU0EsUUFBUWxZLFFBQVE7WUFDekQsT0FBT3FHLFFBQVFyRyxjQUFjO1FBQy9CO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNiLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJcUMsY0FBY3JDLGdDQUFtQkEsQ0FBQztRQUV0Qyw2Q0FBNkM7UUFDN0MsSUFBSThZLGVBQWVDLElBQUkxVSxTQUFTO1FBRWhDdkUsT0FBT0ksT0FBTyxHQUFHO1lBQ2YsNkNBQTZDO1lBQzdDNlksS0FBS0E7WUFDTG5DLEtBQUt2VSxZQUFZeVcsYUFBYWxDLEdBQUc7WUFDakNyTixLQUFLbEgsWUFBWXlXLGFBQWF2UCxHQUFHO1lBQ2pDNE0sUUFBUTlULFlBQVl5VyxZQUFZLENBQUMsU0FBUztZQUMxQ3RYLE9BQU9zWDtRQUNUO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNoWixRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSTZWLE9BQU83VixnQ0FBbUJBLENBQUM7UUFDL0IsSUFBSXVKLE1BQU92SixnQ0FBbUJBLENBQUMsTUFBTXVKLEdBQUc7UUFDeEMsSUFBSXdNLE9BQU8vVixnQ0FBbUJBLENBQUM7UUFDL0IsSUFBSWdXLGVBQWVoVyxnQ0FBbUJBLENBQUM7UUFDdkMsSUFBSWlXLGFBQWFqVyxnQ0FBbUJBLENBQUM7UUFDckMsSUFBSWtXLGdCQUFnQmxXLGdDQUFtQkEsQ0FBQztRQUN4QyxJQUFJb0IsZ0JBQWdCcEIsZ0NBQW1CQSxDQUFDO1FBRXhDLHdDQUF3QztRQUN4Qyw0REFBNEQ7UUFDNURGLE9BQU9JLE9BQU8sR0FBRyxTQUFTc1gsZUFBZW5CLEtBQUs7WUFDNUMsSUFBSTdOLElBQUlxTixLQUFLLElBQUk7WUFDakIsSUFBSVMsV0FBV04sYUFBYUs7WUFDNUIsSUFBSU4sS0FBS3ZOLE1BQU04TixTQUFTUCxJQUFJLEVBQUUsT0FBT0UsV0FBV3pOLEdBQUcsU0FBVStOLENBQUM7Z0JBQzVELElBQUlELFNBQVNFLFFBQVEsQ0FBQ0QsSUFBSSxPQUFPO1lBQ25DLEdBQUcsVUFBVTtZQUNiLElBQUl6USxXQUFXd1EsU0FBU3pHLFdBQVc7WUFDbkMsT0FBT3FHLGNBQWNwUSxVQUFVLFNBQVV5USxDQUFDO2dCQUN4QyxJQUFJaE4sSUFBSWYsR0FBRytOLElBQUksT0FBT25WLGNBQWMwRSxVQUFVLFVBQVU7WUFDMUQsT0FBTztRQUNUO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNoRyxRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSWtGLGNBQWFsRixnQ0FBbUJBLENBQUM7UUFDckMsSUFBSWdaLHVCQUF1QmhaLGdDQUFtQkEsQ0FBQztRQUMvQyxJQUFJaVosbUNBQW1DalosZ0NBQW1CQSxDQUFDO1FBRTNELElBQUlvSyxtQkFBa0JsRixZQUFXa0YsZUFBZTtRQUNoRCxJQUFJOE8sZUFBZWhVLFlBQVdtRixXQUFXO1FBQ3pDLElBQUk4TyxrQkFBa0JqVSxZQUFXa1UsY0FBYztRQUMvQyxJQUFJQyxTQUFTO1FBQ2IsSUFBSUMsZUFBZUMsU0FBUzlULFFBQVErVDtRQUVwQyxJQUFJUCxrQ0FBa0M7WUFDcENJLFNBQVMsU0FBVUksWUFBWTtnQkFDN0JyUCxpQkFBZ0JxUCxjQUFjO29CQUFFbFAsVUFBVTt3QkFBQ2tQO3FCQUFhO2dCQUFDO1lBQzNEO1FBQ0YsT0FBTyxJQUFJUCxjQUFjLElBQUk7WUFDM0IsSUFBSSxDQUFDQyxpQkFBaUI7Z0JBQ3BCRyxnQkFBZ0JOLHFCQUFxQjtnQkFDckMsSUFBSU0sZUFBZUgsa0JBQWtCRyxjQUFjRixjQUFjO1lBQ25FO1lBRUEsSUFBSUQsaUJBQWlCO2dCQUNuQkksVUFBVSxJQUFJSjtnQkFDZDFULFNBQVMsSUFBSXlULGFBQWE7Z0JBRTFCTSxVQUFVLFNBQVVDLFlBQVk7b0JBQzlCRixRQUFRRyxLQUFLLENBQUNDLFdBQVcsQ0FBQyxNQUFNO3dCQUFDRjtxQkFBYTtnQkFDaEQ7Z0JBRUEsSUFBSWhVLE9BQU8rRSxVQUFVLEtBQUssR0FBRztvQkFDM0JnUCxRQUFRL1Q7b0JBQ1IsSUFBSUEsT0FBTytFLFVBQVUsS0FBSyxHQUFHNk8sU0FBU0c7Z0JBQ3hDO1lBQ0Y7UUFDRixFQUFFLE9BQU8zWCxPQUFPLENBQWM7UUFFOUIvQixPQUFPSSxPQUFPLEdBQUdtWjtJQUdqQixHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3ZaLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCx1REFBdUQsR0FDdkQsSUFBSTRaLGFBQWE1WixnQ0FBbUJBLENBQUM7UUFDckMsSUFBSXNDLFFBQVF0QyxnQ0FBbUJBLENBQUM7UUFDaEMsSUFBSWtGLGNBQWFsRixnQ0FBbUJBLENBQUM7UUFFckMsSUFBSWlELFVBQVVpQyxZQUFXaEMsTUFBTTtRQUUvQixzRkFBc0Y7UUFDdEZwRCxPQUFPSSxPQUFPLEdBQUcsQ0FBQyxDQUFDa0QsT0FBTzRULHFCQUFxQixJQUFJLENBQUMxVSxNQUFNO1lBQ3hELElBQUl1WCxTQUFTQyxPQUFPO1lBQ3BCLHFEQUFxRDtZQUNyRCwyRkFBMkY7WUFDM0YsaUdBQWlHO1lBQ2pHLG1CQUFtQjtZQUNuQixPQUFPLENBQUM3VyxRQUFRNFcsV0FBVyxDQUFFelcsQ0FBQUEsT0FBT3lXLG1CQUFtQkMsTUFBSyxLQUMxRCxzRkFBc0Y7WUFDdEYsQ0FBQ0EsT0FBT0MsSUFBSSxJQUFJSCxjQUFjQSxhQUFhO1FBQy9DO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUM5WixRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSXdDLGNBQWN4QyxnQ0FBbUJBLENBQUM7UUFDdEMsSUFBSTZZLFVBQVU3WSxnQ0FBbUJBLENBQUM7UUFFbEMsSUFBSVMsYUFBYUM7UUFDakIseUVBQXlFO1FBQ3pFLElBQUltRSwyQkFBMkJ6QixPQUFPeUIsd0JBQXdCO1FBRTlELG1EQUFtRDtRQUNuRCxJQUFJbVYsb0NBQW9DeFgsZUFBZSxDQUFDO1lBQ3RELG9EQUFvRDtZQUNwRCxJQUFJLElBQUksS0FBSzhCLFdBQVcsT0FBTztZQUMvQixJQUFJO2dCQUNGLCtEQUErRDtnQkFDL0RsQixPQUFPRCxjQUFjLENBQUMsRUFBRSxFQUFFLFVBQVU7b0JBQUVpQixVQUFVO2dCQUFNLEdBQUdyRCxNQUFNLEdBQUc7WUFDcEUsRUFBRSxPQUFPYyxPQUFPO2dCQUNkLE9BQU9BLGlCQUFpQm5CO1lBQzFCO1FBQ0Y7UUFFQVosT0FBT0ksT0FBTyxHQUFHOFosb0NBQW9DLFNBQVV4UixDQUFDLEVBQUV6SCxNQUFNO1lBQ3RFLElBQUk4WCxRQUFRclEsTUFBTSxDQUFDM0QseUJBQXlCMkQsR0FBRyxVQUFVcEUsUUFBUSxFQUFFO2dCQUNqRSxNQUFNLElBQUkzRCxXQUFXO1lBQ3ZCO1lBQUUsT0FBTytILEVBQUV6SCxNQUFNLEdBQUdBO1FBQ3RCLElBQUksU0FBVXlILENBQUMsRUFBRXpILE1BQU07WUFDckIsT0FBT3lILEVBQUV6SCxNQUFNLEdBQUdBO1FBQ3BCO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNqQixRQUFRQywwQkFBMEJDLGdDQUFtQkE7UUFHN0QsSUFBSWtGLGNBQWFsRixnQ0FBbUJBLENBQUM7UUFFckMsNENBQTRDO1FBQzVDRixPQUFPSSxPQUFPLEdBQUcsU0FBVStaLFdBQVcsRUFBRUMsYUFBYTtZQUNuRCxJQUFJN1MsWUFBV25DLFlBQVdtQyxRQUFRO1lBQ2xDLElBQUk4UyxvQkFBb0I5UyxhQUFZQSxVQUFTaEQsU0FBUztZQUN0RCxJQUFJK0MsU0FBUytTLHFCQUFxQkEsaUJBQWlCLENBQUNGLFlBQVk7WUFFaEUsSUFBSUcsU0FBUztZQUViLElBQUloVCxRQUFRLElBQUk7Z0JBQ2RBLE9BQU9oSCxJQUFJLENBQUM7b0JBQ1YyRixNQUFNO3dCQUFjLE9BQU87NEJBQUVFLE1BQU07d0JBQUs7b0JBQUc7b0JBQzNDLFVBQVU7d0JBQWNtVSxTQUFTO29CQUFNO2dCQUN6QyxHQUFHLENBQUM7WUFDTixFQUFFLE9BQU92WSxPQUFPO2dCQUNkLGlEQUFpRDtnQkFDakQsSUFBSSxDQUFFQSxDQUFBQSxpQkFBaUJxWSxhQUFZLEdBQUlFLFNBQVM7WUFDbEQ7WUFFQSxJQUFJLENBQUNBLFFBQVEsT0FBT2hUO1FBQ3RCO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLFNBQVN0SCxNQUFNO1FBR3RCLElBQUl1YSxRQUFRLFNBQVVsYSxFQUFFO1lBQ3RCLE9BQU9BLE1BQU1BLEdBQUdvSCxJQUFJLEtBQUtBLFFBQVFwSDtRQUNuQztRQUVBLHVFQUF1RTtRQUN2RUwsT0FBT0ksT0FBTyxHQUNaLHFEQUFxRDtRQUNyRG1hLE1BQU0sT0FBT25WLGNBQWMsWUFBWUEsZUFDdkNtVixNQUFNLE1BQWlCLElBQVk5QixDQUFNQSxLQUN6Qyx5REFBeUQ7UUFDekQ4QixNQUFNLE9BQU9DLFFBQVEsWUFBWUEsU0FDakNELE1BQU0sT0FBT0UsVUFBVSxZQUFZQSxXQUNuQ0YsTUFBTSxPQUFPLElBQUksSUFBSSxZQUFZLElBQUksS0FFckMsbURBRG1EO1FBQ2xEO1lBQWMsT0FBTyxJQUFJO1FBQUUsT0FBUTVWLFNBQVM7SUFHL0MsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUN6RCx5QkFBeUJqQiwwQkFBMEJDLGdDQUFtQkE7UUFHOUUsSUFBSXdhLGdCQUFnQnhhLGdDQUFtQkEsQ0FBQztRQUN4QyxJQUFJcUMsY0FBY3JDLGdDQUFtQkEsQ0FBQztRQUN0QyxJQUFJMEUsV0FBVzFFLGdDQUFtQkEsQ0FBQztRQUNuQyxJQUFJeWEsMEJBQTBCemEsZ0NBQW1CQSxDQUFDO1FBRWxELElBQUkwYSxtQkFBbUJDO1FBQ3ZCLElBQUlDLDJCQUEyQkYsaUJBQWlCclcsU0FBUztRQUN6RCxJQUFJd1csU0FBU3hZLFlBQVl1WSx5QkFBeUJDLE1BQU07UUFDeEQsSUFBSUMsVUFBVXpZLFlBQVl1WSx3QkFBd0IsQ0FBQyxTQUFTO1FBQzVELElBQUlHLFVBQVUxWSxZQUFZdVkseUJBQXlCRyxPQUFPO1FBQzFELElBQUkvTyxPQUFPM0osWUFBWSxFQUFFLENBQUMySixJQUFJO1FBQzlCLElBQUlnUCxTQUFTLElBQUlOLGlCQUFpQjtRQUVsQ00sTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLO1FBQ3RCLHlDQUF5QztRQUN6Qyx3REFBd0Q7UUFDeERBLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSzFXO1FBRXRCLElBQUkwVyxTQUFTLE9BQU8sT0FBTztZQUN6QlIsY0FBY0ksMEJBQTBCLFVBQVUsU0FBVS9XLEtBQUssV0FBVyxHQUFaO2dCQUM5RCxJQUFJOUMsU0FBU0QsVUFBVUMsTUFBTTtnQkFDN0IsSUFBSWthLFNBQVNsYSxTQUFTLElBQUl1RCxZQUFZeEQsU0FBUyxDQUFDLEVBQUU7Z0JBQ2xELElBQUlDLFVBQVVrYSxXQUFXM1csV0FBVyxPQUFPd1csUUFBUSxJQUFJLEVBQUVqWDtnQkFDekQsSUFBSXFYLFVBQVUsRUFBRTtnQkFDaEJILFFBQVEsSUFBSSxFQUFFLFNBQVVJLENBQUMsRUFBRUMsQ0FBQztvQkFDMUJwUCxLQUFLa1AsU0FBUzt3QkFBRS9PLEtBQUtpUDt3QkFBR3BaLE9BQU9tWjtvQkFBRTtnQkFDbkM7Z0JBQ0FWLHdCQUF3QjFaLFFBQVE7Z0JBQ2hDLElBQUlvTCxNQUFNekgsU0FBU2I7Z0JBQ25CLElBQUk3QixRQUFRMEMsU0FBU3VXO2dCQUNyQixJQUFJM0ssUUFBUTtnQkFDWixJQUFJK0ssU0FBUztnQkFDYixJQUFJQyxRQUFRO2dCQUNaLElBQUlDLGdCQUFnQkwsUUFBUW5hLE1BQU07Z0JBQ2xDLElBQUl5YTtnQkFDSixNQUFPbEwsUUFBUWlMLGNBQWU7b0JBQzVCQyxRQUFRTixPQUFPLENBQUM1SyxRQUFRO29CQUN4QixJQUFJZ0wsU0FBU0UsTUFBTXJQLEdBQUcsS0FBS0EsS0FBSzt3QkFDOUJtUCxRQUFRO3dCQUNSUixRQUFRLElBQUksRUFBRVUsTUFBTXJQLEdBQUc7b0JBQ3pCLE9BQU9rUDtnQkFDVDtnQkFDQSxNQUFPQSxTQUFTRSxjQUFlO29CQUM3QkMsUUFBUU4sT0FBTyxDQUFDRyxTQUFTO29CQUN6QixJQUFJLENBQUVHLENBQUFBLE1BQU1yUCxHQUFHLEtBQUtBLE9BQU9xUCxNQUFNeFosS0FBSyxLQUFLQSxLQUFJLEdBQUk2WSxPQUFPLElBQUksRUFBRVcsTUFBTXJQLEdBQUcsRUFBRXFQLE1BQU14WixLQUFLO2dCQUN4RjtZQUNGLEdBQUc7Z0JBQUV5WixZQUFZO2dCQUFNQyxRQUFRO1lBQUs7UUFDdEM7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQzFhLHlCQUF5QmpCLDBCQUEwQkMsZ0NBQW1CQTtRQUc5RSxJQUFJaUIsSUFBSWpCLGdDQUFtQkEsQ0FBQztRQUM1QixJQUFJMEssNkJBQTZCMUssZ0NBQW1CQSxDQUFDO1FBRXJELGlDQUFpQztRQUNqQyxxREFBcUQ7UUFDckRpQixFQUFFO1lBQUVNLFFBQVE7WUFBV3VKLE1BQU07UUFBSyxHQUFHO1lBQ25DNlEsZUFBZSxTQUFTQTtnQkFDdEIsSUFBSTFRLG9CQUFvQlAsMkJBQTJCUSxDQUFDLENBQUMsSUFBSTtnQkFDekQsT0FBTztvQkFDTEcsU0FBU0osa0JBQWtCSSxPQUFPO29CQUNsQ0QsU0FBU0gsa0JBQWtCRyxPQUFPO29CQUNsQ0QsUUFBUUYsa0JBQWtCRSxNQUFNO2dCQUNsQztZQUNGO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3JMLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJdVYsc0JBQXNCdlYsZ0NBQW1CQSxDQUFDO1FBQzlDLElBQUl3QyxjQUFjeEMsZ0NBQW1CQSxDQUFDO1FBQ3RDLElBQUlrRixjQUFhbEYsZ0NBQW1CQSxDQUFDO1FBQ3JDLElBQUlDLGFBQWFELGdDQUFtQkEsQ0FBQztRQUNyQyxJQUFJK0ksV0FBVy9JLGdDQUFtQkEsQ0FBQztRQUNuQyxJQUFJdUMsU0FBU3ZDLGdDQUFtQkEsQ0FBQztRQUNqQyxJQUFJZ0gsVUFBVWhILGdDQUFtQkEsQ0FBQztRQUNsQyxJQUFJTyxjQUFjUCxnQ0FBbUJBLENBQUM7UUFDdEMsSUFBSWdKLDhCQUE4QmhKLGdDQUFtQkEsQ0FBQztRQUN0RCxJQUFJd2EsZ0JBQWdCeGEsZ0NBQW1CQSxDQUFDO1FBQ3hDLElBQUk0Yix3QkFBd0I1YixnQ0FBbUJBLENBQUM7UUFDaEQsSUFBSWlILGdCQUFnQmpILGdDQUFtQkEsQ0FBQztRQUN4QyxJQUFJdU0saUJBQWlCdk0sZ0NBQW1CQSxDQUFDO1FBQ3pDLElBQUk0UyxpQkFBaUI1UyxnQ0FBbUJBLENBQUM7UUFDekMsSUFBSWtJLGtCQUFrQmxJLGdDQUFtQkEsQ0FBQztRQUMxQyxJQUFJNmIsTUFBTTdiLGdDQUFtQkEsQ0FBQztRQUM5QixJQUFJNEMsc0JBQXNCNUMsZ0NBQW1CQSxDQUFDO1FBRTlDLElBQUk2Qyx1QkFBdUJELG9CQUFvQkUsT0FBTztRQUN0RCxJQUFJQyxtQkFBbUJILG9CQUFvQkksR0FBRztRQUM5QyxJQUFJOFksYUFBWTVXLFlBQVc0VyxTQUFTO1FBQ3BDLElBQUlDLHFCQUFxQkQsY0FBYUEsV0FBVXpYLFNBQVM7UUFDekQsSUFBSTJYLHFCQUFvQjlXLFlBQVc4VyxpQkFBaUI7UUFDcEQsSUFBSUMsNkJBQTZCRCxzQkFBcUJBLG1CQUFrQjNYLFNBQVM7UUFDakYsSUFBSTZYLGFBQWFKLGNBQWF2UCxlQUFldVA7UUFDN0MsSUFBSUssc0JBQXNCSixzQkFBc0J4UCxlQUFld1A7UUFDL0QsSUFBSTlLLGtCQUFrQjdOLE9BQU9pQixTQUFTO1FBQ3RDLElBQUkzRCxhQUFZd0UsWUFBV3hFLFNBQVM7UUFFcEMsSUFBSTJMLGdCQUFnQm5FLGdCQUFnQjtRQUNwQyxJQUFJa1Usa0JBQWtCUCxJQUFJO1FBQzFCLElBQUlRLDBCQUEwQjtRQUM5QiwyRUFBMkU7UUFDM0UsSUFBSUMsNEJBQTRCL0csdUJBQXVCLENBQUMsQ0FBQzNDLGtCQUFrQjVMLFFBQVE5QixZQUFXcVgsS0FBSyxNQUFNO1FBQ3pHLElBQUlDLDJCQUEyQjtRQUMvQixJQUFJQyxNQUFNQyxhQUFheFY7UUFFdkIsSUFBSXlWLDZCQUE2QjtZQUMvQmIsV0FBVztZQUNYeFcsWUFBWTtZQUNaMFcsbUJBQW1CO1lBQ25CWSxZQUFZO1lBQ1pDLGFBQWE7WUFDYkMsWUFBWTtZQUNaQyxhQUFhO1lBQ2JDLGNBQWM7WUFDZEMsY0FBYztRQUNoQjtRQUVBLElBQUlDLDhCQUE4QjtZQUNoQ0MsZUFBZTtZQUNmQyxnQkFBZ0I7UUFDbEI7UUFFQSxJQUFJQyxTQUFTLFNBQVNBLE9BQU9sZCxFQUFFO1lBQzdCLElBQUksQ0FBQzRJLFNBQVM1SSxLQUFLLE9BQU87WUFDMUIsSUFBSXVJLFFBQVExQixRQUFRN0c7WUFDcEIsT0FBT3VJLFVBQVUsY0FDWm5HLE9BQU9vYSw0QkFBNEJqVSxVQUNuQ25HLE9BQU8yYSw2QkFBNkJ4VTtRQUMzQztRQUVBLElBQUk0VSwyQkFBMkIsU0FBVW5kLEVBQUU7WUFDekMsSUFBSXFCLFFBQVErSyxlQUFlcE07WUFDM0IsSUFBSSxDQUFDNEksU0FBU3ZILFFBQVE7WUFDdEIsSUFBSStDLFFBQVF4QixpQkFBaUJ2QjtZQUM3QixPQUFPLFNBQVVlLE9BQU9nQyxPQUFPOFgsMkJBQTRCOVgsS0FBSyxDQUFDOFgsd0JBQXdCLEdBQUdpQix5QkFBeUI5YjtRQUN2SDtRQUVBLElBQUkrYixlQUFlLFNBQVVwZCxFQUFFO1lBQzdCLElBQUksQ0FBQzRJLFNBQVM1SSxLQUFLLE9BQU87WUFDMUIsSUFBSXVJLFFBQVExQixRQUFRN0c7WUFDcEIsT0FBT29DLE9BQU9vYSw0QkFBNEJqVSxVQUNyQ25HLE9BQU8yYSw2QkFBNkJ4VTtRQUMzQztRQUVBLElBQUk4VSxjQUFjLFNBQVVyZCxFQUFFO1lBQzVCLElBQUlvZCxhQUFhcGQsS0FBSyxPQUFPQTtZQUM3QixNQUFNLElBQUlPLFdBQVU7UUFDdEI7UUFFQSxJQUFJK2MseUJBQXlCLFNBQVVDLENBQUM7WUFDdEMsSUFBSXpkLFdBQVd5ZCxNQUFPLEVBQUM5SyxrQkFBa0IzTCxjQUFjaVYsWUFBWXdCLEVBQUMsR0FBSSxPQUFPQTtZQUMvRSxNQUFNLElBQUloZCxXQUFVSCxZQUFZbWQsS0FBSztRQUN2QztRQUVBLElBQUlDLHlCQUF5QixTQUFVQyxHQUFHLEVBQUVDLFFBQVEsRUFBRW5jLE1BQU0sRUFBRW9DLE9BQU87WUFDbkUsSUFBSSxDQUFDdEIsYUFBYTtZQUNsQixJQUFJZCxRQUFRLElBQUssSUFBSW9jLFNBQVNuQiwyQkFBNEI7Z0JBQ3hELElBQUlvQix3QkFBd0I3WSxXQUFVLENBQUM0WSxNQUFNO2dCQUM3QyxJQUFJQyx5QkFBeUJ4YixPQUFPd2Isc0JBQXNCMVosU0FBUyxFQUFFdVosTUFBTSxJQUFJO29CQUM3RSxPQUFPRyxzQkFBc0IxWixTQUFTLENBQUN1WixJQUFJO2dCQUM3QyxFQUFFLE9BQU8vYixPQUFPO29CQUNkLHFEQUFxRDtvQkFDckQsSUFBSTt3QkFDRmtjLHNCQUFzQjFaLFNBQVMsQ0FBQ3VaLElBQUksR0FBR0M7b0JBQ3pDLEVBQUUsT0FBT0csUUFBUSxDQUFjO2dCQUNqQztZQUNGO1lBQ0EsSUFBSSxDQUFDN0IsbUJBQW1CLENBQUN5QixJQUFJLElBQUlsYyxRQUFRO2dCQUN2QzhZLGNBQWMyQixxQkFBcUJ5QixLQUFLbGMsU0FBU21jLFdBQzdDdkIsNkJBQTZCUCxrQkFBa0IsQ0FBQzZCLElBQUksSUFBSUMsVUFBVS9aO1lBQ3hFO1FBQ0Y7UUFFQSxJQUFJbWEsK0JBQStCLFNBQVVMLEdBQUcsRUFBRUMsUUFBUSxFQUFFbmMsTUFBTTtZQUNoRSxJQUFJb2MsT0FBT0M7WUFDWCxJQUFJLENBQUN2YixhQUFhO1lBQ2xCLElBQUlvUSxnQkFBZ0I7Z0JBQ2xCLElBQUlsUixRQUFRLElBQUtvYyxTQUFTbkIsMkJBQTRCO29CQUNwRG9CLHdCQUF3QjdZLFdBQVUsQ0FBQzRZLE1BQU07b0JBQ3pDLElBQUlDLHlCQUF5QnhiLE9BQU93Yix1QkFBdUJILE1BQU0sSUFBSTt3QkFDbkUsT0FBT0cscUJBQXFCLENBQUNILElBQUk7b0JBQ25DLEVBQUUsT0FBTy9iLE9BQU8sQ0FBYztnQkFDaEM7Z0JBQ0EsSUFBSSxDQUFDcWEsVUFBVSxDQUFDMEIsSUFBSSxJQUFJbGMsUUFBUTtvQkFDOUIsNkVBQTZFO29CQUM3RSxJQUFJO3dCQUNGLE9BQU84WSxjQUFjMEIsWUFBWTBCLEtBQUtsYyxTQUFTbWMsV0FBV3ZCLDZCQUE2QkosVUFBVSxDQUFDMEIsSUFBSSxJQUFJQztvQkFDNUcsRUFBRSxPQUFPaGMsT0FBTyxDQUFjO2dCQUNoQyxPQUFPO1lBQ1Q7WUFDQSxJQUFLaWMsU0FBU25CLDJCQUE0QjtnQkFDeENvQix3QkFBd0I3WSxXQUFVLENBQUM0WSxNQUFNO2dCQUN6QyxJQUFJQyx5QkFBMEIsRUFBQ0EscUJBQXFCLENBQUNILElBQUksSUFBSWxjLE1BQUssR0FBSTtvQkFDcEU4WSxjQUFjdUQsdUJBQXVCSCxLQUFLQztnQkFDNUM7WUFDRjtRQUNGO1FBRUEsSUFBS3BCLFFBQVFFLDJCQUE0QjtZQUN2Q0QsY0FBY3hYLFdBQVUsQ0FBQ3VYLEtBQUs7WUFDOUJ2VixZQUFZd1YsZUFBZUEsWUFBWXJZLFNBQVM7WUFDaEQsSUFBSTZDLFdBQVdyRSxxQkFBcUJxRSxVQUFVLENBQUNtVix3QkFBd0IsR0FBR0s7aUJBQ3JFSiw0QkFBNEI7UUFDbkM7UUFFQSxJQUFLRyxRQUFRUyw0QkFBNkI7WUFDeENSLGNBQWN4WCxXQUFVLENBQUN1WCxLQUFLO1lBQzlCdlYsWUFBWXdWLGVBQWVBLFlBQVlyWSxTQUFTO1lBQ2hELElBQUk2QyxXQUFXckUscUJBQXFCcUUsVUFBVSxDQUFDbVYsd0JBQXdCLEdBQUdLO1FBQzVFO1FBRUEsdUVBQXVFO1FBQ3ZFLElBQUksQ0FBQ0osNkJBQTZCLENBQUNyYyxXQUFXaWMsZUFBZUEsZUFBZXpYLFNBQVNKLFNBQVMsRUFBRTtZQUM5Riw2Q0FBNkM7WUFDN0M2WCxhQUFhLFNBQVNBO2dCQUNwQixNQUFNLElBQUl4YixXQUFVO1lBQ3RCO1lBQ0EsSUFBSTRiLDJCQUEyQixJQUFLRyxRQUFRRSwyQkFBNEI7Z0JBQ3RFLElBQUl6WCxXQUFVLENBQUN1WCxLQUFLLEVBQUU3SixlQUFlMU4sV0FBVSxDQUFDdVgsS0FBSyxFQUFFUDtZQUN6RDtRQUNGO1FBRUEsSUFBSSxDQUFDSSw2QkFBNkIsQ0FBQ0gsdUJBQXVCQSx3QkFBd0JsTCxpQkFBaUI7WUFDakdrTCxzQkFBc0JELFdBQVc3WCxTQUFTO1lBQzFDLElBQUlpWSwyQkFBMkIsSUFBS0csUUFBUUUsMkJBQTRCO2dCQUN0RSxJQUFJelgsV0FBVSxDQUFDdVgsS0FBSyxFQUFFN0osZUFBZTFOLFdBQVUsQ0FBQ3VYLEtBQUssQ0FBQ3BZLFNBQVMsRUFBRThYO1lBQ25FO1FBQ0Y7UUFFQSxvRUFBb0U7UUFDcEUsSUFBSUcsNkJBQTZCL1AsZUFBZTBQLGdDQUFnQ0UscUJBQXFCO1lBQ25HdkosZUFBZXFKLDRCQUE0QkU7UUFDN0M7UUFFQSxJQUFJM1osZUFBZSxDQUFDRCxPQUFPNFoscUJBQXFCOVAsZ0JBQWdCO1lBQzlEbVEsMkJBQTJCO1lBQzNCWixzQkFBc0JPLHFCQUFxQjlQLGVBQWU7Z0JBQ3hEcEksY0FBYztnQkFDZGpCLEtBQUs7b0JBQ0gsT0FBTytGLFNBQVMsSUFBSSxJQUFJLElBQUksQ0FBQ3FULGdCQUFnQixHQUFHOVg7Z0JBQ2xEO1lBQ0Y7WUFDQSxJQUFLbVksUUFBUUUsMkJBQTRCLElBQUl6WCxXQUFVLENBQUN1WCxLQUFLLEVBQUU7Z0JBQzdEelQsNEJBQTRCOUQsV0FBVSxDQUFDdVgsS0FBSyxFQUFFTCxpQkFBaUJLO1lBQ2pFO1FBQ0Y7UUFFQTNjLE9BQU9JLE9BQU8sR0FBRztZQUNmb2MsMkJBQTJCQTtZQUMzQkYsaUJBQWlCSSw0QkFBNEJKO1lBQzdDb0IsYUFBYUE7WUFDYkMsd0JBQXdCQTtZQUN4QkUsd0JBQXdCQTtZQUN4Qk0sOEJBQThCQTtZQUM5QlgsMEJBQTBCQTtZQUMxQkQsUUFBUUE7WUFDUkUsY0FBY0E7WUFDZHJCLFlBQVlBO1lBQ1pDLHFCQUFxQkE7UUFDdkI7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3JjLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJd0MsY0FBY3hDLGdDQUFtQkEsQ0FBQztRQUN0QyxJQUFJa2UsdUJBQXVCbGUsZ0NBQW1CQSxDQUFDO1FBQy9DLElBQUltZSwyQkFBMkJuZSxnQ0FBbUJBLENBQUM7UUFFbkRGLE9BQU9JLE9BQU8sR0FBRyxTQUFVK0wsTUFBTSxFQUFFRSxHQUFHLEVBQUVuSyxLQUFLO1lBQzNDLElBQUlRLGFBQWEwYixxQkFBcUJoVCxDQUFDLENBQUNlLFFBQVFFLEtBQUtnUyx5QkFBeUIsR0FBR25jO2lCQUM1RWlLLE1BQU0sQ0FBQ0UsSUFBSSxHQUFHbks7UUFDckI7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2xDO1FBR1IsdURBQXVEO1FBQ3ZELElBQUlzZSxjQUFjLE9BQU90UCxZQUFZLFlBQVlBLFNBQVN1UCxHQUFHO1FBRTdELGtDQUFrQztRQUNsQywwQ0FBMEM7UUFDMUMsK0VBQStFO1FBQy9FdmUsT0FBT0ksT0FBTyxHQUFHLE9BQU9rZSxlQUFlLGVBQWVBLGdCQUFnQjlaLFlBQVksU0FBVTNELFFBQVE7WUFDbEcsT0FBTyxPQUFPQSxZQUFZLGNBQWNBLGFBQWF5ZDtRQUN2RCxJQUFJLFNBQVV6ZCxRQUFRO1lBQ3BCLE9BQU8sT0FBT0EsWUFBWTtRQUM1QjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDSyx5QkFBeUJkLFNBQVNGLGdDQUFtQkE7UUFHN0QsSUFBSXdDLGNBQWN4QyxnQ0FBbUJBLENBQUM7UUFDdEMsSUFBSXNlLGlCQUFpQnRlLGdDQUFtQkEsQ0FBQztRQUN6QyxJQUFJdWUsMEJBQTBCdmUsZ0NBQW1CQSxDQUFDO1FBQ2xELElBQUlNLFdBQVdOLGdDQUFtQkEsQ0FBQztRQUNuQyxJQUFJd2UsZ0JBQWdCeGUsZ0NBQW1CQSxDQUFDO1FBRXhDLElBQUlTLGFBQWFDO1FBQ2pCLCtEQUErRDtRQUMvRCxJQUFJK2Qsa0JBQWtCcmIsT0FBT0QsY0FBYztRQUMzQyx5RUFBeUU7UUFDekUsSUFBSXViLDRCQUE0QnRiLE9BQU95Qix3QkFBd0I7UUFDL0QsSUFBSThaLGFBQWE7UUFDakIsSUFBSWpjLGVBQWU7UUFDbkIsSUFBSWtjLFdBQVc7UUFFZixpQ0FBaUM7UUFDakMscURBQXFEO1FBQ3JEMWUsUUFBUWdMLENBQUMsR0FBRzFJLGNBQWMrYiwwQkFBMEIsU0FBU3BiLGVBQWVxRixDQUFDLEVBQUVxVyxDQUFDLEVBQUVDLFVBQVU7WUFDMUZ4ZSxTQUFTa0k7WUFDVHFXLElBQUlMLGNBQWNLO1lBQ2xCdmUsU0FBU3dlO1lBQ1QsSUFBSSxPQUFPdFcsTUFBTSxjQUFjcVcsTUFBTSxlQUFlLFdBQVdDLGNBQWNGLFlBQVlFLGNBQWMsQ0FBQ0EsVUFBVSxDQUFDRixTQUFTLEVBQUU7Z0JBQzVILElBQUlHLFVBQVVMLDBCQUEwQmxXLEdBQUdxVztnQkFDM0MsSUFBSUUsV0FBV0EsT0FBTyxDQUFDSCxTQUFTLEVBQUU7b0JBQ2hDcFcsQ0FBQyxDQUFDcVcsRUFBRSxHQUFHQyxXQUFXOWMsS0FBSztvQkFDdkI4YyxhQUFhO3dCQUNYN2EsY0FBY3ZCLGdCQUFnQm9jLGFBQWFBLFVBQVUsQ0FBQ3BjLGFBQWEsR0FBR3FjLE9BQU8sQ0FBQ3JjLGFBQWE7d0JBQzNGK1ksWUFBWWtELGNBQWNHLGFBQWFBLFVBQVUsQ0FBQ0gsV0FBVyxHQUFHSSxPQUFPLENBQUNKLFdBQVc7d0JBQ25GdmEsVUFBVTtvQkFDWjtnQkFDRjtZQUNGO1lBQUUsT0FBT3FhLGdCQUFnQmpXLEdBQUdxVyxHQUFHQztRQUNqQyxJQUFJTCxrQkFBa0IsU0FBU3RiLGVBQWVxRixDQUFDLEVBQUVxVyxDQUFDLEVBQUVDLFVBQVU7WUFDNUR4ZSxTQUFTa0k7WUFDVHFXLElBQUlMLGNBQWNLO1lBQ2xCdmUsU0FBU3dlO1lBQ1QsSUFBSVIsZ0JBQWdCLElBQUk7Z0JBQ3RCLE9BQU9HLGdCQUFnQmpXLEdBQUdxVyxHQUFHQztZQUMvQixFQUFFLE9BQU9qZCxPQUFPLENBQWM7WUFDOUIsSUFBSSxTQUFTaWQsY0FBYyxTQUFTQSxZQUFZLE1BQU0sSUFBSXJlLFdBQVc7WUFDckUsSUFBSSxXQUFXcWUsWUFBWXRXLENBQUMsQ0FBQ3FXLEVBQUUsR0FBR0MsV0FBVzljLEtBQUs7WUFDbEQsT0FBT3dHO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQzFJLFFBQVFDLDBCQUEwQkMsZ0NBQW1CQTtRQUc3RCxJQUFJaUYsYUFBYWpGLGdDQUFtQkEsQ0FBQztRQUVyQyxJQUFJZ2YsZ0JBQWdCLFNBQVVqSixJQUFJO1lBQ2hDLE9BQU87Z0JBQ0xBLE1BQU1BO2dCQUNOeE0sS0FBSztvQkFDSCxPQUFPO2dCQUNUO2dCQUNBaEIsTUFBTTtvQkFDSixPQUFPO3dCQUNMeEMsTUFBTTs0QkFDSixPQUFPO2dDQUFFRSxNQUFNOzRCQUFLO3dCQUN0QjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxJQUFJZ1osZ0NBQWdDLFNBQVVsSixJQUFJO1lBQ2hELE9BQU87Z0JBQ0xBLE1BQU1BO2dCQUNOeE0sS0FBSztvQkFDSCxPQUFPO2dCQUNUO2dCQUNBaEIsTUFBTTtvQkFDSixNQUFNLElBQUkyVyxNQUFNO2dCQUNsQjtZQUNGO1FBQ0Y7UUFFQXBmLE9BQU9JLE9BQU8sR0FBRyxTQUFVMkQsSUFBSSxFQUFFc2IsUUFBUTtZQUN2QyxJQUFJcEcsT0FBTTlULFdBQVc7WUFDckIsSUFBSTtnQkFDRixJQUFJOFQsTUFBSyxDQUFDbFYsS0FBSyxDQUFDbWIsY0FBYztnQkFDOUIsSUFBSTtvQkFDRiw2RUFBNkU7b0JBQzdFLHVEQUF1RDtvQkFDdkQsNEJBQTRCO29CQUM1QixpREFBaUQ7b0JBQ2pELElBQUlqRyxNQUFLLENBQUNsVixLQUFLLENBQUNtYixjQUFjLENBQUM7b0JBQy9CLE9BQU87Z0JBQ1QsRUFBRSxPQUFPaEIsUUFBUTtvQkFDZixJQUFJLENBQUNtQixVQUFVLE9BQU87b0JBQ3RCLDhCQUE4QjtvQkFDOUIsK0NBQStDO29CQUMvQyxJQUFJO3dCQUNGLElBQUlwRyxNQUFLLENBQUNsVixLQUFLLENBQUNvYiw4QkFBOEIsQ0FBQzlMO3dCQUMvQyxPQUFPO29CQUNULEVBQUUsT0FBT3RSLE9BQU87d0JBQ2QsSUFBSXlILE1BQU0sSUFBSXlQO3dCQUNkelAsSUFBSXNOLEdBQUcsQ0FBQzt3QkFDUnROLElBQUlzTixHQUFHLENBQUM7d0JBQ1IsT0FBT3VJLFNBQVM3VixHQUFHLENBQUN6RixLQUFLLENBQUNvYiw4QkFBOEI5TDtvQkFDMUQ7Z0JBQ0Y7WUFDRixFQUFFLE9BQU90UixPQUFPO2dCQUNkLE9BQU87WUFDVDtRQUNGO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNiLHlCQUF5QmpCLDBCQUEwQkMsaUNBQW1CQTtRQUc5RSxJQUFJaUIsSUFBSWpCLGlDQUFtQkEsQ0FBQztRQUM1QixJQUFJSSxPQUFPSixpQ0FBbUJBLENBQUM7UUFDL0IsSUFBSU0sV0FBV04saUNBQW1CQSxDQUFDO1FBQ25DLElBQUltQixvQkFBb0JuQixpQ0FBbUJBLENBQUM7UUFDNUMsSUFBSW9mLFVBQVVwZixpQ0FBbUJBLENBQUM7UUFDbEMsSUFBSXFmLG9CQUFvQnJmLGlDQUFtQkEsQ0FBQztRQUM1QyxJQUFJbUcsc0JBQXNCbkcsaUNBQW1CQSxDQUFDO1FBQzlDLElBQUlvQixnQkFBZ0JwQixpQ0FBbUJBLENBQUM7UUFDeEMsSUFBSXFCLDJDQUEyQ3JCLGlDQUFtQkEsQ0FBQztRQUNuRSxJQUFJb0csVUFBVXBHLGlDQUFtQkEsQ0FBQztRQUVsQyxJQUFJc2YsaUNBQWlDLENBQUNsWixXQUFXL0UseUNBQXlDLFFBQVE0UjtRQUVsRyxJQUFJeE0sZ0JBQWdCTixvQkFBb0I7WUFDdEMsSUFBSUwsV0FBVyxJQUFJLENBQUNBLFFBQVE7WUFDNUIsSUFBSSxDQUFDLElBQUksQ0FBQ3laLFNBQVMsSUFBSTtnQkFDckIsSUFBSSxDQUFDdFosSUFBSSxHQUFHO2dCQUNaLE9BQU83RSxjQUFjMEUsVUFBVSxVQUFVeEI7WUFDM0M7WUFDQSxJQUFJbEMsU0FBUzlCLFNBQVNGLEtBQUssSUFBSSxDQUFDMkYsSUFBSSxFQUFFRDtZQUN0QyxJQUFJRyxPQUFPLElBQUksQ0FBQ0EsSUFBSSxHQUFHLENBQUMsQ0FBQzdELE9BQU82RCxJQUFJO1lBQ3BDLElBQUksQ0FBQ0EsTUFBTSxPQUFPN0QsT0FBT0osS0FBSztRQUNoQztRQUVBLG1DQUFtQztRQUNuQyx1REFBdUQ7UUFDdkRmLEVBQUU7WUFBRU0sUUFBUTtZQUFZQyxPQUFPO1lBQU1DLE1BQU07WUFBTUMsUUFBUTBFLFdBQVdrWjtRQUErQixHQUFHO1lBQ3BHRSxNQUFNLFNBQVNBLEtBQUtDLEtBQUs7Z0JBQ3ZCbmYsU0FBUyxJQUFJO2dCQUNiLElBQUlpZjtnQkFDSixJQUFJO29CQUNGQSxZQUFZRixrQkFBa0JELFFBQVEsQ0FBQ0s7Z0JBQ3pDLEVBQUUsT0FBTzVkLE9BQU87b0JBQ2RULGNBQWMsSUFBSSxFQUFFLFNBQVNTO2dCQUMvQjtnQkFFQSxJQUFJeWQsZ0NBQWdDLE9BQU9sZixLQUFLa2YsZ0NBQWdDLElBQUksRUFBRUM7Z0JBRXRGLE9BQU8sSUFBSTlZLGNBQWN0RixrQkFBa0IsSUFBSSxHQUFHO29CQUNoRG9lLFdBQVdBO2dCQUNiO1lBQ0Y7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDdmUseUJBQXlCakIsMEJBQTBCQyxpQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsaUNBQW1CQSxDQUFDO1FBQzVCLElBQUlrRixjQUFhbEYsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUlpRixhQUFhakYsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUltZSwyQkFBMkJuZSxpQ0FBbUJBLENBQUM7UUFDbkQsSUFBSW1ELGlCQUFrQm5ELGlDQUFtQkEsQ0FBQyxNQUFNa0wsQ0FBQztRQUNqRCxJQUFJM0ksU0FBU3ZDLGlDQUFtQkEsQ0FBQztRQUNqQyxJQUFJMGYsYUFBYTFmLGlDQUFtQkEsQ0FBQztRQUNyQyxJQUFJMmYsb0JBQW9CM2YsaUNBQW1CQSxDQUFDO1FBQzVDLElBQUk0ZiwwQkFBMEI1ZixpQ0FBbUJBLENBQUM7UUFDbEQsSUFBSTZmLHdCQUF3QjdmLGlDQUFtQkEsQ0FBQztRQUNoRCxJQUFJOGYsa0JBQWtCOWYsaUNBQW1CQSxDQUFDO1FBQzFDLElBQUl3QyxjQUFjeEMsaUNBQW1CQSxDQUFDO1FBQ3RDLElBQUlvRyxVQUFVcEcsaUNBQW1CQSxDQUFDO1FBRWxDLElBQUkrZixnQkFBZ0I7UUFDcEIsSUFBSWIsU0FBUWphLFdBQVc7UUFDdkIsSUFBSSthLHFCQUFxQi9hLFdBQVc4YTtRQUVwQyxJQUFJRSxnQkFBZ0IsU0FBU0M7WUFDM0JSLFdBQVcsSUFBSSxFQUFFUztZQUNqQixJQUFJQyxrQkFBa0J0ZixVQUFVQyxNQUFNO1lBQ3RDLElBQUlzZixVQUFVVCx3QkFBd0JRLGtCQUFrQixJQUFJOWIsWUFBWXhELFNBQVMsQ0FBQyxFQUFFO1lBQ3BGLElBQUkrQyxPQUFPK2Isd0JBQXdCUSxrQkFBa0IsSUFBSTliLFlBQVl4RCxTQUFTLENBQUMsRUFBRSxFQUFFO1lBQ25GLElBQUlvUCxPQUFPLElBQUk4UCxtQkFBbUJLLFNBQVN4YztZQUMzQyxJQUFJaEMsUUFBUSxJQUFJcWQsT0FBTW1CO1lBQ3RCeGUsTUFBTWdDLElBQUksR0FBR2tjO1lBQ2I1YyxlQUFlK00sTUFBTSxTQUFTaU8seUJBQXlCLEdBQUcyQixnQkFBZ0JqZSxNQUFNeWUsS0FBSyxFQUFFO1lBQ3ZGWCxrQkFBa0J6UCxNQUFNLElBQUksRUFBRStQO1lBQzlCLE9BQU8vUDtRQUNUO1FBRUEsSUFBSWlRLHdCQUF3QkYsY0FBYzViLFNBQVMsR0FBRzJiLG1CQUFtQjNiLFNBQVM7UUFFbEYsSUFBSWtjLGtCQUFrQixXQUFXLElBQUlyQixPQUFNYTtRQUMzQyxJQUFJUywwQkFBMEIsV0FBVyxJQUFJUixtQkFBbUIsR0FBRztRQUVuRSx5RUFBeUU7UUFDekUsSUFBSTVULGFBQWE0VCxzQkFBc0J4ZCxlQUFlWSxPQUFPeUIsd0JBQXdCLENBQUNLLGFBQVk2YTtRQUVsRyw4RUFBOEU7UUFDOUUsa0RBQWtEO1FBQ2xELElBQUlVLG1CQUFtQixDQUFDLENBQUNyVSxjQUFjLENBQUVBLENBQUFBLFdBQVdoSSxRQUFRLElBQUlnSSxXQUFXbkksWUFBWTtRQUV2RixJQUFJeWMscUJBQXFCSCxtQkFBbUIsQ0FBQ0Usb0JBQW9CLENBQUNEO1FBRWxFLG9FQUFvRTtRQUNwRSw4REFBOEQ7UUFDOUR2ZixFQUFFO1lBQUVzWixRQUFRO1lBQU1wVyxhQUFhO1lBQU16QyxRQUFRMEUsV0FBV3NhO1FBQW1CLEdBQUc7WUFDNUVSLGNBQWNRLHFCQUFxQlQsZ0JBQWdCRDtRQUNyRDtRQUVBLElBQUlXLHlCQUF5QjFiLFdBQVc4YTtRQUN4QyxJQUFJYSxrQ0FBa0NELHVCQUF1QnRjLFNBQVM7UUFFdEUsSUFBSXVjLGdDQUFnQ3pjLFdBQVcsS0FBS3djLHdCQUF3QjtZQUMxRSxJQUFJLENBQUN2YSxTQUFTO2dCQUNaakQsZUFBZXlkLGlDQUFpQyxlQUFlekMseUJBQXlCLEdBQUd3QztZQUM3RjtZQUVBLElBQUssSUFBSXhVLE9BQU8wVCxzQkFBdUIsSUFBSXRkLE9BQU9zZCx1QkFBdUIxVCxNQUFNO2dCQUM3RSxJQUFJMFUsV0FBV2hCLHFCQUFxQixDQUFDMVQsSUFBSTtnQkFDekMsSUFBSTJVLGVBQWVELFNBQVNFLENBQUM7Z0JBQzdCLElBQUksQ0FBQ3hlLE9BQU9vZSx3QkFBd0JHLGVBQWU7b0JBQ2pEM2QsZUFBZXdkLHdCQUF3QkcsY0FBYzNDLHlCQUF5QixHQUFHMEMsU0FBU0csQ0FBQztnQkFDN0Y7WUFDRjtRQUNGO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNsaEI7UUFHUkEsT0FBT0ksT0FBTyxHQUFHO1lBQ2YrZ0IsZ0JBQWdCO2dCQUFFRixHQUFHO2dCQUFrQkMsR0FBRztnQkFBR0UsR0FBRztZQUFFO1lBQ2xEQyxvQkFBb0I7Z0JBQUVKLEdBQUc7Z0JBQXNCQyxHQUFHO2dCQUFHRSxHQUFHO1lBQUU7WUFDMURFLHVCQUF1QjtnQkFBRUwsR0FBRztnQkFBeUJDLEdBQUc7Z0JBQUdFLEdBQUc7WUFBRTtZQUNoRUcsb0JBQW9CO2dCQUFFTixHQUFHO2dCQUFzQkMsR0FBRztnQkFBR0UsR0FBRztZQUFFO1lBQzFESSx1QkFBdUI7Z0JBQUVQLEdBQUc7Z0JBQXlCQyxHQUFHO2dCQUFHRSxHQUFHO1lBQUU7WUFDaEVLLG9CQUFvQjtnQkFBRVIsR0FBRztnQkFBdUJDLEdBQUc7Z0JBQUdFLEdBQUc7WUFBRTtZQUMzRE0sNEJBQTRCO2dCQUFFVCxHQUFHO2dCQUErQkMsR0FBRztnQkFBR0UsR0FBRztZQUFFO1lBQzNFTyxlQUFlO2dCQUFFVixHQUFHO2dCQUFpQkMsR0FBRztnQkFBR0UsR0FBRztZQUFFO1lBQ2hEUSxtQkFBbUI7Z0JBQUVYLEdBQUc7Z0JBQXFCQyxHQUFHO2dCQUFHRSxHQUFHO1lBQUU7WUFDeERTLHFCQUFxQjtnQkFBRVosR0FBRztnQkFBdUJDLEdBQUc7Z0JBQUlFLEdBQUc7WUFBRTtZQUM3RFUsbUJBQW1CO2dCQUFFYixHQUFHO2dCQUFxQkMsR0FBRztnQkFBSUUsR0FBRztZQUFFO1lBQ3pEMVUsYUFBYTtnQkFBRXVVLEdBQUc7Z0JBQWNDLEdBQUc7Z0JBQUlFLEdBQUc7WUFBRTtZQUM1Q1csMEJBQTBCO2dCQUFFZCxHQUFHO2dCQUE0QkMsR0FBRztnQkFBSUUsR0FBRztZQUFFO1lBQ3ZFWSxnQkFBZ0I7Z0JBQUVmLEdBQUc7Z0JBQWlCQyxHQUFHO2dCQUFJRSxHQUFHO1lBQUU7WUFDbERhLG9CQUFvQjtnQkFBRWhCLEdBQUc7Z0JBQXNCQyxHQUFHO2dCQUFJRSxHQUFHO1lBQUU7WUFDM0RjLGlCQUFpQjtnQkFBRWpCLEdBQUc7Z0JBQWtCQyxHQUFHO2dCQUFJRSxHQUFHO1lBQUU7WUFDcERlLG1CQUFtQjtnQkFBRWxCLEdBQUc7Z0JBQXFCQyxHQUFHO2dCQUFJRSxHQUFHO1lBQUU7WUFDekRnQixlQUFlO2dCQUFFbkIsR0FBRztnQkFBZ0JDLEdBQUc7Z0JBQUlFLEdBQUc7WUFBRTtZQUNoRGlCLGNBQWM7Z0JBQUVwQixHQUFHO2dCQUFlQyxHQUFHO2dCQUFJRSxHQUFHO1lBQUU7WUFDOUNrQixZQUFZO2dCQUFFckIsR0FBRztnQkFBYUMsR0FBRztnQkFBSUUsR0FBRztZQUFFO1lBQzFDbUIsa0JBQWtCO2dCQUFFdEIsR0FBRztnQkFBb0JDLEdBQUc7Z0JBQUlFLEdBQUc7WUFBRTtZQUN2RG9CLG9CQUFvQjtnQkFBRXZCLEdBQUc7Z0JBQXNCQyxHQUFHO2dCQUFJRSxHQUFHO1lBQUU7WUFDM0RxQixjQUFjO2dCQUFFeEIsR0FBRztnQkFBZUMsR0FBRztnQkFBSUUsR0FBRztZQUFFO1lBQzlDc0Isc0JBQXNCO2dCQUFFekIsR0FBRztnQkFBeUJDLEdBQUc7Z0JBQUlFLEdBQUc7WUFBRTtZQUNoRXVCLGdCQUFnQjtnQkFBRTFCLEdBQUc7Z0JBQWtCQyxHQUFHO2dCQUFJRSxHQUFHO1lBQUU7UUFDckQ7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2xnQix5QkFBeUJqQiwwQkFBMEJDLGlDQUFtQkE7UUFHOUUsSUFBSWlCLElBQUlqQixpQ0FBbUJBLENBQUM7UUFDNUIsSUFBSTZXLHNCQUFzQjdXLGlDQUFtQkEsQ0FBQztRQUM5QyxJQUFJdUwsZ0NBQWdDdkwsaUNBQW1CQSxDQUFDO1FBQ3hELElBQUl3TCx5QkFBeUJ4TCxpQ0FBbUJBLENBQUM7UUFFakQsSUFBSXdHLFNBQVMsQ0FBQ2dGLHVCQUF1QiwwQkFBMEIsQ0FBQ0QsOEJBQThCO1FBRTlGLDZDQUE2QztRQUM3QyxpRUFBaUU7UUFDakV0SyxFQUFFO1lBQUVNLFFBQVE7WUFBT0MsT0FBTztZQUFNQyxNQUFNO1lBQU1DLFFBQVE4RTtRQUFPLEdBQUc7WUFDNURxUSxxQkFBcUJBO1FBQ3ZCO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUMvVyxRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSWlGLGFBQWFqRixpQ0FBbUJBLENBQUM7UUFDckMsSUFBSXFDLGNBQWNyQyxpQ0FBbUJBLENBQUM7UUFDdEMsSUFBSTBpQiw0QkFBNEIxaUIsaUNBQW1CQSxDQUFDO1FBQ3BELElBQUkyaUIsOEJBQThCM2lCLGlDQUFtQkEsQ0FBQztRQUN0RCxJQUFJTSxXQUFXTixpQ0FBbUJBLENBQUM7UUFFbkMsSUFBSTRpQixTQUFTdmdCLFlBQVksRUFBRSxDQUFDdWdCLE1BQU07UUFFbEMsdURBQXVEO1FBQ3ZEOWlCLE9BQU9JLE9BQU8sR0FBRytFLFdBQVcsV0FBVyxjQUFjLFNBQVM0ZCxRQUFRMWlCLEVBQUU7WUFDdEUsSUFBSW9JLE9BQU9tYSwwQkFBMEJ4WCxDQUFDLENBQUM1SyxTQUFTSDtZQUNoRCxJQUFJNlcsd0JBQXdCMkwsNEJBQTRCelgsQ0FBQztZQUN6RCxPQUFPOEwsd0JBQXdCNEwsT0FBT3JhLE1BQU15TyxzQkFBc0I3VyxPQUFPb0k7UUFDM0U7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3pJLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJOGlCLGFBQWE5aUIsaUNBQW1CQSxDQUFDO1FBRXJDLElBQUlTLGFBQWFDO1FBRWpCWixPQUFPSSxPQUFPLEdBQUcsU0FBVUMsRUFBRTtZQUMzQixJQUFJMmlCLFdBQVczaUIsS0FBSyxNQUFNLElBQUlNLFdBQVc7WUFDekMsT0FBT047UUFDVDtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDTCxRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSXlTLHNCQUFzQnpTLGlDQUFtQkEsQ0FBQztRQUM5QyxJQUFJOFYsYUFBYTlWLGlDQUFtQkEsQ0FBQztRQUVyQ0YsT0FBT0ksT0FBTyxHQUFHdVMsb0JBQW9CcUQsV0FBV3RVLEtBQUssRUFBRSxRQUFRLFVBQVUsU0FBVThILEdBQUc7WUFDcEYsT0FBT0EsSUFBSXlNLElBQUk7UUFDakI7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQy9VLHlCQUF5QmpCLDBCQUEwQkMsaUNBQW1CQTtRQUc5RSxJQUFJaUIsSUFBSWpCLGlDQUFtQkEsQ0FBQztRQUM1QixJQUFJa0YsY0FBYWxGLGlDQUFtQkEsQ0FBQztRQUNyQyxJQUFJK2lCLDhCQUE4Qi9pQixpQ0FBbUJBLENBQUM7UUFDdEQsSUFBSWdqQixjQUFjaGpCLGlDQUFtQkEsQ0FBQztRQUV0QyxJQUFJc0YsY0FBYUosWUFBV0ksVUFBVTtRQUV0QyxJQUFJQyxzQ0FBc0MsQ0FBQ0QsZUFBYyxDQUFDQSxZQUFXMmQsVUFBVSxJQUFJLENBQUM7WUFDbEYsaURBQWlEO1lBQ2pELElBQUk7Z0JBQ0YzZCxZQUFXMmQsVUFBVSxDQUFDO2dCQUN0QjtZQUNGLEVBQUUsT0FBT3BoQixPQUFPLENBQWM7WUFDOUIsSUFBSTtnQkFDRnlELFlBQVcyZCxVQUFVLENBQUMsSUFBSTtZQUM1QixFQUFFLE9BQU9waEIsT0FBTztnQkFDZCxPQUFPO1lBQ1Q7UUFDRjtRQUVBLGlDQUFpQztRQUNqQyxzREFBc0Q7UUFDdEQsSUFBSXlELGFBQVlyRSxFQUFFO1lBQUVNLFFBQVE7WUFBY3VKLE1BQU07WUFBTXBKLFFBQVE2RDtRQUFvQyxHQUFHO1lBQ25HMGQsWUFBWSxTQUFTQSxXQUFXclcsT0FBTyxhQUFhLEdBQWQ7Z0JBQ3BDLElBQUl4SyxTQUFTNGdCLFlBQVlwVyxRQUFROUwsVUFBVUMsTUFBTSxHQUFHLElBQUlELFNBQVMsQ0FBQyxFQUFFLEdBQUd3RCxXQUFXLE1BQU07Z0JBQ3hGLE9BQU95ZSw0QkFBNEJ6ZCxhQUFZbEQsT0FBTzRLLEtBQUs7WUFDN0Q7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDbE4sUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUk0UCxvQkFBb0I1UCxpQ0FBbUJBLENBQUM7UUFFNUNGLE9BQU9JLE9BQU8sR0FBRyxTQUFVd2MsV0FBVyxFQUFFd0csSUFBSSxFQUFFQyxPQUFPO1lBQ25ELElBQUk3UyxRQUFRO1lBQ1osSUFBSXZQLFNBQVNELFVBQVVDLE1BQU0sR0FBRyxJQUFJb2lCLFVBQVV2VCxrQkFBa0JzVDtZQUNoRSxJQUFJOWdCLFNBQVMsSUFBSXNhLFlBQVkzYjtZQUM3QixNQUFPQSxTQUFTdVAsTUFBT2xPLE1BQU0sQ0FBQ2tPLE1BQU0sR0FBRzRTLElBQUksQ0FBQzVTLFFBQVE7WUFDcEQsT0FBT2xPO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3RDLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCx3REFBd0Q7UUFDeEQsSUFBSW9qQixnQkFBZ0JwakIsaUNBQW1CQSxDQUFDO1FBQ3hDLElBQUkwUyx5QkFBeUIxUyxpQ0FBbUJBLENBQUM7UUFFakRGLE9BQU9JLE9BQU8sR0FBRyxTQUFVQyxFQUFFO1lBQzNCLE9BQU9pakIsY0FBYzFRLHVCQUF1QnZTO1FBQzlDO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNMLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJaVgsc0JBQXNCalgsaUNBQW1CQSxDQUFDO1FBRTlDLElBQUltWCxNQUFNNVAsS0FBSzRQLEdBQUc7UUFDbEIsSUFBSXpLLE1BQU1uRixLQUFLbUYsR0FBRztRQUVsQixtREFBbUQ7UUFDbkQscUNBQXFDO1FBQ3JDLHFHQUFxRztRQUNyRzVNLE9BQU9JLE9BQU8sR0FBRyxTQUFVb1EsS0FBSyxFQUFFdlAsTUFBTTtZQUN0QyxJQUFJc2lCLFVBQVVwTSxvQkFBb0IzRztZQUNsQyxPQUFPK1MsVUFBVSxJQUFJbE0sSUFBSWtNLFVBQVV0aUIsUUFBUSxLQUFLMkwsSUFBSTJXLFNBQVN0aUI7UUFDL0Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ0MseUJBQXlCakIsMEJBQTBCQyxpQ0FBbUJBO1FBRzlFLGdDQUFnQztRQUNoQ0EsaUNBQW1CQSxDQUFDO0lBR3BCLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDRixRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSWtGLGNBQWFsRixpQ0FBbUJBLENBQUM7UUFDckMsSUFBSXFDLGNBQWNyQyxpQ0FBbUJBLENBQUM7UUFDdEMsSUFBSXlTLHNCQUFzQnpTLGlDQUFtQkEsQ0FBQztRQUM5QyxJQUFJc2pCLFVBQVV0akIsaUNBQW1CQSxDQUFDO1FBQ2xDLElBQUlvRixjQUFjcEYsaUNBQW1CQSxDQUFDO1FBQ3RDLElBQUl3Vix3QkFBd0J4VixpQ0FBbUJBLENBQUM7UUFDaEQsSUFBSXVqQixxQkFBcUJ2akIsaUNBQW1CQSxDQUFDO1FBQzdDLElBQUlpWixtQ0FBbUNqWixpQ0FBbUJBLENBQUM7UUFFM0QsSUFBSW9LLG1CQUFrQmxGLFlBQVdrRixlQUFlO1FBQ2hELElBQUlDLGVBQWNuRixZQUFXbUYsV0FBVztRQUN4QyxJQUFJb0wsWUFBV3ZRLFlBQVd1USxRQUFRO1FBQ2xDLElBQUkvSSxNQUFNbkYsS0FBS21GLEdBQUc7UUFDbEIsSUFBSThXLHVCQUF1Qm5aLGFBQVloRyxTQUFTO1FBQ2hELElBQUlvZixvQkFBb0JoTyxVQUFTcFIsU0FBUztRQUMxQyxJQUFJZixRQUFRakIsWUFBWW1oQixxQkFBcUJsZ0IsS0FBSztRQUNsRCxJQUFJb2dCLGNBQWNqUixvQkFBb0IrUSxzQkFBc0IsYUFBYTtRQUN6RSxJQUFJRyxnQkFBZ0JsUixvQkFBb0IrUSxzQkFBc0IsaUJBQWlCO1FBQy9FLElBQUlJLFVBQVV2aEIsWUFBWW9oQixrQkFBa0JHLE9BQU87UUFDbkQsSUFBSUMsVUFBVXhoQixZQUFZb2hCLGtCQUFrQkksT0FBTztRQUVuRC9qQixPQUFPSSxPQUFPLEdBQUcsQ0FBQytZLG9DQUFvQ3NLLGtCQUFpQixLQUFNLFNBQVVPLFdBQVcsRUFBRUMsU0FBUyxFQUFFQyxvQkFBb0I7WUFDakksSUFBSXhaLGFBQWFnTCxzQkFBc0JzTztZQUN2QyxJQUFJRyxnQkFBZ0JGLGNBQWN6ZixZQUFZa0csYUFBYThZLFFBQVFTO1lBQ25FLElBQUlHLGNBQWMsQ0FBQ1IsZUFBZSxDQUFDQSxZQUFZSTtZQUMvQyxJQUFJSztZQUNKL2UsWUFBWTBlO1lBQ1osSUFBSTdLLGtDQUFrQztnQkFDcEM2SyxjQUFjMVosaUJBQWdCMFosYUFBYTtvQkFBRXZaLFVBQVU7d0JBQUN1WjtxQkFBWTtnQkFBQztnQkFDckUsSUFBSXRaLGVBQWV5WixpQkFBa0JELENBQUFBLHdCQUF3QkUsV0FBVSxHQUFJLE9BQU9KO1lBQ3BGO1lBQ0EsSUFBSXRaLGNBQWN5WixpQkFBa0IsRUFBQ0Qsd0JBQXdCRSxXQUFVLEdBQUk7Z0JBQ3pFQyxZQUFZN2dCLE1BQU13Z0IsYUFBYSxHQUFHRztZQUNwQyxPQUFPO2dCQUNMLElBQUluZ0IsVUFBVWtnQix3QkFBd0IsQ0FBQ0UsZUFBZVAsZ0JBQWdCO29CQUFFQSxlQUFlQSxjQUFjRztnQkFBYSxJQUFJeGY7Z0JBQ3RINmYsWUFBWSxJQUFJOVosYUFBWTRaLGVBQWVuZ0I7Z0JBQzNDLElBQUlzZ0IsSUFBSSxJQUFJM08sVUFBU3FPO2dCQUNyQixJQUFJTyxJQUFJLElBQUk1TyxVQUFTME87Z0JBQ3JCLElBQUlHLGFBQWE1WCxJQUFJdVgsZUFBZXpaO2dCQUNwQyxJQUFLLElBQUk5RSxJQUFJLEdBQUdBLElBQUk0ZSxZQUFZNWUsSUFBS21lLFFBQVFRLEdBQUczZSxHQUFHa2UsUUFBUVEsR0FBRzFlO1lBQ2hFO1lBQ0EsSUFBSSxDQUFDdVQsa0NBQWtDc0ssbUJBQW1CTztZQUMxRCxPQUFPSztRQUNUO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNya0IsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUkySixRQUFRM0osaUNBQW1CQSxDQUFDO1FBRWhDRixPQUFPSSxPQUFPLEdBQUcsU0FBVWlNLEdBQUcsRUFBRW5LLEtBQUs7WUFDbkMsT0FBTzJILEtBQUssQ0FBQ3dDLElBQUksSUFBS3hDLENBQUFBLEtBQUssQ0FBQ3dDLElBQUksR0FBR25LLFNBQVMsQ0FBQztRQUMvQztJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDaEIseUJBQXlCakIsMEJBQTBCQyxpQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsaUNBQW1CQSxDQUFDO1FBQzVCLElBQUlpRixhQUFhakYsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUl5YSwwQkFBMEJ6YSxpQ0FBbUJBLENBQUM7UUFDbEQsSUFBSTBFLFdBQVcxRSxpQ0FBbUJBLENBQUM7UUFDbkMsSUFBSXVrQixpQkFBaUJ2a0IsaUNBQW1CQSxDQUFDO1FBRXpDLElBQUl3a0IsT0FBTXZmLFdBQVc7UUFFckIscUJBQXFCO1FBQ3JCLGdEQUFnRDtRQUNoRGhFLEVBQUU7WUFBRU0sUUFBUTtZQUFPdUosTUFBTTtZQUFNcEosUUFBUSxDQUFDNmlCO1FBQWUsR0FBRztZQUN4REUsT0FBTyxTQUFTQSxNQUFNQyxHQUFHO2dCQUN2QixJQUFJM2pCLFNBQVMwWix3QkFBd0IzWixVQUFVQyxNQUFNLEVBQUU7Z0JBQ3ZELElBQUk0akIsWUFBWWpnQixTQUFTZ2dCO2dCQUN6QixJQUFJRSxPQUFPN2pCLFNBQVMsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS3dELFlBQVlBLFlBQVlJLFNBQVM1RCxTQUFTLENBQUMsRUFBRTtnQkFDdkYsSUFBSTtvQkFDRixPQUFPLElBQUkwakIsS0FBSUcsV0FBV0M7Z0JBQzVCLEVBQUUsT0FBTy9pQixPQUFPO29CQUNkLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUMvQixRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSTZrQixjQUFjN2tCLGlDQUFtQkEsQ0FBQztRQUV0QyxJQUFJUyxhQUFhQztRQUVqQixnQ0FBZ0M7UUFDaEMsd0NBQXdDO1FBQ3hDWixPQUFPSSxPQUFPLEdBQUcsU0FBVVMsUUFBUTtZQUNqQyxJQUFJbWtCLE9BQU9ELFlBQVlsa0IsVUFBVTtZQUNqQyxJQUFJLE9BQU9ta0IsUUFBUSxVQUFVLE1BQU0sSUFBSXJrQixXQUFXO1lBQ2xELGdEQUFnRDtZQUNoRCxPQUFPc2tCLE9BQU9EO1FBQ2hCO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUM5akIseUJBQXlCakIsMEJBQTBCQyxpQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsaUNBQW1CQSxDQUFDO1FBQzVCLElBQUl1WCxhQUFhdlgsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUl3TCx5QkFBeUJ4TCxpQ0FBbUJBLENBQUM7UUFFakQsSUFBSXNQLFlBQVksQ0FBQzlELHVCQUF1QixjQUFjLFNBQVVwSixNQUFNO1lBQ3BFLE9BQU9BO1FBQ1Q7UUFFQSxvQ0FBb0M7UUFDcEMsd0RBQXdEO1FBQ3hEbkIsRUFBRTtZQUFFTSxRQUFRO1lBQU9DLE9BQU87WUFBTUMsTUFBTTtZQUFNQyxRQUFRNE47UUFBVSxHQUFHO1lBQy9EaUksWUFBWUE7UUFDZDtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDelgsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUl3QyxjQUFjeEMsaUNBQW1CQSxDQUFDO1FBQ3RDLElBQUlzQyxRQUFRdEMsaUNBQW1CQSxDQUFDO1FBQ2hDLElBQUl5WCxnQkFBZ0J6WCxpQ0FBbUJBLENBQUM7UUFFeEMsNkNBQTZDO1FBQzdDRixPQUFPSSxPQUFPLEdBQUcsQ0FBQ3NDLGVBQWUsQ0FBQ0YsTUFBTTtZQUN0QywrRUFBK0U7WUFDL0UsT0FBT2MsT0FBT0QsY0FBYyxDQUFDc1UsY0FBYyxRQUFRLEtBQUs7Z0JBQ3REelUsS0FBSztvQkFBYyxPQUFPO2dCQUFHO1lBQy9CLEdBQUdvaEIsQ0FBQyxLQUFLO1FBQ1g7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3RrQixRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSUssWUFBWUwsaUNBQW1CQSxDQUFDO1FBQ3BDLElBQUlnSSxvQkFBb0JoSSxpQ0FBbUJBLENBQUM7UUFFNUMsaUNBQWlDO1FBQ2pDLHlDQUF5QztRQUN6Q0YsT0FBT0ksT0FBTyxHQUFHLFNBQVU4a0IsQ0FBQyxFQUFFbkcsQ0FBQztZQUM3QixJQUFJb0csT0FBT0QsQ0FBQyxDQUFDbkcsRUFBRTtZQUNmLE9BQU83VyxrQkFBa0JpZCxRQUFRM2dCLFlBQVlqRSxVQUFVNGtCO1FBQ3pEO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNubEIsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlLLFlBQVlMLGlDQUFtQkEsQ0FBQztRQUVwQyxJQUFJUyxhQUFhQztRQUVqQixJQUFJd2tCLG9CQUFvQixTQUFVeEgsQ0FBQztZQUNqQyxJQUFJdFMsU0FBU0Q7WUFDYixJQUFJLENBQUNFLE9BQU8sR0FBRyxJQUFJcVMsRUFBRSxTQUFVeUgsU0FBUyxFQUFFQyxRQUFRO2dCQUNoRCxJQUFJaGEsWUFBWTlHLGFBQWE2RyxXQUFXN0csV0FBVyxNQUFNLElBQUk3RCxXQUFXO2dCQUN4RTJLLFVBQVUrWjtnQkFDVmhhLFNBQVNpYTtZQUNYO1lBQ0EsSUFBSSxDQUFDaGEsT0FBTyxHQUFHL0ssVUFBVStLO1lBQ3pCLElBQUksQ0FBQ0QsTUFBTSxHQUFHOUssVUFBVThLO1FBQzFCO1FBRUEsNENBQTRDO1FBQzVDLG9EQUFvRDtRQUNwRHJMLE9BQU9JLE9BQU8sQ0FBQ2dMLENBQUMsR0FBRyxTQUFVd1MsQ0FBQztZQUM1QixPQUFPLElBQUl3SCxrQkFBa0J4SDtRQUMvQjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDNWQsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlxQyxjQUFjckMsaUNBQW1CQSxDQUFDO1FBQ3RDLElBQUlLLFlBQVlMLGlDQUFtQkEsQ0FBQztRQUNwQyxJQUFJcWxCLGNBQWNybEIsaUNBQW1CQSxDQUFDO1FBRXRDLElBQUk4RyxPQUFPekUsWUFBWUEsWUFBWXlFLElBQUk7UUFFdkMsb0NBQW9DO1FBQ3BDaEgsT0FBT0ksT0FBTyxHQUFHLFNBQVUwRixFQUFFLEVBQUVzSyxJQUFJO1lBQ2pDN1AsVUFBVXVGO1lBQ1YsT0FBT3NLLFNBQVM1TCxZQUFZc0IsS0FBS3lmLGNBQWN2ZSxLQUFLbEIsSUFBSXNLLFFBQVE7Z0JBQzlELE9BQU90SyxHQUFHNkUsS0FBSyxDQUFDeUYsTUFBTXBQO1lBQ3hCO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2hCLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJaUosU0FBU2pKLGlDQUFtQkEsQ0FBQztRQUNqQyxJQUFJNmIsTUFBTTdiLGlDQUFtQkEsQ0FBQztRQUU5QixJQUFJdUksT0FBT1UsT0FBTztRQUVsQm5KLE9BQU9JLE9BQU8sR0FBRyxTQUFVaU0sR0FBRztZQUM1QixPQUFPNUQsSUFBSSxDQUFDNEQsSUFBSSxJQUFLNUQsQ0FBQUEsSUFBSSxDQUFDNEQsSUFBSSxHQUFHMFAsSUFBSTFQLElBQUc7UUFDMUM7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3JNLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJbUssY0FBY25LLGlDQUFtQkEsQ0FBQztRQUV0Q0YsT0FBT0ksT0FBTyxHQUFHaUssZ0JBQWdCO0lBR2pDLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDckssUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlzbEIsV0FBV3RsQixpQ0FBbUJBLENBQUM7UUFFbkMseUNBQXlDO1FBQ3pDLGlEQUFpRDtRQUNqREYsT0FBT0ksT0FBTyxHQUFHLFNBQVUyTCxHQUFHO1lBQzVCLE9BQU95WixTQUFTelosSUFBSTlLLE1BQU07UUFDNUI7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2pCO1FBR1JBLE9BQU9JLE9BQU8sR0FBRyxDQUFDO0lBR2xCLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDSixRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSXdhLGdCQUFnQnhhLGlDQUFtQkEsQ0FBQztRQUV4Q0YsT0FBT0ksT0FBTyxHQUFHLFNBQVVxQixNQUFNLEVBQUVxTixHQUFHLEVBQUU5SyxPQUFPO1lBQzdDLElBQUssSUFBSXFJLE9BQU95QyxJQUFLNEwsY0FBY2paLFFBQVE0SyxLQUFLeUMsR0FBRyxDQUFDekMsSUFBSSxFQUFFckk7WUFDMUQsT0FBT3ZDO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3pCLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJTSxXQUFXTixpQ0FBbUJBLENBQUM7UUFDbkMsSUFBSW9CLGdCQUFnQnBCLGlDQUFtQkEsQ0FBQztRQUV4Qyw2REFBNkQ7UUFDN0RGLE9BQU9JLE9BQU8sR0FBRyxTQUFVNEYsUUFBUSxFQUFFRixFQUFFLEVBQUU1RCxLQUFLLEVBQUV1akIsT0FBTztZQUNyRCxJQUFJO2dCQUNGLE9BQU9BLFVBQVUzZixHQUFHdEYsU0FBUzBCLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLElBQUk0RCxHQUFHNUQ7WUFDekQsRUFBRSxPQUFPSCxPQUFPO2dCQUNkVCxjQUFjMEUsVUFBVSxTQUFTakU7WUFDbkM7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDL0I7UUFHUkEsT0FBT0ksT0FBTyxHQUFHO0lBR2pCLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDSixRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSWtGLGNBQWFsRixpQ0FBbUJBLENBQUM7UUFDckMsSUFBSTZFLDJCQUE0QjdFLGlDQUFtQkEsQ0FBQyxNQUFNa0wsQ0FBQztRQUMzRCxJQUFJbEMsOEJBQThCaEosaUNBQW1CQSxDQUFDO1FBQ3RELElBQUl3YSxnQkFBZ0J4YSxpQ0FBbUJBLENBQUM7UUFDeEMsSUFBSXdsQix1QkFBdUJ4bEIsaUNBQW1CQSxDQUFDO1FBQy9DLElBQUl5bEIsNEJBQTRCemxCLGlDQUFtQkEsQ0FBQztRQUNwRCxJQUFJbVIsV0FBV25SLGlDQUFtQkEsQ0FBQztRQUVuQzs7Ozs7Ozs7Ozs7Ozs7QUFjQSxHQUNBRixPQUFPSSxPQUFPLEdBQUcsU0FBVTRELE9BQU8sRUFBRVUsTUFBTTtZQUN4QyxJQUFJa2hCLFNBQVM1aEIsUUFBUXZDLE1BQU07WUFDM0IsSUFBSW9rQixTQUFTN2hCLFFBQVF5VyxNQUFNO1lBQzNCLElBQUlxTCxTQUFTOWhCLFFBQVFnSCxJQUFJO1lBQ3pCLElBQUl0RSxRQUFRakYsUUFBUTRLLEtBQUswWixnQkFBZ0JDLGdCQUFnQjFaO1lBQ3pELElBQUl1WixRQUFRO2dCQUNWcGtCLFNBQVMyRDtZQUNYLE9BQU8sSUFBSTBnQixRQUFRO2dCQUNqQnJrQixTQUFTMkQsV0FBVSxDQUFDd2dCLE9BQU8sSUFBSUYscUJBQXFCRSxRQUFRLENBQUM7WUFDL0QsT0FBTztnQkFDTG5rQixTQUFTMkQsV0FBVSxDQUFDd2dCLE9BQU8sSUFBSXhnQixXQUFVLENBQUN3Z0IsT0FBTyxDQUFDcmhCLFNBQVM7WUFDN0Q7WUFDQSxJQUFJOUMsUUFBUSxJQUFLNEssT0FBTzNILE9BQVE7Z0JBQzlCc2hCLGlCQUFpQnRoQixNQUFNLENBQUMySCxJQUFJO2dCQUM1QixJQUFJckksUUFBUWlpQixjQUFjLEVBQUU7b0JBQzFCM1osYUFBYXZILHlCQUF5QnRELFFBQVE0SztvQkFDOUMwWixpQkFBaUJ6WixjQUFjQSxXQUFXcEssS0FBSztnQkFDakQsT0FBTzZqQixpQkFBaUJ0a0IsTUFBTSxDQUFDNEssSUFBSTtnQkFDbkMzRixTQUFTMkssU0FBU3dVLFNBQVN4WixNQUFNdVosU0FBVUUsQ0FBQUEsU0FBUyxNQUFNLEdBQUUsSUFBS3paLEtBQUtySSxRQUFRcEMsTUFBTTtnQkFDcEYsc0JBQXNCO2dCQUN0QixJQUFJLENBQUM4RSxVQUFVcWYsbUJBQW1CdmhCLFdBQVc7b0JBQzNDLElBQUksT0FBT3doQixrQkFBa0IsT0FBT0QsZ0JBQWdCO29CQUNwREosMEJBQTBCSyxnQkFBZ0JEO2dCQUM1QztnQkFDQSw4Q0FBOEM7Z0JBQzlDLElBQUkvaEIsUUFBUWlXLElBQUksSUFBSzhMLGtCQUFrQkEsZUFBZTlMLElBQUksRUFBRztvQkFDM0QvUSw0QkFBNEI4YyxnQkFBZ0IsUUFBUTtnQkFDdEQ7Z0JBQ0F0TCxjQUFjalosUUFBUTRLLEtBQUsyWixnQkFBZ0JoaUI7WUFDN0M7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDOUMseUJBQXlCakIsMEJBQTBCQyxpQ0FBbUJBO1FBRzlFLElBQUl3QyxjQUFjeEMsaUNBQW1CQSxDQUFDO1FBQ3RDLElBQUk0Yix3QkFBd0I1YixpQ0FBbUJBLENBQUM7UUFDaEQsSUFBSThpQixhQUFhOWlCLGlDQUFtQkEsQ0FBQztRQUVyQyxJQUFJd2pCLHVCQUF1Qm5aLFlBQVloRyxTQUFTO1FBRWhELDBDQUEwQztRQUMxQyxrRUFBa0U7UUFDbEUsSUFBSTdCLGVBQWUsQ0FBRSxlQUFjZ2hCLG9CQUFtQixHQUFJO1lBQ3hENUgsc0JBQXNCNEgsc0JBQXNCLFlBQVk7Z0JBQ3REdmYsY0FBYztnQkFDZGpCLEtBQUssU0FBU2dqQjtvQkFDWixPQUFPbEQsV0FBVyxJQUFJO2dCQUN4QjtZQUNGO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQzloQix5QkFBeUJqQiwwQkFBMEJDLGlDQUFtQkE7UUFHOUUsSUFBSWlCLElBQUlqQixpQ0FBbUJBLENBQUM7UUFDNUIsSUFBSWtGLGNBQWFsRixpQ0FBbUJBLENBQUM7UUFDckMsSUFBSWdqQixjQUFjaGpCLGlDQUFtQkEsQ0FBQztRQUN0QyxJQUFJbUYsZUFBZW5GLGlDQUFtQkEsQ0FBQztRQUV2QyxJQUFJc0YsY0FBYUosWUFBV0ksVUFBVTtRQUV0QyxJQUFJQyxzQ0FBc0MsQ0FBQ0QsZUFBYyxDQUFDQSxZQUFXakIsU0FBUyxDQUFDNGhCLGFBQWEsSUFBSSxDQUFDO1lBQy9GLElBQUkxa0IsU0FBUyxJQUFJK0QsWUFBVztnQkFBQztnQkFBSztnQkFBSztnQkFBSztnQkFBSzthQUFJO1lBQ3JELElBQUk7Z0JBQ0YvRCxPQUFPMGtCLGFBQWEsQ0FBQyxJQUFJO2dCQUN6QjtZQUNGLEVBQUUsT0FBT3BrQixPQUFPLENBQWM7WUFDOUIsaURBQWlEO1lBQ2pELElBQUk7Z0JBQ0ZOLE9BQU8wa0IsYUFBYSxDQUFDO2dCQUNyQjtZQUNGLEVBQUUsT0FBT3BrQixPQUFPLENBQWM7WUFDOUIsSUFBSTtnQkFDRk4sT0FBTzBrQixhQUFhLENBQUM7WUFDdkIsRUFBRSxPQUFPcGtCLE9BQU87Z0JBQ2QsT0FBT04sTUFBTSxDQUFDLEVBQUUsS0FBSyxNQUFNQSxNQUFNLENBQUMsRUFBRSxLQUFLLE1BQU1BLE1BQU0sQ0FBQyxFQUFFLEtBQUssTUFBTUEsTUFBTSxDQUFDLEVBQUUsS0FBSyxPQUFPQSxNQUFNLENBQUMsRUFBRSxLQUFLO1lBQ3hHO1FBQ0Y7UUFFQSw4Q0FBOEM7UUFDOUMsc0RBQXNEO1FBQ3RELElBQUkrRCxhQUFZckUsRUFBRTtZQUFFTSxRQUFRO1lBQWNDLE9BQU87WUFBTUUsUUFBUTZEO1FBQW9DLEdBQUc7WUFDcEcwZ0IsZUFBZSxTQUFTQSxjQUFjclosT0FBTyxhQUFhLEdBQWQ7Z0JBQzFDekgsYUFBYSxJQUFJO2dCQUVqQixJQUFJL0MsU0FBUzRnQixZQUFZcFcsUUFBUTlMLFVBQVVDLE1BQU0sR0FBRyxJQUFJRCxTQUFTLENBQUMsRUFBRSxHQUFHd0QsV0FBVyxJQUFJLEVBQUUsSUFBSSxDQUFDdkQsTUFBTTtnQkFFbkcsT0FBTztvQkFBRWtNLE1BQU03SyxPQUFPNkssSUFBSTtvQkFBRUMsU0FBUzlLLE9BQU84SyxPQUFPO2dCQUFDO1lBQ3REO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3BOLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJd0MsY0FBY3hDLGlDQUFtQkEsQ0FBQztRQUN0QyxJQUFJa2UsdUJBQXVCbGUsaUNBQW1CQSxDQUFDO1FBQy9DLElBQUltZSwyQkFBMkJuZSxpQ0FBbUJBLENBQUM7UUFFbkRGLE9BQU9JLE9BQU8sR0FBR3NDLGNBQWMsU0FBVXlKLE1BQU0sRUFBRUUsR0FBRyxFQUFFbkssS0FBSztZQUN6RCxPQUFPa2MscUJBQXFCaFQsQ0FBQyxDQUFDZSxRQUFRRSxLQUFLZ1MseUJBQXlCLEdBQUduYztRQUN6RSxJQUFJLFNBQVVpSyxNQUFNLEVBQUVFLEdBQUcsRUFBRW5LLEtBQUs7WUFDOUJpSyxNQUFNLENBQUNFLElBQUksR0FBR25LO1lBQ2QsT0FBT2lLO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ25NLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJcUMsY0FBY3JDLGlDQUFtQkEsQ0FBQztRQUN0QyxJQUFJSyxZQUFZTCxpQ0FBbUJBLENBQUM7UUFFcENGLE9BQU9JLE9BQU8sR0FBRyxTQUFVK0wsTUFBTSxFQUFFRSxHQUFHLEVBQUUvRSxNQUFNO1lBQzVDLElBQUk7Z0JBQ0YseUVBQXlFO2dCQUN6RSxPQUFPL0UsWUFBWWhDLFVBQVUrQyxPQUFPeUIsd0JBQXdCLENBQUNvSCxRQUFRRSxJQUFJLENBQUMvRSxPQUFPO1lBQ25GLEVBQUUsT0FBT3ZGLE9BQU8sQ0FBYztRQUNoQztJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDYix5QkFBeUJkLFNBQVNGLGlDQUFtQkE7UUFHN0QsSUFBSXdDLGNBQWN4QyxpQ0FBbUJBLENBQUM7UUFDdEMsSUFBSXVlLDBCQUEwQnZlLGlDQUFtQkEsQ0FBQztRQUNsRCxJQUFJa2UsdUJBQXVCbGUsaUNBQW1CQSxDQUFDO1FBQy9DLElBQUlNLFdBQVdOLGlDQUFtQkEsQ0FBQztRQUNuQyxJQUFJOEwsa0JBQWtCOUwsaUNBQW1CQSxDQUFDO1FBQzFDLElBQUlrbUIsYUFBYWxtQixpQ0FBbUJBLENBQUM7UUFFckMsbUNBQW1DO1FBQ25DLHVEQUF1RDtRQUN2RCxpRUFBaUU7UUFDakVFLFFBQVFnTCxDQUFDLEdBQUcxSSxlQUFlLENBQUMrYiwwQkFBMEJuYixPQUFPK2lCLGdCQUFnQixHQUFHLFNBQVNBLGlCQUFpQjNkLENBQUMsRUFBRTRHLFVBQVU7WUFDckg5TyxTQUFTa0k7WUFDVCxJQUFJNGQsUUFBUXRhLGdCQUFnQnNEO1lBQzVCLElBQUk3RyxPQUFPMmQsV0FBVzlXO1lBQ3RCLElBQUlyTyxTQUFTd0gsS0FBS3hILE1BQU07WUFDeEIsSUFBSXVQLFFBQVE7WUFDWixJQUFJbkU7WUFDSixNQUFPcEwsU0FBU3VQLE1BQU80TixxQkFBcUJoVCxDQUFDLENBQUMxQyxHQUFHMkQsTUFBTTVELElBQUksQ0FBQytILFFBQVEsRUFBRThWLEtBQUssQ0FBQ2phLElBQUk7WUFDaEYsT0FBTzNEO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQzFJO1FBR1IsSUFBSW1ELFVBQVVDO1FBRWRwRCxPQUFPSSxPQUFPLEdBQUcsU0FBVVMsUUFBUTtZQUNqQyxJQUFJO2dCQUNGLE9BQU9zQyxRQUFRdEM7WUFDakIsRUFBRSxPQUFPa0IsT0FBTztnQkFDZCxPQUFPO1lBQ1Q7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDL0I7UUFHUixJQUFJVyxhQUFhQztRQUNqQixJQUFJK1MsbUJBQW1CLGtCQUFrQixrQ0FBa0M7UUFFM0UzVCxPQUFPSSxPQUFPLEdBQUcsU0FBVUMsRUFBRTtZQUMzQixJQUFJQSxLQUFLc1Qsa0JBQWtCLE1BQU1oVCxXQUFXO1lBQzVDLE9BQU9OO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ0wsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlDLGFBQWFELGlDQUFtQkEsQ0FBQztRQUNyQyxJQUFJa2UsdUJBQXVCbGUsaUNBQW1CQSxDQUFDO1FBQy9DLElBQUk0RCxjQUFjNUQsaUNBQW1CQSxDQUFDO1FBQ3RDLElBQUl3bEIsdUJBQXVCeGxCLGlDQUFtQkEsQ0FBQztRQUUvQ0YsT0FBT0ksT0FBTyxHQUFHLFNBQVVzSSxDQUFDLEVBQUUyRCxHQUFHLEVBQUVuSyxLQUFLLEVBQUU4QixPQUFPO1lBQy9DLElBQUksQ0FBQ0EsU0FBU0EsVUFBVSxDQUFDO1lBQ3pCLElBQUl1aUIsU0FBU3ZpQixRQUFRMlgsVUFBVTtZQUMvQixJQUFJNVgsT0FBT0MsUUFBUUQsSUFBSSxLQUFLUyxZQUFZUixRQUFRRCxJQUFJLEdBQUdzSTtZQUN2RCxJQUFJbE0sV0FBVytCLFFBQVE0QixZQUFZNUIsT0FBTzZCLE1BQU1DO1lBQ2hELElBQUlBLFFBQVF5VyxNQUFNLEVBQUU7Z0JBQ2xCLElBQUk4TCxRQUFRN2QsQ0FBQyxDQUFDMkQsSUFBSSxHQUFHbks7cUJBQ2hCd2pCLHFCQUFxQnJaLEtBQUtuSztZQUNqQyxPQUFPO2dCQUNMLElBQUk7b0JBQ0YsSUFBSSxDQUFDOEIsUUFBUTRYLE1BQU0sRUFBRSxPQUFPbFQsQ0FBQyxDQUFDMkQsSUFBSTt5QkFDN0IsSUFBSTNELENBQUMsQ0FBQzJELElBQUksRUFBRWthLFNBQVM7Z0JBQzVCLEVBQUUsT0FBT3hrQixPQUFPLENBQWM7Z0JBQzlCLElBQUl3a0IsUUFBUTdkLENBQUMsQ0FBQzJELElBQUksR0FBR25LO3FCQUNoQmtjLHFCQUFxQmhULENBQUMsQ0FBQzFDLEdBQUcyRCxLQUFLO29CQUNsQ25LLE9BQU9BO29CQUNQeVosWUFBWTtvQkFDWnhYLGNBQWMsQ0FBQ0gsUUFBUXdpQixlQUFlO29CQUN0Q2xpQixVQUFVLENBQUNOLFFBQVF5aUIsV0FBVztnQkFDaEM7WUFDRjtZQUFFLE9BQU8vZDtRQUNYO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUMxSSxRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSXdtQix3QkFBd0J4bUIsaUNBQW1CQSxDQUFDO1FBQ2hELElBQUlDLGFBQWFELGlDQUFtQkEsQ0FBQztRQUNyQyxJQUFJeW1CLGFBQWF6bUIsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUlrSSxrQkFBa0JsSSxpQ0FBbUJBLENBQUM7UUFFMUMsSUFBSXFNLGdCQUFnQm5FLGdCQUFnQjtRQUNwQyxJQUFJTCxVQUFVekU7UUFFZCxpQkFBaUI7UUFDakIsSUFBSXNqQixvQkFBb0JELFdBQVc7WUFBYyxPQUFPM2xCO1FBQVcsU0FBUztRQUU1RSwrQ0FBK0M7UUFDL0MsSUFBSTZsQixTQUFTLFNBQVV4bUIsRUFBRSxFQUFFZ00sR0FBRztZQUM1QixJQUFJO2dCQUNGLE9BQU9oTSxFQUFFLENBQUNnTSxJQUFJO1lBQ2hCLEVBQUUsT0FBT3RLLE9BQU8sQ0FBYztRQUNoQztRQUVBLG9EQUFvRDtRQUNwRC9CLE9BQU9JLE9BQU8sR0FBR3NtQix3QkFBd0JDLGFBQWEsU0FBVXRtQixFQUFFO1lBQ2hFLElBQUlxSSxHQUFHb2UsS0FBS3hrQjtZQUNaLE9BQU9qQyxPQUFPbUUsWUFBWSxjQUFjbkUsT0FBTyxPQUFPLFNBRWxELE9BQVF5bUIsQ0FBQUEsTUFBTUQsT0FBT25lLElBQUlYLFFBQVExSCxLQUFLa00sY0FBYSxLQUFNLFdBQVd1YSxNQUVwRUYsb0JBQW9CRCxXQUFXamUsS0FFL0IsQ0FBQ3BHLFNBQVNxa0IsV0FBV2plLEVBQUMsTUFBTyxZQUFZdkksV0FBV3VJLEVBQUVxZSxNQUFNLElBQUksY0FBY3prQjtRQUNwRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDdEMsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUk2a0IsY0FBYzdrQixpQ0FBbUJBLENBQUM7UUFDdEMsSUFBSXlRLFdBQVd6USxpQ0FBbUJBLENBQUM7UUFFbkMscUNBQXFDO1FBQ3JDLDZDQUE2QztRQUM3Q0YsT0FBT0ksT0FBTyxHQUFHLFNBQVVTLFFBQVE7WUFDakMsSUFBSXdMLE1BQU0wWSxZQUFZbGtCLFVBQVU7WUFDaEMsT0FBTzhQLFNBQVN0RSxPQUFPQSxNQUFNQSxNQUFNO1FBQ3JDO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNyTTtRQUdSQSxPQUFPSSxPQUFPLEdBQUcsU0FBVTRtQixNQUFNLEVBQUU5a0IsS0FBSztZQUN0QyxPQUFPO2dCQUNMeVosWUFBWSxDQUFFcUwsQ0FBQUEsU0FBUztnQkFDdkI3aUIsY0FBYyxDQUFFNmlCLENBQUFBLFNBQVM7Z0JBQ3pCMWlCLFVBQVUsQ0FBRTBpQixDQUFBQSxTQUFTO2dCQUNyQjlrQixPQUFPQTtZQUNUO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2xDLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCx1REFBdUQsR0FDdkQsSUFBSSttQixnQkFBZ0IvbUIsaUNBQW1CQSxDQUFDO1FBRXhDRixPQUFPSSxPQUFPLEdBQUc2bUIsaUJBQ2YsQ0FBQ2pOLE9BQU9DLElBQUksSUFDWixPQUFPRCxPQUFPaFUsUUFBUSxJQUFJO0lBRzVCLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDaEcsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlxQyxjQUFjckMsaUNBQW1CQSxDQUFDO1FBQ3RDLElBQUlzQyxRQUFRdEMsaUNBQW1CQSxDQUFDO1FBQ2hDLElBQUlnSCxVQUFVaEgsaUNBQW1CQSxDQUFDO1FBRWxDLElBQUk2SCxVQUFVekU7UUFDZCxJQUFJTyxRQUFRdEIsWUFBWSxHQUFHc0IsS0FBSztRQUVoQyxvRUFBb0U7UUFDcEU3RCxPQUFPSSxPQUFPLEdBQUdvQyxNQUFNO1lBQ3JCLDRFQUE0RTtZQUM1RSx5REFBeUQ7WUFDekQsT0FBTyxDQUFDdUYsUUFBUSxLQUFLbWYsb0JBQW9CLENBQUM7UUFDNUMsS0FBSyxTQUFVN21CLEVBQUU7WUFDZixPQUFPNkcsUUFBUTdHLFFBQVEsV0FBV3dELE1BQU14RCxJQUFJLE1BQU0wSCxRQUFRMUg7UUFDNUQsSUFBSTBIO0lBR0osR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUMvSCxRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSXVKLE1BQU92SixpQ0FBbUJBLENBQUMsTUFBTXVKLEdBQUc7UUFFeEMsZ0RBQWdEO1FBQ2hEekosT0FBT0ksT0FBTyxHQUFHLFNBQVVDLEVBQUU7WUFDM0JvSixJQUFJcEo7WUFDSixPQUFPQTtRQUNUO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNhLHlCQUF5QmQsU0FBU0YsaUNBQW1CQTtRQUc3RCxJQUFJd0MsY0FBY3hDLGlDQUFtQkEsQ0FBQztRQUN0QyxJQUFJSSxPQUFPSixpQ0FBbUJBLENBQUM7UUFDL0IsSUFBSWluQiw2QkFBNkJqbkIsaUNBQW1CQSxDQUFDO1FBQ3JELElBQUltZSwyQkFBMkJuZSxpQ0FBbUJBLENBQUM7UUFDbkQsSUFBSThMLGtCQUFrQjlMLGlDQUFtQkEsQ0FBQztRQUMxQyxJQUFJd2UsZ0JBQWdCeGUsaUNBQW1CQSxDQUFDO1FBQ3hDLElBQUl1QyxTQUFTdkMsaUNBQW1CQSxDQUFDO1FBQ2pDLElBQUlzZSxpQkFBaUJ0ZSxpQ0FBbUJBLENBQUM7UUFFekMseUVBQXlFO1FBQ3pFLElBQUkwZSw0QkFBNEJ0YixPQUFPeUIsd0JBQXdCO1FBRS9ELDJDQUEyQztRQUMzQywrREFBK0Q7UUFDL0QzRSxRQUFRZ0wsQ0FBQyxHQUFHMUksY0FBY2tjLDRCQUE0QixTQUFTN1oseUJBQXlCMkQsQ0FBQyxFQUFFcVcsQ0FBQztZQUMxRnJXLElBQUlzRCxnQkFBZ0J0RDtZQUNwQnFXLElBQUlMLGNBQWNLO1lBQ2xCLElBQUlQLGdCQUFnQixJQUFJO2dCQUN0QixPQUFPSSwwQkFBMEJsVyxHQUFHcVc7WUFDdEMsRUFBRSxPQUFPaGQsT0FBTyxDQUFjO1lBQzlCLElBQUlVLE9BQU9pRyxHQUFHcVcsSUFBSSxPQUFPVix5QkFBeUIsQ0FBQy9kLEtBQUs2bUIsMkJBQTJCL2IsQ0FBQyxFQUFFMUMsR0FBR3FXLElBQUlyVyxDQUFDLENBQUNxVyxFQUFFO1FBQ25HO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUMvZSxRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSWtGLGNBQWFsRixpQ0FBbUJBLENBQUM7UUFDckMsSUFBSXlTLHNCQUFzQnpTLGlDQUFtQkEsQ0FBQztRQUM5QyxJQUFJZ0gsVUFBVWhILGlDQUFtQkEsQ0FBQztRQUVsQyxJQUFJcUssZUFBY25GLFlBQVdtRixXQUFXO1FBQ3hDLElBQUkzSixhQUFZd0UsWUFBV3hFLFNBQVM7UUFFcEMsV0FBVztRQUNYLDJEQUEyRDtRQUMzRCxvRUFBb0U7UUFDcEVaLE9BQU9JLE9BQU8sR0FBR21LLGdCQUFlb0ksb0JBQW9CcEksYUFBWWhHLFNBQVMsRUFBRSxjQUFjLFVBQVUsU0FBVW1FLENBQUM7WUFDNUcsSUFBSXhCLFFBQVF3QixPQUFPLGVBQWUsTUFBTSxJQUFJOUgsV0FBVTtZQUN0RCxPQUFPOEgsRUFBRWdDLFVBQVU7UUFDckI7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQzFLLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJc0MsUUFBUXRDLGlDQUFtQkEsQ0FBQztRQUNoQyxJQUFJa0ksa0JBQWtCbEksaUNBQW1CQSxDQUFDO1FBQzFDLElBQUl3QyxjQUFjeEMsaUNBQW1CQSxDQUFDO1FBQ3RDLElBQUlvRyxVQUFVcEcsaUNBQW1CQSxDQUFDO1FBRWxDLElBQUltSSxXQUFXRCxnQkFBZ0I7UUFFL0JwSSxPQUFPSSxPQUFPLEdBQUcsQ0FBQ29DLE1BQU07WUFDdEIsOEVBQThFO1lBQzlFLElBQUlvaUIsTUFBTSxJQUFJRixJQUFJLGlCQUFpQjtZQUNuQyxJQUFJeEosU0FBUzBKLElBQUl3QyxZQUFZO1lBQzdCLElBQUlDLFVBQVUsSUFBSXhNLGdCQUFnQjtZQUNsQyxJQUFJdlksU0FBUztZQUNic2lCLElBQUkwQyxRQUFRLEdBQUc7WUFDZnBNLE9BQU9ELE9BQU8sQ0FBQyxTQUFVL1ksS0FBSyxFQUFFbUssR0FBRztnQkFDakM2TyxNQUFNLENBQUMsU0FBUyxDQUFDO2dCQUNqQjVZLFVBQVUrSixNQUFNbks7WUFDbEI7WUFDQW1sQixPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUs7WUFDdkIseUNBQXlDO1lBQ3pDLHdEQUF3RDtZQUN4REEsT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLN2lCO1lBQ3ZCLE9BQU8sV0FBYSxFQUFDb2dCLElBQUkyQyxNQUFNLElBQUksQ0FBQ0YsUUFBUTVkLEdBQUcsQ0FBQyxLQUFLLE1BQU00ZCxRQUFRNWQsR0FBRyxDQUFDLEtBQUssTUFBTSxDQUFDNGQsUUFBUTVkLEdBQUcsQ0FBQyxLQUFLakYsY0FBYzZpQixRQUFRNWQsR0FBRyxDQUFDLElBQUcsS0FDM0gsQ0FBQ3lSLE9BQU9qRixJQUFJLElBQUszUCxDQUFBQSxXQUFXLENBQUM1RCxXQUFVLEtBQ3hDLENBQUN3WSxPQUFPc00sSUFBSSxJQUNaNUMsSUFBSTZDLElBQUksS0FBSyw2QkFDYnZNLE9BQU9oWSxHQUFHLENBQUMsU0FBUyxPQUNwQkUsT0FBTyxJQUFJeVgsZ0JBQWdCLGFBQWEsU0FDeEMsQ0FBQ0ssTUFBTSxDQUFDN1MsU0FBUyxJQUVqQixJQUFJcWMsSUFBSSxlQUFlZ0QsUUFBUSxLQUFLLE9BQ3BDLElBQUk3TSxnQkFBZ0IsSUFBSUEsZ0JBQWdCLFFBQVEzWCxHQUFHLENBQUMsU0FBUyxPQUU3RCxJQUFJd2hCLElBQUksZ0JBQWdCaUQsSUFBSSxLQUFLLGdCQUVqQyxJQUFJakQsSUFBSSxlQUFla0QsSUFBSSxLQUFLLGFBRWhDdGxCLFdBQVcsVUFFWCxJQUFJb2lCLElBQUksYUFBYWxnQixXQUFXbWpCLElBQUksS0FBSztRQUNoRDtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDM25CLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJeW1CLGFBQWF6bUIsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUlxQyxjQUFjckMsaUNBQW1CQSxDQUFDO1FBRXRDRixPQUFPSSxPQUFPLEdBQUcsU0FBVTBGLEVBQUU7WUFDM0IsZUFBZTtZQUNmLG9EQUFvRDtZQUNwRCxvREFBb0Q7WUFDcEQsSUFBSTZnQixXQUFXN2dCLFFBQVEsWUFBWSxPQUFPdkQsWUFBWXVEO1FBQ3hEO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUM1RSx5QkFBeUJqQiwwQkFBMEJDLGlDQUFtQkE7UUFHOUUsSUFBSXdhLGdCQUFnQnhhLGlDQUFtQkEsQ0FBQztRQUN4QyxJQUFJcUMsY0FBY3JDLGlDQUFtQkEsQ0FBQztRQUN0QyxJQUFJMEUsV0FBVzFFLGlDQUFtQkEsQ0FBQztRQUNuQyxJQUFJeWEsMEJBQTBCemEsaUNBQW1CQSxDQUFDO1FBRWxELElBQUkwYSxtQkFBbUJDO1FBQ3ZCLElBQUlDLDJCQUEyQkYsaUJBQWlCclcsU0FBUztRQUN6RCxJQUFJc2pCLFNBQVN0bEIsWUFBWXVZLHlCQUF5QitNLE1BQU07UUFDeEQsSUFBSUMsT0FBT3ZsQixZQUFZdVkseUJBQXlCclIsR0FBRztRQUNuRCxJQUFJeVIsU0FBUyxJQUFJTixpQkFBaUI7UUFFbEMseUNBQXlDO1FBQ3pDLHdEQUF3RDtRQUN4RCxJQUFJTSxPQUFPelIsR0FBRyxDQUFDLEtBQUssTUFBTSxDQUFDeVIsT0FBT3pSLEdBQUcsQ0FBQyxLQUFLakYsWUFBWTtZQUNyRGtXLGNBQWNJLDBCQUEwQixPQUFPLFNBQVNyUixJQUFJMUYsS0FBSyxXQUFXLEdBQVo7Z0JBQzlELElBQUk5QyxTQUFTRCxVQUFVQyxNQUFNO2dCQUM3QixJQUFJa2EsU0FBU2xhLFNBQVMsSUFBSXVELFlBQVl4RCxTQUFTLENBQUMsRUFBRTtnQkFDbEQsSUFBSUMsVUFBVWthLFdBQVczVyxXQUFXLE9BQU9zakIsS0FBSyxJQUFJLEVBQUUvakI7Z0JBQ3RELElBQUlna0IsU0FBU0YsT0FBTyxJQUFJLEVBQUU5akIsT0FBTyx3QkFBd0I7Z0JBQ3pENFcsd0JBQXdCMVosUUFBUTtnQkFDaEMsSUFBSWlCLFFBQVEwQyxTQUFTdVc7Z0JBQ3JCLElBQUkzSyxRQUFRO2dCQUNaLE1BQU9BLFFBQVF1WCxPQUFPOW1CLE1BQU0sQ0FBRTtvQkFDNUIsSUFBSThtQixNQUFNLENBQUN2WCxRQUFRLEtBQUt0TyxPQUFPLE9BQU87Z0JBQ3hDO2dCQUFFLE9BQU87WUFDWCxHQUFHO2dCQUFFeVosWUFBWTtnQkFBTUMsUUFBUTtZQUFLO1FBQ3RDO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUMxYSx5QkFBeUJqQiwwQkFBMEJDLGlDQUFtQkE7UUFHOUUsSUFBSWlCLElBQUlqQixpQ0FBbUJBLENBQUM7UUFDNUIsSUFBSUksT0FBT0osaUNBQW1CQSxDQUFDO1FBQy9CLElBQUlrQixVQUFVbEIsaUNBQW1CQSxDQUFDO1FBQ2xDLElBQUlLLFlBQVlMLGlDQUFtQkEsQ0FBQztRQUNwQyxJQUFJTSxXQUFXTixpQ0FBbUJBLENBQUM7UUFDbkMsSUFBSW1CLG9CQUFvQm5CLGlDQUFtQkEsQ0FBQztRQUM1QyxJQUFJb0IsZ0JBQWdCcEIsaUNBQW1CQSxDQUFDO1FBQ3hDLElBQUlxQiwyQ0FBMkNyQixpQ0FBbUJBLENBQUM7UUFFbkUsSUFBSThuQixvQ0FBb0N6bUIseUNBQXlDLFdBQVdYO1FBRTVGLHNDQUFzQztRQUN0QywwREFBMEQ7UUFDMURPLEVBQUU7WUFBRU0sUUFBUTtZQUFZQyxPQUFPO1lBQU1DLE1BQU07WUFBTUMsUUFBUW9tQjtRQUFrQyxHQUFHO1lBQzVGL00sU0FBUyxTQUFTQSxRQUFRblYsRUFBRTtnQkFDMUJ0RixTQUFTLElBQUk7Z0JBQ2IsSUFBSTtvQkFDRkQsVUFBVXVGO2dCQUNaLEVBQUUsT0FBTy9ELE9BQU87b0JBQ2RULGNBQWMsSUFBSSxFQUFFLFNBQVNTO2dCQUMvQjtnQkFFQSxJQUFJaW1CLG1DQUFtQyxPQUFPMW5CLEtBQUswbkIsbUNBQW1DLElBQUksRUFBRWxpQjtnQkFFNUYsSUFBSTlELFNBQVNYLGtCQUFrQixJQUFJO2dCQUNuQyxJQUFJWSxVQUFVO2dCQUNkYixRQUFRWSxRQUFRLFNBQVVFLEtBQUs7b0JBQzdCNEQsR0FBRzVELE9BQU9EO2dCQUNaLEdBQUc7b0JBQUVHLFdBQVc7Z0JBQUs7WUFDdkI7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDcEMsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlvRyxVQUFVcEcsaUNBQW1CQSxDQUFDO1FBQ2xDLElBQUlrRixjQUFhbEYsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUl3bEIsdUJBQXVCeGxCLGlDQUFtQkEsQ0FBQztRQUUvQyxJQUFJK25CLFNBQVM7UUFDYixJQUFJcGUsUUFBUTdKLE9BQU9JLE9BQU8sR0FBR2dGLFdBQVUsQ0FBQzZpQixPQUFPLElBQUl2QyxxQkFBcUJ1QyxRQUFRLENBQUM7UUFFaEZwZSxDQUFBQSxNQUFNcWUsUUFBUSxJQUFLcmUsQ0FBQUEsTUFBTXFlLFFBQVEsR0FBRyxFQUFFLEdBQUdoYyxJQUFJLENBQUM7WUFDN0NvTSxTQUFTO1lBQ1Q2UCxNQUFNN2hCLFVBQVUsU0FBUztZQUN6QjhoQixXQUFXO1lBQ1hDLFNBQVM7WUFDVDNqQixRQUFRO1FBQ1Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3hELHlCQUF5QmpCLDBCQUEwQkMsaUNBQW1CQTtRQUc5RSxJQUFJaUIsSUFBSWpCLGlDQUFtQkEsQ0FBQztRQUM1QixJQUFJb1csYUFBYXBXLGlDQUFtQkEsQ0FBQztRQUNyQyxJQUFJc0MsUUFBUXRDLGlDQUFtQkEsQ0FBQztRQUNoQyxJQUFJd0wseUJBQXlCeEwsaUNBQW1CQSxDQUFDO1FBRWpELElBQUlvb0IsOEJBQThCLENBQUM1Yyx1QkFBdUIsY0FBYyxTQUFVcEosTUFBTTtZQUN0RixPQUFPQSxPQUFPMlQsSUFBSSxLQUFLO1FBQ3pCO1FBRUEsSUFBSXZQLFNBQVM0aEIsK0JBQStCOWxCLE1BQU07WUFDaEQsaURBQWlEO1lBQ2pELElBQUkrbEIsVUFBVTtnQkFDWnRTLE1BQU07Z0JBQ054TSxLQUFLO29CQUFjLE9BQU87Z0JBQU07Z0JBQ2hDaEIsTUFBTTtvQkFDSixJQUFJK0gsUUFBUTtvQkFDWixPQUFPO3dCQUNMdkssTUFBTTs0QkFDSixJQUFJRSxPQUFPcUssVUFBVTs0QkFDckIsSUFBSWdZLFFBQVEvZSxHQUFHLENBQUMsSUFBSStlLFFBQVFDLEtBQUs7NEJBQ2pDLE9BQU87Z0NBQUV0aUIsTUFBTUE7Z0NBQU1qRSxPQUFPOzRCQUFFO3dCQUNoQztvQkFDRjtnQkFDRjtZQUNGO1lBQ0EsZ0RBQWdEO1lBQ2hELElBQUlzbUIsVUFBVSxJQUFJdlAsSUFBSTtnQkFBQztnQkFBRztnQkFBRztnQkFBRzthQUFFO1lBQ2xDLHFFQUFxRTtZQUNyRSxPQUFPdVAsUUFBUWxTLFVBQVUsQ0FBQ2lTLFNBQVN0UyxJQUFJLEtBQUs7UUFDOUM7UUFFQSxvQ0FBb0M7UUFDcEMsd0RBQXdEO1FBQ3hEOVUsRUFBRTtZQUFFTSxRQUFRO1lBQU9DLE9BQU87WUFBTUMsTUFBTTtZQUFNQyxRQUFROEU7UUFBTyxHQUFHO1lBQzVENFAsWUFBWUE7UUFDZDtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDdFcsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlzQyxRQUFRdEMsaUNBQW1CQSxDQUFDO1FBQ2hDLElBQUlDLGFBQWFELGlDQUFtQkEsQ0FBQztRQUNyQyxJQUFJK0ksV0FBVy9JLGlDQUFtQkEsQ0FBQztRQUNuQyxJQUFJbVAsU0FBU25QLGlDQUFtQkEsQ0FBQztRQUNqQyxJQUFJdU0saUJBQWlCdk0saUNBQW1CQSxDQUFDO1FBQ3pDLElBQUl3YSxnQkFBZ0J4YSxpQ0FBbUJBLENBQUM7UUFDeEMsSUFBSWtJLGtCQUFrQmxJLGlDQUFtQkEsQ0FBQztRQUMxQyxJQUFJb0csVUFBVXBHLGlDQUFtQkEsQ0FBQztRQUVsQyxJQUFJbUksV0FBV0QsZ0JBQWdCO1FBQy9CLElBQUlzZ0IseUJBQXlCO1FBRTdCLCtCQUErQjtRQUMvQiwwREFBMEQ7UUFDMUQsSUFBSXJPLG1CQUFtQnNPLG1DQUFtQ0M7UUFFMUQscURBQXFELEdBQ3JELElBQUksRUFBRSxDQUFDbmdCLElBQUksRUFBRTtZQUNYbWdCLGdCQUFnQixFQUFFLENBQUNuZ0IsSUFBSTtZQUN2QiwwQ0FBMEM7WUFDMUMsSUFBSSxDQUFFLFdBQVVtZ0IsYUFBWSxHQUFJRix5QkFBeUI7aUJBQ3BEO2dCQUNIQyxvQ0FBb0NsYyxlQUFlQSxlQUFlbWM7Z0JBQ2xFLElBQUlELHNDQUFzQ3JsQixPQUFPaUIsU0FBUyxFQUFFOFYsb0JBQW9Cc087WUFDbEY7UUFDRjtRQUVBLElBQUlFLHlCQUF5QixDQUFDNWYsU0FBU29SLHNCQUFzQjdYLE1BQU07WUFDakUsSUFBSXVFLE9BQU8sQ0FBQztZQUNaLDhCQUE4QjtZQUM5QixPQUFPc1QsaUJBQWlCLENBQUNoUyxTQUFTLENBQUMvSCxJQUFJLENBQUN5RyxVQUFVQTtRQUNwRDtRQUVBLElBQUk4aEIsd0JBQXdCeE8sb0JBQW9CLENBQUM7YUFDNUMsSUFBSS9ULFNBQVMrVCxvQkFBb0JoTCxPQUFPZ0w7UUFFN0MsNkNBQTZDO1FBQzdDLDhEQUE4RDtRQUM5RCxJQUFJLENBQUNsYSxXQUFXa2EsaUJBQWlCLENBQUNoUyxTQUFTLEdBQUc7WUFDNUNxUyxjQUFjTCxtQkFBbUJoUyxVQUFVO2dCQUN6QyxPQUFPLElBQUk7WUFDYjtRQUNGO1FBRUFySSxPQUFPSSxPQUFPLEdBQUc7WUFDZmlhLG1CQUFtQkE7WUFDbkJxTyx3QkFBd0JBO1FBQzFCO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUMxb0IsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlxQyxjQUFjckMsaUNBQW1CQSxDQUFDO1FBRXRDRixPQUFPSSxPQUFPLEdBQUdtQyxZQUFZLEVBQUUsQ0FBQ2lCLEtBQUs7SUFHckMsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUN4RCxRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSWlYLHNCQUFzQmpYLGlDQUFtQkEsQ0FBQztRQUM5QyxJQUFJc2xCLFdBQVd0bEIsaUNBQW1CQSxDQUFDO1FBRW5DLElBQUlnVCxjQUFjQztRQUVsQiwrQkFBK0I7UUFDL0IsdUNBQXVDO1FBQ3ZDblQsT0FBT0ksT0FBTyxHQUFHLFNBQVVDLEVBQUU7WUFDM0IsSUFBSUEsT0FBT21FLFdBQVcsT0FBTztZQUM3QixJQUFJeUYsU0FBU2tOLG9CQUFvQjlXO1lBQ2pDLElBQUlZLFNBQVN1a0IsU0FBU3ZiO1lBQ3RCLElBQUlBLFdBQVdoSixRQUFRLE1BQU0sSUFBSWlTLFlBQVk7WUFDN0MsT0FBT2pTO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2pCLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJdUMsU0FBU3ZDLGlDQUFtQkEsQ0FBQztRQUNqQyxJQUFJNmlCLFVBQVU3aUIsaUNBQW1CQSxDQUFDO1FBQ2xDLElBQUk0b0IsaUNBQWlDNW9CLGlDQUFtQkEsQ0FBQztRQUN6RCxJQUFJa2UsdUJBQXVCbGUsaUNBQW1CQSxDQUFDO1FBRS9DRixPQUFPSSxPQUFPLEdBQUcsU0FBVXFCLE1BQU0sRUFBRWlELE1BQU0sRUFBRXFrQixVQUFVO1lBQ25ELElBQUl0Z0IsT0FBT3NhLFFBQVFyZTtZQUNuQixJQUFJckIsaUJBQWlCK2EscUJBQXFCaFQsQ0FBQztZQUMzQyxJQUFJckcsMkJBQTJCK2pCLCtCQUErQjFkLENBQUM7WUFDL0QsSUFBSyxJQUFJeEYsSUFBSSxHQUFHQSxJQUFJNkMsS0FBS3hILE1BQU0sRUFBRTJFLElBQUs7Z0JBQ3BDLElBQUl5RyxNQUFNNUQsSUFBSSxDQUFDN0MsRUFBRTtnQkFDakIsSUFBSSxDQUFDbkQsT0FBT2hCLFFBQVE0SyxRQUFRLENBQUUwYyxDQUFBQSxjQUFjdG1CLE9BQU9zbUIsWUFBWTFjLElBQUcsR0FBSTtvQkFDcEVoSixlQUFlNUIsUUFBUTRLLEtBQUt0SCx5QkFBeUJMLFFBQVEySDtnQkFDL0Q7WUFDRjtRQUNGO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNyTSxRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSWdJLG9CQUFvQmhJLGlDQUFtQkEsQ0FBQztRQUU1QyxJQUFJUyxhQUFhQztRQUVqQiw4Q0FBOEM7UUFDOUMsc0RBQXNEO1FBQ3REWixPQUFPSSxPQUFPLEdBQUcsU0FBVUMsRUFBRTtZQUMzQixJQUFJNkgsa0JBQWtCN0gsS0FBSyxNQUFNLElBQUlNLFdBQVcsMEJBQTBCTjtZQUMxRSxPQUFPQTtRQUNUO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNMLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJa0YsY0FBYWxGLGlDQUFtQkEsQ0FBQztRQUNyQyxJQUFJQyxhQUFhRCxpQ0FBbUJBLENBQUM7UUFFckMsSUFBSThvQixZQUFZLFNBQVVub0IsUUFBUTtZQUNoQyxPQUFPVixXQUFXVSxZQUFZQSxXQUFXMkQ7UUFDM0M7UUFFQXhFLE9BQU9JLE9BQU8sR0FBRyxTQUFVNm9CLFNBQVMsRUFBRTNoQixNQUFNO1lBQzFDLE9BQU90RyxVQUFVQyxNQUFNLEdBQUcsSUFBSStuQixVQUFVNWpCLFdBQVUsQ0FBQzZqQixVQUFVLElBQUk3akIsV0FBVSxDQUFDNmpCLFVBQVUsSUFBSTdqQixXQUFVLENBQUM2akIsVUFBVSxDQUFDM2hCLE9BQU87UUFDekg7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3RIO1FBR1Isc0RBQXNEO1FBQ3REQSxPQUFPSSxPQUFPLEdBQUcsT0FBT21LLGVBQWUsZUFBZSxPQUFPb0wsWUFBWTtJQUd6RSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3pVLHlCQUF5QmpCLDBCQUEwQkMsaUNBQW1CQTtRQUc5RSxJQUFJaUIsSUFBSWpCLGlDQUFtQkEsQ0FBQztRQUM1QixJQUFJZ3BCLFlBQVlocEIsaUNBQW1CQSxDQUFDO1FBRXBDLHVEQUF1RDtRQUN2RCwyRUFBMkU7UUFDM0UsSUFBSWdwQixXQUFXL25CLEVBQUU7WUFBRU0sUUFBUTtZQUFlQyxPQUFPO1FBQUssR0FBRztZQUN2RHluQix1QkFBdUIsU0FBU0E7Z0JBQzlCLE9BQU9ELFVBQVUsSUFBSSxFQUFFbG9CLFVBQVVDLE1BQU0sR0FBR0QsU0FBUyxDQUFDLEVBQUUsR0FBR3dELFdBQVc7WUFDdEU7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDdEQseUJBQXlCakIsMEJBQTBCQyxpQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsaUNBQW1CQSxDQUFDO1FBQzVCLElBQUlzQyxRQUFRdEMsaUNBQW1CQSxDQUFDO1FBQ2hDLElBQUlrcEIsZUFBZWxwQixpQ0FBbUJBLENBQUM7UUFDdkMsSUFBSXdMLHlCQUF5QnhMLGlDQUFtQkEsQ0FBQztRQUVqRCxJQUFJc1AsWUFBWSxDQUFDOUQsdUJBQXVCLGdCQUFnQixTQUFVcEosTUFBTTtZQUN0RSxPQUFPQSxPQUFPMlQsSUFBSSxLQUFLLEtBQUszVCxPQUFPbUgsR0FBRyxDQUFDLE1BQU1uSCxPQUFPbUgsR0FBRyxDQUFDO1FBQzFELE1BQU1qSCxNQUFNO1lBQ1Ysb0dBQW9HO1lBQ3BHLE9BQU9ZLE9BQU80UCxNQUFNcVcsSUFBSSxDQUFDLElBQUlwUSxJQUFJO2dCQUFDO2dCQUFHO2dCQUFHO2FBQUUsRUFBRW1RLFlBQVksQ0FBQyxJQUFJblEsSUFBSTtnQkFBQztnQkFBRzthQUFFLFNBQVM7UUFDbEY7UUFFQSxzQ0FBc0M7UUFDdEMsMERBQTBEO1FBQzFEOVgsRUFBRTtZQUFFTSxRQUFRO1lBQU9DLE9BQU87WUFBTUMsTUFBTTtZQUFNQyxRQUFRNE47UUFBVSxHQUFHO1lBQy9ENFosY0FBY0E7UUFDaEI7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3BwQixRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSWlYLHNCQUFzQmpYLGlDQUFtQkEsQ0FBQztRQUU5QyxJQUFJME0sTUFBTW5GLEtBQUttRixHQUFHO1FBRWxCLGdDQUFnQztRQUNoQyx3Q0FBd0M7UUFDeEM1TSxPQUFPSSxPQUFPLEdBQUcsU0FBVVMsUUFBUTtZQUNqQyxJQUFJb1gsTUFBTWQsb0JBQW9CdFc7WUFDOUIsT0FBT29YLE1BQU0sSUFBSXJMLElBQUlxTCxLQUFLLG9CQUFvQixHQUFHLGtDQUFrQztRQUNyRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDL1cseUJBQXlCakIsMEJBQTBCQyxpQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsaUNBQW1CQSxDQUFDO1FBQzVCLElBQUlncEIsWUFBWWhwQixpQ0FBbUJBLENBQUM7UUFFcEMsMENBQTBDO1FBQzFDLDhEQUE4RDtRQUM5RCxJQUFJZ3BCLFdBQVcvbkIsRUFBRTtZQUFFTSxRQUFRO1lBQWVDLE9BQU87UUFBSyxHQUFHO1lBQ3ZEK0ksVUFBVSxTQUFTQTtnQkFDakIsT0FBT3llLFVBQVUsSUFBSSxFQUFFbG9CLFVBQVVDLE1BQU0sR0FBR0QsU0FBUyxDQUFDLEVBQUUsR0FBR3dELFdBQVc7WUFDdEU7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDdEQseUJBQXlCakIsMEJBQTBCQyxpQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsaUNBQW1CQSxDQUFDO1FBQzVCLElBQUlrRixjQUFhbEYsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUkwZixhQUFhMWYsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUlNLFdBQVdOLGlDQUFtQkEsQ0FBQztRQUNuQyxJQUFJQyxhQUFhRCxpQ0FBbUJBLENBQUM7UUFDckMsSUFBSXVNLGlCQUFpQnZNLGlDQUFtQkEsQ0FBQztRQUN6QyxJQUFJNGIsd0JBQXdCNWIsaUNBQW1CQSxDQUFDO1FBQ2hELElBQUlvcEIsaUJBQWlCcHBCLGlDQUFtQkEsQ0FBQztRQUN6QyxJQUFJc0MsUUFBUXRDLGlDQUFtQkEsQ0FBQztRQUNoQyxJQUFJdUMsU0FBU3ZDLGlDQUFtQkEsQ0FBQztRQUNqQyxJQUFJa0ksa0JBQWtCbEksaUNBQW1CQSxDQUFDO1FBQzFDLElBQUltYSxvQkFBcUJuYSxpQ0FBbUJBLENBQUMsTUFBTW1hLGlCQUFpQjtRQUNwRSxJQUFJM1gsY0FBY3hDLGlDQUFtQkEsQ0FBQztRQUN0QyxJQUFJb0csVUFBVXBHLGlDQUFtQkEsQ0FBQztRQUVsQyxJQUFJcXBCLGNBQWM7UUFDbEIsSUFBSWxoQixXQUFXO1FBQ2YsSUFBSWtFLGdCQUFnQm5FLGdCQUFnQjtRQUVwQyxJQUFJekgsYUFBYUM7UUFDakIsSUFBSTRvQixpQkFBaUJwa0IsV0FBVSxDQUFDaUQsU0FBUztRQUV6QyxtREFBbUQ7UUFDbkQsSUFBSTNCLFNBQVNKLFdBQ1IsQ0FBQ25HLFdBQVdxcEIsbUJBQ1pBLGVBQWVqbEIsU0FBUyxLQUFLOFYscUJBRTdCLENBQUM3WCxNQUFNO1lBQWNnbkIsZUFBZSxDQUFDO1FBQUk7UUFFOUMsSUFBSUMsc0JBQXNCLFNBQVNsaUI7WUFDakNxWSxXQUFXLElBQUksRUFBRXZGO1lBQ2pCLElBQUk1TixlQUFlLElBQUksTUFBTTROLG1CQUFtQixNQUFNLElBQUkxWixXQUFXO1FBQ3ZFO1FBRUEsSUFBSStvQixrQ0FBa0MsU0FBVXJkLEdBQUcsRUFBRW5LLEtBQUs7WUFDeEQsSUFBSVEsYUFBYTtnQkFDZm9aLHNCQUFzQnpCLG1CQUFtQmhPLEtBQUs7b0JBQzVDbEksY0FBYztvQkFDZGpCLEtBQUs7d0JBQ0gsT0FBT2hCO29CQUNUO29CQUNBc0gsS0FBSyxTQUFVNEgsV0FBVzt3QkFDeEI1USxTQUFTLElBQUk7d0JBQ2IsSUFBSSxJQUFJLEtBQUs2WixtQkFBbUIsTUFBTSxJQUFJMVosV0FBVzt3QkFDckQsSUFBSThCLE9BQU8sSUFBSSxFQUFFNEosTUFBTSxJQUFJLENBQUNBLElBQUksR0FBRytFOzZCQUM5QmtZLGVBQWUsSUFBSSxFQUFFamQsS0FBSytFO29CQUNqQztnQkFDRjtZQUNGLE9BQU9pSixpQkFBaUIsQ0FBQ2hPLElBQUksR0FBR25LO1FBQ2xDO1FBRUEsSUFBSSxDQUFDTyxPQUFPNFgsbUJBQW1COU4sZ0JBQWdCbWQsZ0NBQWdDbmQsZUFBZWxFO1FBRTlGLElBQUkzQixVQUFVLENBQUNqRSxPQUFPNFgsbUJBQW1Ca1AsZ0JBQWdCbFAsaUJBQWlCLENBQUNrUCxZQUFZLEtBQUtqbUIsUUFBUTtZQUNsR29tQixnQ0FBZ0NILGFBQWFFO1FBQy9DO1FBRUFBLG9CQUFvQmxsQixTQUFTLEdBQUc4VjtRQUVoQyx5QkFBeUI7UUFDekIsd0NBQXdDO1FBQ3hDbFosRUFBRTtZQUFFc1osUUFBUTtZQUFNcFcsYUFBYTtZQUFNekMsUUFBUThFO1FBQU8sR0FBRztZQUNyRGEsVUFBVWtpQjtRQUNaO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUN6cEIsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlrRixjQUFhbEYsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUlpSixTQUFTakosaUNBQW1CQSxDQUFDO1FBQ2pDLElBQUl1QyxTQUFTdkMsaUNBQW1CQSxDQUFDO1FBQ2pDLElBQUk2YixNQUFNN2IsaUNBQW1CQSxDQUFDO1FBQzlCLElBQUkrbUIsZ0JBQWdCL21CLGlDQUFtQkEsQ0FBQztRQUN4QyxJQUFJNEgsb0JBQW9CNUgsaUNBQW1CQSxDQUFDO1FBRTVDLElBQUk4WixVQUFTNVUsWUFBVzRVLE1BQU07UUFDOUIsSUFBSTJQLHdCQUF3QnhnQixPQUFPO1FBQ25DLElBQUl5Z0Isd0JBQXdCOWhCLG9CQUFvQmtTLE9BQU0sQ0FBQyxNQUFNLElBQUlBLFVBQVNBLFdBQVVBLFFBQU82UCxhQUFhLElBQUk5TjtRQUU1Ry9iLE9BQU9JLE9BQU8sR0FBRyxTQUFVMkQsSUFBSTtZQUM3QixJQUFJLENBQUN0QixPQUFPa25CLHVCQUF1QjVsQixPQUFPO2dCQUN4QzRsQixxQkFBcUIsQ0FBQzVsQixLQUFLLEdBQUdrakIsaUJBQWlCeGtCLE9BQU91WCxTQUFRalcsUUFDMURpVyxPQUFNLENBQUNqVyxLQUFLLEdBQ1o2bEIsc0JBQXNCLFlBQVk3bEI7WUFDeEM7WUFBRSxPQUFPNGxCLHFCQUFxQixDQUFDNWxCLEtBQUs7UUFDdEM7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQy9ELFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJcUMsY0FBY3JDLGlDQUFtQkEsQ0FBQztRQUN0QyxJQUFJdUMsU0FBU3ZDLGlDQUFtQkEsQ0FBQztRQUVqQyxJQUFJNHBCLGVBQWVwZDtRQUNuQixJQUFJcWQsWUFBWXBkO1FBQ2hCLElBQUlxZCxlQUFlNW1CLE9BQU80bUIsWUFBWTtRQUN0QyxJQUFJQyxLQUFLMW5CLFlBQVksR0FBRzJQLE1BQU07UUFDOUIsSUFBSTFPLFFBQVFqQixZQUFZLEdBQUdpQixLQUFLO1FBQ2hDLElBQUltRixPQUFPcEcsWUFBWSxJQUFJb0csSUFBSTtRQUUvQixJQUFJdWhCLGFBQWE7WUFDZixPQUFPO1lBQ1AsUUFBUTtZQUNSLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztZQUNQLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztRQUNUO1FBRUEsSUFBSUMsa0JBQWtCO1FBQ3RCLCtEQUErRDtRQUMvRCxJQUFJQyxxQkFBcUI7UUFFekJwcUIsT0FBT0ksT0FBTyxHQUFHLFNBQVVzRSxNQUFNLEVBQUVrQixDQUFDO1lBQ2xDLElBQUl5a0IsZUFBZTtZQUNuQixJQUFJbm9CLFFBQVE7WUFDWixNQUFPMEQsSUFBSWxCLE9BQU96RCxNQUFNLENBQUU7Z0JBQ3hCLElBQUlxcEIsTUFBTUwsR0FBR3ZsQixRQUFRa0I7Z0JBQ3JCLElBQUkwa0IsUUFBUSxNQUFNO29CQUNoQixJQUFJQyxXQUFXL21CLE1BQU1rQixRQUFRa0IsR0FBR0EsSUFBSTtvQkFDcEMsSUFBSW5ELE9BQU95bkIsWUFBWUssV0FBVzt3QkFDaENyb0IsU0FBU2dvQixVQUFVLENBQUNLLFNBQVM7d0JBQzdCM2tCLEtBQUs7b0JBQ1AsT0FBTyxJQUFJMmtCLGFBQWEsT0FBTzt3QkFDN0Iza0IsS0FBSzt3QkFDTCxJQUFJNGtCLGdCQUFnQmhuQixNQUFNa0IsUUFBUWtCLEdBQUdBLElBQUk7d0JBQ3pDLElBQUksQ0FBQytDLEtBQUt3aEIsaUJBQWlCSyxnQkFBZ0IsTUFBTSxJQUFJVixhQUFhLDRCQUE0QmxrQjt3QkFDOUYxRCxTQUFTOG5CLGFBQWFELFVBQVVTLGVBQWU7d0JBQy9DNWtCLEtBQUs7b0JBQ1AsT0FBTyxNQUFNLElBQUlra0IsYUFBYSwrQkFBK0JTLFdBQVc7Z0JBQzFFLE9BQU8sSUFBSUQsUUFBUSxLQUFLO29CQUN0QkQsZUFBZTtvQkFDZnprQjtvQkFDQTtnQkFDRixPQUFPO29CQUNMLElBQUkrQyxLQUFLeWhCLG9CQUFvQkUsTUFBTSxNQUFNLElBQUlSLGFBQWEsaURBQWlEbGtCO29CQUMzRzFELFNBQVNvb0I7b0JBQ1Qxa0I7Z0JBQ0Y7WUFDRjtZQUNBLElBQUl5a0IsY0FBYyxNQUFNLElBQUlQLGFBQWEsNkJBQTZCbGtCO1lBQ3RFLE9BQU87Z0JBQUUxRCxPQUFPQTtnQkFBT3VvQixLQUFLN2tCO1lBQUU7UUFDaEM7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQzFFLHlCQUF5QmpCLDBCQUEwQkMsaUNBQW1CQTtRQUc5RSxJQUFJaUIsSUFBSWpCLGlDQUFtQkEsQ0FBQztRQUM1QixJQUFJa0IsVUFBVWxCLGlDQUFtQkEsQ0FBQztRQUNsQyxJQUFJSyxZQUFZTCxpQ0FBbUJBLENBQUM7UUFDcEMsSUFBSU0sV0FBV04saUNBQW1CQSxDQUFDO1FBQ25DLElBQUltQixvQkFBb0JuQixpQ0FBbUJBLENBQUM7UUFDNUMsSUFBSW9CLGdCQUFnQnBCLGlDQUFtQkEsQ0FBQztRQUN4QyxJQUFJcUIsMkNBQTJDckIsaUNBQW1CQSxDQUFDO1FBQ25FLElBQUl5SyxRQUFRekssaUNBQW1CQSxDQUFDO1FBQ2hDLElBQUlzQyxRQUFRdEMsaUNBQW1CQSxDQUFDO1FBRWhDLElBQUlTLGFBQWFDO1FBRWpCLGlEQUFpRDtRQUNqRCxJQUFJOHBCLDZCQUE2QmxvQixNQUFNO1lBQ3JDLHNJQUFzSTtZQUN0SSxFQUFFLENBQUNpRyxJQUFJLEdBQUdraUIsTUFBTSxDQUFDLFlBQTBCLEdBQUdubUI7UUFDaEQ7UUFFQSxJQUFJb21CLG1DQUFtQyxDQUFDRiw4QkFBOEJucEIseUNBQXlDLFVBQVVaO1FBRXpILHFDQUFxQztRQUNyQyx5REFBeUQ7UUFDekRRLEVBQUU7WUFBRU0sUUFBUTtZQUFZQyxPQUFPO1lBQU1DLE1BQU07WUFBTUMsUUFBUThvQiw4QkFBOEJFO1FBQWlDLEdBQUc7WUFDekhELFFBQVEsU0FBU0EsT0FBT0UsUUFBUSxrQkFBa0IsR0FBbkI7Z0JBQzdCcnFCLFNBQVMsSUFBSTtnQkFDYixJQUFJO29CQUNGRCxVQUFVc3FCO2dCQUNaLEVBQUUsT0FBTzlvQixPQUFPO29CQUNkVCxjQUFjLElBQUksRUFBRSxTQUFTUztnQkFDL0I7Z0JBRUEsSUFBSStvQixZQUFZOXBCLFVBQVVDLE1BQU0sR0FBRztnQkFDbkMsSUFBSThwQixjQUFjRCxZQUFZdG1CLFlBQVl4RCxTQUFTLENBQUMsRUFBRTtnQkFDdEQsSUFBSTRwQixrQ0FBa0M7b0JBQ3BDLE9BQU9qZ0IsTUFBTWlnQixrQ0FBa0MsSUFBSSxFQUFFRSxZQUFZO3dCQUFDRDtxQkFBUSxHQUFHO3dCQUFDQTt3QkFBU0U7cUJBQVk7Z0JBQ3JHO2dCQUNBLElBQUkvb0IsU0FBU1gsa0JBQWtCLElBQUk7Z0JBQ25DLElBQUlZLFVBQVU7Z0JBQ2RiLFFBQVFZLFFBQVEsU0FBVUUsS0FBSztvQkFDN0IsSUFBSTRvQixXQUFXO3dCQUNiQSxZQUFZO3dCQUNaQyxjQUFjN29CO29CQUNoQixPQUFPO3dCQUNMNm9CLGNBQWNGLFFBQVFFLGFBQWE3b0IsT0FBT0Q7b0JBQzVDO29CQUNBQTtnQkFDRixHQUFHO29CQUFFRyxXQUFXO2dCQUFLO2dCQUNyQixJQUFJMG9CLFdBQVcsTUFBTSxJQUFJbnFCLFdBQVc7Z0JBQ3BDLE9BQU9vcUI7WUFDVDtRQUNGO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUM3cEIseUJBQXlCakIsMEJBQTBCQyxpQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsaUNBQW1CQSxDQUFDO1FBQzVCLElBQUl3QyxjQUFjeEMsaUNBQW1CQSxDQUFDO1FBQ3RDLElBQUlrRixjQUFhbEYsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUlpRixhQUFhakYsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUlxQyxjQUFjckMsaUNBQW1CQSxDQUFDO1FBQ3RDLElBQUlJLE9BQU9KLGlDQUFtQkEsQ0FBQztRQUMvQixJQUFJQyxhQUFhRCxpQ0FBbUJBLENBQUM7UUFDckMsSUFBSStJLFdBQVcvSSxpQ0FBbUJBLENBQUM7UUFDbkMsSUFBSTZZLFVBQVU3WSxpQ0FBbUJBLENBQUM7UUFDbEMsSUFBSXVDLFNBQVN2QyxpQ0FBbUJBLENBQUM7UUFDakMsSUFBSTBFLFdBQVcxRSxpQ0FBbUJBLENBQUM7UUFDbkMsSUFBSTRQLG9CQUFvQjVQLGlDQUFtQkEsQ0FBQztRQUM1QyxJQUFJb3BCLGlCQUFpQnBwQixpQ0FBbUJBLENBQUM7UUFDekMsSUFBSXNDLFFBQVF0QyxpQ0FBbUJBLENBQUM7UUFDaEMsSUFBSThxQixrQkFBa0I5cUIsaUNBQW1CQSxDQUFDO1FBQzFDLElBQUkrbUIsZ0JBQWdCL21CLGlDQUFtQkEsQ0FBQztRQUV4QyxJQUFJK3FCLFFBQU83bEIsWUFBVzZsQixJQUFJO1FBQzFCLElBQUlwWCxVQUFTek8sWUFBV3lPLE1BQU07UUFDOUIsSUFBSW5ILGVBQWN0SCxZQUFXc0gsV0FBVztRQUN4QyxJQUFJd2UsY0FBY0QsU0FBUUEsTUFBS3RHLEtBQUs7UUFDcEMsSUFBSXdHLDBCQUEwQmhtQixXQUFXLFVBQVU7UUFDbkQseUVBQXlFO1FBQ3pFLElBQUlKLDJCQUEyQnpCLE9BQU95Qix3QkFBd0I7UUFDOUQsSUFBSWtsQixLQUFLMW5CLFlBQVksR0FBRzJQLE1BQU07UUFDOUIsSUFBSTFPLFFBQVFqQixZQUFZLEdBQUdpQixLQUFLO1FBQ2hDLElBQUltRixPQUFPcEcsWUFBWSxJQUFJb0csSUFBSTtRQUMvQixJQUFJdUQsT0FBTzNKLFlBQVksRUFBRSxDQUFDMkosSUFBSTtRQUU5QixJQUFJa2YsV0FBVztRQUNmLElBQUlDLG9CQUFvQjtRQUN4QixJQUFJQyxrQkFBa0I7UUFDdEIsSUFBSUMsZ0JBQWdCO1FBRXBCLElBQUlDLFlBQVk7UUFDaEIsSUFBSUMsU0FBUztRQUViLElBQUlDLFNBQVMsU0FBVWhuQixNQUFNLEVBQUVpbkIsT0FBTztZQUNwQ2puQixTQUFTRSxTQUFTRjtZQUNsQixJQUFJa25CLFVBQVUsSUFBSUMsUUFBUW5uQixRQUFRLEdBQUc7WUFDckMsSUFBSW9uQixPQUFPRixRQUFRakgsS0FBSztZQUN4QixJQUFJemlCLFFBQVE0cEIsS0FBSzVwQixLQUFLO1lBQ3RCLElBQUk2cEIsV0FBV0gsUUFBUUksSUFBSSxDQUFDVCxlQUFlTyxLQUFLckIsR0FBRztZQUNuRCxJQUFJc0IsV0FBV3JuQixPQUFPekQsTUFBTSxFQUFFO2dCQUM1QixNQUFNLElBQUl5TCxhQUFZLGtDQUFrQ3VkLEdBQUd2bEIsUUFBUXFuQixZQUFZLGlDQUFpQ0E7WUFDbEg7WUFDQSxPQUFPNXJCLFdBQVd3ckIsV0FBV00sWUFBWTtnQkFBRSxJQUFJL3BCO1lBQU0sR0FBRyxJQUFJeXBCLFNBQVNHLFFBQVE1cEI7UUFDL0U7UUFFQSxJQUFJK3BCLGNBQWMsU0FBVUMsTUFBTSxFQUFFbm9CLElBQUksRUFBRTRuQixPQUFPLEVBQUVRLElBQUk7WUFDckQsSUFBSXRULE1BQU1xVCxNQUFNLENBQUNub0IsS0FBSztZQUN0QixJQUFJcW9CLGFBQWFELFFBQVF0VCxRQUFRc1QsS0FBS2pxQixLQUFLO1lBQzNDLElBQUkwcEIsVUFBVVEsY0FBYyxPQUFPRCxLQUFLem5CLE1BQU0sSUFBSSxXQUFXO2dCQUFFQSxRQUFReW5CLEtBQUt6bkIsTUFBTTtZQUFDLElBQUksQ0FBQztZQUN4RixJQUFJMm5CLG1CQUFtQjVqQixNQUFNd1AsS0FBS3JTLEdBQUdtWjtZQUNyQyxJQUFJOVYsU0FBUzRQLE1BQU07Z0JBQ2pCLElBQUl5VCxjQUFjdlQsUUFBUUY7Z0JBQzFCLElBQUkwVCxRQUFRSCxhQUFhRCxLQUFLSSxLQUFLLEdBQUdELGNBQWMsRUFBRSxHQUFHLENBQUM7Z0JBQzFELElBQUlBLGFBQWE7b0JBQ2ZELG9CQUFvQkUsTUFBTXRyQixNQUFNO29CQUNoQ2dYLE1BQU1uSSxrQkFBa0IrSTtvQkFDeEIsSUFBS2pULElBQUksR0FBR0EsSUFBSXFTLEtBQUtyUyxJQUFLO3dCQUN4QjRtQixvQkFBb0IzVCxLQUFLalQsR0FBR3FtQixZQUFZcFQsS0FBSyxLQUFLalQsR0FBRytsQixTQUFTL2xCLElBQUl5bUIsb0JBQW9CRSxLQUFLLENBQUMzbUIsRUFBRSxHQUFHcEI7b0JBQ25HO2dCQUNGLE9BQU87b0JBQ0xpRSxPQUFPMGlCLHdCQUF3QnRTO29CQUMvQlosTUFBTW5JLGtCQUFrQnJIO29CQUN4QixJQUFLN0MsSUFBSSxHQUFHQSxJQUFJcVMsS0FBS3JTLElBQUs7d0JBQ3hCbVosSUFBSXRXLElBQUksQ0FBQzdDLEVBQUU7d0JBQ1g0bUIsb0JBQW9CM1QsS0FBS2tHLEdBQUdrTixZQUFZcFQsS0FBS2tHLEdBQUc0TSxTQUFTbHBCLE9BQU84cEIsT0FBT3hOLEtBQUt3TixLQUFLLENBQUN4TixFQUFFLEdBQUd2YTtvQkFDekY7Z0JBQ0Y7WUFDRjtZQUNBLE9BQU9sRSxLQUFLcXJCLFNBQVNPLFFBQVFub0IsTUFBTThVLEtBQUsrUztRQUMxQztRQUVBLElBQUlZLHNCQUFzQixTQUFVcmdCLE1BQU0sRUFBRUUsR0FBRyxFQUFFbkssS0FBSztZQUNwRCxJQUFJUSxhQUFhO2dCQUNmLElBQUk0SixhQUFhdkgseUJBQXlCb0gsUUFBUUU7Z0JBQ2xELElBQUlDLGNBQWMsQ0FBQ0EsV0FBV25JLFlBQVksRUFBRTtZQUM5QztZQUNBLElBQUlqQyxVQUFVc0MsV0FBVyxPQUFPMkgsTUFBTSxDQUFDRSxJQUFJO2lCQUN0Q2lkLGVBQWVuZCxRQUFRRSxLQUFLbks7UUFDbkM7UUFFQSxJQUFJdXFCLFFBQU8sU0FBVXZxQixLQUFLLEVBQUV1b0IsR0FBRyxFQUFFL2xCLE1BQU0sRUFBRTZuQixLQUFLO1lBQzVDLElBQUksQ0FBQ3JxQixLQUFLLEdBQUdBO1lBQ2IsSUFBSSxDQUFDdW9CLEdBQUcsR0FBR0E7WUFDWCxJQUFJLENBQUMvbEIsTUFBTSxHQUFHQTtZQUNkLElBQUksQ0FBQzZuQixLQUFLLEdBQUdBO1FBQ2Y7UUFFQSxJQUFJVixVQUFVLFNBQVVubkIsTUFBTSxFQUFFOEwsS0FBSztZQUNuQyxJQUFJLENBQUM5TCxNQUFNLEdBQUdBO1lBQ2QsSUFBSSxDQUFDOEwsS0FBSyxHQUFHQTtRQUNmO1FBRUEsb0NBQW9DO1FBQ3BDcWIsUUFBUXRuQixTQUFTLEdBQUc7WUFDbEJtb0IsTUFBTSxTQUFVQyxTQUFTO2dCQUN2QixPQUFPLElBQUlkLFFBQVEsSUFBSSxDQUFDbm5CLE1BQU0sRUFBRWlvQjtZQUNsQztZQUNBaEksT0FBTztnQkFDTCxJQUFJamdCLFNBQVMsSUFBSSxDQUFDQSxNQUFNO2dCQUN4QixJQUFJa0IsSUFBSSxJQUFJLENBQUNvbUIsSUFBSSxDQUFDVCxlQUFlLElBQUksQ0FBQy9hLEtBQUs7Z0JBQzNDLElBQUlrYyxPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDOW1CO2dCQUNyQixJQUFJMGtCLE1BQU1MLEdBQUd2bEIsUUFBUWtCO2dCQUNyQixJQUFJK0MsS0FBSzJpQixpQkFBaUJoQixNQUFNLE9BQU9vQyxLQUFLemlCLE1BQU07Z0JBQ2xELE9BQVFxZ0I7b0JBQ04sS0FBSzt3QkFDSCxPQUFPb0MsS0FBS3ZnQixNQUFNO29CQUNwQixLQUFLO3dCQUNILE9BQU91Z0IsS0FBS0UsS0FBSztvQkFDbkIsS0FBSzt3QkFDSCxPQUFPRixLQUFLNWYsTUFBTTtvQkFDcEIsS0FBSzt3QkFDSCxPQUFPNGYsS0FBS0csT0FBTyxDQUFDO29CQUN0QixLQUFLO3dCQUNILE9BQU9ILEtBQUtHLE9BQU8sQ0FBQztvQkFDdEIsS0FBSzt3QkFDSCxPQUFPSCxLQUFLRyxPQUFPLENBQUM7Z0JBQ3hCO2dCQUFFLE1BQU0sSUFBSW5nQixhQUFZLDRCQUE0QjRkLE1BQU0sV0FBVzFrQjtZQUN2RTtZQUNBdW1CLE1BQU0sU0FBVXZpQixJQUFJLEVBQUUxSCxLQUFLLEVBQUU0cUIsS0FBSyxFQUFFckMsR0FBRyxFQUFFOEIsS0FBSztnQkFDNUMsT0FBTyxJQUFJRSxNQUFLdnFCLE9BQU91b0IsS0FBSzdnQixPQUFPLE9BQU9wRyxNQUFNLElBQUksQ0FBQ2tCLE1BQU0sRUFBRW9vQixPQUFPckMsTUFBTThCO1lBQzVFO1lBQ0FwZ0IsUUFBUTtnQkFDTixJQUFJekgsU0FBUyxJQUFJLENBQUNBLE1BQU07Z0JBQ3hCLElBQUlrQixJQUFJLElBQUksQ0FBQzRLLEtBQUssR0FBRztnQkFDckIsSUFBSXVjLGdCQUFnQjtnQkFDcEIsSUFBSTVnQixTQUFTLENBQUM7Z0JBQ2QsSUFBSW9nQixRQUFRLENBQUM7Z0JBQ2IsTUFBTzNtQixJQUFJbEIsT0FBT3pELE1BQU0sQ0FBRTtvQkFDeEIyRSxJQUFJLElBQUksQ0FBQ29uQixLQUFLLENBQUM7d0JBQUM7d0JBQUs7cUJBQUksRUFBRXBuQjtvQkFDM0IsSUFBSXFrQixHQUFHdmxCLFFBQVFrQixPQUFPLE9BQU8sQ0FBQ21uQixlQUFlO3dCQUMzQ25uQjt3QkFDQTtvQkFDRjtvQkFDQSxrQkFBa0I7b0JBQ2xCLElBQUl0RCxTQUFTLElBQUksQ0FBQ29xQixJQUFJLENBQUM5bUIsR0FBR2tILE1BQU07b0JBQ2hDLElBQUlULE1BQU0vSixPQUFPSixLQUFLO29CQUN0QjBELElBQUl0RCxPQUFPbW9CLEdBQUc7b0JBQ2Q3a0IsSUFBSSxJQUFJLENBQUNvbkIsS0FBSyxDQUFDO3dCQUFDO3FCQUFJLEVBQUVwbkIsS0FBSztvQkFDM0IsZ0JBQWdCO29CQUNoQkEsSUFBSSxJQUFJLENBQUNvbUIsSUFBSSxDQUFDVCxlQUFlM2xCO29CQUM3QnRELFNBQVMsSUFBSSxDQUFDb3FCLElBQUksQ0FBQzltQixHQUFHK2UsS0FBSztvQkFDM0IyRSxlQUFlaUQsT0FBT2xnQixLQUFLL0o7b0JBQzNCZ25CLGVBQWVuZCxRQUFRRSxLQUFLL0osT0FBT0osS0FBSztvQkFDeEMwRCxJQUFJLElBQUksQ0FBQ29uQixLQUFLLENBQUM7d0JBQUM7d0JBQUs7cUJBQUksRUFBRTFxQixPQUFPbW9CLEdBQUc7b0JBQ3JDLElBQUlILE1BQU1MLEdBQUd2bEIsUUFBUWtCO29CQUNyQixJQUFJMGtCLFFBQVEsS0FBSzt3QkFDZnlDLGdCQUFnQjt3QkFDaEJubkI7b0JBQ0YsT0FBTyxJQUFJMGtCLFFBQVEsS0FBSzt3QkFDdEIxa0I7d0JBQ0E7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsT0FBTyxJQUFJLENBQUN1bUIsSUFBSSxDQUFDVixRQUFRdGYsUUFBUSxJQUFJLENBQUNxRSxLQUFLLEVBQUU1SyxHQUFHMm1CO1lBQ2xEO1lBQ0FLLE9BQU87Z0JBQ0wsSUFBSWxvQixTQUFTLElBQUksQ0FBQ0EsTUFBTTtnQkFDeEIsSUFBSWtCLElBQUksSUFBSSxDQUFDNEssS0FBSyxHQUFHO2dCQUNyQixJQUFJeWMsZ0JBQWdCO2dCQUNwQixJQUFJTCxRQUFRLEVBQUU7Z0JBQ2QsSUFBSUwsUUFBUSxFQUFFO2dCQUNkLE1BQU8zbUIsSUFBSWxCLE9BQU96RCxNQUFNLENBQUU7b0JBQ3hCMkUsSUFBSSxJQUFJLENBQUNvbUIsSUFBSSxDQUFDVCxlQUFlM2xCO29CQUM3QixJQUFJcWtCLEdBQUd2bEIsUUFBUWtCLE9BQU8sT0FBTyxDQUFDcW5CLGVBQWU7d0JBQzNDcm5CO3dCQUNBO29CQUNGO29CQUNBLElBQUl0RCxTQUFTLElBQUksQ0FBQ29xQixJQUFJLENBQUM5bUIsR0FBRytlLEtBQUs7b0JBQy9CelksS0FBS3FnQixPQUFPanFCO29CQUNaNEosS0FBSzBnQixPQUFPdHFCLE9BQU9KLEtBQUs7b0JBQ3hCMEQsSUFBSSxJQUFJLENBQUNvbkIsS0FBSyxDQUFDO3dCQUFDO3dCQUFLO3FCQUFJLEVBQUUxcUIsT0FBT21vQixHQUFHO29CQUNyQyxJQUFJUixHQUFHdmxCLFFBQVFrQixPQUFPLEtBQUs7d0JBQ3pCcW5CLGdCQUFnQjt3QkFDaEJybkI7b0JBQ0YsT0FBTyxJQUFJcWtCLEdBQUd2bEIsUUFBUWtCLE9BQU8sS0FBSzt3QkFDaENBO3dCQUNBO29CQUNGO2dCQUNGO2dCQUNBLE9BQU8sSUFBSSxDQUFDdW1CLElBQUksQ0FBQ1YsUUFBUW1CLE9BQU8sSUFBSSxDQUFDcGMsS0FBSyxFQUFFNUssR0FBRzJtQjtZQUNqRDtZQUNBemYsUUFBUTtnQkFDTixJQUFJMEQsUUFBUSxJQUFJLENBQUNBLEtBQUs7Z0JBQ3RCLElBQUkwYyxTQUFTbEMsZ0JBQWdCLElBQUksQ0FBQ3RtQixNQUFNLEVBQUUsSUFBSSxDQUFDOEwsS0FBSyxHQUFHO2dCQUN2RCxPQUFPLElBQUksQ0FBQzJiLElBQUksQ0FBQ1gsV0FBVzBCLE9BQU9ockIsS0FBSyxFQUFFc08sT0FBTzBjLE9BQU96QyxHQUFHO1lBQzdEO1lBQ0F4Z0IsUUFBUTtnQkFDTixJQUFJdkYsU0FBUyxJQUFJLENBQUNBLE1BQU07Z0JBQ3hCLElBQUl5b0IsYUFBYSxJQUFJLENBQUMzYyxLQUFLO2dCQUMzQixJQUFJNUssSUFBSXVuQjtnQkFDUixJQUFJbEQsR0FBR3ZsQixRQUFRa0IsT0FBTyxLQUFLQTtnQkFDM0IsSUFBSXFrQixHQUFHdmxCLFFBQVFrQixPQUFPLEtBQUtBO3FCQUN0QixJQUFJK0MsS0FBSzBpQixtQkFBbUJwQixHQUFHdmxCLFFBQVFrQixLQUFLQSxJQUFJLElBQUksQ0FBQ29tQixJQUFJLENBQUNaLFVBQVV4bEIsSUFBSTtxQkFDeEUsTUFBTSxJQUFJOEcsYUFBWSxnQ0FBZ0M5RztnQkFDM0QsSUFBSXFrQixHQUFHdmxCLFFBQVFrQixPQUFPLEtBQUtBLElBQUksSUFBSSxDQUFDb21CLElBQUksQ0FBQ1osVUFBVXhsQixJQUFJO2dCQUN2RCxJQUFJcWtCLEdBQUd2bEIsUUFBUWtCLE9BQU8sT0FBT3FrQixHQUFHdmxCLFFBQVFrQixPQUFPLEtBQUs7b0JBQ2xEQTtvQkFDQSxJQUFJcWtCLEdBQUd2bEIsUUFBUWtCLE9BQU8sT0FBT3FrQixHQUFHdmxCLFFBQVFrQixPQUFPLEtBQUtBO29CQUNwRCxJQUFJd25CLHFCQUFxQnhuQjtvQkFDekJBLElBQUksSUFBSSxDQUFDb21CLElBQUksQ0FBQ1osVUFBVXhsQjtvQkFDeEIsSUFBSXduQix1QkFBdUJ4bkIsR0FBRyxNQUFNLElBQUk4RyxhQUFZLGlEQUFpRDlHO2dCQUN2RztnQkFDQSxPQUFPLElBQUksQ0FBQ3VtQixJQUFJLENBQUNYLFdBQVczWCxRQUFPclEsTUFBTWtCLFFBQVF5b0IsWUFBWXZuQixLQUFLdW5CLFlBQVl2bkI7WUFDaEY7WUFDQWluQixTQUFTLFNBQVUzcUIsS0FBSztnQkFDdEIsSUFBSTJxQixVQUFVLEtBQUszcUI7Z0JBQ25CLElBQUlzTyxRQUFRLElBQUksQ0FBQ0EsS0FBSztnQkFDdEIsSUFBSXViLFdBQVd2YixRQUFRcWMsUUFBUTVyQixNQUFNO2dCQUNyQyxJQUFJdUMsTUFBTSxJQUFJLENBQUNrQixNQUFNLEVBQUU4TCxPQUFPdWIsY0FBY2MsU0FBUyxNQUFNLElBQUluZ0IsYUFBWSwrQkFBK0I4RDtnQkFDMUcsT0FBTyxJQUFJLENBQUMyYixJQUFJLENBQUNYLFdBQVd0cEIsT0FBT3NPLE9BQU91YjtZQUM1QztZQUNBQyxNQUFNLFNBQVVxQixLQUFLLEVBQUV6bkIsQ0FBQztnQkFDdEIsSUFBSWxCLFNBQVMsSUFBSSxDQUFDQSxNQUFNO2dCQUN4QixNQUFPa0IsSUFBSWxCLE9BQU96RCxNQUFNLEVBQUUyRSxJQUFLLElBQUksQ0FBQytDLEtBQUswa0IsT0FBT3BELEdBQUd2bEIsUUFBUWtCLEtBQUs7Z0JBQ2hFLE9BQU9BO1lBQ1Q7WUFDQW9uQixPQUFPLFNBQVVKLEtBQUssRUFBRWhuQixDQUFDO2dCQUN2QkEsSUFBSSxJQUFJLENBQUNvbUIsSUFBSSxDQUFDVCxlQUFlM2xCO2dCQUM3QixJQUFJMGtCLE1BQU1MLEdBQUcsSUFBSSxDQUFDdmxCLE1BQU0sRUFBRWtCO2dCQUMxQixJQUFLLElBQUlzUCxJQUFJLEdBQUdBLElBQUkwWCxNQUFNM3JCLE1BQU0sRUFBRWlVLElBQUssSUFBSTBYLEtBQUssQ0FBQzFYLEVBQUUsS0FBS29WLEtBQUssT0FBTzFrQjtnQkFDcEUsTUFBTSxJQUFJOEcsYUFBWSw0QkFBNEI0ZCxNQUFNLFdBQVcxa0I7WUFDckU7UUFDRjtRQUVBLElBQUkwbkIsb0JBQW9COXFCLE1BQU07WUFDNUIsSUFBSStxQixZQUFZO1lBQ2hCLElBQUk3b0I7WUFDSndtQixZQUFZcUMsV0FBVyxTQUFVbGhCLEdBQUcsRUFBRW5LLEtBQUssRUFBRTBwQixPQUFPO2dCQUNsRGxuQixTQUFTa25CLFFBQVFsbkIsTUFBTTtZQUN6QjtZQUNBLE9BQU9BLFdBQVc2b0I7UUFDcEI7UUFFQSxJQUFJQyxvQkFBb0J2RyxpQkFBaUIsQ0FBQ3prQixNQUFNO1lBQzlDLGVBQWU7WUFDZixPQUFPLElBQUkwb0IsWUFBWSxZQUFhLENBQUM3WDtRQUN2QztRQUVBLHNCQUFzQjtRQUN0QiwwQ0FBMEM7UUFDMUMsMERBQTBEO1FBQzFEbFMsRUFBRTtZQUFFTSxRQUFRO1lBQVF1SixNQUFNO1lBQU1wSixRQUFRMHJCO1FBQWtCLEdBQUc7WUFDM0QzSSxPQUFPLFNBQVNBLE1BQU04SSxJQUFJLEVBQUU5QixPQUFPO2dCQUNqQyxPQUFPNkIscUJBQXFCLENBQUNydEIsV0FBV3dyQixXQUFXVCxZQUFZdUMsUUFBUS9CLE9BQU8rQixNQUFNOUI7WUFDdEY7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDM3JCLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJcUMsY0FBY3JDLGlDQUFtQkEsQ0FBQztRQUN0QyxJQUFJa1csZ0JBQWdCbFcsaUNBQW1CQSxDQUFDO1FBQ3hDLElBQUk4VixhQUFhOVYsaUNBQW1CQSxDQUFDO1FBRXJDLElBQUkrWSxPQUFNakQsV0FBV2lELEdBQUc7UUFDeEIsSUFBSUQsZUFBZWhELFdBQVd0VSxLQUFLO1FBQ25DLElBQUl1WixVQUFVMVksWUFBWXlXLGFBQWFpQyxPQUFPO1FBQzlDLElBQUl4UyxPQUFPbEcsWUFBWXlXLGFBQWF2USxJQUFJO1FBQ3hDLElBQUl4QyxPQUFPd0MsS0FBSyxJQUFJd1EsUUFBT2hULElBQUk7UUFFL0JqRyxPQUFPSSxPQUFPLEdBQUcsU0FBVW9KLEdBQUcsRUFBRTFELEVBQUUsRUFBRTRuQixhQUFhO1lBQy9DLE9BQU9BLGdCQUFnQnRYLGNBQWM7Z0JBQUVwUSxVQUFVeUMsS0FBS2U7Z0JBQU12RCxNQUFNQTtZQUFLLEdBQUdILE1BQU1tVixRQUFRelIsS0FBSzFEO1FBQy9GO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUM1RSx5QkFBeUJkLFNBQVNGLGlDQUFtQkE7UUFHN0QsSUFBSXFJLHFCQUFxQnJJLGlDQUFtQkEsQ0FBQztRQUM3QyxJQUFJc0ksY0FBY3RJLGlDQUFtQkEsQ0FBQztRQUV0QyxJQUFJbUosYUFBYWIsWUFBWXNhLE1BQU0sQ0FBQyxVQUFVO1FBRTlDLHNDQUFzQztRQUN0QywwREFBMEQ7UUFDMUQsb0VBQW9FO1FBQ3BFMWlCLFFBQVFnTCxDQUFDLEdBQUc5SCxPQUFPcXFCLG1CQUFtQixJQUFJLFNBQVNBLG9CQUFvQmpsQixDQUFDO1lBQ3RFLE9BQU9ILG1CQUFtQkcsR0FBR1c7UUFDL0I7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3JKLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJNlYsT0FBTzdWLGlDQUFtQkEsQ0FBQztRQUMvQixJQUFJdUosTUFBT3ZKLGlDQUFtQkEsQ0FBQyxNQUFNdUosR0FBRztRQUN4QyxJQUFJd00sT0FBTy9WLGlDQUFtQkEsQ0FBQztRQUMvQixJQUFJZ1csZUFBZWhXLGlDQUFtQkEsQ0FBQztRQUN2QyxJQUFJa1csZ0JBQWdCbFcsaUNBQW1CQSxDQUFDO1FBQ3hDLElBQUlvQixnQkFBZ0JwQixpQ0FBbUJBLENBQUM7UUFFeEMsc0NBQXNDO1FBQ3RDLDBEQUEwRDtRQUMxREYsT0FBT0ksT0FBTyxHQUFHLFNBQVNtUCxhQUFhZ0gsS0FBSztZQUMxQyxJQUFJN04sSUFBSXFOLEtBQUssSUFBSTtZQUNqQixJQUFJUyxXQUFXTixhQUFhSztZQUM1QixJQUFJTixLQUFLdk4sS0FBSzhOLFNBQVNQLElBQUksRUFBRSxPQUFPO1lBQ3BDLElBQUlqUSxXQUFXd1EsU0FBU3pHLFdBQVc7WUFDbkMsT0FBT3FHLGNBQWNwUSxVQUFVLFNBQVV5USxDQUFDO2dCQUN4QyxJQUFJLENBQUNoTixJQUFJZixHQUFHK04sSUFBSSxPQUFPblYsY0FBYzBFLFVBQVUsVUFBVTtZQUMzRCxPQUFPO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2hHLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJK0ksV0FBVy9JLGlDQUFtQkEsQ0FBQztRQUVuQyxJQUFJaUQsVUFBVUM7UUFDZCxJQUFJekMsYUFBYUM7UUFFakIscUNBQXFDO1FBQ3JDWixPQUFPSSxPQUFPLEdBQUcsU0FBVVMsUUFBUTtZQUNqQyxJQUFJb0ksU0FBU3BJLFdBQVcsT0FBT0E7WUFDL0IsTUFBTSxJQUFJRixXQUFXd0MsUUFBUXRDLFlBQVk7UUFDM0M7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2IsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlxQyxjQUFjckMsaUNBQW1CQSxDQUFDO1FBRXRDLElBQUkwdEIsU0FBU3hPO1FBQ2IsSUFBSTNiLFVBQVVsQixZQUFZLEdBQUdrQixPQUFPO1FBRXBDLElBQUlvcUIsT0FBTyxTQUFXQyxHQUFHO1lBQUksT0FBTzFxQixPQUFPLElBQUl3cUIsT0FBT0UsS0FBS3ROLEtBQUs7UUFBRyxFQUFHO1FBQ3RFLDJFQUEyRTtRQUMzRSxJQUFJdU4sMkJBQTJCO1FBQy9CLElBQUlDLHdCQUF3QkQseUJBQXlCaG5CLElBQUksQ0FBQzhtQjtRQUUxRDd0QixPQUFPSSxPQUFPLEdBQUcsU0FBVW9nQixLQUFLLEVBQUV5TixXQUFXO1lBQzNDLElBQUlELHlCQUF5QixPQUFPeE4sU0FBUyxZQUFZLENBQUNvTixPQUFPTSxpQkFBaUIsRUFBRTtnQkFDbEYsTUFBT0QsY0FBZXpOLFFBQVEvYyxRQUFRK2MsT0FBT3VOLDBCQUEwQjtZQUN6RTtZQUFFLE9BQU92TjtRQUNYO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUN4Z0IsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlrRixjQUFhbEYsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUlDLGFBQWFELGlDQUFtQkEsQ0FBQztRQUVyQyxJQUFJcUosV0FBVW5FLFlBQVdtRSxPQUFPO1FBRWhDdkosT0FBT0ksT0FBTyxHQUFHRCxXQUFXb0osYUFBWSxjQUFjeEMsSUFBSSxDQUFDM0QsT0FBT21HO0lBR2xFLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDdkosUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlJLE9BQU9KLGlDQUFtQkEsQ0FBQztRQUMvQixJQUFJTSxXQUFXTixpQ0FBbUJBLENBQUM7UUFDbkMsSUFBSW1CLG9CQUFvQm5CLGlDQUFtQkEsQ0FBQztRQUM1QyxJQUFJUSxvQkFBb0JSLGlDQUFtQkEsQ0FBQztRQUU1Q0YsT0FBT0ksT0FBTyxHQUFHLFNBQVUyTCxHQUFHLEVBQUVvaUIsY0FBYztZQUM1QyxJQUFJLENBQUNBLGtCQUFrQixPQUFPcGlCLFFBQVEsVUFBVXZMLFNBQVN1TDtZQUN6RCxJQUFJekUsU0FBUzVHLGtCQUFrQnFMO1lBQy9CLE9BQU8xSyxrQkFBa0JiLFNBQVM4RyxXQUFXOUMsWUFBWWxFLEtBQUtnSCxRQUFReUUsT0FBT0E7UUFDL0U7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQy9MLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJd0MsY0FBY3hDLGlDQUFtQkEsQ0FBQztRQUN0QyxJQUFJc0MsUUFBUXRDLGlDQUFtQkEsQ0FBQztRQUVoQyxrQkFBa0I7UUFDbEIsdURBQXVEO1FBQ3ZERixPQUFPSSxPQUFPLEdBQUdzQyxlQUFlRixNQUFNO1lBQ3BDLCtFQUErRTtZQUMvRSxPQUFPYyxPQUFPRCxjQUFjLENBQUMsWUFBMEIsR0FBRyxhQUFhO2dCQUNyRW5CLE9BQU87Z0JBQ1BvQyxVQUFVO1lBQ1osR0FBR0MsU0FBUyxLQUFLO1FBQ25CO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNyRCx5QkFBeUJqQiwwQkFBMEJDLGlDQUFtQkE7UUFHOUUsSUFBSXdDLGNBQWN4QyxpQ0FBbUJBLENBQUM7UUFDdEMsSUFBSXFDLGNBQWNyQyxpQ0FBbUJBLENBQUM7UUFDdEMsSUFBSTRiLHdCQUF3QjViLGlDQUFtQkEsQ0FBQztRQUVoRCxJQUFJNGEsMkJBQTJCRCxnQkFBZ0J0VyxTQUFTO1FBQ3hELElBQUkwVyxVQUFVMVksWUFBWXVZLHlCQUF5QkcsT0FBTztRQUUxRCwwQ0FBMEM7UUFDMUMseUNBQXlDO1FBQ3pDLElBQUl2WSxlQUFlLENBQUUsV0FBVW9ZLHdCQUF1QixHQUFJO1lBQ3hEZ0Isc0JBQXNCaEIsMEJBQTBCLFFBQVE7Z0JBQ3RENVgsS0FBSyxTQUFTK1M7b0JBQ1osSUFBSXJCLFFBQVE7b0JBQ1pxRyxRQUFRLElBQUksRUFBRTt3QkFBY3JHO29CQUFTO29CQUNyQyxPQUFPQTtnQkFDVDtnQkFDQXpRLGNBQWM7Z0JBQ2R3WCxZQUFZO1lBQ2Q7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDM2I7UUFHUiwyQkFBMkI7UUFDM0JBLE9BQU9JLE9BQU8sR0FBRztZQUNmO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0Q7SUFHRCxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ0osUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlxbEIsY0FBY3JsQixpQ0FBbUJBLENBQUM7UUFFdEMsSUFBSTJFLG9CQUFvQkYsU0FBU0osU0FBUztRQUMxQyxJQUFJb0csUUFBUTlGLGtCQUFrQjhGLEtBQUs7UUFDbkMsSUFBSXJLLE9BQU91RSxrQkFBa0J2RSxJQUFJO1FBRWpDLGdGQUFnRjtRQUNoRk4sT0FBT0ksT0FBTyxHQUFHLE9BQU9ndUIsV0FBVyxZQUFZQSxRQUFRempCLEtBQUssSUFBSzRhLENBQUFBLGNBQWNqbEIsS0FBSzBHLElBQUksQ0FBQzJELFNBQVM7WUFDaEcsT0FBT3JLLEtBQUtxSyxLQUFLLENBQUNBLE9BQU8zSjtRQUMzQjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDaEIsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUk2VixPQUFPN1YsaUNBQW1CQSxDQUFDO1FBQy9CLElBQUk4VixhQUFhOVYsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUkrVixPQUFPL1YsaUNBQW1CQSxDQUFDO1FBQy9CLElBQUlnVyxlQUFlaFcsaUNBQW1CQSxDQUFDO1FBQ3ZDLElBQUlpVyxhQUFhalcsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUlrVyxnQkFBZ0JsVyxpQ0FBbUJBLENBQUM7UUFFeEMsSUFBSStZLE9BQU1qRCxXQUFXaUQsR0FBRztRQUN4QixJQUFJbkMsTUFBTWQsV0FBV2MsR0FBRztRQUN4QixJQUFJck4sTUFBTXVNLFdBQVd2TSxHQUFHO1FBRXhCLHNDQUFzQztRQUN0QywwREFBMEQ7UUFDMUR6SixPQUFPSSxPQUFPLEdBQUcsU0FBU2dwQixhQUFhN1MsS0FBSztZQUMxQyxJQUFJN04sSUFBSXFOLEtBQUssSUFBSTtZQUNqQixJQUFJUyxXQUFXTixhQUFhSztZQUM1QixJQUFJalUsU0FBUyxJQUFJMlc7WUFFakIsSUFBSWhELEtBQUt2TixLQUFLOE4sU0FBU1AsSUFBSSxFQUFFO2dCQUMzQkcsY0FBY0ksU0FBU3pHLFdBQVcsSUFBSSxTQUFVMEcsQ0FBQztvQkFDL0MsSUFBSWhOLElBQUlmLEdBQUcrTixJQUFJSyxJQUFJeFUsUUFBUW1VO2dCQUM3QjtZQUNGLE9BQU87Z0JBQ0xOLFdBQVd6TixHQUFHLFNBQVUrTixDQUFDO29CQUN2QixJQUFJRCxTQUFTRSxRQUFRLENBQUNELElBQUlLLElBQUl4VSxRQUFRbVU7Z0JBQ3hDO1lBQ0Y7WUFFQSxPQUFPblU7UUFDVDtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDcEIseUJBQXlCZDtRQUdqQyxJQUFJaXVCLHdCQUF3QixDQUFDLEVBQUVuSCxvQkFBb0I7UUFDbkQseUVBQXlFO1FBQ3pFLElBQUluaUIsMkJBQTJCekIsT0FBT3lCLHdCQUF3QjtRQUU5RCxxQkFBcUI7UUFDckIsSUFBSXVwQixjQUFjdnBCLDRCQUE0QixDQUFDc3BCLHNCQUFzQi90QixJQUFJLENBQUM7WUFBRSxHQUFHO1FBQUUsR0FBRztRQUVwRixnRUFBZ0U7UUFDaEUscUVBQXFFO1FBQ3JFRixRQUFRZ0wsQ0FBQyxHQUFHa2pCLGNBQWMsU0FBU3BILHFCQUFxQmhDLENBQUM7WUFDdkQsSUFBSTVZLGFBQWF2SCx5QkFBeUIsSUFBSSxFQUFFbWdCO1lBQ2hELE9BQU8sQ0FBQyxDQUFDNVksY0FBY0EsV0FBV3FQLFVBQVU7UUFDOUMsSUFBSTBTO0lBR0osR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNydUIsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUkwUyx5QkFBeUIxUyxpQ0FBbUJBLENBQUM7UUFFakQsSUFBSTZILFVBQVV6RTtRQUVkLGdDQUFnQztRQUNoQyx3Q0FBd0M7UUFDeEN0RCxPQUFPSSxPQUFPLEdBQUcsU0FBVVMsUUFBUTtZQUNqQyxPQUFPa0gsUUFBUTZLLHVCQUF1Qi9SO1FBQ3hDO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNiO1FBR1JBLE9BQU9JLE9BQU8sR0FBRyxTQUFVdUksSUFBSTtZQUM3QixJQUFJO2dCQUNGLE9BQU8sQ0FBQyxDQUFDQTtZQUNYLEVBQUUsT0FBTzVHLE9BQU87Z0JBQ2QsT0FBTztZQUNUO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQy9CLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJa0YsY0FBYWxGLGlDQUFtQkEsQ0FBQztRQUNyQyxJQUFJcUMsY0FBY3JDLGlDQUFtQkEsQ0FBQztRQUN0QyxJQUFJcXVCLHNCQUFzQnJ1QixpQ0FBbUJBLENBQUM7UUFDOUMsSUFBSXdZLFVBQVV4WSxpQ0FBbUJBLENBQUM7UUFDbEMsSUFBSXVDLFNBQVN2QyxpQ0FBbUJBLENBQUM7UUFDakMsSUFBSXN1QixZQUFZdHVCLGlDQUFtQkEsQ0FBQztRQUNwQyxJQUFJdXVCLG9CQUFvQnZ1QixpQ0FBbUJBLENBQUM7UUFDNUMsSUFBSW9GLGNBQWNwRixpQ0FBbUJBLENBQUM7UUFFdEMsSUFBSTRSLGlCQUFpQjBjLFVBQVVwYyxHQUFHO1FBQ2xDLElBQUlMLG9CQUFvQnljLFVBQVVsYyxNQUFNO1FBRXhDLElBQUk1RixlQUFjdEgsWUFBV3NILFdBQVc7UUFDeEMsSUFBSTlMLGFBQVl3RSxZQUFXeEUsU0FBUztRQUNwQyxJQUFJcXBCLEtBQUsxbkIsWUFBWSxHQUFHMlAsTUFBTTtRQUU5QixJQUFJd2Msc0JBQXNCLFNBQVU1aEIsTUFBTSxFQUFFMEQsS0FBSztZQUMvQyxJQUFJdlAsU0FBUzZMLE9BQU83TCxNQUFNO1lBQzFCLE1BQU11UCxRQUFRdlAsUUFBUXVQLFFBQVM7Z0JBQzdCLElBQUk4WixNQUFNTCxHQUFHbmQsUUFBUTBEO2dCQUNyQixJQUFJOFosUUFBUSxPQUFPQSxRQUFRLE9BQVFBLFFBQVEsUUFBUUEsUUFBUSxRQUFRQSxRQUFRLE1BQU07WUFDbkY7WUFBRSxPQUFPOVo7UUFDWDtRQUVBLElBQUltZSxvQkFBb0IsU0FBVUMsS0FBSyxFQUFFdG1CLFFBQVEsRUFBRXVtQixnQkFBZ0I7WUFDakUsSUFBSUMsY0FBY0YsTUFBTTN0QixNQUFNO1lBRTlCLElBQUk2dEIsY0FBYyxHQUFHO2dCQUNuQkYsU0FBU0UsZ0JBQWdCLElBQUksT0FBTztZQUN0QztZQUVBLElBQUlDLFVBQVUsQ0FBQ3ptQixRQUFRLENBQUMyaEIsR0FBRzJFLE9BQU8sR0FBRyxJQUFJLEVBQUMsSUFDckN0bUIsQ0FBQUEsUUFBUSxDQUFDMmhCLEdBQUcyRSxPQUFPLEdBQUcsSUFBSSxFQUFDLElBQzNCdG1CLENBQUFBLFFBQVEsQ0FBQzJoQixHQUFHMkUsT0FBTyxHQUFHLElBQUksS0FDM0J0bUIsUUFBUSxDQUFDMmhCLEdBQUcyRSxPQUFPLEdBQUc7WUFFMUIsSUFBSUksYUFBYTtnQkFDZEQsV0FBVyxLQUFNO2dCQUNqQkEsV0FBVyxJQUFLO2dCQUNqQkEsVUFBVTthQUNYO1lBRUQsSUFBSUQsZ0JBQWdCLEdBQUc7Z0JBQ3JCLElBQUlELG9CQUFvQkcsVUFBVSxDQUFDLEVBQUUsS0FBSyxHQUFHO29CQUMzQyxNQUFNLElBQUl0aUIsYUFBWTtnQkFDeEI7Z0JBQ0EsT0FBTztvQkFBQ3NpQixVQUFVLENBQUMsRUFBRTtpQkFBQztZQUN4QjtZQUVBLElBQUlGLGdCQUFnQixHQUFHO2dCQUNyQixJQUFJRCxvQkFBb0JHLFVBQVUsQ0FBQyxFQUFFLEtBQUssR0FBRztvQkFDM0MsTUFBTSxJQUFJdGlCLGFBQVk7Z0JBQ3hCO2dCQUNBLE9BQU87b0JBQUNzaUIsVUFBVSxDQUFDLEVBQUU7b0JBQUVBLFVBQVUsQ0FBQyxFQUFFO2lCQUFDO1lBQ3ZDO1lBRUEsT0FBT0E7UUFDVDtRQUVBLElBQUlDLGFBQWEsU0FBVS9oQixLQUFLLEVBQUVnaUIsUUFBUSxFQUFFOWhCLE9BQU87WUFDakQsSUFBSStoQixpQkFBaUJELFNBQVNqdUIsTUFBTTtZQUNwQyxJQUFLLElBQUl1UCxRQUFRLEdBQUdBLFFBQVEyZSxnQkFBZ0IzZSxRQUFTO2dCQUNuRHRELEtBQUssQ0FBQ0UsVUFBVW9ELE1BQU0sR0FBRzBlLFFBQVEsQ0FBQzFlLE1BQU07WUFDMUM7WUFDQSxPQUFPcEQsVUFBVStoQjtRQUNuQjtRQUVBLG9EQUFvRCxHQUNwRG52QixPQUFPSSxPQUFPLEdBQUcsU0FBVTBNLE1BQU0sRUFBRTlJLE9BQU8sRUFBRStJLElBQUksRUFBRUUsU0FBUztZQUN6RHlMLFFBQVE1TDtZQUNSeWhCLG9CQUFvQnZxQjtZQUNwQixJQUFJc0UsV0FBV21tQixrQkFBa0J6cUIsYUFBYSxXQUFXOE4saUJBQWlCQztZQUMxRSxJQUFJcWQsb0JBQW9CcHJCLFVBQVVBLFFBQVFvckIsaUJBQWlCLEdBQUc1cUI7WUFFOUQsSUFBSTRxQixzQkFBc0I1cUIsV0FBVzRxQixvQkFBb0I7WUFFekQsSUFBSUEsc0JBQXNCLFdBQVdBLHNCQUFzQixZQUFZQSxzQkFBc0IsdUJBQXVCO2dCQUNsSCxNQUFNLElBQUl4dUIsV0FBVTtZQUN0QjtZQUVBLElBQUltTSxNQUFNekgsWUFBWXlILEtBQUtwSCxNQUFNO1lBRWpDLElBQUlxSCxlQUFlRixPQUFPN0wsTUFBTTtZQUNoQyxJQUFJaU0sUUFBUUgsUUFBUSxFQUFFO1lBQ3RCLElBQUlLLFVBQVU7WUFDZCxJQUFJRCxPQUFPO1lBQ1gsSUFBSXloQixRQUFRO1lBQ1osSUFBSXBlLFFBQVE7WUFFWixJQUFJdkQsV0FBVyxNQUFPLEtBQU07Z0JBQzFCdUQsUUFBUWtlLG9CQUFvQjVoQixRQUFRMEQ7Z0JBQ3BDLElBQUlBLFVBQVV4RCxjQUFjO29CQUMxQixJQUFJNGhCLE1BQU0zdEIsTUFBTSxHQUFHLEdBQUc7d0JBQ3BCLElBQUltdUIsc0JBQXNCLHVCQUF1Qjs0QkFDL0M7d0JBQ0Y7d0JBQ0EsSUFBSUEsc0JBQXNCLFNBQVM7NEJBQ2pDLElBQUlSLE1BQU0zdEIsTUFBTSxLQUFLLEdBQUc7Z0NBQ3RCLE1BQU0sSUFBSXlMLGFBQVk7NEJBQ3hCOzRCQUNBVSxVQUFVNmhCLFdBQVcvaEIsT0FBT3loQixrQkFBa0JDLE9BQU90bUIsVUFBVSxRQUFROEU7d0JBQ3pFLE9BQU87NEJBQ0wsTUFBTSxJQUFJVixhQUFZO3dCQUN4QjtvQkFDRjtvQkFDQVMsT0FBT0g7b0JBQ1A7Z0JBQ0Y7Z0JBQ0EsSUFBSXNkLE1BQU1MLEdBQUduZCxRQUFRMEQ7Z0JBQ3JCLEVBQUVBO2dCQUNGLElBQUk4WixRQUFRLEtBQUs7b0JBQ2YsSUFBSXNFLE1BQU0zdEIsTUFBTSxHQUFHLEdBQUc7d0JBQ3BCLE1BQU0sSUFBSXlMLGFBQVk7b0JBQ3hCO29CQUNBOEQsUUFBUWtlLG9CQUFvQjVoQixRQUFRMEQ7b0JBQ3BDLElBQUlvZSxNQUFNM3RCLE1BQU0sS0FBSyxHQUFHO3dCQUN0QixJQUFJdVAsVUFBVXhELGNBQWM7NEJBQzFCLElBQUlvaUIsc0JBQXNCLHVCQUF1QjtnQ0FDL0M7NEJBQ0Y7NEJBQ0EsTUFBTSxJQUFJMWlCLGFBQVk7d0JBQ3hCO3dCQUNBLElBQUl1ZCxHQUFHbmQsUUFBUTBELFdBQVcsS0FBSzs0QkFDN0IsRUFBRUE7NEJBQ0ZBLFFBQVFrZSxvQkFBb0I1aEIsUUFBUTBEO3dCQUN0QztvQkFDRjtvQkFDQSxJQUFJQSxRQUFReEQsY0FBYzt3QkFDeEIsTUFBTSxJQUFJTixhQUFZO29CQUN4QjtvQkFDQVUsVUFBVTZoQixXQUFXL2hCLE9BQU95aEIsa0JBQWtCQyxPQUFPdG1CLFVBQVU4bUIsc0JBQXNCLFdBQVdoaUI7b0JBQ2hHRCxPQUFPSDtvQkFDUDtnQkFDRjtnQkFDQSxJQUFJLENBQUN2SyxPQUFPNkYsVUFBVWdpQixNQUFNO29CQUMxQixNQUFNLElBQUk1ZCxhQUFZO2dCQUN4QjtnQkFDQSxJQUFJMmlCLGlCQUFpQnBpQixZQUFZRztnQkFDakMsSUFBSWlpQixtQkFBbUIsS0FBS1QsTUFBTTN0QixNQUFNLEtBQUssS0FBS291QixtQkFBbUIsS0FBS1QsTUFBTTN0QixNQUFNLEtBQUssR0FBRztvQkFFNUY7Z0JBQ0Y7Z0JBRUEydEIsU0FBU3RFO2dCQUNULElBQUlzRSxNQUFNM3RCLE1BQU0sS0FBSyxHQUFHO29CQUN0Qm1NLFVBQVU2aEIsV0FBVy9oQixPQUFPeWhCLGtCQUFrQkMsT0FBT3RtQixVQUFVLFFBQVE4RTtvQkFDdkV3aEIsUUFBUTtvQkFDUnpoQixPQUFPcUQ7b0JBQ1AsSUFBSXBELFlBQVlILFdBQVc7d0JBQ3pCO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQSxPQUFPO2dCQUFFQyxPQUFPQTtnQkFBT0MsTUFBTUE7Z0JBQU1DLFNBQVNBO1lBQVE7UUFDdEQ7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3BOLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJOFYsYUFBYTlWLGlDQUFtQkEsQ0FBQztRQUNyQyxJQUFJa0IsVUFBVWxCLGlDQUFtQkEsQ0FBQztRQUVsQyxJQUFJK1ksT0FBTWpELFdBQVdpRCxHQUFHO1FBQ3hCLElBQUluQyxNQUFNZCxXQUFXYyxHQUFHO1FBRXhCOVcsT0FBT0ksT0FBTyxHQUFHLFNBQVVvSixHQUFHO1lBQzVCLElBQUlsSCxTQUFTLElBQUkyVztZQUNqQjdYLFFBQVFvSSxLQUFLLFNBQVVuSixFQUFFO2dCQUN2QnlXLElBQUl4VSxRQUFRakM7WUFDZDtZQUNBLE9BQU9pQztRQUNUO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUN0QyxRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSXFDLGNBQWNyQyxpQ0FBbUJBLENBQUM7UUFDdEMsSUFBSStRLFdBQVcvUSxpQ0FBbUJBLENBQUM7UUFFbkMsSUFBSStHLGlCQUFpQjFFLFlBQVksQ0FBQyxFQUFFMEUsY0FBYztRQUVsRCxzQ0FBc0M7UUFDdEMsOENBQThDO1FBQzlDLHVEQUF1RDtRQUN2RGpILE9BQU9JLE9BQU8sR0FBR2tELE9BQU9iLE1BQU0sSUFBSSxTQUFTQSxPQUFPcEMsRUFBRSxFQUFFZ00sR0FBRztZQUN2RCxPQUFPcEYsZUFBZWdLLFNBQVM1USxLQUFLZ007UUFDdEM7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3JNLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJQyxhQUFhRCxpQ0FBbUJBLENBQUM7UUFDckMsSUFBSU8sY0FBY1AsaUNBQW1CQSxDQUFDO1FBRXRDLElBQUlTLGFBQWFDO1FBRWpCLHlDQUF5QztRQUN6Q1osT0FBT0ksT0FBTyxHQUFHLFNBQVVTLFFBQVE7WUFDakMsSUFBSVYsV0FBV1UsV0FBVyxPQUFPQTtZQUNqQyxNQUFNLElBQUlGLFdBQVdGLFlBQVlJLFlBQVk7UUFDL0M7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ0sseUJBQXlCakIsMEJBQTBCQyxpQ0FBbUJBO1FBRzlFLElBQUlpQixJQUFJakIsaUNBQW1CQSxDQUFDO1FBQzVCLElBQUlJLE9BQU9KLGlDQUFtQkEsQ0FBQztRQUMvQixJQUFJTSxXQUFXTixpQ0FBbUJBLENBQUM7UUFDbkMsSUFBSW1CLG9CQUFvQm5CLGlDQUFtQkEsQ0FBQztRQUM1QyxJQUFJb2YsVUFBVXBmLGlDQUFtQkEsQ0FBQztRQUNsQyxJQUFJcWYsb0JBQW9CcmYsaUNBQW1CQSxDQUFDO1FBQzVDLElBQUlvQixnQkFBZ0JwQixpQ0FBbUJBLENBQUM7UUFDeEMsSUFBSW1HLHNCQUFzQm5HLGlDQUFtQkEsQ0FBQztRQUM5QyxJQUFJcUcsd0NBQXdDckcsaUNBQW1CQSxDQUFDO1FBQ2hFLElBQUlxQiwyQ0FBMkNyQixpQ0FBbUJBLENBQUM7UUFDbkUsSUFBSW9HLFVBQVVwRyxpQ0FBbUJBLENBQUM7UUFFbEMsSUFBSW92Qiw0Q0FBNEMsQ0FBQ2hwQixXQUFXLENBQUNDLHNDQUFzQyxRQUFRO1FBQzNHLElBQUlncEIsaUNBQWlDLENBQUNqcEIsV0FBVyxDQUFDZ3BCLDZDQUM3Qy90Qix5Q0FBeUMsUUFBUTRSO1FBRXRELElBQUl6TSxTQUFTSixXQUFXZ3BCLDZDQUE2Q0M7UUFFckUsSUFBSTVvQixnQkFBZ0JOLG9CQUFvQjtZQUN0QyxJQUFJTCxXQUFXLElBQUksQ0FBQ0EsUUFBUTtZQUM1QixJQUFJQyxPQUFPLElBQUksQ0FBQ0EsSUFBSTtZQUNwQixJQUFJM0QsUUFBUTZEO1lBQ1osTUFBTyxJQUFJLENBQUNzWixTQUFTLENBQUU7Z0JBQ3JCLElBQUksQ0FBQ0EsU0FBUztnQkFDZG5kLFNBQVM5QixTQUFTRixLQUFLMkYsTUFBTUQ7Z0JBQzdCRyxPQUFPLElBQUksQ0FBQ0EsSUFBSSxHQUFHLENBQUMsQ0FBQzdELE9BQU82RCxJQUFJO2dCQUNoQyxJQUFJQSxNQUFNO1lBQ1o7WUFDQTdELFNBQVM5QixTQUFTRixLQUFLMkYsTUFBTUQ7WUFDN0JHLE9BQU8sSUFBSSxDQUFDQSxJQUFJLEdBQUcsQ0FBQyxDQUFDN0QsT0FBTzZELElBQUk7WUFDaEMsSUFBSSxDQUFDQSxNQUFNLE9BQU83RCxPQUFPSixLQUFLO1FBQ2hDO1FBRUEsbUNBQW1DO1FBQ25DLHVEQUF1RDtRQUN2RGYsRUFBRTtZQUFFTSxRQUFRO1lBQVlDLE9BQU87WUFBTUMsTUFBTTtZQUFNQyxRQUFROEU7UUFBTyxHQUFHO1lBQ2pFOG9CLE1BQU0sU0FBU0EsS0FBSzdQLEtBQUs7Z0JBQ3ZCbmYsU0FBUyxJQUFJO2dCQUNiLElBQUlpZjtnQkFDSixJQUFJO29CQUNGQSxZQUFZRixrQkFBa0JELFFBQVEsQ0FBQ0s7Z0JBQ3pDLEVBQUUsT0FBTzVkLE9BQU87b0JBQ2RULGNBQWMsSUFBSSxFQUFFLFNBQVNTO2dCQUMvQjtnQkFFQSxJQUFJd3RCLGdDQUFnQyxPQUFPanZCLEtBQUtpdkIsZ0NBQWdDLElBQUksRUFBRTlQO2dCQUV0RixPQUFPLElBQUk5WSxjQUFjdEYsa0JBQWtCLElBQUksR0FBRztvQkFDaERvZSxXQUFXQTtnQkFDYjtZQUNGO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3pmLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJa0YsY0FBYWxGLGlDQUFtQkEsQ0FBQztRQUNyQyxJQUFJdXZCLFVBQVV2dkIsaUNBQW1CQSxDQUFDO1FBRWxDRixPQUFPSSxPQUFPLEdBQUcsU0FBVTJELElBQUk7WUFDN0IsSUFBSTByQixTQUFTO2dCQUNYLElBQUk7b0JBQ0YsT0FBT3JxQixZQUFXb1QsT0FBTyxDQUFDa1gsZ0JBQWdCLENBQUMzckI7Z0JBQzdDLEVBQUUsT0FBT2hDLE9BQU8sQ0FBYztnQkFDOUIsSUFBSTtvQkFDRiwrQ0FBK0M7b0JBQy9DLE9BQU80QyxTQUFTLHFCQUFxQlosT0FBTztnQkFDOUMsRUFBRSxPQUFPaEMsT0FBTyxDQUFjO1lBQ2hDO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2IseUJBQXlCakIsMEJBQTBCQyxpQ0FBbUJBO1FBRzlFLGdDQUFnQztRQUNoQ0EsaUNBQW1CQSxDQUFDO0lBR3BCLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDRixRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSWtGLGNBQWFsRixpQ0FBbUJBLENBQUM7UUFFckMsK0RBQStEO1FBQy9ELElBQUltRCxpQkFBaUJDLE9BQU9ELGNBQWM7UUFFMUNyRCxPQUFPSSxPQUFPLEdBQUcsU0FBVWlNLEdBQUcsRUFBRW5LLEtBQUs7WUFDbkMsSUFBSTtnQkFDRm1CLGVBQWUrQixhQUFZaUgsS0FBSztvQkFBRW5LLE9BQU9BO29CQUFPaUMsY0FBYztvQkFBTUcsVUFBVTtnQkFBSztZQUNyRixFQUFFLE9BQU92QyxPQUFPO2dCQUNkcUQsV0FBVSxDQUFDaUgsSUFBSSxHQUFHbks7WUFDcEI7WUFBRSxPQUFPQTtRQUNYO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNsQyxRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSUksT0FBT0osaUNBQW1CQSxDQUFDO1FBQy9CLElBQUltUCxTQUFTblAsaUNBQW1CQSxDQUFDO1FBQ2pDLElBQUlnSiw4QkFBOEJoSixpQ0FBbUJBLENBQUM7UUFDdEQsSUFBSXl2QixpQkFBaUJ6dkIsaUNBQW1CQSxDQUFDO1FBQ3pDLElBQUlrSSxrQkFBa0JsSSxpQ0FBbUJBLENBQUM7UUFDMUMsSUFBSTRDLHNCQUFzQjVDLGlDQUFtQkEsQ0FBQztRQUM5QyxJQUFJK0gsWUFBWS9ILGlDQUFtQkEsQ0FBQztRQUNwQyxJQUFJbWEsb0JBQXFCbmEsaUNBQW1CQSxDQUFDLE1BQU1tYSxpQkFBaUI7UUFDcEUsSUFBSXVWLHlCQUF5QjF2QixpQ0FBbUJBLENBQUM7UUFDakQsSUFBSW9CLGdCQUFnQnBCLGlDQUFtQkEsQ0FBQztRQUN4QyxJQUFJMnZCLG1CQUFtQjN2QixpQ0FBbUJBLENBQUM7UUFFM0MsSUFBSXFNLGdCQUFnQm5FLGdCQUFnQjtRQUNwQyxJQUFJMG5CLGtCQUFrQjtRQUN0QixJQUFJQywwQkFBMEI7UUFDOUIsSUFBSUMsU0FBUztRQUNiLElBQUlDLFFBQVE7UUFDWixJQUFJQyxtQkFBbUJwdEIsb0JBQW9CMEcsR0FBRztRQUU5QyxJQUFJMm1CLCtCQUErQixTQUFVN2YsV0FBVztZQUN0RCxJQUFJck4sbUJBQW1CSCxvQkFBb0I0RyxTQUFTLENBQUM0RyxjQUFjeWYsMEJBQTBCRDtZQUU3RixPQUFPSCxlQUFldGdCLE9BQU9nTCxvQkFBb0I7Z0JBQy9DcFUsTUFBTSxTQUFTQTtvQkFDYixJQUFJeEIsUUFBUXhCLGlCQUFpQixJQUFJO29CQUNqQyxzQkFBc0I7b0JBQ3RCLGdJQUFnSTtvQkFDaEksd0RBQXdEO29CQUN4RCxJQUFJcU4sYUFBYSxPQUFPN0wsTUFBTTJyQixXQUFXO29CQUN6QyxJQUFJM3JCLE1BQU0wQixJQUFJLEVBQUUsT0FBT3lwQix1QkFBdUJwckIsV0FBVztvQkFDekQsSUFBSTt3QkFDRixJQUFJbEMsU0FBU21DLE1BQU0yckIsV0FBVzt3QkFDOUIsT0FBTzNyQixNQUFNNHJCLG1CQUFtQixHQUFHL3RCLFNBQVNzdEIsdUJBQXVCdHRCLFFBQVFtQyxNQUFNMEIsSUFBSTtvQkFDdkYsRUFBRSxPQUFPcEUsT0FBTzt3QkFDZDBDLE1BQU0wQixJQUFJLEdBQUc7d0JBQ2IsTUFBTXBFO29CQUNSO2dCQUNGO2dCQUNBLFVBQVU7b0JBQ1IsSUFBSTBDLFFBQVF4QixpQkFBaUIsSUFBSTtvQkFDakMsSUFBSStDLFdBQVd2QixNQUFNdUIsUUFBUTtvQkFDN0J2QixNQUFNMEIsSUFBSSxHQUFHO29CQUNiLElBQUltSyxhQUFhO3dCQUNmLElBQUlnZ0IsZUFBZXJvQixVQUFVakMsVUFBVTt3QkFDdkMsT0FBT3NxQixlQUFlaHdCLEtBQUtnd0IsY0FBY3RxQixZQUFZNHBCLHVCQUF1QnByQixXQUFXO29CQUN6RjtvQkFDQSxJQUFJQyxNQUFNb0MsS0FBSyxFQUFFLElBQUk7d0JBQ25CdkYsY0FBY21ELE1BQU1vQyxLQUFLLENBQUNiLFFBQVEsRUFBRWdxQjtvQkFDdEMsRUFBRSxPQUFPanVCLE9BQU87d0JBQ2QsT0FBT1QsY0FBYzBFLFVBQVVpcUIsT0FBT2x1QjtvQkFDeEM7b0JBQ0EsSUFBSTBDLE1BQU04ckIsU0FBUyxFQUFFLElBQUk7d0JBQ3ZCVixpQkFBaUJwckIsTUFBTThyQixTQUFTLEVBQUVQO29CQUNwQyxFQUFFLE9BQU9qdUIsT0FBTzt3QkFDZCxPQUFPVCxjQUFjMEUsVUFBVWlxQixPQUFPbHVCO29CQUN4QztvQkFDQSxJQUFJaUUsVUFBVTFFLGNBQWMwRSxVQUFVZ3FCO29CQUN0QyxPQUFPSix1QkFBdUJwckIsV0FBVztnQkFDM0M7WUFDRjtRQUNGO1FBRUEsSUFBSWdzQixnQ0FBZ0NMLDZCQUE2QjtRQUNqRSxJQUFJTSwwQkFBMEJOLDZCQUE2QjtRQUUzRGpuQiw0QkFBNEJ1bkIseUJBQXlCbGtCLGVBQWU7UUFFcEV2TSxPQUFPSSxPQUFPLEdBQUcsU0FBVWd3QixXQUFXLEVBQUU5ZixXQUFXLEVBQUVvZ0IscUJBQXFCO1lBQ3hFLElBQUkvcEIsZ0JBQWdCLFNBQVNZLFVBQVN2RixNQUFNLEVBQUV5QyxLQUFLO2dCQUNqRCxJQUFJQSxPQUFPO29CQUNUQSxNQUFNdUIsUUFBUSxHQUFHaEUsT0FBT2dFLFFBQVE7b0JBQ2hDdkIsTUFBTXdCLElBQUksR0FBR2pFLE9BQU9pRSxJQUFJO2dCQUMxQixPQUFPeEIsUUFBUXpDO2dCQUNmeUMsTUFBTW1GLElBQUksR0FBRzBHLGNBQWN5ZiwwQkFBMEJEO2dCQUNyRHJyQixNQUFNNHJCLG1CQUFtQixHQUFHLENBQUMsQ0FBQ0s7Z0JBQzlCanNCLE1BQU0yckIsV0FBVyxHQUFHQTtnQkFDcEIzckIsTUFBTXhDLE9BQU8sR0FBRztnQkFDaEJ3QyxNQUFNMEIsSUFBSSxHQUFHO2dCQUNiK3BCLGlCQUFpQixJQUFJLEVBQUV6ckI7WUFDekI7WUFFQWtDLGNBQWNwQyxTQUFTLEdBQUcrTCxjQUFja2dCLGdDQUFnQ0M7WUFFeEUsT0FBTzlwQjtRQUNUO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUN6Rix5QkFBeUJqQiwwQkFBMEJDLGlDQUFtQkE7UUFHOUUsSUFBSWlCLElBQUlqQixpQ0FBbUJBLENBQUM7UUFDNUIsSUFBSWtGLGNBQWFsRixpQ0FBbUJBLENBQUM7UUFDckMsSUFBSXFDLGNBQWNyQyxpQ0FBbUJBLENBQUM7UUFDdEMsSUFBSXF1QixzQkFBc0JydUIsaUNBQW1CQSxDQUFDO1FBQzlDLElBQUltRixlQUFlbkYsaUNBQW1CQSxDQUFDO1FBQ3ZDLElBQUlvRixjQUFjcEYsaUNBQW1CQSxDQUFDO1FBQ3RDLElBQUlzdUIsWUFBWXR1QixpQ0FBbUJBLENBQUM7UUFDcEMsSUFBSXV1QixvQkFBb0J2dUIsaUNBQW1CQSxDQUFDO1FBRTVDLElBQUk0UixpQkFBaUIwYyxVQUFVcmMsR0FBRztRQUNsQyxJQUFJSixvQkFBb0J5YyxVQUFVbmMsTUFBTTtRQUV4QyxJQUFJSCxTQUFTM1AsWUFBWSxHQUFHMlAsTUFBTTtRQUVsQyxJQUFJMU0sY0FBYUosWUFBV0ksVUFBVTtRQUV0QyxJQUFJQyxzQ0FBc0MsQ0FBQ0QsZUFBYyxDQUFDQSxZQUFXakIsU0FBUyxDQUFDb3NCLFFBQVEsSUFBSSxDQUFDO1lBQzFGLElBQUk7Z0JBQ0YsSUFBSWx2QixTQUFTLElBQUkrRDtnQkFDakIvRCxPQUFPa3ZCLFFBQVEsQ0FBQztZQUNsQixFQUFFLE9BQU81dUIsT0FBTztnQkFDZCxPQUFPO1lBQ1Q7UUFDRjtRQUVBLHlDQUF5QztRQUN6QyxzREFBc0Q7UUFDdEQsSUFBSXlELGFBQVlyRSxFQUFFO1lBQUVNLFFBQVE7WUFBY0MsT0FBTztZQUFNRSxRQUFRNkQ7UUFBb0MsR0FBRztZQUNwR2tyQixVQUFVLFNBQVNBO2dCQUNqQixJQUFJL0QsUUFBUXZuQixhQUFhLElBQUk7Z0JBQzdCLElBQUlyQixVQUFVaEQsVUFBVUMsTUFBTSxHQUFHc3RCLG9CQUFvQnZ0QixTQUFTLENBQUMsRUFBRSxJQUFJd0Q7Z0JBQ3JFLElBQUk4RCxXQUFXbW1CLGtCQUFrQnpxQixhQUFhLFdBQVc4TixpQkFBaUJDO2dCQUMxRSxJQUFJNmUsY0FBYyxDQUFDLENBQUM1c0IsV0FBVyxDQUFDLENBQUNBLFFBQVE0c0IsV0FBVztnQkFDcER0ckIsWUFBWSxJQUFJLENBQUNLLE1BQU07Z0JBRXZCLElBQUlyRCxTQUFTO2dCQUNiLElBQUlzRCxJQUFJO2dCQUNSLElBQUkzRSxTQUFTMnJCLE1BQU0zckIsTUFBTTtnQkFDekIsSUFBSTh0QjtnQkFFSixJQUFJOUUsS0FBSyxTQUFVNEcsS0FBSztvQkFDdEIsT0FBTzNlLE9BQU81SixVQUFVLFdBQWEsSUFBSXVvQixRQUFVO2dCQUNyRDtnQkFFQSxNQUFPanJCLElBQUksSUFBSTNFLFFBQVEyRSxLQUFLLEVBQUc7b0JBQzdCbXBCLFVBQVUsQ0FBQ25DLEtBQUssQ0FBQ2huQixFQUFFLElBQUksRUFBQyxJQUFNZ25CLENBQUFBLEtBQUssQ0FBQ2huQixJQUFJLEVBQUUsSUFBSSxLQUFLZ25CLEtBQUssQ0FBQ2huQixJQUFJLEVBQUU7b0JBQy9EdEQsVUFBVTJuQixHQUFHLEtBQUtBLEdBQUcsS0FBS0EsR0FBRyxLQUFLQSxHQUFHO2dCQUN2QztnQkFDQSxJQUFJcmtCLElBQUksTUFBTTNFLFFBQVE7b0JBQ3BCOHRCLFVBQVUsQ0FBQ25DLEtBQUssQ0FBQ2huQixFQUFFLElBQUksRUFBQyxJQUFNZ25CLENBQUFBLEtBQUssQ0FBQ2huQixJQUFJLEVBQUUsSUFBSTtvQkFDOUN0RCxVQUFVMm5CLEdBQUcsS0FBS0EsR0FBRyxLQUFLQSxHQUFHLEtBQU0yRyxDQUFBQSxjQUFjLEtBQUssR0FBRTtnQkFDMUQsT0FBTyxJQUFJaHJCLElBQUksTUFBTTNFLFFBQVE7b0JBQzNCOHRCLFVBQVVuQyxLQUFLLENBQUNobkIsRUFBRSxJQUFJO29CQUN0QnRELFVBQVUybkIsR0FBRyxLQUFLQSxHQUFHLEtBQU0yRyxDQUFBQSxjQUFjLEtBQUssSUFBRztnQkFDbkQ7Z0JBRUEsT0FBT3R1QjtZQUNUO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3RDLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJcWxCLGNBQWNybEIsaUNBQW1CQSxDQUFDO1FBRXRDLElBQUkyRSxvQkFBb0JGLFNBQVNKLFNBQVM7UUFDMUMsSUFBSWpFLE9BQU91RSxrQkFBa0J2RSxJQUFJO1FBQ2pDLGlFQUFpRTtRQUNqRSxJQUFJd3dCLHNCQUFzQnZMLGVBQWUxZ0Isa0JBQWtCbUMsSUFBSSxDQUFDQSxJQUFJLENBQUMxRyxNQUFNQTtRQUUzRU4sT0FBT0ksT0FBTyxHQUFHbWxCLGNBQWN1TCxzQkFBc0IsU0FBVWhyQixFQUFFO1lBQy9ELE9BQU87Z0JBQ0wsT0FBT3hGLEtBQUtxSyxLQUFLLENBQUM3RSxJQUFJOUU7WUFDeEI7UUFDRjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDaEIsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlrRixjQUFhbEYsaUNBQW1CQSxDQUFDO1FBQ3JDLElBQUl3UyxZQUFZeFMsaUNBQW1CQSxDQUFDO1FBRXBDLElBQUlzWSxXQUFVcFQsWUFBV29ULE9BQU87UUFDaEMsSUFBSUQsUUFBT25ULFlBQVdtVCxJQUFJO1FBQzFCLElBQUkyUCxXQUFXMVAsWUFBV0EsU0FBUTBQLFFBQVEsSUFBSTNQLFNBQVFBLE1BQUtELE9BQU87UUFDbEUsSUFBSXlZLEtBQUs3SSxZQUFZQSxTQUFTNkksRUFBRTtRQUNoQyxJQUFJQyxPQUFPMVk7UUFFWCxJQUFJeVksSUFBSTtZQUNOQyxRQUFRRCxHQUFHbHRCLEtBQUssQ0FBQztZQUNqQix1REFBdUQ7WUFDdkQsd0RBQXdEO1lBQ3hEeVUsVUFBVTBZLEtBQUssQ0FBQyxFQUFFLEdBQUcsS0FBS0EsS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLElBQUksQ0FBRUEsQ0FBQUEsS0FBSyxDQUFDLEVBQUUsR0FBR0EsS0FBSyxDQUFDLEVBQUU7UUFDcEU7UUFFQSxxRUFBcUU7UUFDckUsbURBQW1EO1FBQ25ELElBQUksQ0FBQzFZLFdBQVc1RixXQUFXO1lBQ3pCc2UsUUFBUXRlLFVBQVVzZSxLQUFLLENBQUM7WUFDeEIsSUFBSSxDQUFDQSxTQUFTQSxLQUFLLENBQUMsRUFBRSxJQUFJLElBQUk7Z0JBQzVCQSxRQUFRdGUsVUFBVXNlLEtBQUssQ0FBQztnQkFDeEIsSUFBSUEsT0FBTzFZLFVBQVUsQ0FBQzBZLEtBQUssQ0FBQyxFQUFFO1lBQ2hDO1FBQ0Y7UUFFQWh4QixPQUFPSSxPQUFPLEdBQUdrWTtJQUdqQixHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3RZLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJSSxPQUFPSixpQ0FBbUJBLENBQUM7UUFDL0IsSUFBSU0sV0FBV04saUNBQW1CQSxDQUFDO1FBQ25DLElBQUkrSCxZQUFZL0gsaUNBQW1CQSxDQUFDO1FBRXBDRixPQUFPSSxPQUFPLEdBQUcsU0FBVTRGLFFBQVEsRUFBRW1FLElBQUksRUFBRWpJLEtBQUs7WUFDOUMsSUFBSSt1QixhQUFhQztZQUNqQjF3QixTQUFTd0Y7WUFDVCxJQUFJO2dCQUNGaXJCLGNBQWNocEIsVUFBVWpDLFVBQVU7Z0JBQ2xDLElBQUksQ0FBQ2lyQixhQUFhO29CQUNoQixJQUFJOW1CLFNBQVMsU0FBUyxNQUFNakk7b0JBQzVCLE9BQU9BO2dCQUNUO2dCQUNBK3VCLGNBQWMzd0IsS0FBSzJ3QixhQUFhanJCO1lBQ2xDLEVBQUUsT0FBT2pFLE9BQU87Z0JBQ2RtdkIsYUFBYTtnQkFDYkQsY0FBY2x2QjtZQUNoQjtZQUNBLElBQUlvSSxTQUFTLFNBQVMsTUFBTWpJO1lBQzVCLElBQUlndkIsWUFBWSxNQUFNRDtZQUN0Qnp3QixTQUFTeXdCO1lBQ1QsT0FBTy91QjtRQUNUO0lBR0EsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUNsQyxRQUFRQywwQkFBMEJDLGlDQUFtQkE7UUFHN0QsSUFBSXFsQixjQUFjcmxCLGlDQUFtQkEsQ0FBQztRQUV0QyxJQUFJSSxPQUFPcUUsU0FBU0osU0FBUyxDQUFDakUsSUFBSTtRQUNsQyxpRUFBaUU7UUFDakVOLE9BQU9JLE9BQU8sR0FBR21sQixjQUFjamxCLEtBQUswRyxJQUFJLENBQUMxRyxRQUFRO1lBQy9DLE9BQU9BLEtBQUtxSyxLQUFLLENBQUNySyxNQUFNVTtRQUMxQjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDRSx5QkFBeUJqQiwwQkFBMEJDLGlDQUFtQkE7UUFHOUUsSUFBSWl4QixZQUFZanhCLGlDQUFtQkEsQ0FBQztRQUNwQyxJQUFJa3hCLHNCQUFzQmx4QixpQ0FBbUJBLENBQUM7UUFDOUMsSUFBSW14QixnQkFBZ0JueEIsaUNBQW1CQSxDQUFDO1FBQ3hDLElBQUlpWCxzQkFBc0JqWCxpQ0FBbUJBLENBQUM7UUFDOUMsSUFBSW94QixXQUFXcHhCLGlDQUFtQkEsQ0FBQztRQUVuQyxJQUFJd2QsY0FBYzBULG9CQUFvQjFULFdBQVc7UUFDakQsSUFBSUYsMkJBQTJCNFQsb0JBQW9CNVQsd0JBQXdCO1FBQzNFLElBQUlLLHlCQUF5QnVULG9CQUFvQnZULHNCQUFzQjtRQUV2RSxJQUFJMFQsZUFBZTtZQUNqQixJQUFJO2dCQUNGLG9IQUFvSDtnQkFDcEgsSUFBSXZWLFVBQVUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHO29CQUFFbEQsU0FBUzt3QkFBYyxNQUFNO29CQUFHO2dCQUFFO1lBQ2xFLEVBQUUsT0FBTy9XLE9BQU87Z0JBQ2QsOEVBQThFO2dCQUM5RSxnRUFBZ0U7Z0JBQ2hFLE9BQU9BLFVBQVU7WUFDbkI7UUFDRjtRQUVBLHFHQUFxRztRQUNyRyxJQUFJeXZCLHFDQUFxQ0QsZ0JBQWdCO1lBQ3ZELElBQUk7Z0JBQ0Ysa0dBQWtHO2dCQUNsRyxJQUFJdlYsVUFBVSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSztZQUNqQyxFQUFFLE9BQU9qYSxPQUFPO2dCQUNkLE9BQU87WUFDVDtRQUNGO1FBRUEsdUNBQXVDO1FBQ3ZDLDJEQUEyRDtRQUMzRDhiLHVCQUF1QixRQUFRO1lBQUUsUUFBUSxTQUFVck4sS0FBSyxFQUFFdE8sS0FBSztnQkFDN0QsSUFBSXdHLElBQUlnVixZQUFZLElBQUk7Z0JBQ3hCLElBQUkrVCxnQkFBZ0J0YSxvQkFBb0IzRztnQkFDeEMsSUFBSWtoQixjQUFjTCxjQUFjM29CLEtBQUs0b0IsU0FBU3B2QixTQUFTLENBQUNBO2dCQUN4RCxPQUFPaXZCLFVBQVV6b0IsR0FBRzhVLHlCQUF5QjlVLElBQUkrb0IsZUFBZUM7WUFDbEU7UUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUNILGdCQUFnQkM7SUFHOUIsR0FBRyxHQUFHO0lBRU4sR0FBRyxHQUFHLE1BQ04sR0FBRyxHQUFJLENBQUN4eEIsUUFBUUMsMEJBQTBCQyxpQ0FBbUJBO1FBRzdELElBQUlpWCxzQkFBc0JqWCxpQ0FBbUJBLENBQUM7UUFFOUMsSUFBSWdULGNBQWNDO1FBRWxCblQsT0FBT0ksT0FBTyxHQUFHLFNBQVVDLEVBQUU7WUFDM0IsSUFBSWlDLFNBQVM2VSxvQkFBb0I5VztZQUNqQyxJQUFJaUMsU0FBUyxHQUFHLE1BQU0sSUFBSTRRLFlBQVk7WUFDdEMsT0FBTzVRO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ3RDLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJOEwsa0JBQWtCOUwsaUNBQW1CQSxDQUFDO1FBQzFDLElBQUl5eEIsa0JBQWtCenhCLGlDQUFtQkEsQ0FBQztRQUMxQyxJQUFJNFAsb0JBQW9CNVAsaUNBQW1CQSxDQUFDO1FBRTVDLGlFQUFpRTtRQUNqRSxJQUFJMHhCLGVBQWUsU0FBVUMsV0FBVztZQUN0QyxPQUFPLFNBQVV6YyxLQUFLLEVBQUUwYyxFQUFFLEVBQUVDLFNBQVM7Z0JBQ25DLElBQUlycEIsSUFBSXNELGdCQUFnQm9KO2dCQUN4QixJQUFJblUsU0FBUzZPLGtCQUFrQnBIO2dCQUMvQixJQUFJekgsV0FBVyxHQUFHLE9BQU8sQ0FBQzR3QixlQUFlLENBQUM7Z0JBQzFDLElBQUlyaEIsUUFBUW1oQixnQkFBZ0JJLFdBQVc5d0I7Z0JBQ3ZDLElBQUlpQjtnQkFDSix1REFBdUQ7Z0JBQ3ZELHdEQUF3RDtnQkFDeEQsSUFBSTJ2QixlQUFlQyxPQUFPQSxJQUFJLE1BQU83d0IsU0FBU3VQLE1BQU87b0JBQ25EdE8sUUFBUXdHLENBQUMsQ0FBQzhILFFBQVE7b0JBQ2xCLHdEQUF3RDtvQkFDeEQsSUFBSXRPLFVBQVVBLE9BQU8sT0FBTztnQkFDOUIsb0RBQW9EO2dCQUNwRDtxQkFBTyxNQUFNakIsU0FBU3VQLE9BQU9BLFFBQVM7b0JBQ3BDLElBQUksQ0FBQ3FoQixlQUFlcmhCLFNBQVM5SCxDQUFBQSxLQUFNQSxDQUFDLENBQUM4SCxNQUFNLEtBQUtzaEIsSUFBSSxPQUFPRCxlQUFlcmhCLFNBQVM7Z0JBQ3JGO2dCQUFFLE9BQU8sQ0FBQ3FoQixlQUFlLENBQUM7WUFDNUI7UUFDRjtRQUVBN3hCLE9BQU9JLE9BQU8sR0FBRztZQUNmLG9DQUFvQztZQUNwQyx3REFBd0Q7WUFDeERzVyxVQUFVa2IsYUFBYTtZQUN2QixtQ0FBbUM7WUFDbkMsdURBQXVEO1lBQ3ZEM2xCLFNBQVMybEIsYUFBYTtRQUN4QjtJQUdBLEdBQUcsR0FBRztJQUVOLEdBQUcsR0FBRyxNQUNOLEdBQUcsR0FBSSxDQUFDMXdCLHlCQUF5QmpCLDBCQUEwQkMsaUNBQW1CQTtRQUc5RSxnQ0FBZ0M7UUFDaENBLGlDQUFtQkEsQ0FBQztJQUdwQixHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ2dCLHlCQUF5QmpCLDBCQUEwQkMsaUNBQW1CQTtRQUc5RSxnQ0FBZ0M7UUFDaENBLGlDQUFtQkEsQ0FBQztJQUdwQixHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQ0Y7UUFHUixzRUFBc0U7UUFDdEUsaURBQWlEO1FBQ2pEQSxPQUFPSSxPQUFPLEdBQUcsU0FBVStaLFdBQVc7WUFDcEMsSUFBSTtnQkFDRix3REFBd0Q7Z0JBQ3hELElBQUlxTyxVQUFVLElBQUl2UDtnQkFDbEIsSUFBSXNQLFVBQVU7b0JBQ1p0UyxNQUFNO29CQUNOeE0sS0FBSzt3QkFBYyxPQUFPO29CQUFNO29CQUNoQ2hCLE1BQU07d0JBQ0osMEVBQTBFO3dCQUMxRSxPQUFPbkYsT0FBT0QsY0FBYyxDQUFDLENBQUMsR0FBRyxRQUFROzRCQUN2Q0gsS0FBSztnQ0FDSHNsQixRQUFRQyxLQUFLO2dDQUNiRCxRQUFRMVIsR0FBRyxDQUFDO2dDQUNaLE9BQU87b0NBQ0wsT0FBTzt3Q0FBRTNRLE1BQU07b0NBQUs7Z0NBQ3RCOzRCQUNGO3dCQUNGO29CQUNGO2dCQUNGO2dCQUNBLElBQUk3RCxTQUFTa21CLE9BQU8sQ0FBQ3JPLFlBQVksQ0FBQ29PO2dCQUVsQyxPQUFPam1CLE9BQU8yVCxJQUFJLEtBQUssS0FBSzNULE9BQU95bEIsTUFBTSxHQUFHOWhCLElBQUksR0FBRy9ELEtBQUssS0FBSztZQUMvRCxFQUFFLE9BQU9ILE9BQU87Z0JBQ2QsT0FBTztZQUNUO1FBQ0Y7SUFHQSxHQUFHLEdBQUc7SUFFTixHQUFHLEdBQUcsTUFDTixHQUFHLEdBQUksQ0FBQy9CLFFBQVFDLDBCQUEwQkMsaUNBQW1CQTtRQUc3RCxJQUFJNFAsb0JBQW9CNVAsaUNBQW1CQSxDQUFDO1FBQzVDLElBQUlpWCxzQkFBc0JqWCxpQ0FBbUJBLENBQUM7UUFFOUMsSUFBSWdULGNBQWNDO1FBRWxCLG9EQUFvRDtRQUNwRCwyREFBMkQ7UUFDM0RuVCxPQUFPSSxPQUFPLEdBQUcsU0FBVXNJLENBQUMsRUFBRWtWLENBQUMsRUFBRXBOLEtBQUssRUFBRXRPLEtBQUs7WUFDM0MsSUFBSStWLE1BQU1uSSxrQkFBa0JwSDtZQUM1QixJQUFJK29CLGdCQUFnQnRhLG9CQUFvQjNHO1lBQ3hDLElBQUl3aEIsY0FBY1AsZ0JBQWdCLElBQUl4WixNQUFNd1osZ0JBQWdCQTtZQUM1RCxJQUFJTyxlQUFlL1osT0FBTytaLGNBQWMsR0FBRyxNQUFNLElBQUk5ZSxZQUFZO1lBQ2pFLElBQUkrZSxJQUFJLElBQUlyVSxFQUFFM0Y7WUFDZCxJQUFJcUQsSUFBSTtZQUNSLE1BQU9BLElBQUlyRCxLQUFLcUQsSUFBSzJXLENBQUMsQ0FBQzNXLEVBQUUsR0FBR0EsTUFBTTBXLGNBQWM5dkIsUUFBUXdHLENBQUMsQ0FBQzRTLEVBQUU7WUFDNUQsT0FBTzJXO1FBQ1Q7SUFHQSxHQUFHLEdBQUc7QUFFRztBQUNULHdFQUF3RSxHQUN4RSxNQUFNLEdBQUcsbUJBQW1CO0FBQzVCLE1BQU0sR0FBRyxJQUFJQywyQkFBMkIsQ0FBQztBQUN6QyxNQUFNLEdBQ04sTUFBTSxHQUFHLHVCQUF1QjtBQUNoQyxNQUFNLEdBQUcsU0FBU2h5QixpQ0FBbUJBLENBQUNpeUIsUUFBUTtJQUM5QyxNQUFNLEdBQUksOEJBQThCO0lBQ3hDLE1BQU0sR0FBSSxJQUFJQyxlQUFlRix3QkFBd0IsQ0FBQ0MsU0FBUztJQUMvRCxNQUFNLEdBQUksSUFBSUMsaUJBQWlCNXRCLFdBQVc7UUFDMUMsTUFBTSxHQUFLLE9BQU80dEIsYUFBYWh5QixPQUFPO0lBQ3RDLE1BQU0sR0FBSTtJQUNWLE1BQU0sR0FBSSxrREFBa0Q7SUFDNUQsTUFBTSxHQUFJLElBQUlKLFNBQVNreUIsd0JBQXdCLENBQUNDLFNBQVMsR0FBRztRQUM1RCxNQUFNLEdBQUssc0JBQXNCO1FBQ2pDLE1BQU0sR0FBSywwQkFBMEI7UUFDckMsTUFBTSxHQUFLL3hCLFNBQVMsQ0FBQztJQUNYO0lBQ1YsTUFBTSxHQUNOLE1BQU0sR0FBSSw4QkFBOEI7SUFDeEMsTUFBTSxHQUFJTCxtQkFBbUIsQ0FBQ295QixTQUFTLENBQUM3eEIsSUFBSSxDQUFDTixPQUFPSSxPQUFPLEVBQUVKLFFBQVFBLE9BQU9JLE9BQU8sRUFBRUYsaUNBQW1CQTtJQUN4RyxNQUFNLEdBQ04sTUFBTSxHQUFJLG1DQUFtQztJQUM3QyxNQUFNLEdBQUksT0FBT0YsT0FBT0ksT0FBTztBQUMvQixNQUFNLEdBQUc7QUFDVCxNQUFNLEdBQ04sd0VBQXdFLEdBQ3hFLE1BQU0sR0FBRywyQ0FBMkMsR0FDcEQsTUFBTSxHQUFJO0lBQ1YsTUFBTSxHQUFJLDhDQUE4QztJQUN4RCxNQUFNLEdBQUlGLGlDQUFtQkEsQ0FBQ215QixDQUFDLEdBQUcsQ0FBQ2p5QixTQUFTa3lCO1FBQzVDLE1BQU0sR0FBSyxJQUFJLElBQUlqbUIsT0FBT2ltQixXQUFZO1lBQ3RDLE1BQU0sR0FBTSxJQUFHcHlCLGlDQUFtQkEsQ0FBQ3F5QixDQUFDLENBQUNELFlBQVlqbUIsUUFBUSxDQUFDbk0saUNBQW1CQSxDQUFDcXlCLENBQUMsQ0FBQ255QixTQUFTaU0sTUFBTTtnQkFDL0YsTUFBTSxHQUFPL0ksT0FBT0QsY0FBYyxDQUFDakQsU0FBU2lNLEtBQUs7b0JBQUVzUCxZQUFZO29CQUFNelksS0FBS292QixVQUFVLENBQUNqbUIsSUFBSTtnQkFBQztZQUMxRixNQUFNLEdBQU07UUFDWixNQUFNLEdBQUs7SUFDWCxNQUFNLEdBQUk7QUFDVixNQUFNLEdBQUc7QUFDVCxNQUFNLEdBQ04sTUFBTSxHQUFHLDRDQUE0QyxHQUNyRCxNQUFNLEdBQUk7SUFDVixNQUFNLEdBQUluTSxpQ0FBbUJBLENBQUNxeUIsQ0FBQyxHQUFHLENBQUN4bUIsS0FBS3ltQixPQUFVbHZCLE9BQU9pQixTQUFTLENBQUMwQyxjQUFjLENBQUMzRyxJQUFJLENBQUN5TCxLQUFLeW1CO0FBQzVGLE1BQU0sR0FBRztBQUNULE1BQU0sR0FDTix3RUFBd0UsR0FDeEUsSUFBSUMsc0JBQXNCLENBQUM7QUFFM0IsbUVBQW1FO0FBQ25FLElBQUlDLGdCQUFnQnh5QixpQ0FBbUJBLENBQUM7QUFDeEMsOEVBQThFO0FBQzlFLElBQUl5eUIsMkJBQTJCenlCLGlDQUFtQkEsQ0FBQztBQUNuRCw4RUFBOEU7QUFDOUUsSUFBSTB5QiwyQkFBMkIxeUIsaUNBQW1CQSxDQUFDO0FBQ25ELDhGQUE4RjtBQUM5RixJQUFJMnlCLDJDQUEyQzN5QixpQ0FBbUJBLENBQUM7QUFDbkUsNkVBQTZFO0FBQzdFLElBQUk0eUIsMEJBQTBCNXlCLGlDQUFtQkEsQ0FBQztBQUNsRCx3RUFBd0U7QUFDeEUsSUFBSTZ5QixxQkFBcUI3eUIsaUNBQW1CQSxDQUFDO0FBQzdDLG9FQUFvRTtBQUNwRSxJQUFJOHlCLGlCQUFpQjl5QixpQ0FBbUJBLENBQUM7QUFDekMseUVBQXlFO0FBQ3pFLElBQUkreUIsc0JBQXNCL3lCLGlDQUFtQkEsQ0FBQztBQUM5Qyw2RUFBNkU7QUFDN0UsSUFBSWd6QiwwQkFBMEJoekIsaUNBQW1CQSxDQUFDO0FBQ2xELG9GQUFvRjtBQUNwRixJQUFJaXpCLGlDQUFpQ2p6QixpQ0FBbUJBLENBQUM7QUFDekQsd0ZBQXdGO0FBQ3hGLElBQUlrekIscUNBQXFDbHpCLGlDQUFtQkEsQ0FBQztBQUM3RCxxRkFBcUY7QUFDckYsSUFBSW16QixrQ0FBa0NuekIsaUNBQW1CQSxDQUFDO0FBQzFELGtGQUFrRjtBQUNsRixJQUFJb3pCLCtCQUErQnB6QixpQ0FBbUJBLENBQUM7QUFDdkQsK0VBQStFO0FBQy9FLElBQUlxekIsNEJBQTRCcnpCLGlDQUFtQkEsQ0FBQztBQUNwRCw2RUFBNkU7QUFDN0UsSUFBSXN6QiwwQkFBMEJ0ekIsaUNBQW1CQSxDQUFDO0FBQ2xELG1FQUFtRTtBQUNuRSxJQUFJdXpCLGdCQUFnQnZ6QixpQ0FBbUJBLENBQUM7RUFDdkMsdUJBQXVCO0FBaUJ4QixNQUFNd3pCLFdBQVcsT0FBT2xiLFlBQVksWUFBWUEsVUFBVSxPQUFPLHNCQUFzQixDQUFDQSxRQUFRMFAsUUFBUSxDQUFDeUwsRUFBRSxJQUFJLENBQUVuYixDQUFBQSxRQUFRMFAsUUFBUSxDQUFDMEwsUUFBUSxJQUFJcGIsUUFBUTVPLElBQUksSUFBSTRPLFFBQVE1TyxJQUFJLEtBQUssU0FBUTtBQUN2TCxNQUFNaXFCLHVCQUF1QjtJQUFDO0lBQU87SUFBRztJQUFHO0lBQU87SUFBRztDQUFFO0FBQ3ZELE1BQU1DLGNBQWM7QUFDcEIsTUFBTUMsc0JBQXNCO0FBQzVCLE1BQU1DLGtCQUFrQkQsc0JBQXNCRDtBQUM5QyxNQUFNRyxzQkFBc0I7SUFDMUJDLEtBQUs7SUFDTEMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsbUJBQW1CO0lBQ25CQyxxQkFBcUI7SUFDckJDLHFCQUFxQjtJQUNyQkMsWUFBWTtJQUNaQyxRQUFRO0FBQ1Y7QUFDQSxNQUFNQyxpQkFBaUI7SUFDckJDLFNBQVM7SUFDVEMsUUFBUTtJQUNSQyxjQUFjO0lBQ2RDLGdCQUFnQjtBQUNsQjtBQUNBLE1BQU1DLHlCQUF5QjtBQUMvQixNQUFNQyx1QkFBdUI7SUFDM0JMLFNBQVMsQ0FBQztJQUNWTSxNQUFNO0lBQ05DLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxPQUFPO0lBQ1BDLEtBQUs7SUFDTEMsT0FBTztJQUNQQyxXQUFXO0lBQ1hDLFNBQVM7QUFDWDtBQUNBLE1BQU1DLDZCQUE2QjtJQUNqQ0MsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLGVBQWU7SUFDZkMsZ0JBQWdCO0lBQ2hCQyxrQkFBa0I7SUFDbEJDLFdBQVc7SUFDWEMsZUFBZTtJQUNmQyxhQUFhO0lBQ2JDLGlCQUFpQjtJQUNqQkMscUJBQXFCO0lBQ3JCQyxnQkFBZ0I7SUFDaEJDLG9CQUFvQjtJQUNwQkMsV0FBVztBQUNiO0FBQ0EsTUFBTUMsaUJBQWlCO0lBQ3JCcEMsT0FBTztJQUNQcUMsaUJBQWlCO0lBQ2pCQyxNQUFNO0lBQ05DLG9CQUFvQjtJQUNwQkMsd0JBQXdCO0lBQ3hCQyx3QkFBd0I7SUFDeEJDLFVBQVU7SUFDVkMsb0JBQW9CO0FBQ3RCO0FBQ0EsTUFBTUMsb0JBQW9CO0lBQ3hCQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsYUFBYTtJQUNiQyxXQUFXO0lBQ1hDLGtCQUFrQjtJQUNsQkMsb0JBQW9CO0lBQ3BCQyx5QkFBeUI7SUFDekJDLGFBQWE7SUFDYkMsa0JBQWtCO0lBQ2xCQyxrQkFBa0I7QUFDcEI7QUFDQSxNQUFNQyxpQkFBaUI7SUFDckJDLGdCQUFnQjtJQUNoQkMsV0FBVztJQUNYQyxZQUFZO0FBQ2Q7QUFDQSxNQUFNQyxpQkFBaUI7SUFDckJDLE1BQU07SUFDTkMsTUFBTTtJQUNOOUMsVUFBVTtJQUNWK0MsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZsRCxXQUFXO0lBQ1htRCxXQUFXO0lBQ1hDLFVBQVU7SUFDVkMsV0FBVztJQUNYcEQsT0FBTztJQUNQcUQsT0FBTztJQUNQcEQsS0FBSztJQUNMQyxPQUFPO0lBQ1BvRCxnQkFBZ0I7SUFDaEJDLE9BQU87SUFDUEMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsYUFBYTtJQUNiQyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsUUFBUTtJQUNSQyxRQUFRO0FBQ1Y7QUFDQSxNQUFNQyxzQkFBc0I7SUFDMUJDLE9BQU87SUFDUEMsT0FBTztBQUNUO0FBQ0EsTUFBTUMsaUJBQWlCO0lBQ3JCcEMsV0FBVztJQUNYcUMsUUFBUTtJQUNSckYsT0FBTztJQUNQc0YsUUFBUTtJQUNSQyxVQUFVO0lBQ1ZDLFFBQVE7SUFDUkMsVUFBVTtJQUNWQyxRQUFRO0lBQ1JDLGNBQWM7SUFDZEMsZ0JBQWdCO0FBQ2xCO0FBQ0EsTUFBTUMsc0JBQXNCO0lBQzFCSixVQUFVO0lBQ1ZLLFVBQVU7SUFDVkMsVUFBVTtJQUNWQyxXQUFXO0lBQ1hDLFVBQVU7SUFDVkMsZUFBZTtJQUNmQyxPQUFPO0lBQ1BDLFlBQVk7SUFDWkMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsWUFBWTtJQUNaQyxhQUFhO0lBQ2JDLGlCQUFpQjtJQUNqQkMsYUFBYTtJQUNiQyxNQUFNO0lBQ05DLFVBQVU7SUFDVkMsZ0JBQWdCO0lBQ2hCQyxtQkFBbUI7QUFDckI7QUFDQSxNQUFNQyw0QkFBNEI7SUFDaENDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLE9BQU87SUFDUGpELFdBQVc7QUFDYjtBQUNBLE1BQU1rRCw0QkFBNEI7SUFDaENDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsR0FBRztJQUNINXZCLEdBQUc7SUFDSDBZLEdBQUc7SUFDSHRILEdBQUc7QUFDTDtBQUNBLE1BQU15ZSwwQkFBMEI7SUFDOUJDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtBQUNOO0FBQ0EsTUFBTUMsc0JBQXNCO0lBQzFCajBCLEdBQUc7SUFDSGtWLEdBQUc7QUFDTDtBQUNBLE1BQU1nZixpQkFBaUI7SUFDckJDLFFBQVE7SUFDUkMsVUFBVTtJQUNWQyxPQUFPO0FBQ1Q7QUFDQSxNQUFNQyxNQUFNO0lBQ1ZDLFlBQVk7SUFDWkMsY0FBYztJQUNkQyxZQUFZO0lBQ1pDLGFBQWE7SUFDYkMsZUFBZTtJQUNmQyxTQUFTO0lBQ1RDLG9CQUFvQjtJQUNwQkMsYUFBYTtJQUNiQyxXQUFXO0lBQ1hDLE1BQU07SUFDTkMsU0FBUztJQUNUQyxXQUFXO0lBQ1hDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLFVBQVU7SUFDVkMsVUFBVTtJQUNWQyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsUUFBUTtJQUNSQyxhQUFhO0lBQ2JDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLGNBQWM7SUFDZEMsaUJBQWlCO0lBQ2pCQyxtQkFBbUI7SUFDbkJDLFNBQVM7SUFDVEMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFdBQVc7SUFDWEMsU0FBUztJQUNUQyxnQkFBZ0I7SUFDaEJDLGdCQUFnQjtJQUNoQkMsV0FBVztJQUNYQyxZQUFZO0lBQ1pDLFNBQVM7SUFDVEMsc0JBQXNCO0lBQ3RCQyxhQUFhO0lBQ2JDLFVBQVU7SUFDVkMsb0JBQW9CO0lBQ3BCQyxlQUFlO0lBQ2ZDLFVBQVU7SUFDVkMsVUFBVTtJQUNWQyxnQkFBZ0I7SUFDaEJDLGtCQUFrQjtJQUNsQkMsNEJBQTRCO0lBQzVCQyxjQUFjO0lBQ2RDLHVCQUF1QjtJQUN2QkMscUJBQXFCO0lBQ3JCQyxtQkFBbUI7SUFDbkJDLGdCQUFnQjtJQUNoQkMsaUJBQWlCO0lBQ2pCQyxjQUFjO0lBQ2RDLGVBQWU7SUFDZkMsZUFBZTtJQUNmQyxhQUFhO0lBQ2JDLG1CQUFtQjtJQUNuQkMsaUJBQWlCO0lBQ2pCQyxvQkFBb0I7SUFDcEJDLGtCQUFrQjtJQUNsQkMsYUFBYTtJQUNiQyxrQkFBa0I7SUFDbEJDLGdCQUFnQjtJQUNoQkMsZ0JBQWdCO0lBQ2hCQyxjQUFjO0lBQ2RDLFdBQVc7SUFDWEMsZ0JBQWdCO0lBQ2hCQyxvQkFBb0I7SUFDcEJDLHlCQUF5QjtJQUN6QkMsa0JBQWtCO0lBQ2xCQyxhQUFhO0lBQ2JDLFdBQVc7SUFDWEMsdUJBQXVCO0lBQ3ZCQyxxQkFBcUI7SUFDckJDLFlBQVk7SUFDWkMsVUFBVTtJQUNWQyxpQkFBaUI7SUFDakJDLGVBQWU7SUFDZkMsdUJBQXVCO0lBQ3ZCQyw0QkFBNEI7SUFDNUJDLG1CQUFtQjtJQUNuQkMseUJBQXlCO0lBQ3pCQyw4QkFBOEI7SUFDOUJDLHlCQUF5QjtJQUN6QkMsNkJBQTZCO0lBQzdCQywwQkFBMEI7SUFDMUJDLGVBQWU7SUFDZkMsc0JBQXNCO0lBQ3RCQyxvQkFBb0I7SUFDcEJDLGFBQWE7QUFDZjtBQUNBLE1BQU1DLFVBQVU7SUFDZC9FLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RHLFdBQVc7QUFDYjtBQUNBLE1BQU0yRSxvQkFBb0I7SUFDeEJDLGVBQWU7SUFDZkMsb0JBQW9CO0FBQ3RCO0FBQ0EsSUFBSUMsWUFBWXBHLGVBQWVFLFFBQVE7QUFDdkMsU0FBU21HLGtCQUFrQkMsS0FBSztJQUM5QixJQUFJcnZCLE9BQU9zdkIsU0FBUyxDQUFDRCxRQUFRO1FBQzNCRixZQUFZRTtJQUNkO0FBQ0Y7QUFDQSxTQUFTRTtJQUNQLE9BQU9KO0FBQ1Q7QUFDQSxTQUFTSyxLQUFLQyxHQUFHO0lBQ2YsSUFBSU4sYUFBYXBHLGVBQWVHLEtBQUssRUFBRTtRQUNyQ3dHLFFBQVFGLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRUMsSUFBSSxDQUFDO0lBQzdCO0FBQ0Y7QUFDQSxTQUFTRSxLQUFLRixHQUFHO0lBQ2YsSUFBSU4sYUFBYXBHLGVBQWVFLFFBQVEsRUFBRTtRQUN4Q3lHLFFBQVFDLElBQUksQ0FBQyxDQUFDLFNBQVMsRUFBRUYsSUFBSSxDQUFDO0lBQ2hDO0FBQ0Y7QUFDQSxTQUFTRyxZQUFZSCxHQUFHO0lBQ3RCLE1BQU0sSUFBSWxrQixNQUFNa2tCO0FBQ2xCO0FBQ0EsU0FBU0ksT0FBT0MsSUFBSSxFQUFFTCxHQUFHO0lBQ3ZCLElBQUksQ0FBQ0ssTUFBTTtRQUNURixZQUFZSDtJQUNkO0FBQ0Y7QUFDQSxTQUFTTSxpQkFBaUJoZixHQUFHO0lBQzNCLE9BQVFBLEtBQUtpZjtRQUNYLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBTztJQUNYO0FBQ0Y7QUFDQSxTQUFTQyx1QkFBdUJsZixHQUFHLEVBQUVtZixVQUFVLElBQUksRUFBRS8vQixVQUFVLElBQUk7SUFDakUsSUFBSSxDQUFDNGdCLEtBQUs7UUFDUixPQUFPO0lBQ1Q7SUFDQSxJQUFJNWdCLFdBQVcsT0FBTzRnQixRQUFRLFVBQVU7UUFDdEMsSUFBSTVnQixRQUFRZ2dDLGtCQUFrQixJQUFJcGYsSUFBSXFmLFVBQVUsQ0FBQyxTQUFTO1lBQ3hELE1BQU1DLE9BQU90ZixJQUFJb00sS0FBSyxDQUFDO1lBQ3ZCLElBQUlrVCxNQUFNampDLFVBQVUsR0FBRztnQkFDckIyakIsTUFBTSxDQUFDLE9BQU8sRUFBRUEsSUFBSSxDQUFDO1lBQ3ZCO1FBQ0Y7UUFDQSxJQUFJNWdCLFFBQVFtZ0Msa0JBQWtCLEVBQUU7WUFDOUIsSUFBSTtnQkFDRnZmLE1BQU13ZixtQkFBbUJ4ZjtZQUMzQixFQUFFLE9BQU0sQ0FBQztRQUNYO0lBQ0Y7SUFDQSxNQUFNeWYsY0FBY04sVUFBVXJmLElBQUlDLEtBQUssQ0FBQ0MsS0FBS21mLFdBQVdyZixJQUFJQyxLQUFLLENBQUNDO0lBQ2xFLE9BQU9nZixpQkFBaUJTLGVBQWVBLGNBQWM7QUFDdkQ7QUFDQSxTQUFTQyxjQUFjMWYsR0FBRyxFQUFFZ0QsSUFBSSxFQUFFMmMsV0FBVyxLQUFLO0lBQ2hELE1BQU1DLE1BQU05ZixJQUFJQyxLQUFLLENBQUNDO0lBQ3RCLElBQUk0ZixLQUFLO1FBQ1BBLElBQUk1YyxJQUFJLEdBQUdBO1FBQ1gsT0FBTzRjLElBQUkvYyxJQUFJO0lBQ2pCO0lBQ0EsSUFBSThjLFlBQVlULHVCQUF1QmxmLEtBQUssdUJBQXVCO1FBQ2pFLE9BQU9BLElBQUkvZ0IsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUrakIsT0FBTyxDQUFDLENBQUMsRUFBRUEsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBQzNEO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBUzZjLE9BQU8xNEIsR0FBRyxFQUFFeW1CLElBQUksRUFBRXR3QixLQUFLLEVBQUV3aUMsa0JBQWtCLEtBQUs7SUFDdkRwaEMsT0FBT0QsY0FBYyxDQUFDMEksS0FBS3ltQixNQUFNO1FBQy9CdHdCO1FBQ0F5WixZQUFZLENBQUMrb0I7UUFDYnZnQyxjQUFjO1FBQ2RHLFVBQVU7SUFDWjtJQUNBLE9BQU9wQztBQUNUO0FBQ0EsTUFBTXlpQyxnQkFBZ0IsU0FBU0M7SUFDN0IsU0FBU0QsY0FBY3BrQixPQUFPLEVBQUV4YyxJQUFJO1FBQ2xDLElBQUksQ0FBQ3djLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUN4YyxJQUFJLEdBQUdBO0lBQ2Q7SUFDQTRnQyxjQUFjcGdDLFNBQVMsR0FBRyxJQUFJNmE7SUFDOUJ1bEIsY0FBY3RnQyxXQUFXLEdBQUdzZ0M7SUFDNUIsT0FBT0E7QUFDVDtBQUNBLE1BQU1FLDBCQUEwQkY7SUFDOUJ0Z0MsWUFBWWkvQixHQUFHLEVBQUV3QixJQUFJLENBQUU7UUFDckIsS0FBSyxDQUFDeEIsS0FBSztRQUNYLElBQUksQ0FBQ3dCLElBQUksR0FBR0E7SUFDZDtBQUNGO0FBQ0EsTUFBTUMsOEJBQThCSjtJQUNsQ3RnQyxZQUFZaS9CLEdBQUcsRUFBRTBCLE9BQU8sQ0FBRTtRQUN4QixLQUFLLENBQUMxQixLQUFLO1FBQ1gsSUFBSSxDQUFDMEIsT0FBTyxHQUFHQTtJQUNqQjtBQUNGO0FBQ0EsTUFBTUMsNEJBQTRCTjtJQUNoQ3RnQyxZQUFZaS9CLEdBQUcsQ0FBRTtRQUNmLEtBQUssQ0FBQ0EsS0FBSztJQUNiO0FBQ0Y7QUFDQSxNQUFNNEIsMEJBQTBCUDtJQUM5QnRnQyxZQUFZaS9CLEdBQUcsRUFBRTZCLE1BQU0sRUFBRUMsT0FBTyxDQUFFO1FBQ2hDLEtBQUssQ0FBQzlCLEtBQUs7UUFDWCxJQUFJLENBQUM2QixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO0lBQ2pCO0FBQ0Y7QUFDQSxNQUFNQyxvQkFBb0JWO0lBQ3hCdGdDLFlBQVlpL0IsR0FBRyxDQUFFO1FBQ2YsS0FBSyxDQUFDQSxLQUFLO0lBQ2I7QUFDRjtBQUNBLE1BQU1nQyx1QkFBdUJYO0lBQzNCdGdDLFlBQVlpL0IsR0FBRyxDQUFFO1FBQ2YsS0FBSyxDQUFDQSxLQUFLO0lBQ2I7QUFDRjtBQUNBLFNBQVNpQyxjQUFjcjRCLEtBQUs7SUFDMUIsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLE9BQU9qTSxXQUFXdUQsV0FBVztRQUM1RGkvQixZQUFZO0lBQ2Q7SUFDQSxNQUFNeGlDLFNBQVNpTSxNQUFNak0sTUFBTTtJQUMzQixNQUFNdWtDLHFCQUFxQjtJQUMzQixJQUFJdmtDLFNBQVN1a0Msb0JBQW9CO1FBQy9CLE9BQU9waUMsT0FBTzRtQixZQUFZLENBQUNyZixLQUFLLENBQUMsTUFBTXVDO0lBQ3pDO0lBQ0EsTUFBTXU0QixTQUFTLEVBQUU7SUFDakIsSUFBSyxJQUFJNy9CLElBQUksR0FBR0EsSUFBSTNFLFFBQVEyRSxLQUFLNC9CLG1CQUFvQjtRQUNuRCxNQUFNRSxXQUFXaitCLEtBQUttRixHQUFHLENBQUNoSCxJQUFJNC9CLG9CQUFvQnZrQztRQUNsRCxNQUFNMnRCLFFBQVExaEIsTUFBTXk0QixRQUFRLENBQUMvL0IsR0FBRzgvQjtRQUNoQ0QsT0FBT3Y1QixJQUFJLENBQUM5SSxPQUFPNG1CLFlBQVksQ0FBQ3JmLEtBQUssQ0FBQyxNQUFNaWtCO0lBQzlDO0lBQ0EsT0FBTzZXLE9BQU8vaEMsSUFBSSxDQUFDO0FBQ3JCO0FBQ0EsU0FBU2tpQyxjQUFjQyxHQUFHO0lBQ3hCLElBQUksT0FBT0EsUUFBUSxVQUFVO1FBQzNCcEMsWUFBWTtJQUNkO0lBQ0EsTUFBTXhpQyxTQUFTNGtDLElBQUk1a0MsTUFBTTtJQUN6QixNQUFNaU0sUUFBUSxJQUFJMUgsV0FBV3ZFO0lBQzdCLElBQUssSUFBSTJFLElBQUksR0FBR0EsSUFBSTNFLFFBQVEsRUFBRTJFLEVBQUc7UUFDL0JzSCxLQUFLLENBQUN0SCxFQUFFLEdBQUdpZ0MsSUFBSUMsVUFBVSxDQUFDbGdDLEtBQUs7SUFDakM7SUFDQSxPQUFPc0g7QUFDVDtBQUNBLFNBQVM2NEIsU0FBUzdqQyxLQUFLO0lBQ3JCLE9BQU9rQixPQUFPNG1CLFlBQVksQ0FBQzluQixTQUFTLEtBQUssTUFBTUEsU0FBUyxLQUFLLE1BQU1BLFNBQVMsSUFBSSxNQUFNQSxRQUFRO0FBQ2hHO0FBQ0EsU0FBUzhqQyxXQUFXajZCLEdBQUc7SUFDckIsT0FBT3pJLE9BQU9tRixJQUFJLENBQUNzRCxLQUFLOUssTUFBTTtBQUNoQztBQUNBLFNBQVNnbEM7SUFDUCxNQUFNQyxVQUFVLElBQUkxZ0MsV0FBVztJQUMvQjBnQyxPQUFPLENBQUMsRUFBRSxHQUFHO0lBQ2IsTUFBTUMsU0FBUyxJQUFJbHBCLFlBQVlpcEIsUUFBUXZnQyxNQUFNLEVBQUUsR0FBRztJQUNsRCxPQUFPd2dDLE1BQU0sQ0FBQyxFQUFFLEtBQUs7QUFDdkI7QUFDQSxTQUFTQztJQUNQLElBQUk7UUFDRixJQUFJemhDLFNBQVM7UUFDYixPQUFPO0lBQ1QsRUFBRSxPQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFDQSxNQUFNMGhDO0lBQ0osV0FBV0osaUJBQWlCO1FBQzFCLE9BQU94QixPQUFPLElBQUksRUFBRSxrQkFBa0J3QjtJQUN4QztJQUNBLFdBQVdHLGtCQUFrQjtRQUMzQixPQUFPM0IsT0FBTyxJQUFJLEVBQUUsbUJBQW1CMkI7SUFDekM7SUFDQSxXQUFXRSw2QkFBNkI7UUFDdEMsT0FBTzdCLE9BQU8sSUFBSSxFQUFFLDhCQUE4QixPQUFPOEIsb0JBQW9CO0lBQy9FO0lBQ0EsV0FBV0MsMEJBQTBCO1FBQ25DLE9BQU8vQixPQUFPLElBQUksRUFBRSwyQkFBMkIsT0FBT2dDLGlCQUFpQjtJQUN6RTtJQUNBLFdBQVdDLFdBQVc7UUFDcEIsTUFBTSxFQUNKQSxRQUFRLEVBQ1JoMEIsU0FBUyxFQUNWLEdBQUdEO1FBQ0osT0FBT2d5QixPQUFPLElBQUksRUFBRSxZQUFZO1lBQzlCa0MsV0FBV2owQixVQUFVZ0UsUUFBUSxDQUFDO1lBQzlCa3dCLFNBQVNGLFNBQVNod0IsUUFBUSxDQUFDO1lBQzNCbXdCLE9BQU9ILFNBQVNod0IsUUFBUSxDQUFDO1lBQ3pCb3dCLFdBQVdKLFNBQVNod0IsUUFBUSxDQUFDO1lBQzdCcXdCLFdBQVdyMEIsVUFBVWdFLFFBQVEsQ0FBQztRQUNoQztJQUNGO0lBQ0EsV0FBV3N3QixzQkFBc0I7UUFDL0IsT0FBT3ZDLE9BQU8sSUFBSSxFQUFFLHVCQUF1QnIvQixXQUFXNmhDLEdBQUcsRUFBRUMsV0FBVztJQUN4RTtBQUNGO0FBQ0EsTUFBTUMsYUFBYW4wQixNQUFNcVcsSUFBSSxDQUFDclcsTUFBTSxLQUFLdkssSUFBSSxJQUFJWixDQUFBQSxJQUFLQSxFQUFFakQsUUFBUSxDQUFDLElBQUl3aUMsUUFBUSxDQUFDLEdBQUc7QUFDakYsTUFBTUM7SUFDSixPQUFPQyxhQUFhQyxDQUFDLEVBQUVDLENBQUMsRUFBRWpqQixDQUFDLEVBQUU7UUFDM0IsT0FBTyxDQUFDLENBQUMsRUFBRTRpQixVQUFVLENBQUNJLEVBQUUsQ0FBQyxFQUFFSixVQUFVLENBQUNLLEVBQUUsQ0FBQyxFQUFFTCxVQUFVLENBQUM1aUIsRUFBRSxDQUFDLENBQUM7SUFDNUQ7SUFDQSxPQUFPa2pCLHFCQUFxQkMsRUFBRSxFQUFFO1FBQzlCLE9BQU87WUFBQ0EsR0FBR3BqQixDQUFDO1lBQUVvakIsR0FBR25qQixDQUFDO1lBQUVtakIsR0FBR3htQixDQUFDO1lBQUV3bUIsR0FBR3JWLENBQUM7WUFBRXFWLEdBQUdqeEIsQ0FBQztZQUFFaXhCLEdBQUd0OEIsQ0FBQztTQUFDO0lBQzdDO0lBQ0EsT0FBT3U4QixZQUFZL0osU0FBUyxFQUFFZ0ssTUFBTSxFQUFFO1FBQ3BDLElBQUl2NUI7UUFDSixJQUFJdXZCLFNBQVMsQ0FBQyxFQUFFLEVBQUU7WUFDaEIsSUFBSUEsU0FBUyxDQUFDLEVBQUUsR0FBRyxHQUFHO2dCQUNwQnZ2QixPQUFPdTVCLE1BQU0sQ0FBQyxFQUFFO2dCQUNoQkEsTUFBTSxDQUFDLEVBQUUsR0FBR0EsTUFBTSxDQUFDLEVBQUU7Z0JBQ3JCQSxNQUFNLENBQUMsRUFBRSxHQUFHdjVCO1lBQ2Q7WUFDQXU1QixNQUFNLENBQUMsRUFBRSxJQUFJaEssU0FBUyxDQUFDLEVBQUU7WUFDekJnSyxNQUFNLENBQUMsRUFBRSxJQUFJaEssU0FBUyxDQUFDLEVBQUU7WUFDekIsSUFBSUEsU0FBUyxDQUFDLEVBQUUsR0FBRyxHQUFHO2dCQUNwQnZ2QixPQUFPdTVCLE1BQU0sQ0FBQyxFQUFFO2dCQUNoQkEsTUFBTSxDQUFDLEVBQUUsR0FBR0EsTUFBTSxDQUFDLEVBQUU7Z0JBQ3JCQSxNQUFNLENBQUMsRUFBRSxHQUFHdjVCO1lBQ2Q7WUFDQXU1QixNQUFNLENBQUMsRUFBRSxJQUFJaEssU0FBUyxDQUFDLEVBQUU7WUFDekJnSyxNQUFNLENBQUMsRUFBRSxJQUFJaEssU0FBUyxDQUFDLEVBQUU7UUFDM0IsT0FBTztZQUNMdnZCLE9BQU91NUIsTUFBTSxDQUFDLEVBQUU7WUFDaEJBLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFO1lBQ3JCQSxNQUFNLENBQUMsRUFBRSxHQUFHdjVCO1lBQ1pBLE9BQU91NUIsTUFBTSxDQUFDLEVBQUU7WUFDaEJBLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFO1lBQ3JCQSxNQUFNLENBQUMsRUFBRSxHQUFHdjVCO1lBQ1osSUFBSXV2QixTQUFTLENBQUMsRUFBRSxHQUFHLEdBQUc7Z0JBQ3BCdnZCLE9BQU91NUIsTUFBTSxDQUFDLEVBQUU7Z0JBQ2hCQSxNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRTtnQkFDckJBLE1BQU0sQ0FBQyxFQUFFLEdBQUd2NUI7WUFDZDtZQUNBdTVCLE1BQU0sQ0FBQyxFQUFFLElBQUloSyxTQUFTLENBQUMsRUFBRTtZQUN6QmdLLE1BQU0sQ0FBQyxFQUFFLElBQUloSyxTQUFTLENBQUMsRUFBRTtZQUN6QixJQUFJQSxTQUFTLENBQUMsRUFBRSxHQUFHLEdBQUc7Z0JBQ3BCdnZCLE9BQU91NUIsTUFBTSxDQUFDLEVBQUU7Z0JBQ2hCQSxNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRTtnQkFDckJBLE1BQU0sQ0FBQyxFQUFFLEdBQUd2NUI7WUFDZDtZQUNBdTVCLE1BQU0sQ0FBQyxFQUFFLElBQUloSyxTQUFTLENBQUMsRUFBRTtZQUN6QmdLLE1BQU0sQ0FBQyxFQUFFLElBQUloSyxTQUFTLENBQUMsRUFBRTtRQUMzQjtRQUNBZ0ssTUFBTSxDQUFDLEVBQUUsSUFBSWhLLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCZ0ssTUFBTSxDQUFDLEVBQUUsSUFBSWhLLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCZ0ssTUFBTSxDQUFDLEVBQUUsSUFBSWhLLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCZ0ssTUFBTSxDQUFDLEVBQUUsSUFBSWhLLFNBQVMsQ0FBQyxFQUFFO0lBQzNCO0lBQ0EsT0FBT0EsVUFBVWlLLEVBQUUsRUFBRUMsRUFBRSxFQUFFO1FBQ3ZCLE9BQU87WUFBQ0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7WUFBRUQsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7WUFBRUQsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7WUFBRUQsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7WUFBRUQsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUU7WUFBRUEsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUU7U0FBQztJQUNuTjtJQUNBLE9BQU9FLG9CQUFvQjNtQixDQUFDLEVBQUU0bUIsRUFBRSxFQUFFO1FBQ2hDLE9BQU87WUFBQzVtQixDQUFDLENBQUMsRUFBRSxHQUFHNG1CLEdBQUcxakIsQ0FBQyxHQUFHbEQsQ0FBQyxDQUFDLEVBQUUsR0FBRzRtQixHQUFHempCLENBQUM7WUFBRW5ELENBQUMsQ0FBQyxFQUFFLEdBQUc0bUIsR0FBRzFqQixDQUFDLEdBQUdsRCxDQUFDLENBQUMsRUFBRSxHQUFHNG1CLEdBQUd6akIsQ0FBQztZQUFFbkQsQ0FBQyxDQUFDLEVBQUUsR0FBRzRtQixHQUFHOW1CLENBQUMsR0FBR0UsQ0FBQyxDQUFDLEVBQUUsR0FBRzRtQixHQUFHM1YsQ0FBQztZQUFFalIsQ0FBQyxDQUFDLEVBQUUsR0FBRzRtQixHQUFHOW1CLENBQUMsR0FBR0UsQ0FBQyxDQUFDLEVBQUUsR0FBRzRtQixHQUFHM1YsQ0FBQztZQUFFalIsQ0FBQyxDQUFDLEVBQUUsR0FBRzRtQixHQUFHdnhCLENBQUMsR0FBRzJLLENBQUMsQ0FBQyxFQUFFLEdBQUc0bUIsR0FBRzU4QixDQUFDLEdBQUdnVyxDQUFDLENBQUMsRUFBRTtZQUFFQSxDQUFDLENBQUMsRUFBRSxHQUFHNG1CLEdBQUd2eEIsQ0FBQyxHQUFHMkssQ0FBQyxDQUFDLEVBQUUsR0FBRzRtQixHQUFHNThCLENBQUMsR0FBR2dXLENBQUMsQ0FBQyxFQUFFO1NBQUM7SUFDekw7SUFDQSxPQUFPNm1CLGVBQWVDLENBQUMsRUFBRTltQixDQUFDLEVBQUUrbUIsTUFBTSxDQUFDLEVBQUU7UUFDbkMsTUFBTUMsS0FBS0YsQ0FBQyxDQUFDQyxJQUFJO1FBQ2pCLE1BQU1FLEtBQUtILENBQUMsQ0FBQ0MsTUFBTSxFQUFFO1FBQ3JCRCxDQUFDLENBQUNDLElBQUksR0FBR0MsS0FBS2huQixDQUFDLENBQUMsRUFBRSxHQUFHaW5CLEtBQUtqbkIsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUU7UUFDckM4bUIsQ0FBQyxDQUFDQyxNQUFNLEVBQUUsR0FBR0MsS0FBS2huQixDQUFDLENBQUMsRUFBRSxHQUFHaW5CLEtBQUtqbkIsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUU7SUFDM0M7SUFDQSxPQUFPa25CLHVCQUF1QkosQ0FBQyxFQUFFdEssU0FBUyxFQUFFdUssTUFBTSxDQUFDLEVBQUU7UUFDbkQsTUFBTUksS0FBSzNLLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLE1BQU1pSyxLQUFLakssU0FBUyxDQUFDLEVBQUU7UUFDdkIsTUFBTWtLLEtBQUtsSyxTQUFTLENBQUMsRUFBRTtRQUN2QixNQUFNNEssS0FBSzVLLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLE1BQU02SyxLQUFLN0ssU0FBUyxDQUFDLEVBQUU7UUFDdkIsTUFBTThLLEtBQUs5SyxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFLLElBQUloNEIsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLEtBQUssRUFBRztZQUM3QixNQUFNK2lDLEtBQUtULENBQUMsQ0FBQ0MsTUFBTXZpQyxFQUFFO1lBQ3JCLE1BQU1nakMsTUFBTVYsQ0FBQyxDQUFDQyxNQUFNdmlDLElBQUksRUFBRTtZQUMxQnNpQyxDQUFDLENBQUNDLE1BQU12aUMsRUFBRSxHQUFHK2lDLEtBQUtKLEtBQUtLLE1BQU1kLEtBQUtXO1lBQ2xDUCxDQUFDLENBQUNDLE1BQU12aUMsSUFBSSxFQUFFLEdBQUcraUMsS0FBS2QsS0FBS2UsTUFBTUosS0FBS0U7UUFDeEM7SUFDRjtJQUNBLE9BQU9HLHNCQUFzQlgsQ0FBQyxFQUFFOW1CLENBQUMsRUFBRTtRQUNqQyxNQUFNZ25CLEtBQUtGLENBQUMsQ0FBQyxFQUFFO1FBQ2YsTUFBTUcsS0FBS0gsQ0FBQyxDQUFDLEVBQUU7UUFDZixNQUFNN1YsSUFBSWpSLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFO1FBQ25DOG1CLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQ0UsS0FBS2huQixDQUFDLENBQUMsRUFBRSxHQUFHaW5CLEtBQUtqbkIsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsSUFBSWlSO1FBQzdENlYsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUNFLEtBQUtobkIsQ0FBQyxDQUFDLEVBQUUsR0FBR2luQixLQUFLam5CLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLElBQUlpUjtJQUNoRTtJQUNBLE9BQU95Vyx3QkFBd0JDLElBQUksRUFBRW5MLFNBQVMsRUFBRW9MLE1BQU0sRUFBRTtRQUN0RCxNQUFNVCxLQUFLM0ssU0FBUyxDQUFDLEVBQUU7UUFDdkIsTUFBTWlLLEtBQUtqSyxTQUFTLENBQUMsRUFBRTtRQUN2QixNQUFNa0ssS0FBS2xLLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLE1BQU00SyxLQUFLNUssU0FBUyxDQUFDLEVBQUU7UUFDdkIsTUFBTTZLLEtBQUs3SyxTQUFTLENBQUMsRUFBRTtRQUN2QixNQUFNOEssS0FBSzlLLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLE1BQU1xTCxLQUFLRixJQUFJLENBQUMsRUFBRTtRQUNsQixNQUFNRyxLQUFLSCxJQUFJLENBQUMsRUFBRTtRQUNsQixNQUFNSSxLQUFLSixJQUFJLENBQUMsRUFBRTtRQUNsQixNQUFNSyxLQUFLTCxJQUFJLENBQUMsRUFBRTtRQUNsQixJQUFJTSxLQUFLZCxLQUFLVSxLQUFLUjtRQUNuQixJQUFJYSxLQUFLRDtRQUNULElBQUlFLEtBQUtoQixLQUFLWSxLQUFLVjtRQUNuQixJQUFJZSxLQUFLRDtRQUNULElBQUlFLEtBQUtqQixLQUFLVSxLQUFLUjtRQUNuQixJQUFJZ0IsS0FBS0Q7UUFDVCxJQUFJRSxLQUFLbkIsS0FBS1ksS0FBS1Y7UUFDbkIsSUFBSWtCLEtBQUtEO1FBQ1QsSUFBSTlCLE9BQU8sS0FBS0MsT0FBTyxHQUFHO1lBQ3hCLE1BQU0rQixPQUFPaEMsS0FBS29CO1lBQ2xCLE1BQU1hLE9BQU9qQyxLQUFLc0I7WUFDbEIsTUFBTVksT0FBT2pDLEtBQUtvQjtZQUNsQixNQUFNYyxPQUFPbEMsS0FBS3NCO1lBQ2xCQyxNQUFNVTtZQUNOUCxNQUFNTztZQUNOUixNQUFNUztZQUNOVixNQUFNVTtZQUNOUCxNQUFNSTtZQUNORCxNQUFNQztZQUNORixNQUFNRztZQUNOSixNQUFNSTtRQUNSO1FBQ0FkLE1BQU0sQ0FBQyxFQUFFLEdBQUd2aEMsS0FBS21GLEdBQUcsQ0FBQ284QixNQUFNLENBQUMsRUFBRSxFQUFFSyxJQUFJRSxJQUFJRCxJQUFJRTtRQUM1Q1IsTUFBTSxDQUFDLEVBQUUsR0FBR3ZoQyxLQUFLbUYsR0FBRyxDQUFDbzhCLE1BQU0sQ0FBQyxFQUFFLEVBQUVTLElBQUlFLElBQUlELElBQUlFO1FBQzVDWixNQUFNLENBQUMsRUFBRSxHQUFHdmhDLEtBQUs0UCxHQUFHLENBQUMyeEIsTUFBTSxDQUFDLEVBQUUsRUFBRUssSUFBSUUsSUFBSUQsSUFBSUU7UUFDNUNSLE1BQU0sQ0FBQyxFQUFFLEdBQUd2aEMsS0FBSzRQLEdBQUcsQ0FBQzJ4QixNQUFNLENBQUMsRUFBRSxFQUFFUyxJQUFJRSxJQUFJRCxJQUFJRTtJQUM5QztJQUNBLE9BQU9LLGlCQUFpQjdvQixDQUFDLEVBQUU7UUFDekIsTUFBTWlSLElBQUlqUixDQUFDLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRTtRQUNuQyxPQUFPO1lBQUNBLENBQUMsQ0FBQyxFQUFFLEdBQUdpUjtZQUFHLENBQUNqUixDQUFDLENBQUMsRUFBRSxHQUFHaVI7WUFBRyxDQUFDalIsQ0FBQyxDQUFDLEVBQUUsR0FBR2lSO1lBQUdqUixDQUFDLENBQUMsRUFBRSxHQUFHaVI7WUFBSWpSLENBQUFBLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLElBQUlpUjtZQUFJalIsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsSUFBSWlSO1NBQUU7SUFDckg7SUFDQSxPQUFPNlgsOEJBQThCQyxNQUFNLEVBQUVuQixNQUFNLEVBQUU7UUFDbkQsTUFBTVQsS0FBSzRCLE1BQU0sQ0FBQyxFQUFFO1FBQ3BCLE1BQU10QyxLQUFLc0MsTUFBTSxDQUFDLEVBQUU7UUFDcEIsTUFBTXJDLEtBQUtxQyxNQUFNLENBQUMsRUFBRTtRQUNwQixNQUFNM0IsS0FBSzJCLE1BQU0sQ0FBQyxFQUFFO1FBQ3BCLE1BQU03bEIsSUFBSWlrQixNQUFNLElBQUlWLE1BQU07UUFDMUIsTUFBTXRqQixJQUFJZ2tCLEtBQUtULEtBQUtELEtBQUtXO1FBQ3pCLE1BQU10bkIsSUFBSTRtQixNQUFNLElBQUlVLE1BQU07UUFDMUIsTUFBTTRCLFFBQVEsQ0FBQzlsQixJQUFJcEQsQ0FBQUEsSUFBSztRQUN4QixNQUFNbXBCLFNBQVM1aUMsS0FBSzZpQyxJQUFJLENBQUNGLFNBQVMsSUFBSzlsQixDQUFBQSxJQUFJcEQsSUFBSXFELEtBQUs7UUFDcER5a0IsTUFBTSxDQUFDLEVBQUUsR0FBR3ZoQyxLQUFLNmlDLElBQUksQ0FBQ0YsUUFBUUMsVUFBVTtRQUN4Q3JCLE1BQU0sQ0FBQyxFQUFFLEdBQUd2aEMsS0FBSzZpQyxJQUFJLENBQUNGLFFBQVFDLFVBQVU7SUFDMUM7SUFDQSxPQUFPRSxjQUFjeEIsSUFBSSxFQUFFO1FBQ3pCLE1BQU14QixJQUFJd0IsS0FBS3ZsQyxLQUFLLENBQUM7UUFDckIsSUFBSXVsQyxJQUFJLENBQUMsRUFBRSxHQUFHQSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3JCeEIsQ0FBQyxDQUFDLEVBQUUsR0FBR3dCLElBQUksQ0FBQyxFQUFFO1lBQ2R4QixDQUFDLENBQUMsRUFBRSxHQUFHd0IsSUFBSSxDQUFDLEVBQUU7UUFDaEI7UUFDQSxJQUFJQSxJQUFJLENBQUMsRUFBRSxHQUFHQSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3JCeEIsQ0FBQyxDQUFDLEVBQUUsR0FBR3dCLElBQUksQ0FBQyxFQUFFO1lBQ2R4QixDQUFDLENBQUMsRUFBRSxHQUFHd0IsSUFBSSxDQUFDLEVBQUU7UUFDaEI7UUFDQSxPQUFPeEI7SUFDVDtJQUNBLE9BQU9pRCxVQUFVQyxLQUFLLEVBQUVDLEtBQUssRUFBRTtRQUM3QixNQUFNQyxPQUFPbGpDLEtBQUs0UCxHQUFHLENBQUM1UCxLQUFLbUYsR0FBRyxDQUFDNjlCLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLEdBQUdoakMsS0FBS21GLEdBQUcsQ0FBQzg5QixLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRTtRQUMvRSxNQUFNRSxRQUFRbmpDLEtBQUttRixHQUFHLENBQUNuRixLQUFLNFAsR0FBRyxDQUFDb3pCLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLEdBQUdoakMsS0FBSzRQLEdBQUcsQ0FBQ3F6QixLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRTtRQUNoRixJQUFJQyxPQUFPQyxPQUFPO1lBQ2hCLE9BQU87UUFDVDtRQUNBLE1BQU1DLE9BQU9wakMsS0FBSzRQLEdBQUcsQ0FBQzVQLEtBQUttRixHQUFHLENBQUM2OUIsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsR0FBR2hqQyxLQUFLbUYsR0FBRyxDQUFDODlCLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFO1FBQy9FLE1BQU1JLFFBQVFyakMsS0FBS21GLEdBQUcsQ0FBQ25GLEtBQUs0UCxHQUFHLENBQUNvekIsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsR0FBR2hqQyxLQUFLNFAsR0FBRyxDQUFDcXpCLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFO1FBQ2hGLElBQUlHLE9BQU9DLE9BQU87WUFDaEIsT0FBTztRQUNUO1FBQ0EsT0FBTztZQUFDSDtZQUFNRTtZQUFNRDtZQUFPRTtTQUFNO0lBQ25DO0lBQ0EsT0FBT0MsaUJBQWlCbmpDLENBQUMsRUFBRTBNLENBQUMsRUFBRXN6QixNQUFNLEVBQUU7UUFDcENBLE1BQU0sQ0FBQyxFQUFFLEdBQUduZ0MsS0FBS21GLEdBQUcsQ0FBQ2c3QixNQUFNLENBQUMsRUFBRSxFQUFFaGdDO1FBQ2hDZ2dDLE1BQU0sQ0FBQyxFQUFFLEdBQUduZ0MsS0FBS21GLEdBQUcsQ0FBQ2c3QixNQUFNLENBQUMsRUFBRSxFQUFFdHpCO1FBQ2hDc3pCLE1BQU0sQ0FBQyxFQUFFLEdBQUduZ0MsS0FBSzRQLEdBQUcsQ0FBQ3V3QixNQUFNLENBQUMsRUFBRSxFQUFFaGdDO1FBQ2hDZ2dDLE1BQU0sQ0FBQyxFQUFFLEdBQUduZ0MsS0FBSzRQLEdBQUcsQ0FBQ3V3QixNQUFNLENBQUMsRUFBRSxFQUFFdHpCO0lBQ2xDO0lBQ0EsT0FBTzAyQixnQkFBZ0JDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRXhELE1BQU0sRUFBRTtRQUM3Q0EsTUFBTSxDQUFDLEVBQUUsR0FBR25nQyxLQUFLbUYsR0FBRyxDQUFDZzdCLE1BQU0sQ0FBQyxFQUFFLEVBQUVxRCxJQUFJRTtRQUNwQ3ZELE1BQU0sQ0FBQyxFQUFFLEdBQUduZ0MsS0FBS21GLEdBQUcsQ0FBQ2c3QixNQUFNLENBQUMsRUFBRSxFQUFFc0QsSUFBSUU7UUFDcEN4RCxNQUFNLENBQUMsRUFBRSxHQUFHbmdDLEtBQUs0UCxHQUFHLENBQUN1d0IsTUFBTSxDQUFDLEVBQUUsRUFBRXFELElBQUlFO1FBQ3BDdkQsTUFBTSxDQUFDLEVBQUUsR0FBR25nQyxLQUFLNFAsR0FBRyxDQUFDdXdCLE1BQU0sQ0FBQyxFQUFFLEVBQUVzRCxJQUFJRTtJQUN0QztJQUNBLE9BQU8sQ0FBQ0Msa0JBQWtCLENBQUNKLEVBQUUsRUFBRUUsRUFBRSxFQUFFRyxFQUFFLEVBQUVDLEVBQUUsRUFBRUwsRUFBRSxFQUFFRSxFQUFFLEVBQUVJLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxDQUFDLEVBQUU5RCxNQUFNO1FBQ2xFLElBQUk4RCxLQUFLLEtBQUtBLEtBQUssR0FBRztZQUNwQjtRQUNGO1FBQ0EsTUFBTUMsS0FBSyxJQUFJRDtRQUNmLE1BQU1FLEtBQUtGLElBQUlBO1FBQ2YsTUFBTUcsTUFBTUQsS0FBS0Y7UUFDakIsTUFBTTlqQyxJQUFJK2pDLEtBQU1BLENBQUFBLEtBQU1BLENBQUFBLEtBQUtWLEtBQUssSUFBSVMsSUFBSVAsRUFBQyxJQUFLLElBQUlTLEtBQUtOLEVBQUMsSUFBS08sTUFBTU47UUFDbkUsTUFBTWozQixJQUFJcTNCLEtBQU1BLENBQUFBLEtBQU1BLENBQUFBLEtBQUtULEtBQUssSUFBSVEsSUFBSU4sRUFBQyxJQUFLLElBQUlRLEtBQUtKLEVBQUMsSUFBS0ssTUFBTUo7UUFDbkU3RCxNQUFNLENBQUMsRUFBRSxHQUFHbmdDLEtBQUttRixHQUFHLENBQUNnN0IsTUFBTSxDQUFDLEVBQUUsRUFBRWhnQztRQUNoQ2dnQyxNQUFNLENBQUMsRUFBRSxHQUFHbmdDLEtBQUttRixHQUFHLENBQUNnN0IsTUFBTSxDQUFDLEVBQUUsRUFBRXR6QjtRQUNoQ3N6QixNQUFNLENBQUMsRUFBRSxHQUFHbmdDLEtBQUs0UCxHQUFHLENBQUN1d0IsTUFBTSxDQUFDLEVBQUUsRUFBRWhnQztRQUNoQ2dnQyxNQUFNLENBQUMsRUFBRSxHQUFHbmdDLEtBQUs0UCxHQUFHLENBQUN1d0IsTUFBTSxDQUFDLEVBQUUsRUFBRXR6QjtJQUNsQztJQUNBLE9BQU8sQ0FBQ3czQixXQUFXLENBQUNiLEVBQUUsRUFBRUUsRUFBRSxFQUFFRyxFQUFFLEVBQUVDLEVBQUUsRUFBRUwsRUFBRSxFQUFFRSxFQUFFLEVBQUVJLEVBQUUsRUFBRUMsRUFBRSxFQUFFbm5CLENBQUMsRUFBRUMsQ0FBQyxFQUFFckQsQ0FBQyxFQUFFMG1CLE1BQU07UUFDakUsSUFBSW5nQyxLQUFLK0wsR0FBRyxDQUFDOFEsS0FBSyxPQUFPO1lBQ3ZCLElBQUk3YyxLQUFLK0wsR0FBRyxDQUFDK1EsTUFBTSxPQUFPO2dCQUN4QixJQUFJLENBQUMsQ0FBQzhtQixrQkFBa0IsQ0FBQ0osSUFBSUUsSUFBSUcsSUFBSUMsSUFBSUwsSUFBSUUsSUFBSUksSUFBSUMsSUFBSSxDQUFDdnFCLElBQUlxRCxHQUFHcWpCO1lBQ25FO1lBQ0E7UUFDRjtRQUNBLE1BQU1tRSxRQUFReG5CLEtBQUssSUFBSSxJQUFJckQsSUFBSW9EO1FBQy9CLElBQUl5bkIsUUFBUSxHQUFHO1lBQ2I7UUFDRjtRQUNBLE1BQU1DLFlBQVl2a0MsS0FBSzZpQyxJQUFJLENBQUN5QjtRQUM1QixNQUFNekMsS0FBSyxJQUFJaGxCO1FBQ2YsSUFBSSxDQUFDLENBQUMrbUIsa0JBQWtCLENBQUNKLElBQUlFLElBQUlHLElBQUlDLElBQUlMLElBQUlFLElBQUlJLElBQUlDLElBQUksQ0FBQyxDQUFDbG5CLElBQUl5bkIsU0FBUSxJQUFLMUMsSUFBSTFCO1FBQ2hGLElBQUksQ0FBQyxDQUFDeUQsa0JBQWtCLENBQUNKLElBQUlFLElBQUlHLElBQUlDLElBQUlMLElBQUlFLElBQUlJLElBQUlDLElBQUksQ0FBQyxDQUFDbG5CLElBQUl5bkIsU0FBUSxJQUFLMUMsSUFBSTFCO0lBQ2xGO0lBQ0EsT0FBT3FFLGtCQUFrQmhCLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUUsRUFBRSxFQUFFRSxFQUFFLEVBQUVELEVBQUUsRUFBRUUsRUFBRSxFQUFFN0QsTUFBTSxFQUFFO1FBQy9EQSxNQUFNLENBQUMsRUFBRSxHQUFHbmdDLEtBQUttRixHQUFHLENBQUNnN0IsTUFBTSxDQUFDLEVBQUUsRUFBRXFELElBQUlNO1FBQ3BDM0QsTUFBTSxDQUFDLEVBQUUsR0FBR25nQyxLQUFLbUYsR0FBRyxDQUFDZzdCLE1BQU0sQ0FBQyxFQUFFLEVBQUVzRCxJQUFJTztRQUNwQzdELE1BQU0sQ0FBQyxFQUFFLEdBQUduZ0MsS0FBSzRQLEdBQUcsQ0FBQ3V3QixNQUFNLENBQUMsRUFBRSxFQUFFcUQsSUFBSU07UUFDcEMzRCxNQUFNLENBQUMsRUFBRSxHQUFHbmdDLEtBQUs0UCxHQUFHLENBQUN1d0IsTUFBTSxDQUFDLEVBQUUsRUFBRXNELElBQUlPO1FBQ3BDLElBQUksQ0FBQyxDQUFDSyxXQUFXLENBQUNiLElBQUlFLElBQUlHLElBQUlDLElBQUlMLElBQUlFLElBQUlJLElBQUlDLElBQUksSUFBSyxFQUFDUixLQUFLLElBQUtFLENBQUFBLEtBQUtHLEVBQUMsSUFBS0MsRUFBQyxHQUFJLElBQUtOLENBQUFBLEtBQUssSUFBSUUsS0FBS0csRUFBQyxHQUFJLElBQUtILENBQUFBLEtBQUtGLEVBQUMsR0FBSXJEO1FBQ3pILElBQUksQ0FBQyxDQUFDa0UsV0FBVyxDQUFDYixJQUFJRSxJQUFJRyxJQUFJQyxJQUFJTCxJQUFJRSxJQUFJSSxJQUFJQyxJQUFJLElBQUssRUFBQ1AsS0FBSyxJQUFLRSxDQUFBQSxLQUFLSSxFQUFDLElBQUtDLEVBQUMsR0FBSSxJQUFLUCxDQUFBQSxLQUFLLElBQUlFLEtBQUtJLEVBQUMsR0FBSSxJQUFLSixDQUFBQSxLQUFLRixFQUFDLEdBQUl0RDtJQUMzSDtBQUNGO0FBQ0EsTUFBTXNFLDBCQUEyQixtQ0FBbUMsR0FBRyxRQUFTLENBQXdwQjtBQUN4dUIsU0FBU0Msa0JBQWtCdEcsR0FBRyxFQUFFdUcscUJBQXFCLEtBQUs7SUFDeEQsSUFBSXZHLEdBQUcsQ0FBQyxFQUFFLElBQUksUUFBUTtRQUNwQixJQUFJd0c7UUFDSixJQUFJeEcsR0FBRyxDQUFDLEVBQUUsS0FBSyxVQUFVQSxHQUFHLENBQUMsRUFBRSxLQUFLLFFBQVE7WUFDMUN3RyxXQUFXO1lBQ1gsSUFBSXhHLElBQUk1a0MsTUFBTSxHQUFHLE1BQU0sR0FBRztnQkFDeEI0a0MsTUFBTUEsSUFBSXJpQyxLQUFLLENBQUMsR0FBRyxDQUFDO1lBQ3RCO1FBQ0YsT0FBTyxJQUFJcWlDLEdBQUcsQ0FBQyxFQUFFLEtBQUssVUFBVUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxRQUFRO1lBQ2pEd0csV0FBVztZQUNYLElBQUl4RyxJQUFJNWtDLE1BQU0sR0FBRyxNQUFNLEdBQUc7Z0JBQ3hCNGtDLE1BQU1BLElBQUlyaUMsS0FBSyxDQUFDLEdBQUcsQ0FBQztZQUN0QjtRQUNGLE9BQU8sSUFBSXFpQyxHQUFHLENBQUMsRUFBRSxLQUFLLFVBQVVBLEdBQUcsQ0FBQyxFQUFFLEtBQUssVUFBVUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxRQUFRO1lBQ3RFd0csV0FBVztRQUNiO1FBQ0EsSUFBSUEsVUFBVTtZQUNaLElBQUk7Z0JBQ0YsTUFBTUMsVUFBVSxJQUFJQyxZQUFZRixVQUFVO29CQUN4Q0csT0FBTztnQkFDVDtnQkFDQSxNQUFNN21DLFNBQVNpZ0MsY0FBY0M7Z0JBQzdCLE1BQU00RyxVQUFVSCxRQUFRSSxNQUFNLENBQUMvbUM7Z0JBQy9CLElBQUl5bUMsc0JBQXNCLENBQUNLLFFBQVEvMUIsUUFBUSxDQUFDLFNBQVM7b0JBQ25ELE9BQU8rMUI7Z0JBQ1Q7Z0JBQ0EsT0FBT0EsUUFBUUUsVUFBVSxDQUFDLDJCQUEyQjtZQUN2RCxFQUFFLE9BQU9DLElBQUk7Z0JBQ1hwSixLQUFLLENBQUMsb0JBQW9CLEVBQUVvSixHQUFHLEVBQUUsQ0FBQztZQUNwQztRQUNGO0lBQ0Y7SUFDQSxNQUFNbkgsU0FBUyxFQUFFO0lBQ2pCLElBQUssSUFBSTcvQixJQUFJLEdBQUdpbkMsS0FBS2hILElBQUk1a0MsTUFBTSxFQUFFMkUsSUFBSWluQyxJQUFJam5DLElBQUs7UUFDNUMsTUFBTWtuQyxXQUFXakgsSUFBSUMsVUFBVSxDQUFDbGdDO1FBQ2hDLElBQUksQ0FBQ3dtQyxzQkFBc0JVLGFBQWEsTUFBTTtZQUM1QyxNQUFPLEVBQUVsbkMsSUFBSWluQyxNQUFNaEgsSUFBSUMsVUFBVSxDQUFDbGdDLE9BQU8sS0FBTSxDQUFDO1lBQ2hEO1FBQ0Y7UUFDQSxNQUFNay9CLE9BQU9vSCx1QkFBdUIsQ0FBQ1ksU0FBUztRQUM5Q3JILE9BQU92NUIsSUFBSSxDQUFDNDRCLE9BQU8xaEMsT0FBTzRtQixZQUFZLENBQUM4YSxRQUFRZSxJQUFJM3pCLE1BQU0sQ0FBQ3RNO0lBQzVEO0lBQ0EsT0FBTzYvQixPQUFPL2hDLElBQUksQ0FBQztBQUNyQjtBQUNBLFNBQVMwZ0MsbUJBQW1CeUIsR0FBRztJQUM3QixPQUFPa0gsbUJBQW1CQyxPQUFPbkg7QUFDbkM7QUFDQSxTQUFTb0gsbUJBQW1CcEgsR0FBRztJQUM3QixPQUFPcUgsU0FBU0MsbUJBQW1CdEg7QUFDckM7QUFDQSxTQUFTdUgsYUFBYUMsSUFBSSxFQUFFQyxJQUFJO0lBQzlCLElBQUlELEtBQUtwc0MsTUFBTSxLQUFLcXNDLEtBQUtyc0MsTUFBTSxFQUFFO1FBQy9CLE9BQU87SUFDVDtJQUNBLElBQUssSUFBSTJFLElBQUksR0FBR2luQyxLQUFLUSxLQUFLcHNDLE1BQU0sRUFBRTJFLElBQUlpbkMsSUFBSWpuQyxJQUFLO1FBQzdDLElBQUl5bkMsSUFBSSxDQUFDem5DLEVBQUUsS0FBSzBuQyxJQUFJLENBQUMxbkMsRUFBRSxFQUFFO1lBQ3ZCLE9BQU87UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBUzJuQyxvQkFBb0JDLE9BQU8sSUFBSUMsTUFBTTtJQUM1QyxJQUFJLENBQUVELENBQUFBLGdCQUFnQkMsSUFBRyxHQUFJO1FBQzNCRCxPQUFPLElBQUlDLEtBQUtEO0lBQ2xCO0lBQ0EsTUFBTTduQyxTQUFTO1FBQUM2bkMsS0FBS0UsY0FBYyxHQUFHOW9DLFFBQVE7UUFBSzRvQyxDQUFBQSxLQUFLRyxXQUFXLEtBQUssR0FBRy9vQyxRQUFRLEdBQUd3aUMsUUFBUSxDQUFDLEdBQUc7UUFBTW9HLEtBQUtJLFVBQVUsR0FBR2hwQyxRQUFRLEdBQUd3aUMsUUFBUSxDQUFDLEdBQUc7UUFBTW9HLEtBQUtLLFdBQVcsR0FBR2pwQyxRQUFRLEdBQUd3aUMsUUFBUSxDQUFDLEdBQUc7UUFBTW9HLEtBQUtNLGFBQWEsR0FBR2xwQyxRQUFRLEdBQUd3aUMsUUFBUSxDQUFDLEdBQUc7UUFBTW9HLEtBQUtPLGFBQWEsR0FBR25wQyxRQUFRLEdBQUd3aUMsUUFBUSxDQUFDLEdBQUc7S0FBSztJQUMxUyxPQUFPemhDLE9BQU9qQyxJQUFJLENBQUM7QUFDckI7QUFDQSxJQUFJc3FDLGlCQUFpQjtBQUNyQixJQUFJQyxtQkFBbUI7QUFDdkIsU0FBU0MsaUJBQWlCckksR0FBRztJQUMzQixJQUFJLENBQUNtSSxnQkFBZ0I7UUFDbkJBLGlCQUFpQjtRQUNqQkMsbUJBQW1CLElBQUlFLElBQUk7WUFBQztnQkFBQztnQkFBSzthQUFLO1NBQUM7SUFDMUM7SUFDQSxPQUFPdEksSUFBSThHLFVBQVUsQ0FBQ3FCLGdCQUFnQixDQUFDSSxHQUFHL0YsSUFBSWdHLEtBQU9oRyxLQUFLQSxHQUFHNTJCLFNBQVMsQ0FBQyxVQUFVdzhCLGlCQUFpQi9xQyxHQUFHLENBQUNtckM7QUFDeEc7QUFDQSxTQUFTQztJQUNQLElBQUksT0FBT0MsT0FBT0MsVUFBVSxLQUFLLFlBQVk7UUFDM0MsT0FBT0QsT0FBT0MsVUFBVTtJQUMxQjtJQUNBLE1BQU1DLE1BQU0sSUFBSWpwQyxXQUFXO0lBQzNCK29DLE9BQU9HLGVBQWUsQ0FBQ0Q7SUFDdkIsT0FBT2xKLGNBQWNrSjtBQUN2QjtBQUNBLE1BQU1FLG1CQUFtQjtBQUN6QixTQUFTQyxxQkFBcUJDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxJQUFJO0lBQ3JELElBQUksQ0FBQy83QixNQUFNK0YsT0FBTyxDQUFDZzJCLFNBQVNBLEtBQUs5dEMsTUFBTSxHQUFHLEdBQUc7UUFDM0MsT0FBTztJQUNUO0lBQ0EsTUFBTSxDQUFDK3RDLE1BQU1DLE1BQU0sR0FBRy9qQyxLQUFLLEdBQUc2akM7SUFDOUIsSUFBSSxDQUFDRixTQUFTRyxTQUFTLENBQUNuN0IsT0FBT3N2QixTQUFTLENBQUM2TCxPQUFPO1FBQzlDLE9BQU87SUFDVDtJQUNBLElBQUksQ0FBQ0YsVUFBVUcsT0FBTztRQUNwQixPQUFPO0lBQ1Q7SUFDQSxNQUFNQyxVQUFVaGtDLEtBQUtqSyxNQUFNO0lBQzNCLElBQUlrdUMsWUFBWTtJQUNoQixPQUFRRixLQUFLbHJDLElBQUk7UUFDZixLQUFLO1lBQ0gsSUFBSW1yQyxVQUFVLEtBQUtBLFVBQVUsR0FBRztnQkFDOUIsT0FBTztZQUNUO1lBQ0E7UUFDRixLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU9BLFlBQVk7UUFDckIsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILElBQUlBLFVBQVUsR0FBRztnQkFDZixPQUFPO1lBQ1Q7WUFDQTtRQUNGLEtBQUs7WUFDSCxJQUFJQSxZQUFZLEdBQUc7Z0JBQ2pCLE9BQU87WUFDVDtZQUNBQyxZQUFZO1lBQ1o7UUFDRjtZQUNFLE9BQU87SUFDWDtJQUNBLEtBQUssTUFBTXJoQixPQUFPNWlCLEtBQU07UUFDdEIsSUFBSSxPQUFPNGlCLFFBQVEsWUFBWXFoQixhQUFhcmhCLFFBQVEsTUFBTTtZQUN4RDtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBU3NoQixVQUFVL3pCLENBQUMsRUFBRXpPLEdBQUcsRUFBRXlLLEdBQUc7SUFDNUIsT0FBTzVQLEtBQUttRixHQUFHLENBQUNuRixLQUFLNFAsR0FBRyxDQUFDZ0UsR0FBR3pPLE1BQU15SztBQUNwQztBQUNBLFNBQVNnNEIsVUFBVUMsR0FBRztJQUNwQixJQUFJOXBDLFdBQVdqQixTQUFTLENBQUNtQixLQUFLLEVBQUU7UUFDOUIsT0FBTzRwQyxJQUFJNXBDLEtBQUs7SUFDbEI7SUFDQSxPQUFPc04sTUFBTXFXLElBQUksQ0FBQ2ltQixLQUFLQyxDQUFBQSxNQUFPcEksVUFBVSxDQUFDb0ksSUFBSSxFQUFFN3JDLElBQUksQ0FBQztBQUN0RDtBQUNBLFNBQVM4ckMsYUFBYUYsR0FBRztJQUN2QixJQUFJOXBDLFdBQVdqQixTQUFTLENBQUNvc0IsUUFBUSxFQUFFO1FBQ2pDLE9BQU8yZSxJQUFJM2UsUUFBUTtJQUNyQjtJQUNBLE9BQU84ZSxLQUFLbEssY0FBYytKO0FBQzVCO0FBQ0EsU0FBU0ksZUFBZTdKLEdBQUc7SUFDekIsSUFBSXJnQyxXQUFXMmQsVUFBVSxFQUFFO1FBQ3pCLE9BQU8zZCxXQUFXMmQsVUFBVSxDQUFDMGlCO0lBQy9CO0lBQ0EsT0FBT0QsY0FBYytKLEtBQUs5SjtBQUM1QjtBQUNBLElBQUksT0FBT3ArQixLQUFLZ04sVUFBVSxLQUFLLFlBQVk7SUFDekNoTixLQUFLZ04sVUFBVSxHQUFHLFNBQVVFLE9BQU87UUFDakMsT0FBT0EsUUFBUWdXLE1BQU0sQ0FBQyxDQUFDckcsR0FBR0MsSUFBTUQsSUFBSUMsR0FBRztJQUN6QztBQUNGO0FBQ0EsSUFBSSxPQUFPcXJCLFlBQVlDLEdBQUcsS0FBSyxZQUFZO0lBQ3pDRCxZQUFZQyxHQUFHLEdBQUcsU0FBVTMvQixRQUFRO1FBQ2xDLE1BQU00L0IsS0FBSyxJQUFJQztRQUNmLE1BQU0sRUFDSkMsTUFBTSxFQUNQLEdBQUdGO1FBQ0osS0FBSyxNQUFNN3VCLEtBQUsvUSxTQUFVO1lBQ3hCLElBQUkrUSxFQUFFZ3ZCLE9BQU8sRUFBRTtnQkFDYkgsR0FBR0ksS0FBSyxDQUFDanZCLEVBQUVrdkIsTUFBTTtnQkFDakIsT0FBT0g7WUFDVDtRQUNGO1FBQ0EsS0FBSyxNQUFNL3VCLEtBQUsvUSxTQUFVO1lBQ3hCK1EsRUFBRW12QixnQkFBZ0IsQ0FBQyxTQUFTO2dCQUMxQk4sR0FBR0ksS0FBSyxDQUFDanZCLEVBQUVrdkIsTUFBTTtZQUNuQixHQUFHO2dCQUNESDtZQUNGO1FBQ0Y7UUFDQSxPQUFPQTtJQUNUO0FBQ0Y7QUFFQSxxRUFBcUU7QUFDckUsSUFBSUssa0JBQWtCbndDLGlDQUFtQkEsQ0FBQztBQUMxQyxrRkFBa0Y7QUFDbEYsSUFBSW93QywrQkFBK0Jwd0MsaUNBQW1CQSxDQUFDO0FBQ3ZELCtFQUErRTtBQUMvRSxJQUFJcXdDLDRCQUE0QnJ3QyxpQ0FBbUJBLENBQUM7QUFDcEQsZ0ZBQWdGO0FBQ2hGLElBQUlzd0MsNkJBQTZCdHdDLGlDQUFtQkEsQ0FBQztFQUNwRCw0QkFBNEI7QUFFN0IsTUFBTXV3QztJQUNKLE9BQU9DLFlBQVlDLEdBQUcsRUFBRTtRQUN0QixNQUFNajhCLFFBQVEsRUFBRTtRQUNoQixNQUFNczBCLFNBQVM7WUFDYnQwQjtZQUNBazhCLFFBQVF0dEMsT0FBTytMLE1BQU0sQ0FBQztRQUN4QjtRQUNBLFNBQVN3aEMsS0FBSzFrQixJQUFJO1lBQ2hCLElBQUksQ0FBQ0EsTUFBTTtnQkFDVDtZQUNGO1lBQ0EsSUFBSTBaLE1BQU07WUFDVixNQUFNOWhDLE9BQU9vb0IsS0FBS3BvQixJQUFJO1lBQ3RCLElBQUlBLFNBQVMsU0FBUztnQkFDcEI4aEMsTUFBTTFaLEtBQUtqcUIsS0FBSztZQUNsQixPQUFPLElBQUksQ0FBQ3V1QyxRQUFRSyxlQUFlLENBQUMvc0MsT0FBTztnQkFDekM7WUFDRixPQUFPLElBQUlvb0IsTUFBTTRrQixZQUFZTCxhQUFhO2dCQUN4QzdLLE1BQU0xWixLQUFLNGtCLFVBQVUsQ0FBQ0wsV0FBVztZQUNuQyxPQUFPLElBQUl2a0IsS0FBS2pxQixLQUFLLEVBQUU7Z0JBQ3JCMmpDLE1BQU0xWixLQUFLanFCLEtBQUs7WUFDbEI7WUFDQSxJQUFJMmpDLFFBQVEsTUFBTTtnQkFDaEJueEIsTUFBTXhJLElBQUksQ0FBQztvQkFDVDI1QjtnQkFDRjtZQUNGO1lBQ0EsSUFBSSxDQUFDMVosS0FBSzZrQixRQUFRLEVBQUU7Z0JBQ2xCO1lBQ0Y7WUFDQSxLQUFLLE1BQU1DLFNBQVM5a0IsS0FBSzZrQixRQUFRLENBQUU7Z0JBQ2pDSCxLQUFLSTtZQUNQO1FBQ0Y7UUFDQUosS0FBS0Y7UUFDTCxPQUFPM0g7SUFDVDtJQUNBLE9BQU84SCxnQkFBZ0Ivc0MsSUFBSSxFQUFFO1FBQzNCLE9BQU8sQ0FBRUEsQ0FBQUEsU0FBUyxjQUFjQSxTQUFTLFdBQVdBLFNBQVMsWUFBWUEsU0FBUyxRQUFPO0lBQzNGO0FBQ0Y7RUFFQyw2QkFBNkI7QUFHOUIsTUFBTW10QztJQUNKLE9BQU9DLGFBQWE1akMsSUFBSSxFQUFFcUksRUFBRSxFQUFFdzdCLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUU7UUFDdEQsTUFBTUMsYUFBYUYsUUFBUUcsUUFBUSxDQUFDNTdCLElBQUk7WUFDdEMxVCxPQUFPO1FBQ1Q7UUFDQSxPQUFRa3ZDLFFBQVFydEMsSUFBSTtZQUNsQixLQUFLO2dCQUNILElBQUl3dEMsV0FBV3J2QyxLQUFLLEtBQUssTUFBTTtvQkFDN0JxTCxLQUFLbWpDLFdBQVcsR0FBR2EsV0FBV3J2QyxLQUFLO2dCQUNyQztnQkFDQSxJQUFJb3ZDLFdBQVcsU0FBUztvQkFDdEI7Z0JBQ0Y7Z0JBQ0EvakMsS0FBSzZpQyxnQkFBZ0IsQ0FBQyxTQUFTcUIsQ0FBQUE7b0JBQzdCSixRQUFRSyxRQUFRLENBQUM5N0IsSUFBSTt3QkFDbkIxVCxPQUFPdXZDLE1BQU1od0MsTUFBTSxDQUFDUyxLQUFLO29CQUMzQjtnQkFDRjtnQkFDQTtZQUNGLEtBQUs7Z0JBQ0gsSUFBSWt2QyxRQUFRTCxVQUFVLENBQUNubkMsSUFBSSxLQUFLLFdBQVd3bkMsUUFBUUwsVUFBVSxDQUFDbm5DLElBQUksS0FBSyxZQUFZO29CQUNqRixJQUFJMm5DLFdBQVdydkMsS0FBSyxLQUFLa3ZDLFFBQVFMLFVBQVUsQ0FBQ1ksS0FBSyxFQUFFO3dCQUNqRHBrQyxLQUFLcWtDLFlBQVksQ0FBQyxXQUFXO29CQUMvQixPQUFPLElBQUlMLFdBQVdydkMsS0FBSyxLQUFLa3ZDLFFBQVFMLFVBQVUsQ0FBQ2MsTUFBTSxFQUFFO3dCQUN6RHRrQyxLQUFLdWtDLGVBQWUsQ0FBQztvQkFDdkI7b0JBQ0EsSUFBSVIsV0FBVyxTQUFTO3dCQUN0QjtvQkFDRjtvQkFDQS9qQyxLQUFLNmlDLGdCQUFnQixDQUFDLFVBQVVxQixDQUFBQTt3QkFDOUJKLFFBQVFLLFFBQVEsQ0FBQzk3QixJQUFJOzRCQUNuQjFULE9BQU91dkMsTUFBTWh3QyxNQUFNLENBQUNzd0MsT0FBTyxHQUFHTixNQUFNaHdDLE1BQU0sQ0FBQ3V3QyxZQUFZLENBQUMsV0FBV1AsTUFBTWh3QyxNQUFNLENBQUN1d0MsWUFBWSxDQUFDO3dCQUMvRjtvQkFDRjtnQkFDRixPQUFPO29CQUNMLElBQUlULFdBQVdydkMsS0FBSyxLQUFLLE1BQU07d0JBQzdCcUwsS0FBS3FrQyxZQUFZLENBQUMsU0FBU0wsV0FBV3J2QyxLQUFLO29CQUM3QztvQkFDQSxJQUFJb3ZDLFdBQVcsU0FBUzt3QkFDdEI7b0JBQ0Y7b0JBQ0EvakMsS0FBSzZpQyxnQkFBZ0IsQ0FBQyxTQUFTcUIsQ0FBQUE7d0JBQzdCSixRQUFRSyxRQUFRLENBQUM5N0IsSUFBSTs0QkFDbkIxVCxPQUFPdXZDLE1BQU1od0MsTUFBTSxDQUFDUyxLQUFLO3dCQUMzQjtvQkFDRjtnQkFDRjtnQkFDQTtZQUNGLEtBQUs7Z0JBQ0gsSUFBSXF2QyxXQUFXcnZDLEtBQUssS0FBSyxNQUFNO29CQUM3QnFMLEtBQUtxa0MsWUFBWSxDQUFDLFNBQVNMLFdBQVdydkMsS0FBSztvQkFDM0MsS0FBSyxNQUFNK3ZDLFVBQVViLFFBQVFKLFFBQVEsQ0FBRTt3QkFDckMsSUFBSWlCLE9BQU9sQixVQUFVLENBQUM3dUMsS0FBSyxLQUFLcXZDLFdBQVdydkMsS0FBSyxFQUFFOzRCQUNoRCt2QyxPQUFPbEIsVUFBVSxDQUFDbUIsUUFBUSxHQUFHO3dCQUMvQixPQUFPLElBQUlELE9BQU9sQixVQUFVLENBQUM5cEMsY0FBYyxDQUFDLGFBQWE7NEJBQ3ZELE9BQU9nckMsT0FBT2xCLFVBQVUsQ0FBQ21CLFFBQVE7d0JBQ25DO29CQUNGO2dCQUNGO2dCQUNBM2tDLEtBQUs2aUMsZ0JBQWdCLENBQUMsU0FBU3FCLENBQUFBO29CQUM3QixNQUFNenRDLFVBQVV5dEMsTUFBTWh3QyxNQUFNLENBQUN1QyxPQUFPO29CQUNwQyxNQUFNOUIsUUFBUThCLFFBQVFtdUMsYUFBYSxLQUFLLENBQUMsSUFBSSxLQUFLbnVDLE9BQU8sQ0FBQ0EsUUFBUW11QyxhQUFhLENBQUMsQ0FBQ2p3QyxLQUFLO29CQUN0Rm12QyxRQUFRSyxRQUFRLENBQUM5N0IsSUFBSTt3QkFDbkIxVDtvQkFDRjtnQkFDRjtnQkFDQTtRQUNKO0lBQ0Y7SUFDQSxPQUFPa3dDLGNBQWMsRUFDbkI3a0MsSUFBSSxFQUNKNmpDLE9BQU8sRUFDUEMsVUFBVSxJQUFJLEVBQ2RDLE1BQU0sRUFDTmUsV0FBVyxFQUNaLEVBQUU7UUFDRCxNQUFNLEVBQ0p0QixVQUFVLEVBQ1gsR0FBR0s7UUFDSixNQUFNa0Isc0JBQXNCL2tDLGdCQUFnQmdsQztRQUM1QyxJQUFJeEIsV0FBV25uQyxJQUFJLEtBQUssU0FBUztZQUMvQm1uQyxXQUFXaHRDLElBQUksR0FBRyxDQUFDLEVBQUVndEMsV0FBV2h0QyxJQUFJLENBQUMsQ0FBQyxFQUFFdXRDLE9BQU8sQ0FBQztRQUNsRDtRQUNBLEtBQUssTUFBTSxDQUFDamxDLEtBQUtuSyxNQUFNLElBQUlvQixPQUFPOFgsT0FBTyxDQUFDMjFCLFlBQWE7WUFDckQsSUFBSTd1QyxVQUFVLFFBQVFBLFVBQVVzQyxXQUFXO2dCQUN6QztZQUNGO1lBQ0EsT0FBUTZIO2dCQUNOLEtBQUs7b0JBQ0gsSUFBSW5LLE1BQU1qQixNQUFNLEVBQUU7d0JBQ2hCc00sS0FBS3FrQyxZQUFZLENBQUN2bEMsS0FBS25LLE1BQU13QixJQUFJLENBQUM7b0JBQ3BDO29CQUNBO2dCQUNGLEtBQUs7b0JBQ0g7Z0JBQ0YsS0FBSztvQkFDSDZKLEtBQUtxa0MsWUFBWSxDQUFDLG1CQUFtQjF2QztvQkFDckM7Z0JBQ0YsS0FBSztvQkFDSG9CLE9BQU9rdkMsTUFBTSxDQUFDamxDLEtBQUtvQixLQUFLLEVBQUV6TTtvQkFDMUI7Z0JBQ0YsS0FBSztvQkFDSHFMLEtBQUttakMsV0FBVyxHQUFHeHVDO29CQUNuQjtnQkFDRjtvQkFDRSxJQUFJLENBQUNvd0MsdUJBQXVCam1DLFFBQVEsVUFBVUEsUUFBUSxhQUFhO3dCQUNqRWtCLEtBQUtxa0MsWUFBWSxDQUFDdmxDLEtBQUtuSztvQkFDekI7WUFDSjtRQUNGO1FBQ0EsSUFBSW93QyxxQkFBcUI7WUFDdkJELFlBQVlJLGlCQUFpQixDQUFDbGxDLE1BQU13akMsV0FBV3RwQixJQUFJLEVBQUVzcEIsV0FBVzJCLFNBQVM7UUFDM0U7UUFDQSxJQUFJckIsV0FBV04sV0FBVzRCLE1BQU0sRUFBRTtZQUNoQyxJQUFJLENBQUN4QixZQUFZLENBQUM1akMsTUFBTXdqQyxXQUFXNEIsTUFBTSxFQUFFdkIsU0FBU0M7UUFDdEQ7SUFDRjtJQUNBLE9BQU91QixPQUFPQyxVQUFVLEVBQUU7UUFDeEIsTUFBTXhCLFVBQVV3QixXQUFXQyxpQkFBaUI7UUFDNUMsTUFBTVQsY0FBY1EsV0FBV1IsV0FBVztRQUMxQyxNQUFNdm1CLE9BQU8rbUIsV0FBV0UsT0FBTztRQUMvQixNQUFNekIsU0FBU3VCLFdBQVd2QixNQUFNLElBQUk7UUFDcEMsTUFBTTBCLFdBQVdoa0MsU0FBUzJJLGFBQWEsQ0FBQ21VLEtBQUsvbkIsSUFBSTtRQUNqRCxJQUFJK25CLEtBQUtpbEIsVUFBVSxFQUFFO1lBQ25CLElBQUksQ0FBQ3FCLGFBQWEsQ0FBQztnQkFDakI3a0MsTUFBTXlsQztnQkFDTjVCLFNBQVN0bEI7Z0JBQ1R3bEI7Z0JBQ0FlO1lBQ0Y7UUFDRjtRQUNBLE1BQU1ZLG1CQUFtQjNCLFdBQVc7UUFDcEMsTUFBTTRCLFVBQVVMLFdBQVdNLEdBQUc7UUFDOUJELFFBQVFuNEIsTUFBTSxDQUFDaTRCO1FBQ2YsSUFBSUgsV0FBV08sUUFBUSxFQUFFO1lBQ3ZCLE1BQU14VixZQUFZLENBQUMsT0FBTyxFQUFFaVYsV0FBV08sUUFBUSxDQUFDeFYsU0FBUyxDQUFDbDZCLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN0RXd2QyxRQUFRdmtDLEtBQUssQ0FBQ2l2QixTQUFTLEdBQUdBO1FBQzVCO1FBQ0EsSUFBSXFWLGtCQUFrQjtZQUNwQkMsUUFBUXRCLFlBQVksQ0FBQyxTQUFTO1FBQ2hDO1FBQ0EsTUFBTXlCLFdBQVcsRUFBRTtRQUNuQixJQUFJdm5CLEtBQUtrbEIsUUFBUSxDQUFDL3ZDLE1BQU0sS0FBSyxHQUFHO1lBQzlCLElBQUk2cUIsS0FBSzVwQixLQUFLLEVBQUU7Z0JBQ2QsTUFBTWlxQixPQUFPbmQsU0FBU3NrQyxjQUFjLENBQUN4bkIsS0FBSzVwQixLQUFLO2dCQUMvQzh3QyxTQUFTajRCLE1BQU0sQ0FBQ29SO2dCQUNoQixJQUFJOG1CLG9CQUFvQnhDLFFBQVFLLGVBQWUsQ0FBQ2hsQixLQUFLL25CLElBQUksR0FBRztvQkFDMURzdkMsU0FBU25uQyxJQUFJLENBQUNpZ0I7Z0JBQ2hCO1lBQ0Y7WUFDQSxPQUFPO2dCQUNMa25CO1lBQ0Y7UUFDRjtRQUNBLE1BQU03eUIsUUFBUTtZQUFDO2dCQUFDc0w7Z0JBQU0sQ0FBQztnQkFBR2tuQjthQUFTO1NBQUM7UUFDcEMsTUFBT3h5QixNQUFNdmYsTUFBTSxHQUFHLEVBQUc7WUFDdkIsTUFBTSxDQUFDc3lDLFFBQVEzdEMsR0FBRzJILEtBQUssR0FBR2lULE1BQU15SixFQUFFLENBQUMsQ0FBQztZQUNwQyxJQUFJcmtCLElBQUksTUFBTTJ0QyxPQUFPdkMsUUFBUSxDQUFDL3ZDLE1BQU0sRUFBRTtnQkFDcEN1ZixNQUFNZ3pCLEdBQUc7Z0JBQ1Q7WUFDRjtZQUNBLE1BQU12QyxRQUFRc0MsT0FBT3ZDLFFBQVEsQ0FBQyxFQUFFeHdCLE1BQU15SixFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ2hELElBQUlnbkIsVUFBVSxNQUFNO2dCQUNsQjtZQUNGO1lBQ0EsTUFBTSxFQUNKbHRDLElBQUksRUFDTCxHQUFHa3RDO1lBQ0osSUFBSWx0QyxTQUFTLFNBQVM7Z0JBQ3BCLE1BQU1vb0IsT0FBT25kLFNBQVNza0MsY0FBYyxDQUFDckMsTUFBTS91QyxLQUFLO2dCQUNoRG14QyxTQUFTbm5DLElBQUksQ0FBQ2lnQjtnQkFDZDVlLEtBQUt3TixNQUFNLENBQUNvUjtnQkFDWjtZQUNGO1lBQ0EsTUFBTXNuQixZQUFZeEMsT0FBT0YsWUFBWTJDLFFBQVExa0MsU0FBUzJrQyxlQUFlLENBQUMxQyxNQUFNRixVQUFVLENBQUMyQyxLQUFLLEVBQUUzdkMsUUFBUWlMLFNBQVMySSxhQUFhLENBQUM1VDtZQUM3SHdKLEtBQUt3TixNQUFNLENBQUMwNEI7WUFDWixJQUFJeEMsTUFBTUYsVUFBVSxFQUFFO2dCQUNwQixJQUFJLENBQUNxQixhQUFhLENBQUM7b0JBQ2pCN2tDLE1BQU1rbUM7b0JBQ05yQyxTQUFTSDtvQkFDVEk7b0JBQ0FDO29CQUNBZTtnQkFDRjtZQUNGO1lBQ0EsSUFBSXBCLE1BQU1ELFFBQVEsRUFBRS92QyxTQUFTLEdBQUc7Z0JBQzlCdWYsTUFBTXRVLElBQUksQ0FBQztvQkFBQytrQztvQkFBTyxDQUFDO29CQUFHd0M7aUJBQVU7WUFDbkMsT0FBTyxJQUFJeEMsTUFBTS91QyxLQUFLLEVBQUU7Z0JBQ3RCLE1BQU1pcUIsT0FBT25kLFNBQVNza0MsY0FBYyxDQUFDckMsTUFBTS91QyxLQUFLO2dCQUNoRCxJQUFJK3dDLG9CQUFvQnhDLFFBQVFLLGVBQWUsQ0FBQy9zQyxPQUFPO29CQUNyRHN2QyxTQUFTbm5DLElBQUksQ0FBQ2lnQjtnQkFDaEI7Z0JBQ0FzbkIsVUFBVTE0QixNQUFNLENBQUNvUjtZQUNuQjtRQUNGO1FBQ0EsS0FBSyxNQUFNMkYsTUFBTW9oQixRQUFRVSxnQkFBZ0IsQ0FBQyx5REFBMEQ7WUFDbEc5aEIsR0FBRzhmLFlBQVksQ0FBQyxZQUFZO1FBQzlCO1FBQ0EsT0FBTztZQUNMeUI7UUFDRjtJQUNGO0lBQ0EsT0FBT1EsT0FBT2hCLFVBQVUsRUFBRTtRQUN4QixNQUFNalYsWUFBWSxDQUFDLE9BQU8sRUFBRWlWLFdBQVdPLFFBQVEsQ0FBQ3hWLFNBQVMsQ0FBQ2w2QixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEVtdkMsV0FBV00sR0FBRyxDQUFDeGtDLEtBQUssQ0FBQ2l2QixTQUFTLEdBQUdBO1FBQ2pDaVYsV0FBV00sR0FBRyxDQUFDVyxNQUFNLEdBQUc7SUFDMUI7QUFDRjtFQUVDLGlDQUFpQztBQWNsQyxNQUFNQyxTQUFTO0FBQ2YsTUFBTUM7O2FBQ0cvTSxNQUFNOzs7YUFDTmdOLE1BQU07OzthQUNOQyxtQkFBbUIsSUFBSSxDQUFDak4sR0FBRyxHQUFHLElBQUksQ0FBQ2dOLEdBQUc7O0FBQy9DO0FBQ0EsZUFBZUUsVUFBVXZ2QixHQUFHLEVBQUVoYixPQUFPLE1BQU07SUFDekMsSUFBSXdxQyxnQkFBZ0J4dkIsS0FBSzVWLFNBQVNxbEMsT0FBTyxHQUFHO1FBQzFDLE1BQU1DLFdBQVcsTUFBTUMsTUFBTTN2QjtRQUM3QixJQUFJLENBQUMwdkIsU0FBU0UsRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSXAxQixNQUFNazFCLFNBQVNHLFVBQVU7UUFDckM7UUFDQSxPQUFRN3FDO1lBQ04sS0FBSztnQkFDSCxPQUFPMHFDLFNBQVN0d0IsV0FBVztZQUM3QixLQUFLO2dCQUNILE9BQU9zd0IsU0FBU0ksSUFBSTtZQUN0QixLQUFLO2dCQUNILE9BQU9KLFNBQVNLLElBQUk7UUFDeEI7UUFDQSxPQUFPTCxTQUFTN21CLElBQUk7SUFDdEI7SUFDQSxPQUFPLElBQUkzaUIsUUFBUSxDQUFDUSxTQUFTRDtRQUMzQixNQUFNdXBDLFVBQVUsSUFBSUM7UUFDcEJELFFBQVEzbEMsSUFBSSxDQUFDLE9BQU8yVixLQUFLO1FBQ3pCZ3dCLFFBQVFFLFlBQVksR0FBR2xyQztRQUN2QmdyQyxRQUFRRyxrQkFBa0IsR0FBRztZQUMzQixJQUFJSCxRQUFRSSxVQUFVLEtBQUtILGVBQWVJLElBQUksRUFBRTtnQkFDOUM7WUFDRjtZQUNBLElBQUlMLFFBQVF6UCxNQUFNLEtBQUssT0FBT3lQLFFBQVF6UCxNQUFNLEtBQUssR0FBRztnQkFDbEQsT0FBUXY3QjtvQkFDTixLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSzt3QkFDSDBCLFFBQVFzcEMsUUFBUU4sUUFBUTt3QkFDeEI7Z0JBQ0o7Z0JBQ0FocEMsUUFBUXNwQyxRQUFRTSxZQUFZO2dCQUM1QjtZQUNGO1lBQ0E3cEMsT0FBTyxJQUFJK1QsTUFBTXcxQixRQUFRSCxVQUFVO1FBQ3JDO1FBQ0FHLFFBQVFPLElBQUksQ0FBQztJQUNmO0FBQ0Y7QUFDQSxNQUFNQztJQUNKL3dDLFlBQVksRUFDVmd4QyxPQUFPLEVBQ1BDLFFBQVEsRUFDUkMsS0FBSyxFQUNMQyxRQUFRLEVBQ1JDLFVBQVUsQ0FBQyxFQUNYQyxVQUFVLENBQUMsRUFDWEMsV0FBVyxLQUFLLEVBQ2pCLENBQUU7UUFDRCxJQUFJLENBQUNOLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmSCxTQUFTRDtRQUNULE1BQU1NLFVBQVUsQ0FBQ1AsT0FBTyxDQUFDLEVBQUUsR0FBR0EsT0FBTyxDQUFDLEVBQUUsSUFBSTtRQUM1QyxNQUFNUSxVQUFVLENBQUNSLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLElBQUk7UUFDNUMsSUFBSVMsU0FBU0MsU0FBU0MsU0FBU0M7UUFDL0JULFlBQVk7UUFDWixJQUFJQSxXQUFXLEdBQUc7WUFDaEJBLFlBQVk7UUFDZDtRQUNBLE9BQVFBO1lBQ04sS0FBSztnQkFDSE0sVUFBVSxDQUFDO2dCQUNYQyxVQUFVO2dCQUNWQyxVQUFVO2dCQUNWQyxVQUFVO2dCQUNWO1lBQ0YsS0FBSztnQkFDSEgsVUFBVTtnQkFDVkMsVUFBVTtnQkFDVkMsVUFBVTtnQkFDVkMsVUFBVTtnQkFDVjtZQUNGLEtBQUs7Z0JBQ0hILFVBQVU7Z0JBQ1ZDLFVBQVUsQ0FBQztnQkFDWEMsVUFBVSxDQUFDO2dCQUNYQyxVQUFVO2dCQUNWO1lBQ0YsS0FBSztnQkFDSEgsVUFBVTtnQkFDVkMsVUFBVTtnQkFDVkMsVUFBVTtnQkFDVkMsVUFBVSxDQUFDO2dCQUNYO1lBQ0Y7Z0JBQ0UsTUFBTSxJQUFJNzJCLE1BQU07UUFDcEI7UUFDQSxJQUFJdTJCLFVBQVU7WUFDWkssVUFBVSxDQUFDQTtZQUNYQyxVQUFVLENBQUNBO1FBQ2I7UUFDQSxJQUFJQyxlQUFlQztRQUNuQixJQUFJQyxPQUFPQztRQUNYLElBQUlQLFlBQVksR0FBRztZQUNqQkksZ0JBQWdCenVDLEtBQUsrTCxHQUFHLENBQUNxaUMsVUFBVVIsT0FBTyxDQUFDLEVBQUUsSUFBSUUsUUFBUUU7WUFDekRVLGdCQUFnQjF1QyxLQUFLK0wsR0FBRyxDQUFDb2lDLFVBQVVQLE9BQU8sQ0FBQyxFQUFFLElBQUlFLFFBQVFHO1lBQ3pEVSxRQUFRLENBQUNmLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLElBQUlFO1lBQ3BDYyxTQUFTLENBQUNoQixPQUFPLENBQUMsRUFBRSxHQUFHQSxPQUFPLENBQUMsRUFBRSxJQUFJRTtRQUN2QyxPQUFPO1lBQ0xXLGdCQUFnQnp1QyxLQUFLK0wsR0FBRyxDQUFDb2lDLFVBQVVQLE9BQU8sQ0FBQyxFQUFFLElBQUlFLFFBQVFFO1lBQ3pEVSxnQkFBZ0IxdUMsS0FBSytMLEdBQUcsQ0FBQ3FpQyxVQUFVUixPQUFPLENBQUMsRUFBRSxJQUFJRSxRQUFRRztZQUN6RFUsUUFBUSxDQUFDZixPQUFPLENBQUMsRUFBRSxHQUFHQSxPQUFPLENBQUMsRUFBRSxJQUFJRTtZQUNwQ2MsU0FBUyxDQUFDaEIsT0FBTyxDQUFDLEVBQUUsR0FBR0EsT0FBTyxDQUFDLEVBQUUsSUFBSUU7UUFDdkM7UUFDQSxJQUFJLENBQUMzWCxTQUFTLEdBQUc7WUFBQ2tZLFVBQVVQO1lBQU9RLFVBQVVSO1lBQU9TLFVBQVVUO1lBQU9VLFVBQVVWO1lBQU9XLGdCQUFnQkosVUFBVVAsUUFBUUssVUFBVUksVUFBVVQsUUFBUU07WUFBU00sZ0JBQWdCSixVQUFVUixRQUFRSyxVQUFVSyxVQUFVVixRQUFRTTtTQUFRO1FBQ25PLElBQUksQ0FBQ08sS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtJQUNoQjtJQUNBLElBQUlDLFVBQVU7UUFDWixNQUFNQyxPQUFPLElBQUksQ0FBQ2xCLE9BQU87UUFDekIsT0FBTzVRLE9BQU8sSUFBSSxFQUFFLFdBQVc7WUFDN0IrUixXQUFXRCxJQUFJLENBQUMsRUFBRSxHQUFHQSxJQUFJLENBQUMsRUFBRTtZQUM1QkUsWUFBWUYsSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUU7WUFDN0JHLE9BQU9ILElBQUksQ0FBQyxFQUFFO1lBQ2RJLE9BQU9KLElBQUksQ0FBQyxFQUFFO1FBQ2hCO0lBQ0Y7SUFDQS9yQyxNQUFNLEVBQ0orcUMsUUFBUSxJQUFJLENBQUNBLEtBQUssRUFDbEJDLFdBQVcsSUFBSSxDQUFDQSxRQUFRLEVBQ3hCQyxVQUFVLElBQUksQ0FBQ0EsT0FBTyxFQUN0QkMsVUFBVSxJQUFJLENBQUNBLE9BQU8sRUFDdEJDLFdBQVcsS0FBSyxFQUNqQixHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ04sT0FBTyxJQUFJUCxhQUFhO1lBQ3RCQyxTQUFTLElBQUksQ0FBQ0EsT0FBTyxDQUFDN3hDLEtBQUs7WUFDM0I4eEMsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkJDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1FBQ0Y7SUFDRjtJQUNBaUIsdUJBQXVCaHZDLENBQUMsRUFBRTBNLENBQUMsRUFBRTtRQUMzQixNQUFNNHpCLElBQUk7WUFBQ3RnQztZQUFHME07U0FBRTtRQUNoQit5QixLQUFLWSxjQUFjLENBQUNDLEdBQUcsSUFBSSxDQUFDdEssU0FBUztRQUNyQyxPQUFPc0s7SUFDVDtJQUNBMk8sMkJBQTJCOU4sSUFBSSxFQUFFO1FBQy9CLE1BQU0rTixVQUFVO1lBQUMvTixJQUFJLENBQUMsRUFBRTtZQUFFQSxJQUFJLENBQUMsRUFBRTtTQUFDO1FBQ2xDMUIsS0FBS1ksY0FBYyxDQUFDNk8sU0FBUyxJQUFJLENBQUNsWixTQUFTO1FBQzNDLE1BQU1tWixjQUFjO1lBQUNoTyxJQUFJLENBQUMsRUFBRTtZQUFFQSxJQUFJLENBQUMsRUFBRTtTQUFDO1FBQ3RDMUIsS0FBS1ksY0FBYyxDQUFDOE8sYUFBYSxJQUFJLENBQUNuWixTQUFTO1FBQy9DLE9BQU87WUFBQ2taLE9BQU8sQ0FBQyxFQUFFO1lBQUVBLE9BQU8sQ0FBQyxFQUFFO1lBQUVDLFdBQVcsQ0FBQyxFQUFFO1lBQUVBLFdBQVcsQ0FBQyxFQUFFO1NBQUM7SUFDakU7SUFDQUMsa0JBQWtCcHZDLENBQUMsRUFBRTBNLENBQUMsRUFBRTtRQUN0QixNQUFNNHpCLElBQUk7WUFBQ3RnQztZQUFHME07U0FBRTtRQUNoQit5QixLQUFLd0IscUJBQXFCLENBQUNYLEdBQUcsSUFBSSxDQUFDdEssU0FBUztRQUM1QyxPQUFPc0s7SUFDVDtBQUNGO0FBQ0EsTUFBTStPLG9DQUFvQ3RTO0lBQ3hDdGdDLFlBQVlpL0IsR0FBRyxFQUFFNFQsYUFBYSxDQUFDLENBQUU7UUFDL0IsS0FBSyxDQUFDNVQsS0FBSztRQUNYLElBQUksQ0FBQzRULFVBQVUsR0FBR0E7SUFDcEI7QUFDRjtBQUNBLFNBQVNDLGFBQWF2eUIsR0FBRztJQUN2QixNQUFNaW9CLEtBQUtqb0IsSUFBSTNqQixNQUFNO0lBQ3JCLElBQUkyRSxJQUFJO0lBQ1IsTUFBT0EsSUFBSWluQyxNQUFNam9CLEdBQUcsQ0FBQ2hmLEVBQUUsQ0FBQ3d4QyxJQUFJLE9BQU8sR0FBSTtRQUNyQ3h4QztJQUNGO0lBQ0EsT0FBT2dmLElBQUl5eUIsU0FBUyxDQUFDenhDLEdBQUdBLElBQUksR0FBR2dNLFdBQVcsT0FBTztBQUNuRDtBQUNBLFNBQVMwbEMsVUFBVUMsUUFBUTtJQUN6QixPQUFPLE9BQU9BLGFBQWEsWUFBWSxVQUFVeHdDLElBQUksQ0FBQ3d3QztBQUN4RDtBQUNBLFNBQVNDLG1CQUFtQjV5QixHQUFHO0lBQzdCLENBQUNBLElBQUksR0FBR0EsSUFBSS9nQixLQUFLLENBQUMsUUFBUTtJQUMxQixPQUFPK2dCLElBQUl5eUIsU0FBUyxDQUFDenlCLElBQUk2eUIsV0FBVyxDQUFDLE9BQU87QUFDOUM7QUFDQSxTQUFTQyxzQkFBc0I5eUIsR0FBRyxFQUFFK3lCLGtCQUFrQixjQUFjO0lBQ2xFLElBQUksT0FBTy95QixRQUFRLFVBQVU7UUFDM0IsT0FBTyt5QjtJQUNUO0lBQ0EsSUFBSVIsYUFBYXZ5QixNQUFNO1FBQ3JCNGUsS0FBSztRQUNMLE9BQU9tVTtJQUNUO0lBQ0EsTUFBTUMsU0FBUy95QixDQUFBQTtRQUNiLElBQUk7WUFDRixPQUFPLElBQUlILElBQUlHO1FBQ2pCLEVBQUUsT0FBTTtZQUNOLElBQUk7Z0JBQ0YsT0FBTyxJQUFJSCxJQUFJcW9CLG1CQUFtQmxvQjtZQUNwQyxFQUFFLE9BQU07Z0JBQ04sSUFBSTtvQkFDRixPQUFPLElBQUlILElBQUlHLFdBQVc7Z0JBQzVCLEVBQUUsT0FBTTtvQkFDTixJQUFJO3dCQUNGLE9BQU8sSUFBSUgsSUFBSXFvQixtQkFBbUJsb0IsWUFBWTtvQkFDaEQsRUFBRSxPQUFNO3dCQUNOLE9BQU87b0JBQ1Q7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxNQUFNZ3pCLFNBQVNELE9BQU9oekI7SUFDdEIsSUFBSSxDQUFDaXpCLFFBQVE7UUFDWCxPQUFPRjtJQUNUO0lBQ0EsTUFBTWpMLFNBQVMzb0MsQ0FBQUE7UUFDYixJQUFJO1lBQ0YsSUFBSTBvQyxVQUFVTSxtQkFBbUJocEM7WUFDakMsSUFBSTBvQyxRQUFRLzFCLFFBQVEsQ0FBQyxNQUFNO2dCQUN6QisxQixVQUFVQSxRQUFRNW9DLEtBQUssQ0FBQyxLQUFLb21CLEVBQUUsQ0FBQyxDQUFDO2dCQUNqQyxJQUFJd2lCLFFBQVExbEMsSUFBSSxDQUFDLGFBQWE7b0JBQzVCLE9BQU8wbEM7Z0JBQ1Q7Z0JBQ0EsT0FBTzFvQztZQUNUO1lBQ0EsT0FBTzBvQztRQUNULEVBQUUsT0FBTTtZQUNOLE9BQU8xb0M7UUFDVDtJQUNGO0lBQ0EsTUFBTSt6QyxXQUFXO0lBQ2pCLE1BQU1QLFdBQVdNLE9BQU92d0IsUUFBUSxDQUFDempCLEtBQUssQ0FBQyxLQUFLb21CLEVBQUUsQ0FBQyxDQUFDO0lBQ2hELElBQUk2dEIsU0FBUy93QyxJQUFJLENBQUN3d0MsV0FBVztRQUMzQixPQUFPN0ssT0FBTzZLO0lBQ2hCO0lBQ0EsSUFBSU0sT0FBT3p3QixZQUFZLENBQUNuUixJQUFJLEdBQUcsR0FBRztRQUNoQyxNQUFNOFIsU0FBUy9VLE1BQU1xVyxJQUFJLENBQUN3dUIsT0FBT3p3QixZQUFZLENBQUNXLE1BQU0sSUFBSWd3QixPQUFPO1FBQy9ELEtBQUssTUFBTTcxQyxTQUFTNmxCLE9BQVE7WUFDMUIsSUFBSSt2QixTQUFTL3dDLElBQUksQ0FBQzdFLFFBQVE7Z0JBQ3hCLE9BQU93cUMsT0FBT3hxQztZQUNoQjtRQUNGO1FBQ0EsTUFBTXVHLE9BQU91SyxNQUFNcVcsSUFBSSxDQUFDd3VCLE9BQU96d0IsWUFBWSxDQUFDM2UsSUFBSSxJQUFJc3ZDLE9BQU87UUFDM0QsS0FBSyxNQUFNMXJDLE9BQU81RCxLQUFNO1lBQ3RCLElBQUlxdkMsU0FBUy93QyxJQUFJLENBQUNzRixNQUFNO2dCQUN0QixPQUFPcWdDLE9BQU9yZ0M7WUFDaEI7UUFDRjtJQUNGO0lBQ0EsSUFBSXdyQyxPQUFPandCLElBQUksRUFBRTtRQUNmLE1BQU1vd0IsYUFBYTtRQUNuQixNQUFNQyxlQUFlRCxXQUFXcnZDLElBQUksQ0FBQ2t2QyxPQUFPandCLElBQUk7UUFDaEQsSUFBSXF3QixjQUFjO1lBQ2hCLE9BQU92TCxPQUFPdUwsWUFBWSxDQUFDLEVBQUU7UUFDL0I7SUFDRjtJQUNBLE9BQU9OO0FBQ1Q7QUFDQSxNQUFNTztJQUdKQyxLQUFLcDBDLElBQUksRUFBRTtRQUNULElBQUlBLFFBQVEsSUFBSSxDQUFDcTBDLE9BQU8sRUFBRTtZQUN4QjVVLEtBQUssQ0FBQyw2QkFBNkIsRUFBRXovQixLQUFLLENBQUM7UUFDN0M7UUFDQSxJQUFJLENBQUNxMEMsT0FBTyxDQUFDcjBDLEtBQUssR0FBRzBwQyxLQUFLNEssR0FBRztJQUMvQjtJQUNBQyxRQUFRdjBDLElBQUksRUFBRTtRQUNaLElBQUksQ0FBRUEsQ0FBQUEsUUFBUSxJQUFJLENBQUNxMEMsT0FBTyxHQUFHO1lBQzNCNVUsS0FBSyxDQUFDLCtCQUErQixFQUFFei9CLEtBQUssQ0FBQztRQUMvQztRQUNBLElBQUksQ0FBQ3cwQyxLQUFLLENBQUNyc0MsSUFBSSxDQUFDO1lBQ2RuSTtZQUNBK29CLE9BQU8sSUFBSSxDQUFDc3JCLE9BQU8sQ0FBQ3IwQyxLQUFLO1lBQ3pCMG1CLEtBQUtnakIsS0FBSzRLLEdBQUc7UUFDZjtRQUNBLE9BQU8sSUFBSSxDQUFDRCxPQUFPLENBQUNyMEMsS0FBSztJQUMzQjtJQUNBYSxXQUFXO1FBQ1QsTUFBTTR6QyxTQUFTLEVBQUU7UUFDakIsSUFBSUMsVUFBVTtRQUNkLEtBQUssTUFBTSxFQUNUMTBDLElBQUksRUFDTCxJQUFJLElBQUksQ0FBQ3cwQyxLQUFLLENBQUU7WUFDZkUsVUFBVWh4QyxLQUFLNFAsR0FBRyxDQUFDdFQsS0FBSzlDLE1BQU0sRUFBRXczQztRQUNsQztRQUNBLEtBQUssTUFBTSxFQUNUMTBDLElBQUksRUFDSitvQixLQUFLLEVBQ0xyQyxHQUFHLEVBQ0osSUFBSSxJQUFJLENBQUM4dEIsS0FBSyxDQUFFO1lBQ2ZDLE9BQU90c0MsSUFBSSxDQUFDLENBQUMsRUFBRW5JLEtBQUsyMEMsTUFBTSxDQUFDRCxTQUFTLENBQUMsRUFBRWh1QixNQUFNcUMsTUFBTSxJQUFJLENBQUM7UUFDMUQ7UUFDQSxPQUFPMHJCLE9BQU85MEMsSUFBSSxDQUFDO0lBQ3JCOzthQW5DQTAwQyxVQUFVOTBDLE9BQU8rTCxNQUFNLENBQUM7YUFDeEJrcEMsUUFBUSxFQUFFOztBQW1DWjtBQUNBLFNBQVNuRSxnQkFBZ0J4dkIsR0FBRyxFQUFFbWYsT0FBTztJQUNuQyxNQUFNUyxNQUFNVCxVQUFVcmYsSUFBSUMsS0FBSyxDQUFDQyxLQUFLbWYsV0FBV3JmLElBQUlDLEtBQUssQ0FBQ0M7SUFDMUQsT0FBTzRmLEtBQUtYLGFBQWEsV0FBV1csS0FBS1gsYUFBYTtBQUN4RDtBQUNBLFNBQVM4VSxjQUFjbGlDLENBQUM7SUFDdEJBLEVBQUVtaUMsY0FBYztBQUNsQjtBQUNBLFNBQVNDLFVBQVVwaUMsQ0FBQztJQUNsQkEsRUFBRW1pQyxjQUFjO0lBQ2hCbmlDLEVBQUVxaUMsZUFBZTtBQUNuQjtBQUNBLFNBQVNDLFdBQVcvVCxPQUFPO0lBQ3pCekIsUUFBUXlWLEdBQUcsQ0FBQywyQkFBMkJoVTtBQUN6QztBQUNBLE1BQU1pVTtJQUNKLE9BQU8sQ0FBQzVyQixLQUFLLENBQUM7SUFDZCxPQUFPNnJCLGFBQWFwb0MsS0FBSyxFQUFFO1FBQ3pCLElBQUlBLGlCQUFpQjI4QixNQUFNO1lBQ3pCLE9BQU8zOEI7UUFDVDtRQUNBLElBQUksQ0FBQ0EsU0FBUyxPQUFPQSxVQUFVLFVBQVU7WUFDdkMsT0FBTztRQUNUO1FBQ0EsSUFBSSxDQUFDLENBQUN1YyxLQUFLLEtBQUssSUFBSThyQixPQUFPLFFBQVEsYUFBYSxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsZUFBZSxjQUFjLE9BQU8sY0FBYztRQUN4SyxNQUFNQyxVQUFVLElBQUksQ0FBQyxDQUFDL3JCLEtBQUssQ0FBQzFrQixJQUFJLENBQUNtSTtRQUNqQyxJQUFJLENBQUNzb0MsU0FBUztZQUNaLE9BQU87UUFDVDtRQUNBLE1BQU1DLE9BQU8xc0MsU0FBU3lzQyxPQUFPLENBQUMsRUFBRSxFQUFFO1FBQ2xDLElBQUlFLFFBQVEzc0MsU0FBU3lzQyxPQUFPLENBQUMsRUFBRSxFQUFFO1FBQ2pDRSxRQUFRQSxTQUFTLEtBQUtBLFNBQVMsS0FBS0EsUUFBUSxJQUFJO1FBQ2hELElBQUlDLE1BQU01c0MsU0FBU3lzQyxPQUFPLENBQUMsRUFBRSxFQUFFO1FBQy9CRyxNQUFNQSxPQUFPLEtBQUtBLE9BQU8sS0FBS0EsTUFBTTtRQUNwQyxJQUFJQyxPQUFPN3NDLFNBQVN5c0MsT0FBTyxDQUFDLEVBQUUsRUFBRTtRQUNoQ0ksT0FBT0EsUUFBUSxLQUFLQSxRQUFRLEtBQUtBLE9BQU87UUFDeEMsSUFBSUMsU0FBUzlzQyxTQUFTeXNDLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDbENLLFNBQVNBLFVBQVUsS0FBS0EsVUFBVSxLQUFLQSxTQUFTO1FBQ2hELElBQUlwUCxTQUFTMTlCLFNBQVN5c0MsT0FBTyxDQUFDLEVBQUUsRUFBRTtRQUNsQy9PLFNBQVNBLFVBQVUsS0FBS0EsVUFBVSxLQUFLQSxTQUFTO1FBQ2hELE1BQU1xUCx3QkFBd0JOLE9BQU8sQ0FBQyxFQUFFLElBQUk7UUFDNUMsSUFBSU8sYUFBYWh0QyxTQUFTeXNDLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDdENPLGFBQWFBLGNBQWMsS0FBS0EsY0FBYyxLQUFLQSxhQUFhO1FBQ2hFLElBQUlDLGVBQWVqdEMsU0FBU3lzQyxPQUFPLENBQUMsRUFBRSxFQUFFLE9BQU87UUFDL0NRLGVBQWVBLGdCQUFnQixLQUFLQSxnQkFBZ0IsS0FBS0EsZUFBZTtRQUN4RSxJQUFJRiwwQkFBMEIsS0FBSztZQUNqQ0YsUUFBUUc7WUFDUkYsVUFBVUc7UUFDWixPQUFPLElBQUlGLDBCQUEwQixLQUFLO1lBQ3hDRixRQUFRRztZQUNSRixVQUFVRztRQUNaO1FBQ0EsT0FBTyxJQUFJbk0sS0FBS0EsS0FBS29NLEdBQUcsQ0FBQ1IsTUFBTUMsT0FBT0MsS0FBS0MsTUFBTUMsUUFBUXBQO0lBQzNEO0FBQ0Y7QUFDQSxTQUFTeVAsbUJBQW1CQyxPQUFPLEVBQUUsRUFDbkN4RSxRQUFRLENBQUMsRUFDVEMsV0FBVyxDQUFDLEVBQ2I7SUFDQyxNQUFNLEVBQ0pZLEtBQUssRUFDTEMsTUFBTSxFQUNQLEdBQUcwRCxRQUFRaEosVUFBVSxDQUFDcGlDLEtBQUs7SUFDNUIsTUFBTTBtQyxVQUFVO1FBQUM7UUFBRztRQUFHMW9DLFNBQVN5cEM7UUFBUXpwQyxTQUFTMHBDO0tBQVE7SUFDekQsT0FBTyxJQUFJakIsYUFBYTtRQUN0QkM7UUFDQUMsVUFBVTtRQUNWQztRQUNBQztJQUNGO0FBQ0Y7QUFDQSxTQUFTd0UsT0FBT0MsS0FBSztJQUNuQixJQUFJQSxNQUFNaFcsVUFBVSxDQUFDLE1BQU07UUFDekIsTUFBTWlXLFdBQVd2dEMsU0FBU3N0QyxNQUFNejJDLEtBQUssQ0FBQyxJQUFJO1FBQzFDLE9BQU87WUFBRTAyQyxDQUFBQSxXQUFXLFFBQU8sS0FBTTtZQUFLQSxDQUFBQSxXQUFXLFFBQU8sS0FBTTtZQUFHQSxXQUFXO1NBQVM7SUFDdkY7SUFDQSxJQUFJRCxNQUFNaFcsVUFBVSxDQUFDLFNBQVM7UUFDNUIsT0FBT2dXLE1BQU16MkMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHSyxLQUFLLENBQUMsS0FBS2lJLEdBQUcsQ0FBQ2xFLENBQUFBLElBQUsrRSxTQUFTL0U7SUFDekQ7SUFDQSxJQUFJcXlDLE1BQU1oVyxVQUFVLENBQUMsVUFBVTtRQUM3QixPQUFPZ1csTUFBTXoyQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUdLLEtBQUssQ0FBQyxLQUFLaUksR0FBRyxDQUFDbEUsQ0FBQUEsSUFBSytFLFNBQVMvRSxJQUFJcEUsS0FBSyxDQUFDLEdBQUc7SUFDdEU7SUFDQWdnQyxLQUFLLENBQUMsMkJBQTJCLEVBQUV5VyxNQUFNLENBQUMsQ0FBQztJQUMzQyxPQUFPO1FBQUM7UUFBRztRQUFHO0tBQUU7QUFDbEI7QUFDQSxTQUFTRSxlQUFlQyxNQUFNO0lBQzVCLE1BQU1DLE9BQU9yckMsU0FBUzJJLGFBQWEsQ0FBQztJQUNwQzBpQyxLQUFLMXJDLEtBQUssQ0FBQzJyQyxVQUFVLEdBQUc7SUFDeEJELEtBQUsxckMsS0FBSyxDQUFDNHJDLFdBQVcsR0FBRztJQUN6QnZyQyxTQUFTd3JDLElBQUksQ0FBQ3ovQixNQUFNLENBQUNzL0I7SUFDckIsS0FBSyxNQUFNdDJDLFFBQVFxMkMsT0FBTzN4QyxJQUFJLEdBQUk7UUFDaEM0eEMsS0FBSzFyQyxLQUFLLENBQUNzckMsS0FBSyxHQUFHbDJDO1FBQ25CLE1BQU0wMkMsZ0JBQWdCaGlDLE9BQU9paUMsZ0JBQWdCLENBQUNMLE1BQU1KLEtBQUs7UUFDekRHLE9BQU81d0MsR0FBRyxDQUFDekYsTUFBTWkyQyxPQUFPUztJQUMxQjtJQUNBSixLQUFLaGtDLE1BQU07QUFDYjtBQUNBLFNBQVNza0Msb0JBQW9CQyxHQUFHO0lBQzlCLE1BQU0sRUFDSnQyQixDQUFDLEVBQ0RDLENBQUMsRUFDRHJELENBQUMsRUFDRG1SLENBQUMsRUFDRDViLENBQUMsRUFDRHJMLENBQUMsRUFDRixHQUFHd3ZDLElBQUlDLFlBQVk7SUFDcEIsT0FBTztRQUFDdjJCO1FBQUdDO1FBQUdyRDtRQUFHbVI7UUFBRzViO1FBQUdyTDtLQUFFO0FBQzNCO0FBQ0EsU0FBUzB2QywyQkFBMkJGLEdBQUc7SUFDckMsTUFBTSxFQUNKdDJCLENBQUMsRUFDREMsQ0FBQyxFQUNEckQsQ0FBQyxFQUNEbVIsQ0FBQyxFQUNENWIsQ0FBQyxFQUNEckwsQ0FBQyxFQUNGLEdBQUd3dkMsSUFBSUMsWUFBWSxHQUFHRSxVQUFVO0lBQ2pDLE9BQU87UUFBQ3oyQjtRQUFHQztRQUFHckQ7UUFBR21SO1FBQUc1YjtRQUFHckw7S0FBRTtBQUMzQjtBQUNBLFNBQVM0dkMsbUJBQW1CN0gsR0FBRyxFQUFFQyxRQUFRLEVBQUU2SCxXQUFXLEtBQUssRUFBRUMsYUFBYSxJQUFJO0lBQzVFLElBQUk5SCxvQkFBb0JnQyxjQUFjO1FBQ3BDLE1BQU0sRUFDSm9CLFNBQVMsRUFDVEMsVUFBVSxFQUNYLEdBQUdyRCxTQUFTa0QsT0FBTztRQUNwQixNQUFNLEVBQ0ozbkMsS0FBSyxFQUNOLEdBQUd3a0M7UUFDSixNQUFNZ0ksV0FBVzlVLGlCQUFpQlcsbUJBQW1CO1FBQ3JELE1BQU1vVSxJQUFJLENBQUMsNEJBQTRCLEVBQUU1RSxVQUFVLEVBQUUsQ0FBQyxFQUNwRDZFLElBQUksQ0FBQyw0QkFBNEIsRUFBRTVFLFdBQVcsRUFBRSxDQUFDO1FBQ25ELE1BQU02RSxXQUFXSCxXQUFXLENBQUMsWUFBWSxFQUFFQyxFQUFFLHVCQUF1QixDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUVBLEVBQUUsQ0FBQyxDQUFDLEVBQ2xGRyxZQUFZSixXQUFXLENBQUMsWUFBWSxFQUFFRSxFQUFFLHVCQUF1QixDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUVBLEVBQUUsQ0FBQyxDQUFDO1FBQ2pGLElBQUksQ0FBQ0osWUFBWTdILFNBQVNvQyxRQUFRLEdBQUcsUUFBUSxHQUFHO1lBQzlDN21DLE1BQU15bkMsS0FBSyxHQUFHa0Y7WUFDZDNzQyxNQUFNMG5DLE1BQU0sR0FBR2tGO1FBQ2pCLE9BQU87WUFDTDVzQyxNQUFNeW5DLEtBQUssR0FBR21GO1lBQ2Q1c0MsTUFBTTBuQyxNQUFNLEdBQUdpRjtRQUNqQjtJQUNGO0lBQ0EsSUFBSUosWUFBWTtRQUNkL0gsSUFBSXZCLFlBQVksQ0FBQyxzQkFBc0J3QixTQUFTb0MsUUFBUTtJQUMxRDtBQUNGO0FBQ0EsTUFBTWdHO0lBQ0puM0MsYUFBYztRQUNaLE1BQU0sRUFDSm8zQyxVQUFVLEVBQ1gsR0FBR0Q7UUFDSixJQUFJLENBQUNFLEVBQUUsR0FBR0Q7UUFDVixJQUFJLENBQUNFLEVBQUUsR0FBR0Y7SUFDWjtJQUNBLElBQUlHLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ0YsRUFBRSxLQUFLLEtBQUssSUFBSSxDQUFDQyxFQUFFLEtBQUs7SUFDdEM7SUFDQSxJQUFJRSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUNILEVBQUUsS0FBSyxJQUFJLENBQUNDLEVBQUU7SUFDNUI7SUFDQUcsWUFBWTFGLEtBQUssRUFBRUMsTUFBTSxFQUFFMEYsU0FBUyxFQUFFQyxNQUFNLEVBQUVDLGdCQUFnQixDQUFDLENBQUMsRUFBRTtRQUNoRSxJQUFJQyxlQUFlN29DLFVBQ2pCOG9DLGdCQUFnQjlvQyxVQUNoQitvQyxpQkFBaUIvb0M7UUFDbkIwb0MsWUFBWVAsWUFBWWEsU0FBUyxDQUFDTixXQUFXRTtRQUM3QyxJQUFJRixZQUFZLEdBQUc7WUFDakJHLGVBQWV6MEMsS0FBSzZpQyxJQUFJLENBQUN5UixZQUFhM0YsQ0FBQUEsUUFBUUMsTUFBSztRQUNyRDtRQUNBLElBQUkyRixXQUFXLENBQUMsR0FBRztZQUNqQkcsZ0JBQWdCSCxTQUFTNUY7WUFDekJnRyxpQkFBaUJKLFNBQVMzRjtRQUM1QjtRQUNBLE1BQU1pRyxXQUFXNzBDLEtBQUttRixHQUFHLENBQUNzdkMsY0FBY0MsZUFBZUM7UUFDdkQsSUFBSSxJQUFJLENBQUNWLEVBQUUsR0FBR1ksWUFBWSxJQUFJLENBQUNYLEVBQUUsR0FBR1csVUFBVTtZQUM1QyxJQUFJLENBQUNaLEVBQUUsR0FBR1k7WUFDVixJQUFJLENBQUNYLEVBQUUsR0FBR1c7WUFDVixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxXQUFXYixhQUFhO1FBQ3RCLE9BQU9yMkMsV0FBV20zQyxnQkFBZ0IsSUFBSTtJQUN4QztJQUNBLE9BQU9GLFVBQVVOLFNBQVMsRUFBRUUsYUFBYSxFQUFFO1FBQ3pDLElBQUlBLGlCQUFpQixHQUFHO1lBQ3RCLE1BQU1PLFlBQVkvMEMsS0FBS0QsSUFBSSxDQUFDaVIsT0FBT2drQyxNQUFNLENBQUNDLFVBQVUsR0FBR2prQyxPQUFPZ2tDLE1BQU0sQ0FBQ0UsV0FBVyxHQUFHLElBQUksQ0FBQ2xCLFVBQVUsSUFBSSxJQUFLLEtBQUlRLGdCQUFnQixHQUFFO1lBQ2pJLE9BQU9GLFlBQVksSUFBSXQwQyxLQUFLbUYsR0FBRyxDQUFDbXZDLFdBQVdTLGFBQWFBO1FBQzFEO1FBQ0EsT0FBT1Q7SUFDVDtBQUNGO0FBQ0EsTUFBTWEsMEJBQTBCO0lBQUM7SUFBYztJQUFjO0lBQWE7SUFBYTtJQUFjO0lBQWE7SUFBaUI7SUFBYztDQUFlO0FBQ2hLLE1BQU1DO0lBQ0osV0FBV0MsYUFBYTtRQUN0QixPQUFPclksT0FBTyxJQUFJLEVBQUUsY0FBYyxDQUFDLENBQUNoc0IsUUFBUXNrQyxhQUFhLGdDQUFnQzNEO0lBQzNGO0FBQ0Y7QUFDQSxNQUFNNEQ7SUFDSixXQUFXQyx5QkFBeUI7UUFDbEMsTUFBTTdMLFVBQVVwaUMsU0FBUzJJLGFBQWEsQ0FBQztRQUN2Q3k1QixRQUFROEwsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQyxXQUFXO1FBQ2pDLE1BQU0sRUFDSm5JLEtBQUssRUFDTixHQUFHeWlDO1FBQ0p6aUMsTUFBTXluQyxLQUFLLEdBQUd6bkMsTUFBTTBuQyxNQUFNLEdBQUc7UUFDN0IxbkMsTUFBTUMsT0FBTyxHQUFHO1FBQ2hCRCxNQUFNc3JDLEtBQUssR0FBRztRQUNkanJDLFNBQVN3ckMsSUFBSSxDQUFDei9CLE1BQU0sQ0FBQ3EyQjtRQUNyQixNQUFNLEVBQ0o2SSxLQUFLLEVBQ04sR0FBR3hoQyxPQUFPaWlDLGdCQUFnQixDQUFDdEo7UUFDNUJBLFFBQVEvNkIsTUFBTTtRQUNkLE9BQU9vdUIsT0FBTyxJQUFJLEVBQUUsMEJBQTBCdVYsT0FBT0M7SUFDdkQ7QUFDRjtBQUNBLFNBQVNrRCxhQUFhNVYsQ0FBQyxFQUFFQyxDQUFDLEVBQUVqakIsQ0FBQyxFQUFFNjRCLE9BQU87SUFDcENBLFVBQVUzMUMsS0FBS21GLEdBQUcsQ0FBQ25GLEtBQUs0UCxHQUFHLENBQUMrbEMsV0FBVyxHQUFHLElBQUk7SUFDOUMsTUFBTUMsUUFBUSxNQUFPLEtBQUlELE9BQU07SUFDL0I3VixJQUFJOS9CLEtBQUs2MUMsS0FBSyxDQUFDL1YsSUFBSTZWLFVBQVVDO0lBQzdCN1YsSUFBSS8vQixLQUFLNjFDLEtBQUssQ0FBQzlWLElBQUk0VixVQUFVQztJQUM3Qjk0QixJQUFJOWMsS0FBSzYxQyxLQUFLLENBQUMvNEIsSUFBSTY0QixVQUFVQztJQUM3QixPQUFPO1FBQUM5VjtRQUFHQztRQUFHampCO0tBQUU7QUFDbEI7QUFDQSxTQUFTZzVCLFNBQVNDLEdBQUcsRUFBRXhVLE1BQU07SUFDM0IsTUFBTXpCLElBQUlpVyxHQUFHLENBQUMsRUFBRSxHQUFHO0lBQ25CLE1BQU1oVyxJQUFJZ1csR0FBRyxDQUFDLEVBQUUsR0FBRztJQUNuQixNQUFNajVCLElBQUlpNUIsR0FBRyxDQUFDLEVBQUUsR0FBRztJQUNuQixNQUFNbm1DLE1BQU01UCxLQUFLNFAsR0FBRyxDQUFDa3dCLEdBQUdDLEdBQUdqakI7SUFDM0IsTUFBTTNYLE1BQU1uRixLQUFLbUYsR0FBRyxDQUFDMjZCLEdBQUdDLEdBQUdqakI7SUFDM0IsTUFBTWs1QixJQUFJLENBQUNwbUMsTUFBTXpLLEdBQUUsSUFBSztJQUN4QixJQUFJeUssUUFBUXpLLEtBQUs7UUFDZm84QixNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRSxHQUFHO0lBQzFCLE9BQU87UUFDTCxNQUFNM1csSUFBSWhiLE1BQU16SztRQUNoQm84QixNQUFNLENBQUMsRUFBRSxHQUFHeVUsSUFBSSxNQUFNcHJCLElBQUtoYixDQUFBQSxNQUFNekssR0FBRSxJQUFLeWxCLElBQUssS0FBSWhiLE1BQU16SyxHQUFFO1FBQ3pELE9BQVF5SztZQUNOLEtBQUtrd0I7Z0JBQ0h5QixNQUFNLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQ3hCLElBQUlqakIsQ0FBQUEsSUFBSzhOLElBQUttVixDQUFBQSxJQUFJampCLElBQUksSUFBSSxFQUFDLElBQUs7Z0JBQzlDO1lBQ0YsS0FBS2lqQjtnQkFDSHdCLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDemtCLElBQUlnakIsQ0FBQUEsSUFBS2xWLElBQUksS0FBSztnQkFDaEM7WUFDRixLQUFLOU47Z0JBQ0h5a0IsTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUN6QixJQUFJQyxDQUFBQSxJQUFLblYsSUFBSSxLQUFLO2dCQUNoQztRQUNKO0lBQ0Y7SUFDQTJXLE1BQU0sQ0FBQyxFQUFFLEdBQUd5VTtBQUNkO0FBQ0EsU0FBU0MsU0FBU0MsR0FBRyxFQUFFM1UsTUFBTTtJQUMzQixNQUFNcVMsSUFBSXNDLEdBQUcsQ0FBQyxFQUFFO0lBQ2hCLE1BQU0xOEIsSUFBSTA4QixHQUFHLENBQUMsRUFBRTtJQUNoQixNQUFNRixJQUFJRSxHQUFHLENBQUMsRUFBRTtJQUNoQixNQUFNejhCLElBQUksQ0FBQyxJQUFJelosS0FBSytMLEdBQUcsQ0FBQyxJQUFJaXFDLElBQUksRUFBQyxJQUFLeDhCO0lBQ3RDLE1BQU1yWixJQUFJc1osSUFBSyxLQUFJelosS0FBSytMLEdBQUcsQ0FBQzZuQyxJQUFJLEtBQUssSUFBSSxFQUFDO0lBQzFDLE1BQU1qNkIsSUFBSXE4QixJQUFJdjhCLElBQUk7SUFDbEIsT0FBUXpaLEtBQUtDLEtBQUssQ0FBQzJ6QyxJQUFJO1FBQ3JCLEtBQUs7WUFDSHJTLE1BQU0sQ0FBQyxFQUFFLEdBQUc5bkIsSUFBSUU7WUFDaEI0bkIsTUFBTSxDQUFDLEVBQUUsR0FBR3BoQyxJQUFJd1o7WUFDaEI0bkIsTUFBTSxDQUFDLEVBQUUsR0FBRzVuQjtZQUNaO1FBQ0YsS0FBSztZQUNING5CLE1BQU0sQ0FBQyxFQUFFLEdBQUdwaEMsSUFBSXdaO1lBQ2hCNG5CLE1BQU0sQ0FBQyxFQUFFLEdBQUc5bkIsSUFBSUU7WUFDaEI0bkIsTUFBTSxDQUFDLEVBQUUsR0FBRzVuQjtZQUNaO1FBQ0YsS0FBSztZQUNING5CLE1BQU0sQ0FBQyxFQUFFLEdBQUc1bkI7WUFDWjRuQixNQUFNLENBQUMsRUFBRSxHQUFHOW5CLElBQUlFO1lBQ2hCNG5CLE1BQU0sQ0FBQyxFQUFFLEdBQUdwaEMsSUFBSXdaO1lBQ2hCO1FBQ0YsS0FBSztZQUNING5CLE1BQU0sQ0FBQyxFQUFFLEdBQUc1bkI7WUFDWjRuQixNQUFNLENBQUMsRUFBRSxHQUFHcGhDLElBQUl3WjtZQUNoQjRuQixNQUFNLENBQUMsRUFBRSxHQUFHOW5CLElBQUlFO1lBQ2hCO1FBQ0YsS0FBSztZQUNING5CLE1BQU0sQ0FBQyxFQUFFLEdBQUdwaEMsSUFBSXdaO1lBQ2hCNG5CLE1BQU0sQ0FBQyxFQUFFLEdBQUc1bkI7WUFDWjRuQixNQUFNLENBQUMsRUFBRSxHQUFHOW5CLElBQUlFO1lBQ2hCO1FBQ0YsS0FBSztRQUNMLEtBQUs7WUFDSDRuQixNQUFNLENBQUMsRUFBRSxHQUFHOW5CLElBQUlFO1lBQ2hCNG5CLE1BQU0sQ0FBQyxFQUFFLEdBQUc1bkI7WUFDWjRuQixNQUFNLENBQUMsRUFBRSxHQUFHcGhDLElBQUl3WjtZQUNoQjtJQUNKO0FBQ0Y7QUFDQSxTQUFTdzhCLGlCQUFpQmgyQyxDQUFDO0lBQ3pCLE9BQU9BLEtBQUssVUFBVUEsSUFBSSxRQUFRLENBQUMsQ0FBQ0EsSUFBSSxLQUFJLElBQUssS0FBSSxLQUFNO0FBQzdEO0FBQ0EsU0FBU2kyQyxjQUFjQyxJQUFJLEVBQUVDLElBQUksRUFBRS9VLE1BQU07SUFDdkMwVSxTQUFTSSxNQUFNOVU7SUFDZkEsT0FBT2w5QixHQUFHLENBQUM4eEM7SUFDWCxNQUFNSSxPQUFPLFNBQVNoVixNQUFNLENBQUMsRUFBRSxHQUFHLFNBQVNBLE1BQU0sQ0FBQyxFQUFFLEdBQUcsU0FBU0EsTUFBTSxDQUFDLEVBQUU7SUFDekUwVSxTQUFTSyxNQUFNL1U7SUFDZkEsT0FBT2w5QixHQUFHLENBQUM4eEM7SUFDWCxNQUFNSyxPQUFPLFNBQVNqVixNQUFNLENBQUMsRUFBRSxHQUFHLFNBQVNBLE1BQU0sQ0FBQyxFQUFFLEdBQUcsU0FBU0EsTUFBTSxDQUFDLEVBQUU7SUFDekUsT0FBT2dWLE9BQU9DLE9BQU8sQ0FBQ0QsT0FBTyxJQUFHLElBQU1DLENBQUFBLE9BQU8sSUFBRyxJQUFLLENBQUNBLE9BQU8sSUFBRyxJQUFNRCxDQUFBQSxPQUFPLElBQUc7QUFDbEY7QUFDQSxNQUFNRSxnQkFBZ0IsSUFBSS9QO0FBQzFCLFNBQVNnUSxrQkFBa0JDLFNBQVMsRUFBRUMsVUFBVTtJQUM5QyxNQUFNaHlDLE1BQU0reEMsU0FBUyxDQUFDLEVBQUUsR0FBR0EsU0FBUyxDQUFDLEVBQUUsR0FBRyxRQUFRQSxTQUFTLENBQUMsRUFBRSxHQUFHLFVBQVVDLFVBQVUsQ0FBQyxFQUFFLEdBQUcsWUFBWUEsVUFBVSxDQUFDLEVBQUUsR0FBRyxjQUFjQSxVQUFVLENBQUMsRUFBRSxHQUFHO0lBQ3JKLElBQUlDLGNBQWNKLGNBQWNoN0MsR0FBRyxDQUFDbUo7SUFDcEMsSUFBSWl5QyxhQUFhO1FBQ2YsT0FBT0E7SUFDVDtJQUNBLE1BQU0xeEIsUUFBUSxJQUFJMVAsYUFBYTtJQUMvQixNQUFNOHJCLFNBQVNwYyxNQUFNK1ksUUFBUSxDQUFDLEdBQUc7SUFDakMsTUFBTTRZLFVBQVUzeEIsTUFBTStZLFFBQVEsQ0FBQyxHQUFHO0lBQ2xDNFgsU0FBU2EsV0FBV0c7SUFDcEIsTUFBTUMsV0FBVzV4QixNQUFNK1ksUUFBUSxDQUFDLEdBQUc7SUFDbkM0WCxTQUFTYyxZQUFZRztJQUNyQixNQUFNQyxtQkFBbUJELFFBQVEsQ0FBQyxFQUFFLEdBQUc7SUFDdkMsTUFBTUUsY0FBY0QsbUJBQW1CLEtBQUs7SUFDNUNGLE9BQU8sQ0FBQyxFQUFFLEdBQUdFLG1CQUFtQmgzQyxLQUFLNmlDLElBQUksQ0FBQ2lVLE9BQU8sQ0FBQyxFQUFFLElBQUksSUFBSTkyQyxLQUFLNmlDLElBQUksQ0FBQyxJQUFJaVUsT0FBTyxDQUFDLEVBQUU7SUFDcEYsSUFBSVYsY0FBY1UsU0FBU0MsVUFBVXhWLFVBQVUwVixhQUFhO1FBQzFELElBQUk1eEIsT0FBT3JDO1FBQ1gsSUFBSWcwQixrQkFBa0I7WUFDcEIzeEIsUUFBUXl4QixPQUFPLENBQUMsRUFBRTtZQUNsQjl6QixNQUFNO1FBQ1IsT0FBTztZQUNMcUMsUUFBUTtZQUNSckMsTUFBTTh6QixPQUFPLENBQUMsRUFBRTtRQUNsQjtRQUNBLE1BQU1JLFlBQVk7UUFDbEIsTUFBT2wwQixNQUFNcUMsUUFBUTZ4QixVQUFXO1lBQzlCLE1BQU1DLE1BQU1MLE9BQU8sQ0FBQyxFQUFFLEdBQUcsQ0FBQ3p4QixRQUFRckMsR0FBRSxJQUFLO1lBQ3pDLElBQUlnMEIscUJBQXFCWixjQUFjVSxTQUFTQyxVQUFVeFYsVUFBVTBWLGFBQWE7Z0JBQy9FNXhCLFFBQVE4eEI7WUFDVixPQUFPO2dCQUNMbjBCLE1BQU1tMEI7WUFDUjtRQUNGO1FBQ0FMLE9BQU8sQ0FBQyxFQUFFLEdBQUdFLG1CQUFtQmgwQixNQUFNcUM7SUFDeEM7SUFDQTR3QixTQUFTYSxTQUFTdlY7SUFDbEJzVixjQUFjalgsS0FBS0MsWUFBWSxDQUFDNy9CLEtBQUs2MUMsS0FBSyxDQUFDdFUsTUFBTSxDQUFDLEVBQUUsR0FBRyxNQUFNdmhDLEtBQUs2MUMsS0FBSyxDQUFDdFUsTUFBTSxDQUFDLEVBQUUsR0FBRyxNQUFNdmhDLEtBQUs2MUMsS0FBSyxDQUFDdFUsTUFBTSxDQUFDLEVBQUUsR0FBRztJQUNqSGtWLGNBQWMxMEMsR0FBRyxDQUFDNkMsS0FBS2l5QztJQUN2QixPQUFPQTtBQUNUO0FBQ0EsU0FBU08sZUFBZSxFQUN0QnR4QyxJQUFJLEVBQ0p1eEMsR0FBRyxFQUNIQyxTQUFTLEVBQ1YsRUFBRUMsU0FBUztJQUNWLE1BQU1DLFdBQVdqd0MsU0FBU2t3QyxzQkFBc0I7SUFDaEQsSUFBSSxPQUFPM3hDLFNBQVMsVUFBVTtRQUM1QixNQUFNMjZCLElBQUlsNUIsU0FBUzJJLGFBQWEsQ0FBQztRQUNqQ3V3QixFQUFFNFcsR0FBRyxHQUFHQSxPQUFPO1FBQ2YsTUFBTUssUUFBUTV4QyxLQUFLMUosS0FBSyxDQUFDO1FBQ3pCLElBQUssSUFBSStCLElBQUksR0FBR2luQyxLQUFLc1MsTUFBTWwrQyxNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUksRUFBRWpuQyxFQUFHO1lBQzlDLE1BQU13NUMsT0FBT0QsS0FBSyxDQUFDdjVDLEVBQUU7WUFDckJzaUMsRUFBRW50QixNQUFNLENBQUMvTCxTQUFTc2tDLGNBQWMsQ0FBQzhMO1lBQ2pDLElBQUl4NUMsSUFBSWluQyxLQUFLLEdBQUc7Z0JBQ2QzRSxFQUFFbnRCLE1BQU0sQ0FBQy9MLFNBQVMySSxhQUFhLENBQUM7WUFDbEM7UUFDRjtRQUNBc25DLFNBQVNsa0MsTUFBTSxDQUFDbXRCO0lBQ2xCLE9BQU87UUFDTGdKLFNBQVMwQixNQUFNLENBQUM7WUFDZEcsU0FBU3hsQztZQUNUNGxDLEtBQUs4TDtZQUNMM04sUUFBUTtRQUNWO0lBQ0Y7SUFDQTJOLFNBQVNJLFVBQVUsQ0FBQ25DLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUMsWUFBWWlvQztJQUM5Q0MsVUFBVWprQyxNQUFNLENBQUNra0M7QUFDbkI7QUFFQSxzRUFBc0U7QUFDdEUsSUFBSUssbUJBQW1CcC9DLGlDQUFtQkEsQ0FBQztBQUMzQywrRUFBK0U7QUFDL0UsSUFBSXEvQyw0QkFBNEJyL0MsaUNBQW1CQSxDQUFDO0FBQ3BELDBFQUEwRTtBQUMxRSxJQUFJcy9DLHVCQUF1QnQvQyxpQ0FBbUJBLENBQUM7QUFDL0MsNEVBQTRFO0FBQzVFLElBQUl1L0MseUJBQXlCdi9DLGlDQUFtQkEsQ0FBQztBQUNqRCxnRkFBZ0Y7QUFDaEYsSUFBSXcvQyw2QkFBNkJ4L0MsaUNBQW1CQSxDQUFDO0FBQ3JELDRFQUE0RTtBQUM1RSxJQUFJeS9DLHlCQUF5QnovQyxpQ0FBbUJBLENBQUM7QUFDakQsOEVBQThFO0FBQzlFLElBQUkwL0MsMkJBQTJCMS9DLGlDQUFtQkEsQ0FBQztBQUNuRCxvRkFBb0Y7QUFDcEYsSUFBSTIvQyxpQ0FBaUMzL0MsaUNBQW1CQSxDQUFDO0FBQ3pELHFFQUFxRTtBQUNyRSxJQUFJNC9DLGtCQUFrQjUvQyxpQ0FBbUJBLENBQUM7QUFDMUMsc0VBQXNFO0FBQ3RFLElBQUk2L0MsbUJBQW1CNy9DLGlDQUFtQkEsQ0FBQztBQUMzQyx1RUFBdUU7QUFDdkUsSUFBSTgvQyxvQkFBb0I5L0MsaUNBQW1CQSxDQUFDO0FBQzVDLHNFQUFzRTtBQUN0RSxJQUFJKy9DLG1CQUFtQi8vQyxpQ0FBbUJBLENBQUM7QUFDM0MsdUVBQXVFO0FBQ3ZFLElBQUlnZ0Qsb0JBQW9CaGdELGlDQUFtQkEsQ0FBQztFQUMzQyxrQ0FBa0M7QUFFbkMsTUFBTWlnRDtJQUNKLENBQUNDLE9BQU8sQ0FBUTtJQUNoQixDQUFDQyxXQUFXLENBQVE7SUFDcEIsQ0FBQ0MsTUFBTSxDQUFDO0lBQ1IsQ0FBQ0MsT0FBTyxDQUFRO0lBQ2hCLENBQUNDLE9BQU8sQ0FBUTtJQUNoQixDQUFDQyxPQUFPLENBQVE7SUFDaEIsQ0FBQ0Msb0JBQW9CLENBQVE7SUFDN0IsQ0FBQ0MsMEJBQTBCLENBQVE7SUFDbkMsT0FBTyxDQUFDQyxVQUFVLEdBQUcsS0FBSztJQUMxQnY4QyxZQUFZaThDLE1BQU0sQ0FBRTthQVRwQixDQUFDRixPQUFPLEdBQUc7YUFDWCxDQUFDQyxXQUFXLEdBQUc7YUFFZixDQUFDRSxPQUFPLEdBQUc7YUFDWCxDQUFDQyxPQUFPLEdBQUc7YUFDWCxDQUFDQyxPQUFPLEdBQUc7YUFDWCxDQUFDQyxvQkFBb0IsR0FBRzthQUN4QixDQUFDQywwQkFBMEIsR0FBRztRQUc1QixJQUFJLENBQUMsQ0FBQ0wsTUFBTSxHQUFHQTtRQUNmSCxjQUFjLENBQUNTLFVBQVUsS0FBS3Q5QyxPQUFPdTlDLE1BQU0sQ0FBQztZQUMxQ0MsVUFBVTtZQUNWQyxXQUFXO1lBQ1hDLEtBQUs7WUFDTEMsT0FBTztZQUNQQyxXQUFXO1FBQ2I7SUFDRjtJQUNBdE8sU0FBUztRQUNQLE1BQU11TyxjQUFjLElBQUksQ0FBQyxDQUFDZixPQUFPLEdBQUdweEMsU0FBUzJJLGFBQWEsQ0FBQztRQUMzRHdwQyxZQUFZakUsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQyxlQUFlO1FBQ3pDcXFDLFlBQVl2UCxZQUFZLENBQUMsUUFBUTtRQUNqQyxNQUFNNUIsU0FBUyxJQUFJLENBQUMsQ0FBQ3NRLE1BQU0sQ0FBQ2MsVUFBVSxDQUFDQyxPQUFPO1FBQzlDLElBQUlyUixrQkFBa0JKLGVBQWUsQ0FBQ0ksT0FBT0MsT0FBTyxFQUFFO1lBQ3BEa1IsWUFBWS9RLGdCQUFnQixDQUFDLGVBQWV1SSxlQUFlO2dCQUN6RDNJO1lBQ0Y7WUFDQW1SLFlBQVkvUSxnQkFBZ0IsQ0FBQyxlQUFlK1AsY0FBYyxDQUFDbUIsV0FBVyxFQUFFO2dCQUN0RXRSO1lBQ0Y7UUFDRjtRQUNBLE1BQU11USxVQUFVLElBQUksQ0FBQyxDQUFDQSxPQUFPLEdBQUd2eEMsU0FBUzJJLGFBQWEsQ0FBQztRQUN2RDRvQyxRQUFReEIsU0FBUyxHQUFHO1FBQ3BCb0MsWUFBWXBtQyxNQUFNLENBQUN3bEM7UUFDbkIsTUFBTWdCLFdBQVcsSUFBSSxDQUFDLENBQUNqQixNQUFNLENBQUNrQixlQUFlO1FBQzdDLElBQUlELFVBQVU7WUFDWixNQUFNLEVBQ0o1eUMsS0FBSyxFQUNOLEdBQUd3eUM7WUFDSixNQUFNdjVDLElBQUksSUFBSSxDQUFDLENBQUMwNEMsTUFBTSxDQUFDYyxVQUFVLENBQUNLLFNBQVMsS0FBSyxRQUFRLElBQUlGLFFBQVEsQ0FBQyxFQUFFLEdBQUdBLFFBQVEsQ0FBQyxFQUFFO1lBQ3JGNXlDLE1BQU0reUMsY0FBYyxHQUFHLENBQUMsRUFBRSxNQUFNOTVDLEVBQUUsQ0FBQyxDQUFDO1lBQ3BDK0csTUFBTWd6QyxHQUFHLEdBQUcsQ0FBQyxLQUFLLEVBQUUsTUFBTUosUUFBUSxDQUFDLEVBQUUsQ0FBQyxzQ0FBc0MsQ0FBQztRQUMvRTtRQUNBLE9BQU9KO0lBQ1Q7SUFDQSxJQUFJaE8sTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDLENBQUNpTixPQUFPO0lBQ3RCO0lBQ0EsT0FBTyxDQUFDa0IsV0FBVyxDQUFDN3FDLENBQUM7UUFDbkJBLEVBQUVxaUMsZUFBZTtJQUNuQjtJQUNBLENBQUM4SSxPQUFPLENBQUNuckMsQ0FBQztRQUNSLElBQUksQ0FBQyxDQUFDNnBDLE1BQU0sQ0FBQ3VCLG1CQUFtQixHQUFHO1FBQ25DaEosVUFBVXBpQztJQUNaO0lBQ0EsQ0FBQ3FyQyxRQUFRLENBQUNyckMsQ0FBQztRQUNULElBQUksQ0FBQyxDQUFDNnBDLE1BQU0sQ0FBQ3VCLG1CQUFtQixHQUFHO1FBQ25DaEosVUFBVXBpQztJQUNaO0lBQ0EsQ0FBQ3NyQyxxQkFBcUIsQ0FBQzNRLE9BQU87UUFDNUIsTUFBTXBCLFNBQVMsSUFBSSxDQUFDLENBQUNzUSxNQUFNLENBQUNjLFVBQVUsQ0FBQ0MsT0FBTztRQUM5QyxJQUFJLENBQUVyUixDQUFBQSxrQkFBa0JKLFdBQVUsS0FBTUksT0FBT0MsT0FBTyxFQUFFO1lBQ3RELE9BQU87UUFDVDtRQUNBbUIsUUFBUWhCLGdCQUFnQixDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUN3UixPQUFPLENBQUM1NkMsSUFBSSxDQUFDLElBQUksR0FBRztZQUM1RGc3QyxTQUFTO1lBQ1RoUztRQUNGO1FBQ0FvQixRQUFRaEIsZ0JBQWdCLENBQUMsWUFBWSxJQUFJLENBQUMsQ0FBQzBSLFFBQVEsQ0FBQzk2QyxJQUFJLENBQUMsSUFBSSxHQUFHO1lBQzlEZzdDLFNBQVM7WUFDVGhTO1FBQ0Y7UUFDQW9CLFFBQVFoQixnQkFBZ0IsQ0FBQyxlQUFldUksZUFBZTtZQUNyRDNJO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFDQWlTLE9BQU87UUFDTCxJQUFJLENBQUMsQ0FBQzdCLE9BQU8sQ0FBQ2xELFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7UUFDNUIsSUFBSSxDQUFDLENBQUN1cEMsV0FBVyxFQUFFNkI7SUFDckI7SUFDQUMsT0FBTztRQUNMLElBQUksQ0FBQyxDQUFDL0IsT0FBTyxDQUFDbEQsU0FBUyxDQUFDN21DLE1BQU0sQ0FBQztRQUMvQixJQUFJLENBQUMsQ0FBQ21xQyxPQUFPLEVBQUU0QjtRQUNmLElBQUksQ0FBQyxDQUFDM0IsT0FBTyxFQUFFMkI7SUFDakI7SUFDQUMsa0JBQWtCO1FBQ2hCLE1BQU0sRUFDSkMsVUFBVSxFQUNWbEIsVUFBVSxFQUNYLEdBQUcsSUFBSSxDQUFDLENBQUNkLE1BQU07UUFDaEIsTUFBTWlDLFNBQVN2ekMsU0FBUzJJLGFBQWEsQ0FBQztRQUN0QzRxQyxPQUFPckYsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQyxTQUFTO1FBQzlCeXJDLE9BQU9DLFFBQVEsR0FBRztRQUNsQkQsT0FBTzNRLFlBQVksQ0FBQyxnQkFBZ0J1TyxjQUFjLENBQUNTLFVBQVUsQ0FBQzBCLFdBQVc7UUFDekUsSUFBSSxJQUFJLENBQUMsQ0FBQ1AscUJBQXFCLENBQUNRLFNBQVM7WUFDdkNBLE9BQU9uUyxnQkFBZ0IsQ0FBQyxTQUFTMzVCLENBQUFBO2dCQUMvQjJxQyxXQUFXcUIsTUFBTTtZQUNuQixHQUFHO2dCQUNEelMsUUFBUW9SLFdBQVdDLE9BQU87WUFDNUI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDZCxPQUFPLENBQUN4bEMsTUFBTSxDQUFDd25DO0lBQ3ZCO0lBQ0EsSUFBSSxDQUFDRyxPQUFPO1FBQ1YsTUFBTUEsVUFBVTF6QyxTQUFTMkksYUFBYSxDQUFDO1FBQ3ZDK3FDLFFBQVEzRCxTQUFTLEdBQUc7UUFDcEIsT0FBTzJEO0lBQ1Q7SUFDQSxNQUFNQyxXQUFXbkMsT0FBTyxFQUFFO1FBQ3hCLE1BQU0rQixTQUFTLE1BQU0vQixRQUFRNU4sTUFBTTtRQUNuQyxJQUFJLENBQUMsQ0FBQ21QLHFCQUFxQixDQUFDUTtRQUM1QixJQUFJLENBQUMsQ0FBQ2hDLE9BQU8sQ0FBQ3hsQyxNQUFNLENBQUN3bkMsUUFBUSxJQUFJLENBQUMsQ0FBQ0csT0FBTztRQUMxQyxJQUFJLENBQUMsQ0FBQ2xDLE9BQU8sR0FBR0E7SUFDbEI7SUFDQW9DLFdBQVduQyxPQUFPLEVBQUVvQyxnQkFBZ0IsSUFBSSxFQUFFO1FBQ3hDLElBQUksSUFBSSxDQUFDLENBQUNwQyxPQUFPLEVBQUU7WUFDakI7UUFDRjtRQUNBLE1BQU04QixTQUFTOUIsUUFBUXFDLGdCQUFnQjtRQUN2QyxJQUFJLENBQUNQLFFBQVE7WUFDWDtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNSLHFCQUFxQixDQUFDUTtRQUM1QixNQUFNRyxVQUFVLElBQUksQ0FBQyxDQUFDaEMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLENBQUNnQyxPQUFPO1FBQzFELElBQUksQ0FBQ0csZUFBZTtZQUNsQixJQUFJLENBQUMsQ0FBQ3RDLE9BQU8sQ0FBQ3hsQyxNQUFNLENBQUN3bkMsUUFBUUc7UUFDL0IsT0FBTztZQUNMLElBQUksQ0FBQyxDQUFDbkMsT0FBTyxDQUFDd0MsWUFBWSxDQUFDUixRQUFRTTtZQUNuQyxJQUFJLENBQUMsQ0FBQ3RDLE9BQU8sQ0FBQ3dDLFlBQVksQ0FBQ0wsU0FBU0c7UUFDdEM7UUFDQSxJQUFJLENBQUMsQ0FBQ3BDLE9BQU8sR0FBR0E7UUFDaEJBLFFBQVFMLE9BQU8sR0FBRyxJQUFJO0lBQ3hCO0lBQ0E0QyxlQUFlM0MsV0FBVyxFQUFFO1FBQzFCLElBQUksSUFBSSxDQUFDLENBQUNBLFdBQVcsRUFBRTtZQUNyQjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNBLFdBQVcsR0FBR0E7UUFDcEIsTUFBTWtDLFNBQVNsQyxZQUFZNEMsWUFBWTtRQUN2QyxJQUFJLENBQUMsQ0FBQ2xCLHFCQUFxQixDQUFDUTtRQUM1QixJQUFJLENBQUMsQ0FBQ2hDLE9BQU8sQ0FBQ3hsQyxNQUFNLENBQUN3bkMsUUFBUSxJQUFJLENBQUMsQ0FBQ0csT0FBTztJQUM1QztJQUNBLE1BQU1RLHVCQUF1QkMsZ0JBQWdCLEVBQUU7UUFDN0MsTUFBTVosU0FBUyxJQUFJLENBQUMsQ0FBQzVCLDBCQUEwQixHQUFHLE1BQU13QyxpQkFBaUJDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDOUMsTUFBTTtRQUN0RyxJQUFJLENBQUMsQ0FBQ3lCLHFCQUFxQixDQUFDUTtRQUM1QixJQUFJLENBQUMsQ0FBQ2hDLE9BQU8sQ0FBQ3hsQyxNQUFNLENBQUN3bkMsUUFBUSxJQUFJLENBQUMsQ0FBQ0csT0FBTztJQUM1QztJQUNBVyxhQUFhdC9DLElBQUksRUFBRTtRQUNqQixPQUFRQTtZQUNOLEtBQUs7Z0JBQ0gsSUFBSSxDQUFDLENBQUMwOEMsT0FBTyxFQUFFNkM7Z0JBQ2YsSUFBSSxDQUFDLENBQUM3QyxPQUFPLEdBQUc7Z0JBQ2hCLElBQUksQ0FBQyxDQUFDQyxvQkFBb0IsRUFBRXJxQztnQkFDNUIsSUFBSSxDQUFDLENBQUNxcUMsb0JBQW9CLEdBQUc7Z0JBQzdCO1FBQ0o7SUFDRjtJQUNBLE1BQU02QyxVQUFVeC9DLElBQUksRUFBRXkvQyxJQUFJLEVBQUU7UUFDMUIsT0FBUXovQztZQUNOLEtBQUs7Z0JBQ0gsSUFBSSxDQUFDaS9DLGNBQWMsQ0FBQ1E7Z0JBQ3BCO1lBQ0YsS0FBSztnQkFDSCxNQUFNLElBQUksQ0FBQ2IsVUFBVSxDQUFDYTtnQkFDdEI7WUFDRixLQUFLO2dCQUNILE1BQU0sSUFBSSxDQUFDTixzQkFBc0IsQ0FBQ007Z0JBQ2xDO1lBQ0YsS0FBSztnQkFDSCxJQUFJLENBQUNuQixlQUFlO2dCQUNwQjtZQUNGLEtBQUs7Z0JBQ0gsSUFBSSxDQUFDTyxVQUFVLENBQUNZO2dCQUNoQjtRQUNKO0lBQ0Y7SUFDQSxNQUFNQyxnQkFBZ0IxL0MsSUFBSSxFQUFFeS9DLElBQUksRUFBRUUsY0FBYyxFQUFFO1FBQ2hELE1BQU1iLGdCQUFnQixJQUFJLENBQUMsQ0FBQ3RDLE9BQU8sQ0FBQ29ELGFBQWEsQ0FBQ0Q7UUFDbEQsSUFBSSxDQUFDYixlQUFlO1lBQ2xCO1FBQ0Y7UUFDQSxJQUFJOStDLFNBQVMsV0FBVztZQUN0QixJQUFJLENBQUM2K0MsVUFBVSxDQUFDWSxNQUFNWDtRQUN4QjtJQUNGO0lBQ0FlLDBCQUEwQkMsV0FBVyxFQUFFO1FBQ3JDLElBQUksSUFBSSxDQUFDLENBQUNsRCwwQkFBMEIsRUFBRTtZQUNwQyxJQUFJLENBQUMsQ0FBQ0EsMEJBQTBCLENBQUNtRCxLQUFLLEdBQUdEO1FBQzNDO0lBQ0Y7SUFDQXh0QyxTQUFTO1FBQ1AsSUFBSSxDQUFDLENBQUMrcEMsT0FBTyxDQUFDL3BDLE1BQU07UUFDcEIsSUFBSSxDQUFDLENBQUNncUMsV0FBVyxFQUFFMEQ7UUFDbkIsSUFBSSxDQUFDLENBQUMxRCxXQUFXLEdBQUc7SUFDdEI7QUFDRjtBQUNBLE1BQU0yRDtJQUNKLENBQUN6RCxPQUFPLENBQVE7SUFDaEIsQ0FBQ0gsT0FBTyxDQUFRO0lBQ2hCLENBQUM2RCxTQUFTLENBQUM7SUFDWDUvQyxZQUFZNC9DLFNBQVMsQ0FBRTthQUh2QixDQUFDMUQsT0FBTyxHQUFHO2FBQ1gsQ0FBQ0gsT0FBTyxHQUFHO1FBR1QsSUFBSSxDQUFDLENBQUM2RCxTQUFTLEdBQUdBO0lBQ3BCO0lBQ0EsQ0FBQ3JSLE1BQU07UUFDTCxNQUFNdU8sY0FBYyxJQUFJLENBQUMsQ0FBQ2YsT0FBTyxHQUFHcHhDLFNBQVMySSxhQUFhLENBQUM7UUFDM0R3cEMsWUFBWXBDLFNBQVMsR0FBRztRQUN4Qm9DLFlBQVl2UCxZQUFZLENBQUMsUUFBUTtRQUNqQyxNQUFNNUIsU0FBUyxJQUFJLENBQUMsQ0FBQ2lVLFNBQVMsQ0FBQzVDLE9BQU87UUFDdEMsSUFBSXJSLGtCQUFrQkosZUFBZSxDQUFDSSxPQUFPQyxPQUFPLEVBQUU7WUFDcERrUixZQUFZL1EsZ0JBQWdCLENBQUMsZUFBZXVJLGVBQWU7Z0JBQ3pEM0k7WUFDRjtRQUNGO1FBQ0EsTUFBTXVRLFVBQVUsSUFBSSxDQUFDLENBQUNBLE9BQU8sR0FBR3Z4QyxTQUFTMkksYUFBYSxDQUFDO1FBQ3ZENG9DLFFBQVF4QixTQUFTLEdBQUc7UUFDcEJvQyxZQUFZcG1DLE1BQU0sQ0FBQ3dsQztRQUNuQixJQUFJLElBQUksQ0FBQyxDQUFDMEQsU0FBUyxDQUFDQyxpQkFBaUIsSUFBSTtZQUN2QyxJQUFJLENBQUMsQ0FBQ0MsVUFBVSxDQUFDLGlCQUFpQixDQUFDLDZCQUE2QixDQUFDLEVBQUUsdUNBQXVDO2dCQUN4RyxJQUFJLENBQUMsQ0FBQ0YsU0FBUyxDQUFDRyxnQkFBZ0IsQ0FBQztZQUNuQztRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNELFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxnQ0FBZ0MsQ0FBQyxFQUFFLHlDQUF5QztZQUMvRyxJQUFJLENBQUMsQ0FBQ0YsU0FBUyxDQUFDSSxrQkFBa0IsQ0FBQztRQUNyQztRQUNBLE9BQU9sRDtJQUNUO0lBQ0EsQ0FBQ21ELFlBQVksQ0FBQ0MsS0FBSyxFQUFFQyxLQUFLO1FBQ3hCLElBQUlDLFFBQVE7UUFDWixJQUFJQyxRQUFRO1FBQ1osS0FBSyxNQUFNQyxPQUFPSixNQUFPO1lBQ3ZCLE1BQU1qd0MsSUFBSXF3QyxJQUFJcndDLENBQUMsR0FBR3F3QyxJQUFJdE8sTUFBTTtZQUM1QixJQUFJL2hDLElBQUltd0MsT0FBTztnQkFDYjtZQUNGO1lBQ0EsTUFBTTc4QyxJQUFJKzhDLElBQUkvOEMsQ0FBQyxHQUFJNDhDLENBQUFBLFFBQVFHLElBQUl2TyxLQUFLLEdBQUc7WUFDdkMsSUFBSTloQyxJQUFJbXdDLE9BQU87Z0JBQ2JDLFFBQVE5OEM7Z0JBQ1I2OEMsUUFBUW53QztnQkFDUjtZQUNGO1lBQ0EsSUFBSWt3QyxPQUFPO2dCQUNULElBQUk1OEMsSUFBSTg4QyxPQUFPO29CQUNiQSxRQUFROThDO2dCQUNWO1lBQ0YsT0FBTyxJQUFJQSxJQUFJODhDLE9BQU87Z0JBQ3BCQSxRQUFROThDO1lBQ1Y7UUFDRjtRQUNBLE9BQU87WUFBQzQ4QyxRQUFRLElBQUlFLFFBQVFBO1lBQU9EO1NBQU07SUFDM0M7SUFDQXRDLEtBQUs1TyxNQUFNLEVBQUVnUixLQUFLLEVBQUVDLEtBQUssRUFBRTtRQUN6QixNQUFNLENBQUM1OEMsR0FBRzBNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQ2d3QyxZQUFZLENBQUNDLE9BQU9DO1FBQ3pDLE1BQU0sRUFDSjcxQyxLQUFLLEVBQ04sR0FBRyxJQUFJLENBQUMsQ0FBQ3l4QyxPQUFPLEtBQUssSUFBSSxDQUFDLENBQUN4TixNQUFNO1FBQ2xDVyxPQUFPeDRCLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQ3FsQyxPQUFPO1FBQzNCenhDLE1BQU0reUMsY0FBYyxHQUFHLENBQUMsRUFBRSxNQUFNOTVDLEVBQUUsQ0FBQyxDQUFDO1FBQ3BDK0csTUFBTWd6QyxHQUFHLEdBQUcsQ0FBQyxLQUFLLEVBQUUsTUFBTXJ0QyxFQUFFLHNDQUFzQyxDQUFDO0lBQ3JFO0lBQ0EydEMsT0FBTztRQUNMLElBQUksQ0FBQyxDQUFDN0IsT0FBTyxDQUFDL3BDLE1BQU07SUFDdEI7SUFDQSxDQUFDOHRDLFVBQVUsQ0FBQ1MsV0FBVyxFQUFFQyxNQUFNLEVBQUVDLFdBQVcsRUFBRUMsWUFBWTtRQUN4RCxNQUFNeEMsU0FBU3Z6QyxTQUFTMkksYUFBYSxDQUFDO1FBQ3RDNHFDLE9BQU9yRixTQUFTLENBQUNwbUMsR0FBRyxDQUFDLFNBQVM4dEM7UUFDOUJyQyxPQUFPQyxRQUFRLEdBQUc7UUFDbEJELE9BQU8zUSxZQUFZLENBQUMsZ0JBQWdCaVQ7UUFDcEMsTUFBTXhLLE9BQU9yckMsU0FBUzJJLGFBQWEsQ0FBQztRQUNwQzRxQyxPQUFPeG5DLE1BQU0sQ0FBQ3MvQjtRQUNkQSxLQUFLMEUsU0FBUyxHQUFHO1FBQ2pCMUUsS0FBS3pJLFlBQVksQ0FBQyxnQkFBZ0JrVDtRQUNsQyxNQUFNOVUsU0FBUyxJQUFJLENBQUMsQ0FBQ2lVLFNBQVMsQ0FBQzVDLE9BQU87UUFDdEMsSUFBSXJSLGtCQUFrQkosZUFBZSxDQUFDSSxPQUFPQyxPQUFPLEVBQUU7WUFDcERzUyxPQUFPblMsZ0JBQWdCLENBQUMsZUFBZXVJLGVBQWU7Z0JBQ3BEM0k7WUFDRjtZQUNBdVMsT0FBT25TLGdCQUFnQixDQUFDLFNBQVMyVSxjQUFjO2dCQUM3Qy9VO1lBQ0Y7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDdVEsT0FBTyxDQUFDeGxDLE1BQU0sQ0FBQ3duQztJQUN2QjtBQUNGO0VBRUMsZ0NBQWdDO0FBdUJqQyxTQUFTeUMsV0FBV2o1QyxHQUFHLEVBQUVxbEMsT0FBTyxFQUFFaGxDLEtBQUs7SUFDckMsS0FBSyxNQUFNckksUUFBUXFJLE1BQU87UUFDeEJnbEMsUUFBUWhCLGdCQUFnQixDQUFDcnNDLE1BQU1nSSxHQUFHLENBQUNoSSxLQUFLLENBQUNpRCxJQUFJLENBQUMrRTtJQUNoRDtBQUNGO0FBQ0EsTUFBTWs1QztJQUNKLENBQUNydkMsRUFBRSxDQUFLO0lBQ1IsSUFBSUEsS0FBSztRQUNQLE9BQU8sQ0FBQyxFQUFFb2YsdUJBQXVCLEVBQUUsSUFBSSxDQUFDLENBQUNwZixFQUFFLEdBQUcsQ0FBQztJQUNqRDs7YUFIQSxDQUFDQSxFQUFFLEdBQUc7O0FBSVI7QUFDQSxNQUFNc3ZDO0lBQ0osQ0FBQ0MsTUFBTSxDQUFhO0lBQ3BCLENBQUN2dkMsRUFBRSxDQUFLO0lBQ1IsQ0FBQ3d2QyxLQUFLLENBQVE7SUFDZCxXQUFXQyxzQkFBc0I7UUFDL0IsTUFBTUMsTUFBTSxDQUFDLG9LQUFvSyxDQUFDO1FBQ2xMLE1BQU1DLFNBQVMsSUFBSWhmLGdCQUFnQixHQUFHO1FBQ3RDLE1BQU1xVSxNQUFNMkssT0FBT0MsVUFBVSxDQUFDLE1BQU07WUFDbENDLG9CQUFvQjtRQUN0QjtRQUNBLE1BQU1DLFFBQVEsSUFBSUM7UUFDbEJELE1BQU01MkMsR0FBRyxHQUFHdzJDO1FBQ1osTUFBTS81QyxVQUFVbTZDLE1BQU1oWixNQUFNLEdBQUdrWixJQUFJLENBQUM7WUFDbENoTCxJQUFJaUwsU0FBUyxDQUFDSCxPQUFPLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7WUFDMUMsT0FBTyxJQUFJem9DLFlBQVkyOUIsSUFBSWtMLFlBQVksQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHdDBDLElBQUksQ0FBQzdMLE1BQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSztRQUMxRTtRQUNBLE9BQU84K0IsT0FBTyxJQUFJLEVBQUUsdUJBQXVCbDVCO0lBQzdDO0lBQ0EsTUFBTSxDQUFDckksR0FBRyxDQUFDbUosR0FBRyxFQUFFMDVDLE9BQU87UUFDckIsSUFBSSxDQUFDLENBQUNYLEtBQUssS0FBSyxJQUFJalg7UUFDcEIsSUFBSTM4QixPQUFPLElBQUksQ0FBQyxDQUFDNHpDLEtBQUssQ0FBQ2xpRCxHQUFHLENBQUNtSjtRQUMzQixJQUFJbUYsU0FBUyxNQUFNO1lBQ2pCLE9BQU87UUFDVDtRQUNBLElBQUlBLE1BQU13VixRQUFRO1lBQ2hCeFYsS0FBS3cwQyxVQUFVLElBQUk7WUFDbkIsT0FBT3gwQztRQUNUO1FBQ0EsSUFBSTtZQUNGQSxTQUFTO2dCQUNQd1YsUUFBUTtnQkFDUnBSLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUN1dkMsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQ3Z2QyxFQUFFLEdBQUcsQ0FBQztnQkFDekNvd0MsWUFBWTtnQkFDWkMsT0FBTztZQUNUO1lBQ0EsSUFBSVA7WUFDSixJQUFJLE9BQU9LLFlBQVksVUFBVTtnQkFDL0J2MEMsS0FBS29ULEdBQUcsR0FBR21oQztnQkFDWEwsUUFBUSxNQUFNdlIsVUFBVTRSLFNBQVM7WUFDbkMsT0FBTyxJQUFJQSxtQkFBbUJHLE1BQU07Z0JBQ2xDUixRQUFRbDBDLEtBQUsyMEMsSUFBSSxHQUFHSjtZQUN0QixPQUFPLElBQUlBLG1CQUFtQkssTUFBTTtnQkFDbENWLFFBQVFLO1lBQ1Y7WUFDQSxJQUFJTCxNQUFNOTdDLElBQUksS0FBSyxpQkFBaUI7Z0JBQ2xDLE1BQU15OEMsK0JBQStCbkIsYUFBYUcsbUJBQW1CO2dCQUNyRSxNQUFNaUIsYUFBYSxJQUFJQztnQkFDdkIsTUFBTUMsZUFBZSxJQUFJYjtnQkFDekIsTUFBTWMsZUFBZSxJQUFJMzdDLFFBQVEsQ0FBQ1EsU0FBU0Q7b0JBQ3pDbTdDLGFBQWFFLE1BQU0sR0FBRzt3QkFDcEJsMUMsS0FBS3dWLE1BQU0sR0FBR3cvQjt3QkFDZGgxQyxLQUFLeTBDLEtBQUssR0FBRzt3QkFDYjM2QztvQkFDRjtvQkFDQWc3QyxXQUFXSSxNQUFNLEdBQUc7d0JBQ2xCLE1BQU05aEMsTUFBTXBULEtBQUttMUMsTUFBTSxHQUFHTCxXQUFXaGtELE1BQU07d0JBQzNDa2tELGFBQWExM0MsR0FBRyxHQUFHLE1BQU91M0MsK0JBQWdDLENBQUMsRUFBRXpoQyxJQUFJLG1DQUFtQyxDQUFDLEdBQUdBO29CQUMxRztvQkFDQTRoQyxhQUFhSSxPQUFPLEdBQUdOLFdBQVdNLE9BQU8sR0FBR3Y3QztnQkFDOUM7Z0JBQ0FpN0MsV0FBV08sYUFBYSxDQUFDbkI7Z0JBQ3pCLE1BQU1lO1lBQ1IsT0FBTztnQkFDTGoxQyxLQUFLd1YsTUFBTSxHQUFHLE1BQU04L0Isa0JBQWtCcEI7WUFDeEM7WUFDQWwwQyxLQUFLdzBDLFVBQVUsR0FBRztRQUNwQixFQUFFLE9BQU92dkMsR0FBRztZQUNWK3NCLEtBQUsvc0I7WUFDTGpGLE9BQU87UUFDVDtRQUNBLElBQUksQ0FBQyxDQUFDNHpDLEtBQUssQ0FBQzU3QyxHQUFHLENBQUM2QyxLQUFLbUY7UUFDckIsSUFBSUEsTUFBTTtZQUNSLElBQUksQ0FBQyxDQUFDNHpDLEtBQUssQ0FBQzU3QyxHQUFHLENBQUNnSSxLQUFLb0UsRUFBRSxFQUFFcEU7UUFDM0I7UUFDQSxPQUFPQTtJQUNUO0lBQ0EsTUFBTXUxQyxZQUFZWixJQUFJLEVBQUU7UUFDdEIsTUFBTSxFQUNKYSxZQUFZLEVBQ1pqakQsSUFBSSxFQUNKa1MsSUFBSSxFQUNKck0sSUFBSSxFQUNMLEdBQUd1OEM7UUFDSixPQUFPLElBQUksQ0FBQyxDQUFDampELEdBQUcsQ0FBQyxDQUFDLEVBQUU4akQsYUFBYSxDQUFDLEVBQUVqakQsS0FBSyxDQUFDLEVBQUVrUyxLQUFLLENBQUMsRUFBRXJNLEtBQUssQ0FBQyxFQUFFdThDO0lBQzlEO0lBQ0EsTUFBTWMsV0FBV3JpQyxHQUFHLEVBQUU7UUFDcEIsT0FBTyxJQUFJLENBQUMsQ0FBQzFoQixHQUFHLENBQUMwaEIsS0FBS0E7SUFDeEI7SUFDQSxNQUFNc2lDLFlBQVl0eEMsRUFBRSxFQUFFdXhDLFdBQVcsRUFBRTtRQUNqQyxNQUFNelMsT0FBTyxNQUFNeVM7UUFDbkIsT0FBTyxJQUFJLENBQUMsQ0FBQ2prRCxHQUFHLENBQUMwUyxJQUFJOCtCO0lBQ3ZCO0lBQ0EsTUFBTTBTLFVBQVV4eEMsRUFBRSxFQUFFO1FBQ2xCLElBQUksQ0FBQyxDQUFDd3ZDLEtBQUssS0FBSyxJQUFJalg7UUFDcEIsTUFBTTM4QixPQUFPLElBQUksQ0FBQyxDQUFDNHpDLEtBQUssQ0FBQ2xpRCxHQUFHLENBQUMwUztRQUM3QixJQUFJLENBQUNwRSxNQUFNO1lBQ1QsT0FBTztRQUNUO1FBQ0EsSUFBSUEsS0FBS3dWLE1BQU0sRUFBRTtZQUNmeFYsS0FBS3cwQyxVQUFVLElBQUk7WUFDbkIsT0FBT3gwQztRQUNUO1FBQ0EsSUFBSUEsS0FBSzIwQyxJQUFJLEVBQUU7WUFDYixPQUFPLElBQUksQ0FBQ1ksV0FBVyxDQUFDdjFDLEtBQUsyMEMsSUFBSTtRQUNuQztRQUNBLElBQUkzMEMsS0FBSzIxQyxXQUFXLEVBQUU7WUFDcEIsTUFBTSxFQUNKQSxXQUFXLEVBQ1osR0FBRzMxQztZQUNKLE9BQU9BLEtBQUsyMUMsV0FBVztZQUN2QixPQUFPLElBQUksQ0FBQ0QsV0FBVyxDQUFDMTFDLEtBQUtvRSxFQUFFLEVBQUV1eEM7UUFDbkM7UUFDQSxPQUFPLElBQUksQ0FBQ0YsVUFBVSxDQUFDejFDLEtBQUtvVCxHQUFHO0lBQ2pDO0lBQ0F5aUMsY0FBY3p4QyxFQUFFLEVBQUUydkMsTUFBTSxFQUFFO1FBQ3hCLElBQUksQ0FBQyxDQUFDSCxLQUFLLEtBQUssSUFBSWpYO1FBQ3BCLElBQUkzOEIsT0FBTyxJQUFJLENBQUMsQ0FBQzR6QyxLQUFLLENBQUNsaUQsR0FBRyxDQUFDMFM7UUFDM0IsSUFBSXBFLE1BQU13VixRQUFRO1lBQ2hCeFYsS0FBS3cwQyxVQUFVLElBQUk7WUFDbkIsT0FBT3gwQztRQUNUO1FBQ0EsTUFBTTgxQyxZQUFZLElBQUkvZ0IsZ0JBQWdCZ2YsT0FBT25QLEtBQUssRUFBRW1QLE9BQU9sUCxNQUFNO1FBQ2pFLE1BQU11RSxNQUFNME0sVUFBVTlCLFVBQVUsQ0FBQztRQUNqQzVLLElBQUlpTCxTQUFTLENBQUNOLFFBQVEsR0FBRztRQUN6Qi96QyxPQUFPO1lBQ0x3VixRQUFRc2dDLFVBQVVDLHFCQUFxQjtZQUN2QzN4QyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDdXZDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUN2dkMsRUFBRSxHQUFHLENBQUM7WUFDekNvd0MsWUFBWTtZQUNaQyxPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUMsQ0FBQ2IsS0FBSyxDQUFDNTdDLEdBQUcsQ0FBQ29NLElBQUlwRTtRQUNwQixJQUFJLENBQUMsQ0FBQzR6QyxLQUFLLENBQUM1N0MsR0FBRyxDQUFDZ0ksS0FBS29FLEVBQUUsRUFBRXBFO1FBQ3pCLE9BQU9BO0lBQ1Q7SUFDQWcyQyxVQUFVNXhDLEVBQUUsRUFBRTtRQUNaLE1BQU1wRSxPQUFPLElBQUksQ0FBQyxDQUFDNHpDLEtBQUssQ0FBQ2xpRCxHQUFHLENBQUMwUztRQUM3QixJQUFJLENBQUNwRSxNQUFNeTBDLE9BQU87WUFDaEIsT0FBTztRQUNUO1FBQ0EsT0FBT3owQyxLQUFLbTFDLE1BQU07SUFDcEI7SUFDQWMsU0FBUzd4QyxFQUFFLEVBQUU7UUFDWCxJQUFJLENBQUMsQ0FBQ3d2QyxLQUFLLEtBQUssSUFBSWpYO1FBQ3BCLE1BQU0zOEIsT0FBTyxJQUFJLENBQUMsQ0FBQzR6QyxLQUFLLENBQUNsaUQsR0FBRyxDQUFDMFM7UUFDN0IsSUFBSSxDQUFDcEUsTUFBTTtZQUNUO1FBQ0Y7UUFDQUEsS0FBS3cwQyxVQUFVLElBQUk7UUFDbkIsSUFBSXgwQyxLQUFLdzBDLFVBQVUsS0FBSyxHQUFHO1lBQ3pCO1FBQ0Y7UUFDQSxNQUFNLEVBQ0poL0IsTUFBTSxFQUNQLEdBQUd4VjtRQUNKLElBQUksQ0FBQ0EsS0FBS29ULEdBQUcsSUFBSSxDQUFDcFQsS0FBSzIwQyxJQUFJLEVBQUU7WUFDM0IsTUFBTVosU0FBUyxJQUFJaGYsZ0JBQWdCdmYsT0FBT292QixLQUFLLEVBQUVwdkIsT0FBT3F2QixNQUFNO1lBQzlELE1BQU11RSxNQUFNMkssT0FBT0MsVUFBVSxDQUFDO1lBQzlCNUssSUFBSThNLHVCQUF1QixDQUFDMWdDO1lBQzVCeFYsS0FBSzIxQyxXQUFXLEdBQUc1QixPQUFPb0MsYUFBYTtRQUN6QztRQUNBM2dDLE9BQU81WSxLQUFLO1FBQ1pvRCxLQUFLd1YsTUFBTSxHQUFHO0lBQ2hCO0lBQ0E0Z0MsVUFBVWh5QyxFQUFFLEVBQUU7UUFDWixPQUFPQSxHQUFHcXVCLFVBQVUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQ2toQixNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQy9DOzthQXBLQSxDQUFDQSxNQUFNLEdBQUc3VzthQUNWLENBQUMxNEIsRUFBRSxHQUFHO2FBQ04sQ0FBQ3d2QyxLQUFLLEdBQUc7O0FBbUtYO0FBQ0EsTUFBTXlDO0lBQ0osQ0FBQ0MsUUFBUSxDQUFNO0lBQ2YsQ0FBQ0MsTUFBTSxDQUFTO0lBQ2hCLENBQUNDLE9BQU8sQ0FBQztJQUNULENBQUN6RyxRQUFRLENBQU07SUFDZmw5QyxZQUFZMmpELFVBQVUsR0FBRyxDQUFFO2FBSjNCLENBQUNGLFFBQVEsR0FBRyxFQUFFO2FBQ2QsQ0FBQ0MsTUFBTSxHQUFHO2FBRVYsQ0FBQ3hHLFFBQVEsR0FBRyxDQUFDO1FBRVgsSUFBSSxDQUFDLENBQUN5RyxPQUFPLEdBQUdBO0lBQ2xCO0lBQ0FseEMsSUFBSSxFQUNGbXhDLEdBQUcsRUFDSEMsSUFBSSxFQUNKQyxJQUFJLEVBQ0pDLFFBQVEsRUFDUngrQyxPQUFPMkosR0FBRyxFQUNWODBDLHNCQUFzQixLQUFLLEVBQzNCQyxXQUFXLEtBQUssRUFDakIsRUFBRTtRQUNELElBQUlGLFVBQVU7WUFDWkg7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDLENBQUNGLE1BQU0sRUFBRTtZQUNoQjtRQUNGO1FBQ0EsTUFBTXJxQixPQUFPO1lBQ1h1cUI7WUFDQUM7WUFDQUM7WUFDQXYrQztRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUMsQ0FBQzIzQyxRQUFRLEtBQUssQ0FBQyxHQUFHO1lBQ3pCLElBQUksSUFBSSxDQUFDLENBQUN1RyxRQUFRLENBQUM3bUQsTUFBTSxHQUFHLEdBQUc7Z0JBQzdCLElBQUksQ0FBQyxDQUFDNm1ELFFBQVEsQ0FBQzdtRCxNQUFNLEdBQUc7WUFDMUI7WUFDQSxJQUFJLENBQUMsQ0FBQ3NnRCxRQUFRLEdBQUc7WUFDakIsSUFBSSxDQUFDLENBQUN1RyxRQUFRLENBQUM1N0MsSUFBSSxDQUFDd3hCO1lBQ3BCO1FBQ0Y7UUFDQSxJQUFJMnFCLHVCQUF1QixJQUFJLENBQUMsQ0FBQ1AsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDdkcsUUFBUSxDQUFDLENBQUMzM0MsSUFBSSxLQUFLQSxNQUFNO1lBQ3ZFLElBQUkwK0MsVUFBVTtnQkFDWjVxQixLQUFLd3FCLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQ0osUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDdkcsUUFBUSxDQUFDLENBQUMyRyxJQUFJO1lBQ2pEO1lBQ0EsSUFBSSxDQUFDLENBQUNKLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQ3ZHLFFBQVEsQ0FBQyxHQUFHN2pCO1lBQ2pDO1FBQ0Y7UUFDQSxNQUFNejNCLE9BQU8sSUFBSSxDQUFDLENBQUNzN0MsUUFBUSxHQUFHO1FBQzlCLElBQUl0N0MsU0FBUyxJQUFJLENBQUMsQ0FBQytoRCxPQUFPLEVBQUU7WUFDMUIsSUFBSSxDQUFDLENBQUNGLFFBQVEsQ0FBQ1MsTUFBTSxDQUFDLEdBQUc7UUFDM0IsT0FBTztZQUNMLElBQUksQ0FBQyxDQUFDaEgsUUFBUSxHQUFHdDdDO1lBQ2pCLElBQUlBLE9BQU8sSUFBSSxDQUFDLENBQUM2aEQsUUFBUSxDQUFDN21ELE1BQU0sRUFBRTtnQkFDaEMsSUFBSSxDQUFDLENBQUM2bUQsUUFBUSxDQUFDUyxNQUFNLENBQUN0aUQ7WUFDeEI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDNmhELFFBQVEsQ0FBQzU3QyxJQUFJLENBQUN3eEI7SUFDdEI7SUFDQXdxQixPQUFPO1FBQ0wsSUFBSSxJQUFJLENBQUMsQ0FBQzNHLFFBQVEsS0FBSyxDQUFDLEdBQUc7WUFDekI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDd0csTUFBTSxHQUFHO1FBQ2YsTUFBTSxFQUNKRyxJQUFJLEVBQ0pDLElBQUksRUFDTCxHQUFHLElBQUksQ0FBQyxDQUFDTCxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUN2RyxRQUFRLENBQUM7UUFDbEMyRztRQUNBQztRQUNBLElBQUksQ0FBQyxDQUFDSixNQUFNLEdBQUc7UUFDZixJQUFJLENBQUMsQ0FBQ3hHLFFBQVEsSUFBSTtJQUNwQjtJQUNBaUgsT0FBTztRQUNMLElBQUksSUFBSSxDQUFDLENBQUNqSCxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUN1RyxRQUFRLENBQUM3bUQsTUFBTSxHQUFHLEdBQUc7WUFDOUMsSUFBSSxDQUFDLENBQUNzZ0QsUUFBUSxJQUFJO1lBQ2xCLElBQUksQ0FBQyxDQUFDd0csTUFBTSxHQUFHO1lBQ2YsTUFBTSxFQUNKRSxHQUFHLEVBQ0hFLElBQUksRUFDTCxHQUFHLElBQUksQ0FBQyxDQUFDTCxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUN2RyxRQUFRLENBQUM7WUFDbEMwRztZQUNBRTtZQUNBLElBQUksQ0FBQyxDQUFDSixNQUFNLEdBQUc7UUFDakI7SUFDRjtJQUNBVSxxQkFBcUI7UUFDbkIsT0FBTyxJQUFJLENBQUMsQ0FBQ2xILFFBQVEsS0FBSyxDQUFDO0lBQzdCO0lBQ0FtSCxxQkFBcUI7UUFDbkIsT0FBTyxJQUFJLENBQUMsQ0FBQ25ILFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQ3VHLFFBQVEsQ0FBQzdtRCxNQUFNLEdBQUc7SUFDbEQ7SUFDQTBuRCxVQUFVLytDLElBQUksRUFBRTtRQUNkLElBQUksSUFBSSxDQUFDLENBQUMyM0MsUUFBUSxLQUFLLENBQUMsR0FBRztZQUN6QjtRQUNGO1FBQ0EsSUFBSyxJQUFJMzdDLElBQUksSUFBSSxDQUFDLENBQUMyN0MsUUFBUSxFQUFFMzdDLEtBQUssR0FBR0EsSUFBSztZQUN4QyxJQUFJLElBQUksQ0FBQyxDQUFDa2lELFFBQVEsQ0FBQ2xpRCxFQUFFLENBQUNnRSxJQUFJLEtBQUtBLE1BQU07Z0JBQ25DLElBQUksQ0FBQyxDQUFDaytDLFFBQVEsQ0FBQ1MsTUFBTSxDQUFDM2lELElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQzI3QyxRQUFRLEdBQUczN0M7Z0JBQzlDLElBQUksQ0FBQyxDQUFDMjdDLFFBQVEsR0FBRzM3QztnQkFDakI7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNraUQsUUFBUSxDQUFDN21ELE1BQU0sR0FBRztRQUN4QixJQUFJLENBQUMsQ0FBQ3NnRCxRQUFRLEdBQUcsQ0FBQztJQUNwQjtJQUNBd0MsVUFBVTtRQUNSLElBQUksQ0FBQyxDQUFDK0QsUUFBUSxHQUFHO0lBQ25CO0FBQ0Y7QUFDQSxNQUFNYztJQUNKdmtELFlBQVl3a0QsU0FBUyxDQUFFO1FBQ3JCLElBQUksQ0FBQ2xqRCxNQUFNLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUNrakQsU0FBUyxHQUFHLElBQUkxYTtRQUNyQixJQUFJLENBQUMyYSxPQUFPLEdBQUcsSUFBSTd2QztRQUNuQixNQUFNLEVBQ0o0dEIsS0FBSyxFQUNOLEdBQUdSLGlCQUFpQkssUUFBUTtRQUM3QixLQUFLLE1BQU0sQ0FBQ2orQixNQUFNNFcsVUFBVXJiLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSTZrRCxVQUFXO1lBQ3RELEtBQUssTUFBTXg4QyxPQUFPNUQsS0FBTTtnQkFDdEIsTUFBTXNnRCxXQUFXMThDLElBQUk0M0IsVUFBVSxDQUFDO2dCQUNoQyxJQUFJNEMsU0FBU2tpQixVQUFVO29CQUNyQixJQUFJLENBQUNGLFNBQVMsQ0FBQ3IvQyxHQUFHLENBQUM2QyxJQUFJN0ksS0FBSyxDQUFDLElBQUk7d0JBQy9CNmI7d0JBQ0FyYjtvQkFDRjtvQkFDQSxJQUFJLENBQUM4a0QsT0FBTyxDQUFDaHlDLEdBQUcsQ0FBQ3pLLElBQUl4SSxLQUFLLENBQUMsS0FBS29tQixFQUFFLENBQUMsQ0FBQztnQkFDdEMsT0FBTyxJQUFJLENBQUM0YyxTQUFTLENBQUNraUIsVUFBVTtvQkFDOUIsSUFBSSxDQUFDRixTQUFTLENBQUNyL0MsR0FBRyxDQUFDNkMsS0FBSzt3QkFDdEJnVDt3QkFDQXJiO29CQUNGO29CQUNBLElBQUksQ0FBQzhrRCxPQUFPLENBQUNoeUMsR0FBRyxDQUFDekssSUFBSXhJLEtBQUssQ0FBQyxLQUFLb21CLEVBQUUsQ0FBQyxDQUFDO2dCQUN0QztZQUNGO1FBQ0Y7SUFDRjtJQUNBLENBQUMrK0IsU0FBUyxDQUFDdlgsS0FBSztRQUNkLElBQUlBLE1BQU13WCxNQUFNLEVBQUU7WUFDaEIsSUFBSSxDQUFDdGpELE1BQU0sQ0FBQ3VHLElBQUksQ0FBQztRQUNuQjtRQUNBLElBQUl1bEMsTUFBTXlYLE9BQU8sRUFBRTtZQUNqQixJQUFJLENBQUN2akQsTUFBTSxDQUFDdUcsSUFBSSxDQUFDO1FBQ25CO1FBQ0EsSUFBSXVsQyxNQUFNMFgsT0FBTyxFQUFFO1lBQ2pCLElBQUksQ0FBQ3hqRCxNQUFNLENBQUN1RyxJQUFJLENBQUM7UUFDbkI7UUFDQSxJQUFJdWxDLE1BQU0yWCxRQUFRLEVBQUU7WUFDbEIsSUFBSSxDQUFDempELE1BQU0sQ0FBQ3VHLElBQUksQ0FBQztRQUNuQjtRQUNBLElBQUksQ0FBQ3ZHLE1BQU0sQ0FBQ3VHLElBQUksQ0FBQ3VsQyxNQUFNcGxDLEdBQUc7UUFDMUIsTUFBTXc1QixNQUFNLElBQUksQ0FBQ2xnQyxNQUFNLENBQUNqQyxJQUFJLENBQUM7UUFDN0IsSUFBSSxDQUFDaUMsTUFBTSxDQUFDMUUsTUFBTSxHQUFHO1FBQ3JCLE9BQU80a0M7SUFDVDtJQUNBbDlCLEtBQUs2UixLQUFJLEVBQUVpM0IsS0FBSyxFQUFFO1FBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUNxWCxPQUFPLENBQUNyL0MsR0FBRyxDQUFDZ29DLE1BQU1wbEMsR0FBRyxHQUFHO1lBQ2hDO1FBQ0Y7UUFDQSxNQUFNZzNCLE9BQU8sSUFBSSxDQUFDd2xCLFNBQVMsQ0FBQzNsRCxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM4bEQsU0FBUyxDQUFDdlg7UUFDaEQsSUFBSSxDQUFDcE8sTUFBTTtZQUNUO1FBQ0Y7UUFDQSxNQUFNLEVBQ0poa0IsUUFBUSxFQUNScmIsU0FBUyxFQUNQcWxELFVBQVUsS0FBSyxFQUNmbitDLE9BQU8sRUFBRSxFQUNUbytDLFVBQVUsSUFBSSxFQUNmLEVBQ0YsR0FBR2ptQjtRQUNKLElBQUlpbUIsV0FBVyxDQUFDQSxRQUFROXVDLE9BQU1pM0IsUUFBUTtZQUNwQztRQUNGO1FBQ0FweUIsU0FBU3JZLElBQUksQ0FBQ3dULFVBQVN0UCxNQUFNdW1DO1FBQzdCLElBQUksQ0FBQzRYLFNBQVM7WUFDWnhRLFVBQVVwSDtRQUNaO0lBQ0Y7QUFDRjtBQUNBLE1BQU04WDs7YUFDR0MsaUJBQWlCLElBQUlyYixJQUFJO1lBQUM7Z0JBQUM7Z0JBQWM7b0JBQUM7b0JBQUc7b0JBQUc7aUJBQUU7YUFBQztZQUFFO2dCQUFDO2dCQUFVO29CQUFDO29CQUFLO29CQUFLO2lCQUFJO2FBQUM7U0FBQzs7SUFDeEYsSUFBSXNiLFVBQVU7UUFDWixNQUFNclAsU0FBUyxJQUFJak0sSUFBSTtZQUFDO2dCQUFDO2dCQUFjO2FBQUs7WUFBRTtnQkFBQztnQkFBVTthQUFLO1NBQUM7UUFDL0RnTSxlQUFlQztRQUNmLE9BQU8zVixPQUFPLElBQUksRUFBRSxXQUFXMlY7SUFDakM7SUFDQXNQLFFBQVF6UCxLQUFLLEVBQUU7UUFDYixNQUFNdUQsTUFBTXhELE9BQU9DO1FBQ25CLElBQUksQ0FBQ3hoQyxPQUFPc2tDLFVBQVUsQ0FBQywyQkFBMkIzRCxPQUFPLEVBQUU7WUFDekQsT0FBT29FO1FBQ1Q7UUFDQSxLQUFLLE1BQU0sQ0FBQ3o1QyxNQUFNNGxELElBQUksSUFBSSxJQUFJLENBQUNGLE9BQU8sQ0FBRTtZQUN0QyxJQUFJRSxJQUFJN2dELEtBQUssQ0FBQyxDQUFDbEIsR0FBR2hDLElBQU1nQyxNQUFNNDFDLEdBQUcsQ0FBQzUzQyxFQUFFLEdBQUc7Z0JBQ3JDLE9BQU8yakQsYUFBYUMsY0FBYyxDQUFDdG1ELEdBQUcsQ0FBQ2E7WUFDekM7UUFDRjtRQUNBLE9BQU95NUM7SUFDVDtJQUNBb00sV0FBVzdsRCxJQUFJLEVBQUU7UUFDZixNQUFNeTVDLE1BQU0sSUFBSSxDQUFDaU0sT0FBTyxDQUFDdm1ELEdBQUcsQ0FBQ2E7UUFDN0IsSUFBSSxDQUFDeTVDLEtBQUs7WUFDUixPQUFPejVDO1FBQ1Q7UUFDQSxPQUFPc2pDLEtBQUtDLFlBQVksSUFBSWtXO0lBQzlCO0FBQ0Y7QUFDQSxNQUFNcU07SUFDSixDQUFDQyxlQUFlLENBQXlCO0lBQ3pDLENBQUNDLFlBQVksQ0FBUTtJQUNyQixDQUFDQyxzQkFBc0IsQ0FBUTtJQUMvQixDQUFDQyxVQUFVLENBQWE7SUFDeEIsQ0FBQ0MsU0FBUyxDQUFhO0lBQ3ZCLENBQUNDLGNBQWMsQ0FBUTtJQUN2QixDQUFDclgsaUJBQWlCLENBQVE7SUFDMUIsQ0FBQ3NYLDBCQUEwQixDQUFRO0lBQ25DLENBQUNDLGNBQWMsQ0FBd0I7SUFDdkMsQ0FBQ0MsY0FBYyxDQUFRO0lBQ3ZCLENBQUNDLFdBQVcsQ0FBUTtJQUNwQixDQUFDQyxxQkFBcUIsQ0FBUTtJQUM5QixDQUFDQyxnQkFBZ0IsQ0FBSztJQUN0QixDQUFDQyw0QkFBNEIsQ0FBYTtJQUMxQyxDQUFDQyxlQUFlLENBQVE7SUFDeEIsQ0FBQ0MsV0FBVyxDQUFRO0lBQ3BCLENBQUNDLGdCQUFnQixDQUFhO0lBRTlCLENBQUNDLDZCQUE2QixDQUFTO0lBQ3ZDLENBQUNDLHFCQUFxQixDQUFTO0lBQy9CLENBQUNDLCtCQUErQixDQUFTO0lBQ3pDLENBQUNDLGFBQWEsQ0FBUTtJQUN0QixDQUFDQywyQkFBMkIsQ0FBUTtJQUNwQyxDQUFDQyxjQUFjLENBQVE7SUFDdkIsQ0FBQ0MsZUFBZSxDQUFRO0lBQ3hCLENBQUNDLG9CQUFvQixDQUFTO0lBQzlCLENBQUNDLGVBQWUsQ0FBUTtJQUN4QixDQUFDQyxTQUFTLENBQW1CO0lBQzdCLENBQUNDLFNBQVMsQ0FBUztJQUNuQixDQUFDQyxhQUFhLENBQVM7SUFDdkIsQ0FBQ0MsU0FBUyxDQUFTO0lBQ25CLENBQUNDLGlCQUFpQixDQUFRO0lBQzFCLENBQUNDLGlCQUFpQixDQUFRO0lBQzFCLENBQUNDLHdCQUF3QixDQUFRO0lBQ2pDLENBQUNDLGVBQWUsQ0FBUTtJQUN4QixDQUFDQyxTQUFTLENBQVE7SUFDbEIsQ0FBQzVqQyxJQUFJLENBQTZCO0lBQ2xDLENBQUM2akMsZUFBZSxDQUFhO0lBQzdCLENBQUNDLGdCQUFnQixDQUFRO0lBQ3pCLENBQUM5SSxnQkFBZ0IsQ0FBUTtJQUN6QixDQUFDK0ksVUFBVSxDQUFRO0lBQ25CLENBQUNDLGFBQWEsQ0FBUTtJQUN0QixDQUFDQyxXQUFXLENBQVE7SUFDcEIsQ0FBQ0MsY0FBYyxDQU9iO0lBQ0YsQ0FBQ0MsV0FBVyxDQUFVO0lBQ3RCLENBQUNDLG9CQUFvQixDQUFRO0lBQzdCLENBQUN2TixTQUFTLENBQVE7SUFDbEIsQ0FBQ3dOLE1BQU0sQ0FBUTtJQUNmLENBQUNDLFdBQVcsQ0FBUTtJQUNwQixDQUFDQyxvQkFBb0IsQ0FBUTs7YUFDdEJDLGtCQUFrQjs7O2FBQ2xCQyxnQkFBZ0I7O0lBQ3ZCLFdBQVdDLG1CQUFtQjtRQUM1QixNQUFNbnJELFFBQVFtb0QsMEJBQTBCdGxELFNBQVM7UUFDakQsTUFBTXVvRCxlQUFldHlDLENBQUFBLFFBQVFBLE1BQUssQ0FBQ3drQyxTQUFTLENBQUMrTixRQUFRLENBQUMvOUMsU0FBU2crQyxhQUFhLEtBQUtoK0MsU0FBU2crQyxhQUFhLENBQUNDLE9BQU8sS0FBSyxZQUFZenlDLE1BQUsweUMscUJBQXFCO1FBQzFKLE1BQU1DLG1CQUFtQixDQUFDQyxPQUFPLEVBQy9CM3JELFFBQVFxd0IsRUFBRSxFQUNYO1lBQ0MsSUFBSUEsY0FBY3U3QixrQkFBa0I7Z0JBQ2xDLE1BQU0sRUFDSnpqRCxJQUFJLEVBQ0wsR0FBR2tvQjtnQkFDSixPQUFPbG9CLFNBQVMsVUFBVUEsU0FBUztZQUNyQztZQUNBLE9BQU87UUFDVDtRQUNBLE1BQU0wakQsUUFBUSxJQUFJLENBQUNYLGVBQWU7UUFDbEMsTUFBTVksTUFBTSxJQUFJLENBQUNYLGFBQWE7UUFDOUIsT0FBT25vQixPQUFPLElBQUksRUFBRSxvQkFBb0IsSUFBSW1rQixnQkFBZ0I7WUFBQztnQkFBQztvQkFBQztvQkFBVTtpQkFBYTtnQkFBRWxuRCxNQUFNOHJELFNBQVM7Z0JBQUU7b0JBQ3ZHbEUsU0FBUzZEO2dCQUNYO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBVTtpQkFBYTtnQkFBRXpyRCxNQUFNd21ELElBQUk7Z0JBQUU7b0JBQ3pDb0IsU0FBUzZEO2dCQUNYO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBVTtvQkFBZ0I7b0JBQW9CO29CQUFnQjtpQkFBbUI7Z0JBQUV6ckQsTUFBTThtRCxJQUFJO2dCQUFFO29CQUNuR2MsU0FBUzZEO2dCQUNYO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBYTtvQkFBaUI7b0JBQWtCO29CQUFtQjtvQkFBaUI7b0JBQXFCO29CQUFzQjtvQkFBVTtvQkFBZTtvQkFBZ0I7aUJBQWE7Z0JBQUV6ckQsTUFBTStnRCxNQUFNO2dCQUFFO29CQUN6TTZHLFNBQVM2RDtnQkFDWDthQUFFO1lBQUU7Z0JBQUM7b0JBQUM7b0JBQVM7aUJBQVk7Z0JBQUV6ckQsTUFBTStyRCx3QkFBd0I7Z0JBQUU7b0JBQzNEbkUsU0FBUyxDQUFDOXVDLE9BQU0sRUFDZC9ZLFFBQVFxd0IsRUFBRSxFQUNYLEdBQUssQ0FBRUEsQ0FBQUEsY0FBYzQ3QixpQkFBZ0IsS0FBTWx6QyxNQUFLLENBQUN3a0MsU0FBUyxDQUFDK04sUUFBUSxDQUFDajdCLE9BQU8sQ0FBQ3RYLE1BQUttekMsY0FBYztnQkFDbEc7YUFBRTtZQUFFO2dCQUFDO29CQUFDO29CQUFLO2lCQUFRO2dCQUFFanNELE1BQU0rckQsd0JBQXdCO2dCQUFFO29CQUNuRG5FLFNBQVMsQ0FBQzl1QyxPQUFNLEVBQ2QvWSxRQUFRcXdCLEVBQUUsRUFDWCxHQUFLLENBQUVBLENBQUFBLGNBQWM0N0IsaUJBQWdCLEtBQU1sekMsTUFBSyxDQUFDd2tDLFNBQVMsQ0FBQytOLFFBQVEsQ0FBQy85QyxTQUFTZytDLGFBQWE7Z0JBQzdGO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBVTtpQkFBYTtnQkFBRXRyRCxNQUFNa3NELFdBQVc7YUFBQztZQUFFO2dCQUFDO29CQUFDO29CQUFhO2lCQUFnQjtnQkFBRWxzRCxNQUFNbXNELHdCQUF3QjtnQkFBRTtvQkFDbEgzaUQsTUFBTTt3QkFBQyxDQUFDb2lEO3dCQUFPO3FCQUFFO29CQUNqQmhFLFNBQVN3RDtnQkFDWDthQUFFO1lBQUU7Z0JBQUM7b0JBQUM7b0JBQWtCO2lCQUFzQjtnQkFBRXByRCxNQUFNbXNELHdCQUF3QjtnQkFBRTtvQkFDOUUzaUQsTUFBTTt3QkFBQyxDQUFDcWlEO3dCQUFLO3FCQUFFO29CQUNmakUsU0FBU3dEO2dCQUNYO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBYztpQkFBaUI7Z0JBQUVwckQsTUFBTW1zRCx3QkFBd0I7Z0JBQUU7b0JBQ3JFM2lELE1BQU07d0JBQUNvaUQ7d0JBQU87cUJBQUU7b0JBQ2hCaEUsU0FBU3dEO2dCQUNYO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBbUI7aUJBQXVCO2dCQUFFcHJELE1BQU1tc0Qsd0JBQXdCO2dCQUFFO29CQUNoRjNpRCxNQUFNO3dCQUFDcWlEO3dCQUFLO3FCQUFFO29CQUNkakUsU0FBU3dEO2dCQUNYO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBVztpQkFBYztnQkFBRXByRCxNQUFNbXNELHdCQUF3QjtnQkFBRTtvQkFDL0QzaUQsTUFBTTt3QkFBQzt3QkFBRyxDQUFDb2lEO3FCQUFNO29CQUNqQmhFLFNBQVN3RDtnQkFDWDthQUFFO1lBQUU7Z0JBQUM7b0JBQUM7b0JBQWdCO2lCQUFvQjtnQkFBRXByRCxNQUFNbXNELHdCQUF3QjtnQkFBRTtvQkFDMUUzaUQsTUFBTTt3QkFBQzt3QkFBRyxDQUFDcWlEO3FCQUFJO29CQUNmakUsU0FBU3dEO2dCQUNYO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBYTtpQkFBZ0I7Z0JBQUVwckQsTUFBTW1zRCx3QkFBd0I7Z0JBQUU7b0JBQ25FM2lELE1BQU07d0JBQUM7d0JBQUdvaUQ7cUJBQU07b0JBQ2hCaEUsU0FBU3dEO2dCQUNYO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBa0I7aUJBQXNCO2dCQUFFcHJELE1BQU1tc0Qsd0JBQXdCO2dCQUFFO29CQUM5RTNpRCxNQUFNO3dCQUFDO3dCQUFHcWlEO3FCQUFJO29CQUNkakUsU0FBU3dEO2dCQUNYO2FBQUU7U0FBQztJQUNMO0lBQ0F6b0QsWUFBWTI2QyxTQUFTLEVBQUV3TixNQUFNLEVBQUVDLFdBQVcsRUFBRXRDLGNBQWMsRUFBRUcsY0FBYyxFQUFFbkgsZ0JBQWdCLEVBQUUySyxRQUFRLEVBQUUxQixXQUFXLEVBQUVGLFVBQVUsRUFBRWQsZUFBZSxFQUFFTiw2QkFBNkIsRUFBRUMscUJBQXFCLEVBQUVDLCtCQUErQixFQUFFZSxTQUFTLEVBQUVnQyxhQUFhLEVBQUVDLG1CQUFtQixDQUFFO2FBckh4UixDQUFDbEUsZUFBZSxHQUFHLElBQUkvWjthQUN2QixDQUFDZ2EsWUFBWSxHQUFHO2FBQ2hCLENBQUNDLHNCQUFzQixHQUFHO2FBQzFCLENBQUNDLFVBQVUsR0FBRyxJQUFJOWI7YUFDbEIsQ0FBQytiLFNBQVMsR0FBRyxJQUFJL2I7YUFDakIsQ0FBQ2djLGNBQWMsR0FBRzthQUNsQixDQUFDclgsaUJBQWlCLEdBQUc7YUFDckIsQ0FBQ3NYLDBCQUEwQixHQUFHO2FBQzlCLENBQUNDLGNBQWMsR0FBRyxJQUFJeEM7YUFDdEIsQ0FBQ3lDLGNBQWMsR0FBRzthQUNsQixDQUFDQyxXQUFXLEdBQUc7YUFDZixDQUFDQyxxQkFBcUIsR0FBRzthQUN6QixDQUFDQyxnQkFBZ0IsR0FBRzthQUNwQixDQUFDQyw0QkFBNEIsR0FBRyxJQUFJenhDO2FBQ3BDLENBQUMweEMsZUFBZSxHQUFHO2FBQ25CLENBQUNDLFdBQVcsR0FBRzthQUNmLENBQUNDLGdCQUFnQixHQUFHLElBQUk1eEM7YUFDeEJnMUMsaUJBQWlCO2FBQ2pCLENBQUNuRCw2QkFBNkIsR0FBRzthQUNqQyxDQUFDQyxxQkFBcUIsR0FBRzthQUN6QixDQUFDQywrQkFBK0IsR0FBRzthQUNuQyxDQUFDQyxhQUFhLEdBQUc7YUFDakIsQ0FBQ0MsMkJBQTJCLEdBQUc7YUFDL0IsQ0FBQ0MsY0FBYyxHQUFHO2FBQ2xCLENBQUNDLGVBQWUsR0FBRzthQUNuQixDQUFDQyxvQkFBb0IsR0FBRzthQUN4QixDQUFDQyxlQUFlLEdBQUc7YUFDbkIsQ0FBQ0MsU0FBUyxHQUFHLElBQUl0RzthQUNqQixDQUFDdUcsU0FBUyxHQUFHO2FBQ2IsQ0FBQ0MsYUFBYSxHQUFHO2FBQ2pCLENBQUNDLFNBQVMsR0FBRzthQUNiLENBQUNDLGlCQUFpQixHQUFHO2FBQ3JCLENBQUNDLGlCQUFpQixHQUFHO2FBQ3JCLENBQUNDLHdCQUF3QixHQUFHO2FBQzVCLENBQUNDLGVBQWUsR0FBRzthQUNuQixDQUFDQyxTQUFTLEdBQUc7YUFDYixDQUFDNWpDLElBQUksR0FBRzhNLHFCQUFxQkMsSUFBSTthQUNqQyxDQUFDODJCLGVBQWUsR0FBRyxJQUFJL3lDO2FBQ3ZCLENBQUNnekMsZ0JBQWdCLEdBQUc7YUFDcEIsQ0FBQzlJLGdCQUFnQixHQUFHO2FBQ3BCLENBQUMrSSxVQUFVLEdBQUc7YUFDZCxDQUFDQyxhQUFhLEdBQUc7YUFDakIsQ0FBQ0MsV0FBVyxHQUFHO2FBQ2YsQ0FBQ0MsY0FBYyxHQUFHO1lBQ2hCNkIsV0FBVztZQUNYQyxTQUFTO1lBQ1QxRixvQkFBb0I7WUFDcEJDLG9CQUFvQjtZQUNwQjBGLG1CQUFtQjtZQUNuQkMsaUJBQWlCO1FBQ25CO2FBQ0EsQ0FBQy9CLFdBQVcsR0FBRztZQUFDO1lBQUc7U0FBRTthQUNyQixDQUFDQyxvQkFBb0IsR0FBRzthQUN4QixDQUFDdk4sU0FBUyxHQUFHO2FBQ2IsQ0FBQ3dOLE1BQU0sR0FBRzthQUNWLENBQUNDLFdBQVcsR0FBRzthQUNmLENBQUNDLG9CQUFvQixHQUFHO1FBOER0QixNQUFNMWMsU0FBUyxJQUFJLENBQUNxUixPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUN5SSxlQUFlLENBQUM5WixNQUFNO1FBQzFELElBQUksQ0FBQyxDQUFDZ1AsU0FBUyxHQUFHQTtRQUNsQixJQUFJLENBQUMsQ0FBQ3dOLE1BQU0sR0FBR0E7UUFDZixJQUFJLENBQUMsQ0FBQ0MsV0FBVyxHQUFHQTtRQUNwQixJQUFJLENBQUMsQ0FBQ3RDLGNBQWMsR0FBR0E7UUFDdkIsSUFBSSxDQUFDLENBQUNHLGNBQWMsR0FBR0E7UUFDdkIsSUFBSSxDQUFDLENBQUNuSCxnQkFBZ0IsR0FBR0E7UUFDekIsSUFBSSxDQUFDLENBQUNpSixXQUFXLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ2tDLFNBQVMsR0FBR1I7UUFDakJBLFNBQVNTLEdBQUcsQ0FBQyxpQkFBaUIsSUFBSSxDQUFDQyxlQUFlLENBQUN4bkQsSUFBSSxDQUFDLElBQUksR0FBRztZQUM3RGdwQztRQUNGO1FBQ0E4ZCxTQUFTUyxHQUFHLENBQUMsZ0JBQWdCLElBQUksQ0FBQ0UsY0FBYyxDQUFDem5ELElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDM0RncEM7UUFDRjtRQUNBOGQsU0FBU1MsR0FBRyxDQUFDLGlCQUFpQixJQUFJLENBQUNHLGVBQWUsQ0FBQzFuRCxJQUFJLENBQUMsSUFBSSxHQUFHO1lBQzdEZ3BDO1FBQ0Y7UUFDQThkLFNBQVNTLEdBQUcsQ0FBQyxvQkFBb0IsSUFBSSxDQUFDSSxrQkFBa0IsQ0FBQzNuRCxJQUFJLENBQUMsSUFBSSxHQUFHO1lBQ25FZ3BDO1FBQ0Y7UUFDQThkLFNBQVNTLEdBQUcsQ0FBQyxpQkFBaUIsSUFBSSxDQUFDSyxlQUFlLENBQUM1bkQsSUFBSSxDQUFDLElBQUksR0FBRztZQUM3RGdwQztRQUNGO1FBQ0E4ZCxTQUFTUyxHQUFHLENBQUMsZ0NBQWdDTSxDQUFBQSxNQUFPLElBQUksQ0FBQ0MsWUFBWSxDQUFDRCxJQUFJamxELElBQUksRUFBRWlsRCxJQUFJM3NELEtBQUssR0FBRztZQUMxRjh0QztRQUNGO1FBQ0F2M0IsT0FBTzIzQixnQkFBZ0IsQ0FBQyxlQUFlO1lBQ3JDLElBQUksQ0FBQyxDQUFDcWIsYUFBYSxHQUFHO1FBQ3hCLEdBQUc7WUFDRHpKLFNBQVM7WUFDVGhTO1FBQ0Y7UUFDQXYzQixPQUFPMjNCLGdCQUFnQixDQUFDLGFBQWE7WUFDbkMsSUFBSSxDQUFDLENBQUNxYixhQUFhLEdBQUc7UUFDeEIsR0FBRztZQUNEekosU0FBUztZQUNUaFM7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDK2Usb0JBQW9CO1FBQzFCLElBQUksQ0FBQyxDQUFDQyx1QkFBdUI7UUFDN0IsSUFBSSxDQUFDLENBQUNDLGtCQUFrQjtRQUN4QixJQUFJLENBQUMsQ0FBQ25jLGlCQUFpQixHQUFHc1osWUFBWXRaLGlCQUFpQjtRQUN2RCxJQUFJLENBQUMsQ0FBQ21ZLGFBQWEsR0FBR21CLFlBQVluQixhQUFhO1FBQy9DLElBQUksQ0FBQyxDQUFDaUIsVUFBVSxHQUFHQTtRQUNuQixJQUFJLENBQUMsQ0FBQ2QsZUFBZSxHQUFHQSxtQkFBbUI7UUFDM0MsSUFBSSxDQUFDLENBQUNOLDZCQUE2QixHQUFHQTtRQUN0QyxJQUFJLENBQUMsQ0FBQ0MscUJBQXFCLEdBQUdBO1FBQzlCLElBQUksQ0FBQyxDQUFDQywrQkFBK0IsR0FBR0E7UUFDeEMsSUFBSSxDQUFDLENBQUNlLFNBQVMsR0FBR0EsYUFBYTtRQUMvQixJQUFJLENBQUNtRCxjQUFjLEdBQUc7WUFDcEJDLFdBQVduYixjQUFjRSxnQkFBZ0I7WUFDekNzQixVQUFVO1FBQ1o7UUFDQSxJQUFJLENBQUM0WixjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDbkIsY0FBYyxHQUFHRixpQkFBaUI7UUFDdkMsSUFBSSxDQUFDc0Isb0JBQW9CLEdBQUdyQix3QkFBd0I7UUFDcEQxRCxnQkFBZ0JnRixvQkFBb0IsSUFBSTtJQUMxQztJQUNBdkwsVUFBVTtRQUNSLElBQUksQ0FBQyxDQUFDMkksb0JBQW9CLEVBQUVwaEQ7UUFDNUIsSUFBSSxDQUFDLENBQUNvaEQsb0JBQW9CLEdBQUc7UUFDN0IsSUFBSSxDQUFDLENBQUM1QyxlQUFlLEVBQUU1WjtRQUN2QixJQUFJLENBQUMsQ0FBQzRaLGVBQWUsR0FBRztRQUN4QixJQUFJLENBQUN6SSxPQUFPLEdBQUc7UUFDZixLQUFLLE1BQU1rTyxTQUFTLElBQUksQ0FBQyxDQUFDckYsU0FBUyxDQUFDbmlDLE1BQU0sR0FBSTtZQUM1Q3duQyxNQUFNeEwsT0FBTztRQUNmO1FBQ0EsSUFBSSxDQUFDLENBQUNtRyxTQUFTLENBQUN6aEMsS0FBSztRQUNyQixJQUFJLENBQUMsQ0FBQ3doQyxVQUFVLENBQUN4aEMsS0FBSztRQUN0QixJQUFJLENBQUMsQ0FBQ29pQyxnQkFBZ0IsQ0FBQ3BpQyxLQUFLO1FBQzVCLElBQUksQ0FBQyxDQUFDcWpDLGVBQWUsRUFBRXJqQztRQUN2QixJQUFJLENBQUMsQ0FBQ3NoQyxZQUFZLEdBQUc7UUFDckIsSUFBSSxDQUFDLENBQUNpQyxlQUFlLENBQUN2akMsS0FBSztRQUMzQixJQUFJLENBQUMsQ0FBQzRoQyxjQUFjLENBQUN0RyxPQUFPO1FBQzVCLElBQUksQ0FBQyxDQUFDb0csY0FBYyxFQUFFcEc7UUFDdEIsSUFBSSxDQUFDLENBQUN1RyxjQUFjLEVBQUV2RztRQUN0QixJQUFJLENBQUMsQ0FBQ1osZ0JBQWdCLEVBQUVZO1FBQ3hCLElBQUksQ0FBQyxDQUFDdUgsZUFBZSxFQUFFcko7UUFDdkIsSUFBSSxDQUFDLENBQUNxSixlQUFlLEdBQUc7UUFDeEIsSUFBSSxDQUFDLENBQUNPLHdCQUF3QixFQUFFOUg7UUFDaEMsSUFBSSxDQUFDLENBQUM4SCx3QkFBd0IsR0FBRztRQUNqQyxJQUFJLENBQUMsQ0FBQzdCLHNCQUFzQixHQUFHO1FBQy9CLElBQUksSUFBSSxDQUFDLENBQUNrQiwyQkFBMkIsRUFBRTtZQUNyQ3NFLGFBQWEsSUFBSSxDQUFDLENBQUN0RSwyQkFBMkI7WUFDOUMsSUFBSSxDQUFDLENBQUNBLDJCQUEyQixHQUFHO1FBQ3RDO1FBQ0EsSUFBSSxJQUFJLENBQUMsQ0FBQ3FCLG9CQUFvQixFQUFFO1lBQzlCaUQsYUFBYSxJQUFJLENBQUMsQ0FBQ2pELG9CQUFvQjtZQUN2QyxJQUFJLENBQUMsQ0FBQ0Esb0JBQW9CLEdBQUc7UUFDL0I7UUFDQSxJQUFJLENBQUMwQixjQUFjLEVBQUVsSztRQUNyQixJQUFJLENBQUMsQ0FBQ3FJLFdBQVcsR0FBRztJQUN0QjtJQUNBcUQsZUFBZTNmLEVBQUUsRUFBRTtRQUNqQixPQUFPRixZQUFZQyxHQUFHLENBQUM7WUFBQyxJQUFJLENBQUN3UixPQUFPO1lBQUV2UixHQUFHRSxNQUFNO1NBQUM7SUFDbEQ7SUFDQSxJQUFJK2IsWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDLENBQUNBLFNBQVM7SUFDeEI7SUFDQSxJQUFJMkQsb0JBQW9CO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLENBQUMzRSxxQkFBcUI7SUFDcEM7SUFDQSxJQUFJNEUsK0JBQStCO1FBQ2pDLE9BQU8sSUFBSSxDQUFDLENBQUMzRSwrQkFBK0I7SUFDOUM7SUFDQSxJQUFJNEUsWUFBWTtRQUNkLE9BQU9uckIsT0FBTyxJQUFJLEVBQUUsYUFBYSxJQUFJLENBQUMsQ0FBQ3luQixVQUFVLEdBQUcsSUFBSSxDQUFDLENBQUNqQixhQUFhLENBQUM0RSxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMzRCxVQUFVLENBQUM0RCxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM1RCxVQUFVLENBQUM2RCxVQUFVLElBQUk7SUFDbko7SUFDQSxJQUFJdE8sWUFBWTtRQUNkLE9BQU9oZCxPQUFPLElBQUksRUFBRSxhQUFhaVcsaUJBQWlCLElBQUksQ0FBQyxDQUFDc0UsU0FBUyxFQUFFeUMsU0FBUztJQUM5RTtJQUNBLElBQUl1TyxtQkFBbUI7UUFDckIsT0FBT3ZyQixPQUFPLElBQUksRUFBRSxvQkFBb0IsSUFBSSxDQUFDLENBQUMybUIsZUFBZSxHQUFHLElBQUlqZCxJQUFJLElBQUksQ0FBQyxDQUFDaWQsZUFBZSxDQUFDdm5ELEtBQUssQ0FBQyxLQUFLaUksR0FBRyxDQUFDbWtELENBQUFBO1lBQzNHQSxPQUFPQSxLQUFLcHNELEtBQUssQ0FBQyxLQUFLaUksR0FBRyxDQUFDbEUsQ0FBQUEsSUFBS0EsRUFBRXd2QyxJQUFJO1lBQ3RDNlksSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0MsV0FBVztZQUM3QixPQUFPRDtRQUNULE1BQU07SUFDUjtJQUNBLElBQUk3RSxrQkFBa0I7UUFDcEIsTUFBTSxFQUNKNEUsZ0JBQWdCLEVBQ2pCLEdBQUcsSUFBSTtRQUNSLElBQUksQ0FBQ0Esa0JBQWtCO1lBQ3JCLE9BQU92ckIsT0FBTyxJQUFJLEVBQUUsbUJBQW1CO1FBQ3pDO1FBQ0EsTUFBTTM0QixNQUFNLElBQUlxaUM7UUFDaEIsTUFBTWdpQixTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQ2pFLFVBQVU7UUFDakMsS0FBSyxNQUFNLENBQUNub0QsTUFBTWsyQyxNQUFNLElBQUkrVixpQkFBa0I7WUFDNUMsTUFBTUksZUFBZXJzRCxLQUFLc3NELFFBQVEsQ0FBQztZQUNuQyxJQUFJRixVQUFVQyxjQUFjO2dCQUMxQnRrRCxJQUFJdEMsR0FBRyxDQUFDekYsS0FBS04sT0FBTyxDQUFDLFFBQVEsS0FBS3cyQztnQkFDbEM7WUFDRjtZQUNBLElBQUksQ0FBQ2tXLFVBQVUsQ0FBQ0MsY0FBYztnQkFDNUJ0a0QsSUFBSXRDLEdBQUcsQ0FBQ3pGLE1BQU1rMkM7WUFDaEI7UUFDRjtRQUNBLE9BQU94VixPQUFPLElBQUksRUFBRSxtQkFBbUIzNEI7SUFDekM7SUFDQSxJQUFJd2tELHNCQUFzQjtRQUN4QixPQUFPN3JCLE9BQU8sSUFBSSxFQUFFLHVCQUF1QixJQUFJLENBQUMybUIsZUFBZSxHQUFHLElBQUlqZCxJQUFJbjdCLE1BQU1xVyxJQUFJLENBQUMsSUFBSSxDQUFDK2hDLGVBQWUsRUFBRTMwQyxDQUFBQSxJQUFLQSxFQUFFc2hDLE9BQU8sT0FBTztJQUNsSTtJQUNBd1ksZUFBZXRXLEtBQUssRUFBRTtRQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDK1YsZ0JBQWdCLEVBQUU7WUFDMUIsT0FBTy9WO1FBQ1Q7UUFDQSxNQUFNdVcsWUFBWSxJQUFJLENBQUNGLG1CQUFtQixDQUFDcHRELEdBQUcsQ0FBQysyQztRQUMvQyxPQUFPLElBQUksQ0FBQytWLGdCQUFnQixDQUFDOXNELEdBQUcsQ0FBQ3N0RCxjQUFjdlc7SUFDakQ7SUFDQXdXLG1CQUFtQnhXLEtBQUssRUFBRTtRQUN4QixPQUFPLElBQUksQ0FBQ3FXLG1CQUFtQixDQUFDcHRELEdBQUcsQ0FBQysyQyxVQUFVQTtJQUNoRDtJQUNBeVcseUJBQXlCbkIsS0FBSyxFQUFFO1FBQzlCLElBQUlBLE9BQU87WUFDVCxJQUFJLENBQUMzQixXQUFXO1lBQ2hCLElBQUksQ0FBQytDLGlCQUFpQixDQUFDO1FBQ3pCLE9BQU87WUFDTCxJQUFJLENBQUNBLGlCQUFpQixDQUFDO1FBQ3pCO1FBQ0EsSUFBSSxDQUFDLENBQUNuRyxxQkFBcUIsR0FBRytFO0lBQ2hDO0lBQ0FxQiw0QkFBNEJ2USxXQUFXLEVBQUU7UUFDdkMsSUFBSSxDQUFDLENBQUN3TCx3QkFBd0IsR0FBR3hMO0lBQ25DO0lBQ0F3USxZQUFZdlEsTUFBTSxFQUFFd1EsWUFBWSxLQUFLLEVBQUU7UUFDckMsSUFBSSxDQUFDLENBQUMzRyxjQUFjLEVBQUUwRyxZQUFZLElBQUksRUFBRXZRLFFBQVF3UTtJQUNsRDtJQUNBNU0sb0JBQW9CO1FBQ2xCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDb0csY0FBYztJQUMvQjtJQUNBeUcsWUFBWXpRLE1BQU0sRUFBRTBRLElBQUksRUFBRUMsSUFBSSxFQUFFanRELE9BQU8sRUFBRTtRQUN2QyxJQUFJLENBQUMsQ0FBQ3NtRCxjQUFjLEVBQUU0RyxXQUFXLElBQUksRUFBRTVRLFFBQVEwUSxNQUFNQyxNQUFNanREO0lBQzdEO0lBQ0FtdEQsY0FBY0MsU0FBUyxFQUFFcjFDLEdBQUcsRUFBRTtRQUM1QixNQUFNd3pDLFFBQVEsSUFBSSxDQUFDLENBQUNyRixTQUFTLENBQUNobkQsR0FBRyxDQUFDa3VEO1FBQ2xDLE1BQU05USxTQUFTaVAsT0FBTzhCLGVBQWV0MUM7UUFDckN1a0MsUUFBUWdSLGNBQWMsTUFBTTtJQUM5QjtJQUNBQyxjQUFjalIsTUFBTSxFQUFFO1FBQ3BCLElBQUksQ0FBQyxDQUFDZ0ssY0FBYyxFQUFFaUgsY0FBY2pSLE9BQU9rUixPQUFPO0lBQ3BEO0lBQ0FDLGlCQUFpQm5SLE1BQU0sRUFBRTtRQUN2QixJQUFJLENBQUMsQ0FBQ2dLLGNBQWMsRUFBRW1ILGlCQUFpQm5SO0lBQ3pDO0lBQ0FvUixjQUFjcFIsTUFBTSxFQUFFO1FBQ3BCLElBQUksQ0FBQyxDQUFDZ0ssY0FBYyxFQUFFcUgsZUFBZTtZQUFDclIsT0FBT3ZrQyxHQUFHO1NBQUM7SUFDbkQ7SUFDQXUxQyxjQUFjaFIsTUFBTSxFQUFFc1IsVUFBVSxFQUFFdFgsYUFBYTkxQyxTQUFTLEVBQUU7UUFDeEQsSUFBSSxDQUFDLENBQUM4bEQsY0FBYyxFQUFFdUgsbUJBQW1CdlIsUUFBUXNSLFlBQVl0WDtJQUMvRDtJQUNBd1gsaUJBQWlCN1gsS0FBSyxFQUFFbUQsT0FBTyxFQUFFO1FBQy9CLE9BQU9uRCxTQUFTLElBQUksQ0FBQyxDQUFDcVEsY0FBYyxFQUFFd0gsaUJBQWlCN1gsT0FBT21ELFlBQVk7SUFDNUU7SUFDQTJVLDBCQUEwQjtRQUN4QixPQUFPLElBQUksQ0FBQyxDQUFDekgsY0FBYyxFQUFFMEgsaUJBQWlCO0lBQ2hEO0lBQ0EsTUFBTUMsdUJBQXVCQyxVQUFVLEVBQUU7UUFDdkMsSUFBSSxJQUFJLENBQUMsQ0FBQ2hJLFNBQVMsQ0FBQ3pnRCxHQUFHLENBQUN5b0QsYUFBYSxJQUFJO1lBQ3ZDO1FBQ0Y7UUFDQSxNQUFNLEVBQ0o1bUQsT0FBTyxFQUNQQyxPQUFPLEVBQ1IsR0FBR1QsUUFBUStRLGFBQWE7UUFDekIsTUFBTXMyQyxvQkFBb0J0RCxDQUFBQTtZQUN4QixJQUFJQSxJQUFJcUQsVUFBVSxLQUFLQSxZQUFZO2dCQUNqQyxJQUFJLENBQUM1RCxTQUFTLENBQUM4RCxJQUFJLENBQUMsbUJBQW1CRDtnQkFDdkM3bUQ7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDZ2pELFNBQVMsQ0FBQytELEVBQUUsQ0FBQyxtQkFBbUJGO1FBQ3JDLE1BQU01bUQ7SUFDUjtJQUNBK21ELGFBQWFoUyxNQUFNLEVBQUU7UUFDbkIsSUFBSSxDQUFDLENBQUM2QyxnQkFBZ0IsRUFBRW1QLGFBQWE7WUFDbkNyTyxXQUFXLElBQUk7WUFDZjNEO1FBQ0Y7SUFDRjtJQUNBLElBQUk2QyxtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsZ0JBQWdCO0lBQy9CO0lBQ0FvUCxhQUFhcHFDLElBQUksRUFBRTlJLFFBQVEsRUFBRTtRQUMzQixJQUFJLENBQUNpdkMsU0FBUyxDQUFDK0QsRUFBRSxDQUFDLCtCQUErQmh6QyxVQUFVO1lBQ3pEbXpDLE1BQU07WUFDTnhpQixRQUFRLElBQUksQ0FBQ3FSLE9BQU87UUFDdEI7UUFDQSxJQUFJLENBQUNpTixTQUFTLENBQUNtRSxRQUFRLENBQUMsMEJBQTBCO1lBQ2hEL3RELFFBQVEsSUFBSTtZQUNaeWpCO1FBQ0Y7SUFDRjtJQUNBdXFDLGNBQWMzdUQsSUFBSSxFQUFFN0IsS0FBSyxFQUFFO1FBQ3pCLElBQUksQ0FBQ29zRCxTQUFTLENBQUNtRSxRQUFRLENBQUMsaUJBQWlCO1lBQ3ZDL3RELFFBQVEsSUFBSTtZQUNaWDtZQUNBN0I7UUFDRjtJQUNGO0lBQ0Ewc0QsZ0JBQWdCLEVBQ2Q3cUQsSUFBSSxFQUNKN0IsS0FBSyxFQUNOLEVBQUU7UUFDRCxPQUFRNkI7WUFDTixLQUFLO2dCQUNILElBQUksQ0FBQyxDQUFDaW5ELCtCQUErQixHQUFHOW9EO2dCQUN4QztRQUNKO0lBQ0Y7SUFDQXVzRCxlQUFlLEVBQ2J5RCxVQUFVLEVBQ1gsRUFBRTtRQUNELElBQUksQ0FBQyxDQUFDekgsZ0JBQWdCLEdBQUd5SCxhQUFhO0lBQ3hDO0lBQ0FTLHFCQUFxQjtRQUNuQixJQUFJLENBQUMsQ0FBQzNULFNBQVMsQ0FBQzRULEtBQUs7SUFDdkI7SUFDQUMsV0FBV2pyRCxDQUFDLEVBQUUwTSxDQUFDLEVBQUU7UUFDZixLQUFLLE1BQU1pN0MsU0FBUyxJQUFJLENBQUMsQ0FBQ3JGLFNBQVMsQ0FBQ25pQyxNQUFNLEdBQUk7WUFDNUMsTUFBTSxFQUNKbmdCLEdBQUdrckQsTUFBTSxFQUNUeCtDLEdBQUd5K0MsTUFBTSxFQUNUM2MsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBR2taLE1BQU1wYyxHQUFHLENBQUM2ZixxQkFBcUI7WUFDbkMsSUFBSXByRCxLQUFLa3JELFVBQVVsckQsS0FBS2tyRCxTQUFTMWMsU0FBUzloQyxLQUFLeStDLFVBQVV6K0MsS0FBS3krQyxTQUFTMWMsUUFBUTtnQkFDN0UsT0FBT2taO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBb0Isa0JBQWtCenVELFFBQVEsS0FBSyxFQUFFO1FBQy9CLElBQUksQ0FBQyxDQUFDc3FELE1BQU0sQ0FBQ3RQLFNBQVMsQ0FBQytWLE1BQU0sQ0FBQyxnQkFBZ0Ivd0Q7SUFDaEQ7SUFDQWd4RCxpQkFBaUI1UyxNQUFNLEVBQUU7UUFDdkIsSUFBSSxDQUFDLENBQUN1SyxnQkFBZ0IsQ0FBQy96QyxHQUFHLENBQUN3cEM7SUFDN0I7SUFDQTZTLG9CQUFvQjdTLE1BQU0sRUFBRTtRQUMxQixJQUFJLENBQUMsQ0FBQ3VLLGdCQUFnQixDQUFDcEksTUFBTSxDQUFDbkM7SUFDaEM7SUFDQW9PLGdCQUFnQixFQUNkblosS0FBSyxFQUNOLEVBQUU7UUFDRCxJQUFJLENBQUM2ZCxjQUFjO1FBQ25CLElBQUksQ0FBQ2xFLGNBQWMsQ0FBQ0MsU0FBUyxHQUFHNVosUUFBUXZCLGNBQWNFLGdCQUFnQjtRQUN0RSxLQUFLLE1BQU1vTSxVQUFVLElBQUksQ0FBQyxDQUFDdUssZ0JBQWdCLENBQUU7WUFDM0N2SyxPQUFPb08sZUFBZTtRQUN4QjtRQUNBLElBQUksQ0FBQyxDQUFDbEUscUJBQXFCLEVBQUVrRTtJQUMvQjtJQUNBQyxtQkFBbUIsRUFDakIwRSxhQUFhLEVBQ2QsRUFBRTtRQUNELElBQUksQ0FBQ0QsY0FBYztRQUNuQixJQUFJLENBQUNsRSxjQUFjLENBQUMxWixRQUFRLEdBQUc2ZDtJQUNqQztJQUNBLENBQUNDLDRCQUE0QixDQUFDLEVBQzVCQyxVQUFVLEVBQ1g7UUFDQyxPQUFPQSxXQUFXQyxRQUFRLEtBQUsvbUMsS0FBS2duQyxTQUFTLEdBQUdGLFdBQVdHLGFBQWEsR0FBR0g7SUFDN0U7SUFDQSxDQUFDSSxvQkFBb0IsQ0FBQ0MsU0FBUztRQUM3QixNQUFNLEVBQ0pDLFlBQVksRUFDYixHQUFHLElBQUk7UUFDUixJQUFJQSxhQUFhQyxZQUFZLENBQUNGLFlBQVk7WUFDeEMsT0FBT0M7UUFDVDtRQUNBLEtBQUssTUFBTXRFLFNBQVMsSUFBSSxDQUFDLENBQUNyRixTQUFTLENBQUNuaUMsTUFBTSxHQUFJO1lBQzVDLElBQUl3bkMsTUFBTXVFLFlBQVksQ0FBQ0YsWUFBWTtnQkFDakMsT0FBT3JFO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBbEwsbUJBQW1CMFAsbUJBQW1CLEVBQUUsRUFBRXRULFVBQVUsS0FBSyxFQUFFO1FBQ3pELE1BQU11VCxZQUFZaGxELFNBQVNpbEQsWUFBWTtRQUN2QyxJQUFJLENBQUNELGFBQWFBLFVBQVVFLFdBQVcsRUFBRTtZQUN2QztRQUNGO1FBQ0EsTUFBTSxFQUNKWCxVQUFVLEVBQ1ZZLFlBQVksRUFDWkMsU0FBUyxFQUNUQyxXQUFXLEVBQ1osR0FBR0w7UUFDSixNQUFNdm1DLE9BQU91bUMsVUFBVXB2RCxRQUFRO1FBQy9CLE1BQU0wdkQsZ0JBQWdCLElBQUksQ0FBQyxDQUFDaEIsNEJBQTRCLENBQUNVO1FBQ3pELE1BQU1KLFlBQVlVLGNBQWNDLE9BQU8sQ0FBQztRQUN4QyxNQUFNaFEsUUFBUSxJQUFJLENBQUNpUSxpQkFBaUIsQ0FBQ1o7UUFDckMsSUFBSSxDQUFDclAsT0FBTztZQUNWO1FBQ0Y7UUFDQXlQLFVBQVVTLEtBQUs7UUFDZixNQUFNbEYsUUFBUSxJQUFJLENBQUMsQ0FBQ29FLG9CQUFvQixDQUFDQztRQUN6QyxNQUFNYyxhQUFhLElBQUksQ0FBQyxDQUFDdnNDLElBQUksS0FBSzhNLHFCQUFxQkMsSUFBSTtRQUMzRCxNQUFNN1YsV0FBVztZQUNmLE1BQU1paEMsU0FBU2lQLE9BQU9vRixzQkFBc0I7Z0JBQzFDL3NELEdBQUc7Z0JBQ0gwTSxHQUFHO1lBQ0wsR0FBRyxPQUFPO2dCQUNSeS9DO2dCQUNBeFA7Z0JBQ0FnUDtnQkFDQVk7Z0JBQ0FDO2dCQUNBQztnQkFDQTVtQztZQUNGO1lBQ0EsSUFBSWluQyxZQUFZO2dCQUNkLElBQUksQ0FBQ0UsY0FBYyxDQUFDLGFBQWEsTUFBTTtZQUN6QztZQUNBLElBQUluVSxTQUFTO2dCQUNYSCxRQUFReVE7WUFDVjtRQUNGO1FBQ0EsSUFBSTJELFlBQVk7WUFDZCxJQUFJLENBQUNuQyxZQUFZLENBQUN0OUIscUJBQXFCRyxTQUFTLEVBQUUvVjtZQUNsRDtRQUNGO1FBQ0FBO0lBQ0Y7SUFDQStrQyxpQkFBaUIyUCxtQkFBbUIsRUFBRSxFQUFFO1FBQ3RDLElBQUksQ0FBQzFQLGtCQUFrQixDQUFDMFAsa0JBQWtCO0lBQzVDO0lBQ0EsQ0FBQ2Msc0JBQXNCO1FBQ3JCLE1BQU1iLFlBQVlobEQsU0FBU2lsRCxZQUFZO1FBQ3ZDLElBQUksQ0FBQ0QsYUFBYUEsVUFBVUUsV0FBVyxFQUFFO1lBQ3ZDO1FBQ0Y7UUFDQSxNQUFNSSxnQkFBZ0IsSUFBSSxDQUFDLENBQUNoQiw0QkFBNEIsQ0FBQ1U7UUFDekQsTUFBTUosWUFBWVUsY0FBY0MsT0FBTyxDQUFDO1FBQ3hDLE1BQU1oUSxRQUFRLElBQUksQ0FBQ2lRLGlCQUFpQixDQUFDWjtRQUNyQyxJQUFJLENBQUNyUCxPQUFPO1lBQ1Y7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDK0csZUFBZSxLQUFLLElBQUl0SCxnQkFBZ0IsSUFBSTtRQUNsRCxJQUFJLENBQUMsQ0FBQ3NILGVBQWUsQ0FBQ25KLElBQUksQ0FBQ3lSLFdBQVdyUCxPQUFPLElBQUksQ0FBQzlDLFNBQVMsS0FBSztJQUNsRTtJQUNBcVQsc0NBQXNDQyxZQUFZLEVBQUU7UUFDbEQsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDamlCLGlCQUFpQixFQUFFO1lBQzVCLE9BQU87UUFDVDtRQUNBLE1BQU16bUMsTUFBTSxDQUFDLEVBQUUyb0IsdUJBQXVCLEVBQUUrL0IsYUFBYSxDQUFDO1FBQ3RELE1BQU1DLGNBQWMsSUFBSSxDQUFDLENBQUNsaUIsaUJBQWlCLENBQUNtaUIsV0FBVyxDQUFDNW9EO1FBQ3hELElBQUkyb0QsYUFBYTtZQUNmLElBQUksQ0FBQyxDQUFDbGlCLGlCQUFpQixDQUFDejhCLE1BQU0sQ0FBQ2hLO1FBQ2pDO1FBQ0EsT0FBTzJvRDtJQUNUO0lBQ0FFLHVCQUF1QjVVLE1BQU0sRUFBRTtRQUM3QixJQUFJLENBQUNBLE9BQU82TixPQUFPLE1BQU0sSUFBSSxDQUFDLENBQUNyYixpQkFBaUIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDQSxpQkFBaUIsQ0FBQ3JwQyxHQUFHLENBQUM2MkMsT0FBTzFxQyxFQUFFLEdBQUc7WUFDM0YsSUFBSSxDQUFDLENBQUNrOUIsaUJBQWlCLENBQUNwQixRQUFRLENBQUM0TyxPQUFPMXFDLEVBQUUsRUFBRTBxQztRQUM5QztJQUNGO0lBQ0E2VSxVQUFVQyxTQUFTLEVBQUVscUQsT0FBTyxJQUFJLEVBQUU7UUFDaEMsTUFBTXVoRCxjQUFjLElBQUksQ0FBQyxDQUFDQSxXQUFXO1FBQ3JDLElBQUksQ0FBQ0EsYUFBYTtZQUNoQjtRQUNGO1FBQ0FBLFlBQVk3YSxZQUFZLENBQUMsZ0JBQWdCd2pCO1FBQ3pDLElBQUlscUQsTUFBTTtZQUNSdWhELFlBQVk3YSxZQUFZLENBQUMsa0JBQWtCM21CLEtBQUtvcUMsU0FBUyxDQUFDbnFEO1FBQzVELE9BQU87WUFDTHVoRCxZQUFZM2EsZUFBZSxDQUFDO1FBQzlCO0lBQ0Y7SUFDQSxDQUFDd2pCLGVBQWU7UUFDZCxNQUFNdEIsWUFBWWhsRCxTQUFTaWxELFlBQVk7UUFDdkMsSUFBSSxDQUFDRCxhQUFhQSxVQUFVRSxXQUFXLEVBQUU7WUFDdkMsSUFBSSxJQUFJLENBQUMsQ0FBQ2pJLGdCQUFnQixFQUFFO2dCQUMxQixJQUFJLENBQUMsQ0FBQ1gsZUFBZSxFQUFFcko7Z0JBQ3ZCLElBQUksQ0FBQyxDQUFDZ0ssZ0JBQWdCLEdBQUc7Z0JBQ3pCLElBQUksQ0FBQyxDQUFDc0osb0JBQW9CLENBQUM7b0JBQ3pCbEgsaUJBQWlCO2dCQUNuQjtZQUNGO1lBQ0E7UUFDRjtRQUNBLE1BQU0sRUFDSmtGLFVBQVUsRUFDWCxHQUFHUztRQUNKLElBQUlULGVBQWUsSUFBSSxDQUFDLENBQUN0SCxnQkFBZ0IsRUFBRTtZQUN6QztRQUNGO1FBQ0EsTUFBTXFJLGdCQUFnQixJQUFJLENBQUMsQ0FBQ2hCLDRCQUE0QixDQUFDVTtRQUN6RCxNQUFNSixZQUFZVSxjQUFjQyxPQUFPLENBQUM7UUFDeEMsSUFBSSxDQUFDWCxXQUFXO1lBQ2QsSUFBSSxJQUFJLENBQUMsQ0FBQzNILGdCQUFnQixFQUFFO2dCQUMxQixJQUFJLENBQUMsQ0FBQ1gsZUFBZSxFQUFFcko7Z0JBQ3ZCLElBQUksQ0FBQyxDQUFDZ0ssZ0JBQWdCLEdBQUc7Z0JBQ3pCLElBQUksQ0FBQyxDQUFDc0osb0JBQW9CLENBQUM7b0JBQ3pCbEgsaUJBQWlCO2dCQUNuQjtZQUNGO1lBQ0E7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDL0MsZUFBZSxFQUFFcko7UUFDdkIsSUFBSSxDQUFDLENBQUNnSyxnQkFBZ0IsR0FBR3NIO1FBQ3pCLElBQUksQ0FBQyxDQUFDZ0Msb0JBQW9CLENBQUM7WUFDekJsSCxpQkFBaUI7UUFDbkI7UUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDbG1DLElBQUksS0FBSzhNLHFCQUFxQkcsU0FBUyxJQUFJLElBQUksQ0FBQyxDQUFDak4sSUFBSSxLQUFLOE0scUJBQXFCQyxJQUFJLEVBQUU7WUFDN0Y7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDLENBQUMvTSxJQUFJLEtBQUs4TSxxQkFBcUJHLFNBQVMsRUFBRTtZQUNqRCxJQUFJLENBQUN3L0IsY0FBYyxDQUFDLGFBQWEsTUFBTTtRQUN6QztRQUNBLElBQUksQ0FBQyxDQUFDdkosb0JBQW9CLEdBQUcsSUFBSSxDQUFDK0QsY0FBYztRQUNoRCxJQUFJLENBQUMsSUFBSSxDQUFDQSxjQUFjLEVBQUU7WUFDeEIsTUFBTW9HLGNBQWMsSUFBSSxDQUFDLENBQUNydEMsSUFBSSxLQUFLOE0scUJBQXFCRyxTQUFTLEdBQUcsSUFBSSxDQUFDLENBQUN1K0Isb0JBQW9CLENBQUNDLGFBQWE7WUFDNUc0QixhQUFhQztZQUNiLElBQUksSUFBSSxDQUFDLENBQUNoSyxhQUFhLEVBQUU7Z0JBQ3ZCLE1BQU0zYixLQUFLLElBQUlDO2dCQUNmLE1BQU1DLFNBQVMsSUFBSSxDQUFDeWYsY0FBYyxDQUFDM2Y7Z0JBQ25DLE1BQU00bEIsWUFBWWovQyxDQUFBQTtvQkFDaEIsSUFBSUEsRUFBRTdNLElBQUksS0FBSyxlQUFlNk0sRUFBRThyQyxNQUFNLEtBQUssR0FBRzt3QkFDNUM7b0JBQ0Y7b0JBQ0F6UyxHQUFHSSxLQUFLO29CQUNSc2xCLGFBQWFDLGNBQWM7b0JBQzNCLElBQUloL0MsRUFBRTdNLElBQUksS0FBSyxhQUFhO3dCQUMxQixJQUFJLENBQUMsQ0FBQytyRCxXQUFXLENBQUM7b0JBQ3BCO2dCQUNGO2dCQUNBbDlDLE9BQU8yM0IsZ0JBQWdCLENBQUMsYUFBYXNsQixXQUFXO29CQUM5QzFsQjtnQkFDRjtnQkFDQXYzQixPQUFPMjNCLGdCQUFnQixDQUFDLFFBQVFzbEIsV0FBVztvQkFDekMxbEI7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMd2xCLGFBQWFDLGNBQWM7Z0JBQzNCLElBQUksQ0FBQyxDQUFDRSxXQUFXLENBQUM7WUFDcEI7UUFDRjtJQUNGO0lBQ0EsQ0FBQ0EsV0FBVyxDQUFDNUIsbUJBQW1CLEVBQUU7UUFDaEMsSUFBSSxJQUFJLENBQUMsQ0FBQzVyQyxJQUFJLEtBQUs4TSxxQkFBcUJHLFNBQVMsRUFBRTtZQUNqRCxJQUFJLENBQUNpdkIsa0JBQWtCLENBQUMwUDtRQUMxQixPQUFPLElBQUksSUFBSSxDQUFDLENBQUNqSiw2QkFBNkIsRUFBRTtZQUM5QyxJQUFJLENBQUMsQ0FBQytKLHNCQUFzQjtRQUM5QjtJQUNGO0lBQ0EsQ0FBQzlGLG9CQUFvQjtRQUNuQi8vQyxTQUFTb2hDLGdCQUFnQixDQUFDLG1CQUFtQixJQUFJLENBQUMsQ0FBQ2tsQixlQUFlLENBQUN0dUQsSUFBSSxDQUFDLElBQUksR0FBRztZQUM3RWdwQyxRQUFRLElBQUksQ0FBQ3FSLE9BQU87UUFDdEI7SUFDRjtJQUNBLENBQUN1VSxlQUFlO1FBQ2QsSUFBSSxJQUFJLENBQUMsQ0FBQ3pLLGNBQWMsRUFBRTtZQUN4QjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNBLGNBQWMsR0FBRyxJQUFJcGI7UUFDM0IsTUFBTUMsU0FBUyxJQUFJLENBQUN5ZixjQUFjLENBQUMsSUFBSSxDQUFDLENBQUN0RSxjQUFjO1FBQ3ZEMXlDLE9BQU8yM0IsZ0JBQWdCLENBQUMsU0FBUyxJQUFJLENBQUN3aUIsS0FBSyxDQUFDNXJELElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDdERncEM7UUFDRjtRQUNBdjNCLE9BQU8yM0IsZ0JBQWdCLENBQUMsUUFBUSxJQUFJLENBQUN5bEIsSUFBSSxDQUFDN3VELElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDcERncEM7UUFDRjtJQUNGO0lBQ0EsQ0FBQzhsQixrQkFBa0I7UUFDakIsSUFBSSxDQUFDLENBQUMzSyxjQUFjLEVBQUVqYjtRQUN0QixJQUFJLENBQUMsQ0FBQ2liLGNBQWMsR0FBRztJQUN6QjtJQUNBMEssT0FBTztRQUNMLElBQUksQ0FBQ3pHLGNBQWMsR0FBRztRQUN0QixJQUFJLElBQUksQ0FBQyxDQUFDL0Qsb0JBQW9CLEVBQUU7WUFDOUIsSUFBSSxDQUFDLENBQUNBLG9CQUFvQixHQUFHO1lBQzdCLElBQUksQ0FBQyxDQUFDc0ssV0FBVyxDQUFDO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ0ksWUFBWSxFQUFFO1lBQ3RCO1FBQ0Y7UUFDQSxNQUFNLEVBQ0ovSSxhQUFhLEVBQ2QsR0FBR2grQztRQUNKLEtBQUssTUFBTXN4QyxVQUFVLElBQUksQ0FBQyxDQUFDMEwsZUFBZSxDQUFFO1lBQzFDLElBQUkxTCxPQUFPbk4sR0FBRyxDQUFDNFosUUFBUSxDQUFDQyxnQkFBZ0I7Z0JBQ3RDLElBQUksQ0FBQyxDQUFDcEIsaUJBQWlCLEdBQUc7b0JBQUN0TDtvQkFBUTBNO2lCQUFjO2dCQUNqRDFNLE9BQU91QixtQkFBbUIsR0FBRztnQkFDN0I7WUFDRjtRQUNGO0lBQ0Y7SUFDQStRLFFBQVE7UUFDTixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNoSCxpQkFBaUIsRUFBRTtZQUM1QjtRQUNGO1FBQ0EsTUFBTSxDQUFDb0ssWUFBWXBLLGtCQUFrQixHQUFHLElBQUksQ0FBQyxDQUFDQSxpQkFBaUI7UUFDL0QsSUFBSSxDQUFDLENBQUNBLGlCQUFpQixHQUFHO1FBQzFCQSxrQkFBa0J4YixnQkFBZ0IsQ0FBQyxXQUFXO1lBQzVDNGxCLFdBQVduVSxtQkFBbUIsR0FBRztRQUNuQyxHQUFHO1lBQ0QyUSxNQUFNO1lBQ054aUIsUUFBUSxJQUFJLENBQUNxUixPQUFPO1FBQ3RCO1FBQ0F1SyxrQkFBa0JnSCxLQUFLO0lBQ3pCO0lBQ0EsQ0FBQzNELGtCQUFrQjtRQUNqQixJQUFJLElBQUksQ0FBQyxDQUFDdEQsaUJBQWlCLEVBQUU7WUFDM0I7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDQSxpQkFBaUIsR0FBRyxJQUFJNWI7UUFDOUIsTUFBTUMsU0FBUyxJQUFJLENBQUN5ZixjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM5RCxpQkFBaUI7UUFDMURsekMsT0FBTzIzQixnQkFBZ0IsQ0FBQyxXQUFXLElBQUksQ0FBQzZsQixPQUFPLENBQUNqdkQsSUFBSSxDQUFDLElBQUksR0FBRztZQUMxRGdwQztRQUNGO1FBQ0F2M0IsT0FBTzIzQixnQkFBZ0IsQ0FBQyxTQUFTLElBQUksQ0FBQzhsQixLQUFLLENBQUNsdkQsSUFBSSxDQUFDLElBQUksR0FBRztZQUN0RGdwQztRQUNGO0lBQ0Y7SUFDQSxDQUFDbW1CLHFCQUFxQjtRQUNwQixJQUFJLENBQUMsQ0FBQ3hLLGlCQUFpQixFQUFFemI7UUFDekIsSUFBSSxDQUFDLENBQUN5YixpQkFBaUIsR0FBRztJQUM1QjtJQUNBLENBQUN5SyxxQkFBcUI7UUFDcEIsSUFBSSxJQUFJLENBQUMsQ0FBQzdMLFdBQVcsRUFBRTtZQUNyQjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNBLFdBQVcsR0FBRyxJQUFJeGE7UUFDeEIsTUFBTUMsU0FBUyxJQUFJLENBQUN5ZixjQUFjLENBQUMsSUFBSSxDQUFDLENBQUNsRixXQUFXO1FBQ3BEdjdDLFNBQVNvaEMsZ0JBQWdCLENBQUMsUUFBUSxJQUFJLENBQUNpbUIsSUFBSSxDQUFDcnZELElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDdERncEM7UUFDRjtRQUNBaGhDLFNBQVNvaEMsZ0JBQWdCLENBQUMsT0FBTyxJQUFJLENBQUNrbUIsR0FBRyxDQUFDdHZELElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDcERncEM7UUFDRjtRQUNBaGhDLFNBQVNvaEMsZ0JBQWdCLENBQUMsU0FBUyxJQUFJLENBQUNtbUIsS0FBSyxDQUFDdnZELElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDeERncEM7UUFDRjtJQUNGO0lBQ0EsQ0FBQ3dtQix3QkFBd0I7UUFDdkIsSUFBSSxDQUFDLENBQUNqTSxXQUFXLEVBQUVyYTtRQUNuQixJQUFJLENBQUMsQ0FBQ3FhLFdBQVcsR0FBRztJQUN0QjtJQUNBLENBQUN5RSx1QkFBdUI7UUFDdEIsTUFBTWhmLFNBQVMsSUFBSSxDQUFDcVIsT0FBTztRQUMzQnJ5QyxTQUFTb2hDLGdCQUFnQixDQUFDLFlBQVksSUFBSSxDQUFDcW1CLFFBQVEsQ0FBQ3p2RCxJQUFJLENBQUMsSUFBSSxHQUFHO1lBQzlEZ3BDO1FBQ0Y7UUFDQWhoQyxTQUFTb2hDLGdCQUFnQixDQUFDLFFBQVEsSUFBSSxDQUFDNWdCLElBQUksQ0FBQ3hvQixJQUFJLENBQUMsSUFBSSxHQUFHO1lBQ3REZ3BDO1FBQ0Y7SUFDRjtJQUNBMG1CLG1CQUFtQjtRQUNqQixJQUFJLENBQUMsQ0FBQ3pILGtCQUFrQjtRQUN4QixJQUFJLENBQUMsQ0FBQ21ILHFCQUFxQjtJQUM3QjtJQUNBTyxzQkFBc0I7UUFDcEIsSUFBSSxDQUFDLENBQUNSLHFCQUFxQjtRQUMzQixJQUFJLENBQUMsQ0FBQ0ssd0JBQXdCO0lBQ2hDO0lBQ0FDLFNBQVNobEIsS0FBSyxFQUFFO1FBQ2QsS0FBSyxNQUFNLEVBQ1Q3bkMsSUFBSSxFQUNMLElBQUk2bkMsTUFBTW1sQixZQUFZLENBQUNsaUQsS0FBSyxDQUFFO1lBQzdCLEtBQUssTUFBTTR0QyxjQUFjLElBQUksQ0FBQyxDQUFDc0ksV0FBVyxDQUFFO2dCQUMxQyxJQUFJdEksV0FBV3VVLHdCQUF3QixDQUFDanRELE9BQU87b0JBQzdDNm5DLE1BQU1tbEIsWUFBWSxDQUFDRSxVQUFVLEdBQUc7b0JBQ2hDcmxCLE1BQU1tSCxjQUFjO29CQUNwQjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBcHBCLEtBQUtpaUIsS0FBSyxFQUFFO1FBQ1YsS0FBSyxNQUFNejVCLFFBQVF5NUIsTUFBTW1sQixZQUFZLENBQUNsaUQsS0FBSyxDQUFFO1lBQzNDLEtBQUssTUFBTTR0QyxjQUFjLElBQUksQ0FBQyxDQUFDc0ksV0FBVyxDQUFFO2dCQUMxQyxJQUFJdEksV0FBV3VVLHdCQUF3QixDQUFDNytDLEtBQUtwTyxJQUFJLEdBQUc7b0JBQ2xEMDRDLFdBQVdpVSxLQUFLLENBQUN2K0MsTUFBTSxJQUFJLENBQUM2N0MsWUFBWTtvQkFDeENwaUIsTUFBTW1ILGNBQWM7b0JBQ3BCO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBQ0F5ZCxLQUFLNWtCLEtBQUssRUFBRTtRQUNWQSxNQUFNbUgsY0FBYztRQUNwQixJQUFJLENBQUMsQ0FBQ21SLFlBQVksRUFBRXFKO1FBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMyQyxZQUFZLEVBQUU7WUFDdEI7UUFDRjtRQUNBLE1BQU1nQixVQUFVLEVBQUU7UUFDbEIsS0FBSyxNQUFNelcsVUFBVSxJQUFJLENBQUMsQ0FBQzBMLGVBQWUsQ0FBRTtZQUMxQyxNQUFNZ0wsYUFBYTFXLE9BQU8wSSxTQUFTLENBQUM7WUFDcEMsSUFBSWdPLFlBQVk7Z0JBQ2RELFFBQVE3cUQsSUFBSSxDQUFDOHFEO1lBQ2Y7UUFDRjtRQUNBLElBQUlELFFBQVE5MUQsTUFBTSxLQUFLLEdBQUc7WUFDeEI7UUFDRjtRQUNBd3dDLE1BQU13bEIsYUFBYSxDQUFDQyxPQUFPLENBQUMscUJBQXFCanNDLEtBQUtvcUMsU0FBUyxDQUFDMEI7SUFDbEU7SUFDQVQsSUFBSTdrQixLQUFLLEVBQUU7UUFDVCxJQUFJLENBQUM0a0IsSUFBSSxDQUFDNWtCO1FBQ1YsSUFBSSxDQUFDZ1IsTUFBTTtJQUNiO0lBQ0EsTUFBTThULE1BQU05a0IsS0FBSyxFQUFFO1FBQ2pCQSxNQUFNbUgsY0FBYztRQUNwQixNQUFNLEVBQ0pxZSxhQUFhLEVBQ2QsR0FBR3hsQjtRQUNKLEtBQUssTUFBTXo1QixRQUFRaS9DLGNBQWN2aUQsS0FBSyxDQUFFO1lBQ3RDLEtBQUssTUFBTTR0QyxjQUFjLElBQUksQ0FBQyxDQUFDc0ksV0FBVyxDQUFFO2dCQUMxQyxJQUFJdEksV0FBV3VVLHdCQUF3QixDQUFDNytDLEtBQUtwTyxJQUFJLEdBQUc7b0JBQ2xEMDRDLFdBQVdpVSxLQUFLLENBQUN2K0MsTUFBTSxJQUFJLENBQUM2N0MsWUFBWTtvQkFDeEM7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsSUFBSXJpRCxPQUFPeWxELGNBQWN6RixPQUFPLENBQUM7UUFDakMsSUFBSSxDQUFDaGdELE1BQU07WUFDVDtRQUNGO1FBQ0EsSUFBSTtZQUNGQSxPQUFPeVosS0FBS3RHLEtBQUssQ0FBQ25UO1FBQ3BCLEVBQUUsT0FBT283QixJQUFJO1lBQ1hwSixLQUFLLENBQUMsUUFBUSxFQUFFb0osR0FBR3JzQixPQUFPLENBQUMsRUFBRSxDQUFDO1lBQzlCO1FBQ0Y7UUFDQSxJQUFJLENBQUN2TixNQUFNK0YsT0FBTyxDQUFDdkgsT0FBTztZQUN4QjtRQUNGO1FBQ0EsSUFBSSxDQUFDbzhDLFdBQVc7UUFDaEIsTUFBTTJCLFFBQVEsSUFBSSxDQUFDc0UsWUFBWTtRQUMvQixJQUFJO1lBQ0YsTUFBTXNELGFBQWEsRUFBRTtZQUNyQixLQUFLLE1BQU03VyxVQUFVOXVDLEtBQU07Z0JBQ3pCLE1BQU00bEQscUJBQXFCLE1BQU03SCxNQUFNOEgsV0FBVyxDQUFDL1c7Z0JBQ25ELElBQUksQ0FBQzhXLG9CQUFvQjtvQkFDdkI7Z0JBQ0Y7Z0JBQ0FELFdBQVdqckQsSUFBSSxDQUFDa3JEO1lBQ2xCO1lBQ0EsTUFBTW5QLE1BQU07Z0JBQ1YsS0FBSyxNQUFNM0gsVUFBVTZXLFdBQVk7b0JBQy9CLElBQUksQ0FBQyxDQUFDRyxnQkFBZ0IsQ0FBQ2hYO2dCQUN6QjtnQkFDQSxJQUFJLENBQUMsQ0FBQ2lYLGFBQWEsQ0FBQ0o7WUFDdEI7WUFDQSxNQUFNalAsT0FBTztnQkFDWCxLQUFLLE1BQU01SCxVQUFVNlcsV0FBWTtvQkFDL0I3VyxPQUFPanFDLE1BQU07Z0JBQ2Y7WUFDRjtZQUNBLElBQUksQ0FBQ21oRCxXQUFXLENBQUM7Z0JBQ2Z2UDtnQkFDQUM7Z0JBQ0FFLFVBQVU7WUFDWjtRQUNGLEVBQUUsT0FBT3hiLElBQUk7WUFDWHBKLEtBQUssQ0FBQyxRQUFRLEVBQUVvSixHQUFHcnNCLE9BQU8sQ0FBQyxFQUFFLENBQUM7UUFDaEM7SUFDRjtJQUNBMDFDLFFBQVF4a0IsS0FBSyxFQUFFO1FBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQzJkLGNBQWMsSUFBSTNkLE1BQU1wbEMsR0FBRyxLQUFLLFNBQVM7WUFDakQsSUFBSSxDQUFDK2lELGNBQWMsR0FBRztRQUN4QjtRQUNBLElBQUksSUFBSSxDQUFDLENBQUNqbkMsSUFBSSxLQUFLOE0scUJBQXFCQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUN1aUMsd0JBQXdCLEVBQUU7WUFDOUU1TiwwQkFBMEJnRCxnQkFBZ0IsQ0FBQ2xrRCxJQUFJLENBQUMsSUFBSSxFQUFFOG9DO1FBQ3hEO0lBQ0Y7SUFDQXlrQixNQUFNemtCLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxDQUFDMmQsY0FBYyxJQUFJM2QsTUFBTXBsQyxHQUFHLEtBQUssU0FBUztZQUNoRCxJQUFJLENBQUMraUQsY0FBYyxHQUFHO1lBQ3RCLElBQUksSUFBSSxDQUFDLENBQUMvRCxvQkFBb0IsRUFBRTtnQkFDOUIsSUFBSSxDQUFDLENBQUNBLG9CQUFvQixHQUFHO2dCQUM3QixJQUFJLENBQUMsQ0FBQ3NLLFdBQVcsQ0FBQztZQUNwQjtRQUNGO0lBQ0Y7SUFDQW5ILGdCQUFnQixFQUNkenFELElBQUksRUFDTCxFQUFFO1FBQ0QsT0FBUUE7WUFDTixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNILElBQUksQ0FBQ0EsS0FBSztnQkFDVjtZQUNGLEtBQUs7Z0JBQ0gsSUFBSSxDQUFDc2dELGtCQUFrQixDQUFDO2dCQUN4QjtZQUNGLEtBQUs7Z0JBQ0gsSUFBSSxDQUFDRCxnQkFBZ0IsQ0FBQztnQkFDdEI7UUFDSjtJQUNGO0lBQ0EsQ0FBQ21SLG9CQUFvQixDQUFDdndCLE9BQU87UUFDM0IsTUFBTTB5QixhQUFhcDBELE9BQU84WCxPQUFPLENBQUM0cEIsU0FBU251QixJQUFJLENBQUMsQ0FBQyxDQUFDeEssS0FBS25LLE1BQU0sR0FBSyxJQUFJLENBQUMsQ0FBQ21xRCxjQUFjLENBQUNoZ0QsSUFBSSxLQUFLbks7UUFDaEcsSUFBSXcxRCxZQUFZO1lBQ2QsSUFBSSxDQUFDcEosU0FBUyxDQUFDbUUsUUFBUSxDQUFDLGlDQUFpQztnQkFDdkQvdEQsUUFBUSxJQUFJO2dCQUNac2dDLFNBQVMxaEMsT0FBT2t2QyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM2WixjQUFjLEVBQUVybkI7WUFDL0M7WUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDN2MsSUFBSSxLQUFLOE0scUJBQXFCRyxTQUFTLElBQUk0UCxRQUFRb3BCLGlCQUFpQixLQUFLLE9BQU87Z0JBQ3hGLElBQUksQ0FBQyxDQUFDdUosZ0JBQWdCLENBQUM7b0JBQUM7d0JBQUNqaUMsMkJBQTJCVyxjQUFjO3dCQUFFO3FCQUFLO2lCQUFDO1lBQzVFO1FBQ0Y7SUFDRjtJQUNBLENBQUNzaEMsZ0JBQWdCLENBQUMzeUIsT0FBTztRQUN2QixJQUFJLENBQUNzcEIsU0FBUyxDQUFDbUUsUUFBUSxDQUFDLGlDQUFpQztZQUN2RC90RCxRQUFRLElBQUk7WUFDWnNnQztRQUNGO0lBQ0Y7SUFDQTR5QixnQkFBZ0IxSixTQUFTLEVBQUU7UUFDekIsSUFBSUEsV0FBVztZQUNiLElBQUksQ0FBQyxDQUFDMEgsZUFBZTtZQUNyQixJQUFJLENBQUMsQ0FBQ1EscUJBQXFCO1lBQzNCLElBQUksQ0FBQyxDQUFDYixvQkFBb0IsQ0FBQztnQkFDekJySCxXQUFXLElBQUksQ0FBQyxDQUFDL2xDLElBQUksS0FBSzhNLHFCQUFxQkMsSUFBSTtnQkFDbkRpNUIsU0FBUyxJQUFJLENBQUMsQ0FBQ0EsT0FBTztnQkFDdEIxRixvQkFBb0IsSUFBSSxDQUFDLENBQUM0QixjQUFjLENBQUM1QixrQkFBa0I7Z0JBQzNEQyxvQkFBb0IsSUFBSSxDQUFDLENBQUMyQixjQUFjLENBQUMzQixrQkFBa0I7Z0JBQzNEMEYsbUJBQW1CO1lBQ3JCO1FBQ0YsT0FBTztZQUNMLElBQUksQ0FBQyxDQUFDMEgsa0JBQWtCO1lBQ3hCLElBQUksQ0FBQyxDQUFDVSx3QkFBd0I7WUFDOUIsSUFBSSxDQUFDLENBQUNqQixvQkFBb0IsQ0FBQztnQkFDekJySCxXQUFXO1lBQ2I7WUFDQSxJQUFJLENBQUN5QyxpQkFBaUIsQ0FBQztRQUN6QjtJQUNGO0lBQ0FrSCxvQkFBb0JDLEtBQUssRUFBRTtRQUN6QixJQUFJLElBQUksQ0FBQyxDQUFDbE4sV0FBVyxFQUFFO1lBQ3JCO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQ0EsV0FBVyxHQUFHa047UUFDcEIsS0FBSyxNQUFNeFYsY0FBYyxJQUFJLENBQUMsQ0FBQ3NJLFdBQVcsQ0FBRTtZQUMxQyxJQUFJLENBQUMsQ0FBQytNLGdCQUFnQixDQUFDclYsV0FBV3lWLHlCQUF5QjtRQUM3RDtJQUNGO0lBQ0FDLFFBQVE7UUFDTixPQUFPLElBQUksQ0FBQyxDQUFDek0sU0FBUyxDQUFDMzFDLEVBQUU7SUFDM0I7SUFDQSxJQUFJaStDLGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUMsQ0FBQzNKLFNBQVMsQ0FBQ2huRCxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUN1bkQsZ0JBQWdCO0lBQ25EO0lBQ0F3TixTQUFTN0csU0FBUyxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLENBQUNsSCxTQUFTLENBQUNobkQsR0FBRyxDQUFDa3VEO0lBQzdCO0lBQ0EsSUFBSTNHLG1CQUFtQjtRQUNyQixPQUFPLElBQUksQ0FBQyxDQUFDQSxnQkFBZ0I7SUFDL0I7SUFDQXlOLFNBQVMzSSxLQUFLLEVBQUU7UUFDZCxJQUFJLENBQUMsQ0FBQ3JGLFNBQVMsQ0FBQzFnRCxHQUFHLENBQUMrbEQsTUFBTTZCLFNBQVMsRUFBRTdCO1FBQ3JDLElBQUksSUFBSSxDQUFDLENBQUMvRCxTQUFTLEVBQUU7WUFDbkIrRCxNQUFNNEksTUFBTTtRQUNkLE9BQU87WUFDTDVJLE1BQU02SSxPQUFPO1FBQ2Y7SUFDRjtJQUNBQyxZQUFZOUksS0FBSyxFQUFFO1FBQ2pCLElBQUksQ0FBQyxDQUFDckYsU0FBUyxDQUFDekgsTUFBTSxDQUFDOE0sTUFBTTZCLFNBQVM7SUFDeEM7SUFDQSxNQUFNa0gsV0FBV253QyxJQUFJLEVBQUVvd0MsU0FBUyxJQUFJLEVBQUVDLGlCQUFpQixLQUFLLEVBQUVDLHNCQUFzQixLQUFLLEVBQUUxSCxjQUFjLEtBQUssRUFBRTtRQUM5RyxJQUFJLElBQUksQ0FBQyxDQUFDNW9DLElBQUksS0FBS0EsTUFBTTtZQUN2QjtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUMsQ0FBQ3VrQyxvQkFBb0IsRUFBRTtZQUM5QixNQUFNLElBQUksQ0FBQyxDQUFDQSxvQkFBb0IsQ0FBQ25oRCxPQUFPO1lBQ3hDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ21oRCxvQkFBb0IsRUFBRTtnQkFDL0I7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNBLG9CQUFvQixHQUFHNWhELFFBQVErUSxhQUFhO1FBQ2xELElBQUksQ0FBQyxDQUFDMnVDLHFCQUFxQixFQUFFNEk7UUFDN0IsSUFBSSxJQUFJLENBQUMsQ0FBQ2pyQyxJQUFJLEtBQUs4TSxxQkFBcUJNLEtBQUssRUFBRTtZQUM3QyxJQUFJLENBQUMsQ0FBQyswQixjQUFjLEVBQUVvTztRQUN4QjtRQUNBLElBQUksQ0FBQyxDQUFDcE8sY0FBYyxFQUFFcU87UUFDdEIsSUFBSSxDQUFDLENBQUN4d0MsSUFBSSxHQUFHQTtRQUNiLElBQUlBLFNBQVM4TSxxQkFBcUJDLElBQUksRUFBRTtZQUN0QyxJQUFJLENBQUMwaUMsZUFBZSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxDQUFDZ0IsVUFBVTtZQUNoQixLQUFLLE1BQU10WSxVQUFVLElBQUksQ0FBQyxDQUFDMkosVUFBVSxDQUFDbGlDLE1BQU0sR0FBSTtnQkFDOUN1NEIsT0FBT3VZLDJCQUEyQjtZQUNwQztZQUNBLElBQUksQ0FBQzVLLGNBQWMsRUFBRWhNO1lBQ3JCLElBQUksQ0FBQ3FQLGFBQWEsQ0FBQztZQUNuQixJQUFJLENBQUMsQ0FBQzVFLG9CQUFvQixDQUFDcGhELE9BQU87WUFDbEM7UUFDRjtRQUNBLEtBQUssTUFBTWcxQyxVQUFVLElBQUksQ0FBQyxDQUFDMkosVUFBVSxDQUFDbGlDLE1BQU0sR0FBSTtZQUM5Q3U0QixPQUFPd1ksMEJBQTBCO1FBQ25DO1FBQ0EsSUFBSTN3QyxTQUFTOE0scUJBQXFCTyxTQUFTLEVBQUU7WUFDM0MsTUFBTSxJQUFJLENBQUMsQ0FBQzJ0QixnQkFBZ0IsRUFBRTRWO1FBQ2hDO1FBQ0EsSUFBSSxDQUFDbkIsZUFBZSxDQUFDO1FBQ3JCLE1BQU0sSUFBSSxDQUFDLENBQUNvQixTQUFTO1FBQ3JCLElBQUksQ0FBQ3BMLFdBQVc7UUFDaEIsS0FBSyxNQUFNMkIsU0FBUyxJQUFJLENBQUMsQ0FBQ3JGLFNBQVMsQ0FBQ25pQyxNQUFNLEdBQUk7WUFDNUN3bkMsTUFBTStJLFVBQVUsQ0FBQ253QztRQUNuQjtRQUNBLElBQUlBLFNBQVM4TSxxQkFBcUJNLEtBQUssRUFBRTtZQUN2QyxJQUFJLENBQUMsQ0FBQ3kwQixzQkFBc0IsS0FBSyxNQUFNLElBQUksQ0FBQyxDQUFDb0MsV0FBVyxDQUFDNk0sb0JBQW9CLENBQUMsSUFBSWhnRCxJQUFJLElBQUksQ0FBQyxDQUFDMnhDLFdBQVcsQ0FBQzkrQyxHQUFHLENBQUNvdEQsQ0FBQUEsY0FBZUEsWUFBWUMsV0FBVztZQUNsSixNQUFNQyxhQUFhLElBQUluZ0Q7WUFDdkIsTUFBTW9nRCxjQUFjLEVBQUU7WUFDdEIsS0FBSyxNQUFNL1ksVUFBVSxJQUFJLENBQUMsQ0FBQzJKLFVBQVUsQ0FBQ2xpQyxNQUFNLEdBQUk7Z0JBQzlDLE1BQU0sRUFDSnV4QyxtQkFBbUIsRUFDbkJDLFVBQVUsRUFDVkMsT0FBTyxFQUNSLEdBQUdsWjtnQkFDSixJQUFJZ1oscUJBQXFCO29CQUN2QkYsV0FBV3RpRCxHQUFHLENBQUN3aUQ7Z0JBQ2pCO2dCQUNBLElBQUlDLGNBQWMsQ0FBQ0MsU0FBUztvQkFDMUJILFlBQVludEQsSUFBSSxDQUFDbzBDLE9BQU9rUixPQUFPO2dCQUNqQztZQUNGO1lBQ0EsS0FBSyxNQUFNaUksY0FBYyxJQUFJLENBQUMsQ0FBQ3pQLHNCQUFzQixDQUFFO2dCQUNyRCxNQUFNLEVBQ0pwMEMsRUFBRSxFQUNGOGpELFFBQVEsRUFDUkMsV0FBVyxFQUNaLEdBQUdGO2dCQUNKLElBQUlDLFlBQVlDLGFBQWE5ekIsT0FBTyxDQUFDdXpCLFdBQVczdkQsR0FBRyxDQUFDbU0sT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDODBDLDRCQUE0QixDQUFDamhELEdBQUcsQ0FBQ21NLEtBQUs7b0JBQ3RHeWpELFlBQVludEQsSUFBSSxDQUFDdXREO2dCQUNuQjtZQUNGO1lBQ0EsSUFBSSxDQUFDLENBQUNuUCxjQUFjLEVBQUVzUCxZQUFZUDtRQUNwQztRQUNBLElBQUksQ0FBQ2QsUUFBUTtZQUNYLElBQUlDLGdCQUFnQjtnQkFDbEIsSUFBSSxDQUFDL0ssd0JBQXdCO1lBQy9CO1lBQ0EsSUFBSSxDQUFDLENBQUNmLG9CQUFvQixDQUFDcGhELE9BQU87WUFDbEM7UUFDRjtRQUNBLEtBQUssTUFBTWcxQyxVQUFVLElBQUksQ0FBQyxDQUFDMkosVUFBVSxDQUFDbGlDLE1BQU0sR0FBSTtZQUM5QyxJQUFJdTRCLE9BQU92a0MsR0FBRyxLQUFLdzhDLFFBQVE7Z0JBQ3pCLElBQUksQ0FBQ3NCLFdBQVcsQ0FBQ3ZaO2dCQUNqQixJQUFJeVEsYUFBYTtvQkFDZnpRLE9BQU95USxXQUFXO2dCQUNwQixPQUFPLElBQUkwSCxxQkFBcUI7b0JBQzlCblksT0FBT3daLGVBQWU7Z0JBQ3hCLE9BQU87b0JBQ0x4WixPQUFPc1MsS0FBSztnQkFDZDtZQUNGLE9BQU87Z0JBQ0x0UyxPQUFPeVosUUFBUTtZQUNqQjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNyTixvQkFBb0IsQ0FBQ3BoRCxPQUFPO0lBQ3BDO0lBQ0FtaUQsMkJBQTJCO1FBQ3pCLElBQUksSUFBSSxDQUFDb0csWUFBWSxDQUFDbUcsdUJBQXVCLElBQUk7WUFDL0MsSUFBSSxDQUFDbkcsWUFBWSxDQUFDb0csWUFBWTtRQUNoQztJQUNGO0lBQ0FDLGNBQWNsMkQsT0FBTyxFQUFFO1FBQ3JCLElBQUlBLFFBQVFta0IsSUFBSSxLQUFLLElBQUksQ0FBQyxDQUFDQSxJQUFJLEVBQUU7WUFDL0I7UUFDRjtRQUNBLElBQUksQ0FBQ21tQyxTQUFTLENBQUNtRSxRQUFRLENBQUMsOEJBQThCO1lBQ3BEL3RELFFBQVEsSUFBSTtZQUNaLEdBQUdWLE9BQU87UUFDWjtJQUNGO0lBQ0E4cUQsYUFBYWxsRCxJQUFJLEVBQUUxSCxLQUFLLEVBQUU7UUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDMG9ELFdBQVcsRUFBRTtZQUN0QjtRQUNGO1FBQ0EsT0FBUWhoRDtZQUNOLEtBQUs4ckIsMkJBQTJCRSxNQUFNO2dCQUNwQyxJQUFJLENBQUNpK0IsWUFBWSxDQUFDb0csWUFBWSxDQUFDLzNEO2dCQUMvQjtZQUNGLEtBQUt3ekIsMkJBQTJCWSxrQkFBa0I7Z0JBQ2hELElBQUksQ0FBQ2c0QixTQUFTLENBQUNtRSxRQUFRLENBQUMsbUJBQW1CO29CQUN6Qy90RCxRQUFRLElBQUk7b0JBQ1pzZ0MsU0FBUzt3QkFDUHA3QixNQUFNO3dCQUNONEgsTUFBTTs0QkFDSjVILE1BQU07NEJBQ051d0QsUUFBUTt3QkFDVjtvQkFDRjtnQkFDRjtnQkFDQyxLQUFJLENBQUMsQ0FBQ2hPLGFBQWEsS0FBSyxJQUFJaGUsS0FBSSxFQUFHM2tDLEdBQUcsQ0FBQ0ksTUFBTTFIO2dCQUM5QyxJQUFJLENBQUMweUQsY0FBYyxDQUFDLGFBQWExeUQ7Z0JBQ2pDO1FBQ0o7UUFDQSxJQUFJLElBQUksQ0FBQzZ6RCxZQUFZLEVBQUU7WUFDckIsS0FBSyxNQUFNelYsVUFBVSxJQUFJLENBQUMsQ0FBQzBMLGVBQWUsQ0FBRTtnQkFDMUMxTCxPQUFPd08sWUFBWSxDQUFDbGxELE1BQU0xSDtZQUM1QjtRQUNGLE9BQU87WUFDTCxLQUFLLE1BQU1vZ0QsY0FBYyxJQUFJLENBQUMsQ0FBQ3NJLFdBQVcsQ0FBRTtnQkFDMUN0SSxXQUFXOFgsbUJBQW1CLENBQUN4d0QsTUFBTTFIO1lBQ3ZDO1FBQ0Y7SUFDRjtJQUNBMHlELGVBQWVockQsSUFBSSxFQUFFeXdELE9BQU8sRUFBRUMsZUFBZSxLQUFLLEVBQUU7UUFDbEQsS0FBSyxNQUFNaGEsVUFBVSxJQUFJLENBQUMsQ0FBQzJKLFVBQVUsQ0FBQ2xpQyxNQUFNLEdBQUk7WUFDOUMsSUFBSXU0QixPQUFPZ0MsVUFBVSxLQUFLMTRDLE1BQU07Z0JBQzlCMDJDLE9BQU82QixJQUFJLENBQUNrWTtZQUNkO1FBQ0Y7UUFDQSxNQUFNNTFELFFBQVEsSUFBSSxDQUFDLENBQUMwbkQsYUFBYSxFQUFFanBELElBQUl3eUIsMkJBQTJCWSxrQkFBa0IsS0FBSztRQUN6RixJQUFJN3hCLFVBQVU0MUQsU0FBUztZQUNyQixJQUFJLENBQUMsQ0FBQzFDLGdCQUFnQixDQUFDO2dCQUFDO29CQUFDamlDLDJCQUEyQlksa0JBQWtCO29CQUFFK2pDO2lCQUFRO2FBQUM7UUFDbkY7SUFDRjtJQUNBRSxjQUFjQyxXQUFXLEtBQUssRUFBRTtRQUM5QixJQUFJLElBQUksQ0FBQyxDQUFDOU8sU0FBUyxLQUFLOE8sVUFBVTtZQUNoQztRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUM5TyxTQUFTLEdBQUc4TztRQUNsQixLQUFLLE1BQU1qTCxTQUFTLElBQUksQ0FBQyxDQUFDckYsU0FBUyxDQUFDbmlDLE1BQU0sR0FBSTtZQUM1QyxJQUFJeXlDLFVBQVU7Z0JBQ1pqTCxNQUFNa0wsWUFBWTtZQUNwQixPQUFPO2dCQUNMbEwsTUFBTW1MLFdBQVc7WUFDbkI7WUFDQW5MLE1BQU1wYyxHQUFHLENBQUMrSixTQUFTLENBQUMrVixNQUFNLENBQUMsV0FBV3VIO1FBQ3hDO0lBQ0Y7SUFDQSxNQUFNLENBQUN4QixTQUFTO1FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDeE4sU0FBUyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxDQUFDQSxTQUFTLEdBQUc7WUFDbEIsTUFBTW1QLFdBQVcsRUFBRTtZQUNuQixLQUFLLE1BQU1wTCxTQUFTLElBQUksQ0FBQyxDQUFDckYsU0FBUyxDQUFDbmlDLE1BQU0sR0FBSTtnQkFDNUM0eUMsU0FBU3p1RCxJQUFJLENBQUNxakQsTUFBTTRJLE1BQU07WUFDNUI7WUFDQSxNQUFNcnRELFFBQVF5VCxHQUFHLENBQUNvOEM7WUFDbEIsS0FBSyxNQUFNcmEsVUFBVSxJQUFJLENBQUMsQ0FBQzJKLFVBQVUsQ0FBQ2xpQyxNQUFNLEdBQUk7Z0JBQzlDdTRCLE9BQU82WCxNQUFNO1lBQ2Y7UUFDRjtJQUNGO0lBQ0EsQ0FBQ1MsVUFBVTtRQUNULElBQUksQ0FBQ2hMLFdBQVc7UUFDaEIsSUFBSSxJQUFJLENBQUMsQ0FBQ3BDLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUMsQ0FBQ0EsU0FBUyxHQUFHO1lBQ2xCLEtBQUssTUFBTStELFNBQVMsSUFBSSxDQUFDLENBQUNyRixTQUFTLENBQUNuaUMsTUFBTSxHQUFJO2dCQUM1Q3duQyxNQUFNNkksT0FBTztZQUNmO1lBQ0EsS0FBSyxNQUFNOVgsVUFBVSxJQUFJLENBQUMsQ0FBQzJKLFVBQVUsQ0FBQ2xpQyxNQUFNLEdBQUk7Z0JBQzlDdTRCLE9BQU84WCxPQUFPO1lBQ2hCO1FBQ0Y7SUFDRjtJQUNBLENBQUN3QyxXQUFXeEosU0FBUyxFQUFFO1FBQ3JCLEtBQUssTUFBTTlRLFVBQVUsSUFBSSxDQUFDLENBQUMySixVQUFVLENBQUNsaUMsTUFBTSxHQUFJO1lBQzlDLElBQUl1NEIsT0FBTzhRLFNBQVMsS0FBS0EsV0FBVztnQkFDbEMsTUFBTTlRO1lBQ1I7UUFDRjtJQUNGO0lBQ0F1YSxVQUFVamxELEVBQUUsRUFBRTtRQUNaLE9BQU8sSUFBSSxDQUFDLENBQUNxMEMsVUFBVSxDQUFDL21ELEdBQUcsQ0FBQzBTO0lBQzlCO0lBQ0FrbEQsVUFBVXhhLE1BQU0sRUFBRTtRQUNoQixJQUFJLENBQUMsQ0FBQzJKLFVBQVUsQ0FBQ3pnRCxHQUFHLENBQUM4MkMsT0FBTzFxQyxFQUFFLEVBQUUwcUM7SUFDbEM7SUFDQXlhLGFBQWF6YSxNQUFNLEVBQUU7UUFDbkIsSUFBSUEsT0FBT25OLEdBQUcsQ0FBQzRaLFFBQVEsQ0FBQy85QyxTQUFTZytDLGFBQWEsR0FBRztZQUMvQyxJQUFJLElBQUksQ0FBQyxDQUFDOUIsMkJBQTJCLEVBQUU7Z0JBQ3JDc0UsYUFBYSxJQUFJLENBQUMsQ0FBQ3RFLDJCQUEyQjtZQUNoRDtZQUNBLElBQUksQ0FBQyxDQUFDQSwyQkFBMkIsR0FBRzhQLFdBQVc7Z0JBQzdDLElBQUksQ0FBQ3JJLGtCQUFrQjtnQkFDdkIsSUFBSSxDQUFDLENBQUN6SCwyQkFBMkIsR0FBRztZQUN0QyxHQUFHO1FBQ0w7UUFDQSxJQUFJLENBQUMsQ0FBQ2pCLFVBQVUsQ0FBQ3hILE1BQU0sQ0FBQ25DLE9BQU8xcUMsRUFBRTtRQUNqQyxJQUFJMHFDLE9BQU9nWixtQkFBbUIsRUFBRTtZQUM5QixJQUFJLENBQUMsQ0FBQ3hOLGVBQWUsRUFBRXJKLE9BQU9uQyxPQUFPZ1osbUJBQW1CO1FBQzFEO1FBQ0EsSUFBSSxDQUFDUyxRQUFRLENBQUN6WjtRQUNkLElBQUksQ0FBQ0EsT0FBT2daLG1CQUFtQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM1Tyw0QkFBNEIsQ0FBQ2poRCxHQUFHLENBQUM2MkMsT0FBT2daLG1CQUFtQixHQUFHO1lBQ3RHLElBQUksQ0FBQyxDQUFDeG1CLGlCQUFpQixFQUFFejhCLE9BQU9pcUMsT0FBTzFxQyxFQUFFO1FBQzNDO0lBQ0Y7SUFDQXFsRCw0QkFBNEIzYSxNQUFNLEVBQUU7UUFDbEMsSUFBSSxDQUFDLENBQUNvSyw0QkFBNEIsQ0FBQzV6QyxHQUFHLENBQUN3cEMsT0FBT2daLG1CQUFtQjtRQUNqRSxJQUFJLENBQUM0Qiw0QkFBNEIsQ0FBQzVhO1FBQ2xDQSxPQUFPa1osT0FBTyxHQUFHO0lBQ25CO0lBQ0EyQiwyQkFBMkI3QixtQkFBbUIsRUFBRTtRQUM5QyxPQUFPLElBQUksQ0FBQyxDQUFDNU8sNEJBQTRCLENBQUNqaEQsR0FBRyxDQUFDNnZEO0lBQ2hEO0lBQ0E4QiwrQkFBK0I5YSxNQUFNLEVBQUU7UUFDckMsSUFBSSxDQUFDLENBQUNvSyw0QkFBNEIsQ0FBQ2pJLE1BQU0sQ0FBQ25DLE9BQU9nWixtQkFBbUI7UUFDcEUsSUFBSSxDQUFDK0IsK0JBQStCLENBQUMvYTtRQUNyQ0EsT0FBT2taLE9BQU8sR0FBRztJQUNuQjtJQUNBLENBQUNsQyxnQkFBZ0IsQ0FBQ2hYLE1BQU07UUFDdEIsTUFBTWlQLFFBQVEsSUFBSSxDQUFDLENBQUNyRixTQUFTLENBQUNobkQsR0FBRyxDQUFDbzlDLE9BQU84USxTQUFTO1FBQ2xELElBQUk3QixPQUFPO1lBQ1RBLE1BQU0rTCxZQUFZLENBQUNoYjtRQUNyQixPQUFPO1lBQ0wsSUFBSSxDQUFDd2EsU0FBUyxDQUFDeGE7WUFDZixJQUFJLENBQUM0VSxzQkFBc0IsQ0FBQzVVO1FBQzlCO0lBQ0Y7SUFDQWliLGdCQUFnQmpiLE1BQU0sRUFBRTtRQUN0QixJQUFJLElBQUksQ0FBQyxDQUFDeUosWUFBWSxLQUFLekosUUFBUTtZQUNqQztRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUN5SixZQUFZLEdBQUd6SjtRQUNyQixJQUFJQSxRQUFRO1lBQ1YsSUFBSSxDQUFDLENBQUNxWCxnQkFBZ0IsQ0FBQ3JYLE9BQU9rYixrQkFBa0I7UUFDbEQ7SUFDRjtJQUNBLElBQUksQ0FBQ0Msa0JBQWtCO1FBQ3JCLElBQUlDLEtBQUs7UUFDVCxLQUFLQSxNQUFNLElBQUksQ0FBQyxDQUFDMVAsZUFBZSxDQUFFLENBQUM7UUFDbkMsT0FBTzBQO0lBQ1Q7SUFDQUMsU0FBU3JiLE1BQU0sRUFBRTtRQUNmLElBQUksSUFBSSxDQUFDLENBQUNtYixrQkFBa0IsS0FBS25iLFFBQVE7WUFDdkMsSUFBSSxDQUFDLENBQUNxWCxnQkFBZ0IsQ0FBQ3JYLE9BQU9rYixrQkFBa0I7UUFDbEQ7SUFDRjtJQUNBSSw2QkFBNkJ0WixVQUFVLEVBQUU7UUFDdkMsSUFBSSxDQUFDLENBQUNxVixnQkFBZ0IsQ0FBQ3JWLFdBQVd5Vix5QkFBeUI7SUFDN0Q7SUFDQThELGVBQWV2YixNQUFNLEVBQUU7UUFDckIsSUFBSSxJQUFJLENBQUMsQ0FBQzBMLGVBQWUsQ0FBQ3ZpRCxHQUFHLENBQUM2MkMsU0FBUztZQUNyQyxJQUFJLENBQUMsQ0FBQzBMLGVBQWUsQ0FBQ3ZKLE1BQU0sQ0FBQ25DO1lBQzdCQSxPQUFPeVosUUFBUTtZQUNmLElBQUksQ0FBQyxDQUFDeEUsb0JBQW9CLENBQUM7Z0JBQ3pCbkgsbUJBQW1CLElBQUksQ0FBQzJILFlBQVk7WUFDdEM7WUFDQTtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUMvSixlQUFlLENBQUNsMUMsR0FBRyxDQUFDd3BDO1FBQzFCQSxPQUFPd2IsTUFBTTtRQUNiLElBQUksQ0FBQyxDQUFDbkUsZ0JBQWdCLENBQUNyWCxPQUFPa2Isa0JBQWtCO1FBQ2hELElBQUksQ0FBQyxDQUFDakcsb0JBQW9CLENBQUM7WUFDekJuSCxtQkFBbUI7UUFDckI7SUFDRjtJQUNBeUwsWUFBWXZaLE1BQU0sRUFBRTtRQUNsQixJQUFJLENBQUM0WixhQUFhLENBQUM7WUFDakIveEMsTUFBTW00QixPQUFPbjRCLElBQUk7WUFDakJvd0MsUUFBUWpZLE9BQU8xcUMsRUFBRTtRQUNuQjtRQUNBLElBQUksQ0FBQyxDQUFDNDBDLHFCQUFxQixFQUFFNEk7UUFDN0IsS0FBSyxNQUFNc0ksTUFBTSxJQUFJLENBQUMsQ0FBQzFQLGVBQWUsQ0FBRTtZQUN0QyxJQUFJMFAsT0FBT3BiLFFBQVE7Z0JBQ2pCb2IsR0FBRzNCLFFBQVE7WUFDYjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUMvTixlQUFlLENBQUN2akMsS0FBSztRQUMzQixJQUFJLENBQUMsQ0FBQ3VqQyxlQUFlLENBQUNsMUMsR0FBRyxDQUFDd3BDO1FBQzFCQSxPQUFPd2IsTUFBTTtRQUNiLElBQUksQ0FBQyxDQUFDbkUsZ0JBQWdCLENBQUNyWCxPQUFPa2Isa0JBQWtCO1FBQ2hELElBQUksQ0FBQyxDQUFDakcsb0JBQW9CLENBQUM7WUFDekJuSCxtQkFBbUI7UUFDckI7SUFDRjtJQUNBd0QsV0FBV3RSLE1BQU0sRUFBRTtRQUNqQixPQUFPLElBQUksQ0FBQyxDQUFDMEwsZUFBZSxDQUFDdmlELEdBQUcsQ0FBQzYyQztJQUNuQztJQUNBLElBQUl5YixzQkFBc0I7UUFDeEIsT0FBTyxJQUFJLENBQUMsQ0FBQy9QLGVBQWUsQ0FBQ2prQyxNQUFNLEdBQUc5aEIsSUFBSSxHQUFHL0QsS0FBSztJQUNwRDtJQUNBNjNELFNBQVN6WixNQUFNLEVBQUU7UUFDZkEsT0FBT3laLFFBQVE7UUFDZixJQUFJLENBQUMsQ0FBQy9OLGVBQWUsQ0FBQ3ZKLE1BQU0sQ0FBQ25DO1FBQzdCLElBQUksQ0FBQyxDQUFDaVYsb0JBQW9CLENBQUM7WUFDekJuSCxtQkFBbUIsSUFBSSxDQUFDMkgsWUFBWTtRQUN0QztJQUNGO0lBQ0EsSUFBSUEsZUFBZTtRQUNqQixPQUFPLElBQUksQ0FBQyxDQUFDL0osZUFBZSxDQUFDLzFDLElBQUksS0FBSztJQUN4QztJQUNBLElBQUkwM0MsaUJBQWlCO1FBQ25CLE9BQU8sSUFBSSxDQUFDLENBQUMzQixlQUFlLENBQUMvMUMsSUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDOGxELG1CQUFtQixDQUFDcE8sY0FBYztJQUNwRjtJQUNBekYsT0FBTztRQUNMLElBQUksQ0FBQyxDQUFDbUMsY0FBYyxDQUFDbkMsSUFBSTtRQUN6QixJQUFJLENBQUMsQ0FBQ3FOLG9CQUFvQixDQUFDO1lBQ3pCOU0sb0JBQW9CLElBQUksQ0FBQyxDQUFDNEIsY0FBYyxDQUFDNUIsa0JBQWtCO1lBQzNEQyxvQkFBb0I7WUFDcEJ5RixTQUFTLElBQUksQ0FBQyxDQUFDQSxPQUFPO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDRixjQUFjLEVBQUVoTTtJQUN2QjtJQUNBdUcsT0FBTztRQUNMLElBQUksQ0FBQyxDQUFDNkIsY0FBYyxDQUFDN0IsSUFBSTtRQUN6QixJQUFJLENBQUMsQ0FBQytNLG9CQUFvQixDQUFDO1lBQ3pCOU0sb0JBQW9CO1lBQ3BCQyxvQkFBb0IsSUFBSSxDQUFDLENBQUMyQixjQUFjLENBQUMzQixrQkFBa0I7WUFDM0R5RixTQUFTLElBQUksQ0FBQyxDQUFDQSxPQUFPO1FBQ3hCO0lBQ0Y7SUFDQXFKLFlBQVl0OEMsTUFBTSxFQUFFO1FBQ2xCLElBQUksQ0FBQyxDQUFDbXZDLGNBQWMsQ0FBQ3Z6QyxHQUFHLENBQUNvRTtRQUN6QixJQUFJLENBQUMsQ0FBQ3E2QyxvQkFBb0IsQ0FBQztZQUN6QjlNLG9CQUFvQjtZQUNwQkMsb0JBQW9CO1lBQ3BCeUYsU0FBUyxJQUFJLENBQUMsQ0FBQ0EsT0FBTztRQUN4QjtJQUNGO0lBQ0E2TixlQUFlcHlELElBQUksRUFBRTtRQUNuQixJQUFJLENBQUMsQ0FBQ3lnRCxjQUFjLENBQUMxQixTQUFTLENBQUMvK0M7SUFDakM7SUFDQSxDQUFDdWtELE9BQU87UUFDTixJQUFJLElBQUksQ0FBQyxDQUFDbEUsVUFBVSxDQUFDaDBDLElBQUksS0FBSyxHQUFHO1lBQy9CLE9BQU87UUFDVDtRQUNBLElBQUksSUFBSSxDQUFDLENBQUNnMEMsVUFBVSxDQUFDaDBDLElBQUksS0FBSyxHQUFHO1lBQy9CLEtBQUssTUFBTXFxQyxVQUFVLElBQUksQ0FBQyxDQUFDMkosVUFBVSxDQUFDbGlDLE1BQU0sR0FBSTtnQkFDOUMsT0FBT3U0QixPQUFPNk4sT0FBTztZQUN2QjtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBQ0ExTCxTQUFTO1FBQ1AsSUFBSSxDQUFDMlEsY0FBYztRQUNuQixNQUFNNkksZ0JBQWdCLElBQUksQ0FBQ3BJLFlBQVksRUFBRXFJLGtCQUFrQjtRQUMzRCxJQUFJLENBQUMsSUFBSSxDQUFDbkcsWUFBWSxJQUFJLENBQUNrRyxlQUFlO1lBQ3hDO1FBQ0Y7UUFDQSxNQUFNbEYsVUFBVWtGLGdCQUFnQjtZQUFDQTtTQUFjLEdBQUc7ZUFBSSxJQUFJLENBQUMsQ0FBQ2pRLGVBQWU7U0FBQztRQUM1RSxNQUFNL0QsTUFBTTtZQUNWLElBQUksQ0FBQ2dHLGNBQWMsRUFBRTlMLEtBQUsrRixNQUFNNk8sUUFBUTkxRCxNQUFNLEtBQUssSUFBSTgxRCxPQUFPLENBQUMsRUFBRSxDQUFDelUsVUFBVSxHQUFHeVUsUUFBUTkxRCxNQUFNO1lBQzdGLEtBQUssTUFBTXEvQyxVQUFVeVcsUUFBUztnQkFDNUJ6VyxPQUFPanFDLE1BQU07WUFDZjtRQUNGO1FBQ0EsTUFBTTZ4QyxPQUFPO1lBQ1gsS0FBSyxNQUFNNUgsVUFBVXlXLFFBQVM7Z0JBQzVCLElBQUksQ0FBQyxDQUFDTyxnQkFBZ0IsQ0FBQ2hYO1lBQ3pCO1FBQ0Y7UUFDQSxJQUFJLENBQUNrWCxXQUFXLENBQUM7WUFDZnZQO1lBQ0FDO1lBQ0FFLFVBQVU7UUFDWjtJQUNGO0lBQ0FnTCxpQkFBaUI7UUFDZixJQUFJLENBQUMsQ0FBQ3JKLFlBQVksRUFBRXFKO0lBQ3RCO0lBQ0FsRyx3QkFBd0I7UUFDdEIsT0FBTyxJQUFJLENBQUMsQ0FBQ25ELFlBQVksSUFBSSxJQUFJLENBQUNnTSxZQUFZO0lBQ2hEO0lBQ0EsQ0FBQ3dCLGFBQWEsQ0FBQ1IsT0FBTztRQUNwQixLQUFLLE1BQU16VyxVQUFVLElBQUksQ0FBQyxDQUFDMEwsZUFBZSxDQUFFO1lBQzFDMUwsT0FBT3laLFFBQVE7UUFDakI7UUFDQSxJQUFJLENBQUMsQ0FBQy9OLGVBQWUsQ0FBQ3ZqQyxLQUFLO1FBQzNCLEtBQUssTUFBTTYzQixVQUFVeVcsUUFBUztZQUM1QixJQUFJelcsT0FBTzZOLE9BQU8sSUFBSTtnQkFDcEI7WUFDRjtZQUNBLElBQUksQ0FBQyxDQUFDbkMsZUFBZSxDQUFDbDFDLEdBQUcsQ0FBQ3dwQztZQUMxQkEsT0FBT3diLE1BQU07UUFDZjtRQUNBLElBQUksQ0FBQyxDQUFDdkcsb0JBQW9CLENBQUM7WUFDekJuSCxtQkFBbUIsSUFBSSxDQUFDMkgsWUFBWTtRQUN0QztJQUNGO0lBQ0F2SSxZQUFZO1FBQ1YsS0FBSyxNQUFNbE4sVUFBVSxJQUFJLENBQUMsQ0FBQzBMLGVBQWUsQ0FBRTtZQUMxQzFMLE9BQU82YixNQUFNO1FBQ2Y7UUFDQSxJQUFJLENBQUMsQ0FBQzVFLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQ3ROLFVBQVUsQ0FBQ2xpQyxNQUFNO0lBQzdDO0lBQ0E2bEMsY0FBYztRQUNaLElBQUksSUFBSSxDQUFDLENBQUM3RCxZQUFZLEVBQUU7WUFDdEIsSUFBSSxDQUFDLENBQUNBLFlBQVksQ0FBQ3FKLGNBQWM7WUFDakMsSUFBSSxJQUFJLENBQUMsQ0FBQ2pyQyxJQUFJLEtBQUs4TSxxQkFBcUJDLElBQUksRUFBRTtnQkFDNUM7WUFDRjtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUMsQ0FBQ3MxQixxQkFBcUIsRUFBRTRJLGtCQUFrQjtZQUNqRDtRQUNGO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQzJDLFlBQVksRUFBRTtZQUN0QjtRQUNGO1FBQ0EsS0FBSyxNQUFNelYsVUFBVSxJQUFJLENBQUMsQ0FBQzBMLGVBQWUsQ0FBRTtZQUMxQzFMLE9BQU95WixRQUFRO1FBQ2pCO1FBQ0EsSUFBSSxDQUFDLENBQUMvTixlQUFlLENBQUN2akMsS0FBSztRQUMzQixJQUFJLENBQUMsQ0FBQzhzQyxvQkFBb0IsQ0FBQztZQUN6Qm5ILG1CQUFtQjtRQUNyQjtJQUNGO0lBQ0FQLHlCQUF5QmptRCxDQUFDLEVBQUUwTSxDQUFDLEVBQUU4bkQsV0FBVyxLQUFLLEVBQUU7UUFDL0MsSUFBSSxDQUFDQSxVQUFVO1lBQ2IsSUFBSSxDQUFDaEosY0FBYztRQUNyQjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUMyQyxZQUFZLEVBQUU7WUFDdEI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDekosV0FBVyxDQUFDLEVBQUUsSUFBSTFrRDtRQUN4QixJQUFJLENBQUMsQ0FBQzBrRCxXQUFXLENBQUMsRUFBRSxJQUFJaDRDO1FBQ3hCLE1BQU0sQ0FBQytuRCxRQUFRQyxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUNoUSxXQUFXO1FBQzFDLE1BQU15SyxVQUFVO2VBQUksSUFBSSxDQUFDLENBQUMvSyxlQUFlO1NBQUM7UUFDMUMsTUFBTXVRLGVBQWU7UUFDckIsSUFBSSxJQUFJLENBQUMsQ0FBQ2hRLG9CQUFvQixFQUFFO1lBQzlCaUQsYUFBYSxJQUFJLENBQUMsQ0FBQ2pELG9CQUFvQjtRQUN6QztRQUNBLElBQUksQ0FBQyxDQUFDQSxvQkFBb0IsR0FBR3lPLFdBQVc7WUFDdEMsSUFBSSxDQUFDLENBQUN6TyxvQkFBb0IsR0FBRztZQUM3QixJQUFJLENBQUMsQ0FBQ0QsV0FBVyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQ0EsV0FBVyxDQUFDLEVBQUUsR0FBRztZQUM5QyxJQUFJLENBQUNrTCxXQUFXLENBQUM7Z0JBQ2Z2UCxLQUFLO29CQUNILEtBQUssTUFBTTNILFVBQVV5VyxRQUFTO3dCQUM1QixJQUFJLElBQUksQ0FBQyxDQUFDOU0sVUFBVSxDQUFDeGdELEdBQUcsQ0FBQzYyQyxPQUFPMXFDLEVBQUUsR0FBRzs0QkFDbkMwcUMsT0FBT2tjLGVBQWUsQ0FBQ0gsUUFBUUM7NEJBQy9CaGMsT0FBT21jLGVBQWU7d0JBQ3hCO29CQUNGO2dCQUNGO2dCQUNBdlUsTUFBTTtvQkFDSixLQUFLLE1BQU01SCxVQUFVeVcsUUFBUzt3QkFDNUIsSUFBSSxJQUFJLENBQUMsQ0FBQzlNLFVBQVUsQ0FBQ3hnRCxHQUFHLENBQUM2MkMsT0FBTzFxQyxFQUFFLEdBQUc7NEJBQ25DMHFDLE9BQU9rYyxlQUFlLENBQUMsQ0FBQ0gsUUFBUSxDQUFDQzs0QkFDakNoYyxPQUFPbWMsZUFBZTt3QkFDeEI7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0FyVSxVQUFVO1lBQ1o7UUFDRixHQUFHbVU7UUFDSCxLQUFLLE1BQU1qYyxVQUFVeVcsUUFBUztZQUM1QnpXLE9BQU9rYyxlQUFlLENBQUM1MEQsR0FBRzBNO1lBQzFCZ3NDLE9BQU9tYyxlQUFlO1FBQ3hCO0lBQ0Y7SUFDQUMsbUJBQW1CO1FBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUMzRyxZQUFZLEVBQUU7WUFDdEI7UUFDRjtRQUNBLElBQUksQ0FBQ3BGLGlCQUFpQixDQUFDO1FBQ3ZCLElBQUksQ0FBQyxDQUFDaEcsZUFBZSxHQUFHLElBQUl4YztRQUM1QixLQUFLLE1BQU1tUyxVQUFVLElBQUksQ0FBQyxDQUFDMEwsZUFBZSxDQUFFO1lBQzFDLElBQUksQ0FBQyxDQUFDckIsZUFBZSxDQUFDbmhELEdBQUcsQ0FBQzgyQyxRQUFRO2dCQUNoQ3FjLFFBQVFyYyxPQUFPMTRDLENBQUM7Z0JBQ2hCZzFELFFBQVF0YyxPQUFPaHNDLENBQUM7Z0JBQ2hCdW9ELGdCQUFnQnZjLE9BQU84USxTQUFTO2dCQUNoQzBMLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05DLGNBQWMsQ0FBQztZQUNqQjtRQUNGO0lBQ0Y7SUFDQUMsaUJBQWlCO1FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDdFMsZUFBZSxFQUFFO1lBQzFCLE9BQU87UUFDVDtRQUNBLElBQUksQ0FBQ2dHLGlCQUFpQixDQUFDO1FBQ3ZCLE1BQU03a0QsTUFBTSxJQUFJLENBQUMsQ0FBQzYrQyxlQUFlO1FBQ2pDLElBQUksQ0FBQyxDQUFDQSxlQUFlLEdBQUc7UUFDeEIsSUFBSXVTLHlCQUF5QjtRQUM3QixLQUFLLE1BQU0sQ0FBQyxFQUNWdDFELENBQUMsRUFDRDBNLENBQUMsRUFDRDg4QyxTQUFTLEVBQ1YsRUFBRWx2RCxNQUFNLElBQUk0SixJQUFLO1lBQ2hCNUosTUFBTTQ2RCxJQUFJLEdBQUdsMUQ7WUFDYjFGLE1BQU02NkQsSUFBSSxHQUFHem9EO1lBQ2JwUyxNQUFNODZELFlBQVksR0FBRzVMO1lBQ3JCOEwsMkJBQTJCdDFELE1BQU0xRixNQUFNeTZELE1BQU0sSUFBSXJvRCxNQUFNcFMsTUFBTTA2RCxNQUFNLElBQUl4TCxjQUFjbHZELE1BQU0yNkQsY0FBYztRQUMzRztRQUNBLElBQUksQ0FBQ0ssd0JBQXdCO1lBQzNCLE9BQU87UUFDVDtRQUNBLE1BQU1DLE9BQU8sQ0FBQzdjLFFBQVExNEMsR0FBRzBNLEdBQUc4OEM7WUFDMUIsSUFBSSxJQUFJLENBQUMsQ0FBQ25ILFVBQVUsQ0FBQ3hnRCxHQUFHLENBQUM2MkMsT0FBTzFxQyxFQUFFLEdBQUc7Z0JBQ25DLE1BQU0yOUIsU0FBUyxJQUFJLENBQUMsQ0FBQzJXLFNBQVMsQ0FBQ2huRCxHQUFHLENBQUNrdUQ7Z0JBQ25DLElBQUk3ZCxRQUFRO29CQUNWK00sT0FBTzhjLHFCQUFxQixDQUFDN3BCLFFBQVEzckMsR0FBRzBNO2dCQUMxQyxPQUFPO29CQUNMZ3NDLE9BQU84USxTQUFTLEdBQUdBO29CQUNuQjlRLE9BQU8xNEMsQ0FBQyxHQUFHQTtvQkFDWDA0QyxPQUFPaHNDLENBQUMsR0FBR0E7Z0JBQ2I7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDa2pELFdBQVcsQ0FBQztZQUNmdlAsS0FBSztnQkFDSCxLQUFLLE1BQU0sQ0FBQzNILFFBQVEsRUFDbEJ3YyxJQUFJLEVBQ0pDLElBQUksRUFDSkMsWUFBWSxFQUNiLENBQUMsSUFBSWx4RCxJQUFLO29CQUNUcXhELEtBQUs3YyxRQUFRd2MsTUFBTUMsTUFBTUM7Z0JBQzNCO1lBQ0Y7WUFDQTlVLE1BQU07Z0JBQ0osS0FBSyxNQUFNLENBQUM1SCxRQUFRLEVBQ2xCcWMsTUFBTSxFQUNOQyxNQUFNLEVBQ05DLGNBQWMsRUFDZixDQUFDLElBQUkvd0QsSUFBSztvQkFDVHF4RCxLQUFLN2MsUUFBUXFjLFFBQVFDLFFBQVFDO2dCQUMvQjtZQUNGO1lBQ0F6VSxVQUFVO1FBQ1o7UUFDQSxPQUFPO0lBQ1Q7SUFDQWlWLG9CQUFvQkMsRUFBRSxFQUFFQyxFQUFFLEVBQUU7UUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDNVMsZUFBZSxFQUFFO1lBQzFCO1FBQ0Y7UUFDQSxLQUFLLE1BQU1ySyxVQUFVLElBQUksQ0FBQyxDQUFDcUssZUFBZSxDQUFDbGlELElBQUksR0FBSTtZQUNqRDYzQyxPQUFPa2QsSUFBSSxDQUFDRixJQUFJQztRQUNsQjtJQUNGO0lBQ0FFLFFBQVFuZCxNQUFNLEVBQUU7UUFDZCxJQUFJQSxPQUFPL00sTUFBTSxLQUFLLE1BQU07WUFDMUIsTUFBTUEsU0FBUyxJQUFJLENBQUMwa0IsUUFBUSxDQUFDM1gsT0FBTzhRLFNBQVM7WUFDN0MsSUFBSTdkLFFBQVE7Z0JBQ1ZBLE9BQU9tcUIsWUFBWSxDQUFDcGQ7Z0JBQ3BCL00sT0FBTytuQixZQUFZLENBQUNoYjtZQUN0QixPQUFPO2dCQUNMLElBQUksQ0FBQ3dhLFNBQVMsQ0FBQ3hhO2dCQUNmLElBQUksQ0FBQzRVLHNCQUFzQixDQUFDNVU7Z0JBQzVCQSxPQUFPbWQsT0FBTztZQUNoQjtRQUNGLE9BQU87WUFDTG5kLE9BQU8vTSxNQUFNLENBQUMrbkIsWUFBWSxDQUFDaGI7UUFDN0I7SUFDRjtJQUNBLElBQUltWCwyQkFBMkI7UUFDN0IsT0FBTyxJQUFJLENBQUNrRyxTQUFTLElBQUlDLDZCQUE2QixJQUFJLENBQUMsQ0FBQzVSLGVBQWUsQ0FBQy8xQyxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUM4bEQsbUJBQW1CLENBQUM2Qix1QkFBdUI7SUFDNUk7SUFDQUMsU0FBU3ZkLE1BQU0sRUFBRTtRQUNmLE9BQU8sSUFBSSxDQUFDLENBQUN5SixZQUFZLEtBQUt6SjtJQUNoQztJQUNBcWQsWUFBWTtRQUNWLE9BQU8sSUFBSSxDQUFDLENBQUM1VCxZQUFZO0lBQzNCO0lBQ0ErVCxVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUMsQ0FBQzMxQyxJQUFJO0lBQ25CO0lBQ0E0MUMsZ0JBQWdCO1FBQ2QsT0FBTyxJQUFJLENBQUMsQ0FBQzUxQyxJQUFJLEtBQUs4TSxxQkFBcUJDLElBQUk7SUFDakQ7SUFDQSxJQUFJOG9DLGVBQWU7UUFDakIsT0FBT3Y1QixPQUFPLElBQUksRUFBRSxnQkFBZ0IsSUFBSXlnQjtJQUMxQztJQUNBc1Asa0JBQWtCWixTQUFTLEVBQUU7UUFDM0IsSUFBSSxDQUFDQSxXQUFXO1lBQ2QsT0FBTztRQUNUO1FBQ0EsTUFBTUksWUFBWWhsRCxTQUFTaWxELFlBQVk7UUFDdkMsSUFBSyxJQUFJcnVELElBQUksR0FBR2luQyxLQUFLbW5CLFVBQVVpSyxVQUFVLEVBQUVyNEQsSUFBSWluQyxJQUFJam5DLElBQUs7WUFDdEQsSUFBSSxDQUFDZ3VELFVBQVU3RyxRQUFRLENBQUNpSCxVQUFVa0ssVUFBVSxDQUFDdDRELEdBQUd1NEQsdUJBQXVCLEdBQUc7Z0JBQ3hFLE9BQU87WUFDVDtRQUNGO1FBQ0EsTUFBTSxFQUNKdjJELEdBQUdrckQsTUFBTSxFQUNUeCtDLEdBQUd5K0MsTUFBTSxFQUNUM2MsT0FBT2dvQixXQUFXLEVBQ2xCL25CLFFBQVFnb0IsWUFBWSxFQUNyQixHQUFHekssVUFBVVoscUJBQXFCO1FBQ25DLElBQUlzTDtRQUNKLE9BQVExSyxVQUFVNWhCLFlBQVksQ0FBQztZQUM3QixLQUFLO2dCQUNIc3NCLFVBQVUsQ0FBQzEyRCxHQUFHME0sR0FBRzhtQyxHQUFHQyxJQUFPO3dCQUN6Qnp6QyxHQUFHLENBQUMwTSxJQUFJeStDLE1BQUssSUFBS3NMO3dCQUNsQi9wRCxHQUFHLElBQUksQ0FBQzFNLElBQUl3ekMsSUFBSTBYLE1BQUssSUFBS3NMO3dCQUMxQmhvQixPQUFPaUYsSUFBSWdqQjt3QkFDWGhvQixRQUFRK0UsSUFBSWdqQjtvQkFDZDtnQkFDQTtZQUNGLEtBQUs7Z0JBQ0hFLFVBQVUsQ0FBQzEyRCxHQUFHME0sR0FBRzhtQyxHQUFHQyxJQUFPO3dCQUN6Qnp6QyxHQUFHLElBQUksQ0FBQ0EsSUFBSXd6QyxJQUFJMFgsTUFBSyxJQUFLc0w7d0JBQzFCOXBELEdBQUcsSUFBSSxDQUFDQSxJQUFJK21DLElBQUkwWCxNQUFLLElBQUtzTDt3QkFDMUJqb0IsT0FBT2dGLElBQUlnakI7d0JBQ1gvbkIsUUFBUWdGLElBQUlnakI7b0JBQ2Q7Z0JBQ0E7WUFDRixLQUFLO2dCQUNIQyxVQUFVLENBQUMxMkQsR0FBRzBNLEdBQUc4bUMsR0FBR0MsSUFBTzt3QkFDekJ6ekMsR0FBRyxJQUFJLENBQUMwTSxJQUFJK21DLElBQUkwWCxNQUFLLElBQUtzTDt3QkFDMUIvcEQsR0FBRyxDQUFDMU0sSUFBSWtyRCxNQUFLLElBQUtzTDt3QkFDbEJob0IsT0FBT2lGLElBQUlnakI7d0JBQ1hob0IsUUFBUStFLElBQUlnakI7b0JBQ2Q7Z0JBQ0E7WUFDRjtnQkFDRUUsVUFBVSxDQUFDMTJELEdBQUcwTSxHQUFHOG1DLEdBQUdDLElBQU87d0JBQ3pCenpDLEdBQUcsQ0FBQ0EsSUFBSWtyRCxNQUFLLElBQUtzTDt3QkFDbEI5cEQsR0FBRyxDQUFDQSxJQUFJeStDLE1BQUssSUFBS3NMO3dCQUNsQmpvQixPQUFPZ0YsSUFBSWdqQjt3QkFDWC9uQixRQUFRZ0YsSUFBSWdqQjtvQkFDZDtnQkFDQTtRQUNKO1FBQ0EsTUFBTTlaLFFBQVEsRUFBRTtRQUNoQixJQUFLLElBQUkzK0MsSUFBSSxHQUFHaW5DLEtBQUttbkIsVUFBVWlLLFVBQVUsRUFBRXI0RCxJQUFJaW5DLElBQUlqbkMsSUFBSztZQUN0RCxNQUFNMjRELFFBQVF2SyxVQUFVa0ssVUFBVSxDQUFDdDREO1lBQ25DLElBQUkyNEQsTUFBTUMsU0FBUyxFQUFFO2dCQUNuQjtZQUNGO1lBQ0EsS0FBSyxNQUFNLEVBQ1Q1MkQsQ0FBQyxFQUNEME0sQ0FBQyxFQUNEOGhDLEtBQUssRUFDTEMsTUFBTSxFQUNQLElBQUlrb0IsTUFBTUUsY0FBYyxHQUFJO2dCQUMzQixJQUFJcm9CLFVBQVUsS0FBS0MsV0FBVyxHQUFHO29CQUMvQjtnQkFDRjtnQkFDQWtPLE1BQU1yNEMsSUFBSSxDQUFDb3lELFFBQVExMkQsR0FBRzBNLEdBQUc4aEMsT0FBT0M7WUFDbEM7UUFDRjtRQUNBLE9BQU9rTyxNQUFNdGpELE1BQU0sS0FBSyxJQUFJLE9BQU9zakQ7SUFDckM7SUFDQTJXLDZCQUE2QixFQUMzQjVCLG1CQUFtQixFQUNuQjFqRCxFQUFFLEVBQ0gsRUFBRTtRQUNBLEtBQUksQ0FBQyxDQUFDdzBDLDBCQUEwQixLQUFLLElBQUlqYyxLQUFJLEVBQUcza0MsR0FBRyxDQUFDOHZELHFCQUFxQjFqRDtJQUM1RTtJQUNBeWxELGdDQUFnQyxFQUM5Qi9CLG1CQUFtQixFQUNwQixFQUFFO1FBQ0QsSUFBSSxDQUFDLENBQUNsUCwwQkFBMEIsRUFBRTNILE9BQU82VztJQUMzQztJQUNBb0Ysd0JBQXdCakYsVUFBVSxFQUFFO1FBQ2xDLE1BQU1rRixXQUFXLElBQUksQ0FBQyxDQUFDdlUsMEJBQTBCLEVBQUVsbkQsSUFBSXUyRCxXQUFXam9ELElBQUksQ0FBQ29FLEVBQUU7UUFDekUsSUFBSSxDQUFDK29ELFVBQVU7WUFDYjtRQUNGO1FBQ0EsTUFBTXJlLFNBQVMsSUFBSSxDQUFDLENBQUN4TixpQkFBaUIsQ0FBQ21pQixXQUFXLENBQUMwSjtRQUNuRCxJQUFJLENBQUNyZSxRQUFRO1lBQ1g7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDLENBQUNuNEIsSUFBSSxLQUFLOE0scUJBQXFCQyxJQUFJLElBQUksQ0FBQ29yQixPQUFPc2UsZUFBZSxFQUFFO1lBQ3ZFO1FBQ0Y7UUFDQXRlLE9BQU9vZSx1QkFBdUIsQ0FBQ2pGO0lBQ2pDO0lBQ0FvRixpQkFBaUI5SixZQUFZLEVBQUV1RSxtQkFBbUIsRUFBRS9ULE1BQU0sRUFBRTtRQUMxRCxNQUFNakYsU0FBUyxJQUFJLENBQUMsQ0FBQ3dMLGVBQWUsRUFBRTVvRCxJQUFJNnhEO1FBQzFDLElBQUksQ0FBQ3pVLFFBQVE7WUFDWDtRQUNGO1FBQ0FBLE9BQU93ZSxTQUFTLENBQUN4RixxQkFBcUIvVDtRQUN0QyxJQUFJLENBQUMsQ0FBQ3VHLGVBQWUsQ0FBQ3JKLE1BQU0sQ0FBQ3NTO0lBQy9CO0lBQ0FnSyxpQkFBaUJoSyxZQUFZLEVBQUV6VSxNQUFNLEVBQUU7UUFDcEMsS0FBSSxDQUFDLENBQUN3TCxlQUFlLEtBQUssSUFBSTNkLEtBQUksRUFBRzNrQyxHQUFHLENBQUN1ckQsY0FBY3pVO0lBQzFEO0FBQ0Y7RUFFQyxtQ0FBbUM7QUFFcEMsTUFBTTBlO0lBQ0osQ0FBQ3hlLE9BQU8sQ0FBUTtJQUNoQixDQUFDeWUsaUJBQWlCLENBQVM7SUFDM0IsQ0FBQ0MsYUFBYSxDQUFRO0lBQ3RCLENBQUNDLGtCQUFrQixDQUFRO0lBQzNCLENBQUNDLGNBQWMsQ0FBUTtJQUN2QixDQUFDQyxxQkFBcUIsQ0FBUTtJQUM5QixDQUFDQyxzQkFBc0IsQ0FBUztJQUNoQyxDQUFDQyxLQUFLLENBQVE7SUFDZCxDQUFDamYsTUFBTSxDQUFRO0lBQ2YsQ0FBQ2tmLFdBQVcsQ0FBUTtJQUNwQixDQUFDQyxrQkFBa0IsQ0FBUTtJQUMzQixDQUFDL1AsaUJBQWlCLENBQVM7SUFDM0IsT0FBTyxDQUFDZ1EsYUFBYSxHQUFHLEtBQUs7O2FBQ3RCQyxRQUFROztJQUNmdDdELFlBQVlpOEMsTUFBTSxDQUFFO2FBZHBCLENBQUNFLE9BQU8sR0FBRzthQUNYLENBQUN5ZSxpQkFBaUIsR0FBRzthQUNyQixDQUFDQyxhQUFhLEdBQUc7YUFDakIsQ0FBQ0Msa0JBQWtCLEdBQUc7YUFDdEIsQ0FBQ0MsY0FBYyxHQUFHO2FBQ2xCLENBQUNDLHFCQUFxQixHQUFHO2FBQ3pCLENBQUNDLHNCQUFzQixHQUFHO2FBQzFCLENBQUNDLEtBQUssR0FBRzthQUNULENBQUNqZixNQUFNLEdBQUc7YUFDVixDQUFDa2YsV0FBVyxHQUFHO2FBQ2YsQ0FBQ0Msa0JBQWtCLEdBQUc7YUFDdEIsQ0FBQy9QLGlCQUFpQixHQUFHO1FBSW5CLElBQUksQ0FBQyxDQUFDcFAsTUFBTSxHQUFHQTtRQUNmLElBQUksQ0FBQyxDQUFDb1AsaUJBQWlCLEdBQUdwUCxPQUFPYyxVQUFVLENBQUNzTyxpQkFBaUI7UUFDN0RzUCxRQUFRLENBQUNVLGFBQWEsS0FBS3A4RCxPQUFPdTlDLE1BQU0sQ0FBQztZQUN2QytlLE9BQU87WUFDUCxlQUFlO1lBQ2Z4NkIsU0FBUztZQUNULGlCQUFpQjtZQUNqQnk2QixRQUFRO1lBQ1IsZ0JBQWdCO1FBQ2xCO0lBQ0Y7SUFDQSxPQUFPQyxXQUFXQyxJQUFJLEVBQUU7UUFDdEJmLFFBQVFXLEtBQUssS0FBS0k7SUFDcEI7SUFDQSxNQUFNbnRCLFNBQVM7UUFDYixNQUFNNE4sVUFBVSxJQUFJLENBQUMsQ0FBQzBlLGFBQWEsR0FBR2x3RCxTQUFTMkksYUFBYSxDQUFDO1FBQzdENm9DLFFBQVF6QixTQUFTLEdBQUc7UUFDcEJ5QixRQUFRZ0MsUUFBUSxHQUFHO1FBQ25CLE1BQU13ZCxRQUFRLElBQUksQ0FBQyxDQUFDYixrQkFBa0IsR0FBR253RCxTQUFTMkksYUFBYSxDQUFDO1FBQ2hFNm9DLFFBQVF6bEMsTUFBTSxDQUFDaWxEO1FBQ2YsSUFBSSxJQUFJLENBQUMsQ0FBQ3RRLGlCQUFpQixFQUFFO1lBQzNCbFAsUUFBUXRELFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7WUFDdEIwcEMsUUFBUTVPLFlBQVksQ0FBQyxnQkFBZ0JvdEIsUUFBUSxDQUFDVSxhQUFhLENBQUN0NkIsT0FBTztZQUNuRTQ2QixNQUFNcHVCLFlBQVksQ0FBQyxnQkFBZ0JvdEIsUUFBUSxDQUFDVSxhQUFhLENBQUMsZ0JBQWdCO1FBQzVFLE9BQU87WUFDTGxmLFFBQVE1TyxZQUFZLENBQUMsZ0JBQWdCO1lBQ3JDb3VCLE1BQU1wdUIsWUFBWSxDQUFDLGdCQUFnQjtRQUNyQztRQUNBLE1BQU01QixTQUFTLElBQUksQ0FBQyxDQUFDc1EsTUFBTSxDQUFDYyxVQUFVLENBQUNDLE9BQU87UUFDOUNiLFFBQVFwUSxnQkFBZ0IsQ0FBQyxlQUFldUksZUFBZTtZQUNyRDNJO1FBQ0Y7UUFDQXdRLFFBQVFwUSxnQkFBZ0IsQ0FBQyxlQUFlcUIsQ0FBQUEsUUFBU0EsTUFBTXFILGVBQWUsSUFBSTtZQUN4RTlJO1FBQ0Y7UUFDQSxNQUFNaXdCLFVBQVV4dUIsQ0FBQUE7WUFDZEEsTUFBTW1ILGNBQWM7WUFDcEIsSUFBSSxDQUFDLENBQUMwSCxNQUFNLENBQUNjLFVBQVUsQ0FBQ3lQLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQ3ZRLE1BQU07WUFDaEQsSUFBSSxJQUFJLENBQUMsQ0FBQ29QLGlCQUFpQixFQUFFO2dCQUMzQixJQUFJLENBQUMsQ0FBQ3BQLE1BQU0sQ0FBQzRmLGdCQUFnQixDQUFDO29CQUM1Qi9GLFFBQVE7b0JBQ1Izb0QsTUFBTTt3QkFDSnd1RCxPQUFPLElBQUksQ0FBQyxDQUFDQSxLQUFLO29CQUNwQjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQXhmLFFBQVFwUSxnQkFBZ0IsQ0FBQyxTQUFTNnZCLFNBQVM7WUFDekNqZSxTQUFTO1lBQ1RoUztRQUNGO1FBQ0F3USxRQUFRcFEsZ0JBQWdCLENBQUMsV0FBV3FCLENBQUFBO1lBQ2xDLElBQUlBLE1BQU1od0MsTUFBTSxLQUFLKytDLFdBQVcvTyxNQUFNcGxDLEdBQUcsS0FBSyxTQUFTO2dCQUNyRCxJQUFJLENBQUMsQ0FBQ2l6RCxzQkFBc0IsR0FBRztnQkFDL0JXLFFBQVF4dUI7WUFDVjtRQUNGLEdBQUc7WUFDRHpCO1FBQ0Y7UUFDQSxNQUFNLElBQUksQ0FBQyxDQUFDbXdCLFFBQVE7UUFDcEIsT0FBTzNmO0lBQ1Q7SUFDQSxJQUFJLENBQUN3ZixLQUFLO1FBQ1IsT0FBTyxJQUFJLENBQUMsQ0FBQ3hmLE9BQU8sSUFBSSxXQUFXLElBQUksQ0FBQyxDQUFDQSxPQUFPLEtBQUssUUFBUSxJQUFJLENBQUNnZixXQUFXLElBQUksWUFBWTtJQUMvRjtJQUNBWSxTQUFTO1FBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDbEIsYUFBYSxFQUFFO1lBQ3hCO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQ0EsYUFBYSxDQUFDdE0sS0FBSyxDQUFDO1lBQ3hCeU4sY0FBYyxJQUFJLENBQUMsQ0FBQ2Ysc0JBQXNCO1FBQzVDO1FBQ0EsSUFBSSxDQUFDLENBQUNBLHNCQUFzQixHQUFHO0lBQ2pDO0lBQ0FuUixVQUFVO1FBQ1IsSUFBSSxJQUFJLENBQUMsQ0FBQ3VCLGlCQUFpQixFQUFFO1lBQzNCLE9BQU8sSUFBSSxDQUFDLENBQUNsUCxPQUFPLEtBQUs7UUFDM0I7UUFDQSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUNBLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDeWUsaUJBQWlCO0lBQ25EO0lBQ0FxQixVQUFVO1FBQ1IsSUFBSSxJQUFJLENBQUMsQ0FBQzVRLGlCQUFpQixFQUFFO1lBQzNCLE9BQU8sSUFBSSxDQUFDLENBQUNsUCxPQUFPLEtBQUssUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUNnZixXQUFXO1FBQ3REO1FBQ0EsT0FBTyxJQUFJLENBQUNyUixPQUFPO0lBQ3JCO0lBQ0EsSUFBSXFSLGNBQWM7UUFDaEIsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsV0FBVztJQUMxQjtJQUNBLE1BQU1lLGVBQWVmLFdBQVcsRUFBRTtRQUNoQyxJQUFJLElBQUksQ0FBQyxDQUFDaGYsT0FBTyxLQUFLLE1BQU07WUFDMUI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDZ2YsV0FBVyxHQUFHQTtRQUNwQixJQUFJLENBQUMsQ0FBQ0Msa0JBQWtCLEdBQUcsTUFBTVQsUUFBUVcsS0FBSyxDQUFDejhELEdBQUcsQ0FBQyxnRUFBZ0U7WUFDakhzOUQsa0JBQWtCaEI7UUFDcEI7UUFDQSxJQUFJLENBQUMsQ0FBQ1csUUFBUTtJQUNoQjtJQUNBTSxtQkFBbUJubUIsYUFBYSxLQUFLLEVBQUU7UUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDb1YsaUJBQWlCLElBQUksSUFBSSxDQUFDLENBQUNsUCxPQUFPLEVBQUU7WUFDN0MsSUFBSSxDQUFDLENBQUMrZSxLQUFLLEVBQUVscEQ7WUFDYixJQUFJLENBQUMsQ0FBQ2twRCxLQUFLLEdBQUc7WUFDZDtRQUNGO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDQSxLQUFLLEVBQUU7WUFDaEIsTUFBTUEsUUFBUSxJQUFJLENBQUMsQ0FBQ0EsS0FBSyxHQUFHdndELFNBQVMySSxhQUFhLENBQUM7WUFDbkQ0bkQsTUFBTXhnQixTQUFTLEdBQUc7WUFDbEIsSUFBSSxDQUFDLENBQUN1QixNQUFNLENBQUNuTixHQUFHLENBQUNwNEIsTUFBTSxDQUFDd2tEO1FBQzFCO1FBQ0EsSUFBSSxDQUFDLENBQUNBLEtBQUssQ0FBQ3JpQixTQUFTLENBQUMrVixNQUFNLENBQUMsVUFBVSxDQUFDM1k7SUFDMUM7SUFDQTBPLFVBQVUwWCxZQUFZLEVBQUU7UUFDdEIsSUFBSWxnQixVQUFVLElBQUksQ0FBQyxDQUFDQSxPQUFPO1FBQzNCLElBQUksQ0FBQ2tnQixnQkFBZ0IsSUFBSSxDQUFDLENBQUNsQixXQUFXLEtBQUtoZixTQUFTO1lBQ2xEQSxVQUFVLElBQUksQ0FBQyxDQUFDaWYsa0JBQWtCO1FBQ3BDO1FBQ0EsT0FBTztZQUNMamY7WUFDQW1nQixZQUFZLElBQUksQ0FBQyxDQUFDMUIsaUJBQWlCO1lBQ25DTyxhQUFhLElBQUksQ0FBQyxDQUFDQSxXQUFXO1lBQzlCQyxvQkFBb0IsSUFBSSxDQUFDLENBQUNBLGtCQUFrQjtRQUM5QztJQUNGO0lBQ0EsSUFBSWp1RCxPQUFPO1FBQ1QsT0FBTztZQUNMZ3ZDLFNBQVMsSUFBSSxDQUFDLENBQUNBLE9BQU87WUFDdEJtZ0IsWUFBWSxJQUFJLENBQUMsQ0FBQzFCLGlCQUFpQjtRQUNyQztJQUNGO0lBQ0EsSUFBSXp0RCxLQUFLLEVBQ1BndkMsT0FBTyxFQUNQbWdCLFVBQVUsRUFDVm5CLFdBQVcsRUFDWEMsa0JBQWtCLEVBQ2xCbUIsU0FBUyxLQUFLLEVBQ2YsRUFBRTtRQUNELElBQUlwQixhQUFhO1lBQ2YsSUFBSSxDQUFDLENBQUNBLFdBQVcsR0FBR0E7WUFDcEIsSUFBSSxDQUFDLENBQUNDLGtCQUFrQixHQUFHQTtRQUM3QjtRQUNBLElBQUksSUFBSSxDQUFDLENBQUNqZixPQUFPLEtBQUtBLFdBQVcsSUFBSSxDQUFDLENBQUN5ZSxpQkFBaUIsS0FBSzBCLFlBQVk7WUFDdkU7UUFDRjtRQUNBLElBQUksQ0FBQ0MsUUFBUTtZQUNYLElBQUksQ0FBQyxDQUFDcGdCLE9BQU8sR0FBR0E7WUFDaEIsSUFBSSxDQUFDLENBQUN5ZSxpQkFBaUIsR0FBRzBCO1FBQzVCO1FBQ0EsSUFBSSxDQUFDLENBQUNSLFFBQVE7SUFDaEI7SUFDQWxOLE9BQU80TixVQUFVLEtBQUssRUFBRTtRQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMzQixhQUFhLEVBQUU7WUFDeEI7UUFDRjtRQUNBLElBQUksQ0FBQzJCLFdBQVcsSUFBSSxDQUFDLENBQUN4QixxQkFBcUIsRUFBRTtZQUMzQzdQLGFBQWEsSUFBSSxDQUFDLENBQUM2UCxxQkFBcUI7WUFDeEMsSUFBSSxDQUFDLENBQUNBLHFCQUFxQixHQUFHO1FBQ2hDO1FBQ0EsSUFBSSxDQUFDLENBQUNILGFBQWEsQ0FBQzRCLFFBQVEsR0FBRyxDQUFDRDtJQUNsQztJQUNBemUsUUFBUTtRQUNOLElBQUksQ0FBQyxDQUFDOUIsTUFBTSxDQUFDNGYsZ0JBQWdCLENBQUM7WUFDNUIvRixRQUFRO1lBQ1Izb0QsTUFBTTtnQkFDSnd1RCxPQUFPLElBQUksQ0FBQyxDQUFDQSxLQUFLO1lBQ3BCO1FBQ0Y7SUFDRjtJQUNBamMsVUFBVTtRQUNSLElBQUksQ0FBQyxDQUFDbWIsYUFBYSxFQUFFN29EO1FBQ3JCLElBQUksQ0FBQyxDQUFDNm9ELGFBQWEsR0FBRztRQUN0QixJQUFJLENBQUMsQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDM0IsSUFBSSxDQUFDLENBQUNDLGNBQWMsR0FBRztRQUN2QixJQUFJLENBQUMsQ0FBQ0csS0FBSyxFQUFFbHBEO1FBQ2IsSUFBSSxDQUFDLENBQUNrcEQsS0FBSyxHQUFHO0lBQ2hCO0lBQ0EsTUFBTSxDQUFDWSxRQUFRO1FBQ2IsTUFBTTVkLFNBQVMsSUFBSSxDQUFDLENBQUMyYyxhQUFhO1FBQ2xDLElBQUksQ0FBQzNjLFFBQVE7WUFDWDtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUMsQ0FBQ21OLGlCQUFpQixFQUFFO1lBQzNCbk4sT0FBT3JGLFNBQVMsQ0FBQytWLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQ3pTLE9BQU87WUFDL0MrQixPQUFPM1EsWUFBWSxDQUFDLGdCQUFnQm90QixRQUFRLENBQUNVLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQ00sS0FBSyxDQUFDO1lBQ3ZFLElBQUksQ0FBQyxDQUFDYixrQkFBa0IsRUFBRXZ0QixhQUFhLGdCQUFnQm90QixRQUFRLENBQUNVLGFBQWEsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUNNLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNyRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUN4ZixPQUFPLEVBQUU7Z0JBQ2xCLElBQUksQ0FBQyxDQUFDNGUsY0FBYyxFQUFFL29EO2dCQUN0QjtZQUNGO1FBQ0YsT0FBTztZQUNMLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ21xQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ3llLGlCQUFpQixFQUFFO2dCQUM5QzFjLE9BQU9yRixTQUFTLENBQUM3bUMsTUFBTSxDQUFDO2dCQUN4QixJQUFJLENBQUMsQ0FBQytvRCxjQUFjLEVBQUUvb0Q7Z0JBQ3RCO1lBQ0Y7WUFDQWtzQyxPQUFPckYsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztZQUNyQnlyQyxPQUFPM1EsWUFBWSxDQUFDLGdCQUFnQjtRQUN0QztRQUNBLElBQUltdkIsVUFBVSxJQUFJLENBQUMsQ0FBQzNCLGNBQWM7UUFDbEMsSUFBSSxDQUFDMkIsU0FBUztZQUNaLElBQUksQ0FBQyxDQUFDM0IsY0FBYyxHQUFHMkIsVUFBVS94RCxTQUFTMkksYUFBYSxDQUFDO1lBQ3hEb3BELFFBQVFoaUIsU0FBUyxHQUFHO1lBQ3BCZ2lCLFFBQVFudkIsWUFBWSxDQUFDLFFBQVE7WUFDN0JtdkIsUUFBUW5yRCxFQUFFLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLENBQUMsQ0FBQzBxQyxNQUFNLENBQUMxcUMsRUFBRSxDQUFDLENBQUM7WUFDbEQsTUFBTW9yRCx3QkFBd0I7WUFDOUIsTUFBTWh4QixTQUFTLElBQUksQ0FBQyxDQUFDc1EsTUFBTSxDQUFDYyxVQUFVLENBQUNDLE9BQU87WUFDOUNyUixPQUFPSSxnQkFBZ0IsQ0FBQyxTQUFTO2dCQUMvQm9mLGFBQWEsSUFBSSxDQUFDLENBQUM2UCxxQkFBcUI7Z0JBQ3hDLElBQUksQ0FBQyxDQUFDQSxxQkFBcUIsR0FBRztZQUNoQyxHQUFHO2dCQUNEN00sTUFBTTtZQUNSO1lBQ0FqUSxPQUFPblMsZ0JBQWdCLENBQUMsY0FBYztnQkFDcEMsSUFBSSxDQUFDLENBQUNpdkIscUJBQXFCLEdBQUdyRSxXQUFXO29CQUN2QyxJQUFJLENBQUMsQ0FBQ3FFLHFCQUFxQixHQUFHO29CQUM5QixJQUFJLENBQUMsQ0FBQ0QsY0FBYyxDQUFDbGlCLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7b0JBQ25DLElBQUksQ0FBQyxDQUFDd3BDLE1BQU0sQ0FBQzRmLGdCQUFnQixDQUFDO3dCQUM1Qi9GLFFBQVE7b0JBQ1Y7Z0JBQ0YsR0FBRzZHO1lBQ0wsR0FBRztnQkFDRGh4QjtZQUNGO1lBQ0F1UyxPQUFPblMsZ0JBQWdCLENBQUMsY0FBYztnQkFDcEMsSUFBSSxJQUFJLENBQUMsQ0FBQ2l2QixxQkFBcUIsRUFBRTtvQkFDL0I3UCxhQUFhLElBQUksQ0FBQyxDQUFDNlAscUJBQXFCO29CQUN4QyxJQUFJLENBQUMsQ0FBQ0EscUJBQXFCLEdBQUc7Z0JBQ2hDO2dCQUNBLElBQUksQ0FBQyxDQUFDRCxjQUFjLEVBQUVsaUIsVUFBVTdtQyxPQUFPO1lBQ3pDLEdBQUc7Z0JBQ0QyNUI7WUFDRjtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUMsQ0FBQ2l2QixpQkFBaUIsRUFBRTtZQUMzQjhCLFFBQVFudkIsWUFBWSxDQUFDLGdCQUFnQjtRQUN2QyxPQUFPO1lBQ0xtdkIsUUFBUWp2QixlQUFlLENBQUM7WUFDeEJpdkIsUUFBUXJ3QixXQUFXLEdBQUcsSUFBSSxDQUFDLENBQUM4UCxPQUFPO1FBQ3JDO1FBQ0EsSUFBSSxDQUFDdWdCLFFBQVFFLFVBQVUsRUFBRTtZQUN2QjFlLE9BQU94bkMsTUFBTSxDQUFDZ21EO1FBQ2hCO1FBQ0EsTUFBTTN2QixVQUFVLElBQUksQ0FBQyxDQUFDa1AsTUFBTSxDQUFDNGdCLG9CQUFvQjtRQUNqRDl2QixTQUFTUSxhQUFhLG9CQUFvQm12QixRQUFRbnJELEVBQUU7SUFDdEQ7QUFDRjtFQUVDLGtDQUFrQztBQUVuQyxNQUFNdXJEO0lBQ0osQ0FBQ0MsdUJBQXVCLENBQVE7SUFDaEMsQ0FBQ0Msb0JBQW9CLENBQVE7SUFDN0IsQ0FBQ0Msc0JBQXNCLENBQVM7SUFDaEMsQ0FBQ2hoQixNQUFNLENBQVE7SUFDZixDQUFDaWhCLFdBQVcsQ0FBUTtJQUNwQixDQUFDQyxRQUFRLENBQVE7SUFDakIsQ0FBQy96QyxJQUFJLENBQVE7SUFDYixDQUFDK2YsSUFBSSxDQUFRO0lBQ2IsQ0FBQ2dzQixPQUFPLENBQVM7SUFDakIsQ0FBQ2lJLGFBQWEsQ0FBUTtJQUN0QnA5RCxZQUFZaThDLE1BQU0sQ0FBRTthQVZwQixDQUFDOGdCLHVCQUF1QixHQUFHO2FBQzNCLENBQUNDLG9CQUFvQixHQUFHO2FBQ3hCLENBQUNDLHNCQUFzQixHQUFHO2FBQzFCLENBQUNoaEIsTUFBTSxHQUFHO2FBQ1YsQ0FBQ2loQixXQUFXLEdBQUc7YUFDZixDQUFDQyxRQUFRLEdBQUc7YUFDWixDQUFDL3pDLElBQUksR0FBRzthQUNSLENBQUMrZixJQUFJLEdBQUc7YUFDUixDQUFDZ3NCLE9BQU8sR0FBRzthQUNYLENBQUNpSSxhQUFhLEdBQUc7UUFFZixJQUFJLENBQUMsQ0FBQ25oQixNQUFNLEdBQUdBO0lBQ2pCO0lBQ0F3QyxtQkFBbUI7UUFDakIsTUFBTVAsU0FBUyxJQUFJLENBQUMsQ0FBQzhlLG9CQUFvQixHQUFHcnlELFNBQVMySSxhQUFhLENBQUM7UUFDbkU0cUMsT0FBT3hELFNBQVMsR0FBRztRQUNuQixPQUFPLElBQUksQ0FBQyxDQUFDbk0sTUFBTSxDQUFDMlAsUUFBUTtJQUM5QjtJQUNBbWYsc0JBQXNCO1FBQ3BCLE1BQU1uZixTQUFTLElBQUksQ0FBQyxDQUFDNmUsdUJBQXVCLEdBQUdweUQsU0FBUzJJLGFBQWEsQ0FBQztRQUN0RTRxQyxPQUFPeEQsU0FBUyxHQUFHO1FBQ25CLE1BQU13QyxXQUFXLElBQUksQ0FBQyxDQUFDakIsTUFBTSxDQUFDcWhCLHFCQUFxQjtRQUNuRCxJQUFJcGdCLFVBQVU7WUFDWixNQUFNLEVBQ0o1eUMsS0FBSyxFQUNOLEdBQUc0ekM7WUFDSjV6QyxNQUFNK3lDLGNBQWMsR0FBRyxDQUFDLEtBQUssRUFBRSxNQUFPLEtBQUksQ0FBQyxDQUFDcEIsTUFBTSxDQUFDYyxVQUFVLENBQUNLLFNBQVMsS0FBSyxRQUFRLElBQUlGLFFBQVEsQ0FBQyxFQUFFLEdBQUdBLFFBQVEsQ0FBQyxFQUFFLEVBQUUsOEJBQThCLENBQUM7WUFDbEo1eUMsTUFBTWd6QyxHQUFHLEdBQUcsQ0FBQyxLQUFLLEVBQUUsTUFBTUosUUFBUSxDQUFDLEVBQUUsQ0FBQyw4QkFBOEIsQ0FBQztZQUNyRSxNQUFNdEgsUUFBUSxJQUFJLENBQUMsQ0FBQ3FHLE1BQU0sQ0FBQ3NoQixrQkFBa0I7WUFDN0MsSUFBSTNuQixPQUFPO2dCQUNUdHJDLE1BQU1rekQsZUFBZSxHQUFHNW5CO1lBQzFCO1FBQ0Y7UUFDQSxPQUFPLElBQUksQ0FBQyxDQUFDckgsTUFBTSxDQUFDMlAsUUFBUTtJQUM5QjtJQUNBdWYsY0FBYztRQUNaOUcsV0FBVztZQUNSLEtBQUksQ0FBQyxDQUFDb0csdUJBQXVCLElBQUksSUFBSSxDQUFDLENBQUNDLG9CQUFvQixHQUFHek87UUFDakUsR0FBRztJQUNMO0lBQ0FtUCxpQkFBaUI7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNYLHVCQUF1QixFQUFFO1lBQ2xDO1FBQ0Y7UUFDQSxNQUFNbm5CLFFBQVEsSUFBSSxDQUFDLENBQUNxRyxNQUFNLENBQUNzaEIsa0JBQWtCO1FBQzdDLElBQUkzbkIsT0FBTztZQUNULElBQUksQ0FBQyxDQUFDbW5CLHVCQUF1QixDQUFDenlELEtBQUssQ0FBQ2t6RCxlQUFlLEdBQUc1bkI7UUFDeEQ7UUFDQSxJQUFJLENBQUMsQ0FBQ3FHLE1BQU0sQ0FBQ2MsVUFBVSxDQUFDcVEsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUNuUixNQUFNO0lBQ3ZEO0lBQ0EsSUFBSTBoQixxQkFBcUI7UUFDdkIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDWix1QkFBdUIsRUFBRXBPLHdCQUF3QjVjLFNBQVMsS0FBSyxJQUFJLENBQUMsQ0FBQ2tLLE1BQU0sQ0FBQy9NLE1BQU0sQ0FBQzB1QixrQkFBa0IsQ0FBQzdyQixLQUFLO0lBQzNIO0lBQ0EsSUFBSThyQiw4QkFBOEI7UUFDaEMsSUFBSSxJQUFJLENBQUMsQ0FBQ1QsYUFBYSxFQUFFO1lBQ3ZCLE9BQU8sSUFBSSxDQUFDLENBQUNBLGFBQWE7UUFDNUI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNMLHVCQUF1QixFQUFFO1lBQ2xDLE9BQU87UUFDVDtRQUNBLE1BQU0sRUFDSng1RCxDQUFDLEVBQ0QwTSxDQUFDLEVBQ0QraEMsTUFBTSxFQUNQLEdBQUcsSUFBSSxDQUFDLENBQUMrcUIsdUJBQXVCLENBQUNwTyxxQkFBcUI7UUFDdkQsTUFBTSxFQUNKcHJELEdBQUd1NkQsT0FBTyxFQUNWN3RELEdBQUc4dEQsT0FBTyxFQUNWaHNCLE9BQU9nb0IsV0FBVyxFQUNsQi9uQixRQUFRZ29CLFlBQVksRUFDckIsR0FBRyxJQUFJLENBQUMsQ0FBQy9kLE1BQU0sQ0FBQy9NLE1BQU0sQ0FBQzB1QixrQkFBa0I7UUFDMUMsT0FBTztZQUFFcjZELENBQUFBLElBQUl1NkQsT0FBTSxJQUFLL0Q7WUFBYzlwRCxDQUFBQSxJQUFJK2hDLFNBQVMrckIsT0FBTSxJQUFLL0Q7U0FBYTtJQUM3RTtJQUNBLElBQUk2RCw0QkFBNEIvNUIsR0FBRyxFQUFFO1FBQ25DLElBQUksQ0FBQyxDQUFDczVCLGFBQWEsR0FBR3Q1QjtJQUN4QjtJQUNBazZCLDBCQUEwQjtRQUN4QixPQUFPLElBQUksQ0FBQyxDQUFDWixhQUFhLEtBQUs7SUFDakM7SUFDQWEsZ0NBQWdDO1FBQzlCLElBQUksQ0FBQyxDQUFDbEIsdUJBQXVCLEVBQUUvcUQ7UUFDL0IsSUFBSSxDQUFDLENBQUMrcUQsdUJBQXVCLEdBQUc7SUFDbEM7SUFDQTlkLDZCQUE2QjtRQUMzQixJQUFJLENBQUMsQ0FBQytkLG9CQUFvQixFQUFFaHJEO1FBQzVCLElBQUksQ0FBQyxDQUFDZ3JELG9CQUFvQixHQUFHO0lBQy9CO0lBQ0FrQix1QkFBdUIsRUFDckJyd0IsUUFBUSxFQUNSc3dCLFFBQVEsRUFDVCxFQUFFO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDcEIsdUJBQXVCLEVBQUU7WUFDbEM7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDQSx1QkFBdUIsQ0FBQ2xrQixTQUFTLENBQUMrVixNQUFNLENBQUMsWUFBWS9nQjtRQUMzRCxJQUFJLENBQUMsQ0FBQ2t2Qix1QkFBdUIsQ0FBQ3FCLFlBQVksR0FBR0Q7SUFDL0M7SUFDQSxDQUFDNXZCLE1BQU0sQ0FBQzZOLE9BQU8sRUFBRWlpQixZQUFZO1FBQzNCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ3BpQixNQUFNLENBQUNjLFVBQVUsQ0FBQzhDLGlCQUFpQixJQUFJO1lBQ2hELE9BQU87UUFDVDtRQUNBekQsUUFBUStCLFFBQVEsR0FBRztRQUNuQi9CLFFBQVFraUIsWUFBWSxHQUFHO1FBQ3ZCLElBQUlELGNBQWM7WUFDaEJqaUIsUUFBUW1pQixZQUFZLEdBQUc7WUFDdkJuaUIsUUFBUTdPLFlBQVksQ0FBQyxnQkFBZ0I7UUFDdkMsT0FBTztZQUNMNk8sUUFBUW9pQixvQkFBb0IsR0FBRztnQkFBQyxJQUFJLENBQUMsQ0FBQ3ZpQixNQUFNLENBQUNjLFVBQVUsQ0FBQzJRLHVCQUF1QjthQUFHO1lBQ2xGdFIsUUFBUTdPLFlBQVksQ0FBQyxnQkFBZ0I7UUFDdkM7UUFDQSxNQUFNNUIsU0FBUyxJQUFJLENBQUMsQ0FBQ3NRLE1BQU0sQ0FBQ2MsVUFBVSxDQUFDQyxPQUFPO1FBQzlDLElBQUksQ0FBRXJSLENBQUFBLGtCQUFrQkosV0FBVSxLQUFNSSxPQUFPQyxPQUFPLEVBQUU7WUFDdEQsT0FBT3dRO1FBQ1Q7UUFDQUEsUUFBUXJRLGdCQUFnQixDQUFDLGVBQWV1SSxlQUFlO1lBQ3JEM0k7UUFDRjtRQUNBLElBQUkweUIsY0FBYztZQUNoQmppQixRQUFRclEsZ0JBQWdCLENBQUMsV0FBVzM1QixDQUFBQTtnQkFDbEMsSUFBSSxDQUFDLENBQUM2cEMsTUFBTSxDQUFDdUIsbUJBQW1CLEdBQUc7Z0JBQ25DaEosVUFBVXBpQztZQUNaLEdBQUc7Z0JBQ0R1ckMsU0FBUztnQkFDVGhTO1lBQ0Y7WUFDQXlRLFFBQVFyUSxnQkFBZ0IsQ0FBQyxZQUFZMzVCLENBQUFBO2dCQUNuQyxJQUFJLENBQUMsQ0FBQzZwQyxNQUFNLENBQUN1QixtQkFBbUIsR0FBRztnQkFDbkNoSixVQUFVcGlDO1lBQ1osR0FBRztnQkFDRHVyQyxTQUFTO2dCQUNUaFM7WUFDRjtRQUNGO1FBQ0F5USxRQUFRclEsZ0JBQWdCLENBQUMsZUFBZXFCLENBQUFBLFFBQVNBLE1BQU1xSCxlQUFlLElBQUk7WUFDeEU5STtRQUNGO1FBQ0EsTUFBTWl3QixVQUFVeHVCLENBQUFBO1lBQ2RBLE1BQU1tSCxjQUFjO1lBQ3BCLElBQUk2SCxZQUFZLElBQUksQ0FBQyxDQUFDNGdCLG9CQUFvQixFQUFFO2dCQUMxQyxJQUFJLENBQUN5QixJQUFJO1lBQ1gsT0FBTztnQkFDTCxJQUFJLENBQUMsQ0FBQ3hpQixNQUFNLENBQUNnUixhQUFhLENBQUM7WUFDN0I7UUFDRjtRQUNBN1EsUUFBUXJRLGdCQUFnQixDQUFDLFNBQVM2dkIsU0FBUztZQUN6Q2plLFNBQVM7WUFDVGhTO1FBQ0Y7UUFDQXlRLFFBQVFyUSxnQkFBZ0IsQ0FBQyxXQUFXcUIsQ0FBQUE7WUFDbEMsSUFBSUEsTUFBTWh3QyxNQUFNLEtBQUtnL0MsV0FBV2hQLE1BQU1wbEMsR0FBRyxLQUFLLFNBQVM7Z0JBQ3JELElBQUksQ0FBQyxDQUFDaTFELHNCQUFzQixHQUFHO2dCQUMvQnJCLFFBQVF4dUI7WUFDVjtRQUNGLEdBQUc7WUFDRHpCO1FBQ0Y7UUFDQXlRLFFBQVFyUSxnQkFBZ0IsQ0FBQyxnQkFBZ0I7WUFDdkMsSUFBSSxDQUFDLENBQUNrUSxNQUFNLENBQUNnUixhQUFhLENBQUMsT0FBTztRQUNwQyxHQUFHO1lBQ0R0aEI7UUFDRjtRQUNBeVEsUUFBUXJRLGdCQUFnQixDQUFDLGdCQUFnQjtZQUN2QyxJQUFJLENBQUMsQ0FBQ2tRLE1BQU0sQ0FBQ2dSLGFBQWEsQ0FBQyxPQUFPO1FBQ3BDLEdBQUc7WUFDRHRoQjtRQUNGO1FBQ0EsT0FBT3lRO0lBQ1Q7SUFDQXFpQixLQUFLOStELE9BQU8sRUFBRTtRQUNaLE1BQU11OUMsV0FBVyxJQUFJLENBQUMyZ0IsMkJBQTJCO1FBQ2pELElBQUlsUixNQUFNQztRQUNWLElBQUkxUCxVQUFVO1lBQ1osQ0FBQ3lQLE1BQU1DLEtBQUssR0FBRzFQO1FBQ2pCLE9BQU87WUFDTCxDQUFDeVAsTUFBTUMsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDM1EsTUFBTSxDQUFDcWhCLHFCQUFxQjtZQUNqRCxNQUFNLEVBQ0p2ckIsS0FBSyxFQUNMQyxNQUFNLEVBQ056dUMsQ0FBQyxFQUNEME0sQ0FBQyxFQUNGLEdBQUcsSUFBSSxDQUFDLENBQUNnc0MsTUFBTTtZQUNoQjBRLE9BQU9wcEQsSUFBSW9wRCxPQUFPNWE7WUFDbEI2YSxPQUFPMzhDLElBQUkyOEMsT0FBTzVhO1FBQ3BCO1FBQ0EsTUFBTTBzQixtQkFBbUIsSUFBSSxDQUFDLENBQUN6aUIsTUFBTSxDQUFDL00sTUFBTSxDQUFDMHVCLGtCQUFrQjtRQUMvRCxNQUFNLEVBQ0pyNkQsR0FBR3U2RCxPQUFPLEVBQ1Y3dEQsR0FBRzh0RCxPQUFPLEVBQ1Zoc0IsT0FBT2dvQixXQUFXLEVBQ2xCL25CLFFBQVFnb0IsWUFBWSxFQUNyQixHQUFHMEU7UUFDSixJQUFJLENBQUMsQ0FBQ3ppQixNQUFNLENBQUNjLFVBQVUsQ0FBQzJQLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQ3pRLE1BQU0sRUFBRTZoQixVQUFVblIsT0FBT29OLGFBQWFnRSxVQUFVblIsT0FBT29OLGNBQWM7WUFDN0csR0FBR3I2RCxPQUFPO1lBQ1YrK0Q7UUFDRjtJQUNGO0lBQ0EzQyxTQUFTO1FBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDaUIsb0JBQW9CLEVBQUU7WUFDL0I7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDQSxvQkFBb0IsQ0FBQ3pPLEtBQUssQ0FBQztZQUMvQnlOLGNBQWMsSUFBSSxDQUFDLENBQUNpQixzQkFBc0I7UUFDNUM7UUFDQSxJQUFJLENBQUMsQ0FBQ0Esc0JBQXNCLEdBQUc7SUFDakM7SUFDQTBCLFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQyxDQUFDeEosT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDL3JDLElBQUksS0FBSztJQUN6QztJQUNBMGdDLFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQyxDQUFDMWdDLElBQUksS0FBSztJQUN4QjtJQUNBdzFDLGdCQUFnQjtRQUNkLE9BQU8sSUFBSSxDQUFDRCxTQUFTLE1BQU0sSUFBSSxDQUFDLENBQUN2MUMsSUFBSSxLQUFLLElBQUksQ0FBQyxDQUFDOHpDLFdBQVc7SUFDN0Q7SUFDQXZZLFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQ3gzQyxJQUFJO0lBQ2xCO0lBQ0EsSUFBSUEsT0FBTztRQUNULE9BQU87WUFDTGljLE1BQU0sSUFBSSxDQUFDLENBQUNBLElBQUk7WUFDaEIrekMsVUFBVSxJQUFJLENBQUMsQ0FBQ0EsUUFBUTtZQUN4QmgwQixNQUFNLElBQUksQ0FBQyxDQUFDQSxJQUFJO1lBQ2hCZ3NCLFNBQVMsSUFBSSxDQUFDd0osU0FBUztRQUN6QjtJQUNGO0lBQ0EsSUFBSXh4RCxLQUFLaWMsSUFBSSxFQUFFO1FBQ2IsSUFBSUEsU0FBUyxJQUFJLENBQUMsQ0FBQ0EsSUFBSSxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxDQUFDK3pDLFFBQVEsR0FBRztRQUNuQjtRQUNBLElBQUkvekMsU0FBUyxNQUFNO1lBQ2pCLElBQUksQ0FBQyxDQUFDQSxJQUFJLEdBQUc7WUFDYixJQUFJLENBQUMsQ0FBQytyQyxPQUFPLEdBQUc7WUFDaEI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDL3JDLElBQUksR0FBR0E7UUFDYixJQUFJLENBQUMsQ0FBQytmLElBQUksR0FBRyxJQUFJQztRQUNqQixJQUFJLENBQUMsQ0FBQytyQixPQUFPLEdBQUc7SUFDbEI7SUFDQTBKLGVBQWV6MUMsSUFBSSxFQUFFK3pDLFdBQVcsSUFBSSxFQUFFO1FBQ3BDLElBQUksQ0FBQyxDQUFDRCxXQUFXLEdBQUc5ekM7UUFDcEIsSUFBSSxDQUFDamMsSUFBSSxHQUFHaWM7UUFDWixJQUFJLENBQUMsQ0FBQytmLElBQUksR0FBRztRQUNiLElBQUksQ0FBQyxDQUFDZzBCLFFBQVEsR0FBR0E7SUFDbkI7SUFDQXBmLFFBQVEsQ0FBQztJQUNUMkIsVUFBVTtRQUNSLElBQUksQ0FBQyxDQUFDc2Qsb0JBQW9CLEVBQUVockQ7UUFDNUIsSUFBSSxDQUFDLENBQUNnckQsb0JBQW9CLEdBQUc7UUFDN0IsSUFBSSxDQUFDLENBQUNELHVCQUF1QixFQUFFL3FEO1FBQy9CLElBQUksQ0FBQyxDQUFDK3FELHVCQUF1QixHQUFHO1FBQ2hDLElBQUksQ0FBQyxDQUFDM3pDLElBQUksR0FBRztRQUNiLElBQUksQ0FBQyxDQUFDK3pDLFFBQVEsR0FBRztRQUNqQixJQUFJLENBQUMsQ0FBQ2gwQixJQUFJLEdBQUc7UUFDYixJQUFJLENBQUMsQ0FBQzhTLE1BQU0sR0FBRztRQUNmLElBQUksQ0FBQyxDQUFDZ2hCLHNCQUFzQixHQUFHO1FBQy9CLElBQUksQ0FBQyxDQUFDOUgsT0FBTyxHQUFHO0lBQ2xCO0FBQ0Y7RUFFQyxpQ0FBaUM7QUFFbEMsTUFBTTJKO0lBQ0osQ0FBQ25rQixTQUFTLENBQUM7SUFDWCxDQUFDb2tCLFVBQVUsQ0FBUztJQUNwQixDQUFDQyxpQkFBaUIsQ0FBUTtJQUMxQixDQUFDQyxrQkFBa0IsQ0FBQztJQUNwQixDQUFDQyxZQUFZLENBQUM7SUFDZCxDQUFDQyxVQUFVLENBQUM7SUFDWixDQUFDQyxVQUFVLENBQUM7SUFDWixDQUFDQyxhQUFhLENBQVE7SUFDdEIsQ0FBQzF6QixNQUFNLENBQUM7SUFDUixDQUFDMnpCLFNBQVMsQ0FBUTtJQUNsQixDQUFDQyxjQUFjLENBQUM7SUFDaEIsQ0FBQ0MsV0FBVyxDQUFRO0lBQ3BCeC9ELFlBQVksRUFDVjI2QyxTQUFTLEVBQ1Rza0IscUJBQXFCLElBQUksRUFDekJELG9CQUFvQixJQUFJLEVBQ3hCRSxlQUFlLElBQUksRUFDbkJDLGFBQWEsSUFBSSxFQUNqQkMsYUFBYSxJQUFJLEVBQ2pCenpCLE1BQU0sRUFDUCxDQUFFO2FBbkJILENBQUNvekIsVUFBVSxHQUFHO2FBQ2QsQ0FBQ0MsaUJBQWlCLEdBQUc7YUFLckIsQ0FBQ0ssYUFBYSxHQUFHO2FBRWpCLENBQUNDLFNBQVMsR0FBRzthQUViLENBQUNFLFdBQVcsR0FBRztRQVViLElBQUksQ0FBQyxDQUFDN2tCLFNBQVMsR0FBR0E7UUFDbEIsSUFBSSxDQUFDLENBQUNxa0IsaUJBQWlCLEdBQUdBO1FBQzFCLElBQUksQ0FBQyxDQUFDQyxrQkFBa0IsR0FBR0E7UUFDM0IsSUFBSSxDQUFDLENBQUNDLFlBQVksR0FBR0E7UUFDckIsSUFBSSxDQUFDLENBQUNDLFVBQVUsR0FBR0E7UUFDbkIsSUFBSSxDQUFDLENBQUNDLFVBQVUsR0FBR0E7UUFDbkIsSUFBSSxDQUFDLENBQUNHLGNBQWMsR0FBRyxJQUFJN3pCO1FBQzNCLElBQUksQ0FBQyxDQUFDQyxNQUFNLEdBQUdKLFlBQVlDLEdBQUcsQ0FBQztZQUFDRztZQUFRLElBQUksQ0FBQyxDQUFDNHpCLGNBQWMsQ0FBQzV6QixNQUFNO1NBQUM7UUFDcEVnUCxVQUFVNU8sZ0JBQWdCLENBQUMsY0FBYyxJQUFJLENBQUMsQ0FBQzB6QixZQUFZLENBQUM5OEQsSUFBSSxDQUFDLElBQUksR0FBRztZQUN0RSs4RCxTQUFTO1lBQ1QvekIsUUFBUSxJQUFJLENBQUMsQ0FBQ0EsTUFBTTtRQUN0QjtJQUNGO0lBQ0EsSUFBSWcwQiw4QkFBOEI7UUFDaEMsT0FBTyxLQUFLeG9CLFlBQVlDLFVBQVU7SUFDcEM7SUFDQSxDQUFDcW9CLFlBQVksQ0FBQ2pWLEdBQUc7UUFDZixJQUFJLElBQUksQ0FBQyxDQUFDeVUsa0JBQWtCLE1BQU07WUFDaEM7UUFDRjtRQUNBLElBQUl6VSxJQUFJb1YsT0FBTyxDQUFDaGpFLE1BQU0sS0FBSyxHQUFHO1lBQzVCLElBQUksSUFBSSxDQUFDLENBQUN5aUUsYUFBYSxFQUFFO2dCQUN2QjtZQUNGO1lBQ0EsTUFBTUEsZ0JBQWdCLElBQUksQ0FBQyxDQUFDQSxhQUFhLEdBQUcsSUFBSTN6QjtZQUNoRCxNQUFNQyxTQUFTSixZQUFZQyxHQUFHLENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUNHLE1BQU07Z0JBQUUwekIsY0FBYzF6QixNQUFNO2FBQUM7WUFDbkUsTUFBTWdQLFlBQVksSUFBSSxDQUFDLENBQUNBLFNBQVM7WUFDakMsTUFBTWtsQixPQUFPO2dCQUNYbGlCLFNBQVM7Z0JBQ1RoUztnQkFDQSt6QixTQUFTO1lBQ1g7WUFDQSxNQUFNSSxvQkFBb0IxdEQsQ0FBQUE7Z0JBQ3hCLElBQUlBLEVBQUUydEQsV0FBVyxLQUFLLFNBQVM7b0JBQzdCLElBQUksQ0FBQyxDQUFDVixhQUFhLEVBQUV4ekI7b0JBQ3JCLElBQUksQ0FBQyxDQUFDd3pCLGFBQWEsR0FBRztnQkFDeEI7WUFDRjtZQUNBMWtCLFVBQVU1TyxnQkFBZ0IsQ0FBQyxlQUFlMzVCLENBQUFBO2dCQUN4QyxJQUFJQSxFQUFFMnRELFdBQVcsS0FBSyxTQUFTO29CQUM3QnZyQixVQUFVcGlDO29CQUNWMHRELGtCQUFrQjF0RDtnQkFDcEI7WUFDRixHQUFHeXREO1lBQ0hsbEIsVUFBVTVPLGdCQUFnQixDQUFDLGFBQWErekIsbUJBQW1CRDtZQUMzRGxsQixVQUFVNU8sZ0JBQWdCLENBQUMsaUJBQWlCK3pCLG1CQUFtQkQ7WUFDL0Q7UUFDRjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ0wsV0FBVyxFQUFFO1lBQ3RCLElBQUksQ0FBQyxDQUFDQSxXQUFXLEdBQUcsSUFBSTl6QjtZQUN4QixNQUFNQyxTQUFTSixZQUFZQyxHQUFHLENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUNHLE1BQU07Z0JBQUUsSUFBSSxDQUFDLENBQUM2ekIsV0FBVyxDQUFDN3pCLE1BQU07YUFBQztZQUN2RSxNQUFNZ1AsWUFBWSxJQUFJLENBQUMsQ0FBQ0EsU0FBUztZQUNqQyxNQUFNcWxCLE1BQU07Z0JBQ1ZyMEI7Z0JBQ0FnUyxTQUFTO2dCQUNUK2hCLFNBQVM7WUFDWDtZQUNBL2tCLFVBQVU1TyxnQkFBZ0IsQ0FBQyxhQUFhLElBQUksQ0FBQyxDQUFDazBCLFdBQVcsQ0FBQ3Q5RCxJQUFJLENBQUMsSUFBSSxHQUFHcTlEO1lBQ3RFLE1BQU1FLGFBQWEsSUFBSSxDQUFDLENBQUNBLFVBQVUsQ0FBQ3Y5RCxJQUFJLENBQUMsSUFBSTtZQUM3Q2c0QyxVQUFVNU8sZ0JBQWdCLENBQUMsWUFBWW0wQixZQUFZRjtZQUNuRHJsQixVQUFVNU8sZ0JBQWdCLENBQUMsZUFBZW0wQixZQUFZRjtZQUN0REEsSUFBSXJpQixPQUFPLEdBQUc7WUFDZGhELFVBQVU1TyxnQkFBZ0IsQ0FBQyxlQUFleUksV0FBV3dyQjtZQUNyRHJsQixVQUFVNU8sZ0JBQWdCLENBQUMsZUFBZXlJLFdBQVd3ckI7WUFDckRybEIsVUFBVTVPLGdCQUFnQixDQUFDLGlCQUFpQnlJLFdBQVd3ckI7WUFDdkRybEIsVUFBVTVPLGdCQUFnQixDQUFDLGFBQWF5SSxXQUFXd3JCO1lBQ25ELElBQUksQ0FBQyxDQUFDZCxZQUFZO1FBQ3BCO1FBQ0ExcUIsVUFBVWdXO1FBQ1YsSUFBSUEsSUFBSW9WLE9BQU8sQ0FBQ2hqRSxNQUFNLEtBQUssS0FBSyxJQUFJLENBQUMsQ0FBQ29pRSxpQkFBaUIsTUFBTTtZQUMzRCxJQUFJLENBQUMsQ0FBQ00sU0FBUyxHQUFHO1lBQ2xCO1FBQ0Y7UUFDQSxJQUFJLENBQUNhLFFBQVFDLE9BQU8sR0FBRzVWLElBQUlvVixPQUFPO1FBQ2xDLElBQUlPLE9BQU9FLFVBQVUsR0FBR0QsT0FBT0MsVUFBVSxFQUFFO1lBQ3pDLENBQUNGLFFBQVFDLE9BQU8sR0FBRztnQkFBQ0E7Z0JBQVFEO2FBQU87UUFDckM7UUFDQSxJQUFJLENBQUMsQ0FBQ2IsU0FBUyxHQUFHO1lBQ2hCZ0IsU0FBU0gsT0FBT0ksT0FBTztZQUN2QkMsU0FBU0wsT0FBT00sT0FBTztZQUN2QkMsU0FBU04sT0FBT0csT0FBTztZQUN2QkksU0FBU1AsT0FBT0ssT0FBTztRQUN6QjtJQUNGO0lBQ0EsQ0FBQ1IsV0FBVyxDQUFDelYsR0FBRztRQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzhVLFNBQVMsSUFBSTlVLElBQUlvVixPQUFPLENBQUNoakUsTUFBTSxLQUFLLEdBQUc7WUFDaEQ7UUFDRjtRQUNBNDNDLFVBQVVnVztRQUNWLElBQUksQ0FBQzJWLFFBQVFDLE9BQU8sR0FBRzVWLElBQUlvVixPQUFPO1FBQ2xDLElBQUlPLE9BQU9FLFVBQVUsR0FBR0QsT0FBT0MsVUFBVSxFQUFFO1lBQ3pDLENBQUNGLFFBQVFDLE9BQU8sR0FBRztnQkFBQ0E7Z0JBQVFEO2FBQU87UUFDckM7UUFDQSxNQUFNLEVBQ0pJLFNBQVNLLFFBQVEsRUFDakJILFNBQVNJLFFBQVEsRUFDbEIsR0FBR1Y7UUFDSixNQUFNLEVBQ0pJLFNBQVNPLFFBQVEsRUFDakJMLFNBQVNNLFFBQVEsRUFDbEIsR0FBR1g7UUFDSixNQUFNZCxZQUFZLElBQUksQ0FBQyxDQUFDQSxTQUFTO1FBQ2pDLE1BQU0sRUFDSmdCLFNBQVNVLFFBQVEsRUFDakJSLFNBQVNTLFFBQVEsRUFDakJQLFNBQVNRLFFBQVEsRUFDakJQLFNBQVNRLFFBQVEsRUFDbEIsR0FBRzdCO1FBQ0osTUFBTThCLFdBQVdGLFdBQVdGO1FBQzVCLE1BQU1LLFdBQVdGLFdBQVdGO1FBQzVCLE1BQU1LLFdBQVdSLFdBQVdGO1FBQzVCLE1BQU1XLFdBQVdSLFdBQVdGO1FBQzVCLE1BQU1XLFdBQVdwK0QsS0FBS3ErRCxLQUFLLENBQUNILFVBQVVDLGFBQWE7UUFDbkQsTUFBTUcsWUFBWXQrRCxLQUFLcStELEtBQUssQ0FBQ0wsVUFBVUMsYUFBYTtRQUNwRCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUN0QyxVQUFVLElBQUkzN0QsS0FBSytMLEdBQUcsQ0FBQ3V5RCxZQUFZRixhQUFhMUMsYUFBYWEsMkJBQTJCLEVBQUU7WUFDbkc7UUFDRjtRQUNBTCxVQUFVZ0IsT0FBTyxHQUFHTTtRQUNwQnRCLFVBQVVrQixPQUFPLEdBQUdLO1FBQ3BCdkIsVUFBVW9CLE9BQU8sR0FBR0k7UUFDcEJ4QixVQUFVcUIsT0FBTyxHQUFHSTtRQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNoQyxVQUFVLEVBQUU7WUFDckIsSUFBSSxDQUFDLENBQUNBLFVBQVUsR0FBRztZQUNuQjtRQUNGO1FBQ0EsTUFBTTRDLFNBQVM7WUFBRWYsQ0FBQUEsV0FBV0UsUUFBTyxJQUFLO1lBQUlELENBQUFBLFdBQVdFLFFBQU8sSUFBSztTQUFFO1FBQ3JFLElBQUksQ0FBQyxDQUFDNUIsVUFBVSxHQUFHd0MsUUFBUUQsV0FBV0Y7SUFDeEM7SUFDQSxDQUFDdEIsVUFBVSxDQUFDMVYsR0FBRztRQUNiLElBQUlBLElBQUlvVixPQUFPLENBQUNoakUsTUFBTSxJQUFJLEdBQUc7WUFDM0I7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDLENBQUM0aUUsV0FBVyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxDQUFDQSxXQUFXLENBQUMzekIsS0FBSztZQUN2QixJQUFJLENBQUMsQ0FBQzJ6QixXQUFXLEdBQUc7WUFDcEIsSUFBSSxDQUFDLENBQUNKLFVBQVU7UUFDbEI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNFLFNBQVMsRUFBRTtZQUNwQjtRQUNGO1FBQ0E5cUIsVUFBVWdXO1FBQ1YsSUFBSSxDQUFDLENBQUM4VSxTQUFTLEdBQUc7UUFDbEIsSUFBSSxDQUFDLENBQUNQLFVBQVUsR0FBRztJQUNyQjtJQUNBcmYsVUFBVTtRQUNSLElBQUksQ0FBQyxDQUFDNmYsY0FBYyxFQUFFMXpCO1FBQ3RCLElBQUksQ0FBQyxDQUFDMHpCLGNBQWMsR0FBRztRQUN2QixJQUFJLENBQUMsQ0FBQ0YsYUFBYSxFQUFFeHpCO1FBQ3JCLElBQUksQ0FBQyxDQUFDd3pCLGFBQWEsR0FBRztJQUN4QjtBQUNGO0VBRUMsaUNBQWlDO0FBUWxDLE1BQU11QztJQUNKLENBQUNDLGlCQUFpQixDQUFRO0lBQzFCLENBQUNDLGNBQWMsQ0FBUTtJQUN2QixDQUFDM2xCLE9BQU8sQ0FBUTtJQUNoQixDQUFDQyxPQUFPLENBQVE7SUFDaEIsQ0FBQzJnQix1QkFBdUIsQ0FBUTtJQUNoQyxDQUFDTixRQUFRLENBQVM7SUFDbEIsQ0FBQ3NGLGFBQWEsQ0FBUTtJQUN0QixDQUFDQyxlQUFlLENBQU07SUFDdEIsQ0FBQ0MsV0FBVyxDQUFRO0lBQ3BCLENBQUNDLGlCQUFpQixDQUFRO0lBQzFCLENBQUNDLGVBQWUsQ0FBUTtJQUN4QixDQUFDQyxjQUFjLENBQVE7SUFDdkIsQ0FBQ0MsT0FBTyxDQUFRO0lBQ2hCLENBQUNDLGtCQUFrQixDQUFNO0lBQ3pCLENBQUNDLGNBQWMsQ0FBUztJQUN4QixDQUFDQyxXQUFXLENBQVE7SUFDcEIsQ0FBQzNZLFNBQVMsQ0FBUztJQUNuQixDQUFDNFksWUFBWSxDQUFTO0lBQ3RCLENBQUNDLDJCQUEyQixDQUFTO0lBQ3JDLENBQUNDLGdCQUFnQixDQUFRO0lBQ3pCLENBQUNDLFNBQVMsQ0FBSztJQUNmLENBQUNDLFNBQVMsQ0FBSztJQUNmLENBQUNDLGlCQUFpQixDQUFRO0lBQzFCLENBQUNDLFlBQVksQ0FBUTs7YUFTZHpILFFBQVE7OzthQUNSMEgsZUFBZTs7SUFDdEIsQ0FBQ0MsV0FBVyxDQUFTO0lBQ3JCLENBQUNDLE1BQU0sQ0FBOEI7O2FBQzlCQyxtQkFBbUIsQ0FBQzs7O2FBQ3BCQyxnQkFBZ0IsSUFBSWxlOzs7YUFDcEJtZSxVQUFVOzs7YUFDVkMsb0JBQW9COztJQUMzQixXQUFXQywwQkFBMEI7UUFDbkMsTUFBTUMsU0FBUzVCLGlCQUFpQjFoRSxTQUFTLENBQUN1akUsbUJBQW1CO1FBQzdELE1BQU14YSxRQUFRekQsMEJBQTBCOEMsZUFBZTtRQUN2RCxNQUFNWSxNQUFNMUQsMEJBQTBCK0MsYUFBYTtRQUNuRCxPQUFPbm9CLE9BQU8sSUFBSSxFQUFFLDJCQUEyQixJQUFJbWtCLGdCQUFnQjtZQUFDO2dCQUFDO29CQUFDO29CQUFhO2lCQUFnQjtnQkFBRWlmO2dCQUFRO29CQUMzRzM4RCxNQUFNO3dCQUFDLENBQUNvaUQ7d0JBQU87cUJBQUU7Z0JBQ25CO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBa0I7aUJBQXNCO2dCQUFFdWE7Z0JBQVE7b0JBQ3REMzhELE1BQU07d0JBQUMsQ0FBQ3FpRDt3QkFBSztxQkFBRTtnQkFDakI7YUFBRTtZQUFFO2dCQUFDO29CQUFDO29CQUFjO2lCQUFpQjtnQkFBRXNhO2dCQUFRO29CQUM3QzM4RCxNQUFNO3dCQUFDb2lEO3dCQUFPO3FCQUFFO2dCQUNsQjthQUFFO1lBQUU7Z0JBQUM7b0JBQUM7b0JBQW1CO2lCQUF1QjtnQkFBRXVhO2dCQUFRO29CQUN4RDM4RCxNQUFNO3dCQUFDcWlEO3dCQUFLO3FCQUFFO2dCQUNoQjthQUFFO1lBQUU7Z0JBQUM7b0JBQUM7b0JBQVc7aUJBQWM7Z0JBQUVzYTtnQkFBUTtvQkFDdkMzOEQsTUFBTTt3QkFBQzt3QkFBRyxDQUFDb2lEO3FCQUFNO2dCQUNuQjthQUFFO1lBQUU7Z0JBQUM7b0JBQUM7b0JBQWdCO2lCQUFvQjtnQkFBRXVhO2dCQUFRO29CQUNsRDM4RCxNQUFNO3dCQUFDO3dCQUFHLENBQUNxaUQ7cUJBQUk7Z0JBQ2pCO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBYTtpQkFBZ0I7Z0JBQUVzYTtnQkFBUTtvQkFDM0MzOEQsTUFBTTt3QkFBQzt3QkFBR29pRDtxQkFBTTtnQkFDbEI7YUFBRTtZQUFFO2dCQUFDO29CQUFDO29CQUFrQjtpQkFBc0I7Z0JBQUV1YTtnQkFBUTtvQkFDdEQzOEQsTUFBTTt3QkFBQzt3QkFBR3FpRDtxQkFBSTtnQkFDaEI7YUFBRTtZQUFFO2dCQUFDO29CQUFDO29CQUFVO2lCQUFhO2dCQUFFMFksaUJBQWlCMWhFLFNBQVMsQ0FBQ3dqRSx5QkFBeUI7YUFBQztTQUFDO0lBQ3ZGO0lBQ0ExakUsWUFBWXd1QyxVQUFVLENBQUU7YUE5RHhCLENBQUNxekIsaUJBQWlCLEdBQUc7YUFDckIsQ0FBQ0MsY0FBYyxHQUFHO2FBQ2xCLENBQUMzbEIsT0FBTyxHQUFHO2FBQ1gsQ0FBQ0MsT0FBTyxHQUFHO2FBQ1gsQ0FBQzJnQix1QkFBdUIsR0FBRzthQUMzQixDQUFDTixRQUFRLEdBQUc7YUFDWixDQUFDc0YsYUFBYSxHQUFHO2FBQ2pCLENBQUNDLGVBQWUsR0FBRzthQUNuQixDQUFDQyxXQUFXLEdBQUc7YUFDZixDQUFDQyxpQkFBaUIsR0FBRzthQUNyQixDQUFDQyxlQUFlLEdBQUc7YUFDbkIsQ0FBQ0MsY0FBYyxHQUFHO2FBQ2xCLENBQUNDLE9BQU8sR0FBRzthQUNYLENBQUNDLGtCQUFrQixHQUFHO2FBQ3RCLENBQUNDLGNBQWMsR0FBRzthQUNsQixDQUFDQyxXQUFXLEdBQUc7YUFDZixDQUFDM1ksU0FBUyxHQUFHO2FBQ2IsQ0FBQzRZLFlBQVksR0FBRzthQUNoQixDQUFDQywyQkFBMkIsR0FBRzthQUMvQixDQUFDQyxnQkFBZ0IsR0FBRzthQUNwQixDQUFDQyxTQUFTLEdBQUc7YUFDYixDQUFDQyxTQUFTLEdBQUc7YUFDYixDQUFDQyxpQkFBaUIsR0FBRzthQUNyQixDQUFDQyxZQUFZLEdBQUc7YUFDaEJ4VixhQUFhO2FBQ2JvVyxVQUFVO2FBQ1ZDLGVBQWU7YUFDZkMsa0JBQWtCNWtFLE9BQU8rTCxNQUFNLENBQUM7YUFDaEM4NEQsZUFBZTthQUNmQyxhQUFhO2FBQ2JobkIsYUFBYTthQUNiUyxzQkFBc0I7YUFHdEIsQ0FBQ3lsQixXQUFXLEdBQUc7YUFDZixDQUFDQyxNQUFNLEdBQUd0QixpQkFBaUJ5QixPQUFPO1FBNEJoQyxJQUFJLENBQUNuMEIsTUFBTSxHQUFHVixXQUFXVSxNQUFNO1FBQy9CLElBQUksQ0FBQzM5QixFQUFFLEdBQUdpOUIsV0FBV2o5QixFQUFFO1FBQ3ZCLElBQUksQ0FBQ3dnQyxLQUFLLEdBQUcsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDM0IsSUFBSSxDQUFDK2EsU0FBUyxHQUFHdmUsV0FBV1UsTUFBTSxDQUFDNmQsU0FBUztRQUM1QyxJQUFJLENBQUNydEQsSUFBSSxHQUFHOHVDLFdBQVc5dUMsSUFBSTtRQUMzQixJQUFJLENBQUNvdkMsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDaU8sVUFBVSxHQUFHdk8sV0FBV29SLFNBQVM7UUFDdEMsSUFBSSxDQUFDcVYsbUJBQW1CLEdBQUc7UUFDM0IsSUFBSSxDQUFDK08sb0JBQW9CLEdBQUc7UUFDNUIsSUFBSSxDQUFDSCxlQUFlLENBQUNJLFVBQVUsR0FBR3oxQixXQUFXeTFCLFVBQVU7UUFDdkQsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztRQUMzQixJQUFJLENBQUNqUCxtQkFBbUIsR0FBR3ptQixXQUFXeW1CLG1CQUFtQixJQUFJO1FBQzdELElBQUksQ0FBQ2tQLFlBQVksR0FBRzMxQixXQUFXMjFCLFlBQVksSUFBSSxJQUFJLzZCO1FBQ25ELElBQUksQ0FBQ2c3QixnQkFBZ0IsR0FBRzUxQixXQUFXNDFCLGdCQUFnQixJQUFJO1FBQ3ZELE1BQU0sRUFDSmp6QixRQUFRLEVBQ1JjLFNBQVMsRUFDUEUsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLEtBQUssRUFDTEMsS0FBSyxFQUNOLEVBQ0YsR0FBRyxJQUFJLENBQUNwRCxNQUFNLENBQUNILFFBQVE7UUFDeEIsSUFBSSxDQUFDb0MsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNrekIsWUFBWSxHQUFHLENBQUMsTUFBTWx6QixXQUFXLElBQUksQ0FBQzRMLFVBQVUsQ0FBQzhOLGNBQWMsQ0FBQzFaLFFBQVEsSUFBSTtRQUNqRixJQUFJLENBQUNtekIsY0FBYyxHQUFHO1lBQUNueUI7WUFBV0M7U0FBVztRQUM3QyxJQUFJLENBQUNteUIsZUFBZSxHQUFHO1lBQUNseUI7WUFBT0M7U0FBTTtRQUNyQyxNQUFNLENBQUNQLE9BQU9DLE9BQU8sR0FBRyxJQUFJLENBQUMwc0IsZ0JBQWdCO1FBQzdDLElBQUksQ0FBQ243RCxDQUFDLEdBQUdpckMsV0FBV2pyQyxDQUFDLEdBQUd3dUM7UUFDeEIsSUFBSSxDQUFDOWhDLENBQUMsR0FBR3UrQixXQUFXditCLENBQUMsR0FBRytoQztRQUN4QixJQUFJLENBQUN3eUIsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ3JQLE9BQU8sR0FBRztJQUNqQjtJQUNBLElBQUlsWCxhQUFhO1FBQ2YsT0FBT2gvQyxPQUFPbUosY0FBYyxDQUFDLElBQUksRUFBRXBJLFdBQVcsQ0FBQ3lrRSxLQUFLO0lBQ3REO0lBQ0EsSUFBSTNnRCxPQUFPO1FBQ1QsT0FBTzdrQixPQUFPbUosY0FBYyxDQUFDLElBQUksRUFBRXBJLFdBQVcsQ0FBQzgwRCxXQUFXO0lBQzVEO0lBQ0EsV0FBVzRQLFdBQVc7UUFDcEIsT0FBTztJQUNUO0lBQ0EsV0FBV0Msb0JBQW9CO1FBQzdCLE9BQU92a0MsT0FBTyxJQUFJLEVBQUUscUJBQXFCLElBQUksQ0FBQ2dqQyxhQUFhLENBQUM3ZCxVQUFVLENBQUM7SUFDekU7SUFDQSxPQUFPcWYsd0JBQXdCM29CLE1BQU0sRUFBRTtRQUNyQyxNQUFNNG9CLGFBQWEsSUFBSUMsV0FBVztZQUNoQ3Z6RCxJQUFJMHFDLE9BQU8vTSxNQUFNLENBQUM2MUIsU0FBUztZQUMzQjcxQixRQUFRK00sT0FBTy9NLE1BQU07WUFDckIwUSxXQUFXM0QsT0FBT2MsVUFBVTtRQUM5QjtRQUNBOG5CLFdBQVc1UCxtQkFBbUIsR0FBR2haLE9BQU9nWixtQkFBbUI7UUFDM0Q0UCxXQUFXMVAsT0FBTyxHQUFHO1FBQ3JCMFAsV0FBVzluQixVQUFVLENBQUM4VCxzQkFBc0IsQ0FBQ2dVO0lBQy9DO0lBQ0EsT0FBT3BKLFdBQVdDLElBQUksRUFBRTNlLFVBQVUsRUFBRTtRQUNsQzZrQixpQkFBaUJ0RyxLQUFLLEtBQUtJO1FBQzNCa0csaUJBQWlCb0IsWUFBWSxLQUFLL2pFLE9BQU91OUMsTUFBTSxDQUFDO1lBQzlDL0osU0FBUztZQUNUdXlCLFdBQVc7WUFDWEMsVUFBVTtZQUNWQyxhQUFhO1lBQ2J4eUIsYUFBYTtZQUNieXlCLGNBQWM7WUFDZEMsWUFBWTtZQUNaQyxZQUFZO1FBQ2Q7UUFDQSxJQUFJekQsaUJBQWlCdUIsZ0JBQWdCLEtBQUssQ0FBQyxHQUFHO1lBQzVDO1FBQ0Y7UUFDQSxNQUFNNzRELFFBQVErckMsaUJBQWlCMXJDLFNBQVMyNkQsZUFBZTtRQUN2RDFELGlCQUFpQnVCLGdCQUFnQixHQUFHb0MsV0FBV2o3RCxNQUFNazdELGdCQUFnQixDQUFDLHVCQUF1QjtJQUMvRjtJQUNBLE9BQU96UCxvQkFBb0IwTyxLQUFLLEVBQUVnQixNQUFNLEVBQUUsQ0FBQztJQUMzQyxXQUFXL1IsNEJBQTRCO1FBQ3JDLE9BQU8sRUFBRTtJQUNYO0lBQ0EsT0FBT2xCLHlCQUF5QmtULElBQUksRUFBRTtRQUNwQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPeFQsTUFBTXYrQyxJQUFJLEVBQUV1N0IsTUFBTSxFQUFFO1FBQ3pCOVAsWUFBWTtJQUNkO0lBQ0EsSUFBSSszQixxQkFBcUI7UUFDdkIsT0FBTyxFQUFFO0lBQ1g7SUFDQSxJQUFJd08sZUFBZTtRQUNqQixPQUFPLElBQUksQ0FBQyxDQUFDMUMsV0FBVztJQUMxQjtJQUNBLElBQUkwQyxhQUFhOW5FLEtBQUssRUFBRTtRQUN0QixJQUFJLENBQUMsQ0FBQ29sRSxXQUFXLEdBQUdwbEU7UUFDcEIsSUFBSSxDQUFDaXhDLEdBQUcsRUFBRStKLFVBQVUrVixPQUFPLGFBQWEvd0Q7SUFDMUM7SUFDQSxJQUFJNlosTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDdTlDLG1CQUFtQixJQUFJLElBQUksQ0FBQzFqRCxFQUFFO0lBQzVDO0lBQ0EsSUFBSSszQyxpQkFBaUI7UUFDbkIsT0FBTztJQUNUO0lBQ0FzYyxTQUFTO1FBQ1AsTUFBTSxDQUFDenpCLFdBQVdDLFdBQVcsR0FBRyxJQUFJLENBQUNreUIsY0FBYztRQUNuRCxPQUFRLElBQUksQ0FBQ3VCLGNBQWM7WUFDekIsS0FBSztnQkFDSCxJQUFJLENBQUN0aUUsQ0FBQyxJQUFJLElBQUksQ0FBQ3l1QyxNQUFNLEdBQUdJLGFBQWNELENBQUFBLFlBQVk7Z0JBQ2xELElBQUksQ0FBQ2xpQyxDQUFDLElBQUksSUFBSSxDQUFDOGhDLEtBQUssR0FBR0ksWUFBYUMsQ0FBQUEsYUFBYTtnQkFDakQ7WUFDRixLQUFLO2dCQUNILElBQUksQ0FBQzd1QyxDQUFDLElBQUksSUFBSSxDQUFDd3VDLEtBQUssR0FBRztnQkFDdkIsSUFBSSxDQUFDOWhDLENBQUMsSUFBSSxJQUFJLENBQUMraEMsTUFBTSxHQUFHO2dCQUN4QjtZQUNGLEtBQUs7Z0JBQ0gsSUFBSSxDQUFDenVDLENBQUMsSUFBSSxJQUFJLENBQUN5dUMsTUFBTSxHQUFHSSxhQUFjRCxDQUFBQSxZQUFZO2dCQUNsRCxJQUFJLENBQUNsaUMsQ0FBQyxJQUFJLElBQUksQ0FBQzhoQyxLQUFLLEdBQUdJLFlBQWFDLENBQUFBLGFBQWE7Z0JBQ2pEO1lBQ0Y7Z0JBQ0UsSUFBSSxDQUFDN3VDLENBQUMsSUFBSSxJQUFJLENBQUN3dUMsS0FBSyxHQUFHO2dCQUN2QixJQUFJLENBQUM5aEMsQ0FBQyxJQUFJLElBQUksQ0FBQytoQyxNQUFNLEdBQUc7Z0JBQ3hCO1FBQ0o7UUFDQSxJQUFJLENBQUM4ekIsaUJBQWlCO0lBQ3hCO0lBQ0EzUyxZQUFZdDhDLE1BQU0sRUFBRTtRQUNsQixJQUFJLENBQUNrbUMsVUFBVSxDQUFDb1csV0FBVyxDQUFDdDhDO0lBQzlCO0lBQ0EsSUFBSTI0QyxlQUFlO1FBQ2pCLE9BQU8sSUFBSSxDQUFDelMsVUFBVSxDQUFDeVMsWUFBWTtJQUNyQztJQUNBdVcsa0JBQWtCO1FBQ2hCLElBQUksQ0FBQ2ozQixHQUFHLENBQUN4a0MsS0FBSyxDQUFDNDRELE1BQU0sR0FBRztJQUMxQjtJQUNBOEMsa0JBQWtCO1FBQ2hCLElBQUksQ0FBQ2wzQixHQUFHLENBQUN4a0MsS0FBSyxDQUFDNDRELE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQ0EsTUFBTTtJQUN0QztJQUNBK0MsVUFBVS8yQixNQUFNLEVBQUU7UUFDaEIsSUFBSUEsV0FBVyxNQUFNO1lBQ25CLElBQUksQ0FBQzZkLFNBQVMsR0FBRzdkLE9BQU82ZCxTQUFTO1lBQ2pDLElBQUksQ0FBQ3VYLGNBQWMsR0FBR3AxQixPQUFPbzFCLGNBQWM7UUFDN0MsT0FBTztZQUNMLElBQUksQ0FBQyxDQUFDNEIsWUFBWTtZQUNsQixJQUFJLENBQUMsQ0FBQzlELGNBQWMsRUFBRXB3RDtZQUN0QixJQUFJLENBQUMsQ0FBQ293RCxjQUFjLEdBQUc7UUFDekI7UUFDQSxJQUFJLENBQUNsekIsTUFBTSxHQUFHQTtJQUNoQjtJQUNBaTNCLFFBQVEvNEIsS0FBSyxFQUFFO1FBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQ29RLG1CQUFtQixFQUFFO1lBQzdCO1FBQ0Y7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMra0IsY0FBYyxFQUFFO1lBQ3pCLElBQUksQ0FBQ3J6QixNQUFNLENBQUNzbUIsV0FBVyxDQUFDLElBQUk7UUFDOUIsT0FBTztZQUNMLElBQUksQ0FBQyxDQUFDK00sY0FBYyxHQUFHO1FBQ3pCO0lBQ0Y7SUFDQTZELFNBQVNoNUIsS0FBSyxFQUFFO1FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQ29RLG1CQUFtQixFQUFFO1lBQzdCO1FBQ0Y7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDZ25CLGVBQWUsRUFBRTtZQUN6QjtRQUNGO1FBQ0EsTUFBTXBuRSxTQUFTZ3dDLE1BQU1pNUIsYUFBYTtRQUNsQyxJQUFJanBFLFFBQVE4eUQsUUFBUSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMzK0MsRUFBRSxDQUFDLENBQUMsR0FBRztZQUNsQztRQUNGO1FBQ0E2N0IsTUFBTW1ILGNBQWM7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQ3JGLE1BQU0sRUFBRW8zQixxQkFBcUI7WUFDckMsSUFBSSxDQUFDdlgsY0FBYztRQUNyQjtJQUNGO0lBQ0FBLGlCQUFpQjtRQUNmLElBQUksSUFBSSxDQUFDakYsT0FBTyxJQUFJO1lBQ2xCLElBQUksQ0FBQzkzQyxNQUFNO1FBQ2IsT0FBTztZQUNMLElBQUksQ0FBQzhsRCxNQUFNO1FBQ2I7SUFDRjtJQUNBQSxTQUFTO1FBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQzJLLFlBQVksSUFBSTtZQUN4QjtRQUNGO1FBQ0EsSUFBSSxDQUFDNVIsc0JBQXNCO0lBQzdCO0lBQ0FBLHlCQUF5QjtRQUN2QixJQUFJLENBQUM5VCxVQUFVLENBQUM4VCxzQkFBc0IsQ0FBQyxJQUFJO0lBQzdDO0lBQ0EwVixNQUFNaGpFLENBQUMsRUFBRTBNLENBQUMsRUFBRWdwRCxFQUFFLEVBQUVDLEVBQUUsRUFBRTtRQUNsQixNQUFNLENBQUNubkIsT0FBT0MsT0FBTyxHQUFHLElBQUksQ0FBQzBzQixnQkFBZ0I7UUFDN0MsQ0FBQ3pGLElBQUlDLEdBQUcsR0FBRyxJQUFJLENBQUNzTix1QkFBdUIsQ0FBQ3ZOLElBQUlDO1FBQzVDLElBQUksQ0FBQzMxRCxDQUFDLEdBQUcsQ0FBQ0EsSUFBSTAxRCxFQUFDLElBQUtsbkI7UUFDcEIsSUFBSSxDQUFDOWhDLENBQUMsR0FBRyxDQUFDQSxJQUFJaXBELEVBQUMsSUFBS2xuQjtRQUNwQixJQUFJLENBQUM4ekIsaUJBQWlCO0lBQ3hCO0lBQ0FXLGdCQUFnQkMsS0FBSyxFQUFFQyxLQUFLLEVBQUU7UUFDNUIsTUFBTSxDQUFDNU0sYUFBYUMsYUFBYSxHQUFHLElBQUksQ0FBQzBFLGdCQUFnQjtRQUN6RCxJQUFJLENBQUM2SCxLQUFLLENBQUNHLFFBQVEzTSxhQUFhNE0sUUFBUTNNLGNBQWMsSUFBSSxDQUFDam9CLEtBQUssR0FBR2dvQixhQUFhLElBQUksQ0FBQy9uQixNQUFNLEdBQUdnb0I7UUFDOUYsSUFBSSxDQUFDNE0sYUFBYTtJQUNwQjtJQUNBLENBQUNDLFNBQVMsQ0FBQyxDQUFDOTBCLE9BQU9DLE9BQU8sRUFBRXp1QyxDQUFDLEVBQUUwTSxDQUFDO1FBQzlCLENBQUMxTSxHQUFHME0sRUFBRSxHQUFHLElBQUksQ0FBQ3UyRCx1QkFBdUIsQ0FBQ2pqRSxHQUFHME07UUFDekMsSUFBSSxDQUFDMU0sQ0FBQyxJQUFJQSxJQUFJd3VDO1FBQ2QsSUFBSSxDQUFDOWhDLENBQUMsSUFBSUEsSUFBSStoQztRQUNkLElBQUksQ0FBQzgwQixjQUFjLENBQUMsSUFBSSxDQUFDdmpFLENBQUMsRUFBRSxJQUFJLENBQUMwTSxDQUFDO1FBQ2xDLElBQUksQ0FBQzYxRCxpQkFBaUI7SUFDeEI7SUFDQWUsVUFBVXRqRSxDQUFDLEVBQUUwTSxDQUFDLEVBQUU7UUFDZCxJQUFJLENBQUMsQ0FBQzQyRCxTQUFTLENBQUMsSUFBSSxDQUFDbkksZ0JBQWdCLEVBQUVuN0QsR0FBRzBNO0lBQzVDO0lBQ0Frb0QsZ0JBQWdCNTBELENBQUMsRUFBRTBNLENBQUMsRUFBRTtRQUNwQixJQUFJLENBQUMsQ0FBQ3V5RCxXQUFXLEtBQUs7WUFBQyxJQUFJLENBQUNqL0QsQ0FBQztZQUFFLElBQUksQ0FBQzBNLENBQUM7WUFBRSxJQUFJLENBQUM4aEMsS0FBSztZQUFFLElBQUksQ0FBQ0MsTUFBTTtTQUFDO1FBQy9ELElBQUksQ0FBQyxDQUFDNjBCLFNBQVMsQ0FBQyxJQUFJLENBQUN2QyxjQUFjLEVBQUUvZ0UsR0FBRzBNO1FBQ3hDLElBQUksQ0FBQzYrQixHQUFHLENBQUNpNEIsY0FBYyxDQUFDO1lBQ3RCQyxPQUFPO1FBQ1Q7SUFDRjtJQUNBNU8sa0JBQWtCO1FBQ2hCLElBQUksQ0FBQ3dPLGFBQWEsQ0FBQyxJQUFJLENBQUNyakUsQ0FBQyxFQUFFLElBQUksQ0FBQzBNLENBQUM7SUFDbkM7SUFDQWtwRCxLQUFLRixFQUFFLEVBQUVDLEVBQUUsRUFBRTtRQUNYLElBQUksQ0FBQyxDQUFDc0osV0FBVyxLQUFLO1lBQUMsSUFBSSxDQUFDai9ELENBQUM7WUFBRSxJQUFJLENBQUMwTSxDQUFDO1lBQUUsSUFBSSxDQUFDOGhDLEtBQUs7WUFBRSxJQUFJLENBQUNDLE1BQU07U0FBQztRQUMvRCxNQUFNLEVBQ0psRCxHQUFHLEVBQ0g0dkIsa0JBQWtCLENBQUMzRSxhQUFhQyxhQUFhLEVBQzlDLEdBQUcsSUFBSTtRQUNSLElBQUksQ0FBQ3oyRCxDQUFDLElBQUkwMUQsS0FBS2M7UUFDZixJQUFJLENBQUM5cEQsQ0FBQyxJQUFJaXBELEtBQUtjO1FBQ2YsSUFBSSxJQUFJLENBQUM5cUIsTUFBTSxJQUFLLEtBQUksQ0FBQzNyQyxDQUFDLEdBQUcsS0FBSyxJQUFJLENBQUNBLENBQUMsR0FBRyxLQUFLLElBQUksQ0FBQzBNLENBQUMsR0FBRyxLQUFLLElBQUksQ0FBQ0EsQ0FBQyxHQUFHLElBQUk7WUFDekUsTUFBTSxFQUNKMU0sQ0FBQyxFQUNEME0sQ0FBQyxFQUNGLEdBQUcsSUFBSSxDQUFDNitCLEdBQUcsQ0FBQzZmLHFCQUFxQjtZQUNsQyxJQUFJLElBQUksQ0FBQ3pmLE1BQU0sQ0FBQyszQixhQUFhLENBQUMsSUFBSSxFQUFFMWpFLEdBQUcwTSxJQUFJO2dCQUN6QyxJQUFJLENBQUMxTSxDQUFDLElBQUlILEtBQUtDLEtBQUssQ0FBQyxJQUFJLENBQUNFLENBQUM7Z0JBQzNCLElBQUksQ0FBQzBNLENBQUMsSUFBSTdNLEtBQUtDLEtBQUssQ0FBQyxJQUFJLENBQUM0TSxDQUFDO1lBQzdCO1FBQ0Y7UUFDQSxJQUFJLEVBQ0YxTSxDQUFDLEVBQ0QwTSxDQUFDLEVBQ0YsR0FBRyxJQUFJO1FBQ1IsTUFBTSxDQUFDaTNELElBQUlDLEdBQUcsR0FBRyxJQUFJLENBQUNDLGtCQUFrQjtRQUN4QzdqRSxLQUFLMmpFO1FBQ0xqM0QsS0FBS2szRDtRQUNMLE1BQU0sRUFDSjc4RCxLQUFLLEVBQ04sR0FBR3drQztRQUNKeGtDLE1BQU0rOEQsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU05akUsQ0FBQUEsRUFBRytqRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkNoOUQsTUFBTWd6QyxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsTUFBTXJ0QyxDQUFBQSxFQUFHcTNELE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUNSLGNBQWMsQ0FBQ3ZqRSxHQUFHME07UUFDdkI2K0IsSUFBSWk0QixjQUFjLENBQUM7WUFDakJDLE9BQU87UUFDVDtJQUNGO0lBQ0FGLGVBQWV2akUsQ0FBQyxFQUFFME0sQ0FBQyxFQUFFLENBQUM7SUFDdEIyMkQsY0FBY3JqRSxDQUFDLEVBQUUwTSxDQUFDLEVBQUUsQ0FBQztJQUNyQixJQUFJczNELGdCQUFnQjtRQUNsQixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQy9FLFdBQVcsSUFBSyxLQUFJLENBQUMsQ0FBQ0EsV0FBVyxDQUFDLEVBQUUsS0FBSyxJQUFJLENBQUNqL0QsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDaS9ELFdBQVcsQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDdnlELENBQUM7SUFDbkc7SUFDQSxJQUFJdTNELGtCQUFrQjtRQUNwQixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQ2hGLFdBQVcsSUFBSyxLQUFJLENBQUMsQ0FBQ0EsV0FBVyxDQUFDLEVBQUUsS0FBSyxJQUFJLENBQUN6d0IsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDeXdCLFdBQVcsQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDeHdCLE1BQU07SUFDNUc7SUFDQW8xQixxQkFBcUI7UUFDbkIsTUFBTSxDQUFDck4sYUFBYUMsYUFBYSxHQUFHLElBQUksQ0FBQzBFLGdCQUFnQjtRQUN6RCxNQUFNLEVBQ0p5RSxnQkFBZ0IsRUFDakIsR0FBR3ZCO1FBQ0osTUFBTXIrRCxJQUFJNC9ELG1CQUFtQnBKO1FBQzdCLE1BQU05cEQsSUFBSWt6RCxtQkFBbUJuSjtRQUM3QixPQUFRLElBQUksQ0FBQzdvQixRQUFRO1lBQ25CLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQyxDQUFDNXRDO29CQUFHME07aUJBQUU7WUFDaEIsS0FBSztnQkFDSCxPQUFPO29CQUFDMU07b0JBQUcwTTtpQkFBRTtZQUNmLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQzFNO29CQUFHLENBQUMwTTtpQkFBRTtZQUNoQjtnQkFDRSxPQUFPO29CQUFDLENBQUMxTTtvQkFBRyxDQUFDME07aUJBQUU7UUFDbkI7SUFDRjtJQUNBLElBQUl3M0QsbUJBQW1CO1FBQ3JCLE9BQU87SUFDVDtJQUNBM0Isa0JBQWtCMzBCLFdBQVcsSUFBSSxDQUFDQSxRQUFRLEVBQUU7UUFDMUMsTUFBTSxFQUNKckMsS0FBSyxFQUNIeGtDLEtBQUssRUFDTixFQUNEZzZELGdCQUFnQixDQUFDbnlCLFdBQVdDLFdBQVcsRUFDeEMsR0FBRyxJQUFJO1FBQ1IsSUFBSSxFQUNGN3VDLENBQUMsRUFDRDBNLENBQUMsRUFDRDhoQyxLQUFLLEVBQ0xDLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUkQsU0FBU0k7UUFDVEgsVUFBVUk7UUFDVjd1QyxLQUFLNHVDO1FBQ0xsaUMsS0FBS21pQztRQUNMLElBQUksSUFBSSxDQUFDcTFCLGdCQUFnQixFQUFFO1lBQ3pCLE9BQVF0MkI7Z0JBQ04sS0FBSztvQkFDSDV0QyxJQUFJd25DLFVBQVV4bkMsR0FBRyxHQUFHNHVDLFlBQVlKO29CQUNoQzloQyxJQUFJODZCLFVBQVU5NkIsR0FBRyxHQUFHbWlDLGFBQWFKO29CQUNqQztnQkFDRixLQUFLO29CQUNIenVDLElBQUl3bkMsVUFBVXhuQyxHQUFHLEdBQUc0dUMsWUFBWUg7b0JBQ2hDL2hDLElBQUk4NkIsVUFBVTk2QixHQUFHOGhDLE9BQU9LO29CQUN4QjtnQkFDRixLQUFLO29CQUNIN3VDLElBQUl3bkMsVUFBVXhuQyxHQUFHd3VDLE9BQU9JO29CQUN4QmxpQyxJQUFJODZCLFVBQVU5NkIsR0FBRytoQyxRQUFRSTtvQkFDekI7Z0JBQ0YsS0FBSztvQkFDSDd1QyxJQUFJd25DLFVBQVV4bkMsR0FBR3l1QyxRQUFRRztvQkFDekJsaUMsSUFBSTg2QixVQUFVOTZCLEdBQUcsR0FBR21pQyxhQUFhTDtvQkFDakM7WUFDSjtRQUNGO1FBQ0EsSUFBSSxDQUFDeHVDLENBQUMsR0FBR0EsS0FBSzR1QztRQUNkLElBQUksQ0FBQ2xpQyxDQUFDLEdBQUdBLEtBQUttaUM7UUFDZCxNQUFNLENBQUM4MEIsSUFBSUMsR0FBRyxHQUFHLElBQUksQ0FBQ0Msa0JBQWtCO1FBQ3hDN2pFLEtBQUsyakU7UUFDTGozRCxLQUFLazNEO1FBQ0w3OEQsTUFBTSs4RCxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsTUFBTTlqRSxDQUFBQSxFQUFHK2pFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2Q2g5RCxNQUFNZ3pDLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNcnRDLENBQUFBLEVBQUdxM0QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQ0ksU0FBUztJQUNoQjtJQUNBLE9BQU8sQ0FBQ0MsV0FBVyxDQUFDcGtFLENBQUMsRUFBRTBNLENBQUMsRUFBRTIzRCxLQUFLO1FBQzdCLE9BQVFBO1lBQ04sS0FBSztnQkFDSCxPQUFPO29CQUFDMzNEO29CQUFHLENBQUMxTTtpQkFBRTtZQUNoQixLQUFLO2dCQUNILE9BQU87b0JBQUMsQ0FBQ0E7b0JBQUcsQ0FBQzBNO2lCQUFFO1lBQ2pCLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQyxDQUFDQTtvQkFBRzFNO2lCQUFFO1lBQ2hCO2dCQUNFLE9BQU87b0JBQUNBO29CQUFHME07aUJBQUU7UUFDakI7SUFDRjtJQUNBdTJELHdCQUF3QmpqRSxDQUFDLEVBQUUwTSxDQUFDLEVBQUU7UUFDNUIsT0FBTzJ4RCxpQkFBaUIsQ0FBQytGLFdBQVcsQ0FBQ3BrRSxHQUFHME0sR0FBRyxJQUFJLENBQUM0MUQsY0FBYztJQUNoRTtJQUNBZ0Msd0JBQXdCdGtFLENBQUMsRUFBRTBNLENBQUMsRUFBRTtRQUM1QixPQUFPMnhELGlCQUFpQixDQUFDK0YsV0FBVyxDQUFDcGtFLEdBQUcwTSxHQUFHLE1BQU0sSUFBSSxDQUFDNDFELGNBQWM7SUFDdEU7SUFDQSxDQUFDaUMsaUJBQWlCLENBQUMzMkIsUUFBUTtRQUN6QixPQUFRQTtZQUNOLEtBQUs7Z0JBQ0g7b0JBQ0UsTUFBTSxDQUFDZ0IsV0FBV0MsV0FBVyxHQUFHLElBQUksQ0FBQ2t5QixjQUFjO29CQUNuRCxPQUFPO3dCQUFDO3dCQUFHLENBQUNueUIsWUFBWUM7d0JBQVlBLGFBQWFEO3dCQUFXO3FCQUFFO2dCQUNoRTtZQUNGLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQyxDQUFDO29CQUFHO29CQUFHO29CQUFHLENBQUM7aUJBQUU7WUFDdkIsS0FBSztnQkFDSDtvQkFDRSxNQUFNLENBQUNBLFdBQVdDLFdBQVcsR0FBRyxJQUFJLENBQUNreUIsY0FBYztvQkFDbkQsT0FBTzt3QkFBQzt3QkFBR255QixZQUFZQzt3QkFBWSxDQUFDQSxhQUFhRDt3QkFBVztxQkFBRTtnQkFDaEU7WUFDRjtnQkFDRSxPQUFPO29CQUFDO29CQUFHO29CQUFHO29CQUFHO2lCQUFFO1FBQ3ZCO0lBQ0Y7SUFDQSxJQUFJNDFCLGNBQWM7UUFDaEIsT0FBTyxJQUFJLENBQUNockIsVUFBVSxDQUFDOE4sY0FBYyxDQUFDQyxTQUFTO0lBQ2pEO0lBQ0EsSUFBSSthLGlCQUFpQjtRQUNuQixPQUFPLENBQUMsSUFBSSxDQUFDOW9CLFVBQVUsQ0FBQzhOLGNBQWMsQ0FBQzFaLFFBQVEsR0FBRyxJQUFJLENBQUNrekIsWUFBWSxJQUFJO0lBQ3pFO0lBQ0EsSUFBSTNGLG1CQUFtQjtRQUNyQixNQUFNLEVBQ0pxSixXQUFXLEVBQ1h6RCxnQkFBZ0IsQ0FBQ255QixXQUFXQyxXQUFXLEVBQ3hDLEdBQUcsSUFBSTtRQUNSLE9BQU87WUFBQ0QsWUFBWTQxQjtZQUFhMzFCLGFBQWEyMUI7U0FBWTtJQUM1RDtJQUNBQyxVQUFVO1FBQ1IsTUFBTSxFQUNKbDVCLEtBQUssRUFDSHhrQyxLQUFLLEVBQ04sRUFDRHluQyxLQUFLLEVBQ0xDLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUjFuQyxNQUFNeW5DLEtBQUssR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNQSxLQUFJLEVBQUd1MUIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzVDaDlELE1BQU0wbkMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU1BLE1BQUssRUFBR3MxQixPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDaEQ7SUFDQVcsd0JBQXdCO1FBQ3RCLE9BQU87WUFBQztZQUFHO1NBQUU7SUFDZjtJQUNBLENBQUNDLGNBQWM7UUFDYixJQUFJLElBQUksQ0FBQyxDQUFDakcsV0FBVyxFQUFFO1lBQ3JCO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQ0EsV0FBVyxHQUFHdDNELFNBQVMySSxhQUFhLENBQUM7UUFDM0MsSUFBSSxDQUFDLENBQUMydUQsV0FBVyxDQUFDcHBCLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7UUFDaEMsTUFBTTAxRCxVQUFVLElBQUksQ0FBQ25FLG9CQUFvQixHQUFHO1lBQUM7WUFBVztZQUFZO1lBQWU7U0FBYSxHQUFHO1lBQUM7WUFBVztZQUFhO1lBQVk7WUFBZTtZQUFlO1lBQWdCO1lBQWM7U0FBYTtRQUNqTixNQUFNcjRCLFNBQVMsSUFBSSxDQUFDb1IsVUFBVSxDQUFDQyxPQUFPO1FBQ3RDLEtBQUssTUFBTXQ5QyxRQUFReW9FLFFBQVM7WUFDMUIsTUFBTXI1QixNQUFNbmtDLFNBQVMySSxhQUFhLENBQUM7WUFDbkMsSUFBSSxDQUFDLENBQUMydUQsV0FBVyxDQUFDdnJELE1BQU0sQ0FBQ280QjtZQUN6QkEsSUFBSStKLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUMsV0FBVy9TO1lBQzdCb3ZDLElBQUl2QixZQUFZLENBQUMscUJBQXFCN3RDO1lBQ3RDb3ZDLElBQUkvQyxnQkFBZ0IsQ0FBQyxlQUFlLElBQUksQ0FBQyxDQUFDcThCLGtCQUFrQixDQUFDemxFLElBQUksQ0FBQyxJQUFJLEVBQUVqRCxPQUFPO2dCQUM3RWlzQztZQUNGO1lBQ0FtRCxJQUFJL0MsZ0JBQWdCLENBQUMsZUFBZXVJLGVBQWU7Z0JBQ2pEM0k7WUFDRjtZQUNBbUQsSUFBSXFQLFFBQVEsR0FBRyxDQUFDO1FBQ2xCO1FBQ0EsSUFBSSxDQUFDclAsR0FBRyxDQUFDdTVCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQ3BHLFdBQVc7SUFDcEM7SUFDQSxDQUFDbUcsa0JBQWtCLENBQUMxb0UsSUFBSSxFQUFFMHRDLEtBQUs7UUFDN0JBLE1BQU1tSCxjQUFjO1FBQ3BCLE1BQU0sRUFDSi9SLEtBQUssRUFDTixHQUFHUixpQkFBaUJLLFFBQVE7UUFDN0IsSUFBSStLLE1BQU04USxNQUFNLEtBQUssS0FBSzlRLE1BQU15WCxPQUFPLElBQUlyaUIsT0FBTztZQUNoRDtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUMyWixPQUFPLEVBQUV5UyxPQUFPO1FBQ3RCLE1BQU0wWixpQkFBaUIsSUFBSSxDQUFDM0MsWUFBWTtRQUN4QyxJQUFJLENBQUNBLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUMsQ0FBQ3pELGlCQUFpQixHQUFHO1lBQUM5MEIsTUFBTW16QixPQUFPO1lBQUVuekIsTUFBTXF6QixPQUFPO1NBQUM7UUFDeEQsTUFBTWgxQixLQUFLLElBQUlDO1FBQ2YsTUFBTUMsU0FBUyxJQUFJLENBQUNvUixVQUFVLENBQUNxTyxjQUFjLENBQUMzZjtRQUM5QyxJQUFJLENBQUN5RCxNQUFNLENBQUNxNUIsbUJBQW1CLENBQUM7UUFDaENuMEQsT0FBTzIzQixnQkFBZ0IsQ0FBQyxlQUFlLElBQUksQ0FBQyxDQUFDeThCLGtCQUFrQixDQUFDN2xFLElBQUksQ0FBQyxJQUFJLEVBQUVqRCxPQUFPO1lBQ2hGZ2dFLFNBQVM7WUFDVC9oQixTQUFTO1lBQ1RoUztRQUNGO1FBQ0F2M0IsT0FBTzIzQixnQkFBZ0IsQ0FBQyxhQUFheUksV0FBVztZQUM5Q2tyQixTQUFTO1lBQ1QvekI7UUFDRjtRQUNBdjNCLE9BQU8yM0IsZ0JBQWdCLENBQUMsZUFBZXVJLGVBQWU7WUFDcEQzSTtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUN3MkIsZUFBZSxHQUFHO1lBQ3RCN0osUUFBUSxJQUFJLENBQUMvMEQsQ0FBQztZQUNkZzFELFFBQVEsSUFBSSxDQUFDdG9ELENBQUM7WUFDZHc0RCxZQUFZLElBQUksQ0FBQzEyQixLQUFLO1lBQ3RCMjJCLGFBQWEsSUFBSSxDQUFDMTJCLE1BQU07UUFDMUI7UUFDQSxNQUFNMjJCLG9CQUFvQixJQUFJLENBQUN6NUIsTUFBTSxDQUFDSixHQUFHLENBQUN4a0MsS0FBSyxDQUFDcytELE1BQU07UUFDdEQsTUFBTUMsY0FBYyxJQUFJLENBQUMvNUIsR0FBRyxDQUFDeGtDLEtBQUssQ0FBQ3MrRCxNQUFNO1FBQ3pDLElBQUksQ0FBQzk1QixHQUFHLENBQUN4a0MsS0FBSyxDQUFDcytELE1BQU0sR0FBRyxJQUFJLENBQUMxNUIsTUFBTSxDQUFDSixHQUFHLENBQUN4a0MsS0FBSyxDQUFDcytELE1BQU0sR0FBR3gwRCxPQUFPaWlDLGdCQUFnQixDQUFDakosTUFBTWh3QyxNQUFNLEVBQUV3ckUsTUFBTTtRQUNuRyxNQUFNRSxvQkFBb0I7WUFDeEJyOUIsR0FBR0ksS0FBSztZQUNSLElBQUksQ0FBQ3FELE1BQU0sQ0FBQ3E1QixtQkFBbUIsQ0FBQztZQUNoQyxJQUFJLENBQUMsQ0FBQ3BzQixPQUFPLEVBQUV5UyxPQUFPO1lBQ3RCLElBQUksQ0FBQytXLFlBQVksR0FBRzJDO1lBQ3BCLElBQUksQ0FBQ3A1QixNQUFNLENBQUNKLEdBQUcsQ0FBQ3hrQyxLQUFLLENBQUNzK0QsTUFBTSxHQUFHRDtZQUMvQixJQUFJLENBQUM3NUIsR0FBRyxDQUFDeGtDLEtBQUssQ0FBQ3MrRCxNQUFNLEdBQUdDO1lBQ3hCLElBQUksQ0FBQyxDQUFDRSxvQkFBb0I7UUFDNUI7UUFDQTMwRCxPQUFPMjNCLGdCQUFnQixDQUFDLGFBQWErOEIsbUJBQW1CO1lBQ3REbjlCO1FBQ0Y7UUFDQXYzQixPQUFPMjNCLGdCQUFnQixDQUFDLFFBQVErOEIsbUJBQW1CO1lBQ2pEbjlCO1FBQ0Y7SUFDRjtJQUNBLENBQUM2M0IsTUFBTSxDQUFDamdFLENBQUMsRUFBRTBNLENBQUMsRUFBRThoQyxLQUFLLEVBQUVDLE1BQU07UUFDekIsSUFBSSxDQUFDRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDenVDLENBQUMsR0FBR0E7UUFDVCxJQUFJLENBQUMwTSxDQUFDLEdBQUdBO1FBQ1QsSUFBSSxDQUFDKzNELE9BQU87UUFDWixJQUFJLENBQUNsQyxpQkFBaUI7UUFDdEIsSUFBSSxDQUFDa0QsVUFBVTtJQUNqQjtJQUNBQSxhQUFhLENBQUM7SUFDZCxDQUFDRCxvQkFBb0I7UUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDNUcsZUFBZSxFQUFFO1lBQzFCO1FBQ0Y7UUFDQSxNQUFNLEVBQ0o3SixNQUFNLEVBQ05DLE1BQU0sRUFDTmtRLFVBQVUsRUFDVkMsV0FBVyxFQUNaLEdBQUcsSUFBSSxDQUFDLENBQUN2RyxlQUFlO1FBQ3pCLElBQUksQ0FBQyxDQUFDQSxlQUFlLEdBQUc7UUFDeEIsTUFBTTFKLE9BQU8sSUFBSSxDQUFDbDFELENBQUM7UUFDbkIsTUFBTW0xRCxPQUFPLElBQUksQ0FBQ3pvRCxDQUFDO1FBQ25CLE1BQU1nNUQsV0FBVyxJQUFJLENBQUNsM0IsS0FBSztRQUMzQixNQUFNbTNCLFlBQVksSUFBSSxDQUFDbDNCLE1BQU07UUFDN0IsSUFBSXltQixTQUFTSCxVQUFVSSxTQUFTSCxVQUFVMFEsYUFBYVIsY0FBY1MsY0FBY1IsYUFBYTtZQUM5RjtRQUNGO1FBQ0EsSUFBSSxDQUFDdlYsV0FBVyxDQUFDO1lBQ2Z2UCxLQUFLLElBQUksQ0FBQyxDQUFDNGYsTUFBTSxDQUFDN2dFLElBQUksQ0FBQyxJQUFJLEVBQUU4MUQsTUFBTUMsTUFBTXVRLFVBQVVDO1lBQ25EcmxCLE1BQU0sSUFBSSxDQUFDLENBQUMyZixNQUFNLENBQUM3Z0UsSUFBSSxDQUFDLElBQUksRUFBRTIxRCxRQUFRQyxRQUFRa1EsWUFBWUM7WUFDMUQza0IsVUFBVTtRQUNaO0lBQ0Y7SUFDQSxPQUFPb2xCLE9BQU81bEUsQ0FBQyxFQUFFO1FBQ2YsT0FBT0gsS0FBSzYxQyxLQUFLLENBQUMxMUMsSUFBSSxTQUFTO0lBQ2pDO0lBQ0EsQ0FBQ2lsRSxrQkFBa0IsQ0FBQzlvRSxJQUFJLEVBQUUwdEMsS0FBSztRQUM3QixNQUFNLENBQUMyc0IsYUFBYUMsYUFBYSxHQUFHLElBQUksQ0FBQzBFLGdCQUFnQjtRQUN6RCxNQUFNcEcsU0FBUyxJQUFJLENBQUMvMEQsQ0FBQztRQUNyQixNQUFNZzFELFNBQVMsSUFBSSxDQUFDdG9ELENBQUM7UUFDckIsTUFBTXc0RCxhQUFhLElBQUksQ0FBQzEyQixLQUFLO1FBQzdCLE1BQU0yMkIsY0FBYyxJQUFJLENBQUMxMkIsTUFBTTtRQUMvQixNQUFNbzNCLFdBQVd4SCxpQkFBaUJ5SCxRQUFRLEdBQUd0UDtRQUM3QyxNQUFNdVAsWUFBWTFILGlCQUFpQnlILFFBQVEsR0FBR3JQO1FBQzlDLE1BQU11UCxpQkFBaUIsSUFBSSxDQUFDLENBQUN6QixpQkFBaUIsQ0FBQyxJQUFJLENBQUMzMkIsUUFBUTtRQUM1RCxNQUFNcTRCLFNBQVMsQ0FBQ2ptRSxHQUFHME0sSUFBTTtnQkFBQ3M1RCxjQUFjLENBQUMsRUFBRSxHQUFHaG1FLElBQUlnbUUsY0FBYyxDQUFDLEVBQUUsR0FBR3Q1RDtnQkFBR3M1RCxjQUFjLENBQUMsRUFBRSxHQUFHaG1FLElBQUlnbUUsY0FBYyxDQUFDLEVBQUUsR0FBR3Q1RDthQUFFO1FBQ3ZILE1BQU13NUQsb0JBQW9CLElBQUksQ0FBQyxDQUFDM0IsaUJBQWlCLENBQUMsTUFBTSxJQUFJLENBQUMzMkIsUUFBUTtRQUNyRSxNQUFNdTRCLFlBQVksQ0FBQ25tRSxHQUFHME0sSUFBTTtnQkFBQ3c1RCxpQkFBaUIsQ0FBQyxFQUFFLEdBQUdsbUUsSUFBSWttRSxpQkFBaUIsQ0FBQyxFQUFFLEdBQUd4NUQ7Z0JBQUd3NUQsaUJBQWlCLENBQUMsRUFBRSxHQUFHbG1FLElBQUlrbUUsaUJBQWlCLENBQUMsRUFBRSxHQUFHeDVEO2FBQUU7UUFDdEksSUFBSTA1RDtRQUNKLElBQUlDO1FBQ0osSUFBSUMsYUFBYTtRQUNqQixJQUFJQyxlQUFlO1FBQ25CLE9BQVFwcUU7WUFDTixLQUFLO2dCQUNIbXFFLGFBQWE7Z0JBQ2JGLFdBQVcsQ0FBQzV5QixHQUFHQyxJQUFNO3dCQUFDO3dCQUFHO3FCQUFFO2dCQUMzQjR5QixjQUFjLENBQUM3eUIsR0FBR0MsSUFBTTt3QkFBQ0Q7d0JBQUdDO3FCQUFFO2dCQUM5QjtZQUNGLEtBQUs7Z0JBQ0gyeUIsV0FBVyxDQUFDNXlCLEdBQUdDLElBQU07d0JBQUNELElBQUk7d0JBQUc7cUJBQUU7Z0JBQy9CNnlCLGNBQWMsQ0FBQzd5QixHQUFHQyxJQUFNO3dCQUFDRCxJQUFJO3dCQUFHQztxQkFBRTtnQkFDbEM7WUFDRixLQUFLO2dCQUNINnlCLGFBQWE7Z0JBQ2JGLFdBQVcsQ0FBQzV5QixHQUFHQyxJQUFNO3dCQUFDRDt3QkFBRztxQkFBRTtnQkFDM0I2eUIsY0FBYyxDQUFDN3lCLEdBQUdDLElBQU07d0JBQUM7d0JBQUdBO3FCQUFFO2dCQUM5QjtZQUNGLEtBQUs7Z0JBQ0g4eUIsZUFBZTtnQkFDZkgsV0FBVyxDQUFDNXlCLEdBQUdDLElBQU07d0JBQUNEO3dCQUFHQyxJQUFJO3FCQUFFO2dCQUMvQjR5QixjQUFjLENBQUM3eUIsR0FBR0MsSUFBTTt3QkFBQzt3QkFBR0EsSUFBSTtxQkFBRTtnQkFDbEM7WUFDRixLQUFLO2dCQUNINnlCLGFBQWE7Z0JBQ2JGLFdBQVcsQ0FBQzV5QixHQUFHQyxJQUFNO3dCQUFDRDt3QkFBR0M7cUJBQUU7Z0JBQzNCNHlCLGNBQWMsQ0FBQzd5QixHQUFHQyxJQUFNO3dCQUFDO3dCQUFHO3FCQUFFO2dCQUM5QjtZQUNGLEtBQUs7Z0JBQ0gyeUIsV0FBVyxDQUFDNXlCLEdBQUdDLElBQU07d0JBQUNELElBQUk7d0JBQUdDO3FCQUFFO2dCQUMvQjR5QixjQUFjLENBQUM3eUIsR0FBR0MsSUFBTTt3QkFBQ0QsSUFBSTt3QkFBRztxQkFBRTtnQkFDbEM7WUFDRixLQUFLO2dCQUNIOHlCLGFBQWE7Z0JBQ2JGLFdBQVcsQ0FBQzV5QixHQUFHQyxJQUFNO3dCQUFDO3dCQUFHQTtxQkFBRTtnQkFDM0I0eUIsY0FBYyxDQUFDN3lCLEdBQUdDLElBQU07d0JBQUNEO3dCQUFHO3FCQUFFO2dCQUM5QjtZQUNGLEtBQUs7Z0JBQ0greUIsZUFBZTtnQkFDZkgsV0FBVyxDQUFDNXlCLEdBQUdDLElBQU07d0JBQUM7d0JBQUdBLElBQUk7cUJBQUU7Z0JBQy9CNHlCLGNBQWMsQ0FBQzd5QixHQUFHQyxJQUFNO3dCQUFDRDt3QkFBR0MsSUFBSTtxQkFBRTtnQkFDbEM7UUFDSjtRQUNBLE1BQU0reUIsUUFBUUosU0FBU2xCLFlBQVlDO1FBQ25DLE1BQU1zQixnQkFBZ0JKLFlBQVluQixZQUFZQztRQUM5QyxJQUFJdUIsc0JBQXNCVCxVQUFVUTtRQUNwQyxNQUFNRSxZQUFZdEksaUJBQWlCdUgsTUFBTSxDQUFDN1EsU0FBUzJSLG1CQUFtQixDQUFDLEVBQUU7UUFDekUsTUFBTUUsWUFBWXZJLGlCQUFpQnVILE1BQU0sQ0FBQzVRLFNBQVMwUixtQkFBbUIsQ0FBQyxFQUFFO1FBQ3pFLElBQUlHLFNBQVM7UUFDYixJQUFJQyxTQUFTO1FBQ2IsSUFBSUMsUUFBUUM7UUFDWixJQUFJLENBQUNuOUIsTUFBTW85QixZQUFZLEVBQUU7WUFDdkIsTUFBTSxFQUNKakssT0FBTyxFQUNQRSxPQUFPLEVBQ1IsR0FBR3J6QjtZQUNKLE1BQU0sQ0FBQ3E5QixhQUFhQyxZQUFZLEdBQUcsSUFBSSxDQUFDLENBQUN4SSxpQkFBaUI7WUFDMUQsQ0FBQ29JLFFBQVFDLE9BQU8sR0FBRyxJQUFJLENBQUMvRCx1QkFBdUIsQ0FBQ2pHLFVBQVVrSyxhQUFhaEssVUFBVWlLO1lBQ2pGLElBQUksQ0FBQyxDQUFDeEksaUJBQWlCLENBQUMsRUFBRSxHQUFHM0I7WUFDN0IsSUFBSSxDQUFDLENBQUMyQixpQkFBaUIsQ0FBQyxFQUFFLEdBQUd6QjtRQUMvQixPQUFPO1lBQ0osR0FDQzZKLE1BQU0sRUFDTkMsTUFBTSxFQUNQLEdBQUduOUIsS0FBSTtRQUNWO1FBQ0EsQ0FBQ2s5QixRQUFRQyxPQUFPLEdBQUdiLFVBQVVZLFNBQVN2USxhQUFhd1EsU0FBU3ZRO1FBQzVELElBQUk2UCxZQUFZO1lBQ2QsTUFBTWMsVUFBVXZuRSxLQUFLcStELEtBQUssQ0FBQ2dILFlBQVlDO1lBQ3ZDMEIsU0FBU0MsU0FBU2puRSxLQUFLNFAsR0FBRyxDQUFDNVAsS0FBS21GLEdBQUcsQ0FBQ25GLEtBQUtxK0QsS0FBSyxDQUFDdUksYUFBYSxDQUFDLEVBQUUsR0FBR0QsS0FBSyxDQUFDLEVBQUUsR0FBR08sUUFBUU4sYUFBYSxDQUFDLEVBQUUsR0FBR0QsS0FBSyxDQUFDLEVBQUUsR0FBR1EsVUFBVUksU0FBUyxJQUFJbEMsWUFBWSxJQUFJQyxjQUFjVSxXQUFXWCxZQUFZYSxZQUFZWjtRQUM3TSxPQUFPLElBQUlvQixjQUFjO1lBQ3ZCTSxTQUFTci9CLFVBQVUzbkMsS0FBSytMLEdBQUcsQ0FBQzY2RCxhQUFhLENBQUMsRUFBRSxHQUFHRCxLQUFLLENBQUMsRUFBRSxHQUFHTyxTQUFTbEIsVUFBVSxLQUFLWDtRQUNwRixPQUFPO1lBQ0w0QixTQUFTdC9CLFVBQVUzbkMsS0FBSytMLEdBQUcsQ0FBQzY2RCxhQUFhLENBQUMsRUFBRSxHQUFHRCxLQUFLLENBQUMsRUFBRSxHQUFHUSxTQUFTakIsV0FBVyxLQUFLWjtRQUNyRjtRQUNBLE1BQU1PLFdBQVdySCxpQkFBaUJ1SCxNQUFNLENBQUNWLGFBQWEyQjtRQUN0RCxNQUFNbEIsWUFBWXRILGlCQUFpQnVILE1BQU0sQ0FBQ1QsY0FBYzJCO1FBQ3hESixzQkFBc0JULFVBQVVJLFlBQVlYLFVBQVVDO1FBQ3RELE1BQU16USxPQUFPeVIsWUFBWUQsbUJBQW1CLENBQUMsRUFBRTtRQUMvQyxNQUFNdlIsT0FBT3lSLFlBQVlGLG1CQUFtQixDQUFDLEVBQUU7UUFDL0MsSUFBSSxDQUFDLENBQUN6SCxXQUFXLEtBQUs7WUFBQyxJQUFJLENBQUNqL0QsQ0FBQztZQUFFLElBQUksQ0FBQzBNLENBQUM7WUFBRSxJQUFJLENBQUM4aEMsS0FBSztZQUFFLElBQUksQ0FBQ0MsTUFBTTtTQUFDO1FBQy9ELElBQUksQ0FBQ0QsS0FBSyxHQUFHazNCO1FBQ2IsSUFBSSxDQUFDajNCLE1BQU0sR0FBR2szQjtRQUNkLElBQUksQ0FBQzNsRSxDQUFDLEdBQUdrMUQ7UUFDVCxJQUFJLENBQUN4b0QsQ0FBQyxHQUFHeW9EO1FBQ1QsSUFBSSxDQUFDc1AsT0FBTztRQUNaLElBQUksQ0FBQ2xDLGlCQUFpQjtRQUN0QixJQUFJLENBQUM4RSxXQUFXO0lBQ2xCO0lBQ0FBLGNBQWMsQ0FBQztJQUNmQyxnQkFBZ0I7UUFDZCxJQUFJLENBQUMsQ0FBQzF1QixPQUFPLEVBQUU0ZjtJQUNqQjtJQUNBLElBQUkrTyxpQkFBaUI7UUFDbkIsT0FBTztJQUNUO0lBQ0EsTUFBTUMsaUJBQWlCO1FBQ3JCLElBQUksSUFBSSxDQUFDbkgsWUFBWSxJQUFJLElBQUksQ0FBQyxDQUFDbkIsWUFBWSxFQUFFO1lBQzNDLE9BQU8sSUFBSSxDQUFDbUIsWUFBWTtRQUMxQjtRQUNBLElBQUksQ0FBQ0EsWUFBWSxHQUFHLElBQUk5bkIsY0FBYyxJQUFJO1FBQzFDLElBQUksQ0FBQ2hOLEdBQUcsQ0FBQ3A0QixNQUFNLENBQUMsSUFBSSxDQUFDa3RELFlBQVksQ0FBQ3IxQixNQUFNO1FBQ3hDLE1BQU0sRUFDSnU4QixjQUFjLEVBQ2YsR0FBRyxJQUFJO1FBQ1IsSUFBSUEsZ0JBQWdCO1lBQ2xCLEtBQUssTUFBTSxDQUFDcHJFLE1BQU15L0MsS0FBSyxJQUFJMnJCLGVBQWdCO2dCQUN6QyxNQUFNLElBQUksQ0FBQ2xILFlBQVksQ0FBQzFrQixTQUFTLENBQUN4L0MsTUFBTXkvQztZQUMxQztRQUNGO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQytWLFVBQVUsRUFBRTtZQUNwQixJQUFJLENBQUMwTyxZQUFZLENBQUMxa0IsU0FBUyxDQUFDLFdBQVcsSUFBSSxDQUFDOHJCLGdCQUFnQjtRQUM5RDtRQUNBLElBQUksQ0FBQ3BILFlBQVksQ0FBQzFrQixTQUFTLENBQUM7UUFDNUIsT0FBTyxJQUFJLENBQUMwa0IsWUFBWTtJQUMxQjtJQUNBcUgsNEJBQTRCO1FBQzFCLElBQUksQ0FBQ3JILFlBQVksRUFBRXhrQixnQkFBZ0IsV0FBVyxJQUFJLENBQUM0ckIsZ0JBQWdCLElBQUk7SUFDekU7SUFDQUUsaUNBQWlDO1FBQy9CLElBQUksQ0FBQ3RILFlBQVksRUFBRTVrQixhQUFhO0lBQ2xDO0lBQ0Ftc0Isb0JBQW9CO1FBQ2xCLElBQUksQ0FBQ3ZILFlBQVksRUFBRTV4RDtRQUNuQixJQUFJLENBQUM0eEQsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQyxDQUFDem5CLE9BQU8sRUFBRXVEO0lBQ2pCO0lBQ0EwckIsYUFBYXp3QixTQUFTLEVBQUU7UUFDdEIsTUFBTTB3QixpQkFBaUIsSUFBSSxDQUFDekgsWUFBWSxFQUFFOTBCO1FBQzFDLElBQUl1OEIsZ0JBQWdCO1lBQ2xCQSxlQUFlQyxNQUFNLENBQUMzd0I7UUFDeEIsT0FBTztZQUNMLElBQUksQ0FBQzdMLEdBQUcsQ0FBQ3A0QixNQUFNLENBQUNpa0M7UUFDbEI7SUFDRjtJQUNBNHdCLHNCQUFzQjtRQUNwQixPQUFPLElBQUksQ0FBQ3o4QixHQUFHLENBQUM2ZixxQkFBcUI7SUFDdkM7SUFDQTZjLGdCQUFnQjtRQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ3J2QixPQUFPLEVBQUU7WUFDbEJ3ZSxRQUFRYyxVQUFVLENBQUNtRyxpQkFBaUJ0RyxLQUFLO1lBQ3pDLElBQUksQ0FBQyxDQUFDbmYsT0FBTyxHQUFHLElBQUl3ZSxRQUFRLElBQUk7WUFDaEMsSUFBSSxJQUFJLENBQUMsQ0FBQ2tILGlCQUFpQixFQUFFO2dCQUMzQixJQUFJLENBQUMsQ0FBQzFsQixPQUFPLENBQUNodkMsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDMDBELGlCQUFpQjtnQkFDNUMsSUFBSSxDQUFDLENBQUNBLGlCQUFpQixHQUFHO1lBQzVCO1FBQ0Y7UUFDQSxPQUFPLElBQUksQ0FBQyxDQUFDMWxCLE9BQU87SUFDdEI7SUFDQSxJQUFJc3ZCLGNBQWM7UUFDaEIsT0FBTyxJQUFJLENBQUMsQ0FBQ3R2QixPQUFPLEVBQUVodkM7SUFDeEI7SUFDQSxJQUFJcytELFlBQVl0K0QsSUFBSSxFQUFFO1FBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ2d2QyxPQUFPLEVBQUU7WUFDbEI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDQSxPQUFPLENBQUNodkMsSUFBSSxHQUFHQTtJQUN2QjtJQUNBLElBQUl1K0QsaUJBQWlCO1FBQ25CLE9BQU8sSUFBSSxDQUFDLENBQUN2dkIsT0FBTyxFQUFFZ2Y7SUFDeEI7SUFDQSxNQUFNd1Esa0JBQWtCdmlELElBQUksRUFBRTtRQUM1QixNQUFNLElBQUksQ0FBQyxDQUFDK3lCLE9BQU8sRUFBRStmLGVBQWU5eUM7SUFDdEM7SUFDQXdpRCxpQkFBaUJ2UCxZQUFZLEVBQUU7UUFDN0IsT0FBTyxJQUFJLENBQUMsQ0FBQ2xnQixPQUFPLEVBQUV3SSxVQUFVMFg7SUFDbEM7SUFDQXdQLGFBQWE7UUFDWCxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQzF2QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ0EsT0FBTyxDQUFDMk4sT0FBTztJQUNsRDtJQUNBZ2lCLGlCQUFpQjtRQUNmLE9BQU8sSUFBSSxDQUFDLENBQUMzdkIsT0FBTyxFQUFFOGYsYUFBYTtJQUNyQztJQUNBOFAscUJBQXFCO1FBQ25CLElBQUksQ0FBQyxDQUFDM3ZCLE9BQU8sRUFBRXFoQjtJQUNqQjtJQUNBdU4sbUJBQW1CO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLENBQUM1dUIsT0FBTyxLQUFLLElBQUkwZ0IsUUFBUSxJQUFJO0lBQzNDO0lBQ0FySSw2QkFBNkI7UUFDM0IsSUFBSSxJQUFJLENBQUMsQ0FBQ3NJLHVCQUF1QixFQUFFO1lBQ2pDLElBQUksSUFBSSxDQUFDaGdCLFVBQVUsQ0FBQzJjLGFBQWEsSUFBSTtnQkFDbkMsSUFBSSxDQUFDLENBQUNxRCx1QkFBdUIsQ0FBQ2xrQixTQUFTLENBQUM3bUMsTUFBTSxDQUFDO1lBQ2pEO1lBQ0E7UUFDRjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUNrakQsVUFBVSxFQUFFO1lBQ3BCO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQzZILHVCQUF1QixHQUFHLElBQUksQ0FBQyxDQUFDM2dCLE9BQU8sQ0FBQ2loQixtQkFBbUI7UUFDakUsSUFBSSxDQUFDdnVCLEdBQUcsQ0FBQ3A0QixNQUFNLENBQUMsSUFBSSxDQUFDLENBQUNxbUQsdUJBQXVCO0lBQy9DO0lBQ0FrQixnQ0FBZ0M7UUFDOUIsSUFBSSxDQUFDLENBQUM3aEIsT0FBTyxDQUFDNmhCLDZCQUE2QjtRQUMzQyxJQUFJLENBQUMsQ0FBQ2xCLHVCQUF1QixHQUFHO0lBQ2xDO0lBQ0F2SSw4QkFBOEI7UUFDNUIsSUFBSSxDQUFDLENBQUN1SSx1QkFBdUIsRUFBRWxrQixVQUFVcG1DLElBQUk7SUFDL0M7SUFDQSxJQUFJMnBDLFVBQVU7UUFDWixNQUFNLEVBQ0pqdkMsTUFBTSxFQUNKZ3dELFFBQVEsRUFDUi96QyxJQUFJLEVBQ0orZixJQUFJLEVBQ0pnc0IsT0FBTyxFQUNSLEVBQ0YsR0FBRyxJQUFJLENBQUMsQ0FBQy9ZLE9BQU87UUFDakIsT0FBTztZQUNMaHpCO1lBQ0ErekM7WUFDQWgwQjtZQUNBZ3NCO1lBQ0F2ZixPQUFPLElBQUksQ0FBQ3NXLGNBQWM7WUFDMUJuVCxTQUFTLElBQUksQ0FBQ0EsT0FBTyxJQUFJO1FBQzNCO0lBQ0Y7SUFDQSxJQUFJcUQsUUFBUWh6QixJQUFJLEVBQUU7UUFDaEIsSUFBSSxDQUFDLENBQUNnekIsT0FBTyxLQUFLLElBQUkwZ0IsUUFBUSxJQUFJO1FBQ2xDLElBQUksQ0FBQyxDQUFDMWdCLE9BQU8sQ0FBQ2p2QyxJQUFJLEdBQUdpYztRQUNyQixJQUFJLElBQUksQ0FBQzhyQyxVQUFVLEVBQUU7WUFDbkIsSUFBSSxDQUFDZ1csOEJBQThCO1lBQ25DLElBQUksQ0FBQ3pXLDBCQUEwQjtZQUMvQixJQUFJLENBQUMxWCxVQUFVLENBQUNtUSxhQUFhLENBQUMsSUFBSTtRQUNwQyxPQUFPO1lBQ0wsSUFBSSxDQUFDK2QseUJBQXlCO1lBQzlCLElBQUksQ0FBQ2hOLDZCQUE2QjtZQUNsQyxJQUFJLENBQUNsaEIsVUFBVSxDQUFDc1EsYUFBYSxDQUFDLElBQUk7UUFDcEM7SUFDRjtJQUNBMmUsZUFBZSxFQUNiNXZCLE9BQU8sRUFDUGlaLFFBQVEsRUFDUjhILFFBQVEsRUFDVCxFQUFFO1FBQ0QsSUFBSSxDQUFDOUgsVUFBVTtZQUNiO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQ2paLE9BQU8sS0FBSyxJQUFJMGdCLFFBQVEsSUFBSTtRQUNsQyxJQUFJLENBQUMsQ0FBQzFnQixPQUFPLENBQUN5aUIsY0FBYyxDQUFDemlCLFNBQVMrZ0I7UUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQ2xJLG1CQUFtQixFQUFFO1lBQzdCO1FBQ0Y7UUFDQSxNQUFNL25CLGFBQWEsSUFBSSxDQUFDNlAsVUFBVSxDQUFDMFQscUNBQXFDLENBQUMsSUFBSSxDQUFDd0UsbUJBQW1CO1FBQ2pHLElBQUkvbkIsWUFBWTtZQUNkLElBQUksQ0FBQysrQix5QkFBeUIsQ0FBQy8rQjtRQUNqQztJQUNGO0lBQ0EsSUFBSWcvQixtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUMsQ0FBQzl2QixPQUFPLEVBQUV3aUI7SUFDeEI7SUFDQSxJQUFJdU4sb0JBQW9CO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLENBQUMvdkIsT0FBTyxFQUFFdWlCO0lBQ3hCO0lBQ0EsSUFBSXpKLGFBQWE7UUFDZixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQzlZLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDQSxPQUFPLENBQUMwTixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzFOLE9BQU8sQ0FBQ3VpQixTQUFTO0lBQ2hGO0lBQ0EsTUFBTWpTLFlBQVkvc0QsT0FBTyxFQUFFO1FBQ3pCLElBQUksQ0FBQyxDQUFDeThDLE9BQU8sS0FBSyxJQUFJMGdCLFFBQVEsSUFBSTtRQUNsQyxJQUFJLENBQUMsQ0FBQzFnQixPQUFPLENBQUNxaUIsSUFBSSxDQUFDOStEO0lBQ3JCO0lBQ0FzdEQsY0FBY00sVUFBVSxFQUFFdFgsYUFBYTkxQyxTQUFTLEVBQUU7UUFDaEQsSUFBSSxJQUFJLENBQUMrMEQsVUFBVSxFQUFFO1lBQ25CLElBQUksQ0FBQ25ZLFVBQVUsQ0FBQ2tRLGFBQWEsQ0FBQyxJQUFJLEVBQUVNLFlBQVl0WDtRQUNsRDtJQUNGO0lBQ0FtMkIseUJBQXlCditCLFFBQVEsRUFBRTtRQUNqQyxJQUFJLENBQUMsQ0FBQ3VPLE9BQU8sQ0FBQ2l3QixpQkFBaUIsQ0FBQ3grQjtJQUNsQztJQUNBMFEsV0FBV29VLFVBQVUsRUFBRTtRQUNyQixJQUFJLElBQUksQ0FBQ3VaLGdCQUFnQixFQUFFO1lBQ3pCLE1BQU1JLHNCQUFzQjtZQUM1QixNQUFNQyx1QkFBdUI7WUFDN0IsTUFBTSxPQUFLQyxJQUFJLEdBQUc3WixXQUFXanVCLElBQUk7WUFDakMsTUFBTSxDQUFDeU4sVUFBVSxHQUFHLElBQUksQ0FBQ215QixjQUFjO1lBQ3ZDLE1BQU0sQ0FBQ2p5QixNQUFNLEdBQUcsSUFBSSxDQUFDa3lCLGVBQWU7WUFDcEMsTUFBTWtJLE1BQU1wNkIsUUFBUUYsWUFBWTtZQUNoQyxNQUFNdTZCLE1BQU1GLE1BQU1EO1lBQ2xCLE1BQU1JLE1BQU1GLE1BQU1IO1lBQ2xCM1osV0FBV2lhLEtBQUssR0FBRztnQkFDakJDLFVBQVUsSUFBSSxDQUFDendCLE9BQU8sQ0FBQ2h6QixJQUFJO2dCQUMzQityQyxTQUFTLElBQUksQ0FBQy9ZLE9BQU8sQ0FBQytZLE9BQU87Z0JBQzdCendCLE1BQU07b0JBQUMrbkM7b0JBQUtDO29CQUFLQztvQkFBS0g7aUJBQUk7WUFDNUI7UUFDRjtJQUNGO0lBQ0FQLDBCQUEwQixFQUN4QlcsT0FBTyxFQUNMQyxRQUFRLEVBQ1IxWCxPQUFPLEVBQ1IsRUFDRixFQUFFO1FBQ0QsSUFBSSxDQUFDLENBQUMvWSxPQUFPLENBQUNqdkMsSUFBSSxHQUFHZ29ELFVBQVUsT0FBTzBYO0lBQ3hDO0lBQ0EsSUFBSUMsMkJBQTJCO1FBQzdCLE9BQU8sSUFBSSxDQUFDNTlCLE1BQU0sQ0FBQzB1QixrQkFBa0I7SUFDdkM7SUFDQXJ2QixTQUFTO1FBQ1AsTUFBTU8sTUFBTSxJQUFJLENBQUNBLEdBQUcsR0FBR25rQyxTQUFTMkksYUFBYSxDQUFDO1FBQzlDdzdCLElBQUl2QixZQUFZLENBQUMsd0JBQXdCLENBQUMsTUFBTSxJQUFJLENBQUM0RCxRQUFRLElBQUk7UUFDakVyQyxJQUFJNEwsU0FBUyxHQUFHLElBQUksQ0FBQ2g3QyxJQUFJO1FBQ3pCb3ZDLElBQUl2QixZQUFZLENBQUMsTUFBTSxJQUFJLENBQUNoOEIsRUFBRTtRQUM5QnU5QixJQUFJcVAsUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDc2UsUUFBUSxHQUFHLENBQUMsSUFBSTtRQUNyQzN0QixJQUFJdkIsWUFBWSxDQUFDLFFBQVE7UUFDekIsSUFBSSxJQUFJLENBQUN3L0IsYUFBYSxFQUFFO1lBQ3RCaitCLElBQUl2QixZQUFZLENBQUMsZ0JBQWdCLElBQUksQ0FBQ3cvQixhQUFhO1FBQ3JEO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ2hKLFVBQVUsRUFBRTtZQUNwQmoxQixJQUFJK0osU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztRQUNwQjtRQUNBLElBQUksQ0FBQ3V6RCxlQUFlO1FBQ3BCLElBQUksQ0FBQyxDQUFDZ0gsaUJBQWlCO1FBQ3ZCLE1BQU0sQ0FBQ2pULGFBQWFDLGFBQWEsR0FBRyxJQUFJLENBQUMwRSxnQkFBZ0I7UUFDekQsSUFBSSxJQUFJLENBQUNtSCxjQUFjLEdBQUcsUUFBUSxHQUFHO1lBQ25DLzJCLElBQUl4a0MsS0FBSyxDQUFDMmlFLFFBQVEsR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNalQsZUFBZUQsV0FBVSxFQUFHdU4sT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3hFeDRCLElBQUl4a0MsS0FBSyxDQUFDNGlFLFNBQVMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNblQsY0FBY0MsWUFBVyxFQUFHc04sT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzNFO1FBQ0EsTUFBTSxDQUFDck8sSUFBSUMsR0FBRyxHQUFHLElBQUksQ0FBQytPLHFCQUFxQjtRQUMzQyxJQUFJLENBQUNwQixTQUFTLENBQUM1TixJQUFJQztRQUNuQnZZLFdBQVcsSUFBSSxFQUFFN1IsS0FBSztZQUFDO1lBQVc7WUFBZTtTQUFXO1FBQzVELElBQUksSUFBSSxDQUFDdnZCLFdBQVcsSUFBSSxJQUFJLENBQUN3OUIsVUFBVSxDQUFDaU8sb0JBQW9CLEVBQUU7WUFDNUQsSUFBSSxDQUFDLENBQUMrWCxZQUFZLEtBQUssSUFBSWpFLGFBQWE7Z0JBQ3RDbmtCLFdBQVc3TDtnQkFDWG13QixvQkFBb0IsSUFBTSxDQUFDLElBQUksQ0FBQzFSLFVBQVU7Z0JBQzFDMlIsY0FBYyxJQUFJLENBQUMsQ0FBQ2lPLHVCQUF1QixDQUFDeHFFLElBQUksQ0FBQyxJQUFJO2dCQUNyRHc4RCxZQUFZLElBQUksQ0FBQyxDQUFDaU8sa0JBQWtCLENBQUN6cUUsSUFBSSxDQUFDLElBQUk7Z0JBQzlDeThELFlBQVksSUFBSSxDQUFDLENBQUNpTyxxQkFBcUIsQ0FBQzFxRSxJQUFJLENBQUMsSUFBSTtnQkFDakRncEMsUUFBUSxJQUFJLENBQUNvUixVQUFVLENBQUNDLE9BQU87WUFDakM7UUFDRjtRQUNBLElBQUksQ0FBQ3lYLDBCQUEwQjtRQUMvQixJQUFJLENBQUMxWCxVQUFVLENBQUM2TSxjQUFjLEVBQUVoTTtRQUNoQyxPQUFPOU87SUFDVDtJQUNBLENBQUNxK0IsdUJBQXVCO1FBQ3RCLElBQUksQ0FBQyxDQUFDaEwsZUFBZSxHQUFHO1lBQ3RCN0osUUFBUSxJQUFJLENBQUMvMEQsQ0FBQztZQUNkZzFELFFBQVEsSUFBSSxDQUFDdG9ELENBQUM7WUFDZHc0RCxZQUFZLElBQUksQ0FBQzEyQixLQUFLO1lBQ3RCMjJCLGFBQWEsSUFBSSxDQUFDMTJCLE1BQU07UUFDMUI7UUFDQSxJQUFJLENBQUMsQ0FBQ21LLE9BQU8sRUFBRXlTLE9BQU87UUFDdEIsSUFBSSxDQUFDMWYsTUFBTSxDQUFDcTVCLG1CQUFtQixDQUFDO0lBQ2xDO0lBQ0EsQ0FBQzZFLGtCQUFrQixDQUFDRSxPQUFPLEVBQUVDLFlBQVksRUFBRS9MLFFBQVE7UUFDakQsTUFBTWdNLGlCQUFpQjtRQUN2QixJQUFJQyxTQUFTRCxpQkFBa0JoTSxDQUFBQSxXQUFXK0wsWUFBVyxJQUFLLElBQUlDO1FBQzlELElBQUlDLFdBQVcsR0FBRztZQUNoQjtRQUNGO1FBQ0EsTUFBTWxFLGlCQUFpQixJQUFJLENBQUMsQ0FBQ3pCLGlCQUFpQixDQUFDLElBQUksQ0FBQzMyQixRQUFRO1FBQzVELE1BQU1xNEIsU0FBUyxDQUFDam1FLEdBQUcwTSxJQUFNO2dCQUFDczVELGNBQWMsQ0FBQyxFQUFFLEdBQUdobUUsSUFBSWdtRSxjQUFjLENBQUMsRUFBRSxHQUFHdDVEO2dCQUFHczVELGNBQWMsQ0FBQyxFQUFFLEdBQUdobUUsSUFBSWdtRSxjQUFjLENBQUMsRUFBRSxHQUFHdDVEO2FBQUU7UUFDdkgsTUFBTSxDQUFDOHBELGFBQWFDLGFBQWEsR0FBRyxJQUFJLENBQUMwRSxnQkFBZ0I7UUFDekQsTUFBTXBHLFNBQVMsSUFBSSxDQUFDLzBELENBQUM7UUFDckIsTUFBTWcxRCxTQUFTLElBQUksQ0FBQ3RvRCxDQUFDO1FBQ3JCLE1BQU13NEQsYUFBYSxJQUFJLENBQUMxMkIsS0FBSztRQUM3QixNQUFNMjJCLGNBQWMsSUFBSSxDQUFDMTJCLE1BQU07UUFDL0IsTUFBTW8zQixXQUFXeEgsaUJBQWlCeUgsUUFBUSxHQUFHdFA7UUFDN0MsTUFBTXVQLFlBQVkxSCxpQkFBaUJ5SCxRQUFRLEdBQUdyUDtRQUM5Q3lULFNBQVNycUUsS0FBSzRQLEdBQUcsQ0FBQzVQLEtBQUttRixHQUFHLENBQUNrbEUsUUFBUSxJQUFJaEYsWUFBWSxJQUFJQyxjQUFjVSxXQUFXWCxZQUFZYSxZQUFZWjtRQUN4RyxNQUFNTyxXQUFXckgsaUJBQWlCdUgsTUFBTSxDQUFDVixhQUFhZ0Y7UUFDdEQsTUFBTXZFLFlBQVl0SCxpQkFBaUJ1SCxNQUFNLENBQUNULGNBQWMrRTtRQUN4RCxJQUFJeEUsYUFBYVIsY0FBY1MsY0FBY1IsYUFBYTtZQUN4RDtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNsRyxXQUFXLEtBQUs7WUFBQ2xLO1lBQVFDO1lBQVFrUTtZQUFZQztTQUFZO1FBQy9ELE1BQU1nRixvQkFBb0JsRSxPQUFPZixhQUFhLEdBQUdDLGNBQWM7UUFDL0QsTUFBTW4zQixVQUFVcXdCLGlCQUFpQnVILE1BQU0sQ0FBQzdRLFNBQVNvVixpQkFBaUIsQ0FBQyxFQUFFO1FBQ3JFLE1BQU1sOEIsVUFBVW93QixpQkFBaUJ1SCxNQUFNLENBQUM1USxTQUFTbVYsaUJBQWlCLENBQUMsRUFBRTtRQUNyRSxNQUFNQyx1QkFBdUJuRSxPQUFPUCxXQUFXLEdBQUdDLFlBQVk7UUFDOUQsSUFBSSxDQUFDM2xFLENBQUMsR0FBR2d1QyxVQUFVbzhCLG9CQUFvQixDQUFDLEVBQUU7UUFDMUMsSUFBSSxDQUFDMTlELENBQUMsR0FBR3VoQyxVQUFVbThCLG9CQUFvQixDQUFDLEVBQUU7UUFDMUMsSUFBSSxDQUFDNTdCLEtBQUssR0FBR2szQjtRQUNiLElBQUksQ0FBQ2ozQixNQUFNLEdBQUdrM0I7UUFDZCxJQUFJLENBQUNsQixPQUFPO1FBQ1osSUFBSSxDQUFDbEMsaUJBQWlCO1FBQ3RCLElBQUksQ0FBQzhFLFdBQVc7SUFDbEI7SUFDQSxDQUFDeUMscUJBQXFCO1FBQ3BCLElBQUksQ0FBQyxDQUFDbHhCLE9BQU8sRUFBRXlTLE9BQU87UUFDdEIsSUFBSSxDQUFDMWYsTUFBTSxDQUFDcTVCLG1CQUFtQixDQUFDO1FBQ2hDLElBQUksQ0FBQyxDQUFDUSxvQkFBb0I7SUFDNUI7SUFDQTZFLFlBQVl4Z0MsS0FBSyxFQUFFO1FBQ2pCLE1BQU0sRUFDSjVLLEtBQUssRUFDTixHQUFHUixpQkFBaUJLLFFBQVE7UUFDN0IsSUFBSStLLE1BQU04USxNQUFNLEtBQUssS0FBSzlRLE1BQU15WCxPQUFPLElBQUlyaUIsT0FBTztZQUNoRDRLLE1BQU1tSCxjQUFjO1lBQ3BCO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQ2d1QixjQUFjLEdBQUc7UUFDdkIsSUFBSSxJQUFJLENBQUNvRCxZQUFZLEVBQUU7WUFDckIsSUFBSSxDQUFDLENBQUN0TixnQkFBZ0IsQ0FBQ2pyQjtZQUN2QjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUN5Z0Msb0JBQW9CLENBQUN6Z0M7SUFDN0I7SUFDQSxDQUFDeWdDLG9CQUFvQixDQUFDemdDLEtBQUs7UUFDekIsTUFBTSxFQUNKNUssS0FBSyxFQUNOLEdBQUdSLGlCQUFpQkssUUFBUTtRQUM3QixJQUFJK0ssTUFBTXlYLE9BQU8sSUFBSSxDQUFDcmlCLFNBQVM0SyxNQUFNMlgsUUFBUSxJQUFJM1gsTUFBTTBYLE9BQU8sSUFBSXRpQixPQUFPO1lBQ3ZFLElBQUksQ0FBQzBNLE1BQU0sQ0FBQ3NvQixjQUFjLENBQUMsSUFBSTtRQUNqQyxPQUFPO1lBQ0wsSUFBSSxDQUFDdG9CLE1BQU0sQ0FBQ3NtQixXQUFXLENBQUMsSUFBSTtRQUM5QjtJQUNGO0lBQ0EsQ0FBQzZDLGdCQUFnQixDQUFDanJCLEtBQUs7UUFDckIsTUFBTSxFQUNKbWdCLFVBQVUsRUFDWCxHQUFHLElBQUk7UUFDUixJQUFJLENBQUN4USxVQUFVLENBQUNzYixnQkFBZ0I7UUFDaEMsSUFBSXlWLHFCQUFxQjtRQUN6QixNQUFNcmlDLEtBQUssSUFBSUM7UUFDZixNQUFNQyxTQUFTLElBQUksQ0FBQ29SLFVBQVUsQ0FBQ3FPLGNBQWMsQ0FBQzNmO1FBQzlDLE1BQU1vMEIsT0FBTztZQUNYbGlCLFNBQVM7WUFDVCtoQixTQUFTO1lBQ1QvekI7UUFDRjtRQUNBLE1BQU1vaUMsYUFBYTM3RCxDQUFBQTtZQUNqQnE1QixHQUFHSSxLQUFLO1lBQ1IsSUFBSSxDQUFDLENBQUNrMkIsYUFBYSxHQUFHO1lBQ3RCLElBQUksQ0FBQyxDQUFDUSxjQUFjLEdBQUc7WUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQ3hsQixVQUFVLENBQUM2YixjQUFjLElBQUk7Z0JBQ3JDLElBQUksQ0FBQyxDQUFDaVYsb0JBQW9CLENBQUN6N0Q7WUFDN0I7WUFDQSxJQUFJMDdELG9CQUFvQjtnQkFDdEIsSUFBSSxDQUFDRSxlQUFlO1lBQ3RCO1FBQ0Y7UUFDQSxJQUFJemdCLFlBQVk7WUFDZCxJQUFJLENBQUMsQ0FBQ3FWLFNBQVMsR0FBR3gxQixNQUFNNmdDLE9BQU87WUFDL0IsSUFBSSxDQUFDLENBQUNwTCxTQUFTLEdBQUd6MUIsTUFBTThnQyxPQUFPO1lBQy9CLElBQUksQ0FBQyxDQUFDbk0sYUFBYSxHQUFHMzBCLE1BQU0rZ0MsU0FBUztZQUNyQyxJQUFJLENBQUMsQ0FBQ25NLGVBQWUsR0FBRzUwQixNQUFNMnlCLFdBQVc7WUFDekMzckQsT0FBTzIzQixnQkFBZ0IsQ0FBQyxlQUFlMzVCLENBQUFBO2dCQUNyQyxJQUFJLENBQUMwN0Qsb0JBQW9CO29CQUN2QkEscUJBQXFCO29CQUNyQixJQUFJLENBQUMvd0IsVUFBVSxDQUFDa1EsYUFBYSxDQUFDLElBQUksRUFBRSxNQUFNO29CQUMxQyxJQUFJLENBQUNtaEIsZ0JBQWdCO2dCQUN2QjtnQkFDQSxNQUFNLEVBQ0pILFNBQVMxcUUsQ0FBQyxFQUNWMnFFLFNBQVNqK0QsQ0FBQyxFQUNWaytELFNBQVMsRUFDVixHQUFHLzdEO2dCQUNKLElBQUkrN0QsY0FBYyxJQUFJLENBQUMsQ0FBQ3BNLGFBQWEsRUFBRTtvQkFDckN2dEIsVUFBVXBpQztvQkFDVjtnQkFDRjtnQkFDQSxNQUFNLENBQUM2bUQsSUFBSUMsR0FBRyxHQUFHLElBQUksQ0FBQ3NOLHVCQUF1QixDQUFDampFLElBQUksSUFBSSxDQUFDLENBQUNxL0QsU0FBUyxFQUFFM3lELElBQUksSUFBSSxDQUFDLENBQUM0eUQsU0FBUztnQkFDdEYsSUFBSSxDQUFDLENBQUNELFNBQVMsR0FBR3IvRDtnQkFDbEIsSUFBSSxDQUFDLENBQUNzL0QsU0FBUyxHQUFHNXlEO2dCQUNsQixJQUFJLENBQUM4c0MsVUFBVSxDQUFDaWMsbUJBQW1CLENBQUNDLElBQUlDO1lBQzFDLEdBQUcyRztZQUNIenJELE9BQU8yM0IsZ0JBQWdCLENBQUMsYUFBYXlJLFdBQVdxckI7WUFDaER6ckQsT0FBTzIzQixnQkFBZ0IsQ0FBQyxlQUFlMzVCLENBQUFBO2dCQUNyQyxJQUFJQSxFQUFFMnRELFdBQVcsS0FBSyxJQUFJLENBQUMsQ0FBQ2lDLGVBQWUsRUFBRTtvQkFDM0MsSUFBSSxJQUFJLENBQUMsQ0FBQ2UsWUFBWSxJQUFJM3dELEVBQUVpOEQsU0FBUyxFQUFFO3dCQUNyQ04sV0FBVzM3RDtvQkFDYjtnQkFDRjtnQkFDQW9pQyxVQUFVcGlDO1lBQ1osR0FBR3l0RDtRQUNMO1FBQ0EsTUFBTWlKLG9CQUFvQjEyRCxDQUFBQTtZQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMydkQsYUFBYSxJQUFJLElBQUksQ0FBQyxDQUFDQSxhQUFhLEtBQUszdkQsRUFBRSs3RCxTQUFTLEVBQUU7Z0JBQy9ESixXQUFXMzdEO2dCQUNYO1lBQ0Y7WUFDQW9pQyxVQUFVcGlDO1FBQ1o7UUFDQWdDLE9BQU8yM0IsZ0JBQWdCLENBQUMsYUFBYSs4QixtQkFBbUI7WUFDdERuOUI7UUFDRjtRQUNBdjNCLE9BQU8yM0IsZ0JBQWdCLENBQUMsUUFBUSs4QixtQkFBbUI7WUFDakRuOUI7UUFDRjtJQUNGO0lBQ0F5aUMsbUJBQW1CLENBQUM7SUFDcEJKLGtCQUFrQixDQUFDO0lBQ25CdEcsWUFBWTtRQUNWLElBQUksSUFBSSxDQUFDLENBQUMvRSxnQkFBZ0IsRUFBRTtZQUMxQnhYLGFBQWEsSUFBSSxDQUFDLENBQUN3WCxnQkFBZ0I7UUFDckM7UUFDQSxJQUFJLENBQUMsQ0FBQ0EsZ0JBQWdCLEdBQUdoTSxXQUFXO1lBQ2xDLElBQUksQ0FBQyxDQUFDZ00sZ0JBQWdCLEdBQUc7WUFDekIsSUFBSSxDQUFDenpCLE1BQU0sRUFBRW8vQixnQkFBZ0IsSUFBSTtRQUNuQyxHQUFHO0lBQ0w7SUFDQXZWLHNCQUFzQjdwQixNQUFNLEVBQUUzckMsQ0FBQyxFQUFFME0sQ0FBQyxFQUFFO1FBQ2xDaS9CLE9BQU9tcUIsWUFBWSxDQUFDLElBQUk7UUFDeEIsSUFBSSxDQUFDOTFELENBQUMsR0FBR0E7UUFDVCxJQUFJLENBQUMwTSxDQUFDLEdBQUdBO1FBQ1QsSUFBSSxDQUFDNjFELGlCQUFpQjtRQUN0QixJQUFJLENBQUNjLGFBQWE7SUFDcEI7SUFDQTJILFFBQVF0VixFQUFFLEVBQUVDLEVBQUUsRUFBRS9uQixXQUFXLElBQUksQ0FBQ0EsUUFBUSxFQUFFO1FBQ3hDLE1BQU1ELFFBQVEsSUFBSSxDQUFDNjJCLFdBQVc7UUFDOUIsTUFBTSxDQUFDNTFCLFdBQVdDLFdBQVcsR0FBRyxJQUFJLENBQUNreUIsY0FBYztRQUNuRCxNQUFNLENBQUNqeUIsT0FBT0MsTUFBTSxHQUFHLElBQUksQ0FBQ2l5QixlQUFlO1FBQzNDLE1BQU1pSyxTQUFTdlYsS0FBSy9uQjtRQUNwQixNQUFNdTlCLFNBQVN2VixLQUFLaG9CO1FBQ3BCLE1BQU0zdEMsSUFBSSxJQUFJLENBQUNBLENBQUMsR0FBRzR1QztRQUNuQixNQUFNbGlDLElBQUksSUFBSSxDQUFDQSxDQUFDLEdBQUdtaUM7UUFDbkIsTUFBTUwsUUFBUSxJQUFJLENBQUNBLEtBQUssR0FBR0k7UUFDM0IsTUFBTUgsU0FBUyxJQUFJLENBQUNBLE1BQU0sR0FBR0k7UUFDN0IsT0FBUWpCO1lBQ04sS0FBSztnQkFDSCxPQUFPO29CQUFDNXRDLElBQUlpckUsU0FBU244QjtvQkFBT0QsYUFBYW5pQyxJQUFJdytELFNBQVN6OEIsU0FBU007b0JBQU8vdUMsSUFBSWlyRSxTQUFTejhCLFFBQVFNO29CQUFPRCxhQUFhbmlDLElBQUl3K0QsU0FBU244QjtpQkFBTTtZQUNwSSxLQUFLO2dCQUNILE9BQU87b0JBQUMvdUMsSUFBSWtyRSxTQUFTcDhCO29CQUFPRCxhQUFhbmlDLElBQUl1K0QsU0FBU2w4QjtvQkFBTy91QyxJQUFJa3JFLFNBQVN6OEIsU0FBU0s7b0JBQU9ELGFBQWFuaUMsSUFBSXUrRCxTQUFTejhCLFFBQVFPO2lCQUFNO1lBQ3BJLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQy91QyxJQUFJaXJFLFNBQVN6OEIsUUFBUU07b0JBQU9ELGFBQWFuaUMsSUFBSXcrRCxTQUFTbjhCO29CQUFPL3VDLElBQUlpckUsU0FBU244QjtvQkFBT0QsYUFBYW5pQyxJQUFJdytELFNBQVN6OEIsU0FBU007aUJBQU07WUFDcEksS0FBSztnQkFDSCxPQUFPO29CQUFDL3VDLElBQUlrckUsU0FBU3o4QixTQUFTSztvQkFBT0QsYUFBYW5pQyxJQUFJdStELFNBQVN6OEIsUUFBUU87b0JBQU8vdUMsSUFBSWtyRSxTQUFTcDhCO29CQUFPRCxhQUFhbmlDLElBQUl1K0QsU0FBU2w4QjtpQkFBTTtZQUNwSTtnQkFDRSxNQUFNLElBQUl2M0IsTUFBTTtRQUNwQjtJQUNGO0lBQ0EyekQsdUJBQXVCaHFDLElBQUksRUFBRTBOLFVBQVUsRUFBRTtRQUN2QyxNQUFNLENBQUN0TCxJQUFJQyxJQUFJRSxJQUFJRSxHQUFHLEdBQUd6QztRQUN6QixNQUFNcU4sUUFBUTlLLEtBQUtIO1FBQ25CLE1BQU1rTCxTQUFTN0ssS0FBS0o7UUFDcEIsT0FBUSxJQUFJLENBQUNvSyxRQUFRO1lBQ25CLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQ3JLO29CQUFJc0wsYUFBYWpMO29CQUFJNEs7b0JBQU9DO2lCQUFPO1lBQzdDLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQ2xMO29CQUFJc0wsYUFBYXJMO29CQUFJaUw7b0JBQVFEO2lCQUFNO1lBQzdDLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQzlLO29CQUFJbUwsYUFBYXJMO29CQUFJZ0w7b0JBQU9DO2lCQUFPO1lBQzdDLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQy9LO29CQUFJbUwsYUFBYWpMO29CQUFJNks7b0JBQVFEO2lCQUFNO1lBQzdDO2dCQUNFLE1BQU0sSUFBSWgzQixNQUFNO1FBQ3BCO0lBQ0Y7SUFDQTR6RCxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUNKLE9BQU8sQ0FBQyxHQUFHO0lBQ3pCO0lBQ0FyaUIsaUJBQWlCO1FBQ2YsT0FBTyxJQUFJLENBQUN0VyxLQUFLLElBQUlnc0IsaUJBQWlCd0IsYUFBYSxDQUFDL2QsT0FBTyxDQUFDLElBQUksQ0FBQ3RJLFVBQVUsQ0FBQ21QLGNBQWMsQ0FBQyxJQUFJLENBQUN0VyxLQUFLO0lBQ3ZHO0lBQ0E4bkIsaUJBQWlCO1FBQ2YsSUFBSSxDQUFDLENBQUN0aEIsT0FBTyxFQUFFc2hCO0lBQ2pCO0lBQ0F2USxVQUFVO1FBQ1IsTUFBTSxFQUNKL1EsU0FBUyxFQUNQaHpCLE1BQU1vWSxHQUFHLEVBQ1RvVSxLQUFLLEVBQ0x6TSxJQUFJLEVBQ0o0UCxPQUFPLEVBQ1BvYyxPQUFPLEVBQ1BnSSxRQUFRLEVBQ1QsRUFDRHpsRCxLQUFLbkcsRUFBRSxFQUNQdzdDLFNBQVMsRUFDVG9YLFlBQVksRUFDWkMsZ0JBQWdCLEVBQ2pCLEdBQUcsSUFBSTtRQUNSLE9BQU87WUFDTDd5RDtZQUNBdzdDO1lBQ0Fyb0IsTUFBTSxJQUFJLENBQUNpcUMsVUFBVTtZQUNyQnhSO1lBQ0E3SCxhQUFhO2dCQUNYOXpCO1lBQ0Y7WUFDQTJpQztZQUNBQyxrQkFBa0JqN0IsUUFBUWk3QjtZQUMxQi9PLFVBQVUsQ0FBQ0Y7WUFDWHZmO1lBQ0FtRDtRQUNGO0lBQ0Y7SUFDQTYxQixVQUFVcmdCLEtBQUssRUFBRSxDQUFDO0lBQ2xCekUsVUFBVTtRQUNSLE9BQU87SUFDVDtJQUNBK2tCLGlCQUFpQjtRQUNmLElBQUksSUFBSSxDQUFDcE0sWUFBWSxJQUFJO1lBQ3ZCLE9BQU87UUFDVDtRQUNBLElBQUksQ0FBQ3Z6QixNQUFNLENBQUNxa0IsZUFBZSxDQUFDO1FBQzVCLElBQUksQ0FBQyxDQUFDa1AsWUFBWSxHQUFHO1FBQ3JCLE9BQU87SUFDVDtJQUNBcU0sa0JBQWtCO1FBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUNyTSxZQUFZLElBQUk7WUFDeEIsT0FBTztRQUNUO1FBQ0EsSUFBSSxDQUFDdnpCLE1BQU0sQ0FBQ3FrQixlQUFlLENBQUM7UUFDNUIsSUFBSSxDQUFDLENBQUNrUCxZQUFZLEdBQUc7UUFDckIsT0FBTztJQUNUO0lBQ0FBLGVBQWU7UUFDYixPQUFPLElBQUksQ0FBQyxDQUFDQSxZQUFZO0lBQzNCO0lBQ0FsSiwwQkFBMEI7UUFDeEIsT0FBTyxJQUFJLENBQUMsQ0FBQ21KLDJCQUEyQjtJQUMxQztJQUNBcU0sbUJBQW1CO1FBQ2pCLE9BQU8sSUFBSSxDQUFDamdDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQzAxQixlQUFlO0lBQzFDO0lBQ0EsSUFBSXdLLGFBQWE7UUFDZixNQUFNLEVBQ0oxeEIsR0FBRyxFQUNIK3BCLElBQUksRUFDSjRILE1BQU0sRUFDTkMsS0FBSyxFQUNOLEdBQUcsSUFBSSxDQUFDM0QsbUJBQW1CO1FBQzVCLE1BQU0sRUFDSjRELFdBQVcsRUFDWEMsVUFBVSxFQUNYLEdBQUdoN0Q7UUFDSixPQUFPaXpELE9BQU8rSCxjQUFjRixRQUFRLEtBQUs1eEIsTUFBTTZ4QixlQUFlRixTQUFTO0lBQ3pFO0lBQ0EsQ0FBQ2pDLGlCQUFpQjtRQUNoQixJQUFJLElBQUksQ0FBQyxDQUFDM0ssT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDdnpCLEdBQUcsRUFBRTtZQUM5QjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUN1ekIsT0FBTyxHQUFHLElBQUkzMkI7UUFDcEIsTUFBTUMsU0FBUyxJQUFJLENBQUNvUixVQUFVLENBQUNxTyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUNpWCxPQUFPO1FBQzNELElBQUksQ0FBQ3Z6QixHQUFHLENBQUMvQyxnQkFBZ0IsQ0FBQyxXQUFXLElBQUksQ0FBQ282QixPQUFPLENBQUN4akUsSUFBSSxDQUFDLElBQUksR0FBRztZQUM1RGdwQztRQUNGO1FBQ0EsSUFBSSxDQUFDbUQsR0FBRyxDQUFDL0MsZ0JBQWdCLENBQUMsWUFBWSxJQUFJLENBQUNxNkIsUUFBUSxDQUFDempFLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDOURncEM7UUFDRjtJQUNGO0lBQ0F5dEIsVUFBVTtRQUNSLElBQUksQ0FBQyxDQUFDNFQsaUJBQWlCO0lBQ3pCO0lBQ0FxQyxPQUFPQyxNQUFNLEVBQUUsQ0FBQztJQUNoQjlMLFNBQVMsQ0FBQztJQUNWK0wsbUJBQW1CO1FBQ2pCLE9BQU87WUFDTGgrRCxJQUFJLElBQUksQ0FBQzBqRCxtQkFBbUI7WUFDNUJFLFNBQVM7WUFDVHBJLFdBQVcsSUFBSSxDQUFDQSxTQUFTO1lBQ3pCc0ksVUFBVSxJQUFJLENBQUN5TyxZQUFZLEVBQUV6TyxZQUFZO1FBQzNDO0lBQ0Y7SUFDQTFRLFVBQVUwWCxlQUFlLEtBQUssRUFBRTkwQyxVQUFVLElBQUksRUFBRTtRQUM5QyxPQUFPO1lBQ0xpb0QsZ0JBQWdCLElBQUksQ0FBQzFyRCxJQUFJO1lBQ3pCaXBDLFdBQVcsSUFBSSxDQUFDQSxTQUFTO1lBQ3pCcm9CLE1BQU0sSUFBSSxDQUFDaXFDLFVBQVU7WUFDckJ4OUIsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkJzK0Isb0JBQW9CLElBQUksQ0FBQ3ZMLG1CQUFtQjtZQUM1QzdPLFVBQVUsSUFBSSxDQUFDeU8sWUFBWSxFQUFFek8sWUFBWTtRQUMzQztJQUNGO0lBQ0EsYUFBYXJDLFlBQVk3bEQsSUFBSSxFQUFFK2hDLE1BQU0sRUFBRTBRLFNBQVMsRUFBRTtRQUNoRCxNQUFNM0QsU0FBUyxJQUFJLElBQUksQ0FBQy83QyxTQUFTLENBQUNGLFdBQVcsQ0FBQztZQUM1Q2t2QztZQUNBMzlCLElBQUkyOUIsT0FBTzYxQixTQUFTO1lBQ3BCbmxCO1lBQ0FxVixxQkFBcUI5bkQsS0FBSzhuRCxtQkFBbUI7WUFDN0NrUCxjQUFjaDNELEtBQUtnM0QsWUFBWTtZQUMvQkMsa0JBQWtCajNELEtBQUtpM0QsZ0JBQWdCO1FBQ3pDO1FBQ0Fub0IsT0FBTzlLLFFBQVEsR0FBR2hrQyxLQUFLZ2tDLFFBQVE7UUFDL0I4SyxPQUFPLENBQUM0bEIsaUJBQWlCLEdBQUcxMEQsS0FBSzAwRCxpQkFBaUI7UUFDbEQ1bEIsT0FBTzBuQixPQUFPLEdBQUd4MkQsS0FBS3VpRSxNQUFNLElBQUk7UUFDaEMsTUFBTSxDQUFDdjlCLFdBQVdDLFdBQVcsR0FBRzZKLE9BQU9xb0IsY0FBYztRQUNyRCxNQUFNLENBQUMvZ0UsR0FBRzBNLEdBQUc4aEMsT0FBT0MsT0FBTyxHQUFHaUssT0FBT3l5QixzQkFBc0IsQ0FBQ3ZoRSxLQUFLdTNCLElBQUksRUFBRTBOO1FBQ3ZFNkosT0FBTzE0QyxDQUFDLEdBQUdBLElBQUk0dUM7UUFDZjhKLE9BQU9oc0MsQ0FBQyxHQUFHQSxJQUFJbWlDO1FBQ2Y2SixPQUFPbEssS0FBSyxHQUFHQSxRQUFRSTtRQUN2QjhKLE9BQU9qSyxNQUFNLEdBQUdBLFNBQVNJO1FBQ3pCLE9BQU82SjtJQUNUO0lBQ0EsSUFBSXNlLGtCQUFrQjtRQUNwQixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUN0RixtQkFBbUIsSUFBSyxLQUFJLENBQUNFLE9BQU8sSUFBSSxJQUFJLENBQUN4USxTQUFTLE9BQU8sSUFBRztJQUNoRjtJQUNBM3lDLFNBQVM7UUFDUCxJQUFJLENBQUMsQ0FBQ3F3RCxPQUFPLEVBQUV4MkI7UUFDZixJQUFJLENBQUMsQ0FBQ3cyQixPQUFPLEdBQUc7UUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQ3ZZLE9BQU8sSUFBSTtZQUNuQixJQUFJLENBQUNnTyxNQUFNO1FBQ2I7UUFDQSxJQUFJLElBQUksQ0FBQzVvQixNQUFNLEVBQUU7WUFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQ2w5QixNQUFNLENBQUMsSUFBSTtRQUN6QixPQUFPO1lBQ0wsSUFBSSxDQUFDK3FDLFVBQVUsQ0FBQzJaLFlBQVksQ0FBQyxJQUFJO1FBQ25DO1FBQ0EsSUFBSSxJQUFJLENBQUMsQ0FBQ2lNLGdCQUFnQixFQUFFO1lBQzFCeFgsYUFBYSxJQUFJLENBQUMsQ0FBQ3dYLGdCQUFnQjtZQUNuQyxJQUFJLENBQUMsQ0FBQ0EsZ0JBQWdCLEdBQUc7UUFDM0I7UUFDQSxJQUFJLENBQUMsQ0FBQ3VELFlBQVk7UUFDbEIsSUFBSSxDQUFDaUYsaUJBQWlCO1FBQ3RCLElBQUksSUFBSSxDQUFDLENBQUNySSxpQkFBaUIsRUFBRTtZQUMzQixLQUFLLE1BQU02TSxXQUFXLElBQUksQ0FBQyxDQUFDN00saUJBQWlCLENBQUNwL0MsTUFBTSxHQUFJO2dCQUN0RHluQyxhQUFhd2tCO1lBQ2Y7WUFDQSxJQUFJLENBQUMsQ0FBQzdNLGlCQUFpQixHQUFHO1FBQzVCO1FBQ0EsSUFBSSxDQUFDNXpCLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQyxDQUFDNnpCLFlBQVksRUFBRXJqQjtRQUNwQixJQUFJLENBQUMsQ0FBQ3FqQixZQUFZLEdBQUc7SUFDdkI7SUFDQSxJQUFJeGpELGNBQWM7UUFDaEIsT0FBTztJQUNUO0lBQ0Fxd0QsZ0JBQWdCO1FBQ2QsSUFBSSxJQUFJLENBQUNyd0QsV0FBVyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxDQUFDMm9ELGNBQWM7WUFDcEIsSUFBSSxDQUFDLENBQUNqRyxXQUFXLENBQUNwcEIsU0FBUyxDQUFDN21DLE1BQU0sQ0FBQztRQUNyQztJQUNGO0lBQ0EsSUFBSW1yQyxrQkFBa0I7UUFDcEIsT0FBTztJQUNUO0lBQ0EsSUFBSW1nQix3QkFBd0I7UUFDMUIsT0FBTyxJQUFJLENBQUN2Z0IsVUFBVSxDQUFDSyxTQUFTLEtBQUssUUFBUTtZQUFDO1lBQUc7U0FBRSxHQUFHO1lBQUM7WUFBRztTQUFFO0lBQzlEO0lBQ0EsSUFBSXl5Qiw4QkFBOEI7UUFDaEMsTUFBTSxFQUNKdlMsdUJBQXVCLENBQUMzUSxNQUFNQyxLQUFLLEVBQ3BDLEdBQUcsSUFBSTtRQUNSLE1BQU0sQ0FBQzZmLEtBQUtDLEtBQUtDLEtBQUtILElBQUksR0FBRyxJQUFJLENBQUNtQyxVQUFVO1FBQzVDLE9BQU87WUFBQy9NLGlCQUFpQnVILE1BQU0sQ0FBQ3NELE1BQU0sQ0FBQ0UsTUFBTUYsR0FBRSxJQUFLOWY7WUFBT2lWLGlCQUFpQnVILE1BQU0sQ0FBQ3VELE1BQU0sQ0FBQ0YsTUFBTUUsR0FBRSxJQUFNLEtBQUk5ZixJQUFHO1NBQUk7SUFDckg7SUFDQSxJQUFJMlEscUJBQXFCO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDeGdCLFVBQVUsQ0FBQzBRLGdCQUFnQixDQUFDLElBQUksQ0FBQ3ZCLGNBQWMsSUFBSSxJQUFJLENBQUNuVCxPQUFPO0lBQzdFO0lBQ0EsSUFBSSsyQix1QkFBdUI7UUFDekIsT0FBTyxJQUFJLENBQUMsQ0FBQzF6QixPQUFPLENBQUN5aEIsMkJBQTJCO0lBQ2xEO0lBQ0EsSUFBSWlTLHFCQUFxQmhzQyxHQUFHLEVBQUU7UUFDNUIsSUFBSSxDQUFDLENBQUNzWSxPQUFPLENBQUN5aEIsMkJBQTJCLEdBQUcvNUI7SUFDOUM7SUFDQWs2QiwwQkFBMEI7UUFDeEIsT0FBTyxJQUFJLENBQUMsQ0FBQzVoQixPQUFPLENBQUM0aEIsdUJBQXVCO0lBQzlDO0lBQ0EsSUFBSUwscUJBQXFCO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLENBQUN2aEIsT0FBTyxDQUFDdWhCLGtCQUFrQjtJQUN6QztJQUNBLElBQUlvUyxxQkFBcUI7UUFDdkIsT0FBTyxJQUFJLENBQUNqaEMsR0FBRztJQUNqQjtJQUNBb3ZCLHVCQUF1QnYrRCxPQUFPLEVBQUU7UUFDOUIsSUFBSSxDQUFDLENBQUN5OEMsT0FBTyxDQUFDOGhCLHNCQUFzQixDQUFDditEO0lBQ3ZDO0lBQ0FpeUQsUUFBUXhrQixLQUFLLEVBQUU7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDN3RCLFdBQVcsSUFBSTZ0QixNQUFNaHdDLE1BQU0sS0FBSyxJQUFJLENBQUMweEMsR0FBRyxJQUFJMUIsTUFBTXBsQyxHQUFHLEtBQUssU0FBUztZQUMzRTtRQUNGO1FBQ0EsSUFBSSxDQUFDKzBDLFVBQVUsQ0FBQ3lZLFdBQVcsQ0FBQyxJQUFJO1FBQ2hDLElBQUksQ0FBQyxDQUFDMk0sZUFBZSxHQUFHO1lBQ3RCN0osUUFBUSxJQUFJLENBQUMvMEQsQ0FBQztZQUNkZzFELFFBQVEsSUFBSSxDQUFDdG9ELENBQUM7WUFDZHc0RCxZQUFZLElBQUksQ0FBQzEyQixLQUFLO1lBQ3RCMjJCLGFBQWEsSUFBSSxDQUFDMTJCLE1BQU07UUFDMUI7UUFDQSxNQUFNckYsV0FBVyxJQUFJLENBQUMsQ0FBQ3MxQixXQUFXLENBQUN0MUIsUUFBUTtRQUMzQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNtMUIsY0FBYyxFQUFFO1lBQ3pCLElBQUksQ0FBQyxDQUFDQSxjQUFjLEdBQUduekQsTUFBTXFXLElBQUksQ0FBQzJuQjtZQUNsQyxNQUFNcWpDLHNCQUFzQixJQUFJLENBQUMsQ0FBQ0MsY0FBYyxDQUFDdHRFLElBQUksQ0FBQyxJQUFJO1lBQzFELE1BQU11dEUsbUJBQW1CLElBQUksQ0FBQyxDQUFDQyxXQUFXLENBQUN4dEUsSUFBSSxDQUFDLElBQUk7WUFDcEQsTUFBTWdwQyxTQUFTLElBQUksQ0FBQ29SLFVBQVUsQ0FBQ0MsT0FBTztZQUN0QyxLQUFLLE1BQU1sTyxPQUFPLElBQUksQ0FBQyxDQUFDZ3pCLGNBQWMsQ0FBRTtnQkFDdEMsTUFBTXBpRSxPQUFPb3ZDLElBQUluQixZQUFZLENBQUM7Z0JBQzlCbUIsSUFBSXZCLFlBQVksQ0FBQyxRQUFRO2dCQUN6QnVCLElBQUkvQyxnQkFBZ0IsQ0FBQyxXQUFXaWtDLHFCQUFxQjtvQkFDbkRya0M7Z0JBQ0Y7Z0JBQ0FtRCxJQUFJL0MsZ0JBQWdCLENBQUMsUUFBUW1rQyxrQkFBa0I7b0JBQzdDdmtDO2dCQUNGO2dCQUNBbUQsSUFBSS9DLGdCQUFnQixDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUNxa0MsWUFBWSxDQUFDenRFLElBQUksQ0FBQyxJQUFJLEVBQUVqRCxPQUFPO29CQUNqRWlzQztnQkFDRjtnQkFDQW1ELElBQUl2QixZQUFZLENBQUMsZ0JBQWdCcTBCLGlCQUFpQm9CLFlBQVksQ0FBQ3RqRSxLQUFLO1lBQ3RFO1FBQ0Y7UUFDQSxNQUFNcW1DLFFBQVEsSUFBSSxDQUFDLENBQUMrN0IsY0FBYyxDQUFDLEVBQUU7UUFDckMsSUFBSXVPLGdCQUFnQjtRQUNwQixLQUFLLE1BQU12aEMsT0FBT25DLFNBQVU7WUFDMUIsSUFBSW1DLFFBQVEvSSxPQUFPO2dCQUNqQjtZQUNGO1lBQ0FzcUM7UUFDRjtRQUNBLE1BQU1DLG9CQUFvQixDQUFDLE1BQU0sSUFBSSxDQUFDbi9CLFFBQVEsR0FBRyxJQUFJLENBQUMwMEIsY0FBYyxJQUFJLE1BQU0sS0FBTSxLQUFJLENBQUMsQ0FBQy9ELGNBQWMsQ0FBQ2xsRSxNQUFNLEdBQUc7UUFDbEgsSUFBSTB6RSxzQkFBc0JELGVBQWU7WUFDdkMsSUFBSUMsb0JBQW9CRCxlQUFlO2dCQUNyQyxJQUFLLElBQUk5dUUsSUFBSSxHQUFHQSxJQUFJOHVFLGdCQUFnQkMsbUJBQW1CL3VFLElBQUs7b0JBQzFELElBQUksQ0FBQyxDQUFDMGdFLFdBQVcsQ0FBQ3ZyRCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUN1ckQsV0FBVyxDQUFDam5CLFVBQVU7Z0JBQ3ZEO1lBQ0YsT0FBTyxJQUFJczFCLG9CQUFvQkQsZUFBZTtnQkFDNUMsSUFBSyxJQUFJOXVFLElBQUksR0FBR0EsSUFBSSt1RSxvQkFBb0JELGVBQWU5dUUsSUFBSztvQkFDMUQsSUFBSSxDQUFDLENBQUMwZ0UsV0FBVyxDQUFDam5CLFVBQVUsQ0FBQ3N3QixNQUFNLENBQUMsSUFBSSxDQUFDLENBQUNySixXQUFXLENBQUNzTyxTQUFTO2dCQUNqRTtZQUNGO1lBQ0EsSUFBSWh2RSxJQUFJO1lBQ1IsS0FBSyxNQUFNcXJDLFNBQVNELFNBQVU7Z0JBQzVCLE1BQU1tQyxNQUFNLElBQUksQ0FBQyxDQUFDZ3pCLGNBQWMsQ0FBQ3ZnRSxJQUFJO2dCQUNyQyxNQUFNN0IsT0FBT292QyxJQUFJbkIsWUFBWSxDQUFDO2dCQUM5QmYsTUFBTVcsWUFBWSxDQUFDLGdCQUFnQnEwQixpQkFBaUJvQixZQUFZLENBQUN0akUsS0FBSztZQUN4RTtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUM4d0Usa0JBQWtCLENBQUM7UUFDekIsSUFBSSxDQUFDLENBQUM5TiwyQkFBMkIsR0FBRztRQUNwQyxJQUFJLENBQUMsQ0FBQ1QsV0FBVyxDQUFDam5CLFVBQVUsQ0FBQ3VULEtBQUssQ0FBQztZQUNqQ3lOLGNBQWM7UUFDaEI7UUFDQTV1QixNQUFNbUgsY0FBYztRQUNwQm5ILE1BQU1xakMsd0JBQXdCO0lBQ2hDO0lBQ0EsQ0FBQ1IsY0FBYyxDQUFDN2lDLEtBQUs7UUFDbkJ3MEIsaUJBQWlCMkIsdUJBQXVCLENBQUNqL0QsSUFBSSxDQUFDLElBQUksRUFBRThvQztJQUN0RDtJQUNBLENBQUMraUMsV0FBVyxDQUFDL2lDLEtBQUs7UUFDaEIsSUFBSSxJQUFJLENBQUMsQ0FBQ3MxQiwyQkFBMkIsSUFBSXQxQixNQUFNaTVCLGFBQWEsRUFBRXpKLGVBQWUsSUFBSSxDQUFDLENBQUNxRixXQUFXLEVBQUU7WUFDOUYsSUFBSSxDQUFDLENBQUNpRSxZQUFZO1FBQ3BCO0lBQ0Y7SUFDQSxDQUFDa0ssWUFBWSxDQUFDMXdFLElBQUk7UUFDaEIsSUFBSSxDQUFDLENBQUM0aUUsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLENBQUNJLDJCQUEyQixHQUFHaGpFLE9BQU87SUFDeEU7SUFDQSxDQUFDOHdFLGtCQUFrQixDQUFDM3lFLEtBQUs7UUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDaWtFLGNBQWMsRUFBRTtZQUN6QjtRQUNGO1FBQ0EsS0FBSyxNQUFNaHpCLE9BQU8sSUFBSSxDQUFDLENBQUNnekIsY0FBYyxDQUFFO1lBQ3RDaHpCLElBQUlxUCxRQUFRLEdBQUd0Z0Q7UUFDakI7SUFDRjtJQUNBNGxFLG9CQUFvQmxnRSxDQUFDLEVBQUUwTSxDQUFDLEVBQUU7UUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDeXlELDJCQUEyQixFQUFFO1lBQ3RDO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQzhGLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDbEcsa0JBQWtCLEVBQUU7WUFDakRnSSxRQUFRL21FO1lBQ1JnbkUsUUFBUXQ2RDtZQUNSdTZELGNBQWM7UUFDaEI7SUFDRjtJQUNBLENBQUN0RSxZQUFZO1FBQ1gsSUFBSSxDQUFDLENBQUN4RCwyQkFBMkIsR0FBRztRQUNwQyxJQUFJLENBQUMsQ0FBQzhOLGtCQUFrQixDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFDLENBQUN6SCxvQkFBb0I7SUFDNUI7SUFDQXJGLDRCQUE0QjtRQUMxQixJQUFJLENBQUMsQ0FBQ3dDLFlBQVk7UUFDbEIsSUFBSSxDQUFDcDNCLEdBQUcsQ0FBQ3lmLEtBQUs7SUFDaEI7SUFDQWtKLFNBQVM7UUFDUCxJQUFJLElBQUksQ0FBQ2xLLFVBQVUsSUFBSSxJQUFJLENBQUNxVyxZQUFZLEVBQUU7WUFDeEMsSUFBSSxDQUFDQSxZQUFZLENBQUM5bEIsSUFBSTtZQUN0QjtRQUNGO1FBQ0EsSUFBSSxDQUFDeVAsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ3FpQixhQUFhO1FBQ2xCLElBQUksQ0FBQzlnQyxHQUFHLEVBQUUrSixVQUFVcG1DLElBQUk7UUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQ214RCxZQUFZLEVBQUU7WUFDdEIsSUFBSSxDQUFDbUgsY0FBYyxHQUFHeHBCLElBQUksQ0FBQztnQkFDekIsSUFBSSxJQUFJLENBQUN6UyxHQUFHLEVBQUUrSixVQUFVNlAsU0FBUyxtQkFBbUI7b0JBQ2xELElBQUksQ0FBQ2tiLFlBQVksRUFBRTlsQjtnQkFDckI7WUFDRjtZQUNBO1FBQ0Y7UUFDQSxJQUFJLENBQUM4bEIsWUFBWSxFQUFFOWxCO1FBQ25CLElBQUksQ0FBQyxDQUFDM0IsT0FBTyxFQUFFaWdCLG1CQUFtQjtJQUNwQztJQUNBN04sUUFBUTtRQUNOLElBQUksSUFBSSxDQUFDemYsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDQSxHQUFHLENBQUM0WixRQUFRLENBQUMvOUMsU0FBU2crQyxhQUFhLEdBQUc7WUFDMURnTyxXQUFXLElBQU0sSUFBSSxDQUFDN25CLEdBQUcsRUFBRXlmLE1BQU07b0JBQy9CbWlCLGVBQWU7Z0JBQ2pCLElBQUk7UUFDTjtJQUNGO0lBQ0FoYixXQUFXO1FBQ1QsSUFBSSxDQUFDLElBQUksQ0FBQ25JLFVBQVUsRUFBRTtZQUNwQjtRQUNGO1FBQ0EsSUFBSSxDQUFDQSxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDLENBQUMwVSxXQUFXLEVBQUVwcEIsVUFBVXBtQyxJQUFJO1FBQ2pDLElBQUksQ0FBQ3E4QixHQUFHLEVBQUUrSixVQUFVN21DLE9BQU87UUFDM0IsSUFBSSxJQUFJLENBQUM4OEIsR0FBRyxFQUFFNFosU0FBUy85QyxTQUFTZytDLGFBQWEsR0FBRztZQUM5QyxJQUFJLENBQUM1TCxVQUFVLENBQUN5UyxZQUFZLENBQUMxZ0IsR0FBRyxDQUFDeWYsS0FBSyxDQUFDO2dCQUNyQ21pQixlQUFlO1lBQ2pCO1FBQ0Y7UUFDQSxJQUFJLENBQUM5TSxZQUFZLEVBQUVobUI7UUFDbkIsSUFBSSxDQUFDLENBQUN6QixPQUFPLEVBQUVpZ0IsbUJBQW1CO1FBQ2xDLElBQUksSUFBSSxDQUFDbEgsVUFBVSxFQUFFO1lBQ25CLElBQUksQ0FBQ25ZLFVBQVUsQ0FBQ2tRLGFBQWEsQ0FBQyxJQUFJLEVBQUUsT0FBTztRQUM3QztJQUNGO0lBQ0F4QyxhQUFhbGxELElBQUksRUFBRTFILEtBQUssRUFBRSxDQUFDO0lBQzNCOHlFLGlCQUFpQixDQUFDO0lBQ2xCQyxnQkFBZ0IsQ0FBQztJQUNqQixJQUFJQyxtQkFBbUI7UUFDckIsT0FBTztJQUNUO0lBQ0FwYixrQkFBa0I7UUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQ29iLGdCQUFnQixFQUFFO1lBQzFCO1FBQ0Y7UUFDQSxJQUFJLENBQUNoQyxjQUFjO1FBQ25CLElBQUksQ0FBQy8vQixHQUFHLENBQUN5ZixLQUFLO0lBQ2hCO0lBQ0F1aUIsU0FBUzFqQyxLQUFLLEVBQUU7UUFDZCxJQUFJQSxNQUFNaHdDLE1BQU0sQ0FBQzJ6RSxRQUFRLEtBQUssVUFBVTtZQUN0QztRQUNGO1FBQ0EsSUFBSSxDQUFDdGIsZUFBZTtRQUNwQixJQUFJLENBQUN2bUIsTUFBTSxDQUFDMm1CLGFBQWEsQ0FBQztZQUN4Qi94QyxNQUFNLElBQUksQ0FBQzlqQixXQUFXLENBQUM4MEQsV0FBVztZQUNsQ1osUUFBUSxJQUFJLENBQUMzaUQsRUFBRTtRQUNqQjtJQUNGO0lBQ0FzckQsdUJBQXVCO1FBQ3JCLE9BQU8sSUFBSSxDQUFDL3RCLEdBQUc7SUFDakI7SUFDQSxJQUFJa2lDLGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQ2xpQyxHQUFHO0lBQ2pCO0lBQ0EsSUFBSSthLFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQyxDQUFDQSxTQUFTO0lBQ3hCO0lBQ0EsSUFBSUEsVUFBVWhzRCxLQUFLLEVBQUU7UUFDbkIsSUFBSSxDQUFDLENBQUNnc0QsU0FBUyxHQUFHaHNEO1FBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUNxeEMsTUFBTSxFQUFFO1lBQ2hCO1FBQ0Y7UUFDQSxJQUFJcnhDLE9BQU87WUFDVCxJQUFJLENBQUNxeEMsTUFBTSxDQUFDc21CLFdBQVcsQ0FBQyxJQUFJO1lBQzVCLElBQUksQ0FBQ3RtQixNQUFNLENBQUNnb0IsZUFBZSxDQUFDLElBQUk7UUFDbEMsT0FBTztZQUNMLElBQUksQ0FBQ2hvQixNQUFNLENBQUNnb0IsZUFBZSxDQUFDO1FBQzlCO0lBQ0Y7SUFDQSxXQUFXbVMsV0FBVztRQUNwQixPQUFPO0lBQ1Q7SUFDQSxPQUFPMVQsMEJBQTBCO1FBQy9CLE9BQU87SUFDVDtJQUNBLElBQUlzYix1QkFBdUI7UUFDekIsT0FBTztZQUNMbmIsUUFBUTtRQUNWO0lBQ0Y7SUFDQSxJQUFJb2IscUJBQXFCO1FBQ3ZCLE9BQU87SUFDVDtJQUNBclYsaUJBQWlCMXVELElBQUksRUFBRWdwRCxXQUFXLEtBQUssRUFBRTtRQUN2QyxJQUFJQSxVQUFVO1lBQ1osSUFBSSxDQUFDLENBQUMyTSxpQkFBaUIsS0FBSyxJQUFJaDVCO1lBQ2hDLE1BQU0sRUFDSmdzQixNQUFNLEVBQ1AsR0FBRzNvRDtZQUNKLElBQUl3aUUsVUFBVSxJQUFJLENBQUMsQ0FBQzdNLGlCQUFpQixDQUFDamtFLEdBQUcsQ0FBQ2kzRDtZQUMxQyxJQUFJNlosU0FBUztnQkFDWHhrQixhQUFhd2tCO1lBQ2Y7WUFDQUEsVUFBVWhaLFdBQVc7Z0JBQ25CLElBQUksQ0FBQ2tGLGdCQUFnQixDQUFDMXVEO2dCQUN0QixJQUFJLENBQUMsQ0FBQzIxRCxpQkFBaUIsQ0FBQzFrQixNQUFNLENBQUMwWDtnQkFDL0IsSUFBSSxJQUFJLENBQUMsQ0FBQ2dOLGlCQUFpQixDQUFDbHhELElBQUksS0FBSyxHQUFHO29CQUN0QyxJQUFJLENBQUMsQ0FBQ2t4RCxpQkFBaUIsR0FBRztnQkFDNUI7WUFDRixHQUFHbEIsaUJBQWlCMEIsaUJBQWlCO1lBQ3JDLElBQUksQ0FBQyxDQUFDUixpQkFBaUIsQ0FBQzM5RCxHQUFHLENBQUMyd0QsUUFBUTZaO1lBQ3BDO1FBQ0Y7UUFDQXhpRSxLQUFLNUgsSUFBSSxLQUFLLElBQUksQ0FBQzA0QyxVQUFVO1FBQzdCLElBQUksQ0FBQ2xCLFVBQVUsQ0FBQ2tOLFNBQVMsQ0FBQ21FLFFBQVEsQ0FBQyxtQkFBbUI7WUFDcEQvdEQsUUFBUSxJQUFJO1lBQ1pzZ0MsU0FBUztnQkFDUHA3QixNQUFNO2dCQUNONEg7WUFDRjtRQUNGO0lBQ0Y7SUFDQTJ3QyxLQUFLa1ksVUFBVSxJQUFJLENBQUMrTixVQUFVLEVBQUU7UUFDOUIsSUFBSSxDQUFDajFCLEdBQUcsQ0FBQytKLFNBQVMsQ0FBQytWLE1BQU0sQ0FBQyxVQUFVLENBQUNvSDtRQUNyQyxJQUFJLENBQUMrTixVQUFVLEdBQUcvTjtJQUNwQjtJQUNBbEMsU0FBUztRQUNQLElBQUksSUFBSSxDQUFDaGxCLEdBQUcsRUFBRTtZQUNaLElBQUksQ0FBQ0EsR0FBRyxDQUFDcVAsUUFBUSxHQUFHO1FBQ3RCO1FBQ0EsSUFBSSxDQUFDLENBQUNzZSxRQUFRLEdBQUc7SUFDbkI7SUFDQTFJLFVBQVU7UUFDUixJQUFJLElBQUksQ0FBQ2psQixHQUFHLEVBQUU7WUFDWixJQUFJLENBQUNBLEdBQUcsQ0FBQ3FQLFFBQVEsR0FBRyxDQUFDO1FBQ3ZCO1FBQ0EsSUFBSSxDQUFDLENBQUNzZSxRQUFRLEdBQUc7SUFDbkI7SUFDQTBVLDRCQUE0QkMsZUFBZSxFQUFFO1FBQzNDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ2hQLGNBQWMsSUFBSSxDQUFDLElBQUksQ0FBQ2pOLE9BQU8sRUFBRTtZQUMxQyxJQUFJLENBQUMsQ0FBQ2lOLGNBQWMsR0FBR2dQLGdCQUFnQkMsaUJBQWlCLENBQUMsSUFBSTtZQUM3RDtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUNsYyxPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDLENBQUNpTixjQUFjLENBQUNwd0QsTUFBTTtZQUMzQixJQUFJLENBQUMsQ0FBQ293RCxjQUFjLEdBQUc7WUFDdkI7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDOEosZ0JBQWdCLElBQUksSUFBSSxDQUFDM0UsYUFBYSxJQUFJLElBQUksQ0FBQ0MsZUFBZSxFQUFFO1lBQ3ZFLElBQUksQ0FBQyxDQUFDcEYsY0FBYyxDQUFDa1AsWUFBWSxDQUFDO2dCQUNoQzVzQyxNQUFNLElBQUksQ0FBQ2lxQyxVQUFVO2dCQUNyQi9CLE9BQU8sSUFBSSxDQUFDeHdCLE9BQU87WUFDckI7UUFDRjtJQUNGO0lBQ0FpZSx3QkFBd0JqRixVQUFVLEVBQUU7UUFDbEMsSUFBSSxJQUFJLENBQUNELE9BQU8sRUFBRTtZQUNoQkMsV0FBV3hYLElBQUk7WUFDZixPQUFPO1FBQ1Q7UUFDQSxJQUFJajBDLFVBQVV5ckQsV0FBV3phLFNBQVMsQ0FBQzJFLGFBQWEsQ0FBQztRQUNqRCxJQUFJLENBQUMzMUMsU0FBUztZQUNaQSxVQUFVZ0IsU0FBUzJJLGFBQWEsQ0FBQztZQUNqQzNKLFFBQVFrdkMsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQyxxQkFBcUIsSUFBSSxDQUFDd3JDLFVBQVU7WUFDMURtWCxXQUFXemEsU0FBUyxDQUFDMHRCLE9BQU8sQ0FBQzErRDtRQUMvQixPQUFPLElBQUlBLFFBQVFvbkUsUUFBUSxLQUFLLFVBQVU7WUFDeEMsTUFBTTd2QixTQUFTdjNDO1lBQ2ZBLFVBQVVnQixTQUFTMkksYUFBYSxDQUFDO1lBQ2pDM0osUUFBUWt2QyxTQUFTLENBQUNwbUMsR0FBRyxDQUFDLHFCQUFxQixJQUFJLENBQUN3ckMsVUFBVTtZQUMxRGlELE9BQU9vcUIsTUFBTSxDQUFDM2hFO1FBQ2hCO1FBQ0EsT0FBT0E7SUFDVDtJQUNBNG5FLHVCQUF1Qm5jLFVBQVUsRUFBRTtRQUNqQyxNQUFNLEVBQ0pwYSxVQUFVLEVBQ1gsR0FBR29hLFdBQVd6YSxTQUFTO1FBQ3hCLElBQUlLLFlBQVkrMUIsYUFBYSxTQUFTLzFCLFdBQVduQyxTQUFTLENBQUM2UCxRQUFRLENBQUMsc0JBQXNCO1lBQ3hGMU4sV0FBV2hwQyxNQUFNO1FBQ25CO0lBQ0Y7QUFDRjtBQUNBLE1BQU04eUQsbUJBQW1CbEQ7SUFDdkI1aEUsWUFBWTZXLE1BQU0sQ0FBRTtRQUNsQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbytDLG1CQUFtQixHQUFHcCtDLE9BQU9vK0MsbUJBQW1CO1FBQ3JELElBQUksQ0FBQ0UsT0FBTyxHQUFHO0lBQ2pCO0lBQ0F4USxZQUFZO1FBQ1YsT0FBTyxJQUFJLENBQUM0cUIsZ0JBQWdCO0lBQzlCO0FBQ0Y7RUFFQyw4QkFBOEI7QUFTL0IsTUFBTWlDLE9BQU87QUFDYixNQUFNQyxZQUFZO0FBQ2xCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUM7SUFDSjN4RSxZQUFZNHhFLElBQUksQ0FBRTtRQUNoQixJQUFJLENBQUNDLEVBQUUsR0FBR0QsT0FBT0EsT0FBTyxhQUFhSjtRQUNyQyxJQUFJLENBQUNNLEVBQUUsR0FBR0YsT0FBT0EsT0FBTyxhQUFhSjtJQUN2QztJQUNBaGlDLE9BQU8vaUMsS0FBSyxFQUFFO1FBQ1osSUFBSVUsTUFBTXZRO1FBQ1YsSUFBSSxPQUFPNlAsVUFBVSxVQUFVO1lBQzdCVSxPQUFPLElBQUloTSxXQUFXc0wsTUFBTTdQLE1BQU0sR0FBRztZQUNyQ0EsU0FBUztZQUNULElBQUssSUFBSTJFLElBQUksR0FBR2luQyxLQUFLLzdCLE1BQU03UCxNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsSUFBSztnQkFDOUMsTUFBTWsvQixPQUFPaDBCLE1BQU1nMUIsVUFBVSxDQUFDbGdDO2dCQUM5QixJQUFJay9CLFFBQVEsTUFBTTtvQkFDaEJ0ekIsSUFBSSxDQUFDdlEsU0FBUyxHQUFHNmpDO2dCQUNuQixPQUFPO29CQUNMdHpCLElBQUksQ0FBQ3ZRLFNBQVMsR0FBRzZqQyxTQUFTO29CQUMxQnR6QixJQUFJLENBQUN2USxTQUFTLEdBQUc2akMsT0FBTztnQkFDMUI7WUFDRjtRQUNGLE9BQU8sSUFBSXY2QixZQUFZZ1QsTUFBTSxDQUFDek0sUUFBUTtZQUNwQ1UsT0FBT1YsTUFBTXROLEtBQUs7WUFDbEJ2QyxTQUFTdVEsS0FBSzlHLFVBQVU7UUFDMUIsT0FBTztZQUNMLE1BQU0sSUFBSTBVLE1BQU07UUFDbEI7UUFDQSxNQUFNZzNELGNBQWNuMUUsVUFBVTtRQUM5QixNQUFNbzFFLGFBQWFwMUUsU0FBU20xRSxjQUFjO1FBQzFDLE1BQU1FLGFBQWEsSUFBSXI1RCxZQUFZekwsS0FBSzdMLE1BQU0sRUFBRSxHQUFHeXdFO1FBQ25ELElBQUlHLEtBQUssR0FDUEMsS0FBSztRQUNQLElBQUlOLEtBQUssSUFBSSxDQUFDQSxFQUFFLEVBQ2RDLEtBQUssSUFBSSxDQUFDQSxFQUFFO1FBQ2QsTUFBTU0sS0FBSyxZQUNUQyxLQUFLO1FBQ1AsTUFBTUMsU0FBU0YsS0FBS1YsVUFDbEJhLFNBQVNGLEtBQUtYO1FBQ2hCLElBQUssSUFBSW53RSxJQUFJLEdBQUdBLElBQUl3d0UsYUFBYXh3RSxJQUFLO1lBQ3BDLElBQUlBLElBQUksR0FBRztnQkFDVDJ3RSxLQUFLRCxVQUFVLENBQUMxd0UsRUFBRTtnQkFDbEIyd0UsS0FBS0EsS0FBS0UsS0FBS1gsWUFBWVMsS0FBS0ksU0FBU1o7Z0JBQ3pDUSxLQUFLQSxNQUFNLEtBQUtBLE9BQU87Z0JBQ3ZCQSxLQUFLQSxLQUFLRyxLQUFLWixZQUFZUyxLQUFLSyxTQUFTYjtnQkFDekNHLE1BQU1LO2dCQUNOTCxLQUFLQSxNQUFNLEtBQUtBLE9BQU87Z0JBQ3ZCQSxLQUFLQSxLQUFLLElBQUk7WUFDaEIsT0FBTztnQkFDTE0sS0FBS0YsVUFBVSxDQUFDMXdFLEVBQUU7Z0JBQ2xCNHdFLEtBQUtBLEtBQUtDLEtBQUtYLFlBQVlVLEtBQUtHLFNBQVNaO2dCQUN6Q1MsS0FBS0EsTUFBTSxLQUFLQSxPQUFPO2dCQUN2QkEsS0FBS0EsS0FBS0UsS0FBS1osWUFBWVUsS0FBS0ksU0FBU2I7Z0JBQ3pDSSxNQUFNSztnQkFDTkwsS0FBS0EsTUFBTSxLQUFLQSxPQUFPO2dCQUN2QkEsS0FBS0EsS0FBSyxJQUFJO1lBQ2hCO1FBQ0Y7UUFDQUksS0FBSztRQUNMLE9BQVFGO1lBQ04sS0FBSztnQkFDSEUsTUFBTS9rRSxJQUFJLENBQUM0a0UsY0FBYyxJQUFJLEVBQUUsSUFBSTtZQUNyQyxLQUFLO2dCQUNIRyxNQUFNL2tFLElBQUksQ0FBQzRrRSxjQUFjLElBQUksRUFBRSxJQUFJO1lBQ3JDLEtBQUs7Z0JBQ0hHLE1BQU0va0UsSUFBSSxDQUFDNGtFLGNBQWMsRUFBRTtnQkFDM0JHLEtBQUtBLEtBQUtFLEtBQUtYLFlBQVlTLEtBQUtJLFNBQVNaO2dCQUN6Q1EsS0FBS0EsTUFBTSxLQUFLQSxPQUFPO2dCQUN2QkEsS0FBS0EsS0FBS0csS0FBS1osWUFBWVMsS0FBS0ssU0FBU2I7Z0JBQ3pDLElBQUlLLGNBQWMsR0FBRztvQkFDbkJGLE1BQU1LO2dCQUNSLE9BQU87b0JBQ0xKLE1BQU1JO2dCQUNSO1FBQ0o7UUFDQSxJQUFJLENBQUNMLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNDLEVBQUUsR0FBR0E7SUFDWjtJQUNBVSxZQUFZO1FBQ1YsSUFBSVgsS0FBSyxJQUFJLENBQUNBLEVBQUUsRUFDZEMsS0FBSyxJQUFJLENBQUNBLEVBQUU7UUFDZEQsTUFBTUMsT0FBTztRQUNiRCxLQUFLQSxLQUFLLGFBQWFKLFlBQVlJLEtBQUssU0FBU0g7UUFDakRJLEtBQUtBLEtBQUssYUFBYUwsWUFBWSxDQUFDLENBQUNLLE1BQU0sS0FBS0QsT0FBTyxFQUFDLElBQUssYUFBYUosU0FBUSxNQUFPO1FBQ3pGSSxNQUFNQyxPQUFPO1FBQ2JELEtBQUtBLEtBQUssYUFBYUosWUFBWUksS0FBSyxTQUFTSDtRQUNqREksS0FBS0EsS0FBSyxhQUFhTCxZQUFZLENBQUMsQ0FBQ0ssTUFBTSxLQUFLRCxPQUFPLEVBQUMsSUFBSyxhQUFhSixTQUFRLE1BQU87UUFDekZJLE1BQU1DLE9BQU87UUFDYixPQUFPLENBQUNELE9BQU8sR0FBR3R4RSxRQUFRLENBQUMsSUFBSXdpQyxRQUFRLENBQUMsR0FBRyxPQUFPLENBQUMrdUMsT0FBTyxHQUFHdnhFLFFBQVEsQ0FBQyxJQUFJd2lDLFFBQVEsQ0FBQyxHQUFHO0lBQ3hGO0FBQ0Y7RUFFQyxzQ0FBc0M7QUFldkMsTUFBTTB2QyxvQkFBb0J4ekUsT0FBT3U5QyxNQUFNLENBQUM7SUFDdEMvMEMsS0FBSztJQUNMOGIsTUFBTTtJQUNObmQsVUFBVWpHO0FBQ1o7QUFDQSxNQUFNdXlFO0lBQ0osQ0FBQ0MsUUFBUSxDQUFTO0lBQ2xCLENBQUNDLFdBQVcsQ0FBUTtJQUNwQixDQUFDQyxVQUFVLENBQVE7SUFDbkIsQ0FBQzdsQyxPQUFPLENBQWE7SUFDckJodEMsYUFBYzthQUpkLENBQUMyeUUsUUFBUSxHQUFHO2FBQ1osQ0FBQ0MsV0FBVyxHQUFHO2FBQ2YsQ0FBQ0MsVUFBVSxHQUFHO2FBQ2QsQ0FBQzdsQyxPQUFPLEdBQUcsSUFBSWxEO1FBRWIsSUFBSSxDQUFDZ3BDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNDLGtCQUFrQixHQUFHO0lBQzVCO0lBQ0E3bEMsU0FBU25sQyxHQUFHLEVBQUVpckUsWUFBWSxFQUFFO1FBQzFCLE1BQU1wMUUsUUFBUSxJQUFJLENBQUMsQ0FBQ212QyxPQUFPLENBQUNudUMsR0FBRyxDQUFDbUo7UUFDaEMsSUFBSW5LLFVBQVVzQyxXQUFXO1lBQ3ZCLE9BQU84eUU7UUFDVDtRQUNBLE9BQU9oMEUsT0FBT2t2QyxNQUFNLENBQUM4a0MsY0FBY3AxRTtJQUNyQztJQUNBK3lELFlBQVk1b0QsR0FBRyxFQUFFO1FBQ2YsT0FBTyxJQUFJLENBQUMsQ0FBQ2dsQyxPQUFPLENBQUNudUMsR0FBRyxDQUFDbUo7SUFDM0I7SUFDQWdLLE9BQU9oSyxHQUFHLEVBQUU7UUFDVixNQUFNMm9ELGNBQWMsSUFBSSxDQUFDLENBQUMzakIsT0FBTyxDQUFDbnVDLEdBQUcsQ0FBQ21KO1FBQ3RDLElBQUkyb0QsZ0JBQWdCeHdELFdBQVc7WUFDN0I7UUFDRjtRQUNBLElBQUl3d0QsdUJBQXVCaVIsa0JBQWtCO1lBQzNDLElBQUksQ0FBQyxDQUFDaVIsVUFBVSxDQUFDejBCLE1BQU0sQ0FBQ3VTLFlBQVlzRSxtQkFBbUI7UUFDekQ7UUFDQSxJQUFJLENBQUMsQ0FBQ2pvQixPQUFPLENBQUNvUixNQUFNLENBQUNwMkM7UUFDckIsSUFBSSxJQUFJLENBQUMsQ0FBQ2dsQyxPQUFPLENBQUNwN0IsSUFBSSxLQUFLLEdBQUc7WUFDNUIsSUFBSSxDQUFDc2hFLGFBQWE7UUFDcEI7UUFDQSxJQUFJLE9BQU8sSUFBSSxDQUFDRixrQkFBa0IsS0FBSyxZQUFZO1lBQ2pELEtBQUssTUFBTW4xRSxTQUFTLElBQUksQ0FBQyxDQUFDbXZDLE9BQU8sQ0FBQ3RwQixNQUFNLEdBQUk7Z0JBQzFDLElBQUk3bEIsaUJBQWlCK2pFLGtCQUFrQjtvQkFDckM7Z0JBQ0Y7WUFDRjtZQUNBLElBQUksQ0FBQ29SLGtCQUFrQixDQUFDO1FBQzFCO0lBQ0Y7SUFDQTNsQyxTQUFTcmxDLEdBQUcsRUFBRW5LLEtBQUssRUFBRTtRQUNuQixNQUFNNkosTUFBTSxJQUFJLENBQUMsQ0FBQ3NsQyxPQUFPLENBQUNudUMsR0FBRyxDQUFDbUo7UUFDOUIsSUFBSTJxRSxXQUFXO1FBQ2YsSUFBSWpyRSxRQUFRdkgsV0FBVztZQUNyQixLQUFLLE1BQU0sQ0FBQ2tYLE9BQU83QyxJQUFJLElBQUl2VixPQUFPOFgsT0FBTyxDQUFDbFosT0FBUTtnQkFDaEQsSUFBSTZKLEdBQUcsQ0FBQzJQLE1BQU0sS0FBSzdDLEtBQUs7b0JBQ3RCbStELFdBQVc7b0JBQ1hqckUsR0FBRyxDQUFDMlAsTUFBTSxHQUFHN0M7Z0JBQ2Y7WUFDRjtRQUNGLE9BQU87WUFDTG0rRCxXQUFXO1lBQ1gsSUFBSSxDQUFDLENBQUMzbEMsT0FBTyxDQUFDN25DLEdBQUcsQ0FBQzZDLEtBQUtuSztRQUN6QjtRQUNBLElBQUk4MEUsVUFBVTtZQUNaLElBQUksQ0FBQyxDQUFDUSxXQUFXO1FBQ25CO1FBQ0EsSUFBSXQxRSxpQkFBaUIrakUsa0JBQWtCO1lBQ3BDLEtBQUksQ0FBQyxDQUFDaVIsVUFBVSxLQUFLLElBQUkvb0MsS0FBSSxFQUFHM2tDLEdBQUcsQ0FBQ3RILE1BQU1vM0QsbUJBQW1CLEVBQUVwM0Q7WUFDaEUsSUFBSSxPQUFPLElBQUksQ0FBQ20xRSxrQkFBa0IsS0FBSyxZQUFZO2dCQUNqRCxJQUFJLENBQUNBLGtCQUFrQixDQUFDbjFFLE1BQU1tQyxXQUFXLENBQUN5a0UsS0FBSztZQUNqRDtRQUNGO0lBQ0Y7SUFDQXIvRCxJQUFJNEMsR0FBRyxFQUFFO1FBQ1AsT0FBTyxJQUFJLENBQUMsQ0FBQ2dsQyxPQUFPLENBQUM1bkMsR0FBRyxDQUFDNEM7SUFDM0I7SUFDQSxJQUFJNEosT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDLENBQUNvN0IsT0FBTyxDQUFDcDdCLElBQUk7SUFDM0I7SUFDQSxDQUFDdWhFLFdBQVc7UUFDVixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNSLFFBQVEsRUFBRTtZQUNuQixJQUFJLENBQUMsQ0FBQ0EsUUFBUSxHQUFHO1lBQ2pCLElBQUksT0FBTyxJQUFJLENBQUNHLGFBQWEsS0FBSyxZQUFZO2dCQUM1QyxJQUFJLENBQUNBLGFBQWE7WUFDcEI7UUFDRjtJQUNGO0lBQ0FJLGdCQUFnQjtRQUNkLElBQUksSUFBSSxDQUFDLENBQUNQLFFBQVEsRUFBRTtZQUNsQixJQUFJLENBQUMsQ0FBQ0EsUUFBUSxHQUFHO1lBQ2pCLElBQUksT0FBTyxJQUFJLENBQUNJLGVBQWUsS0FBSyxZQUFZO2dCQUM5QyxJQUFJLENBQUNBLGVBQWU7WUFDdEI7UUFDRjtJQUNGO0lBQ0EsSUFBSUssUUFBUTtRQUNWLE9BQU8sSUFBSUMsdUJBQXVCLElBQUk7SUFDeEM7SUFDQSxJQUFJQyxlQUFlO1FBQ2pCLElBQUksSUFBSSxDQUFDLENBQUN0bUMsT0FBTyxDQUFDcDdCLElBQUksS0FBSyxHQUFHO1lBQzVCLE9BQU82Z0U7UUFDVDtRQUNBLE1BQU1ockUsTUFBTSxJQUFJcWlDLE9BQ2R2bUIsT0FBTyxJQUFJb3VELGtCQUNYdnJFLFdBQVcsRUFBRTtRQUNmLE1BQU1taEIsVUFBVXRvQixPQUFPK0wsTUFBTSxDQUFDO1FBQzlCLElBQUl1b0UsWUFBWTtRQUNoQixLQUFLLE1BQU0sQ0FBQ3ZyRSxLQUFLd00sSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDdzRCLE9BQU8sQ0FBRTtZQUN0QyxNQUFNMmxCLGFBQWFuK0MsZUFBZW90RCxtQkFBbUJwdEQsSUFBSW13QyxTQUFTLENBQUMsT0FBT3A5QixXQUFXL1M7WUFDckYsSUFBSW0rQyxZQUFZO2dCQUNkbHJELElBQUl0QyxHQUFHLENBQUM2QyxLQUFLMnFEO2dCQUNicHZDLEtBQUtpc0IsTUFBTSxDQUFDLENBQUMsRUFBRXhuQyxJQUFJLENBQUMsRUFBRTRlLEtBQUtvcUMsU0FBUyxDQUFDMkIsWUFBWSxDQUFDO2dCQUNsRDRnQixjQUFjLENBQUMsQ0FBQzVnQixXQUFXaHdDLE1BQU07WUFDbkM7UUFDRjtRQUNBLElBQUk0d0QsV0FBVztZQUNiLEtBQUssTUFBTTExRSxTQUFTNEosSUFBSWljLE1BQU0sR0FBSTtnQkFDaEMsSUFBSTdsQixNQUFNOGtCLE1BQU0sRUFBRTtvQkFDaEJ2YyxTQUFTeUIsSUFBSSxDQUFDaEssTUFBTThrQixNQUFNO2dCQUM1QjtZQUNGO1FBQ0Y7UUFDQSxPQUFPbGIsSUFBSW1LLElBQUksR0FBRyxJQUFJO1lBQ3BCbks7WUFDQThiLE1BQU1BLEtBQUtpdkQsU0FBUztZQUNwQnBzRTtRQUNGLElBQUlxc0U7SUFDTjtJQUNBLElBQUllLGNBQWM7UUFDaEIsSUFBSUMsUUFBUTtRQUNaLE1BQU1DLGVBQWUsSUFBSTVwQztRQUN6QixJQUFJNnBDLHlCQUF5QjtRQUM3QixJQUFJQywwQkFBMEI7UUFDOUIsS0FBSyxNQUFNLzFFLFNBQVMsSUFBSSxDQUFDLENBQUNtdkMsT0FBTyxDQUFDdHBCLE1BQU0sR0FBSTtZQUMxQyxJQUFJLENBQUU3bEIsQ0FBQUEsaUJBQWlCK2pFLGdCQUFlLEdBQUk7Z0JBQ3hDLElBQUkvakUsTUFBTSt1RSxLQUFLLEVBQUU7b0JBQ2YsSUFBSS91RSxNQUFNK3VFLEtBQUssQ0FBQ3pYLE9BQU8sRUFBRTt3QkFDdkJ5ZSwyQkFBMkI7b0JBQzdCLE9BQU87d0JBQ0xELDBCQUEwQjtvQkFDNUI7Z0JBQ0Y7Z0JBQ0E7WUFDRjtZQUNBLElBQUk5MUUsTUFBTWcyRSxnQkFBZ0IsRUFBRTtnQkFDMUJELDJCQUEyQjtZQUM3QixPQUFPLElBQUkvMUUsTUFBTXF1RSxnQkFBZ0IsRUFBRTtnQkFDakN5SCwwQkFBMEI7WUFDNUI7WUFDQSxNQUFNSCxjQUFjMzFFLE1BQU1xekUsa0JBQWtCO1lBQzVDLElBQUksQ0FBQ3NDLGFBQWE7Z0JBQ2hCO1lBQ0Y7WUFDQSxNQUFNLEVBQ0pqdUUsSUFBSSxFQUNMLEdBQUdpdUU7WUFDSixJQUFJLENBQUNFLGFBQWF0dUUsR0FBRyxDQUFDRyxPQUFPO2dCQUMzQm11RSxhQUFhdnVFLEdBQUcsQ0FBQ0ksTUFBTXRHLE9BQU9tSixjQUFjLENBQUN2SyxPQUFPbUMsV0FBVztZQUNqRTtZQUNBeXpFLFVBQVV4MEUsT0FBTytMLE1BQU0sQ0FBQztZQUN4QixNQUFNdkQsTUFBTWdzRSxLQUFLLENBQUNsdUUsS0FBSyxLQUFLLElBQUl1a0M7WUFDaEMsS0FBSyxNQUFNLENBQUM5aEMsS0FBS3dNLElBQUksSUFBSXZWLE9BQU84WCxPQUFPLENBQUN5OEQsYUFBYztnQkFDcEQsSUFBSXhyRSxRQUFRLFFBQVE7b0JBQ2xCO2dCQUNGO2dCQUNBLElBQUk4ckUsV0FBV3JzRSxJQUFJNUksR0FBRyxDQUFDbUo7Z0JBQ3ZCLElBQUksQ0FBQzhyRSxVQUFVO29CQUNiQSxXQUFXLElBQUlocUM7b0JBQ2ZyaUMsSUFBSXRDLEdBQUcsQ0FBQzZDLEtBQUs4ckU7Z0JBQ2Y7Z0JBQ0EsTUFBTXZqRSxRQUFRdWpFLFNBQVNqMUUsR0FBRyxDQUFDMlYsUUFBUTtnQkFDbkNzL0QsU0FBUzN1RSxHQUFHLENBQUNxUCxLQUFLakUsUUFBUTtZQUM1QjtRQUNGO1FBQ0EsSUFBSXFqRSwwQkFBMEIsS0FBS0QseUJBQXlCLEdBQUc7WUFDN0RGLFVBQVV4MEUsT0FBTytMLE1BQU0sQ0FBQztZQUN4QnlvRSxNQUFNTSxRQUFRLEdBQUc7Z0JBQ2Y1ZSxTQUFTeWU7Z0JBQ1RJLFFBQVFMO1lBQ1Y7UUFDRjtRQUNBLElBQUksQ0FBQ0YsT0FBTztZQUNWLE9BQU87UUFDVDtRQUNBLEtBQUssTUFBTSxDQUFDbHVFLE1BQU0wMkMsT0FBTyxJQUFJeTNCLGFBQWM7WUFDekNELEtBQUssQ0FBQ2x1RSxLQUFLLEdBQUcwMkMsT0FBT2c0Qix5QkFBeUIsQ0FBQ1IsS0FBSyxDQUFDbHVFLEtBQUs7UUFDNUQ7UUFDQSxPQUFPa3VFO0lBQ1Q7SUFDQVMsbUJBQW1CO1FBQ2pCLElBQUksQ0FBQyxDQUFDdEIsV0FBVyxHQUFHO0lBQ3RCO0lBQ0F1QixhQUFhempCLFlBQVksRUFBRXZqRCxJQUFJLEVBQUU7UUFDL0IsTUFBTXRQLFFBQVEsSUFBSSxDQUFDLENBQUNnMUUsVUFBVSxFQUFFaDBFLElBQUk2eEQ7UUFDcEMsSUFBSTd5RCxPQUFPO1lBQ1RBLE1BQU1vdUUseUJBQXlCLENBQUM5K0Q7WUFDaEMsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBQ0FxcEQsVUFBVTlGLFlBQVksRUFBRTtRQUN0QixPQUFPLElBQUksQ0FBQyxDQUFDbWlCLFVBQVUsRUFBRWgwRSxJQUFJNnhELGlCQUFpQjtJQUNoRDtJQUNBLElBQUlraUIsY0FBYztRQUNoQixJQUFJLElBQUksQ0FBQyxDQUFDQSxXQUFXLEVBQUU7WUFDckIsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsV0FBVztRQUMxQjtRQUNBLE1BQU13QixNQUFNLEVBQUU7UUFDZCxJQUFJLElBQUksQ0FBQyxDQUFDdkIsVUFBVSxFQUFFO1lBQ3BCLEtBQUssTUFBTWgxRSxTQUFTLElBQUksQ0FBQyxDQUFDZzFFLFVBQVUsQ0FBQ252RCxNQUFNLEdBQUk7Z0JBQzdDLElBQUksQ0FBQzdsQixNQUFNOG1ELFNBQVMsSUFBSTtvQkFDdEI7Z0JBQ0Y7Z0JBQ0F5dkIsSUFBSXZzRSxJQUFJLENBQUNoSyxNQUFNbzNELG1CQUFtQjtZQUNwQztRQUNGO1FBQ0EsT0FBTyxJQUFJLENBQUMsQ0FBQzJkLFdBQVcsR0FBRztZQUN6QndCLEtBQUssSUFBSXgvRCxJQUFJdy9EO1lBQ2I3d0QsTUFBTTZ3RCxJQUFJLzBFLElBQUksQ0FBQztRQUNqQjtJQUNGO0lBQ0EsQ0FBQ3NXLE9BQU9oVSxRQUFRLENBQUMsR0FBRztRQUNsQixPQUFPLElBQUksQ0FBQyxDQUFDcXJDLE9BQU8sQ0FBQ2oyQixPQUFPO0lBQzlCO0FBQ0Y7QUFDQSxNQUFNczhELCtCQUErQlg7SUFDbkMsQ0FBQ1ksWUFBWSxDQUFDO0lBQ2R0ekUsWUFBWWt2QyxNQUFNLENBQUU7UUFDbEIsS0FBSztRQUNMLE1BQU0sRUFDSnpuQyxHQUFHLEVBQ0g4YixJQUFJLEVBQ0puZCxRQUFRLEVBQ1QsR0FBRzhvQyxPQUFPb2tDLFlBQVk7UUFDdkIsTUFBTW50RSxRQUFRRixnQkFBZ0J3QixLQUFLckIsV0FBVztZQUM1Q0E7UUFDRixJQUFJO1FBQ0osSUFBSSxDQUFDLENBQUNrdEUsWUFBWSxHQUFHO1lBQ25CN3JFLEtBQUt0QjtZQUNMb2Q7WUFDQW5kO1FBQ0Y7SUFDRjtJQUNBLElBQUlndEUsUUFBUTtRQUNWaDBDLFlBQVk7SUFDZDtJQUNBLElBQUlrMEMsZUFBZTtRQUNqQixPQUFPLElBQUksQ0FBQyxDQUFDQSxZQUFZO0lBQzNCO0lBQ0EsSUFBSVYsY0FBYztRQUNoQixPQUFPeHlDLE9BQU8sSUFBSSxFQUFFLGVBQWU7WUFDakNnMEMsS0FBSyxJQUFJeC9EO1lBQ1QyTyxNQUFNO1FBQ1I7SUFDRjtBQUNGO0VBRUMsK0JBQStCO0FBV2hDLE1BQU04d0Q7SUFDSixDQUFDQyxXQUFXLENBQWE7SUFDekJ0MEUsWUFBWSxFQUNWdTBFLGdCQUFnQnh6RSxXQUFXNEosUUFBUSxFQUNuQzZwRSxlQUFlLElBQUksRUFDcEIsQ0FBRTthQUpILENBQUNGLFdBQVcsR0FBRyxJQUFJMS9EO1FBS2pCLElBQUksQ0FBQzYvRCxTQUFTLEdBQUdGO1FBQ2pCLElBQUksQ0FBQ0csZUFBZSxHQUFHLElBQUk5L0Q7UUFDM0IsSUFBSSxDQUFDNC9ELFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNHLGVBQWUsR0FBRyxFQUFFO1FBQ3pCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO0lBQ3hCO0lBQ0FDLGtCQUFrQkMsY0FBYyxFQUFFO1FBQ2hDLElBQUksQ0FBQ0osZUFBZSxDQUFDamlFLEdBQUcsQ0FBQ3FpRTtRQUN6QixJQUFJLENBQUNMLFNBQVMsQ0FBQ00sS0FBSyxDQUFDdGlFLEdBQUcsQ0FBQ3FpRTtJQUMzQjtJQUNBRSxxQkFBcUJGLGNBQWMsRUFBRTtRQUNuQyxJQUFJLENBQUNKLGVBQWUsQ0FBQ3QyQixNQUFNLENBQUMwMkI7UUFDNUIsSUFBSSxDQUFDTCxTQUFTLENBQUNNLEtBQUssQ0FBQzMyQixNQUFNLENBQUMwMkI7SUFDOUI7SUFDQUcsV0FBV0MsSUFBSSxFQUFFO1FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQ1YsWUFBWSxFQUFFO1lBQ3RCLElBQUksQ0FBQ0EsWUFBWSxHQUFHLElBQUksQ0FBQ0MsU0FBUyxDQUFDbmhFLGFBQWEsQ0FBQztZQUNqRCxJQUFJLENBQUNtaEUsU0FBUyxDQUFDblAsZUFBZSxDQUFDNlAsb0JBQW9CLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQ3orRCxNQUFNLENBQUMsSUFBSSxDQUFDODlELFlBQVk7UUFDekY7UUFDQSxNQUFNWSxhQUFhLElBQUksQ0FBQ1osWUFBWSxDQUFDYSxLQUFLO1FBQzFDRCxXQUFXSCxVQUFVLENBQUNDLE1BQU1FLFdBQVdFLFFBQVEsQ0FBQzE0RSxNQUFNO0lBQ3hEO0lBQ0F3bkIsUUFBUTtRQUNOLEtBQUssTUFBTTB3RCxrQkFBa0IsSUFBSSxDQUFDSixlQUFlLENBQUU7WUFDakQsSUFBSSxDQUFDRCxTQUFTLENBQUNNLEtBQUssQ0FBQzMyQixNQUFNLENBQUMwMkI7UUFDOUI7UUFDQSxJQUFJLENBQUNKLGVBQWUsQ0FBQ3R3RCxLQUFLO1FBQzFCLElBQUksQ0FBQyxDQUFDa3dELFdBQVcsQ0FBQ2x3RCxLQUFLO1FBQ3ZCLElBQUksSUFBSSxDQUFDb3dELFlBQVksRUFBRTtZQUNyQixJQUFJLENBQUNBLFlBQVksQ0FBQ3hpRSxNQUFNO1lBQ3hCLElBQUksQ0FBQ3dpRSxZQUFZLEdBQUc7UUFDdEI7SUFDRjtJQUNBLE1BQU1lLGVBQWUsRUFDbkJDLGdCQUFnQngyQyxJQUFJLEVBQ3BCeTJDLGVBQWUsRUFDZkMsWUFBWSxFQUNiLEVBQUU7UUFDRCxJQUFJLENBQUMxMkMsUUFBUSxJQUFJLENBQUMsQ0FBQ3MxQyxXQUFXLENBQUNsdkUsR0FBRyxDQUFDNDVCLEtBQUsyMkMsVUFBVSxHQUFHO1lBQ25EO1FBQ0Y7UUFDQXQyQyxPQUFPLENBQUNvMkMsaUJBQWlCO1FBQ3pCLElBQUksSUFBSSxDQUFDRyx5QkFBeUIsRUFBRTtZQUNsQyxNQUFNLEVBQ0pELFVBQVUsRUFDVmxyRSxHQUFHLEVBQ0hILEtBQUssRUFDTixHQUFHMDBCO1lBQ0osTUFBTTYyQyxXQUFXLElBQUlDLFNBQVNILFlBQVlsckUsS0FBS0g7WUFDL0MsSUFBSSxDQUFDdXFFLGlCQUFpQixDQUFDZ0I7WUFDdkIsSUFBSTtnQkFDRixNQUFNQSxTQUFTRSxJQUFJO2dCQUNuQixJQUFJLENBQUMsQ0FBQ3pCLFdBQVcsQ0FBQzdoRSxHQUFHLENBQUNrakU7Z0JBQ3RCRCxlQUFlMTJDO1lBQ2pCLEVBQUUsT0FBTTtnQkFDTkcsS0FBSyxDQUFDLHlCQUF5QixFQUFFSCxLQUFLZzNDLFlBQVksQ0FBQyxvREFBb0QsQ0FBQztnQkFDeEcsSUFBSSxDQUFDaEIsb0JBQW9CLENBQUNhO1lBQzVCO1lBQ0E7UUFDRjtRQUNBejJDLFlBQVk7SUFDZDtJQUNBLE1BQU16OEIsS0FBS3N6RSxJQUFJLEVBQUU7UUFDZixJQUFJQSxLQUFLQyxRQUFRLElBQUlELEtBQUtFLFdBQVcsSUFBSSxDQUFDRixLQUFLVCxjQUFjLEVBQUU7WUFDN0Q7UUFDRjtRQUNBUyxLQUFLQyxRQUFRLEdBQUc7UUFDaEIsSUFBSUQsS0FBS1QsY0FBYyxFQUFFO1lBQ3ZCLE1BQU0sSUFBSSxDQUFDRCxjQUFjLENBQUNVO1lBQzFCO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQ0wseUJBQXlCLEVBQUU7WUFDbEMsTUFBTWQsaUJBQWlCbUIsS0FBS0csb0JBQW9CO1lBQ2hELElBQUl0QixnQkFBZ0I7Z0JBQ2xCLElBQUksQ0FBQ0QsaUJBQWlCLENBQUNDO2dCQUN2QixJQUFJO29CQUNGLE1BQU1BLGVBQWV1QixNQUFNO2dCQUM3QixFQUFFLE9BQU85dEMsSUFBSTtvQkFDWHBKLEtBQUssQ0FBQyxxQkFBcUIsRUFBRTIxQyxlQUFld0IsTUFBTSxDQUFDLElBQUksRUFBRS90QyxHQUFHLEVBQUUsQ0FBQztvQkFDL0QwdEMsS0FBS1IsZUFBZSxHQUFHO29CQUN2QixNQUFNbHRDO2dCQUNSO1lBQ0Y7WUFDQTtRQUNGO1FBQ0EsTUFBTTJzQyxPQUFPZSxLQUFLTSxrQkFBa0I7UUFDcEMsSUFBSXJCLE1BQU07WUFDUixJQUFJLENBQUNELFVBQVUsQ0FBQ0M7WUFDaEIsSUFBSSxJQUFJLENBQUNzQiwwQkFBMEIsRUFBRTtnQkFDbkM7WUFDRjtZQUNBLE1BQU0sSUFBSS92RSxRQUFRUSxDQUFBQTtnQkFDaEIsTUFBTXNwQyxVQUFVLElBQUksQ0FBQ2ttQyxxQkFBcUIsQ0FBQ3h2RTtnQkFDM0MsSUFBSSxDQUFDeXZFLHFCQUFxQixDQUFDVCxNQUFNMWxDO1lBQ25DO1FBQ0Y7SUFDRjtJQUNBLElBQUlxbEMsNEJBQTRCO1FBQzlCLE1BQU1lLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQ2xDLFNBQVMsRUFBRU07UUFDbkMsT0FBTzMwQyxPQUFPLElBQUksRUFBRSw2QkFBNkJ1MkM7SUFDbkQ7SUFDQSxJQUFJSCw2QkFBNkI7UUFDL0IsT0FBT3AyQyxPQUFPLElBQUksRUFBRSw4QkFBOEIvUSxZQUFZMlMsaUJBQWlCSyxRQUFRLENBQUNLLFNBQVM7SUFDbkc7SUFDQSt6QyxzQkFBc0J6N0QsUUFBUSxFQUFFO1FBQzlCLFNBQVM0N0Q7WUFDUHYzQyxPQUFPLENBQUNrUixRQUFRenVDLElBQUksRUFBRTtZQUN0Qnl1QyxRQUFRenVDLElBQUksR0FBRztZQUNmLE1BQU82eUUsZ0JBQWdCLzNFLE1BQU0sR0FBRyxLQUFLKzNFLGVBQWUsQ0FBQyxFQUFFLENBQUM3eUUsSUFBSSxDQUFFO2dCQUM1RCxNQUFNKzBFLGVBQWVsQyxnQkFBZ0Jub0QsS0FBSztnQkFDMUNtcUMsV0FBV2tnQixhQUFhNzdELFFBQVEsRUFBRTtZQUNwQztRQUNGO1FBQ0EsTUFBTSxFQUNKMjVELGVBQWUsRUFDaEIsR0FBRyxJQUFJO1FBQ1IsTUFBTXBrQyxVQUFVO1lBQ2R6dUMsTUFBTTtZQUNOZzFFLFVBQVVGO1lBQ1Y1N0Q7UUFDRjtRQUNBMjVELGdCQUFnQjlzRSxJQUFJLENBQUMwb0M7UUFDckIsT0FBT0E7SUFDVDtJQUNBLElBQUl3bUMsZ0JBQWdCO1FBQ2xCLE1BQU1DLFdBQVcxckMsS0FBSyx5RUFBeUUseUVBQXlFLHlFQUF5RSx5RUFBeUUseUVBQXlFLHlFQUF5RSx5RUFBeUUseUVBQXlFLHlFQUF5RSx5RUFBeUUseUVBQXlFLHlFQUF5RSx5RUFBeUUseUVBQXlFLHlFQUF5RSx5RUFBeUUseUVBQXlFLHlFQUF5RSx5RUFBeUUseUVBQXlFLHlFQUF5RTtRQUNuaEQsT0FBT2xMLE9BQU8sSUFBSSxFQUFFLGlCQUFpQjQyQztJQUN2QztJQUNBTixzQkFBc0JULElBQUksRUFBRTFsQyxPQUFPLEVBQUU7UUFDbkMsU0FBUzBtQyxNQUFNOXBFLElBQUksRUFBRStwRSxNQUFNO1lBQ3pCLE9BQU8vcEUsS0FBS3MwQixVQUFVLENBQUN5MUMsV0FBVyxLQUFLL3BFLEtBQUtzMEIsVUFBVSxDQUFDeTFDLFNBQVMsTUFBTSxLQUFLL3BFLEtBQUtzMEIsVUFBVSxDQUFDeTFDLFNBQVMsTUFBTSxJQUFJL3BFLEtBQUtzMEIsVUFBVSxDQUFDeTFDLFNBQVMsS0FBSztRQUM5STtRQUNBLFNBQVNDLGFBQWF2NkQsQ0FBQyxFQUFFczZELE1BQU0sRUFBRWxsRSxNQUFNLEVBQUVvbEUsTUFBTTtZQUM3QyxNQUFNQyxTQUFTejZELEVBQUVvMkIsU0FBUyxDQUFDLEdBQUdra0M7WUFDOUIsTUFBTUksU0FBUzE2RCxFQUFFbzJCLFNBQVMsQ0FBQ2trQyxTQUFTbGxFO1lBQ3BDLE9BQU9xbEUsU0FBU0QsU0FBU0U7UUFDM0I7UUFDQSxJQUFJLzFFLEdBQUdpbkM7UUFDUCxNQUFNMFksU0FBUyxJQUFJLENBQUN1ekIsU0FBUyxDQUFDbmhFLGFBQWEsQ0FBQztRQUM1QzR0QyxPQUFPblAsS0FBSyxHQUFHO1FBQ2ZtUCxPQUFPbFAsTUFBTSxHQUFHO1FBQ2hCLE1BQU11RSxNQUFNMkssT0FBT0MsVUFBVSxDQUFDO1FBQzlCLElBQUlvMkIsU0FBUztRQUNiLFNBQVNDLFlBQVk5M0UsSUFBSSxFQUFFc2IsUUFBUTtZQUNqQyxJQUFJLEVBQUV1OEQsU0FBUyxJQUFJO2dCQUNqQnA0QyxLQUFLO2dCQUNMbmtCO2dCQUNBO1lBQ0Y7WUFDQXU3QixJQUFJMC9CLElBQUksR0FBRyxVQUFVdjJFO1lBQ3JCNjJDLElBQUlraEMsUUFBUSxDQUFDLEtBQUssR0FBRztZQUNyQixNQUFNQyxZQUFZbmhDLElBQUlrTCxZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUc7WUFDNUMsSUFBSWkyQixVQUFVdnFFLElBQUksQ0FBQyxFQUFFLEdBQUcsR0FBRztnQkFDekI2TjtnQkFDQTtZQUNGO1lBQ0EyN0MsV0FBVzZnQixZQUFZNzBFLElBQUksQ0FBQyxNQUFNakQsTUFBTXNiO1FBQzFDO1FBQ0EsTUFBTTQ1RCxpQkFBaUIsQ0FBQyxFQUFFLEVBQUV4ckMsS0FBSzRLLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQzRnQyxjQUFjLEdBQUcsQ0FBQztRQUNoRSxJQUFJem5FLE9BQU8sSUFBSSxDQUFDNHBFLGFBQWE7UUFDN0IsTUFBTVksaUJBQWlCO1FBQ3ZCeHFFLE9BQU9ncUUsYUFBYWhxRSxNQUFNd3FFLGdCQUFnQi9DLGVBQWVoNEUsTUFBTSxFQUFFZzRFO1FBQ2pFLE1BQU1nRCxzQkFBc0I7UUFDNUIsTUFBTUMsYUFBYTtRQUNuQixJQUFJQyxXQUFXYixNQUFNOXBFLE1BQU15cUU7UUFDM0IsSUFBS3IyRSxJQUFJLEdBQUdpbkMsS0FBS29zQyxlQUFlaDRFLE1BQU0sR0FBRyxHQUFHMkUsSUFBSWluQyxJQUFJam5DLEtBQUssRUFBRztZQUMxRHUyRSxXQUFXQSxXQUFXRCxhQUFhWixNQUFNckMsZ0JBQWdCcnpFLEtBQUs7UUFDaEU7UUFDQSxJQUFJQSxJQUFJcXpFLGVBQWVoNEUsTUFBTSxFQUFFO1lBQzdCazdFLFdBQVdBLFdBQVdELGFBQWFaLE1BQU1yQyxpQkFBaUIsT0FBT3J6RSxLQUFLO1FBQ3hFO1FBQ0E0TCxPQUFPZ3FFLGFBQWFocUUsTUFBTXlxRSxxQkFBcUIsR0FBR2wyQyxTQUFTbzJDO1FBQzNELE1BQU12M0QsTUFBTSxDQUFDLDhCQUE4QixFQUFFNnFCLEtBQUtqK0IsTUFBTSxFQUFFLENBQUM7UUFDM0QsTUFBTStuRSxPQUFPLENBQUMseUJBQXlCLEVBQUVOLGVBQWUsTUFBTSxFQUFFcjBELElBQUksQ0FBQyxDQUFDO1FBQ3RFLElBQUksQ0FBQzAwRCxVQUFVLENBQUNDO1FBQ2hCLE1BQU1wbUMsTUFBTSxJQUFJLENBQUMybEMsU0FBUyxDQUFDbmhFLGFBQWEsQ0FBQztRQUN6Q3c3QixJQUFJeGtDLEtBQUssQ0FBQzJyQyxVQUFVLEdBQUc7UUFDdkJuSCxJQUFJeGtDLEtBQUssQ0FBQ3luQyxLQUFLLEdBQUdqRCxJQUFJeGtDLEtBQUssQ0FBQzBuQyxNQUFNLEdBQUc7UUFDckNsRCxJQUFJeGtDLEtBQUssQ0FBQzR5QyxRQUFRLEdBQUc7UUFDckJwTyxJQUFJeGtDLEtBQUssQ0FBQ2d6QyxHQUFHLEdBQUd4TyxJQUFJeGtDLEtBQUssQ0FBQys4RCxJQUFJLEdBQUc7UUFDakMsS0FBSyxNQUFNM25FLFFBQVE7WUFBQ3UyRSxLQUFLTixVQUFVO1lBQUVmO1NBQWUsQ0FBRTtZQUNwRCxNQUFNNStCLE9BQU8sSUFBSSxDQUFDeStCLFNBQVMsQ0FBQ25oRSxhQUFhLENBQUM7WUFDMUMwaUMsS0FBSzNKLFdBQVcsR0FBRztZQUNuQjJKLEtBQUsxckMsS0FBSyxDQUFDeXRFLFVBQVUsR0FBR3I0RTtZQUN4Qm92QyxJQUFJcDRCLE1BQU0sQ0FBQ3MvQjtRQUNiO1FBQ0EsSUFBSSxDQUFDeStCLFNBQVMsQ0FBQ3QrQixJQUFJLENBQUN6L0IsTUFBTSxDQUFDbzRCO1FBQzNCMG9DLFlBQVk1QyxnQkFBZ0I7WUFDMUI5bEMsSUFBSTk4QixNQUFNO1lBQ1Z1K0IsUUFBUXVtQyxRQUFRO1FBQ2xCO0lBQ0Y7QUFDRjtBQUNBLE1BQU1rQjtJQUNKLENBQUNDLFFBQVEsQ0FBQztJQUNWajRFLFlBQVlrNEUsY0FBYyxFQUFFQyxjQUFjLElBQUksRUFBRUMsS0FBSyxFQUFFQyxvQkFBb0IsQ0FBRTtRQUMzRSxJQUFJLENBQUNDLGNBQWMsR0FBR3I1RSxPQUFPK0wsTUFBTSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxDQUFDaXRFLFFBQVEsR0FBR0M7UUFDakIsSUFBSSxDQUFDeEMsWUFBWSxHQUFHeUM7UUFDcEIsSUFBSUMsT0FBTztZQUNUbjVFLE9BQU9rdkMsTUFBTSxDQUFDLElBQUksRUFBRWlxQztRQUN0QjtRQUNBLElBQUlDLHNCQUFzQjtZQUN4QixJQUFJLENBQUNBLG9CQUFvQixHQUFHQTtRQUM5QjtJQUNGO0lBQ0FqQyx1QkFBdUI7UUFDckIsSUFBSSxDQUFDLElBQUksQ0FBQ2pwRSxJQUFJLElBQUksSUFBSSxDQUFDc29FLGVBQWUsRUFBRTtZQUN0QyxPQUFPO1FBQ1Q7UUFDQSxJQUFJWDtRQUNKLElBQUksQ0FBQyxJQUFJLENBQUN5RCxXQUFXLEVBQUU7WUFDckJ6RCxpQkFBaUIsSUFBSWdCLFNBQVMsSUFBSSxDQUFDSCxVQUFVLEVBQUUsSUFBSSxDQUFDeG9FLElBQUksRUFBRSxDQUFDO1FBQzdELE9BQU87WUFDTCxNQUFNcXJFLE1BQU07Z0JBQ1ZDLFFBQVEsSUFBSSxDQUFDRixXQUFXLENBQUNHLFVBQVU7WUFDckM7WUFDQSxJQUFJLElBQUksQ0FBQ0gsV0FBVyxDQUFDSSxXQUFXLEVBQUU7Z0JBQ2hDSCxJQUFJbHVFLEtBQUssR0FBRyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUNpdUUsV0FBVyxDQUFDSSxXQUFXLENBQUMsR0FBRyxDQUFDO1lBQzFEO1lBQ0E3RCxpQkFBaUIsSUFBSWdCLFNBQVMsSUFBSSxDQUFDeUMsV0FBVyxDQUFDUixVQUFVLEVBQUUsSUFBSSxDQUFDNXFFLElBQUksRUFBRXFyRTtRQUN4RTtRQUNBLElBQUksQ0FBQzlDLFlBQVksR0FBRyxJQUFJO1FBQ3hCLE9BQU9aO0lBQ1Q7SUFDQXlCLHFCQUFxQjtRQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDcHBFLElBQUksSUFBSSxJQUFJLENBQUNzb0UsZUFBZSxFQUFFO1lBQ3RDLE9BQU87UUFDVDtRQUNBLE1BQU1sMUQsTUFBTSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUNxNEQsUUFBUSxDQUFDLFFBQVEsRUFBRXp0QyxhQUFhLElBQUksQ0FBQ2grQixJQUFJLEVBQUUsRUFBRSxDQUFDO1FBQzNFLElBQUkrbkU7UUFDSixJQUFJLENBQUMsSUFBSSxDQUFDcUQsV0FBVyxFQUFFO1lBQ3JCckQsT0FBTyxDQUFDLHlCQUF5QixFQUFFLElBQUksQ0FBQ1MsVUFBVSxDQUFDLE1BQU0sRUFBRXAxRCxJQUFJLENBQUMsQ0FBQztRQUNuRSxPQUFPO1lBQ0wsSUFBSWk0RCxNQUFNLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQ0QsV0FBVyxDQUFDRyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ3hELElBQUksSUFBSSxDQUFDSCxXQUFXLENBQUNJLFdBQVcsRUFBRTtnQkFDaENILE9BQU8sQ0FBQyxvQkFBb0IsRUFBRSxJQUFJLENBQUNELFdBQVcsQ0FBQ0ksV0FBVyxDQUFDLElBQUksQ0FBQztZQUNsRTtZQUNBekQsT0FBTyxDQUFDLHlCQUF5QixFQUFFLElBQUksQ0FBQ3FELFdBQVcsQ0FBQ1IsVUFBVSxDQUFDLEVBQUUsRUFBRVMsSUFBSSxJQUFJLEVBQUVqNEQsSUFBSSxDQUFDLENBQUM7UUFDckY7UUFDQSxJQUFJLENBQUNtMUQsWUFBWSxHQUFHLElBQUksRUFBRW4xRDtRQUMxQixPQUFPMjBEO0lBQ1Q7SUFDQTJELGlCQUFpQkMsSUFBSSxFQUFFQyxTQUFTLEVBQUU7UUFDaEMsSUFBSSxJQUFJLENBQUNULGNBQWMsQ0FBQ1MsVUFBVSxLQUFLNTRFLFdBQVc7WUFDaEQsT0FBTyxJQUFJLENBQUNtNEUsY0FBYyxDQUFDUyxVQUFVO1FBQ3ZDO1FBQ0EsTUFBTUMsUUFBUSxJQUFJLENBQUNyRCxVQUFVLEdBQUcsV0FBV29EO1FBQzNDLElBQUlFO1FBQ0osSUFBSTtZQUNGQSxPQUFPSCxLQUFLajZFLEdBQUcsQ0FBQ202RTtRQUNsQixFQUFFLE9BQU96d0MsSUFBSTtZQUNYcEosS0FBSyxDQUFDLHdDQUF3QyxFQUFFb0osR0FBRyxFQUFFLENBQUM7UUFDeEQ7UUFDQSxNQUFNMndDLE9BQU8sSUFBSUMsT0FBT0YsUUFBUTtRQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDRyxtQkFBbUIsRUFBRTtZQUM3Qk4sS0FBSzE2QixNQUFNLENBQUM0NkI7UUFDZDtRQUNBLE9BQU8sSUFBSSxDQUFDVixjQUFjLENBQUNTLFVBQVUsR0FBR0c7SUFDMUM7SUFDQSxJQUFJRyxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsQ0FBQ3BCLFFBQVEsQ0FBQ29CLEtBQUs7SUFDN0I7SUFDQSxJQUFJQyxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUMsQ0FBQ3JCLFFBQVEsQ0FBQ3FCLElBQUk7SUFDNUI7SUFDQSxJQUFJN0Qsa0JBQWtCO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLENBQUN3QyxRQUFRLENBQUN4QyxlQUFlLElBQUk7SUFDM0M7SUFDQSxJQUFJMkQsc0JBQXNCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLENBQUNuQixRQUFRLENBQUNtQixtQkFBbUIsSUFBSTtJQUMvQztJQUNBLElBQUlHLHFCQUFxQjtRQUN2QixPQUFPLElBQUksQ0FBQyxDQUFDdEIsUUFBUSxDQUFDc0Isa0JBQWtCO0lBQzFDO0lBQ0EsSUFBSUMsY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQyxDQUFDdkIsUUFBUSxDQUFDdUIsV0FBVztJQUNuQztJQUNBLElBQUlDLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQyxDQUFDeEIsUUFBUSxDQUFDd0IsTUFBTTtJQUM5QjtJQUNBLElBQUl0RCxjQUFjO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLENBQUM4QixRQUFRLENBQUM5QixXQUFXO0lBQ25DO0lBQ0EsSUFBSXVELFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQyxDQUFDekIsUUFBUSxDQUFDeUIsU0FBUztJQUNqQztJQUNBLElBQUlDLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQyxDQUFDMUIsUUFBUSxDQUFDMEIsUUFBUTtJQUNoQztJQUNBLElBQUlDLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQyxDQUFDM0IsUUFBUSxDQUFDMkIsTUFBTTtJQUM5QjtJQUNBLElBQUlDLGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUMsQ0FBQzVCLFFBQVEsQ0FBQzRCLFlBQVk7SUFDcEM7SUFDQSxJQUFJQyxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUMsQ0FBQzdCLFFBQVEsQ0FBQzZCLE9BQU87SUFDL0I7SUFDQSxJQUFJQyxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUMsQ0FBQzlCLFFBQVEsQ0FBQzhCLElBQUk7SUFDNUI7SUFDQSxJQUFJQyxhQUFhO1FBQ2YsT0FBTyxJQUFJLENBQUMsQ0FBQy9CLFFBQVEsQ0FBQytCLFVBQVU7SUFDbEM7SUFDQSxJQUFJQyxlQUFlO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLENBQUNoQyxRQUFRLENBQUNnQyxZQUFZO0lBQ3BDO0lBQ0EsSUFBSXRFLGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQyxDQUFDc0MsUUFBUSxDQUFDdEMsVUFBVTtJQUNsQztJQUNBLElBQUlpRCxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsQ0FBQ1gsUUFBUSxDQUFDVyxRQUFRO0lBQ2hDO0lBQ0EsSUFBSWw1RSxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUMsQ0FBQ3U0RSxRQUFRLENBQUN2NEUsSUFBSTtJQUM1QjtJQUNBLElBQUl5TixPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUMsQ0FBQzhxRSxRQUFRLENBQUM5cUUsSUFBSTtJQUM1QjtJQUNBK3NFLFlBQVk7UUFDVixJQUFJLENBQUMsQ0FBQ2pDLFFBQVEsQ0FBQ2lDLFNBQVM7SUFDMUI7SUFDQSxJQUFJM0IsY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQyxDQUFDTixRQUFRLENBQUNNLFdBQVc7SUFDbkM7SUFDQSxJQUFJL0MsaUJBQWlCO1FBQ25CLE9BQU8sSUFBSSxDQUFDLENBQUN5QyxRQUFRLENBQUN6QyxjQUFjO0lBQ3RDO0lBQ0EsSUFBSTJFLGtCQUFrQjtRQUNwQixPQUFPLElBQUksQ0FBQyxDQUFDbEMsUUFBUSxDQUFDa0MsZUFBZTtJQUN2QztBQUNGO0VBRUMsNkJBQTZCO0FBZTlCLFNBQVNDLFdBQVc1bEUsR0FBRztJQUNyQixJQUFJQSxlQUFlNkwsS0FBSztRQUN0QixPQUFPN0wsSUFBSTRPLElBQUk7SUFDakI7SUFDQSxJQUFJLE9BQU81TyxRQUFRLFVBQVU7UUFDM0IsSUFBSTZhLFVBQVU7WUFDWixPQUFPN2E7UUFDVDtRQUNBLE1BQU0rTCxNQUFNRixJQUFJQyxLQUFLLENBQUM5TCxLQUFLSixPQUFPaW1FLFFBQVE7UUFDMUMsSUFBSTk1RCxLQUFLO1lBQ1AsT0FBT0EsSUFBSTZDLElBQUk7UUFDakI7SUFDRjtJQUNBLE1BQU0sSUFBSXJJLE1BQU0sMkJBQTJCO0FBQzdDO0FBQ0EsU0FBU3UvRCxZQUFZOWxFLEdBQUc7SUFDdEIsSUFBSTZhLFlBQVksT0FBT2tyRCxXQUFXLGVBQWUvbEUsZUFBZStsRSxRQUFRO1FBQ3RFLE1BQU0sSUFBSXgvRCxNQUFNO0lBQ2xCO0lBQ0EsSUFBSXZHLGVBQWVyVCxjQUFjcVQsSUFBSW5PLFVBQVUsS0FBS21PLElBQUlsVCxNQUFNLENBQUMrRSxVQUFVLEVBQUU7UUFDekUsT0FBT21PO0lBQ1Q7SUFDQSxJQUFJLE9BQU9BLFFBQVEsVUFBVTtRQUMzQixPQUFPK3NCLGNBQWMvc0I7SUFDdkI7SUFDQSxJQUFJQSxlQUFldE8sZUFBZUEsWUFBWWdULE1BQU0sQ0FBQzFFLFFBQVEsT0FBT0EsUUFBUSxZQUFZLENBQUNnbUUsTUFBTWhtRSxLQUFLNVgsU0FBUztRQUMzRyxPQUFPLElBQUl1RSxXQUFXcVQ7SUFDeEI7SUFDQSxNQUFNLElBQUl1RyxNQUFNLGlEQUFpRDtBQUNuRTtBQUNBLFNBQVMwL0Qsa0JBQWtCam1FLEdBQUc7SUFDNUIsSUFBSSxPQUFPQSxRQUFRLFVBQVU7UUFDM0IsT0FBTztJQUNUO0lBQ0EsSUFBSUEsSUFBSXczQyxRQUFRLENBQUMsTUFBTTtRQUNyQixPQUFPeDNDO0lBQ1Q7SUFDQSxNQUFNLElBQUl1RyxNQUFNLENBQUMsc0JBQXNCLEVBQUV2RyxJQUFJLDhCQUE4QixDQUFDO0FBQzlFO0FBQ0EsTUFBTWttRSxhQUFhMWpFLENBQUFBLElBQUssT0FBT0EsTUFBTSxZQUFZeEgsT0FBT3N2QixTQUFTLENBQUM5bkIsR0FBR2swQixRQUFRbDBCLEVBQUVrMEIsR0FBRyxJQUFJLEtBQUsxN0IsT0FBT3N2QixTQUFTLENBQUM5bkIsR0FBRzJqRSxRQUFRM2pFLEVBQUUyakUsR0FBRyxJQUFJO0FBQ2hJLE1BQU1DLGNBQWM1akUsQ0FBQUEsSUFBSyxPQUFPQSxNQUFNLFlBQVksT0FBT0EsR0FBR3RYLFNBQVM7QUFDckUsTUFBTW03RSxzQkFBc0J0d0MscUJBQXFCNW5DLElBQUksQ0FBQyxNQUFNKzNFLFlBQVlFO0FBQ3hFLE1BQU1FO0lBQ0osQ0FBQ0MsU0FBUyxDQUFhO0lBQ3ZCLENBQUNDLFFBQVEsQ0FBcUI7SUFDOUJ4bEUsWUFBWTlOLEdBQUcsRUFBRXRCLFFBQVEsRUFBRTtRQUN6QixNQUFNZ25DLFFBQVE7WUFDWmpnQyxNQUFNbEgsZ0JBQWdCeUIsS0FBS3RCLFdBQVc7Z0JBQ3BDQTtZQUNGLElBQUk7UUFDTjtRQUNBLElBQUksQ0FBQyxDQUFDNDBFLFFBQVEsQ0FBQ3o1QixJQUFJLENBQUM7WUFDbEIsS0FBSyxNQUFNLENBQUMwNUIsU0FBUyxJQUFJLElBQUksQ0FBQyxDQUFDRixTQUFTLENBQUU7Z0JBQ3hDRSxTQUFTaC9FLElBQUksQ0FBQyxJQUFJLEVBQUVteEM7WUFDdEI7UUFDRjtJQUNGO0lBQ0FyQixpQkFBaUJyc0MsSUFBSSxFQUFFdTdFLFFBQVEsRUFBRXQ3RSxVQUFVLElBQUksRUFBRTtRQUMvQyxJQUFJdTdFLFVBQVU7UUFDZCxJQUFJdjdFLFNBQVNnc0Msa0JBQWtCSixhQUFhO1lBQzFDLE1BQU0sRUFDSkksTUFBTSxFQUNQLEdBQUdoc0M7WUFDSixJQUFJZ3NDLE9BQU9DLE9BQU8sRUFBRTtnQkFDbEJ6TSxLQUFLO2dCQUNMO1lBQ0Y7WUFDQSxNQUFNZzhDLFVBQVUsSUFBTSxJQUFJLENBQUNDLG1CQUFtQixDQUFDMTdFLE1BQU11N0U7WUFDckRDLFVBQVUsSUFBTXZ2QyxPQUFPeXZDLG1CQUFtQixDQUFDLFNBQVNEO1lBQ3BEeHZDLE9BQU9JLGdCQUFnQixDQUFDLFNBQVNvdkM7UUFDbkM7UUFDQSxJQUFJLENBQUMsQ0FBQ0osU0FBUyxDQUFDNTFFLEdBQUcsQ0FBQzgxRSxVQUFVQztJQUNoQztJQUNBRSxvQkFBb0IxN0UsSUFBSSxFQUFFdTdFLFFBQVEsRUFBRTtRQUNsQyxNQUFNQyxVQUFVLElBQUksQ0FBQyxDQUFDSCxTQUFTLENBQUNsOEUsR0FBRyxDQUFDbzhFO1FBQ3BDQztRQUNBLElBQUksQ0FBQyxDQUFDSCxTQUFTLENBQUMzOEIsTUFBTSxDQUFDNjhCO0lBQ3pCO0lBQ0FJLFlBQVk7UUFDVixLQUFLLE1BQU0sR0FBR0gsUUFBUSxJQUFJLElBQUksQ0FBQyxDQUFDSCxTQUFTLENBQUU7WUFDekNHO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQ0gsU0FBUyxDQUFDMzJELEtBQUs7SUFDdkI7O2FBeENBLENBQUMyMkQsU0FBUyxHQUFHLElBQUlqeEM7YUFDakIsQ0FBQ2t4QyxRQUFRLEdBQUd2MEUsUUFBUVEsT0FBTzs7QUF3QzdCO0VBRUMsa0NBQWtDO0FBSW5DLE1BQU1xMEUsZUFBZTtJQUNuQkMsTUFBTTtJQUNOQyxPQUFPO0FBQ1Q7QUFDQSxNQUFNQyxhQUFhO0lBQ2pCQyxRQUFRO0lBQ1JDLGlCQUFpQjtJQUNqQkMsT0FBTztJQUNQQyxTQUFTO0lBQ1RMLE9BQU87SUFDUE0sTUFBTTtJQUNOQyxlQUFlO0lBQ2ZDLGdCQUFnQjtBQUNsQjtBQUNBLFNBQVNDLFFBQVE7QUFDakIsU0FBU0MsV0FBVzN6QyxFQUFFO0lBQ3BCLElBQUlBLGNBQWN0SCxrQkFBa0JzSCxjQUFjM0gsdUJBQXVCMkgsY0FBYy9ILHFCQUFxQitILGNBQWMxSCxxQkFBcUIwSCxjQUFjN0gsdUJBQXVCO1FBQ2xMLE9BQU82SDtJQUNUO0lBQ0EsSUFBSSxDQUFFQSxDQUFBQSxjQUFjeHRCLFNBQVMsT0FBT3d0QixPQUFPLFlBQVlBLE9BQU8sSUFBRyxHQUFJO1FBQ25FbkosWUFBWTtJQUNkO0lBQ0EsT0FBUW1KLEdBQUc3b0MsSUFBSTtRQUNiLEtBQUs7WUFDSCxPQUFPLElBQUl1aEMsZUFBZXNILEdBQUdyc0IsT0FBTztRQUN0QyxLQUFLO1lBQ0gsT0FBTyxJQUFJMGtCLG9CQUFvQjJILEdBQUdyc0IsT0FBTztRQUMzQyxLQUFLO1lBQ0gsT0FBTyxJQUFJc2tCLGtCQUFrQitILEdBQUdyc0IsT0FBTyxFQUFFcXNCLEdBQUc5SCxJQUFJO1FBQ2xELEtBQUs7WUFDSCxPQUFPLElBQUlJLGtCQUFrQjBILEdBQUdyc0IsT0FBTyxFQUFFcXNCLEdBQUd6SCxNQUFNLEVBQUV5SCxHQUFHeEgsT0FBTztRQUNoRSxLQUFLO1lBQ0gsT0FBTyxJQUFJTCxzQkFBc0I2SCxHQUFHcnNCLE9BQU8sRUFBRXFzQixHQUFHNUgsT0FBTztJQUMzRDtJQUNBLE9BQU8sSUFBSUQsc0JBQXNCNkgsR0FBR3JzQixPQUFPLEVBQUVxc0IsR0FBR2hvQyxRQUFRO0FBQzFEO0FBQ0EsTUFBTTQ3RTtJQUNKLENBQUNDLFNBQVMsQ0FBeUI7SUFDbkNwOEUsWUFBWXE4RSxVQUFVLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxDQUFFO2FBRDVDLENBQUNILFNBQVMsR0FBRyxJQUFJMXdDO1FBRWYsSUFBSSxDQUFDMndDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsV0FBVyxHQUFHejlFLE9BQU8rTCxNQUFNLENBQUM7UUFDakMsSUFBSSxDQUFDMnhFLGlCQUFpQixHQUFHMTlFLE9BQU8rTCxNQUFNLENBQUM7UUFDdkMsSUFBSSxDQUFDNHhFLG9CQUFvQixHQUFHMzlFLE9BQU8rTCxNQUFNLENBQUM7UUFDMUMsSUFBSSxDQUFDNnhFLGFBQWEsR0FBRzU5RSxPQUFPK0wsTUFBTSxDQUFDO1FBQ25DdXhFLE9BQU94d0MsZ0JBQWdCLENBQUMsV0FBVyxJQUFJLENBQUMsQ0FBQyt3QyxTQUFTLENBQUNuNkUsSUFBSSxDQUFDLElBQUksR0FBRztZQUM3RGdwQyxRQUFRLElBQUksQ0FBQyxDQUFDeXdDLFNBQVMsQ0FBQ3p3QyxNQUFNO1FBQ2hDO0lBQ0Y7SUFDQSxDQUFDbXhDLFNBQVMsQ0FBQyxFQUNUM3ZFLElBQUksRUFDTDtRQUNDLElBQUlBLEtBQUttdkUsVUFBVSxLQUFLLElBQUksQ0FBQ0QsVUFBVSxFQUFFO1lBQ3ZDO1FBQ0Y7UUFDQSxJQUFJbHZFLEtBQUs0dkUsTUFBTSxFQUFFO1lBQ2YsSUFBSSxDQUFDLENBQUNDLG9CQUFvQixDQUFDN3ZFO1lBQzNCO1FBQ0Y7UUFDQSxJQUFJQSxLQUFLNk4sUUFBUSxFQUFFO1lBQ2pCLE1BQU13aEUsYUFBYXJ2RSxLQUFLcXZFLFVBQVU7WUFDbEMsTUFBTVMsYUFBYSxJQUFJLENBQUNMLG9CQUFvQixDQUFDSixXQUFXO1lBQ3hELElBQUksQ0FBQ1MsWUFBWTtnQkFDZixNQUFNLElBQUlsaUUsTUFBTSxDQUFDLHdCQUF3QixFQUFFeWhFLFdBQVcsQ0FBQztZQUN6RDtZQUNBLE9BQU8sSUFBSSxDQUFDSSxvQkFBb0IsQ0FBQ0osV0FBVztZQUM1QyxJQUFJcnZFLEtBQUs2TixRQUFRLEtBQUtzZ0UsYUFBYUMsSUFBSSxFQUFFO2dCQUN2QzBCLFdBQVdoMkUsT0FBTyxDQUFDa0csS0FBS0EsSUFBSTtZQUM5QixPQUFPLElBQUlBLEtBQUs2TixRQUFRLEtBQUtzZ0UsYUFBYUUsS0FBSyxFQUFFO2dCQUMvQ3lCLFdBQVdqMkUsTUFBTSxDQUFDazFFLFdBQVcvdUUsS0FBSzIrQixNQUFNO1lBQzFDLE9BQU87Z0JBQ0wsTUFBTSxJQUFJL3dCLE1BQU07WUFDbEI7WUFDQTtRQUNGO1FBQ0EsTUFBTSs2QyxTQUFTLElBQUksQ0FBQyttQixhQUFhLENBQUMxdkUsS0FBSzJvRCxNQUFNLENBQUM7UUFDOUMsSUFBSSxDQUFDQSxRQUFRO1lBQ1gsTUFBTSxJQUFJLzZDLE1BQU0sQ0FBQyw0QkFBNEIsRUFBRTVOLEtBQUsyb0QsTUFBTSxDQUFDLENBQUM7UUFDOUQ7UUFDQSxJQUFJM29ELEtBQUtxdkUsVUFBVSxFQUFFO1lBQ25CLE1BQU1ILGFBQWEsSUFBSSxDQUFDQSxVQUFVLEVBQ2hDQyxhQUFhbnZFLEtBQUtrdkUsVUFBVSxFQUM1QkUsU0FBUyxJQUFJLENBQUNBLE1BQU07WUFDdEI5MUUsUUFBUXkyRSxHQUFHLENBQUNwbkIsUUFBUTNvRCxLQUFLQSxJQUFJLEVBQUVvMEMsSUFBSSxDQUFDLFNBQVV0akQsTUFBTTtnQkFDbERzK0UsT0FBTy9tRSxXQUFXLENBQUM7b0JBQ2pCNm1FO29CQUNBQztvQkFDQXRoRSxVQUFVc2dFLGFBQWFDLElBQUk7b0JBQzNCaUIsWUFBWXJ2RSxLQUFLcXZFLFVBQVU7b0JBQzNCcnZFLE1BQU1sUDtnQkFDUjtZQUNGLEdBQUcsU0FBVTZ0QyxNQUFNO2dCQUNqQnl3QyxPQUFPL21FLFdBQVcsQ0FBQztvQkFDakI2bUU7b0JBQ0FDO29CQUNBdGhFLFVBQVVzZ0UsYUFBYUUsS0FBSztvQkFDNUJnQixZQUFZcnZFLEtBQUtxdkUsVUFBVTtvQkFDM0Ixd0MsUUFBUW93QyxXQUFXcHdDO2dCQUNyQjtZQUNGO1lBQ0E7UUFDRjtRQUNBLElBQUkzK0IsS0FBS3N2RSxRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDLENBQUNVLGdCQUFnQixDQUFDaHdFO1lBQ3ZCO1FBQ0Y7UUFDQTJvRCxPQUFPM29ELEtBQUtBLElBQUk7SUFDbEI7SUFDQTZnRCxHQUFHb3ZCLFVBQVUsRUFBRUMsT0FBTyxFQUFFO1FBQ3RCLE1BQU1DLEtBQUssSUFBSSxDQUFDVCxhQUFhO1FBQzdCLElBQUlTLEVBQUUsQ0FBQ0YsV0FBVyxFQUFFO1lBQ2xCLE1BQU0sSUFBSXJpRSxNQUFNLENBQUMsdUNBQXVDLEVBQUVxaUUsV0FBVyxDQUFDLENBQUM7UUFDekU7UUFDQUUsRUFBRSxDQUFDRixXQUFXLEdBQUdDO0lBQ25CO0lBQ0F2c0MsS0FBS3NzQyxVQUFVLEVBQUVqd0UsSUFBSSxFQUFFb3dFLFNBQVMsRUFBRTtRQUNoQyxJQUFJLENBQUNoQixNQUFNLENBQUMvbUUsV0FBVyxDQUFDO1lBQ3RCNm1FLFlBQVksSUFBSSxDQUFDQSxVQUFVO1lBQzNCQyxZQUFZLElBQUksQ0FBQ0EsVUFBVTtZQUMzQnhtQixRQUFRc25CO1lBQ1Jqd0U7UUFDRixHQUFHb3dFO0lBQ0w7SUFDQUMsZ0JBQWdCSixVQUFVLEVBQUVqd0UsSUFBSSxFQUFFb3dFLFNBQVMsRUFBRTtRQUMzQyxNQUFNZixhQUFhLElBQUksQ0FBQ0EsVUFBVTtRQUNsQyxNQUFNUyxhQUFheDJFLFFBQVErUSxhQUFhO1FBQ3hDLElBQUksQ0FBQ29sRSxvQkFBb0IsQ0FBQ0osV0FBVyxHQUFHUztRQUN4QyxJQUFJO1lBQ0YsSUFBSSxDQUFDVixNQUFNLENBQUMvbUUsV0FBVyxDQUFDO2dCQUN0QjZtRSxZQUFZLElBQUksQ0FBQ0EsVUFBVTtnQkFDM0JDLFlBQVksSUFBSSxDQUFDQSxVQUFVO2dCQUMzQnhtQixRQUFRc25CO2dCQUNSWjtnQkFDQXJ2RTtZQUNGLEdBQUdvd0U7UUFDTCxFQUFFLE9BQU9oMUMsSUFBSTtZQUNYMDBDLFdBQVdqMkUsTUFBTSxDQUFDdWhDO1FBQ3BCO1FBQ0EsT0FBTzAwQyxXQUFXLzFFLE9BQU87SUFDM0I7SUFDQXUyRSxlQUFlTCxVQUFVLEVBQUVqd0UsSUFBSSxFQUFFdXdFLGdCQUFnQixFQUFFSCxTQUFTLEVBQUU7UUFDNUQsTUFBTWQsV0FBVyxJQUFJLENBQUNBLFFBQVEsSUFDNUJKLGFBQWEsSUFBSSxDQUFDQSxVQUFVLEVBQzVCQyxhQUFhLElBQUksQ0FBQ0EsVUFBVSxFQUM1QkMsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDdEIsT0FBTyxJQUFJb0IsZUFBZTtZQUN4QmwxRCxPQUFPbTFELENBQUFBO2dCQUNMLE1BQU1DLGtCQUFrQnAzRSxRQUFRK1EsYUFBYTtnQkFDN0MsSUFBSSxDQUFDbWxFLGlCQUFpQixDQUFDRixTQUFTLEdBQUc7b0JBQ2pDbUI7b0JBQ0FFLFdBQVdEO29CQUNYRSxVQUFVO29CQUNWQyxZQUFZO29CQUNaQyxVQUFVO2dCQUNaO2dCQUNBMUIsT0FBTy9tRSxXQUFXLENBQUM7b0JBQ2pCNm1FO29CQUNBQztvQkFDQXhtQixRQUFRc25CO29CQUNSWDtvQkFDQXR2RTtvQkFDQSt3RSxhQUFhTixXQUFXTSxXQUFXO2dCQUNyQyxHQUFHWDtnQkFDSCxPQUFPTSxnQkFBZ0IzMkUsT0FBTztZQUNoQztZQUNBaTNFLE1BQU1QLENBQUFBO2dCQUNKLE1BQU1RLGlCQUFpQjMzRSxRQUFRK1EsYUFBYTtnQkFDNUMsSUFBSSxDQUFDbWxFLGlCQUFpQixDQUFDRixTQUFTLENBQUNzQixRQUFRLEdBQUdLO2dCQUM1QzdCLE9BQU8vbUUsV0FBVyxDQUFDO29CQUNqQjZtRTtvQkFDQUM7b0JBQ0FTLFFBQVF0QixXQUFXSyxJQUFJO29CQUN2Qlc7b0JBQ0F5QixhQUFhTixXQUFXTSxXQUFXO2dCQUNyQztnQkFDQSxPQUFPRSxlQUFlbDNFLE9BQU87WUFDL0I7WUFDQXExRCxRQUFRendCLENBQUFBO2dCQUNOek0sT0FBT3lNLGtCQUFrQi93QixPQUFPO2dCQUNoQyxNQUFNc2pFLG1CQUFtQjUzRSxRQUFRK1EsYUFBYTtnQkFDOUMsSUFBSSxDQUFDbWxFLGlCQUFpQixDQUFDRixTQUFTLENBQUN1QixVQUFVLEdBQUdLO2dCQUM5QyxJQUFJLENBQUMxQixpQkFBaUIsQ0FBQ0YsU0FBUyxDQUFDd0IsUUFBUSxHQUFHO2dCQUM1QzFCLE9BQU8vbUUsV0FBVyxDQUFDO29CQUNqQjZtRTtvQkFDQUM7b0JBQ0FTLFFBQVF0QixXQUFXQyxNQUFNO29CQUN6QmU7b0JBQ0Ezd0MsUUFBUW93QyxXQUFXcHdDO2dCQUNyQjtnQkFDQSxPQUFPdXlDLGlCQUFpQm4zRSxPQUFPO1lBQ2pDO1FBQ0YsR0FBR3cyRTtJQUNMO0lBQ0EsQ0FBQ1AsZ0JBQWdCLENBQUNod0UsSUFBSTtRQUNwQixNQUFNc3ZFLFdBQVd0dkUsS0FBS3N2RSxRQUFRLEVBQzVCSixhQUFhLElBQUksQ0FBQ0EsVUFBVSxFQUM1QkMsYUFBYW52RSxLQUFLa3ZFLFVBQVUsRUFDNUJFLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQ3RCLE1BQU1wbUUsUUFBTyxJQUFJLEVBQ2YyL0MsU0FBUyxJQUFJLENBQUMrbUIsYUFBYSxDQUFDMXZFLEtBQUsyb0QsTUFBTSxDQUFDO1FBQzFDLE1BQU13b0IsYUFBYTtZQUNqQkMsU0FBUWgwRCxLQUFLLEVBQUUzWSxPQUFPLENBQUMsRUFBRTJyRSxTQUFTO2dCQUNoQyxJQUFJLElBQUksQ0FBQ2lCLFdBQVcsRUFBRTtvQkFDcEI7Z0JBQ0Y7Z0JBQ0EsTUFBTUMsa0JBQWtCLElBQUksQ0FBQ1AsV0FBVztnQkFDeEMsSUFBSSxDQUFDQSxXQUFXLElBQUl0c0U7Z0JBQ3BCLElBQUk2c0Usa0JBQWtCLEtBQUssSUFBSSxDQUFDUCxXQUFXLElBQUksR0FBRztvQkFDaEQsSUFBSSxDQUFDUSxjQUFjLEdBQUdqNEUsUUFBUStRLGFBQWE7b0JBQzNDLElBQUksQ0FBQ21uRSxLQUFLLEdBQUcsSUFBSSxDQUFDRCxjQUFjLENBQUN4M0UsT0FBTztnQkFDMUM7Z0JBQ0FxMUUsT0FBTy9tRSxXQUFXLENBQUM7b0JBQ2pCNm1FO29CQUNBQztvQkFDQVMsUUFBUXRCLFdBQVdJLE9BQU87b0JBQzFCWTtvQkFDQWx5RDtnQkFDRixHQUFHZ3pEO1lBQ0w7WUFDQXh6RTtnQkFDRSxJQUFJLElBQUksQ0FBQ3kwRSxXQUFXLEVBQUU7b0JBQ3BCO2dCQUNGO2dCQUNBLElBQUksQ0FBQ0EsV0FBVyxHQUFHO2dCQUNuQmpDLE9BQU8vbUUsV0FBVyxDQUFDO29CQUNqQjZtRTtvQkFDQUM7b0JBQ0FTLFFBQVF0QixXQUFXRyxLQUFLO29CQUN4QmE7Z0JBQ0Y7Z0JBQ0EsT0FBT3RtRSxNQUFLdW1FLFdBQVcsQ0FBQ0QsU0FBUztZQUNuQztZQUNBLytFLE9BQU1vdUMsTUFBTTtnQkFDVnpNLE9BQU95TSxrQkFBa0Ivd0IsT0FBTztnQkFDaEMsSUFBSSxJQUFJLENBQUN5akUsV0FBVyxFQUFFO29CQUNwQjtnQkFDRjtnQkFDQSxJQUFJLENBQUNBLFdBQVcsR0FBRztnQkFDbkJqQyxPQUFPL21FLFdBQVcsQ0FBQztvQkFDakI2bUU7b0JBQ0FDO29CQUNBUyxRQUFRdEIsV0FBV0QsS0FBSztvQkFDeEJpQjtvQkFDQTN3QyxRQUFRb3dDLFdBQVdwd0M7Z0JBQ3JCO1lBQ0Y7WUFDQTR5QyxnQkFBZ0JqNEUsUUFBUStRLGFBQWE7WUFDckNvbkUsUUFBUTtZQUNSQyxVQUFVO1lBQ1ZMLGFBQWE7WUFDYk4sYUFBYS93RSxLQUFLK3dFLFdBQVc7WUFDN0JTLE9BQU87UUFDVDtRQUNBTCxXQUFXSSxjQUFjLENBQUN6M0UsT0FBTztRQUNqQ3EzRSxXQUFXSyxLQUFLLEdBQUdMLFdBQVdJLGNBQWMsQ0FBQ3gzRSxPQUFPO1FBQ3BELElBQUksQ0FBQ3cxRSxXQUFXLENBQUNELFNBQVMsR0FBRzZCO1FBQzdCNzNFLFFBQVF5MkUsR0FBRyxDQUFDcG5CLFFBQVEzb0QsS0FBS0EsSUFBSSxFQUFFbXhFLFlBQVkvOEIsSUFBSSxDQUFDO1lBQzlDZzdCLE9BQU8vbUUsV0FBVyxDQUFDO2dCQUNqQjZtRTtnQkFDQUM7Z0JBQ0FTLFFBQVF0QixXQUFXTyxjQUFjO2dCQUNqQ1M7Z0JBQ0FxQyxTQUFTO1lBQ1g7UUFDRixHQUFHLFNBQVVoekMsTUFBTTtZQUNqQnl3QyxPQUFPL21FLFdBQVcsQ0FBQztnQkFDakI2bUU7Z0JBQ0FDO2dCQUNBUyxRQUFRdEIsV0FBV08sY0FBYztnQkFDakNTO2dCQUNBM3dDLFFBQVFvd0MsV0FBV3B3QztZQUNyQjtRQUNGO0lBQ0Y7SUFDQSxDQUFDa3hDLG9CQUFvQixDQUFDN3ZFLElBQUk7UUFDeEIsTUFBTXN2RSxXQUFXdHZFLEtBQUtzdkUsUUFBUSxFQUM1QkosYUFBYSxJQUFJLENBQUNBLFVBQVUsRUFDNUJDLGFBQWFudkUsS0FBS2t2RSxVQUFVLEVBQzVCRSxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUN0QixNQUFNd0MsbUJBQW1CLElBQUksQ0FBQ3BDLGlCQUFpQixDQUFDRixTQUFTLEVBQ3ZENkIsYUFBYSxJQUFJLENBQUM1QixXQUFXLENBQUNELFNBQVM7UUFDekMsT0FBUXR2RSxLQUFLNHZFLE1BQU07WUFDakIsS0FBS3RCLFdBQVdPLGNBQWM7Z0JBQzVCLElBQUk3dUUsS0FBSzJ4RSxPQUFPLEVBQUU7b0JBQ2hCQyxpQkFBaUJqQixTQUFTLENBQUM3MkUsT0FBTztnQkFDcEMsT0FBTztvQkFDTDgzRSxpQkFBaUJqQixTQUFTLENBQUM5MkUsTUFBTSxDQUFDazFFLFdBQVcvdUUsS0FBSzIrQixNQUFNO2dCQUMxRDtnQkFDQTtZQUNGLEtBQUsydkMsV0FBV00sYUFBYTtnQkFDM0IsSUFBSTV1RSxLQUFLMnhFLE9BQU8sRUFBRTtvQkFDaEJDLGlCQUFpQmhCLFFBQVEsQ0FBQzkyRSxPQUFPO2dCQUNuQyxPQUFPO29CQUNMODNFLGlCQUFpQmhCLFFBQVEsQ0FBQy8yRSxNQUFNLENBQUNrMUUsV0FBVy91RSxLQUFLMitCLE1BQU07Z0JBQ3pEO2dCQUNBO1lBQ0YsS0FBSzJ2QyxXQUFXSyxJQUFJO2dCQUNsQixJQUFJLENBQUN3QyxZQUFZO29CQUNmL0IsT0FBTy9tRSxXQUFXLENBQUM7d0JBQ2pCNm1FO3dCQUNBQzt3QkFDQVMsUUFBUXRCLFdBQVdNLGFBQWE7d0JBQ2hDVTt3QkFDQXFDLFNBQVM7b0JBQ1g7b0JBQ0E7Z0JBQ0Y7Z0JBQ0EsSUFBSVIsV0FBV0osV0FBVyxJQUFJLEtBQUsvd0UsS0FBSyt3RSxXQUFXLEdBQUcsR0FBRztvQkFDdkRJLFdBQVdJLGNBQWMsQ0FBQ3ozRSxPQUFPO2dCQUNuQztnQkFDQXEzRSxXQUFXSixXQUFXLEdBQUcvd0UsS0FBSyt3RSxXQUFXO2dCQUN6Q3ozRSxRQUFReTJFLEdBQUcsQ0FBQ29CLFdBQVdNLE1BQU0sSUFBSTNDLE1BQU0xNkIsSUFBSSxDQUFDO29CQUMxQ2c3QixPQUFPL21FLFdBQVcsQ0FBQzt3QkFDakI2bUU7d0JBQ0FDO3dCQUNBUyxRQUFRdEIsV0FBV00sYUFBYTt3QkFDaENVO3dCQUNBcUMsU0FBUztvQkFDWDtnQkFDRixHQUFHLFNBQVVoekMsTUFBTTtvQkFDakJ5d0MsT0FBTy9tRSxXQUFXLENBQUM7d0JBQ2pCNm1FO3dCQUNBQzt3QkFDQVMsUUFBUXRCLFdBQVdNLGFBQWE7d0JBQ2hDVTt3QkFDQTN3QyxRQUFRb3dDLFdBQVdwd0M7b0JBQ3JCO2dCQUNGO2dCQUNBO1lBQ0YsS0FBSzJ2QyxXQUFXSSxPQUFPO2dCQUNyQng4QyxPQUFPMC9DLGtCQUFrQjtnQkFDekIsSUFBSUEsaUJBQWlCZCxRQUFRLEVBQUU7b0JBQzdCO2dCQUNGO2dCQUNBYyxpQkFBaUJuQixVQUFVLENBQUNXLE9BQU8sQ0FBQ3B4RSxLQUFLb2QsS0FBSztnQkFDOUM7WUFDRixLQUFLa3hELFdBQVdHLEtBQUs7Z0JBQ25CdjhDLE9BQU8wL0Msa0JBQWtCO2dCQUN6QixJQUFJQSxpQkFBaUJkLFFBQVEsRUFBRTtvQkFDN0I7Z0JBQ0Y7Z0JBQ0FjLGlCQUFpQmQsUUFBUSxHQUFHO2dCQUM1QmMsaUJBQWlCbkIsVUFBVSxDQUFDN3pFLEtBQUs7Z0JBQ2pDLElBQUksQ0FBQyxDQUFDaTFFLHNCQUFzQixDQUFDRCxrQkFBa0J0QztnQkFDL0M7WUFDRixLQUFLaEIsV0FBV0QsS0FBSztnQkFDbkJuOEMsT0FBTzAvQyxrQkFBa0I7Z0JBQ3pCQSxpQkFBaUJuQixVQUFVLENBQUNsZ0YsS0FBSyxDQUFDdytFLFdBQVcvdUUsS0FBSzIrQixNQUFNO2dCQUN4RCxJQUFJLENBQUMsQ0FBQ2t6QyxzQkFBc0IsQ0FBQ0Qsa0JBQWtCdEM7Z0JBQy9DO1lBQ0YsS0FBS2hCLFdBQVdFLGVBQWU7Z0JBQzdCLElBQUl4dUUsS0FBSzJ4RSxPQUFPLEVBQUU7b0JBQ2hCQyxpQkFBaUJmLFVBQVUsQ0FBQy8yRSxPQUFPO2dCQUNyQyxPQUFPO29CQUNMODNFLGlCQUFpQmYsVUFBVSxDQUFDaDNFLE1BQU0sQ0FBQ2sxRSxXQUFXL3VFLEtBQUsyK0IsTUFBTTtnQkFDM0Q7Z0JBQ0EsSUFBSSxDQUFDLENBQUNrekMsc0JBQXNCLENBQUNELGtCQUFrQnRDO2dCQUMvQztZQUNGLEtBQUtoQixXQUFXQyxNQUFNO2dCQUNwQixJQUFJLENBQUM0QyxZQUFZO29CQUNmO2dCQUNGO2dCQUNBLE1BQU1XLGFBQWEvQyxXQUFXL3VFLEtBQUsyK0IsTUFBTTtnQkFDekNybEMsUUFBUXkyRSxHQUFHLENBQUNvQixXQUFXTyxRQUFRLElBQUk1QyxNQUFNZ0QsWUFBWTE5QixJQUFJLENBQUM7b0JBQ3hEZzdCLE9BQU8vbUUsV0FBVyxDQUFDO3dCQUNqQjZtRTt3QkFDQUM7d0JBQ0FTLFFBQVF0QixXQUFXRSxlQUFlO3dCQUNsQ2M7d0JBQ0FxQyxTQUFTO29CQUNYO2dCQUNGLEdBQUcsU0FBVWh6QyxNQUFNO29CQUNqQnl3QyxPQUFPL21FLFdBQVcsQ0FBQzt3QkFDakI2bUU7d0JBQ0FDO3dCQUNBUyxRQUFRdEIsV0FBV0UsZUFBZTt3QkFDbENjO3dCQUNBM3dDLFFBQVFvd0MsV0FBV3B3QztvQkFDckI7Z0JBQ0Y7Z0JBQ0F3eUMsV0FBV0ksY0FBYyxDQUFDMTNFLE1BQU0sQ0FBQ2k0RTtnQkFDakNYLFdBQVdFLFdBQVcsR0FBRztnQkFDekIsT0FBTyxJQUFJLENBQUM5QixXQUFXLENBQUNELFNBQVM7Z0JBQ2pDO1lBQ0Y7Z0JBQ0UsTUFBTSxJQUFJMWhFLE1BQU07UUFDcEI7SUFDRjtJQUNBLE1BQU0sQ0FBQ2lrRSxzQkFBc0IsQ0FBQ0QsZ0JBQWdCLEVBQUV0QyxRQUFRO1FBQ3RELE1BQU1oMkUsUUFBUXk0RSxVQUFVLENBQUM7WUFBQ0gsaUJBQWlCakIsU0FBUyxFQUFFNTJFO1lBQVM2M0UsaUJBQWlCaEIsUUFBUSxFQUFFNzJFO1lBQVM2M0UsaUJBQWlCZixVQUFVLEVBQUU5MkU7U0FBUTtRQUN4SSxPQUFPLElBQUksQ0FBQ3kxRSxpQkFBaUIsQ0FBQ0YsU0FBUztJQUN6QztJQUNBLzhCLFVBQVU7UUFDUixJQUFJLENBQUMsQ0FBQzA4QixTQUFTLEVBQUV2d0M7UUFDakIsSUFBSSxDQUFDLENBQUN1d0MsU0FBUyxHQUFHO0lBQ3BCO0FBQ0Y7RUFFQyxrQ0FBa0M7QUFFbkMsTUFBTStDO0lBQ0osQ0FBQ0MsU0FBUyxDQUFTO0lBQ25CcC9FLFlBQVksRUFDVm8vRSxZQUFZLEtBQUssRUFDbEIsQ0FBRTthQUhILENBQUNBLFNBQVMsR0FBRztRQUlYLElBQUksQ0FBQyxDQUFDQSxTQUFTLEdBQUdBO0lBQ3BCO0lBQ0FwMEUsT0FBTyttQyxLQUFLLEVBQUVDLE1BQU0sRUFBRTtRQUNwQixJQUFJRCxTQUFTLEtBQUtDLFVBQVUsR0FBRztZQUM3QixNQUFNLElBQUlqM0IsTUFBTTtRQUNsQjtRQUNBLE1BQU1tbUMsU0FBUyxJQUFJLENBQUNtK0IsYUFBYSxDQUFDdHRDLE9BQU9DO1FBQ3pDLE9BQU87WUFDTGtQO1lBQ0EzNUIsU0FBUzI1QixPQUFPQyxVQUFVLENBQUMsTUFBTTtnQkFDL0JDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDZytCLFNBQVM7WUFDdEM7UUFDRjtJQUNGO0lBQ0FFLE1BQU1DLGdCQUFnQixFQUFFeHRDLEtBQUssRUFBRUMsTUFBTSxFQUFFO1FBQ3JDLElBQUksQ0FBQ3V0QyxpQkFBaUJyK0IsTUFBTSxFQUFFO1lBQzVCLE1BQU0sSUFBSW5tQyxNQUFNO1FBQ2xCO1FBQ0EsSUFBSWczQixTQUFTLEtBQUtDLFVBQVUsR0FBRztZQUM3QixNQUFNLElBQUlqM0IsTUFBTTtRQUNsQjtRQUNBd2tFLGlCQUFpQnIrQixNQUFNLENBQUNuUCxLQUFLLEdBQUdBO1FBQ2hDd3RDLGlCQUFpQnIrQixNQUFNLENBQUNsUCxNQUFNLEdBQUdBO0lBQ25DO0lBQ0EwTixRQUFRNi9CLGdCQUFnQixFQUFFO1FBQ3hCLElBQUksQ0FBQ0EsaUJBQWlCcitCLE1BQU0sRUFBRTtZQUM1QixNQUFNLElBQUlubUMsTUFBTTtRQUNsQjtRQUNBd2tFLGlCQUFpQnIrQixNQUFNLENBQUNuUCxLQUFLLEdBQUc7UUFDaEN3dEMsaUJBQWlCcitCLE1BQU0sQ0FBQ2xQLE1BQU0sR0FBRztRQUNqQ3V0QyxpQkFBaUJyK0IsTUFBTSxHQUFHO1FBQzFCcStCLGlCQUFpQmg0RCxPQUFPLEdBQUc7SUFDN0I7SUFDQTgzRCxjQUFjdHRDLEtBQUssRUFBRUMsTUFBTSxFQUFFO1FBQzNCNVMsWUFBWTtJQUNkO0FBQ0Y7QUFDQSxNQUFNb2dELHlCQUF5Qkw7SUFDN0JuL0UsWUFBWSxFQUNWdTBFLGdCQUFnQnh6RSxXQUFXNEosUUFBUSxFQUNuQ3kwRSxZQUFZLEtBQUssRUFDbEIsQ0FBRTtRQUNELEtBQUssQ0FBQztZQUNKQTtRQUNGO1FBQ0EsSUFBSSxDQUFDM0ssU0FBUyxHQUFHRjtJQUNuQjtJQUNBOEssY0FBY3R0QyxLQUFLLEVBQUVDLE1BQU0sRUFBRTtRQUMzQixNQUFNa1AsU0FBUyxJQUFJLENBQUN1ekIsU0FBUyxDQUFDbmhFLGFBQWEsQ0FBQztRQUM1QzR0QyxPQUFPblAsS0FBSyxHQUFHQTtRQUNmbVAsT0FBT2xQLE1BQU0sR0FBR0E7UUFDaEIsT0FBT2tQO0lBQ1Q7QUFDRjtFQUVDLHVDQUF1QztBQVd4QyxNQUFNdStCO0lBQ0p6L0UsWUFBWSxFQUNWMC9CLFVBQVUsSUFBSSxFQUNkZ2dELGVBQWUsSUFBSSxFQUNwQixDQUFFO1FBQ0QsSUFBSSxDQUFDaGdELE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNnZ0QsWUFBWSxHQUFHQTtJQUN0QjtJQUNBLE1BQU14dkMsTUFBTSxFQUNWeHdDLElBQUksRUFDTCxFQUFFO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQ2dnQyxPQUFPLEVBQUU7WUFDakIsTUFBTSxJQUFJM2tCLE1BQU07UUFDbEI7UUFDQSxJQUFJLENBQUNyYixNQUFNO1lBQ1QsTUFBTSxJQUFJcWIsTUFBTTtRQUNsQjtRQUNBLE1BQU13RixNQUFNLElBQUksQ0FBQ21mLE9BQU8sR0FBR2hnQyxPQUFRLEtBQUksQ0FBQ2dnRixZQUFZLEdBQUcsV0FBVyxFQUFDO1FBQ25FLE9BQU8sSUFBSSxDQUFDQyxNQUFNLENBQUNwL0QsS0FBS2doQyxJQUFJLENBQUNxK0IsQ0FBQUEsV0FBYTtnQkFDeENBO2dCQUNBRixjQUFjLElBQUksQ0FBQ0EsWUFBWTtZQUNqQyxJQUFJRyxLQUFLLENBQUMvekMsQ0FBQUE7WUFDUixNQUFNLElBQUkvd0IsTUFBTSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMya0UsWUFBWSxHQUFHLFlBQVksR0FBRyxTQUFTLEVBQUVuL0QsSUFBSSxDQUFDO1FBQ3ZGO0lBQ0Y7SUFDQSxNQUFNby9ELE9BQU9wL0QsR0FBRyxFQUFFO1FBQ2hCNmUsWUFBWTtJQUNkO0FBQ0Y7QUFDQSxNQUFNMGdELDZCQUE2Qkw7SUFDakMsTUFBTUUsT0FBT3AvRCxHQUFHLEVBQUU7UUFDaEIsTUFBTXBULE9BQU8sTUFBTTJpQyxVQUFVdnZCLEtBQUssSUFBSSxDQUFDbS9ELFlBQVksR0FBRyxnQkFBZ0I7UUFDdEUsT0FBT3Z5RSxnQkFBZ0JqSCxjQUFjLElBQUkvRSxXQUFXZ00sUUFBUW8wQixjQUFjcDBCO0lBQzVFO0FBQ0Y7QUFFQSx3RUFBd0U7QUFDeEUsSUFBSTR5RSxxQkFBcUJsa0YsaUNBQW1CQSxDQUFDO0VBQzVDLGtDQUFrQztBQUtuQyxNQUFNbWtGO0lBQ0pDLFVBQVVDLElBQUksRUFBRTtRQUNkLE9BQU87SUFDVDtJQUNBMTBCLGFBQWEyMEIsT0FBTyxFQUFFQyxPQUFPLEVBQUU7UUFDN0IsT0FBTztJQUNUO0lBQ0FDLGVBQWU1NEUsR0FBRyxFQUFFO1FBQ2xCLE9BQU87SUFDVDtJQUNBNjRFLG9CQUFvQjc0RSxHQUFHLEVBQUU7UUFDdkIsT0FBTztJQUNUO0lBQ0E4NEUsc0JBQXNCQyxVQUFVLEVBQUVMLE9BQU8sRUFBRUMsT0FBTyxFQUFFSyxVQUFVLEVBQUVDLFVBQVUsRUFBRTtRQUMxRSxPQUFPO0lBQ1Q7SUFDQWhoQyxRQUFRaWhDLFVBQVUsS0FBSyxFQUFFLENBQUM7QUFDNUI7QUFDQSxNQUFNQyx5QkFBeUJaO0lBQzdCLENBQUN0Z0QsT0FBTyxDQUFDO0lBQ1QsQ0FBQ21oRCxNQUFNLENBQUM7SUFDUixDQUFDQyxLQUFLLENBQUM7SUFDUCxDQUFDQyxLQUFLLENBQUM7SUFDUCxDQUFDcDJFLFFBQVEsQ0FBQztJQUNWLENBQUNxMkUsU0FBUyxDQUFDO0lBQ1gsQ0FBQ3p2RSxFQUFFLENBQUs7SUFDUnZSLFlBQVksRUFDVitnRixLQUFLLEVBQ0x4TSxnQkFBZ0J4ekUsV0FBVzRKLFFBQVEsRUFDcEMsQ0FBRTtRQUNELEtBQUs7YUFMUCxDQUFDNEcsRUFBRSxHQUFHO1FBTUosSUFBSSxDQUFDLENBQUN3dkUsS0FBSyxHQUFHQTtRQUNkLElBQUksQ0FBQyxDQUFDcDJFLFFBQVEsR0FBRzRwRTtJQUNuQjtJQUNBLElBQUksQ0FBQ3h6QixLQUFLO1FBQ1IsT0FBTyxJQUFJLENBQUMsQ0FBQzgvQixNQUFNLEtBQUssSUFBSS8yQztJQUM5QjtJQUNBLElBQUksQ0FBQ20zQyxRQUFRO1FBQ1gsT0FBTyxJQUFJLENBQUMsQ0FBQ0QsU0FBUyxLQUFLLElBQUlsM0M7SUFDakM7SUFDQSxJQUFJLENBQUNvM0MsSUFBSTtRQUNQLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ0osS0FBSyxFQUFFO1lBQ2hCLE1BQU1oeUMsTUFBTSxJQUFJLENBQUMsQ0FBQ25rQyxRQUFRLENBQUMySSxhQUFhLENBQUM7WUFDekMsTUFBTSxFQUNKaEosS0FBSyxFQUNOLEdBQUd3a0M7WUFDSnhrQyxNQUFNMnJDLFVBQVUsR0FBRztZQUNuQjNyQyxNQUFNNjJFLE9BQU8sR0FBRztZQUNoQjcyRSxNQUFNeW5DLEtBQUssR0FBR3puQyxNQUFNMG5DLE1BQU0sR0FBRztZQUM3QjFuQyxNQUFNNHlDLFFBQVEsR0FBRztZQUNqQjV5QyxNQUFNZ3pDLEdBQUcsR0FBR2h6QyxNQUFNKzhELElBQUksR0FBRztZQUN6Qi84RCxNQUFNNDRELE1BQU0sR0FBRyxDQUFDO1lBQ2hCLE1BQU1qaUIsTUFBTSxJQUFJLENBQUMsQ0FBQ3QyQyxRQUFRLENBQUMya0MsZUFBZSxDQUFDSSxRQUFRO1lBQ25EdVIsSUFBSTFULFlBQVksQ0FBQyxTQUFTO1lBQzFCMFQsSUFBSTFULFlBQVksQ0FBQyxVQUFVO1lBQzNCLElBQUksQ0FBQyxDQUFDdXpDLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQ24yRSxRQUFRLENBQUMya0MsZUFBZSxDQUFDSSxRQUFRO1lBQ3JEWixJQUFJcDRCLE1BQU0sQ0FBQ3VxQztZQUNYQSxJQUFJdnFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQ29xRSxLQUFLO1lBQ3RCLElBQUksQ0FBQyxDQUFDbjJFLFFBQVEsQ0FBQ3dyQyxJQUFJLENBQUN6L0IsTUFBTSxDQUFDbzRCO1FBQzdCO1FBQ0EsT0FBTyxJQUFJLENBQUMsQ0FBQ2d5QyxLQUFLO0lBQ3BCO0lBQ0EsQ0FBQ00sWUFBWSxDQUFDbEIsSUFBSTtRQUNoQixJQUFJQSxLQUFLdGpGLE1BQU0sS0FBSyxHQUFHO1lBQ3JCLE1BQU15a0YsT0FBT25CLElBQUksQ0FBQyxFQUFFO1lBQ3BCLE1BQU01K0UsU0FBUyxJQUFJcU4sTUFBTTtZQUN6QixJQUFLLElBQUlwTixJQUFJLEdBQUdBLElBQUksS0FBS0EsSUFBSztnQkFDNUJELE1BQU0sQ0FBQ0MsRUFBRSxHQUFHOC9FLElBQUksQ0FBQzkvRSxFQUFFLEdBQUc7WUFDeEI7WUFDQSxNQUFNKy9FLFFBQVFoZ0YsT0FBT2pDLElBQUksQ0FBQztZQUMxQixPQUFPO2dCQUFDaWlGO2dCQUFPQTtnQkFBT0E7YUFBTTtRQUM5QjtRQUNBLE1BQU0sQ0FBQ0QsTUFBTUUsTUFBTUMsS0FBSyxHQUFHdEI7UUFDM0IsTUFBTXVCLFVBQVUsSUFBSTl5RSxNQUFNO1FBQzFCLE1BQU0reUUsVUFBVSxJQUFJL3lFLE1BQU07UUFDMUIsTUFBTWd6RSxVQUFVLElBQUloekUsTUFBTTtRQUMxQixJQUFLLElBQUlwTixJQUFJLEdBQUdBLElBQUksS0FBS0EsSUFBSztZQUM1QmtnRixPQUFPLENBQUNsZ0YsRUFBRSxHQUFHOC9FLElBQUksQ0FBQzkvRSxFQUFFLEdBQUc7WUFDdkJtZ0YsT0FBTyxDQUFDbmdGLEVBQUUsR0FBR2dnRixJQUFJLENBQUNoZ0YsRUFBRSxHQUFHO1lBQ3ZCb2dGLE9BQU8sQ0FBQ3BnRixFQUFFLEdBQUdpZ0YsSUFBSSxDQUFDamdGLEVBQUUsR0FBRztRQUN6QjtRQUNBLE9BQU87WUFBQ2tnRixRQUFRcGlGLElBQUksQ0FBQztZQUFNcWlGLFFBQVFyaUYsSUFBSSxDQUFDO1lBQU1zaUYsUUFBUXRpRixJQUFJLENBQUM7U0FBSztJQUNsRTtJQUNBLENBQUN1aUYsU0FBUyxDQUFDcndFLEVBQUU7UUFDWCxJQUFJLElBQUksQ0FBQyxDQUFDbXVCLE9BQU8sS0FBS3YvQixXQUFXO1lBQy9CLElBQUksQ0FBQyxDQUFDdS9CLE9BQU8sR0FBRztZQUNoQixNQUFNbmYsTUFBTSxJQUFJLENBQUMsQ0FBQzVWLFFBQVEsQ0FBQzBWLEdBQUc7WUFDOUIsSUFBSUUsUUFBUSxJQUFJLENBQUMsQ0FBQzVWLFFBQVEsQ0FBQ3FsQyxPQUFPLEVBQUU7Z0JBQ2xDLElBQUk4QyxhQUFhdnlCLE1BQU07b0JBQ3JCNGUsS0FBSztnQkFDUCxPQUFPO29CQUNMLElBQUksQ0FBQyxDQUFDTyxPQUFPLEdBQUdPLGNBQWMxZixLQUFLO2dCQUNyQztZQUNGO1FBQ0Y7UUFDQSxPQUFPLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDbWYsT0FBTyxDQUFDLENBQUMsRUFBRW51QixHQUFHLENBQUMsQ0FBQztJQUN0QztJQUNBMHVFLFVBQVVDLElBQUksRUFBRTtRQUNkLElBQUksQ0FBQ0EsTUFBTTtZQUNULE9BQU87UUFDVDtRQUNBLElBQUlyaUYsUUFBUSxJQUFJLENBQUMsQ0FBQ2tqRCxLQUFLLENBQUNsaUQsR0FBRyxDQUFDcWhGO1FBQzVCLElBQUlyaUYsT0FBTztZQUNULE9BQU9BO1FBQ1Q7UUFDQSxNQUFNLENBQUNna0YsUUFBUUMsUUFBUUMsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDWCxZQUFZLENBQUNsQjtRQUNwRCxNQUFNbDRFLE1BQU1rNEUsS0FBS3RqRixNQUFNLEtBQUssSUFBSWlsRixTQUFTLENBQUMsRUFBRUEsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sQ0FBQztRQUN0RWxrRixRQUFRLElBQUksQ0FBQyxDQUFDa2pELEtBQUssQ0FBQ2xpRCxHQUFHLENBQUNtSjtRQUN4QixJQUFJbkssT0FBTztZQUNULElBQUksQ0FBQyxDQUFDa2pELEtBQUssQ0FBQzU3QyxHQUFHLENBQUMrNkUsTUFBTXJpRjtZQUN0QixPQUFPQTtRQUNUO1FBQ0EsTUFBTTBULEtBQUssQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUN3dkUsS0FBSyxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQ3h2RSxFQUFFLEdBQUcsQ0FBQztRQUN4RCxNQUFNZ1AsTUFBTSxJQUFJLENBQUMsQ0FBQ3FoRSxTQUFTLENBQUNyd0U7UUFDNUIsSUFBSSxDQUFDLENBQUN3dkMsS0FBSyxDQUFDNTdDLEdBQUcsQ0FBQys2RSxNQUFNMy9EO1FBQ3RCLElBQUksQ0FBQyxDQUFDd2dDLEtBQUssQ0FBQzU3QyxHQUFHLENBQUM2QyxLQUFLdVk7UUFDckIsTUFBTWpWLFNBQVMsSUFBSSxDQUFDLENBQUMwMkUsWUFBWSxDQUFDendFO1FBQ2xDLElBQUksQ0FBQyxDQUFDMHdFLHdCQUF3QixDQUFDSixRQUFRQyxRQUFRQyxRQUFRejJFO1FBQ3ZELE9BQU9pVjtJQUNUO0lBQ0FpckMsYUFBYTIwQixPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUM3QixNQUFNcDRFLE1BQU0sQ0FBQyxFQUFFbTRFLFFBQVEsQ0FBQyxFQUFFQyxRQUFRLENBQUM7UUFDbkMsTUFBTUksYUFBYTtRQUNuQixJQUFJeGhELE9BQU8sSUFBSSxDQUFDLENBQUNpaUQsUUFBUSxDQUFDcGlGLEdBQUcsQ0FBQzJoRjtRQUM5QixJQUFJeGhELE1BQU1oM0IsUUFBUUEsS0FBSztZQUNyQixPQUFPZzNCLEtBQUt6ZSxHQUFHO1FBQ2pCO1FBQ0EsSUFBSXllLE1BQU07WUFDUkEsS0FBSzF6QixNQUFNLEVBQUUwRztZQUNiZ3RCLEtBQUtoM0IsR0FBRyxHQUFHQTtZQUNYZzNCLEtBQUt6ZSxHQUFHLEdBQUc7WUFDWHllLEtBQUsxekIsTUFBTSxHQUFHO1FBQ2hCLE9BQU87WUFDTDB6QixPQUFPO2dCQUNMaDNCO2dCQUNBdVksS0FBSztnQkFDTGpWLFFBQVE7WUFDVjtZQUNBLElBQUksQ0FBQyxDQUFDMjFFLFFBQVEsQ0FBQzk3RSxHQUFHLENBQUNxN0UsWUFBWXhoRDtRQUNqQztRQUNBLElBQUksQ0FBQ21oRCxXQUFXLENBQUNDLFNBQVM7WUFDeEIsT0FBT3BoRCxLQUFLemUsR0FBRztRQUNqQjtRQUNBLE1BQU0yaEUsUUFBUSxJQUFJLENBQUMsQ0FBQ3ZzQyxNQUFNLENBQUN3cUM7UUFDM0JBLFVBQVVuOUMsS0FBS0MsWUFBWSxJQUFJaS9DO1FBQy9CLE1BQU1DLFFBQVEsSUFBSSxDQUFDLENBQUN4c0MsTUFBTSxDQUFDeXFDO1FBQzNCQSxVQUFVcDlDLEtBQUtDLFlBQVksSUFBSWsvQztRQUMvQixJQUFJLENBQUMsQ0FBQ2pCLElBQUksQ0FBQzUyRSxLQUFLLENBQUNzckMsS0FBSyxHQUFHO1FBQ3pCLElBQUl1cUMsWUFBWSxhQUFhQyxZQUFZLGFBQWFELFlBQVlDLFNBQVM7WUFDekUsT0FBT3BoRCxLQUFLemUsR0FBRztRQUNqQjtRQUNBLE1BQU05WSxNQUFNLElBQUlrSCxNQUFNO1FBQ3RCLElBQUssSUFBSXBOLElBQUksR0FBR0EsS0FBSyxLQUFLQSxJQUFLO1lBQzdCLE1BQU1nQyxJQUFJaEMsSUFBSTtZQUNka0csR0FBRyxDQUFDbEcsRUFBRSxHQUFHZ0MsS0FBSyxVQUFVQSxJQUFJLFFBQVEsQ0FBQyxDQUFDQSxJQUFJLEtBQUksSUFBSyxLQUFJLEtBQU07UUFDL0Q7UUFDQSxNQUFNKzlFLFFBQVE3NUUsSUFBSXBJLElBQUksQ0FBQztRQUN2QixNQUFNa1MsS0FBSyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQ3d2RSxLQUFLLENBQUMsV0FBVyxDQUFDO1FBQ3hDLE1BQU16MUUsU0FBUzB6QixLQUFLMXpCLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQzAyRSxZQUFZLENBQUN6d0U7UUFDaEQsSUFBSSxDQUFDLENBQUMwd0Usd0JBQXdCLENBQUNYLE9BQU9BLE9BQU9BLE9BQU9oMkU7UUFDcEQsSUFBSSxDQUFDLENBQUM4MkUsaUJBQWlCLENBQUM5MkU7UUFDeEIsTUFBTSsyRSxXQUFXLENBQUN4bEUsR0FBR3JaO1lBQ25CLE1BQU1pbEIsUUFBUXk1RCxLQUFLLENBQUNybEUsRUFBRSxHQUFHO1lBQ3pCLE1BQU11SixNQUFNKzdELEtBQUssQ0FBQ3RsRSxFQUFFLEdBQUc7WUFDdkIsTUFBTW91QixNQUFNLElBQUl0OEIsTUFBTW5MLElBQUk7WUFDMUIsSUFBSyxJQUFJakMsSUFBSSxHQUFHQSxLQUFLaUMsR0FBR2pDLElBQUs7Z0JBQzNCMHBDLEdBQUcsQ0FBQzFwQyxFQUFFLEdBQUdrbkIsUUFBUWxuQixJQUFJaUMsSUFBSzRpQixDQUFBQSxNQUFNcUMsS0FBSTtZQUN0QztZQUNBLE9BQU93aUIsSUFBSTVyQyxJQUFJLENBQUM7UUFDbEI7UUFDQSxJQUFJLENBQUMsQ0FBQzRpRix3QkFBd0IsQ0FBQ0ksU0FBUyxHQUFHLElBQUlBLFNBQVMsR0FBRyxJQUFJQSxTQUFTLEdBQUcsSUFBSS8yRTtRQUMvRTB6QixLQUFLemUsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDcWhFLFNBQVMsQ0FBQ3J3RTtRQUMzQixPQUFPeXRCLEtBQUt6ZSxHQUFHO0lBQ2pCO0lBQ0E4L0QsZUFBZTU0RSxHQUFHLEVBQUU7UUFDbEIsSUFBSTVKLFFBQVEsSUFBSSxDQUFDLENBQUNrakQsS0FBSyxDQUFDbGlELEdBQUcsQ0FBQzRJO1FBQzVCLElBQUk1SixPQUFPO1lBQ1QsT0FBT0E7UUFDVDtRQUNBLE1BQU0sQ0FBQ3lrRixPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUNsQixZQUFZLENBQUM7WUFBQzM1RTtTQUFJO1FBQ3pDLE1BQU1PLE1BQU0sQ0FBQyxNQUFNLEVBQUVzNkUsT0FBTyxDQUFDO1FBQzdCemtGLFFBQVEsSUFBSSxDQUFDLENBQUNrakQsS0FBSyxDQUFDbGlELEdBQUcsQ0FBQ21KO1FBQ3hCLElBQUluSyxPQUFPO1lBQ1QsSUFBSSxDQUFDLENBQUNrakQsS0FBSyxDQUFDNTdDLEdBQUcsQ0FBQ3NDLEtBQUs1SjtZQUNyQixPQUFPQTtRQUNUO1FBQ0EsTUFBTTBULEtBQUssQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUN3dkUsS0FBSyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQ3h2RSxFQUFFLEdBQUcsQ0FBQztRQUNyRCxNQUFNZ1AsTUFBTSxJQUFJLENBQUMsQ0FBQ3FoRSxTQUFTLENBQUNyd0U7UUFDNUIsSUFBSSxDQUFDLENBQUN3dkMsS0FBSyxDQUFDNTdDLEdBQUcsQ0FBQ3NDLEtBQUs4WTtRQUNyQixJQUFJLENBQUMsQ0FBQ3dnQyxLQUFLLENBQUM1N0MsR0FBRyxDQUFDNkMsS0FBS3VZO1FBQ3JCLE1BQU1qVixTQUFTLElBQUksQ0FBQyxDQUFDMDJFLFlBQVksQ0FBQ3p3RTtRQUNsQyxJQUFJLENBQUMsQ0FBQ2d4RSw2QkFBNkIsQ0FBQ0QsUUFBUWgzRTtRQUM1QyxPQUFPaVY7SUFDVDtJQUNBKy9ELG9CQUFvQjc0RSxHQUFHLEVBQUU7UUFDdkIsSUFBSTVKLFFBQVEsSUFBSSxDQUFDLENBQUNrakQsS0FBSyxDQUFDbGlELEdBQUcsQ0FBQzRJLE9BQU87UUFDbkMsSUFBSTVKLE9BQU87WUFDVCxPQUFPQTtRQUNUO1FBQ0EsSUFBSXlrRixRQUFRdDZFO1FBQ1osSUFBSVAsS0FBSztZQUNQLENBQUM2NkUsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDbEIsWUFBWSxDQUFDO2dCQUFDMzVFO2FBQUk7WUFDbkNPLE1BQU0sQ0FBQyxXQUFXLEVBQUVzNkUsT0FBTyxDQUFDO1FBQzlCLE9BQU87WUFDTHQ2RSxNQUFNO1FBQ1I7UUFDQW5LLFFBQVEsSUFBSSxDQUFDLENBQUNrakQsS0FBSyxDQUFDbGlELEdBQUcsQ0FBQ21KO1FBQ3hCLElBQUluSyxPQUFPO1lBQ1QsSUFBSSxDQUFDLENBQUNrakQsS0FBSyxDQUFDNTdDLEdBQUcsQ0FBQ3NDLEtBQUs1SjtZQUNyQixPQUFPQTtRQUNUO1FBQ0EsTUFBTTBULEtBQUssQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUN3dkUsS0FBSyxDQUFDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxDQUFDeHZFLEVBQUUsR0FBRyxDQUFDO1FBQzFELE1BQU1nUCxNQUFNLElBQUksQ0FBQyxDQUFDcWhFLFNBQVMsQ0FBQ3J3RTtRQUM1QixJQUFJLENBQUMsQ0FBQ3d2QyxLQUFLLENBQUM1N0MsR0FBRyxDQUFDc0MsS0FBSzhZO1FBQ3JCLElBQUksQ0FBQyxDQUFDd2dDLEtBQUssQ0FBQzU3QyxHQUFHLENBQUM2QyxLQUFLdVk7UUFDckIsTUFBTWpWLFNBQVMsSUFBSSxDQUFDLENBQUMwMkUsWUFBWSxDQUFDendFO1FBQ2xDLElBQUksQ0FBQyxDQUFDaXhFLHVCQUF1QixDQUFDbDNFO1FBQzlCLElBQUk3RCxLQUFLO1lBQ1AsSUFBSSxDQUFDLENBQUM4NkUsNkJBQTZCLENBQUNELFFBQVFoM0U7UUFDOUM7UUFDQSxPQUFPaVY7SUFDVDtJQUNBZ2dFLHNCQUFzQkMsVUFBVSxFQUFFTCxPQUFPLEVBQUVDLE9BQU8sRUFBRUssVUFBVSxFQUFFQyxVQUFVLEVBQUU7UUFDMUUsTUFBTTE0RSxNQUFNLENBQUMsRUFBRW00RSxRQUFRLENBQUMsRUFBRUMsUUFBUSxDQUFDLEVBQUVLLFdBQVcsQ0FBQyxFQUFFQyxXQUFXLENBQUM7UUFDL0QsSUFBSTFoRCxPQUFPLElBQUksQ0FBQyxDQUFDaWlELFFBQVEsQ0FBQ3BpRixHQUFHLENBQUMyaEY7UUFDOUIsSUFBSXhoRCxNQUFNaDNCLFFBQVFBLEtBQUs7WUFDckIsT0FBT2czQixLQUFLemUsR0FBRztRQUNqQjtRQUNBLElBQUl5ZSxNQUFNO1lBQ1JBLEtBQUsxekIsTUFBTSxFQUFFMEc7WUFDYmd0QixLQUFLaDNCLEdBQUcsR0FBR0E7WUFDWGczQixLQUFLemUsR0FBRyxHQUFHO1lBQ1h5ZSxLQUFLMXpCLE1BQU0sR0FBRztRQUNoQixPQUFPO1lBQ0wwekIsT0FBTztnQkFDTGgzQjtnQkFDQXVZLEtBQUs7Z0JBQ0xqVixRQUFRO1lBQ1Y7WUFDQSxJQUFJLENBQUMsQ0FBQzIxRSxRQUFRLENBQUM5N0UsR0FBRyxDQUFDcTdFLFlBQVl4aEQ7UUFDakM7UUFDQSxJQUFJLENBQUNtaEQsV0FBVyxDQUFDQyxTQUFTO1lBQ3hCLE9BQU9waEQsS0FBS3plLEdBQUc7UUFDakI7UUFDQSxNQUFNLENBQUMyaEUsT0FBT0MsTUFBTSxHQUFHO1lBQUNoQztZQUFTQztTQUFRLENBQUMzNEUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDa3VDLE1BQU0sQ0FBQ2h6QyxJQUFJLENBQUMsSUFBSTtRQUNwRSxJQUFJOC9FLFNBQVNyL0UsS0FBSzYxQyxLQUFLLENBQUMsU0FBU2lwQyxLQUFLLENBQUMsRUFBRSxHQUFHLFNBQVNBLEtBQUssQ0FBQyxFQUFFLEdBQUcsU0FBU0EsS0FBSyxDQUFDLEVBQUU7UUFDakYsSUFBSVEsU0FBU3QvRSxLQUFLNjFDLEtBQUssQ0FBQyxTQUFTa3BDLEtBQUssQ0FBQyxFQUFFLEdBQUcsU0FBU0EsS0FBSyxDQUFDLEVBQUUsR0FBRyxTQUFTQSxLQUFLLENBQUMsRUFBRTtRQUNqRixJQUFJLENBQUNRLFVBQVVDLFNBQVMsR0FBRztZQUFDbkM7WUFBWUM7U0FBVyxDQUFDajVFLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQ2t1QyxNQUFNLENBQUNoekMsSUFBSSxDQUFDLElBQUk7UUFDOUUsSUFBSSsvRSxTQUFTRCxRQUFRO1lBQ25CLENBQUNBLFFBQVFDLFFBQVFDLFVBQVVDLFNBQVMsR0FBRztnQkFBQ0Y7Z0JBQVFEO2dCQUFRRztnQkFBVUQ7YUFBUztRQUM3RTtRQUNBLElBQUksQ0FBQyxDQUFDekIsSUFBSSxDQUFDNTJFLEtBQUssQ0FBQ3NyQyxLQUFLLEdBQUc7UUFDekIsTUFBTXlzQyxXQUFXLENBQUNRLElBQUlDLElBQUl0L0U7WUFDeEIsTUFBTXluQyxNQUFNLElBQUl0OEIsTUFBTTtZQUN0QixNQUFNOU0sT0FBTyxDQUFDNmdGLFNBQVNELE1BQUssSUFBS2ovRTtZQUNqQyxNQUFNdS9FLFdBQVdGLEtBQUs7WUFDdEIsTUFBTUcsVUFBVSxDQUFDRixLQUFLRCxFQUFDLElBQU0sT0FBTXIvRSxDQUFBQTtZQUNuQyxJQUFJeS9FLE9BQU87WUFDWCxJQUFLLElBQUkxaEYsSUFBSSxHQUFHQSxLQUFLaUMsR0FBR2pDLElBQUs7Z0JBQzNCLE1BQU0wVixJQUFJN1QsS0FBSzYxQyxLQUFLLENBQUN3cEMsU0FBU2xoRixJQUFJTTtnQkFDbEMsTUFBTWhFLFFBQVFrbEYsV0FBV3hoRixJQUFJeWhGO2dCQUM3QixJQUFLLElBQUlueUUsSUFBSW95RSxNQUFNcHlFLEtBQUtvRyxHQUFHcEcsSUFBSztvQkFDOUJvNkIsR0FBRyxDQUFDcDZCLEVBQUUsR0FBR2hUO2dCQUNYO2dCQUNBb2xGLE9BQU9oc0UsSUFBSTtZQUNiO1lBQ0EsSUFBSyxJQUFJMVYsSUFBSTBoRixNQUFNMWhGLElBQUksS0FBS0EsSUFBSztnQkFDL0IwcEMsR0FBRyxDQUFDMXBDLEVBQUUsR0FBRzBwQyxHQUFHLENBQUNnNEMsT0FBTyxFQUFFO1lBQ3hCO1lBQ0EsT0FBT2g0QyxJQUFJNXJDLElBQUksQ0FBQztRQUNsQjtRQUNBLE1BQU1rUyxLQUFLLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDd3ZFLEtBQUssQ0FBQyxLQUFLLEVBQUVQLFdBQVcsT0FBTyxDQUFDO1FBQ3RELE1BQU1sMUUsU0FBUzB6QixLQUFLMXpCLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQzAyRSxZQUFZLENBQUN6d0U7UUFDaEQsSUFBSSxDQUFDLENBQUM2d0UsaUJBQWlCLENBQUM5MkU7UUFDeEIsSUFBSSxDQUFDLENBQUMyMkUsd0JBQXdCLENBQUNJLFNBQVNNLFFBQVEsQ0FBQyxFQUFFLEVBQUVDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsSUFBSVAsU0FBU00sUUFBUSxDQUFDLEVBQUUsRUFBRUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxJQUFJUCxTQUFTTSxRQUFRLENBQUMsRUFBRSxFQUFFQyxRQUFRLENBQUMsRUFBRSxFQUFFLElBQUl0M0U7UUFDcEowekIsS0FBS3plLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQ3FoRSxTQUFTLENBQUNyd0U7UUFDM0IsT0FBT3l0QixLQUFLemUsR0FBRztJQUNqQjtJQUNBbS9CLFFBQVFpaEMsVUFBVSxLQUFLLEVBQUU7UUFDdkIsSUFBSUEsV0FBVyxJQUFJLENBQUMsQ0FBQ0ssU0FBUyxFQUFFcHZFLE1BQU07WUFDcEM7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDa3ZFLEtBQUssRUFBRWxrQixXQUFXQSxXQUFXNXFEO1FBQ25DLElBQUksQ0FBQyxDQUFDOHVFLEtBQUssR0FBRztRQUNkLElBQUksQ0FBQyxDQUFDRCxNQUFNLEVBQUV6OEQ7UUFDZCxJQUFJLENBQUMsQ0FBQ3k4RCxNQUFNLEdBQUc7UUFDZixJQUFJLENBQUMsQ0FBQ0csU0FBUyxFQUFFNThEO1FBQ2pCLElBQUksQ0FBQyxDQUFDNDhELFNBQVMsR0FBRztRQUNsQixJQUFJLENBQUMsQ0FBQ3p2RSxFQUFFLEdBQUc7SUFDYjtJQUNBLENBQUNpeEUsdUJBQXVCLENBQUNsM0UsTUFBTTtRQUM3QixNQUFNNDNFLGdCQUFnQixJQUFJLENBQUMsQ0FBQ3Y0RSxRQUFRLENBQUMya0MsZUFBZSxDQUFDSSxRQUFRO1FBQzdEd3pDLGNBQWMzMUMsWUFBWSxDQUFDLFFBQVE7UUFDbkMyMUMsY0FBYzMxQyxZQUFZLENBQUMsVUFBVTtRQUNyQ2ppQyxPQUFPb0wsTUFBTSxDQUFDd3NFO0lBQ2hCO0lBQ0EsQ0FBQ2QsaUJBQWlCLENBQUM5MkUsTUFBTTtRQUN2QixNQUFNNDNFLGdCQUFnQixJQUFJLENBQUMsQ0FBQ3Y0RSxRQUFRLENBQUMya0MsZUFBZSxDQUFDSSxRQUFRO1FBQzdEd3pDLGNBQWMzMUMsWUFBWSxDQUFDLFFBQVE7UUFDbkMyMUMsY0FBYzMxQyxZQUFZLENBQUMsVUFBVTtRQUNyQ2ppQyxPQUFPb0wsTUFBTSxDQUFDd3NFO0lBQ2hCO0lBQ0EsQ0FBQ2xCLFlBQVksQ0FBQ3p3RSxFQUFFO1FBQ2QsTUFBTWpHLFNBQVMsSUFBSSxDQUFDLENBQUNYLFFBQVEsQ0FBQzJrQyxlQUFlLENBQUNJLFFBQVE7UUFDdERwa0MsT0FBT2lpQyxZQUFZLENBQUMsK0JBQStCO1FBQ25EamlDLE9BQU9paUMsWUFBWSxDQUFDLE1BQU1oOEI7UUFDMUIsSUFBSSxDQUFDLENBQUMydkUsSUFBSSxDQUFDeHFFLE1BQU0sQ0FBQ3BMO1FBQ2xCLE9BQU9BO0lBQ1Q7SUFDQSxDQUFDNjNFLFlBQVksQ0FBQ0MsbUJBQW1CLEVBQUV0aUUsSUFBSSxFQUFFd2dFLEtBQUs7UUFDNUMsTUFBTStCLFNBQVMsSUFBSSxDQUFDLENBQUMxNEUsUUFBUSxDQUFDMmtDLGVBQWUsQ0FBQ0ksUUFBUTV1QjtRQUN0RHVpRSxPQUFPOTFDLFlBQVksQ0FBQyxRQUFRO1FBQzVCODFDLE9BQU85MUMsWUFBWSxDQUFDLGVBQWUrekM7UUFDbkM4QixvQkFBb0Ixc0UsTUFBTSxDQUFDMnNFO0lBQzdCO0lBQ0EsQ0FBQ3BCLHdCQUF3QixDQUFDcUIsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sRUFBRWw0RSxNQUFNO1FBQ3RELE1BQU04M0Usc0JBQXNCLElBQUksQ0FBQyxDQUFDejRFLFFBQVEsQ0FBQzJrQyxlQUFlLENBQUNJLFFBQVE7UUFDbkVwa0MsT0FBT29MLE1BQU0sQ0FBQzBzRTtRQUNkLElBQUksQ0FBQyxDQUFDRCxZQUFZLENBQUNDLHFCQUFxQixXQUFXRTtRQUNuRCxJQUFJLENBQUMsQ0FBQ0gsWUFBWSxDQUFDQyxxQkFBcUIsV0FBV0c7UUFDbkQsSUFBSSxDQUFDLENBQUNKLFlBQVksQ0FBQ0MscUJBQXFCLFdBQVdJO0lBQ3JEO0lBQ0EsQ0FBQ2pCLDZCQUE2QixDQUFDa0IsTUFBTSxFQUFFbjRFLE1BQU07UUFDM0MsTUFBTTgzRSxzQkFBc0IsSUFBSSxDQUFDLENBQUN6NEUsUUFBUSxDQUFDMmtDLGVBQWUsQ0FBQ0ksUUFBUTtRQUNuRXBrQyxPQUFPb0wsTUFBTSxDQUFDMHNFO1FBQ2QsSUFBSSxDQUFDLENBQUNELFlBQVksQ0FBQ0MscUJBQXFCLFdBQVdLO0lBQ3JEO0lBQ0EsQ0FBQzl0QyxNQUFNLENBQUNDLEtBQUs7UUFDWCxJQUFJLENBQUMsQ0FBQ3NyQyxJQUFJLENBQUM1MkUsS0FBSyxDQUFDc3JDLEtBQUssR0FBR0E7UUFDekIsT0FBT0QsT0FBT1UsaUJBQWlCLElBQUksQ0FBQyxDQUFDNnFDLElBQUksRUFBRTFiLGdCQUFnQixDQUFDO0lBQzlEO0FBQ0Y7RUFFQyw2Q0FBNkM7QUFXOUMsTUFBTWtlO0lBQ0oxakYsWUFBWSxFQUNWMC9CLFVBQVUsSUFBSSxFQUNmLENBQUU7UUFDRCxJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDakI7SUFDQSxNQUFNd1EsTUFBTSxFQUNWZ0QsUUFBUSxFQUNULEVBQUU7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDeFQsT0FBTyxFQUFFO1lBQ2pCLE1BQU0sSUFBSTNrQixNQUFNO1FBQ2xCO1FBQ0EsSUFBSSxDQUFDbTRCLFVBQVU7WUFDYixNQUFNLElBQUluNEIsTUFBTTtRQUNsQjtRQUNBLE1BQU13RixNQUFNLENBQUMsRUFBRSxJQUFJLENBQUNtZixPQUFPLENBQUMsRUFBRXdULFNBQVMsQ0FBQztRQUN4QyxPQUFPLElBQUksQ0FBQ3lzQyxNQUFNLENBQUNwL0QsS0FBS3MvRCxLQUFLLENBQUMvekMsQ0FBQUE7WUFDNUIsTUFBTSxJQUFJL3dCLE1BQU0sQ0FBQyw2QkFBNkIsRUFBRXdGLElBQUksQ0FBQztRQUN2RDtJQUNGO0lBQ0EsTUFBTW8vRCxPQUFPcC9ELEdBQUcsRUFBRTtRQUNoQjZlLFlBQVk7SUFDZDtBQUNGO0FBQ0EsTUFBTXVrRCxtQ0FBbUNEO0lBQ3ZDLE1BQU0vRCxPQUFPcC9ELEdBQUcsRUFBRTtRQUNoQixNQUFNcFQsT0FBTyxNQUFNMmlDLFVBQVV2dkIsS0FBSztRQUNsQyxPQUFPLElBQUlwZixXQUFXZ007SUFDeEI7QUFDRjtFQUVDLGdDQUFnQztBQVdqQyxNQUFNeTJFO0lBQ0o1akYsWUFBWSxFQUNWMC9CLFVBQVUsSUFBSSxFQUNmLENBQUU7UUFDRCxJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDakI7SUFDQSxNQUFNd1EsTUFBTSxFQUNWZ0QsUUFBUSxFQUNULEVBQUU7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDeFQsT0FBTyxFQUFFO1lBQ2pCLE1BQU0sSUFBSTNrQixNQUFNO1FBQ2xCO1FBQ0EsSUFBSSxDQUFDbTRCLFVBQVU7WUFDYixNQUFNLElBQUluNEIsTUFBTTtRQUNsQjtRQUNBLE1BQU13RixNQUFNLENBQUMsRUFBRSxJQUFJLENBQUNtZixPQUFPLENBQUMsRUFBRXdULFNBQVMsQ0FBQztRQUN4QyxPQUFPLElBQUksQ0FBQ3lzQyxNQUFNLENBQUNwL0QsS0FBS3MvRCxLQUFLLENBQUMvekMsQ0FBQUE7WUFDNUIsTUFBTSxJQUFJL3dCLE1BQU0sQ0FBQyw2QkFBNkIsRUFBRXdGLElBQUksQ0FBQztRQUN2RDtJQUNGO0lBQ0EsTUFBTW8vRCxPQUFPcC9ELEdBQUcsRUFBRTtRQUNoQjZlLFlBQVk7SUFDZDtBQUNGO0FBQ0EsTUFBTXlrRCx1QkFBdUJEO0lBQzNCLE1BQU1qRSxPQUFPcC9ELEdBQUcsRUFBRTtRQUNoQixNQUFNcFQsT0FBTyxNQUFNMmlDLFVBQVV2dkIsS0FBSztRQUNsQyxPQUFPLElBQUlwZixXQUFXZ007SUFDeEI7QUFDRjtFQUVDLDhCQUE4QjtBQWUvQixJQUFJa2lCLFVBQVU7SUFDWixJQUFJNnhCO0lBQ0osSUFBSTtRQUNGLE1BQU00aUMsVUFBVTN2RSxRQUFRa1gsZ0JBQWdCLENBQUMsVUFBVTA0RCxhQUFhLENBQUMsa0dBQWU7UUFDaEYsSUFBSTtZQUNGN2lDLFNBQVM0aUMsUUFBUTtRQUNuQixFQUFFLE9BQU92N0MsSUFBSTtZQUNYcEosS0FBSyxDQUFDLHdDQUF3QyxFQUFFb0osR0FBRyxFQUFFLENBQUM7UUFDeEQ7SUFDRixFQUFFLE9BQU9BLElBQUk7UUFDWHBKLEtBQUssQ0FBQyx5Q0FBeUMsRUFBRW9KLEdBQUcsRUFBRSxDQUFDO0lBQ3pEO0lBQ0EsSUFBSSxDQUFDeG5DLFdBQVdpakYsU0FBUyxFQUFFO1FBQ3pCLElBQUk5aUMsUUFBUThpQyxXQUFXO1lBQ3JCampGLFdBQVdpakYsU0FBUyxHQUFHOWlDLE9BQU84aUMsU0FBUztRQUN6QyxPQUFPO1lBQ0w3a0QsS0FBSztRQUNQO0lBQ0Y7SUFDQSxJQUFJLENBQUNwK0IsV0FBV2tqRixTQUFTLEVBQUU7UUFDekIsSUFBSS9pQyxRQUFRK2lDLFdBQVc7WUFDckJsakYsV0FBV2tqRixTQUFTLEdBQUcvaUMsT0FBTytpQyxTQUFTO1FBQ3pDLE9BQU87WUFDTDlrRCxLQUFLO1FBQ1A7SUFDRjtJQUNBLElBQUksQ0FBQ3ArQixXQUFXbzRFLE1BQU0sRUFBRTtRQUN0QixJQUFJajRCLFFBQVFpNEIsUUFBUTtZQUNsQnA0RSxXQUFXbzRFLE1BQU0sR0FBR2o0QixPQUFPaTRCLE1BQU07UUFDbkMsT0FBTztZQUNMaDZDLEtBQUs7UUFDUDtJQUNGO0lBQ0EsSUFBSSxDQUFDcCtCLFdBQVdxTixTQUFTLEVBQUU4MUUsVUFBVTtRQUNuQ25qRixXQUFXcU4sU0FBUyxHQUFHO1lBQ3JCODFFLFVBQVU7WUFDVjdoRCxVQUFVO1lBQ1ZoMEIsV0FBVztRQUNiO0lBQ0Y7QUFDRjtBQUNBLGVBQWU4MUUscUJBQXFCNWpFLEdBQUc7SUFDckMsTUFBTTZqRSxLQUFLandFLFFBQVFrWCxnQkFBZ0IsQ0FBQztJQUNwQyxNQUFNbGUsT0FBTyxNQUFNaTNFLEdBQUc5dEIsUUFBUSxDQUFDK3RCLFFBQVEsQ0FBQzlqRTtJQUN4QyxPQUFPLElBQUlwZixXQUFXZ007QUFDeEI7QUFDQSxNQUFNbTNFLDBCQUEwQnRFO0FBQW1CO0FBQ25ELE1BQU11RSwwQkFBMEJwRjtJQUM5QkUsY0FBY3R0QyxLQUFLLEVBQUVDLE1BQU0sRUFBRTtRQUMzQixNQUFNOHhDLFVBQVUzdkUsUUFBUWtYLGdCQUFnQixDQUFDLFVBQVUwNEQsYUFBYSxDQUFDLGtHQUFlO1FBQ2hGLE1BQU03aUMsU0FBUzRpQyxRQUFRO1FBQ3ZCLE9BQU81aUMsT0FBT3NqQyxZQUFZLENBQUN6eUMsT0FBT0M7SUFDcEM7QUFDRjtBQUNBLE1BQU15eUMsOEJBQThCaEY7SUFDbEMsTUFBTUUsT0FBT3AvRCxHQUFHLEVBQUU7UUFDaEIsT0FBTzRqRSxxQkFBcUI1akU7SUFDOUI7QUFDRjtBQUNBLE1BQU1ta0Usb0NBQW9DaEI7SUFDeEMsTUFBTS9ELE9BQU9wL0QsR0FBRyxFQUFFO1FBQ2hCLE9BQU80akUscUJBQXFCNWpFO0lBQzlCO0FBQ0Y7QUFDQSxNQUFNb2tFLHdCQUF3QmY7SUFDNUIsTUFBTWpFLE9BQU9wL0QsR0FBRyxFQUFFO1FBQ2hCLE9BQU80akUscUJBQXFCNWpFO0lBQzlCO0FBQ0Y7QUFFQSwwRUFBMEU7QUFDMUUsSUFBSXFrRSx1QkFBdUIvb0YsaUNBQW1CQSxDQUFDO0VBQzlDLDZDQUE2QztBQW9COUMsTUFBTWdwRiwwQkFBMEI7QUFDaEMsTUFBTSxFQUNKeGhGLEtBQUssRUFDTEYsSUFBSSxFQUNMLEdBQUdDO0FBQ0osU0FBUzBoRixXQUFXdjhELEtBQUssRUFBRXBjLEtBQUssRUFBRTQ0RSxJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJO0lBQ3REMzhELEtBQUssQ0FBQ3BjLFFBQVEsSUFBSSxFQUFFLEdBQUcvSSxLQUFLbUYsR0FBRyxDQUFDZ2dCLEtBQUssQ0FBQ3BjLFFBQVEsSUFBSSxFQUFFLEVBQUU0NEU7SUFDdER4OEQsS0FBSyxDQUFDcGMsUUFBUSxJQUFJLEVBQUUsR0FBRy9JLEtBQUttRixHQUFHLENBQUNnZ0IsS0FBSyxDQUFDcGMsUUFBUSxJQUFJLEVBQUUsRUFBRTY0RTtJQUN0RHo4RCxLQUFLLENBQUNwYyxRQUFRLElBQUksRUFBRSxHQUFHL0ksS0FBSzRQLEdBQUcsQ0FBQ3VWLEtBQUssQ0FBQ3BjLFFBQVEsSUFBSSxFQUFFLEVBQUU4NEU7SUFDdEQxOEQsS0FBSyxDQUFDcGMsUUFBUSxJQUFJLEVBQUUsR0FBRy9JLEtBQUs0UCxHQUFHLENBQUN1VixLQUFLLENBQUNwYyxRQUFRLElBQUksRUFBRSxFQUFFKzRFO0FBQ3hEO0FBQ0EsTUFBTUMsYUFBYSxJQUFJdnNFLFlBQVksSUFBSXpYLFdBQVc7SUFBQztJQUFLO0lBQUs7SUFBRztDQUFFLEVBQUVHLE1BQU0sQ0FBQyxDQUFDLEVBQUU7QUFDOUUsTUFBTThqRjtJQUNKLENBQUNDLE1BQU0sQ0FBQztJQUNSLENBQUNDLE1BQU0sQ0FBQztJQUNSdGxGLFlBQVlxbEYsTUFBTSxFQUFFQyxNQUFNLENBQUU7UUFDMUIsSUFBSSxDQUFDLENBQUNELE1BQU0sR0FBR0E7UUFDZixJQUFJLENBQUMsQ0FBQ0MsTUFBTSxHQUFHQTtJQUNqQjtJQUNBLElBQUkxb0YsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLENBQUN5b0YsTUFBTSxDQUFDem9GLE1BQU07SUFDNUI7SUFDQWt0RCxRQUFRdm9ELENBQUMsRUFBRTtRQUNULE9BQU8sSUFBSSxDQUFDLENBQUM4akYsTUFBTSxDQUFDOWpGLEVBQUUsS0FBSzRqRjtJQUM3QjtJQUNBSixLQUFLeGpGLENBQUMsRUFBRTtRQUNOLE9BQU8sSUFBSSxDQUFDLENBQUMrakYsTUFBTSxDQUFDL2pGLElBQUksSUFBSSxFQUFFLEdBQUc7SUFDbkM7SUFDQXlqRixLQUFLempGLENBQUMsRUFBRTtRQUNOLE9BQU8sSUFBSSxDQUFDLENBQUMrakYsTUFBTSxDQUFDL2pGLElBQUksSUFBSSxFQUFFLEdBQUc7SUFDbkM7SUFDQTBqRixLQUFLMWpGLENBQUMsRUFBRTtRQUNOLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQytqRixNQUFNLENBQUMvakYsSUFBSSxJQUFJLEVBQUUsR0FBRyxLQUFLO0lBQ3pDO0lBQ0EyakYsS0FBSzNqRixDQUFDLEVBQUU7UUFDTixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMrakYsTUFBTSxDQUFDL2pGLElBQUksSUFBSSxFQUFFLEdBQUcsS0FBSztJQUN6QztBQUNGO0FBQ0EsTUFBTWdrRixzQkFBc0IsQ0FBQzk5RSxLQUFLTztJQUNoQyxJQUFJLENBQUNQLEtBQUs7UUFDUixPQUFPdEg7SUFDVDtJQUNBLElBQUl0QyxRQUFRNEosSUFBSTVJLEdBQUcsQ0FBQ21KO0lBQ3BCLElBQUksQ0FBQ25LLE9BQU87UUFDVkEsUUFBUTtZQUNOMm5GLGNBQWMsSUFBSTV3RTtZQUNsQjZ3RSxzQkFBc0I7UUFDeEI7UUFDQWgrRSxJQUFJdEMsR0FBRyxDQUFDNkMsS0FBS25LO0lBQ2Y7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsTUFBTTZuRjtJQUNKLENBQUN4akUsTUFBTSxDQUVMO0lBQ0YsQ0FBQ3lqRSxXQUFXLENBTVY7SUFDRixDQUFDQyxpQkFBaUIsQ0FBYTtJQUMvQixDQUFDQyxVQUFVLENBQU07SUFDakIsQ0FBQ0Msa0JBQWtCLENBQU07SUFDekIsQ0FBQ0Msa0JBQWtCLENBQXdCO0lBQzNDLENBQUNDLE9BQU8sQ0FBOEM7SUFDdEQsQ0FBQ0MsV0FBVyxDQUFnRTtJQUM1RSxDQUFDQyxjQUFjLENBQU07SUFDckIsQ0FBQ0MsbUJBQW1CLENBQWE7SUFDakMsQ0FBQ0MsVUFBVSxDQUFhO0lBQ3hCLENBQUNDLG1CQUFtQixDQUFhO0lBQ2pDLENBQUNDLFdBQVcsQ0FBQztJQUNiLENBQUNDLFlBQVksQ0FBQztJQUNkLENBQUNDLFlBQVksQ0FBQztJQUNkLENBQUNuQixNQUFNLENBQUM7SUFDUixDQUFDb0IsYUFBYSxDQUFDO0lBQ2Z6bUYsWUFBWWtoRCxNQUFNLEVBQUV3bEMsZUFBZSxFQUFFQyxzQkFBc0IsS0FBSyxDQUFFO2FBekJsRSxDQUFDemtFLE1BQU0sR0FBRztZQUNSdFQsV0FBVztRQUNiO2FBQ0EsQ0FBQysyRSxXQUFXLEdBQUc7WUFDYi8yRSxXQUFXO1lBQ1gycUIsV0FBVyxFQUFFO1lBQ2I0QixVQUFVLEVBQUU7WUFDWnlyRCxjQUFjLEVBQUU7WUFDaEIsQ0FBQy9CLHdCQUF3QixFQUFFLEVBQUU7UUFDL0I7YUFDQSxDQUFDZSxpQkFBaUIsR0FBRyxJQUFJOTdDO2FBQ3pCLENBQUMrN0MsVUFBVSxHQUFHLEVBQUU7YUFDaEIsQ0FBQ0Msa0JBQWtCLEdBQUcsRUFBRTthQUN4QixDQUFDQyxrQkFBa0IsR0FBRztZQUFDO2dCQUFDO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2FBQUU7U0FBQzthQUMxQyxDQUFDQyxPQUFPLEdBQUc7WUFBQyxDQUFDaDNFO1lBQVUsQ0FBQ0E7WUFBVUE7WUFBVUE7U0FBUzthQUNyRCxDQUFDaTNFLFdBQVcsR0FBRyxJQUFJbnRFLGFBQWE7WUFBQzlKO1lBQVVBO1lBQVUsQ0FBQ0E7WUFBVSxDQUFDQTtTQUFTO2FBQzFFLENBQUNrM0UsY0FBYyxHQUFHLENBQUM7YUFDbkIsQ0FBQ0MsbUJBQW1CLEdBQUcsSUFBSXZ4RTthQUMzQixDQUFDd3hFLFVBQVUsR0FBRyxJQUFJdDhDO2FBQ2xCLENBQUN1OEMsbUJBQW1CLEdBQUcsSUFBSXY4QztRQU96QixJQUFJLENBQUMsQ0FBQ3c4QyxXQUFXLEdBQUdwbEMsT0FBT25QLEtBQUs7UUFDaEMsSUFBSSxDQUFDLENBQUN3MEMsWUFBWSxHQUFHcmxDLE9BQU9sUCxNQUFNO1FBQ2xDLElBQUksQ0FBQyxDQUFDNjBDLGdCQUFnQixDQUFDSDtRQUN2QixJQUFJQyxxQkFBcUI7WUFDdkIsSUFBSSxDQUFDLENBQUNGLGFBQWEsR0FBRyxJQUFJMzhDO1FBQzVCO0lBQ0Y7SUFDQWc5QyxvQkFBb0JKLGVBQWUsRUFBRTtRQUNuQyxJQUFJQSxtQkFBbUIsSUFBSSxDQUFDLENBQUNyQixNQUFNLENBQUN6b0YsTUFBTSxFQUFFO1lBQzFDLElBQUksQ0FBQyxDQUFDaXFGLGdCQUFnQixDQUFDSCxpQkFBaUIsSUFBSSxDQUFDLENBQUNyQixNQUFNO1FBQ3REO0lBQ0Y7SUFDQSxDQUFDd0IsZ0JBQWdCLENBQUNILGVBQWUsRUFBRUssU0FBUztRQUMxQyxNQUFNemxGLFNBQVMsSUFBSTRFLFlBQVl3Z0Ysa0JBQWtCO1FBQ2pELElBQUksQ0FBQyxDQUFDRixZQUFZLEdBQUcsSUFBSTN1RSxrQkFBa0J2VztRQUMzQyxJQUFJLENBQUMsQ0FBQytqRixNQUFNLEdBQUcsSUFBSXpzRSxZQUFZdFg7UUFDL0IsSUFBSXlsRixhQUFhQSxVQUFVbnFGLE1BQU0sR0FBRyxHQUFHO1lBQ3JDLElBQUksQ0FBQyxDQUFDeW9GLE1BQU0sQ0FBQ2xnRixHQUFHLENBQUM0aEY7WUFDakIsSUFBSSxDQUFDLENBQUMxQixNQUFNLENBQUNwckQsSUFBSSxDQUFDa3JELFlBQVk0QixVQUFVbnFGLE1BQU07UUFDaEQsT0FBTztZQUNMLElBQUksQ0FBQyxDQUFDeW9GLE1BQU0sQ0FBQ3ByRCxJQUFJLENBQUNrckQ7UUFDcEI7SUFDRjtJQUNBOXJELEtBQUsydEQsS0FBSyxFQUFFO1FBQ1YsSUFBSSxDQUFDLENBQUM5a0UsTUFBTSxHQUFHO1lBQ2J0VCxXQUFXLElBQUksQ0FBQyxDQUFDc1QsTUFBTTtRQUN6QjtRQUNBLElBQUksQ0FBQyxDQUFDeWpFLFdBQVcsR0FBRztZQUNsQi8yRSxXQUFXLElBQUksQ0FBQyxDQUFDKzJFLFdBQVc7WUFDNUJwc0QsV0FBVztnQkFDVDNxQixXQUFXLElBQUksQ0FBQyxDQUFDKzJFLFdBQVcsQ0FBQ3BzRCxTQUFTO1lBQ3hDO1lBQ0E0QixVQUFVO2dCQUNSdnNCLFdBQVcsSUFBSSxDQUFDLENBQUMrMkUsV0FBVyxDQUFDeHFELFFBQVE7WUFDdkM7WUFDQXlyRCxjQUFjO2dCQUNaaDRFLFdBQVcsSUFBSSxDQUFDLENBQUMrMkUsV0FBVyxDQUFDaUIsWUFBWTtZQUMzQztZQUNBLENBQUMvQix3QkFBd0IsRUFBRTtnQkFDekJqMkUsV0FBVyxJQUFJLENBQUMsQ0FBQysyRSxXQUFXLENBQUNkLHdCQUF3QjtZQUN2RDtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNtQixPQUFPLEdBQUc7WUFDZHAzRSxXQUFXLElBQUksQ0FBQyxDQUFDbzNFLE9BQU87UUFDMUI7UUFDQSxJQUFJLENBQUMsQ0FBQ0gsVUFBVSxDQUFDaCtFLElBQUksQ0FBQ20vRTtRQUN0QixPQUFPLElBQUk7SUFDYjtJQUNBMXRELFFBQVEwdEQsS0FBSyxFQUFFO1FBQ2IsTUFBTUMsV0FBV2hvRixPQUFPbUosY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDOFosTUFBTTtRQUNuRCxJQUFJK2tFLGFBQWEsTUFBTTtZQUNyQixPQUFPLElBQUk7UUFDYjtRQUNBLElBQUksQ0FBQyxDQUFDL2tFLE1BQU0sR0FBRytrRTtRQUNmLElBQUksQ0FBQyxDQUFDdEIsV0FBVyxHQUFHMW1GLE9BQU9tSixjQUFjLENBQUMsSUFBSSxDQUFDLENBQUN1OUUsV0FBVztRQUMzRCxJQUFJLENBQUMsQ0FBQ0ssT0FBTyxHQUFHL21GLE9BQU9tSixjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM0OUUsT0FBTztRQUNuRCxNQUFNa0IsV0FBVyxJQUFJLENBQUMsQ0FBQ3JCLFVBQVUsQ0FBQzEyQyxHQUFHO1FBQ3JDLElBQUkrM0MsYUFBYS9tRixXQUFXO1lBQzFCb2xGLG9CQUFvQixJQUFJLENBQUMsQ0FBQ2tCLGFBQWEsRUFBRU8sUUFBUXhCLGFBQWEveUUsSUFBSXkwRTtZQUNsRSxJQUFJLENBQUMsQ0FBQzdCLE1BQU0sQ0FBQzJCLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQzNCLE1BQU0sQ0FBQzZCLFNBQVM7UUFDOUM7UUFDQSxPQUFPLElBQUk7SUFDYjtJQUNBQyxpQkFBaUJDLEdBQUcsRUFBRTtRQUNwQixJQUFJLENBQUMsQ0FBQ3ZCLFVBQVUsQ0FBQ2grRSxJQUFJLENBQUN1L0U7UUFDdEIsT0FBTyxJQUFJO0lBQ2I7SUFDQUMsZ0JBQWdCO1FBQ2QsSUFBSSxJQUFJLENBQUMsQ0FBQ3hCLFVBQVUsQ0FBQ2pwRixNQUFNLEtBQUssR0FBRztZQUNqQyxPQUFPO1FBQ1Q7UUFDQSxPQUFPLElBQUksQ0FBQyxDQUFDaXBGLFVBQVUsQ0FBQ2pnRSxFQUFFLENBQUMsQ0FBQztJQUM5QjtJQUNBMGhFLGtCQUFrQk4sS0FBSyxFQUFFO1FBQ3ZCLE1BQU1FLFdBQVcsSUFBSSxDQUFDLENBQUNyQixVQUFVLENBQUMxMkMsR0FBRztRQUNyQyxJQUFJKzNDLGFBQWEvbUYsV0FBVztZQUMxQm9sRixvQkFBb0IsSUFBSSxDQUFDLENBQUNrQixhQUFhLEVBQUVPLFFBQVF4QixhQUFhL3lFLElBQUl5MEU7WUFDbEUsSUFBSSxDQUFDLENBQUM3QixNQUFNLENBQUMyQixNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMzQixNQUFNLENBQUM2QixTQUFTO1FBQzlDO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQWxxRCxtQkFBbUJncUQsS0FBSyxFQUFFO1FBQ3hCLElBQUksQ0FBQyxDQUFDbEIsa0JBQWtCLENBQUNqK0UsSUFBSSxDQUFDbS9FO1FBQzlCLE9BQU8sSUFBSTtJQUNiO0lBQ0E5cEQsaUJBQWlCOHBELEtBQUssRUFBRTtRQUN0QixNQUFNRSxXQUFXLElBQUksQ0FBQyxDQUFDcEIsa0JBQWtCLENBQUMzMkMsR0FBRztRQUM3QyxJQUFJKzNDLGFBQWEvbUYsV0FBVztZQUMxQm9sRixvQkFBb0IsSUFBSSxDQUFDLENBQUNrQixhQUFhLEVBQUVPLFFBQVF4QixhQUFhL3lFLElBQUl5MEU7WUFDbEUsSUFBSSxDQUFDLENBQUM3QixNQUFNLENBQUMyQixNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMzQixNQUFNLENBQUM2QixTQUFTO1FBQzlDO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQUssa0JBQWtCaHhDLEdBQUcsRUFBRTtRQUNyQixJQUFJLENBQUMsQ0FBQ3d2QyxrQkFBa0IsQ0FBQ2wrRSxJQUFJLENBQUNtN0IsS0FBS1UsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUNxaUQsa0JBQWtCLENBQUNuZ0UsRUFBRSxDQUFDLENBQUMsSUFBSTJ3QixJQUFJQyxZQUFZO1FBQ3hHLE9BQU8sSUFBSTtJQUNiO0lBQ0FneEMsbUJBQW1CO1FBQ2pCLElBQUksSUFBSSxDQUFDLENBQUN6QixrQkFBa0IsQ0FBQ25wRixNQUFNLEdBQUcsR0FBRztZQUN2QyxJQUFJLENBQUMsQ0FBQ21wRixrQkFBa0IsQ0FBQzUyQyxHQUFHO1FBQzlCO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQXM0QyxpQkFBaUIvbkYsSUFBSSxFQUFFMG5GLEdBQUcsRUFBRTtRQUMxQixJQUFJLENBQUMsQ0FBQ2xsRSxNQUFNLENBQUN4aUIsS0FBSyxHQUFHMG5GO1FBQ3JCLE9BQU8sSUFBSTtJQUNiO0lBQ0FNLHNCQUFzQmhvRixJQUFJLEVBQUUwbkYsR0FBRyxFQUFFO1FBQy9CLElBQUksQ0FBQyxDQUFDekIsV0FBVyxDQUFDam1GLEtBQUssQ0FBQ21JLElBQUksQ0FBQ3UvRTtRQUM3QixPQUFPLElBQUk7SUFDYjtJQUNBTyxxQkFBcUJqb0YsSUFBSSxFQUFFMG5GLEdBQUcsRUFBRTtRQUM5QixJQUFJLENBQUMsQ0FBQ3pCLFdBQVcsQ0FBQ2ptRixLQUFLLENBQUM5QyxNQUFNLEdBQUc7UUFDakMsT0FBTyxJQUFJO0lBQ2I7SUFDQWdyRixnQkFBZ0Jsb0YsSUFBSSxFQUFFMG5GLEdBQUcsRUFBRTtRQUN6QixJQUFJLENBQUMsQ0FBQ3hCLGlCQUFpQixDQUFDemdGLEdBQUcsQ0FBQ3pGLE1BQU0wbkY7UUFDbEMsT0FBTyxJQUFJO0lBQ2I7SUFDQVMsMEJBQTBCbm9GLElBQUksRUFBRW9vRixPQUFPLEVBQUVDLFdBQVcsRUFBRTtRQUNwRCxJQUFJLENBQUMsQ0FBQzdsRSxNQUFNLENBQUN4aUIsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDa21GLGlCQUFpQixDQUFDL21GLEdBQUcsQ0FBQ2lwRixZQUFZQztJQUMvRDtJQUNBQyw2QkFBNkJ0b0YsSUFBSSxFQUFFMG5GLEdBQUcsRUFBRTtRQUN0QyxJQUFJLENBQUNNLHFCQUFxQixDQUFDN0MseUJBQXlCdUM7UUFDcEQsT0FBTyxJQUFJO0lBQ2I7SUFDQWEsNENBQTRDbGdGLEtBQUssRUFBRTtRQUNqRCxLQUFLLE1BQU1ySSxRQUFRcUksTUFBTztZQUN4QixJQUFJckksUUFBUSxJQUFJLENBQUMsQ0FBQ3dpQixNQUFNLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQzhsRSw0QkFBNEIsQ0FBQ3RvRixNQUFNLElBQUksQ0FBQyxDQUFDd2lCLE1BQU0sQ0FBQ3hpQixLQUFLO1lBQzVEO1FBQ0Y7UUFDQSxPQUFPLElBQUk7SUFDYjtJQUNBd29GLHVEQUF1RDtRQUNyRCxLQUFLLE1BQU1DLE9BQU8sSUFBSSxDQUFDLENBQUNoQyxtQkFBbUIsQ0FBRTtZQUMzQyxJQUFJLENBQUM2Qiw0QkFBNEIsQ0FBQ25ELHlCQUF5QnNEO1FBQzdEO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQUMsVUFBVWhCLEdBQUcsRUFBRTtRQUNiLElBQUksSUFBSSxDQUFDLENBQUNsQixjQUFjLEtBQUtrQixLQUFLO1lBQ2hDLElBQUksQ0FBQyxDQUFDbEIsY0FBYyxHQUFHa0I7WUFDdkIsSUFBSSxDQUFDLENBQUNuQixXQUFXLENBQUMsRUFBRSxHQUFHajNFO1lBQ3ZCLElBQUksQ0FBQyxDQUFDaTNFLFdBQVcsQ0FBQyxFQUFFLEdBQUdqM0U7WUFDdkIsSUFBSSxDQUFDLENBQUNpM0UsV0FBVyxDQUFDLEVBQUUsR0FBRyxDQUFDajNFO1lBQ3hCLElBQUksQ0FBQyxDQUFDaTNFLFdBQVcsQ0FBQyxFQUFFLEdBQUcsQ0FBQ2ozRTtRQUMxQjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0FxNUUsY0FBY2pCLEdBQUcsRUFBRTd3QyxHQUFHLEVBQUV3dUMsSUFBSSxFQUFFRSxJQUFJLEVBQUVELElBQUksRUFBRUUsSUFBSSxFQUFFO1FBQzlDLE1BQU0zckQsWUFBWXlKLEtBQUtVLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDcWlELGtCQUFrQixDQUFDbmdFLEVBQUUsQ0FBQyxDQUFDLElBQUkyd0IsSUFBSUMsWUFBWTtRQUM1RixNQUFNd3ZDLFVBQVU7WUFBQ2gzRTtZQUFVQTtZQUFVLENBQUNBO1lBQVUsQ0FBQ0E7U0FBUztRQUMxRGcwQixLQUFLeUIsdUJBQXVCLENBQUM7WUFBQ3NnRDtZQUFNQztZQUFNQztZQUFNQztTQUFLLEVBQUUzckQsV0FBV3lzRDtRQUNsRSxNQUFNamhFLGVBQWVpZSxLQUFLbUQsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDNi9DLE9BQU8sRUFBRUE7UUFDbkQsSUFBSWpoRSxjQUFjO1lBQ2hCLElBQUksQ0FBQyxDQUFDaWhFLE9BQU8sQ0FBQyxFQUFFLEdBQUdqaEUsWUFBWSxDQUFDLEVBQUU7WUFDbEMsSUFBSSxDQUFDLENBQUNpaEUsT0FBTyxDQUFDLEVBQUUsR0FBR2poRSxZQUFZLENBQUMsRUFBRTtZQUNsQyxJQUFJLENBQUMsQ0FBQ2loRSxPQUFPLENBQUMsRUFBRSxHQUFHamhFLFlBQVksQ0FBQyxFQUFFO1lBQ2xDLElBQUksQ0FBQyxDQUFDaWhFLE9BQU8sQ0FBQyxFQUFFLEdBQUdqaEUsWUFBWSxDQUFDLEVBQUU7UUFDcEMsT0FBTztZQUNMLElBQUksQ0FBQyxDQUFDaWhFLE9BQU8sQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUNBLE9BQU8sQ0FBQyxFQUFFLEdBQUdoM0U7WUFDdEMsSUFBSSxDQUFDLENBQUNnM0UsT0FBTyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQ0EsT0FBTyxDQUFDLEVBQUUsR0FBRyxDQUFDaDNFO1FBQ3pDO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQXM1RSxXQUFXbEIsR0FBRyxFQUFFN3dDLEdBQUcsRUFBRXd1QyxJQUFJLEVBQUVFLElBQUksRUFBRUQsSUFBSSxFQUFFRSxJQUFJLEVBQUU7UUFDM0MsTUFBTWMsVUFBVSxJQUFJLENBQUMsQ0FBQ0EsT0FBTztRQUM3QixJQUFJQSxPQUFPLENBQUMsRUFBRSxLQUFLaDNFLFVBQVU7WUFDM0IsT0FBTyxJQUFJO1FBQ2I7UUFDQSxNQUFNdXFCLFlBQVl5SixLQUFLVSxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQ3FpRCxrQkFBa0IsQ0FBQ25nRSxFQUFFLENBQUMsQ0FBQyxJQUFJMndCLElBQUlDLFlBQVk7UUFDNUYsSUFBSXd2QyxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUNoM0UsVUFBVTtZQUM1QmcwQixLQUFLeUIsdUJBQXVCLENBQUM7Z0JBQUNzZ0Q7Z0JBQU1DO2dCQUFNQztnQkFBTUM7YUFBSyxFQUFFM3JELFdBQVcsSUFBSSxDQUFDLENBQUMwc0QsV0FBVztZQUNuRixPQUFPLElBQUk7UUFDYjtRQUNBLE1BQU1sTSxPQUFPO1lBQUMvcUU7WUFBVUE7WUFBVSxDQUFDQTtZQUFVLENBQUNBO1NBQVM7UUFDdkRnMEIsS0FBS3lCLHVCQUF1QixDQUFDO1lBQUNzZ0Q7WUFBTUM7WUFBTUM7WUFBTUM7U0FBSyxFQUFFM3JELFdBQVd3Z0Q7UUFDbEUsSUFBSSxDQUFDLENBQUNrTSxXQUFXLENBQUMsRUFBRSxHQUFHN2lGLEtBQUttRixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMwOUUsV0FBVyxDQUFDLEVBQUUsRUFBRTdpRixLQUFLNFAsR0FBRyxDQUFDK21FLElBQUksQ0FBQyxFQUFFLEVBQUVpTSxPQUFPLENBQUMsRUFBRTtRQUNsRixJQUFJLENBQUMsQ0FBQ0MsV0FBVyxDQUFDLEVBQUUsR0FBRzdpRixLQUFLbUYsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDMDlFLFdBQVcsQ0FBQyxFQUFFLEVBQUU3aUYsS0FBSzRQLEdBQUcsQ0FBQyttRSxJQUFJLENBQUMsRUFBRSxFQUFFaU0sT0FBTyxDQUFDLEVBQUU7UUFDbEYsSUFBSSxDQUFDLENBQUNDLFdBQVcsQ0FBQyxFQUFFLEdBQUc3aUYsS0FBSzRQLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQ2l6RSxXQUFXLENBQUMsRUFBRSxFQUFFN2lGLEtBQUttRixHQUFHLENBQUN3eEUsSUFBSSxDQUFDLEVBQUUsRUFBRWlNLE9BQU8sQ0FBQyxFQUFFO1FBQ2xGLElBQUksQ0FBQyxDQUFDQyxXQUFXLENBQUMsRUFBRSxHQUFHN2lGLEtBQUs0UCxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUNpekUsV0FBVyxDQUFDLEVBQUUsRUFBRTdpRixLQUFLbUYsR0FBRyxDQUFDd3hFLElBQUksQ0FBQyxFQUFFLEVBQUVpTSxPQUFPLENBQUMsRUFBRTtRQUNsRixPQUFPLElBQUk7SUFDYjtJQUNBdUMsb0JBQW9CbkIsR0FBRyxFQUFFN3dDLEdBQUcsRUFBRTAvQixJQUFJLEVBQUUva0MsUUFBUSxDQUFDLEVBQUUzdEMsSUFBSSxDQUFDLEVBQUUwTSxJQUFJLENBQUMsRUFBRXU0RSxVQUFVLEVBQUU7UUFDdkUsTUFBTUMsV0FBV3hTLEtBQUs4RCxJQUFJO1FBQzFCLElBQUkyTztRQUNKLElBQUlDO1FBQ0osSUFBSUYsVUFBVTtZQUNaQyxvQkFBb0JELFFBQVEsQ0FBQyxFQUFFLEtBQUtBLFFBQVEsQ0FBQyxFQUFFLElBQUlBLFFBQVEsQ0FBQyxFQUFFLEtBQUtBLFFBQVEsQ0FBQyxFQUFFLElBQUksSUFBSSxDQUFDLENBQUNwQyxtQkFBbUIsQ0FBQ3huRixHQUFHLENBQUNvM0U7WUFDaEgsSUFBSXlTLHNCQUFzQixPQUFPO2dCQUMvQkMsZUFBZTtvQkFBQztvQkFBRztvQkFBRztvQkFBRztpQkFBRTtnQkFDM0IzbEQsS0FBS3lCLHVCQUF1QixDQUFDZ2tELFVBQVV4UyxLQUFLK0QsVUFBVSxFQUFFMk87Z0JBQ3hELElBQUl6M0MsVUFBVSxLQUFLM3RDLE1BQU0sS0FBSzBNLE1BQU0sR0FBRztvQkFDckMreUIsS0FBS00sV0FBVyxDQUFDO3dCQUFDNE47d0JBQU87d0JBQUc7d0JBQUcsQ0FBQ0E7d0JBQU8zdEM7d0JBQUcwTTtxQkFBRSxFQUFFMDRFO2dCQUNoRDtnQkFDQSxJQUFJRCxtQkFBbUI7b0JBQ3JCLE9BQU8sSUFBSSxDQUFDSixVQUFVLENBQUNsQixLQUFLN3dDLEtBQUtveUMsWUFBWSxDQUFDLEVBQUUsRUFBRUEsWUFBWSxDQUFDLEVBQUUsRUFBRUEsWUFBWSxDQUFDLEVBQUUsRUFBRUEsWUFBWSxDQUFDLEVBQUU7Z0JBQ3JHO1lBQ0Y7UUFDRjtRQUNBLElBQUksQ0FBQ0gsWUFBWTtZQUNmLE9BQU8sSUFBSSxDQUFDSSxrQkFBa0IsQ0FBQ3hCO1FBQ2pDO1FBQ0EsTUFBTXlCLFVBQVVMO1FBQ2hCLElBQUlDLFlBQVlFLGdCQUFnQkQsc0JBQXNCdm9GLFdBQVc7WUFDL0R1b0Ysb0JBQW9CQyxZQUFZLENBQUMsRUFBRSxJQUFJcGxGLElBQUlzbEYsUUFBUUMscUJBQXFCLElBQUlILFlBQVksQ0FBQyxFQUFFLElBQUlwbEYsSUFBSXNsRixRQUFRRSxzQkFBc0IsSUFBSUosWUFBWSxDQUFDLEVBQUUsSUFBSTE0RSxJQUFJNDRFLFFBQVFHLHVCQUF1QixJQUFJTCxZQUFZLENBQUMsRUFBRSxJQUFJMTRFLElBQUk0NEUsUUFBUUksd0JBQXdCO1lBQ3RQLElBQUksQ0FBQyxDQUFDNUMsbUJBQW1CLENBQUNsaEYsR0FBRyxDQUFDOHdFLE1BQU15UztZQUNwQyxJQUFJQSxtQkFBbUI7Z0JBQ3JCLE9BQU8sSUFBSSxDQUFDSixVQUFVLENBQUNsQixLQUFLN3dDLEtBQUtveUMsWUFBWSxDQUFDLEVBQUUsRUFBRUEsWUFBWSxDQUFDLEVBQUUsRUFBRUEsWUFBWSxDQUFDLEVBQUUsRUFBRUEsWUFBWSxDQUFDLEVBQUU7WUFDckc7UUFDRjtRQUNBLE9BQU8sSUFBSSxDQUFDTCxVQUFVLENBQUNsQixLQUFLN3dDLEtBQUtoekMsSUFBSXNsRixRQUFRQyxxQkFBcUIsRUFBRXZsRixJQUFJc2xGLFFBQVFFLHNCQUFzQixFQUFFOTRFLElBQUk0NEUsUUFBUUcsdUJBQXVCLEVBQUUvNEUsSUFBSTQ0RSxRQUFRSSx3QkFBd0I7SUFDbkw7SUFDQUwsbUJBQW1CeEIsR0FBRyxFQUFFO1FBQ3RCLElBQUksQ0FBQyxDQUFDbkIsV0FBVyxDQUFDLEVBQUUsR0FBRzdpRixLQUFLNFAsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUNnekUsT0FBTyxDQUFDLEVBQUU7UUFDbkQsSUFBSSxDQUFDLENBQUNDLFdBQVcsQ0FBQyxFQUFFLEdBQUc3aUYsS0FBSzRQLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDZ3pFLE9BQU8sQ0FBQyxFQUFFO1FBQ25ELElBQUksQ0FBQyxDQUFDQyxXQUFXLENBQUMsRUFBRSxHQUFHN2lGLEtBQUttRixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMrOUUsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDTixPQUFPLENBQUMsRUFBRTtRQUNuRSxJQUFJLENBQUMsQ0FBQ0MsV0FBVyxDQUFDLEVBQUUsR0FBRzdpRixLQUFLbUYsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDZytFLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQ1AsT0FBTyxDQUFDLEVBQUU7UUFDcEUsT0FBTyxJQUFJO0lBQ2I7SUFDQWtELGVBQWVDLGNBQWMsRUFBRTtRQUM3QixPQUFPLElBQUksQ0FBQyxDQUFDam5FLE1BQU0sQ0FBQ2luRSxlQUFlO0lBQ3JDO0lBQ0FDLG1CQUFtQmhDLEdBQUcsRUFBRWlDLGVBQWUsRUFBRTtRQUN2QyxNQUFNbEQsc0JBQXNCLElBQUksQ0FBQyxDQUFDQSxtQkFBbUI7UUFDckQsTUFBTWprRSxTQUFTLElBQUksQ0FBQyxDQUFDQSxNQUFNO1FBQzNCLE1BQU15akUsY0FBYyxJQUFJLENBQUMsQ0FBQ0EsV0FBVztRQUNyQyxLQUFLLE1BQU1qbUYsUUFBUTJwRixnQkFBaUI7WUFDbEMsSUFBSTNwRixRQUFRLElBQUksQ0FBQyxDQUFDd2lCLE1BQU0sRUFBRTtnQkFDeEJpa0Usb0JBQW9CMXpFLEdBQUcsQ0FBQ3lQLE1BQU0sQ0FBQ3hpQixLQUFLO1lBQ3RDLE9BQU8sSUFBSUEsUUFBUWltRixhQUFhO2dCQUM5QkEsV0FBVyxDQUFDam1GLEtBQUssQ0FBQ2tYLE9BQU8sQ0FBQ3V2RSxvQkFBb0IxekUsR0FBRyxFQUFFMHpFO1lBQ3JEO1FBQ0Y7UUFDQSxPQUFPLElBQUk7SUFDYjtJQUNBbUQsc0JBQXNCbEMsR0FBRyxFQUFFMW5GLElBQUksRUFBRTtRQUMvQixJQUFJLElBQUksQ0FBQyxDQUFDa21GLGlCQUFpQixDQUFDeGdGLEdBQUcsQ0FBQzFGLE9BQU87WUFDckMsSUFBSSxDQUFDLENBQUN5bUYsbUJBQW1CLENBQUMxekUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDbXpFLGlCQUFpQixDQUFDL21GLEdBQUcsQ0FBQ2E7UUFDNUQ7UUFDQSxPQUFPLElBQUk7SUFDYjtJQUNBNnBGLGdCQUFnQm5DLEdBQUcsRUFBRW9DLFdBQVcsS0FBSyxFQUFFO1FBQ3JDLElBQUksQ0FBQ0osa0JBQWtCLENBQUNoQyxLQUFLO1lBQUN2QztTQUF3QjtRQUN0RCxJQUFJLElBQUksQ0FBQyxDQUFDNEIsYUFBYSxFQUFFO1lBQ3ZCLE1BQU1oaEYsV0FBVzgvRSxvQkFBb0IsSUFBSSxDQUFDLENBQUNrQixhQUFhLEVBQUVXO1lBQzFELE1BQU0sRUFDSjVCLFlBQVksRUFDYixHQUFHLy9FO1lBQ0osSUFBSSxDQUFDLENBQUMwZ0YsbUJBQW1CLENBQUN2dkUsT0FBTyxDQUFDNHVFLGFBQWEveUUsR0FBRyxFQUFFK3lFO1lBQ3BELElBQUksQ0FBQyxDQUFDSyxVQUFVLENBQUNqdkUsT0FBTyxDQUFDNHVFLGFBQWEveUUsR0FBRyxFQUFFK3lFO1lBQzNDLElBQUksQ0FBQyxDQUFDTSxrQkFBa0IsQ0FBQ2x2RSxPQUFPLENBQUM0dUUsYUFBYS95RSxHQUFHLEVBQUUreUU7WUFDbkRBLGFBQWFwbkMsTUFBTSxDQUFDZ3BDO1lBQ3BCM2hGLFNBQVNnZ0Ysb0JBQW9CLEdBQUc7UUFDbEM7UUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDUyxjQUFjLEtBQUtrQixLQUFLO1lBQ2hDLE1BQU1yQyxPQUFPMWhGLE1BQU0sSUFBSSxDQUFDLENBQUM0aUYsV0FBVyxDQUFDLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxDQUFDSyxXQUFXO1lBQ2pFLE1BQU10QixPQUFPM2hGLE1BQU0sSUFBSSxDQUFDLENBQUM0aUYsV0FBVyxDQUFDLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxDQUFDTSxZQUFZO1lBQ2xFLE1BQU10QixPQUFPOWhGLEtBQUssSUFBSSxDQUFDLENBQUM4aUYsV0FBVyxDQUFDLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxDQUFDSyxXQUFXO1lBQ2hFLE1BQU1wQixPQUFPL2hGLEtBQUssSUFBSSxDQUFDLENBQUM4aUYsV0FBVyxDQUFDLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxDQUFDTSxZQUFZO1lBQ2pFekIsV0FBVyxJQUFJLENBQUMsQ0FBQzBCLFlBQVksRUFBRVksS0FBS3JDLE1BQU1DLE1BQU1DLE1BQU1DO1lBQ3RELEtBQUssTUFBTXVFLFVBQVUsSUFBSSxDQUFDLENBQUN0RCxtQkFBbUIsQ0FBRTtnQkFDOUMsSUFBSXNELFdBQVdyQyxLQUFLO29CQUNsQnRDLFdBQVcsSUFBSSxDQUFDLENBQUMwQixZQUFZLEVBQUVpRCxRQUFRMUUsTUFBTUMsTUFBTUMsTUFBTUM7Z0JBQzNEO1lBQ0Y7WUFDQSxLQUFLLE1BQU13RSxXQUFXLElBQUksQ0FBQyxDQUFDN0QsVUFBVSxDQUFFO2dCQUN0QyxJQUFJNkQsWUFBWXRDLEtBQUs7b0JBQ25CdEMsV0FBVyxJQUFJLENBQUMsQ0FBQzBCLFlBQVksRUFBRWtELFNBQVMzRSxNQUFNQyxNQUFNQyxNQUFNQztnQkFDNUQ7WUFDRjtZQUNBLEtBQUssTUFBTXdFLFdBQVcsSUFBSSxDQUFDLENBQUM1RCxrQkFBa0IsQ0FBRTtnQkFDOUMsSUFBSTRELFlBQVl0QyxLQUFLO29CQUNuQnRDLFdBQVcsSUFBSSxDQUFDLENBQUMwQixZQUFZLEVBQUVrRCxTQUFTM0UsTUFBTUMsTUFBTUMsTUFBTUM7Z0JBQzVEO1lBQ0Y7WUFDQSxJQUFJLENBQUNzRSxVQUFVO2dCQUNiLElBQUksQ0FBQyxDQUFDckQsbUJBQW1CLENBQUMvaEUsS0FBSztnQkFDL0IsSUFBSSxDQUFDLENBQUM4aEUsY0FBYyxHQUFHLENBQUM7WUFDMUI7UUFDRjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0F5RCx3QkFBd0J2QyxHQUFHLEVBQUVvQyxXQUFXLEtBQUssRUFBRTtRQUM3QyxNQUFNSSxPQUFPajdFLE1BQU1xVyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNtaEUsbUJBQW1CO1FBQ2pELElBQUksQ0FBQ29ELGVBQWUsQ0FBQ25DLEtBQUtvQztRQUMxQixJQUFJLENBQUM5QixxQkFBcUIsQ0FBQyxnQkFBZ0JOO1FBQzNDLEtBQUssTUFBTWUsT0FBT3lCLEtBQU07WUFDdEIsSUFBSSxDQUFDbEMscUJBQXFCLENBQUMsZ0JBQWdCUztRQUM3QztRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0EwQiwyQkFBMkJ6QyxHQUFHLEVBQUVvQyxXQUFXLEtBQUssRUFBRTtRQUNoRCxJQUFJLElBQUksQ0FBQyxDQUFDdEQsY0FBYyxLQUFLa0IsS0FBSztZQUNoQyxJQUFJLENBQUMsQ0FBQ2xCLGNBQWMsR0FBRyxDQUFDO1lBQ3hCLElBQUksQ0FBQyxDQUFDRixPQUFPLENBQUMsRUFBRSxHQUFHNWlGLEtBQUs0UCxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUNnekUsT0FBTyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQ0MsV0FBVyxDQUFDLEVBQUU7WUFDbEUsSUFBSSxDQUFDLENBQUNELE9BQU8sQ0FBQyxFQUFFLEdBQUc1aUYsS0FBSzRQLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQ2d6RSxPQUFPLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDQyxXQUFXLENBQUMsRUFBRTtZQUNsRSxJQUFJLENBQUMsQ0FBQ0QsT0FBTyxDQUFDLEVBQUUsR0FBRzVpRixLQUFLbUYsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDeTlFLE9BQU8sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUNDLFdBQVcsQ0FBQyxFQUFFO1lBQ2xFLElBQUksQ0FBQyxDQUFDRCxPQUFPLENBQUMsRUFBRSxHQUFHNWlGLEtBQUttRixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUN5OUUsT0FBTyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQ0MsV0FBVyxDQUFDLEVBQUU7WUFDbEUsSUFBSSxDQUFDdUQsVUFBVTtnQkFDYixJQUFJLENBQUMsQ0FBQ3JELG1CQUFtQixDQUFDL2hFLEtBQUs7WUFDakM7UUFDRjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0EwbEUsMkJBQTJCO1FBQ3pCLE1BQU0zRCxzQkFBc0IsSUFBSSxDQUFDLENBQUNBLG1CQUFtQjtRQUNyRCxJQUFJLENBQUMsQ0FBQ0EsbUJBQW1CLEdBQUcsSUFBSXZ4RTtRQUNoQyxPQUFPdXhFO0lBQ1Q7SUFDQTRELGtCQUFrQjNDLEdBQUcsRUFBRTtRQUNyQixNQUFNNEMsWUFBWSxJQUFJLENBQUMsQ0FBQzVELFVBQVUsQ0FBQ3ZuRixHQUFHLENBQUN1b0Y7UUFDdkMsSUFBSSxDQUFDLENBQUNoQixVQUFVLENBQUNob0MsTUFBTSxDQUFDZ3BDO1FBQ3hCLE9BQU80QztJQUNUO0lBQ0FDLHlCQUF5QnpFLFlBQVksRUFBRTtRQUNyQyxLQUFLLE1BQU0yQyxPQUFPM0MsYUFBYztZQUM5QixJQUFJLENBQUMsQ0FBQ1csbUJBQW1CLENBQUMxekUsR0FBRyxDQUFDMDFFO1FBQ2hDO0lBQ0Y7SUFDQTlzRSxPQUFPO1FBQ0wsSUFBSSxDQUFDLENBQUNnckUsbUJBQW1CLENBQUNqaUUsS0FBSztRQUMvQixPQUFPLElBQUlnaEUsV0FBVyxJQUFJLENBQUMsQ0FBQ0MsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDbUIsWUFBWTtJQUN4RDtJQUNBMEQsb0JBQW9CO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLENBQUN6RCxhQUFhO0lBQzVCO0FBQ0Y7QUFDQSxNQUFNMEQ7SUFDSixDQUFDQyxpQkFBaUIsQ0FBQztJQUNuQixDQUFDcEQsS0FBSyxDQUFDO0lBQ1AsQ0FBQ3FELFlBQVksQ0FBQztJQUNkLENBQUNDLFlBQVksQ0FBSztJQUNsQixDQUFDQyxVQUFVLENBQUs7SUFDaEJ2cUYsWUFBWW9xRixpQkFBaUIsRUFBRXBELEtBQUssRUFBRXFELFlBQVksQ0FBRTthQUZwRCxDQUFDQyxZQUFZLEdBQUc7YUFDaEIsQ0FBQ0MsVUFBVSxHQUFHO1FBRVosSUFBSUgsNkJBQTZCRCxpQ0FBaUNDLGtCQUFrQixDQUFDQyxZQUFZLEtBQUssQ0FBQyxDQUFDQSxjQUFjO1lBQ3BILE9BQU9EO1FBQ1Q7UUFDQSxJQUFJLENBQUMsQ0FBQ0EsaUJBQWlCLEdBQUdBO1FBQzFCLElBQUksQ0FBQyxDQUFDcEQsS0FBSyxHQUFHQTtRQUNkLElBQUksQ0FBQyxDQUFDcUQsWUFBWSxHQUFHLENBQUMsQ0FBQ0E7SUFDekI7SUFDQXZELHNCQUFzQjtRQUNwQixNQUFNLElBQUkvckUsTUFBTTtJQUNsQjtJQUNBc2UsS0FBSzJ0RCxLQUFLLEVBQUU7UUFDVixJQUFJLENBQUMsQ0FBQ3VELFVBQVU7UUFDaEIsSUFBSSxDQUFDLENBQUNILGlCQUFpQixDQUFDL3dELElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzJ0RCxLQUFLO1FBQ3hDLE9BQU8sSUFBSTtJQUNiO0lBQ0ExdEQsUUFBUTB0RCxLQUFLLEVBQUU7UUFDYixJQUFJLElBQUksQ0FBQyxDQUFDdUQsVUFBVSxHQUFHLEdBQUc7WUFDeEIsSUFBSSxDQUFDLENBQUNILGlCQUFpQixDQUFDOXdELE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQzB0RCxLQUFLO1lBQzNDLElBQUksQ0FBQyxDQUFDdUQsVUFBVTtRQUNsQjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0FwRCxpQkFBaUJDLEdBQUcsRUFBRTtRQUNwQixJQUFJLENBQUMsQ0FBQ2tELFlBQVk7UUFDbEIsT0FBTyxJQUFJO0lBQ2I7SUFDQWpELGdCQUFnQjtRQUNkLE9BQU8sSUFBSSxDQUFDLENBQUNpRCxZQUFZLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQ3RELEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQ29ELGlCQUFpQixDQUFDL0MsYUFBYTtJQUNyRjtJQUNBQyxrQkFBa0JGLEdBQUcsRUFBRTtRQUNyQixJQUFJLENBQUMsQ0FBQ2tELFlBQVk7UUFDbEIsT0FBTyxJQUFJO0lBQ2I7SUFDQXR0RCxtQkFBbUJncUQsS0FBSyxFQUFFO1FBQ3hCLE9BQU8sSUFBSTtJQUNiO0lBQ0E5cEQsaUJBQWlCOHBELEtBQUssRUFBRTtRQUN0QixPQUFPLElBQUk7SUFDYjtJQUNBTyxrQkFBa0JoeEMsR0FBRyxFQUFFO1FBQ3JCLElBQUksQ0FBQyxDQUFDNnpDLGlCQUFpQixDQUFDN0MsaUJBQWlCLENBQUNoeEM7UUFDMUMsT0FBTyxJQUFJO0lBQ2I7SUFDQWl4QyxtQkFBbUI7UUFDakIsSUFBSSxDQUFDLENBQUM0QyxpQkFBaUIsQ0FBQzVDLGdCQUFnQjtRQUN4QyxPQUFPLElBQUk7SUFDYjtJQUNBQyxpQkFBaUIvbkYsSUFBSSxFQUFFMG5GLEdBQUcsRUFBRTtRQUMxQixJQUFJLENBQUMsQ0FBQ2dELGlCQUFpQixDQUFDM0MsZ0JBQWdCLENBQUMvbkYsTUFBTSxJQUFJLENBQUMsQ0FBQ3NuRixLQUFLO1FBQzFELE9BQU8sSUFBSTtJQUNiO0lBQ0FVLHNCQUFzQmhvRixJQUFJLEVBQUUwbkYsR0FBRyxFQUFFO1FBQy9CLElBQUksQ0FBQyxDQUFDZ0QsaUJBQWlCLENBQUMxQyxxQkFBcUIsQ0FBQ2hvRixNQUFNLElBQUksQ0FBQyxDQUFDc25GLEtBQUs7UUFDL0QsT0FBTyxJQUFJO0lBQ2I7SUFDQVcscUJBQXFCam9GLElBQUksRUFBRTBuRixHQUFHLEVBQUU7UUFDOUIsSUFBSSxDQUFDLENBQUNnRCxpQkFBaUIsQ0FBQ3pDLG9CQUFvQixDQUFDam9GLE1BQU0sSUFBSSxDQUFDLENBQUNzbkYsS0FBSztRQUM5RCxPQUFPLElBQUk7SUFDYjtJQUNBWSxnQkFBZ0Jsb0YsSUFBSSxFQUFFMG5GLEdBQUcsRUFBRTtRQUN6QixPQUFPLElBQUk7SUFDYjtJQUNBUywwQkFBMEJub0YsSUFBSSxFQUFFb29GLE9BQU8sRUFBRUMsV0FBVyxFQUFFO1FBQ3BELElBQUksQ0FBQyxDQUFDcUMsaUJBQWlCLENBQUN2Qyx5QkFBeUIsQ0FBQ25vRixNQUFNb29GLFNBQVMsSUFBSSxDQUFDLENBQUNkLEtBQUs7UUFDNUUsT0FBTyxJQUFJO0lBQ2I7SUFDQWdCLDZCQUE2QnRvRixJQUFJLEVBQUUwbkYsR0FBRyxFQUFFO1FBQ3RDLElBQUksQ0FBQyxDQUFDZ0QsaUJBQWlCLENBQUNwQyw0QkFBNEIsQ0FBQ3RvRixNQUFNLElBQUksQ0FBQyxDQUFDc25GLEtBQUs7UUFDdEUsT0FBTyxJQUFJO0lBQ2I7SUFDQWlCLDRDQUE0Q2xnRixLQUFLLEVBQUU7UUFDakQsSUFBSSxDQUFDLENBQUNxaUYsaUJBQWlCLENBQUNuQywyQ0FBMkMsQ0FBQ2xnRjtRQUNwRSxPQUFPLElBQUk7SUFDYjtJQUNBbWdGLHVEQUF1RDtRQUNyRCxJQUFJLENBQUMsQ0FBQ2tDLGlCQUFpQixDQUFDbEMsb0RBQW9EO1FBQzVFLE9BQU8sSUFBSTtJQUNiO0lBQ0FFLFVBQVVoQixHQUFHLEVBQUU7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNpRCxZQUFZLEVBQUU7WUFDdkIsSUFBSSxDQUFDLENBQUNELGlCQUFpQixDQUFDaEMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDcEIsS0FBSztRQUMvQztRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0FxQixjQUFjakIsR0FBRyxFQUFFN3dDLEdBQUcsRUFBRXd1QyxJQUFJLEVBQUVFLElBQUksRUFBRUQsSUFBSSxFQUFFRSxJQUFJLEVBQUU7UUFDOUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDbUYsWUFBWSxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxDQUFDRCxpQkFBaUIsQ0FBQy9CLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQ3JCLEtBQUssRUFBRXp3QyxLQUFLd3VDLE1BQU1FLE1BQU1ELE1BQU1FO1FBQzVFO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQW9ELFdBQVdsQixHQUFHLEVBQUU3d0MsR0FBRyxFQUFFd3VDLElBQUksRUFBRUUsSUFBSSxFQUFFRCxJQUFJLEVBQUVFLElBQUksRUFBRTtRQUMzQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNtRixZQUFZLEVBQUU7WUFDdkIsSUFBSSxDQUFDLENBQUNELGlCQUFpQixDQUFDOUIsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDdEIsS0FBSyxFQUFFendDLEtBQUt3dUMsTUFBTUUsTUFBTUQsTUFBTUU7UUFDekU7UUFDQSxPQUFPLElBQUk7SUFDYjtJQUNBcUQsb0JBQW9CbkIsR0FBRyxFQUFFN3dDLEdBQUcsRUFBRTAvQixJQUFJLEVBQUUva0MsS0FBSyxFQUFFM3RDLENBQUMsRUFBRTBNLENBQUMsRUFBRXU0RSxVQUFVLEVBQUU7UUFDM0QsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDNkIsWUFBWSxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxDQUFDRCxpQkFBaUIsQ0FBQzdCLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDdkIsS0FBSyxFQUFFendDLEtBQUswL0IsTUFBTS9rQyxPQUFPM3RDLEdBQUcwTSxHQUFHdTRFO1FBQ25GO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQUksbUJBQW1CeEIsR0FBRyxFQUFFO1FBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ2lELFlBQVksRUFBRTtZQUN2QixJQUFJLENBQUMsQ0FBQ0QsaUJBQWlCLENBQUN4QixrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQzVCLEtBQUs7UUFDeEQ7UUFDQSxPQUFPLElBQUk7SUFDYjtJQUNBa0MsZUFBZUMsY0FBYyxFQUFFO1FBQzdCLE9BQU8sSUFBSSxDQUFDLENBQUNpQixpQkFBaUIsQ0FBQ2xCLGNBQWMsQ0FBQ0M7SUFDaEQ7SUFDQUMsbUJBQW1CaEMsR0FBRyxFQUFFaUMsZUFBZSxFQUFFO1FBQ3ZDLElBQUksQ0FBQyxDQUFDZSxpQkFBaUIsQ0FBQ2hCLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDcEMsS0FBSyxFQUFFcUM7UUFDeEQsT0FBTyxJQUFJO0lBQ2I7SUFDQUMsc0JBQXNCbEMsR0FBRyxFQUFFMW5GLElBQUksRUFBRTtRQUMvQixJQUFJLENBQUMsQ0FBQzBxRixpQkFBaUIsQ0FBQ2QscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUN0QyxLQUFLLEVBQUV0bkY7UUFDM0QsT0FBTyxJQUFJO0lBQ2I7SUFDQTZwRixnQkFBZ0JuQyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDLENBQUNnRCxpQkFBaUIsQ0FBQ2IsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDdkMsS0FBSyxFQUFFO1FBQ3JELE9BQU8sSUFBSTtJQUNiO0lBQ0EyQyx3QkFBd0J2QyxHQUFHLEVBQUU7UUFDM0IsSUFBSSxDQUFDLENBQUNnRCxpQkFBaUIsQ0FBQ1QsdUJBQXVCLENBQUMsSUFBSSxDQUFDLENBQUMzQyxLQUFLLEVBQUU7UUFDN0QsT0FBTyxJQUFJO0lBQ2I7SUFDQTZDLDJCQUEyQnpDLEdBQUcsRUFBRTtRQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNpRCxZQUFZLEVBQUU7WUFDdkIsSUFBSSxDQUFDLENBQUNELGlCQUFpQixDQUFDUCwwQkFBMEIsQ0FBQyxJQUFJLENBQUMsQ0FBQzdDLEtBQUssRUFBRTtRQUNsRTtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0EzckUsT0FBTztRQUNMLE1BQU0sSUFBSU4sTUFBTTtJQUNsQjtJQUNBbXZFLG9CQUFvQjtRQUNsQixNQUFNLElBQUludkUsTUFBTTtJQUNsQjtBQUNGO0FBQ0EsTUFBTXl2RSxlQUFlO0lBQ25CendELFFBQVE7UUFBQztRQUFRO1FBQWE7UUFBVTtRQUFlO1FBQWU7UUFBYTtRQUFXO1FBQVk7UUFBYztLQUFPO0lBQy9IRSxNQUFNO1FBQUM7UUFBUTtRQUFhO1FBQVU7UUFBYTtRQUFhO1FBQTRCO0tBQVE7SUFDcEd3d0QsY0FBYztRQUFDO1FBQWE7UUFBUztRQUFVO1FBQWE7UUFBZTtLQUEyQjtJQUN0R25zRCxhQUFhO1FBQUM7UUFBVTtRQUFhO0tBQVk7SUFDakQvQyxVQUFVO1FBQUM7UUFBYTtRQUFXO1FBQWU7UUFBZTtRQUFVO1FBQVk7UUFBWTtRQUFjO1FBQVE7UUFBVztRQUFVO1FBQWE7UUFBcUI7UUFBUztRQUFhO1FBQWU7UUFBNEI7S0FBZTtJQUNoUWhDLFdBQVc7UUFBQztLQUFZO0lBQ3hCbXhELGtCQUFrQjtRQUFDO1FBQWE7S0FBWTtBQUM5QztFQUVDLGtDQUFrQztBQU9uQyxNQUFNQyxXQUFXO0lBQ2YvM0QsTUFBTTtJQUNOQyxRQUFRO0lBQ1IrM0QsU0FBUztBQUNYO0FBQ0EsU0FBU0MsaUJBQWlCdDBDLEdBQUcsRUFBRXdqQyxJQUFJO0lBQ2pDLElBQUksQ0FBQ0EsTUFBTTtRQUNUO0lBQ0Y7SUFDQSxNQUFNaG9DLFFBQVFnb0MsSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUU7SUFDL0IsTUFBTS9uQyxTQUFTK25DLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFO0lBQ2hDLE1BQU0rUSxTQUFTLElBQUkzUjtJQUNuQjJSLE9BQU9wbUQsSUFBSSxDQUFDcTFDLElBQUksQ0FBQyxFQUFFLEVBQUVBLElBQUksQ0FBQyxFQUFFLEVBQUVob0MsT0FBT0M7SUFDckN1RSxJQUFJL2IsSUFBSSxDQUFDc3dEO0FBQ1g7QUFDQSxNQUFNQztJQUNKQyw4QkFBOEI7UUFDNUIsT0FBTztJQUNUO0lBQ0FDLGFBQWE7UUFDWDdyRCxZQUFZO0lBQ2Q7QUFDRjtBQUNBLE1BQU04ckQsa0NBQWtDSDtJQUN0Qy9xRixZQUFZbXJGLEVBQUUsQ0FBRTtRQUNkLEtBQUs7UUFDTCxJQUFJLENBQUMxbUIsS0FBSyxHQUFHMG1CLEVBQUUsQ0FBQyxFQUFFO1FBQ2xCLElBQUksQ0FBQ0MsS0FBSyxHQUFHRCxFQUFFLENBQUMsRUFBRTtRQUNsQixJQUFJLENBQUNFLFdBQVcsR0FBR0YsRUFBRSxDQUFDLEVBQUU7UUFDeEIsSUFBSSxDQUFDRyxHQUFHLEdBQUdILEVBQUUsQ0FBQyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0ksR0FBRyxHQUFHSixFQUFFLENBQUMsRUFBRTtRQUNoQixJQUFJLENBQUNLLEdBQUcsR0FBR0wsRUFBRSxDQUFDLEVBQUU7UUFDaEIsSUFBSSxDQUFDTSxHQUFHLEdBQUdOLEVBQUUsQ0FBQyxFQUFFO1FBQ2hCLElBQUksQ0FBQ3JsRCxNQUFNLEdBQUc7SUFDaEI7SUFDQTRsRCxnQkFBZ0JuMUMsR0FBRyxFQUFFO1FBQ25CLElBQUlvMUM7UUFDSixJQUFJLElBQUksQ0FBQ2xuQixLQUFLLEtBQUssU0FBUztZQUMxQmtuQixPQUFPcDFDLElBQUlxMUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDTixHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQ0EsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDQSxHQUFHLENBQUMsRUFBRTtRQUNwRixPQUFPLElBQUksSUFBSSxDQUFDOW1CLEtBQUssS0FBSyxVQUFVO1lBQ2xDa25CLE9BQU9wMUMsSUFBSXMxQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUNQLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDQSxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQ0UsR0FBRyxFQUFFLElBQUksQ0FBQ0QsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNBLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDRSxHQUFHO1FBQ3hHO1FBQ0EsS0FBSyxNQUFNSyxhQUFhLElBQUksQ0FBQ1QsV0FBVyxDQUFFO1lBQ3hDTSxLQUFLSSxZQUFZLENBQUNELFNBQVMsQ0FBQyxFQUFFLEVBQUVBLFNBQVMsQ0FBQyxFQUFFO1FBQzlDO1FBQ0EsT0FBT0g7SUFDVDtJQUNBVixXQUFXMTBDLEdBQUcsRUFBRXkxQyxLQUFLLEVBQUVyK0UsT0FBTyxFQUFFcytFLFFBQVEsRUFBRTtRQUN4QyxJQUFJQztRQUNKLElBQUlELGFBQWF0QixTQUFTOTNELE1BQU0sSUFBSW81RCxhQUFhdEIsU0FBUy8zRCxJQUFJLEVBQUU7WUFDOUQsTUFBTXU1RCxZQUFZSCxNQUFNcHhFLE9BQU8sQ0FBQ3d4RSx5QkFBeUIsQ0FBQ0gsVUFBVTMxQyxvQkFBb0JDLFNBQVM7Z0JBQUM7Z0JBQUc7Z0JBQUc7Z0JBQUc7YUFBRTtZQUM3RyxNQUFNeEUsUUFBUTN1QyxLQUFLRCxJQUFJLENBQUNncEYsU0FBUyxDQUFDLEVBQUUsR0FBR0EsU0FBUyxDQUFDLEVBQUUsS0FBSztZQUN4RCxNQUFNbjZDLFNBQVM1dUMsS0FBS0QsSUFBSSxDQUFDZ3BGLFNBQVMsQ0FBQyxFQUFFLEdBQUdBLFNBQVMsQ0FBQyxFQUFFLEtBQUs7WUFDekQsTUFBTUUsWUFBWUwsTUFBTU0sY0FBYyxDQUFDQyxTQUFTLENBQUMsV0FBV3g2QyxPQUFPQztZQUNuRSxNQUFNdzZDLFNBQVNILFVBQVU5a0UsT0FBTztZQUNoQ2lsRSxPQUFPQyxTQUFTLENBQUMsR0FBRyxHQUFHRCxPQUFPdHJDLE1BQU0sQ0FBQ25QLEtBQUssRUFBRXk2QyxPQUFPdHJDLE1BQU0sQ0FBQ2xQLE1BQU07WUFDaEV3NkMsT0FBT0UsU0FBUztZQUNoQkYsT0FBTzluRCxJQUFJLENBQUMsR0FBRyxHQUFHOG5ELE9BQU90ckMsTUFBTSxDQUFDblAsS0FBSyxFQUFFeTZDLE9BQU90ckMsTUFBTSxDQUFDbFAsTUFBTTtZQUMzRHc2QyxPQUFPM2xCLFNBQVMsQ0FBQyxDQUFDc2xCLFNBQVMsQ0FBQyxFQUFFLEVBQUUsQ0FBQ0EsU0FBUyxDQUFDLEVBQUU7WUFDN0N4K0UsVUFBVXExQixLQUFLekosU0FBUyxDQUFDNXJCLFNBQVM7Z0JBQUM7Z0JBQUc7Z0JBQUc7Z0JBQUc7Z0JBQUd3K0UsU0FBUyxDQUFDLEVBQUU7Z0JBQUVBLFNBQVMsQ0FBQyxFQUFFO2FBQUM7WUFDMUVLLE9BQU9qekQsU0FBUyxJQUFJeXlELE1BQU1XLGFBQWE7WUFDdkMsSUFBSSxJQUFJLENBQUM3bUQsTUFBTSxFQUFFO2dCQUNmMG1ELE9BQU9qekQsU0FBUyxJQUFJLElBQUksQ0FBQ3VNLE1BQU07WUFDakM7WUFDQStrRCxpQkFBaUIyQixRQUFRLElBQUksQ0FBQ3BCLEtBQUs7WUFDbkNvQixPQUFPSSxTQUFTLEdBQUcsSUFBSSxDQUFDbEIsZUFBZSxDQUFDYztZQUN4Q0EsT0FBT3Z5RCxJQUFJO1lBQ1hpeUQsVUFBVTMxQyxJQUFJczJDLGFBQWEsQ0FBQ1IsVUFBVW5yQyxNQUFNLEVBQUU7WUFDOUMsTUFBTTRyQyxZQUFZLElBQUk5SSxVQUFVcjJFO1lBQ2hDdStFLFFBQVFhLFlBQVksQ0FBQ0Q7UUFDdkIsT0FBTztZQUNMakMsaUJBQWlCdDBDLEtBQUssSUFBSSxDQUFDNjBDLEtBQUs7WUFDaENjLFVBQVUsSUFBSSxDQUFDUixlQUFlLENBQUNuMUM7UUFDakM7UUFDQSxPQUFPMjFDO0lBQ1Q7QUFDRjtBQUNBLFNBQVNjLGFBQWE3L0UsSUFBSSxFQUFFb2EsT0FBTyxFQUFFeWMsRUFBRSxFQUFFZ0csRUFBRSxFQUFFaWpELEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUU7SUFDekQsTUFBTTlILFNBQVMvOUQsUUFBUSs5RCxNQUFNLEVBQzNCdnZDLFNBQVN4dUIsUUFBUXd1QixNQUFNO0lBQ3pCLE1BQU1sdEMsUUFBUXNFLEtBQUtBLElBQUksRUFDckJrZ0YsVUFBVWxnRixLQUFLNGtDLEtBQUssR0FBRztJQUN6QixJQUFJcGhDO0lBQ0osSUFBSTIwRSxNQUFNLENBQUN0aEQsS0FBSyxFQUFFLEdBQUdzaEQsTUFBTSxDQUFDdDdDLEtBQUssRUFBRSxFQUFFO1FBQ25DcjVCLE1BQU1xekI7UUFDTkEsS0FBS2dHO1FBQ0xBLEtBQUtyNUI7UUFDTEEsTUFBTXU4RTtRQUNOQSxLQUFLQztRQUNMQSxLQUFLeDhFO0lBQ1A7SUFDQSxJQUFJMjBFLE1BQU0sQ0FBQ3Q3QyxLQUFLLEVBQUUsR0FBR3M3QyxNQUFNLENBQUMySCxLQUFLLEVBQUUsRUFBRTtRQUNuQ3Q4RSxNQUFNcTVCO1FBQ05BLEtBQUtpakQ7UUFDTEEsS0FBS3Q4RTtRQUNMQSxNQUFNdzhFO1FBQ05BLEtBQUtDO1FBQ0xBLEtBQUt6OEU7SUFDUDtJQUNBLElBQUkyMEUsTUFBTSxDQUFDdGhELEtBQUssRUFBRSxHQUFHc2hELE1BQU0sQ0FBQ3Q3QyxLQUFLLEVBQUUsRUFBRTtRQUNuQ3I1QixNQUFNcXpCO1FBQ05BLEtBQUtnRztRQUNMQSxLQUFLcjVCO1FBQ0xBLE1BQU11OEU7UUFDTkEsS0FBS0M7UUFDTEEsS0FBS3g4RTtJQUNQO0lBQ0EsTUFBTW0yQixLQUFLLENBQUN3K0MsTUFBTSxDQUFDdGhELEdBQUcsR0FBR3pjLFFBQVE2cEIsT0FBTyxJQUFJN3BCLFFBQVErbEUsTUFBTTtJQUMxRCxNQUFNdm1ELEtBQUssQ0FBQ3UrQyxNQUFNLENBQUN0aEQsS0FBSyxFQUFFLEdBQUd6YyxRQUFROHBCLE9BQU8sSUFBSTlwQixRQUFRZ21FLE1BQU07SUFDOUQsTUFBTXRtRCxLQUFLLENBQUNxK0MsTUFBTSxDQUFDdDdDLEdBQUcsR0FBR3ppQixRQUFRNnBCLE9BQU8sSUFBSTdwQixRQUFRK2xFLE1BQU07SUFDMUQsTUFBTW5tRCxLQUFLLENBQUNtK0MsTUFBTSxDQUFDdDdDLEtBQUssRUFBRSxHQUFHemlCLFFBQVE4cEIsT0FBTyxJQUFJOXBCLFFBQVFnbUUsTUFBTTtJQUM5RCxNQUFNcm1ELEtBQUssQ0FBQ28rQyxNQUFNLENBQUMySCxHQUFHLEdBQUcxbEUsUUFBUTZwQixPQUFPLElBQUk3cEIsUUFBUStsRSxNQUFNO0lBQzFELE1BQU1sbUQsS0FBSyxDQUFDaytDLE1BQU0sQ0FBQzJILEtBQUssRUFBRSxHQUFHMWxFLFFBQVE4cEIsT0FBTyxJQUFJOXBCLFFBQVFnbUUsTUFBTTtJQUM5RCxJQUFJeG1ELE1BQU1LLElBQUk7UUFDWjtJQUNGO0lBQ0EsTUFBTW9tRCxNQUFNejNDLE1BQU0sQ0FBQ20zQyxHQUFHLEVBQ3BCTyxNQUFNMTNDLE1BQU0sQ0FBQ20zQyxLQUFLLEVBQUUsRUFDcEJRLE1BQU0zM0MsTUFBTSxDQUFDbTNDLEtBQUssRUFBRTtJQUN0QixNQUFNUyxNQUFNNTNDLE1BQU0sQ0FBQ28zQyxHQUFHLEVBQ3BCUyxNQUFNNzNDLE1BQU0sQ0FBQ28zQyxLQUFLLEVBQUUsRUFDcEJVLE1BQU05M0MsTUFBTSxDQUFDbzNDLEtBQUssRUFBRTtJQUN0QixNQUFNVyxNQUFNLzNDLE1BQU0sQ0FBQ3EzQyxHQUFHLEVBQ3BCVyxNQUFNaDRDLE1BQU0sQ0FBQ3EzQyxLQUFLLEVBQUUsRUFDcEJZLE1BQU1qNEMsTUFBTSxDQUFDcTNDLEtBQUssRUFBRTtJQUN0QixNQUFNcEksT0FBTzVoRixLQUFLNjFDLEtBQUssQ0FBQ2xTLEtBQ3RCbStDLE9BQU85aEYsS0FBSzYxQyxLQUFLLENBQUM3UjtJQUNwQixJQUFJNm1ELElBQUlDLEtBQUtDLEtBQUtDO0lBQ2xCLElBQUlDLElBQUlDLEtBQUtDLEtBQUtDO0lBQ2xCLElBQUssSUFBSXYrRSxJQUFJKzBFLE1BQU0vMEUsS0FBS2kxRSxNQUFNajFFLElBQUs7UUFDakMsSUFBSUEsSUFBSWszQixJQUFJO1lBQ1YsTUFBTWx3QixJQUFJaEgsSUFBSTgyQixLQUFLLElBQUksQ0FBQ0EsS0FBSzkyQixDQUFBQSxJQUFNODJCLENBQUFBLEtBQUtJLEVBQUM7WUFDekM4bUQsS0FBS25uRCxLQUFLLENBQUNBLEtBQUtHLEVBQUMsSUFBS2h3QjtZQUN0QmkzRSxNQUFNVixNQUFNLENBQUNBLE1BQU1HLEdBQUUsSUFBSzEyRTtZQUMxQmszRSxNQUFNVixNQUFNLENBQUNBLE1BQU1HLEdBQUUsSUFBSzMyRTtZQUMxQm0zRSxNQUFNVixNQUFNLENBQUNBLE1BQU1HLEdBQUUsSUFBSzUyRTtRQUM1QixPQUFPO1lBQ0wsSUFBSUE7WUFDSixJQUFJaEgsSUFBSW0zQixJQUFJO2dCQUNWbndCLElBQUk7WUFDTixPQUFPLElBQUlrd0IsT0FBT0MsSUFBSTtnQkFDcEJud0IsSUFBSTtZQUNOLE9BQU87Z0JBQ0xBLElBQUksQ0FBQ2t3QixLQUFLbDNCLENBQUFBLElBQU1rM0IsQ0FBQUEsS0FBS0MsRUFBQztZQUN4QjtZQUNBNm1ELEtBQUtobkQsS0FBSyxDQUFDQSxLQUFLQyxFQUFDLElBQUtqd0I7WUFDdEJpM0UsTUFBTVAsTUFBTSxDQUFDQSxNQUFNRyxHQUFFLElBQUs3MkU7WUFDMUJrM0UsTUFBTVAsTUFBTSxDQUFDQSxNQUFNRyxHQUFFLElBQUs5MkU7WUFDMUJtM0UsTUFBTVAsTUFBTSxDQUFDQSxNQUFNRyxHQUFFLElBQUsvMkU7UUFDNUI7UUFDQSxJQUFJQTtRQUNKLElBQUloSCxJQUFJODJCLElBQUk7WUFDVjl2QixJQUFJO1FBQ04sT0FBTyxJQUFJaEgsSUFBSW0zQixJQUFJO1lBQ2pCbndCLElBQUk7UUFDTixPQUFPO1lBQ0xBLElBQUksQ0FBQzh2QixLQUFLOTJCLENBQUFBLElBQU04MkIsQ0FBQUEsS0FBS0ssRUFBQztRQUN4QjtRQUNBaW5ELEtBQUt2bkQsS0FBSyxDQUFDQSxLQUFLSSxFQUFDLElBQUtqd0I7UUFDdEJxM0UsTUFBTWQsTUFBTSxDQUFDQSxNQUFNTSxHQUFFLElBQUs3MkU7UUFDMUJzM0UsTUFBTWQsTUFBTSxDQUFDQSxNQUFNTSxHQUFFLElBQUs5MkU7UUFDMUJ1M0UsTUFBTWQsTUFBTSxDQUFDQSxNQUFNTSxHQUFFLElBQUsvMkU7UUFDMUIsTUFBTXczRSxNQUFNcnJGLEtBQUs2MUMsS0FBSyxDQUFDNzFDLEtBQUttRixHQUFHLENBQUMwbEYsSUFBSUk7UUFDcEMsTUFBTUssTUFBTXRyRixLQUFLNjFDLEtBQUssQ0FBQzcxQyxLQUFLNFAsR0FBRyxDQUFDaTdFLElBQUlJO1FBQ3BDLElBQUl4OUUsSUFBSXc4RSxVQUFVcDlFLElBQUl3K0UsTUFBTTtRQUM1QixJQUFLLElBQUlsckYsSUFBSWtyRixLQUFLbHJGLEtBQUttckYsS0FBS25yRixJQUFLO1lBQy9CMFQsSUFBSSxDQUFDZzNFLEtBQUsxcUYsQ0FBQUEsSUFBTTBxRixDQUFBQSxLQUFLSSxFQUFDO1lBQ3RCLElBQUlwM0UsSUFBSSxHQUFHO2dCQUNUQSxJQUFJO1lBQ04sT0FBTyxJQUFJQSxJQUFJLEdBQUc7Z0JBQ2hCQSxJQUFJO1lBQ047WUFDQXBPLEtBQUssQ0FBQ2dJLElBQUksR0FBR3E5RSxNQUFNLENBQUNBLE1BQU1JLEdBQUUsSUFBS3IzRSxJQUFJO1lBQ3JDcE8sS0FBSyxDQUFDZ0ksSUFBSSxHQUFHczlFLE1BQU0sQ0FBQ0EsTUFBTUksR0FBRSxJQUFLdDNFLElBQUk7WUFDckNwTyxLQUFLLENBQUNnSSxJQUFJLEdBQUd1OUUsTUFBTSxDQUFDQSxNQUFNSSxHQUFFLElBQUt2M0UsSUFBSTtZQUNyQ3BPLEtBQUssQ0FBQ2dJLElBQUksR0FBRztRQUNmO0lBQ0Y7QUFDRjtBQUNBLFNBQVM4OUUsV0FBV3hoRixJQUFJLEVBQUV5aEYsTUFBTSxFQUFFcm5FLE9BQU87SUFDdkMsTUFBTXNuRSxLQUFLRCxPQUFPdEosTUFBTTtJQUN4QixNQUFNd0osS0FBS0YsT0FBTzc0QyxNQUFNO0lBQ3hCLElBQUl4MEMsR0FBR2luQztJQUNQLE9BQVFvbUQsT0FBT3JwRixJQUFJO1FBQ2pCLEtBQUs7WUFDSCxNQUFNd3BGLGlCQUFpQkgsT0FBT0csY0FBYztZQUM1QyxNQUFNQyxPQUFPNXJGLEtBQUtDLEtBQUssQ0FBQ3dyRixHQUFHanlGLE1BQU0sR0FBR215RixrQkFBa0I7WUFDdEQsTUFBTUUsT0FBT0YsaUJBQWlCO1lBQzlCLElBQUt4dEYsSUFBSSxHQUFHQSxJQUFJeXRGLE1BQU16dEYsSUFBSztnQkFDekIsSUFBSTJ0RixJQUFJM3RGLElBQUl3dEY7Z0JBQ1osSUFBSyxJQUFJbCtFLElBQUksR0FBR0EsSUFBSW8rRSxNQUFNcCtFLEtBQUtxK0UsSUFBSztvQkFDbENsQyxhQUFhNy9FLE1BQU1vYSxTQUFTc25FLEVBQUUsQ0FBQ0ssRUFBRSxFQUFFTCxFQUFFLENBQUNLLElBQUksRUFBRSxFQUFFTCxFQUFFLENBQUNLLElBQUlILGVBQWUsRUFBRUQsRUFBRSxDQUFDSSxFQUFFLEVBQUVKLEVBQUUsQ0FBQ0ksSUFBSSxFQUFFLEVBQUVKLEVBQUUsQ0FBQ0ksSUFBSUgsZUFBZTtvQkFDOUcvQixhQUFhNy9FLE1BQU1vYSxTQUFTc25FLEVBQUUsQ0FBQ0ssSUFBSUgsaUJBQWlCLEVBQUUsRUFBRUYsRUFBRSxDQUFDSyxJQUFJLEVBQUUsRUFBRUwsRUFBRSxDQUFDSyxJQUFJSCxlQUFlLEVBQUVELEVBQUUsQ0FBQ0ksSUFBSUgsaUJBQWlCLEVBQUUsRUFBRUQsRUFBRSxDQUFDSSxJQUFJLEVBQUUsRUFBRUosRUFBRSxDQUFDSSxJQUFJSCxlQUFlO2dCQUMxSjtZQUNGO1lBQ0E7UUFDRixLQUFLO1lBQ0gsSUFBS3h0RixJQUFJLEdBQUdpbkMsS0FBS3FtRCxHQUFHanlGLE1BQU0sRUFBRTJFLElBQUlpbkMsSUFBSWpuQyxLQUFLLEVBQUc7Z0JBQzFDeXJGLGFBQWE3L0UsTUFBTW9hLFNBQVNzbkUsRUFBRSxDQUFDdHRGLEVBQUUsRUFBRXN0RixFQUFFLENBQUN0dEYsSUFBSSxFQUFFLEVBQUVzdEYsRUFBRSxDQUFDdHRGLElBQUksRUFBRSxFQUFFdXRGLEVBQUUsQ0FBQ3Z0RixFQUFFLEVBQUV1dEYsRUFBRSxDQUFDdnRGLElBQUksRUFBRSxFQUFFdXRGLEVBQUUsQ0FBQ3Z0RixJQUFJLEVBQUU7WUFDdEY7WUFDQTtRQUNGO1lBQ0UsTUFBTSxJQUFJd1osTUFBTTtJQUNwQjtBQUNGO0FBQ0EsTUFBTW8wRSwyQkFBMkJwRTtJQUMvQi9xRixZQUFZbXJGLEVBQUUsQ0FBRTtRQUNkLEtBQUs7UUFDTCxJQUFJLENBQUNpRSxPQUFPLEdBQUdqRSxFQUFFLENBQUMsRUFBRTtRQUNwQixJQUFJLENBQUMvbEMsT0FBTyxHQUFHK2xDLEVBQUUsQ0FBQyxFQUFFO1FBQ3BCLElBQUksQ0FBQ2tFLFFBQVEsR0FBR2xFLEVBQUUsQ0FBQyxFQUFFO1FBQ3JCLElBQUksQ0FBQ21FLE9BQU8sR0FBR25FLEVBQUUsQ0FBQyxFQUFFO1FBQ3BCLElBQUksQ0FBQ0MsS0FBSyxHQUFHRCxFQUFFLENBQUMsRUFBRTtRQUNsQixJQUFJLENBQUNvRSxXQUFXLEdBQUdwRSxFQUFFLENBQUMsRUFBRTtRQUN4QixJQUFJLENBQUNybEQsTUFBTSxHQUFHO0lBQ2hCO0lBQ0EwcEQsa0JBQWtCQyxhQUFhLEVBQUVqeUIsZUFBZSxFQUFFOHVCLGNBQWMsRUFBRTtRQUNoRSxNQUFNb0QsaUJBQWlCO1FBQ3ZCLE1BQU1DLG1CQUFtQjtRQUN6QixNQUFNQyxjQUFjO1FBQ3BCLE1BQU14K0MsVUFBVWh1QyxLQUFLQyxLQUFLLENBQUMsSUFBSSxDQUFDaXNGLE9BQU8sQ0FBQyxFQUFFO1FBQzFDLE1BQU1qK0MsVUFBVWp1QyxLQUFLQyxLQUFLLENBQUMsSUFBSSxDQUFDaXNGLE9BQU8sQ0FBQyxFQUFFO1FBQzFDLE1BQU1PLGNBQWN6c0YsS0FBS0QsSUFBSSxDQUFDLElBQUksQ0FBQ21zRixPQUFPLENBQUMsRUFBRSxJQUFJbCtDO1FBQ2pELE1BQU0wK0MsZUFBZTFzRixLQUFLRCxJQUFJLENBQUMsSUFBSSxDQUFDbXNGLE9BQU8sQ0FBQyxFQUFFLElBQUlqK0M7UUFDbEQsTUFBTVUsUUFBUTN1QyxLQUFLbUYsR0FBRyxDQUFDbkYsS0FBS0QsSUFBSSxDQUFDQyxLQUFLK0wsR0FBRyxDQUFDMGdGLGNBQWNKLGFBQWEsQ0FBQyxFQUFFLEdBQUdDLGtCQUFrQkM7UUFDN0YsTUFBTTM5QyxTQUFTNXVDLEtBQUttRixHQUFHLENBQUNuRixLQUFLRCxJQUFJLENBQUNDLEtBQUsrTCxHQUFHLENBQUMyZ0YsZUFBZUwsYUFBYSxDQUFDLEVBQUUsR0FBR0Msa0JBQWtCQztRQUMvRixNQUFNckMsU0FBU3VDLGNBQWM5OUM7UUFDN0IsTUFBTXc3QyxTQUFTdUMsZUFBZTk5QztRQUM5QixNQUFNenFCLFVBQVU7WUFDZCs5RCxRQUFRLElBQUksQ0FBQzhKLE9BQU87WUFDcEJyNUMsUUFBUSxJQUFJLENBQUNxUCxPQUFPO1lBQ3BCaFUsU0FBUyxDQUFDQTtZQUNWQyxTQUFTLENBQUNBO1lBQ1ZpOEMsUUFBUSxJQUFJQTtZQUNaQyxRQUFRLElBQUlBO1FBQ2Q7UUFDQSxNQUFNd0MsY0FBY2grQyxRQUFRNjlDLGNBQWM7UUFDMUMsTUFBTUksZUFBZWgrQyxTQUFTNDlDLGNBQWM7UUFDNUMsTUFBTXZELFlBQVlDLGVBQWVDLFNBQVMsQ0FBQyxRQUFRd0QsYUFBYUM7UUFDaEUsTUFBTXhELFNBQVNILFVBQVU5a0UsT0FBTztRQUNoQyxNQUFNcGEsT0FBT3EvRSxPQUFPeUQsZUFBZSxDQUFDbCtDLE9BQU9DO1FBQzNDLElBQUl3ckIsaUJBQWlCO1lBQ25CLE1BQU0zMEQsUUFBUXNFLEtBQUtBLElBQUk7WUFDdkIsSUFBSyxJQUFJNUwsSUFBSSxHQUFHaW5DLEtBQUszL0IsTUFBTWpNLE1BQU0sRUFBRTJFLElBQUlpbkMsSUFBSWpuQyxLQUFLLEVBQUc7Z0JBQ2pEc0gsS0FBSyxDQUFDdEgsRUFBRSxHQUFHaThELGVBQWUsQ0FBQyxFQUFFO2dCQUM3QjMwRCxLQUFLLENBQUN0SCxJQUFJLEVBQUUsR0FBR2k4RCxlQUFlLENBQUMsRUFBRTtnQkFDakMzMEQsS0FBSyxDQUFDdEgsSUFBSSxFQUFFLEdBQUdpOEQsZUFBZSxDQUFDLEVBQUU7Z0JBQ2pDMzBELEtBQUssQ0FBQ3RILElBQUksRUFBRSxHQUFHO1lBQ2pCO1FBQ0Y7UUFDQSxLQUFLLE1BQU1xdEYsVUFBVSxJQUFJLENBQUNTLFFBQVEsQ0FBRTtZQUNsQ1YsV0FBV3hoRixNQUFNeWhGLFFBQVFybkU7UUFDM0I7UUFDQWlsRSxPQUFPMEQsWUFBWSxDQUFDL2lGLE1BQU15aUYsYUFBYUE7UUFDdkMsTUFBTTF1QyxTQUFTbXJDLFVBQVVuckMsTUFBTTtRQUMvQixPQUFPO1lBQ0xBO1lBQ0E5UCxTQUFTQSxVQUFVdytDLGNBQWN0QztZQUNqQ2o4QyxTQUFTQSxVQUFVdStDLGNBQWNyQztZQUNqQ0Q7WUFDQUM7UUFDRjtJQUNGO0lBQ0F2Qyw4QkFBOEI7UUFDNUIsT0FBTztJQUNUO0lBQ0FDLFdBQVcxMEMsR0FBRyxFQUFFeTFDLEtBQUssRUFBRXIrRSxPQUFPLEVBQUVzK0UsUUFBUSxFQUFFO1FBQ3hDcEIsaUJBQWlCdDBDLEtBQUssSUFBSSxDQUFDNjBDLEtBQUs7UUFDaEMsTUFBTWw2QyxRQUFRLElBQUlyNEIsYUFBYTtRQUMvQixJQUFJb3pFLGFBQWF0QixTQUFTQyxPQUFPLEVBQUU7WUFDakM1bkQsS0FBSzZDLDZCQUE2QixDQUFDeVEsb0JBQW9CQyxNQUFNckY7UUFDL0QsT0FBTyxJQUFJLElBQUksQ0FBQ3BMLE1BQU0sRUFBRTtZQUN0QjlDLEtBQUs2Qyw2QkFBNkIsQ0FBQyxJQUFJLENBQUNDLE1BQU0sRUFBRW9MO1lBQ2hELE1BQU0sQ0FBQ2kvQyxjQUFjQyxhQUFhLEdBQUdsL0M7WUFDckNsTyxLQUFLNkMsNkJBQTZCLENBQUNtbUQsTUFBTVcsYUFBYSxFQUFFejdDO1lBQ3hEQSxLQUFLLENBQUMsRUFBRSxJQUFJaS9DO1lBQ1pqL0MsS0FBSyxDQUFDLEVBQUUsSUFBSWsvQztRQUNkLE9BQU87WUFDTHB0RCxLQUFLNkMsNkJBQTZCLENBQUNtbUQsTUFBTVcsYUFBYSxFQUFFejdDO1FBQzFEO1FBQ0EsTUFBTW0vQyx5QkFBeUIsSUFBSSxDQUFDYixpQkFBaUIsQ0FBQ3QrQyxPQUFPKzZDLGFBQWF0QixTQUFTQyxPQUFPLEdBQUcsT0FBTyxJQUFJLENBQUMyRSxXQUFXLEVBQUV2RCxNQUFNTSxjQUFjO1FBQzFJLElBQUlMLGFBQWF0QixTQUFTQyxPQUFPLEVBQUU7WUFDakNyMEMsSUFBSXcyQyxZQUFZLElBQUlmLE1BQU1XLGFBQWE7WUFDdkMsSUFBSSxJQUFJLENBQUM3bUQsTUFBTSxFQUFFO2dCQUNmeVEsSUFBSWhkLFNBQVMsSUFBSSxJQUFJLENBQUN1TSxNQUFNO1lBQzlCO1FBQ0Y7UUFDQXlRLElBQUlzd0IsU0FBUyxDQUFDd3BCLHVCQUF1QmovQyxPQUFPLEVBQUVpL0MsdUJBQXVCaC9DLE9BQU87UUFDNUVrRixJQUFJckYsS0FBSyxDQUFDbS9DLHVCQUF1Qi9DLE1BQU0sRUFBRStDLHVCQUF1QjlDLE1BQU07UUFDdEUsT0FBT2gzQyxJQUFJczJDLGFBQWEsQ0FBQ3dELHVCQUF1Qm52QyxNQUFNLEVBQUU7SUFDMUQ7QUFDRjtBQUNBLE1BQU1vdkMsNEJBQTRCdkY7SUFDaENFLGFBQWE7UUFDWCxPQUFPO0lBQ1Q7QUFDRjtBQUNBLFNBQVNzRixrQkFBa0JwRixFQUFFO0lBQzNCLE9BQVFBLEVBQUUsQ0FBQyxFQUFFO1FBQ1gsS0FBSztZQUNILE9BQU8sSUFBSUQsMEJBQTBCQztRQUN2QyxLQUFLO1lBQ0gsT0FBTyxJQUFJZ0UsbUJBQW1CaEU7UUFDaEMsS0FBSztZQUNILE9BQU8sSUFBSW1GO0lBQ2Y7SUFDQSxNQUFNLElBQUl2MUUsTUFBTSxDQUFDLGlCQUFpQixFQUFFb3dFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUM3QztBQUNBLE1BQU1xRixZQUFZO0lBQ2hCQyxTQUFTO0lBQ1RDLFdBQVc7QUFDYjtBQUNBLE1BQU1DOzthQUNHaEIsbUJBQW1COztJQUMxQjN2RixZQUFZbXJGLEVBQUUsRUFBRTUwQyxHQUFHLEVBQUVxNkMscUJBQXFCLEVBQUVqRSxhQUFhLENBQUU7UUFDekQsSUFBSSxDQUFDLzJDLEtBQUssR0FBR3UxQyxFQUFFLENBQUMsRUFBRTtRQUNsQixJQUFJLENBQUMwRixZQUFZLEdBQUcxRixFQUFFLENBQUMsRUFBRTtRQUN6QixJQUFJLENBQUNybEQsTUFBTSxHQUFHcWxELEVBQUUsQ0FBQyxFQUFFO1FBQ25CLElBQUksQ0FBQ3BSLElBQUksR0FBR29SLEVBQUUsQ0FBQyxFQUFFO1FBQ2pCLElBQUksQ0FBQzJGLEtBQUssR0FBRzNGLEVBQUUsQ0FBQyxFQUFFO1FBQ2xCLElBQUksQ0FBQzRGLEtBQUssR0FBRzVGLEVBQUUsQ0FBQyxFQUFFO1FBQ2xCLElBQUksQ0FBQzZGLFNBQVMsR0FBRzdGLEVBQUUsQ0FBQyxFQUFFO1FBQ3RCLElBQUksQ0FBQzhGLFVBQVUsR0FBRzlGLEVBQUUsQ0FBQyxFQUFFO1FBQ3ZCLElBQUksQ0FBQzUwQyxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDcTZDLHFCQUFxQixHQUFHQTtRQUM3QixJQUFJLENBQUNqRSxhQUFhLEdBQUdBO0lBQ3ZCO0lBQ0F1RSxvQkFBb0JsRixLQUFLLEVBQUVoRixLQUFLLEVBQUU7UUFDaEMsTUFBTSxFQUNKak4sSUFBSSxFQUNKOFcsWUFBWSxFQUNaRyxTQUFTLEVBQ1RDLFVBQVUsRUFDVnI3QyxLQUFLLEVBQ0xnN0MscUJBQXFCLEVBQ3RCLEdBQUcsSUFBSTtRQUNSLElBQUksRUFDRkUsS0FBSyxFQUNMQyxLQUFLLEVBQ04sR0FBRyxJQUFJO1FBQ1JELFFBQVExdEYsS0FBSytMLEdBQUcsQ0FBQzJoRjtRQUNqQkMsUUFBUTN0RixLQUFLK0wsR0FBRyxDQUFDNGhGO1FBQ2pCL3hELEtBQUssaUJBQWlCaXlEO1FBQ3RCLE1BQU1ycUQsS0FBS216QyxJQUFJLENBQUMsRUFBRSxFQUNoQmx6QyxLQUFLa3pDLElBQUksQ0FBQyxFQUFFLEVBQ1pqekMsS0FBS2l6QyxJQUFJLENBQUMsRUFBRSxFQUNaaHpDLEtBQUtnekMsSUFBSSxDQUFDLEVBQUU7UUFDZCxNQUFNaG9DLFFBQVFqTCxLQUFLRjtRQUNuQixNQUFNb0wsU0FBU2pMLEtBQUtGO1FBQ3BCLE1BQU1xSyxRQUFRLElBQUlyNEIsYUFBYTtRQUMvQm1xQixLQUFLNkMsNkJBQTZCLENBQUMsSUFBSSxDQUFDQyxNQUFNLEVBQUVvTDtRQUNoRCxNQUFNLENBQUNpL0MsY0FBY0MsYUFBYSxHQUFHbC9DO1FBQ3JDbE8sS0FBSzZDLDZCQUE2QixDQUFDLElBQUksQ0FBQzhtRCxhQUFhLEVBQUV6N0M7UUFDdkQsTUFBTWlnRCxpQkFBaUJoQixlQUFlai9DLEtBQUssQ0FBQyxFQUFFO1FBQzlDLE1BQU1rZ0QsaUJBQWlCaEIsZUFBZWwvQyxLQUFLLENBQUMsRUFBRTtRQUM5QyxJQUFJbzFDLGNBQWN2MEMsT0FDaEJ3MEMsZUFBZXYwQyxRQUNmcS9DLHFCQUFxQixPQUNyQkMsbUJBQW1CO1FBQ3JCLE1BQU1DLGNBQWNudUYsS0FBS0QsSUFBSSxDQUFDMnRGLFFBQVFLO1FBQ3RDLE1BQU1LLGNBQWNwdUYsS0FBS0QsSUFBSSxDQUFDNHRGLFFBQVFLO1FBQ3RDLE1BQU1LLGVBQWVydUYsS0FBS0QsSUFBSSxDQUFDNHVDLFFBQVFvL0M7UUFDdkMsTUFBTU8sZ0JBQWdCdHVGLEtBQUtELElBQUksQ0FBQzZ1QyxTQUFTby9DO1FBQ3pDLElBQUlHLGVBQWVFLGNBQWM7WUFDL0JuTCxjQUFjd0s7UUFDaEIsT0FBTztZQUNMTyxxQkFBcUI7UUFDdkI7UUFDQSxJQUFJRyxlQUFlRSxlQUFlO1lBQ2hDbkwsZUFBZXdLO1FBQ2pCLE9BQU87WUFDTE8sbUJBQW1CO1FBQ3JCO1FBQ0EsTUFBTUssT0FBTyxJQUFJLENBQUNDLGVBQWUsQ0FBQ3RMLGFBQWEsSUFBSSxDQUFDL3ZDLEdBQUcsQ0FBQzJLLE1BQU0sQ0FBQ25QLEtBQUssRUFBRW8vQztRQUN0RSxNQUFNVSxPQUFPLElBQUksQ0FBQ0QsZUFBZSxDQUFDckwsY0FBYyxJQUFJLENBQUNod0MsR0FBRyxDQUFDMkssTUFBTSxDQUFDbFAsTUFBTSxFQUFFby9DO1FBQ3hFLE1BQU0vRSxZQUFZTCxNQUFNTSxjQUFjLENBQUNDLFNBQVMsQ0FBQyxXQUFXb0YsS0FBSy8vRSxJQUFJLEVBQUVpZ0YsS0FBS2pnRixJQUFJO1FBQ2hGLE1BQU00NkUsU0FBU0gsVUFBVTlrRSxPQUFPO1FBQ2hDLE1BQU11cUUsV0FBV2xCLHNCQUFzQm1CLG9CQUFvQixDQUFDdkYsUUFBUXhGO1FBQ3BFOEssU0FBU0UsVUFBVSxHQUFHaEcsTUFBTWdHLFVBQVU7UUFDdEMsSUFBSSxDQUFDQyw4QkFBOEIsQ0FBQ0gsVUFBVWQsV0FBV3A3QztRQUN6RDQyQyxPQUFPM2xCLFNBQVMsQ0FBQyxDQUFDOHFCLEtBQUt6Z0QsS0FBSyxHQUFHdEssSUFBSSxDQUFDaXJELEtBQUszZ0QsS0FBSyxHQUFHcks7UUFDakRpckQsU0FBU3Y0RCxTQUFTLENBQUMsR0FBR280RCxLQUFLemdELEtBQUssRUFBRSxHQUFHLEdBQUcyZ0QsS0FBSzNnRCxLQUFLLEVBQUUsR0FBRztRQUN2RHM3QyxPQUFPbnpELElBQUk7UUFDWHk0RCxTQUFTMUgsaUJBQWlCLEVBQUUvd0Q7UUFDNUIsSUFBSSxDQUFDNjRELFFBQVEsQ0FBQ0osVUFBVWxyRCxJQUFJQyxJQUFJQyxJQUFJQztRQUNwQytxRCxTQUFTbkYsYUFBYSxHQUFHcjJDLG9CQUFvQnc3QyxTQUFTdjdDLEdBQUc7UUFDekR1N0MsU0FBU0ssbUJBQW1CLENBQUN0QjtRQUM3QmlCLFNBQVNNLFVBQVU7UUFDbkJOLFNBQVMxSCxpQkFBaUIsRUFBRTl3RDtRQUM1Qmt6RCxPQUFPbHpELE9BQU87UUFDZCxJQUFJKzNELHNCQUFzQkMsa0JBQWtCO1lBQzFDLE1BQU1qd0MsUUFBUWdyQyxVQUFVbnJDLE1BQU07WUFDOUIsSUFBSW13QyxvQkFBb0I7Z0JBQ3RCL0ssY0FBY3dLO1lBQ2hCO1lBQ0EsSUFBSVEsa0JBQWtCO2dCQUNwQi9LLGVBQWV3SztZQUNqQjtZQUNBLE1BQU1zQixRQUFRLElBQUksQ0FBQ1QsZUFBZSxDQUFDdEwsYUFBYSxJQUFJLENBQUMvdkMsR0FBRyxDQUFDMkssTUFBTSxDQUFDblAsS0FBSyxFQUFFby9DO1lBQ3ZFLE1BQU1tQixRQUFRLElBQUksQ0FBQ1YsZUFBZSxDQUFDckwsY0FBYyxJQUFJLENBQUNod0MsR0FBRyxDQUFDMkssTUFBTSxDQUFDbFAsTUFBTSxFQUFFby9DO1lBQ3pFLE1BQU1tQixRQUFRRixNQUFNemdGLElBQUk7WUFDeEIsTUFBTTRnRixRQUFRRixNQUFNMWdGLElBQUk7WUFDeEIsTUFBTTZnRixhQUFhekcsTUFBTU0sY0FBYyxDQUFDQyxTQUFTLENBQUMsc0JBQXNCZ0csT0FBT0M7WUFDL0UsTUFBTUUsVUFBVUQsV0FBV2xyRSxPQUFPO1lBQ2xDLE1BQU1paEIsS0FBSzZvRCxxQkFBcUJqdUYsS0FBS0MsS0FBSyxDQUFDMHVDLFFBQVErK0MsU0FBUztZQUM1RCxNQUFNNkIsS0FBS3JCLG1CQUFtQmx1RixLQUFLQyxLQUFLLENBQUMydUMsU0FBUysrQyxTQUFTO1lBQzNELElBQUssSUFBSXh2RixJQUFJLEdBQUdBLEtBQUtpbkMsSUFBSWpuQyxJQUFLO2dCQUM1QixJQUFLLElBQUlzUCxJQUFJLEdBQUdBLEtBQUs4aEYsSUFBSTloRixJQUFLO29CQUM1QjZoRixRQUFRbHhDLFNBQVMsQ0FBQ0gsT0FBT2t4QyxRQUFRaHhGLEdBQUdpeEYsUUFBUTNoRixHQUFHMGhGLE9BQU9DLE9BQU8sR0FBRyxHQUFHRCxPQUFPQztnQkFDNUU7WUFDRjtZQUNBLE9BQU87Z0JBQ0x0eEMsUUFBUXV4QyxXQUFXdnhDLE1BQU07Z0JBQ3pCb3NDLFFBQVErRSxNQUFNbmhELEtBQUs7Z0JBQ25CcThDLFFBQVErRSxNQUFNcGhELEtBQUs7Z0JBQ25CRSxTQUFTeEs7Z0JBQ1R5SyxTQUFTeEs7WUFDWDtRQUNGO1FBQ0EsT0FBTztZQUNMcWEsUUFBUW1yQyxVQUFVbnJDLE1BQU07WUFDeEJvc0MsUUFBUXFFLEtBQUt6Z0QsS0FBSztZQUNsQnE4QyxRQUFRc0UsS0FBSzNnRCxLQUFLO1lBQ2xCRSxTQUFTeEs7WUFDVHlLLFNBQVN4SztRQUNYO0lBQ0Y7SUFDQStxRCxnQkFBZ0IvdkYsSUFBSSxFQUFFK3dGLGNBQWMsRUFBRTFoRCxLQUFLLEVBQUU7UUFDM0MsTUFBTXlTLFVBQVV2Z0QsS0FBSzRQLEdBQUcsQ0FBQzI5RSxjQUFjaEIsZ0JBQWdCLEVBQUVpRDtRQUN6RCxJQUFJaGhGLE9BQU94TyxLQUFLRCxJQUFJLENBQUN0QixPQUFPcXZDO1FBQzVCLElBQUl0L0IsUUFBUSt4QyxTQUFTO1lBQ25CL3hDLE9BQU8reEM7UUFDVCxPQUFPO1lBQ0x6UyxRQUFRdC9CLE9BQU8vUDtRQUNqQjtRQUNBLE9BQU87WUFDTHF2QztZQUNBdC9CO1FBQ0Y7SUFDRjtJQUNBc2dGLFNBQVNKLFFBQVEsRUFBRWxyRCxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUU7UUFDakMsTUFBTThyRCxZQUFZL3JELEtBQUtGO1FBQ3ZCLE1BQU1rc0QsYUFBYS9yRCxLQUFLRjtRQUN4QmlyRCxTQUFTdjdDLEdBQUcsQ0FBQzdSLElBQUksQ0FBQ2tDLElBQUlDLElBQUlnc0QsV0FBV0M7UUFDckM5dkQsS0FBS3lCLHVCQUF1QixDQUFDO1lBQUNtQztZQUFJQztZQUFJQztZQUFJQztTQUFHLEVBQUV1UCxvQkFBb0J3N0MsU0FBU3Y3QyxHQUFHLEdBQUd1N0MsU0FBU2wzRSxPQUFPLENBQUMyb0IsTUFBTTtRQUN6R3V1RCxTQUFTdDNELElBQUk7UUFDYnMzRCxTQUFTdjNELE9BQU87SUFDbEI7SUFDQTAzRCwrQkFBK0JILFFBQVEsRUFBRWQsU0FBUyxFQUFFcDdDLEtBQUssRUFBRTtRQUN6RCxNQUFNcnVCLFVBQVV1cUUsU0FBU3Y3QyxHQUFHLEVBQzFCMzdCLFVBQVVrM0UsU0FBU2wzRSxPQUFPO1FBQzVCLE9BQVFvMkU7WUFDTixLQUFLUixVQUFVQyxPQUFPO2dCQUNwQixNQUFNLEVBQ0o3RCxTQUFTLEVBQ1RtRyxXQUFXLEVBQ1osR0FBRyxJQUFJLENBQUN4OEMsR0FBRztnQkFDWmh2QixRQUFRcWxFLFNBQVMsR0FBR2h5RSxRQUFRbzRFLFNBQVMsR0FBR3BHO2dCQUN4Q3JsRSxRQUFRd3JFLFdBQVcsR0FBR240RSxRQUFRcTRFLFdBQVcsR0FBR0Y7Z0JBQzVDO1lBQ0YsS0FBS3ZDLFVBQVVFLFNBQVM7Z0JBQ3RCbnBFLFFBQVFxbEUsU0FBUyxHQUFHcmxFLFFBQVF3ckUsV0FBVyxHQUFHbjlDO2dCQUMxQ2g3QixRQUFRbzRFLFNBQVMsR0FBR3A0RSxRQUFRcTRFLFdBQVcsR0FBR3I5QztnQkFDMUM7WUFDRjtnQkFDRSxNQUFNLElBQUk1VSxZQUFZLENBQUMsd0JBQXdCLEVBQUVnd0QsVUFBVSxDQUFDO1FBQ2hFO0lBQ0Y7SUFDQWhHLDhCQUE4QjtRQUM1QixPQUFPO0lBQ1Q7SUFDQUMsV0FBVzEwQyxHQUFHLEVBQUV5MUMsS0FBSyxFQUFFcitFLE9BQU8sRUFBRXMrRSxRQUFRLEVBQUVqRixLQUFLLEVBQUU7UUFDL0MsSUFBSWxoRCxTQUFTbjRCO1FBQ2IsSUFBSXMrRSxhQUFhdEIsU0FBU0MsT0FBTyxFQUFFO1lBQ2pDOWtELFNBQVM5QyxLQUFLekosU0FBUyxDQUFDdU0sUUFBUWttRCxNQUFNVyxhQUFhO1lBQ25ELElBQUksSUFBSSxDQUFDN21ELE1BQU0sRUFBRTtnQkFDZkEsU0FBUzlDLEtBQUt6SixTQUFTLENBQUN1TSxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUM3QztRQUNGO1FBQ0EsTUFBTXVxRCx5QkFBeUIsSUFBSSxDQUFDYSxtQkFBbUIsQ0FBQ2xGLE9BQU9oRjtRQUMvRCxJQUFJOEYsWUFBWSxJQUFJOUksVUFBVWwrQztRQUM5QmduRCxZQUFZQSxVQUFVam1CLFNBQVMsQ0FBQ3dwQix1QkFBdUJqL0MsT0FBTyxFQUFFaS9DLHVCQUF1QmgvQyxPQUFPO1FBQzlGeTdDLFlBQVlBLFVBQVU1N0MsS0FBSyxDQUFDLElBQUltL0MsdUJBQXVCL0MsTUFBTSxFQUFFLElBQUkrQyx1QkFBdUI5QyxNQUFNO1FBQ2hHLE1BQU1yQixVQUFVMzFDLElBQUlzMkMsYUFBYSxDQUFDd0QsdUJBQXVCbnZDLE1BQU0sRUFBRTtRQUNqRWdyQyxRQUFRYSxZQUFZLENBQUNEO1FBQ3JCLE9BQU9aO0lBQ1Q7QUFDRjtFQUVDLDhCQUE4QjtBQU0vQixTQUFTZ0gsY0FBY3I4RSxNQUFNO0lBQzNCLE9BQVFBLE9BQU8vUSxJQUFJO1FBQ2pCLEtBQUtxdEYsVUFBVTUvRCxjQUFjO1lBQzNCLE9BQU82L0QsMkJBQTJCdjhFO1FBQ3BDLEtBQUtzOEUsVUFBVTMvRCxTQUFTO1lBQ3RCLE9BQU82L0QsaUJBQWlCeDhFO0lBQzVCO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBU3U4RSwyQkFBMkIsRUFDbEMzb0YsR0FBRyxFQUNINm9GLFNBQVMsQ0FBQyxFQUNWNW9ELElBQUksRUFDSnFILEtBQUssRUFDTEMsTUFBTSxFQUNOdWhELGdCQUFnQixVQUFVLEVBQzFCQyxnQkFBZ0IsS0FBSyxFQUN0QjtJQUNDLE1BQU1uYSxRQUFRcjNDLGlCQUFpQkosY0FBYyxHQUFHLGFBQWE7SUFDN0QsTUFBTSxDQUFDNnhELGFBQWFDLFdBQVcsR0FBR0YsZ0JBQWdCO1FBQUNEO1FBQWVsYTtLQUFNLEdBQUc7UUFBQ0E7UUFBT2thO0tBQWM7SUFDakcsTUFBTUksZ0JBQWdCNWhELFNBQVM7SUFDL0IsTUFBTTZoRCxpQkFBaUI3aEQsUUFBUTtJQUMvQixNQUFNOGhELFlBQVlwcEYsSUFBSTdOLE1BQU07SUFDNUI4dEMsT0FBTyxJQUFJOXhCLFlBQVk4eEIsS0FBS3BwQyxNQUFNO0lBQ2xDLElBQUl3eUYsVUFBVTtJQUNkLElBQUssSUFBSXZ5RixJQUFJLEdBQUdBLElBQUl5d0MsUUFBUXp3QyxJQUFLO1FBQy9CLElBQUssTUFBTXlSLE1BQU1zZ0YsU0FBU0ssZUFBZUwsU0FBU3RnRixLQUFLc2dGLFNBQVU7WUFDL0QsTUFBTVMsT0FBT1QsU0FBU08sWUFBWXBwRixHQUFHLENBQUM2b0YsT0FBTyxHQUFHO1lBQ2hENW9ELElBQUksQ0FBQ29wRCxVQUFVLEdBQUdDLE9BQU8sTUFBYUwsYUFBYUQ7WUFDbkQvb0QsSUFBSSxDQUFDb3BELFVBQVUsR0FBR0MsT0FBTyxLQUFZTCxhQUFhRDtZQUNsRC9vRCxJQUFJLENBQUNvcEQsVUFBVSxHQUFHQyxPQUFPLEtBQVdMLGFBQWFEO1lBQ2pEL29ELElBQUksQ0FBQ29wRCxVQUFVLEdBQUdDLE9BQU8sS0FBVUwsYUFBYUQ7WUFDaEQvb0QsSUFBSSxDQUFDb3BELFVBQVUsR0FBR0MsT0FBTyxJQUFTTCxhQUFhRDtZQUMvQy9vRCxJQUFJLENBQUNvcEQsVUFBVSxHQUFHQyxPQUFPLElBQVFMLGFBQWFEO1lBQzlDL29ELElBQUksQ0FBQ29wRCxVQUFVLEdBQUdDLE9BQU8sSUFBT0wsYUFBYUQ7WUFDN0Mvb0QsSUFBSSxDQUFDb3BELFVBQVUsR0FBR0MsT0FBTyxJQUFNTCxhQUFhRDtRQUM5QztRQUNBLElBQUlHLG1CQUFtQixHQUFHO1lBQ3hCO1FBQ0Y7UUFDQSxNQUFNRyxPQUFPVCxTQUFTTyxZQUFZcHBGLEdBQUcsQ0FBQzZvRixTQUFTLEdBQUc7UUFDbEQsSUFBSyxJQUFJemlGLElBQUksR0FBR0EsSUFBSStpRixnQkFBZ0IvaUYsSUFBSztZQUN2QzY1QixJQUFJLENBQUNvcEQsVUFBVSxHQUFHQyxPQUFPLEtBQUssSUFBSWxqRixJQUFJNmlGLGFBQWFEO1FBQ3JEO0lBQ0Y7SUFDQSxPQUFPO1FBQ0xIO1FBQ0FRO0lBQ0Y7QUFDRjtBQUNBLFNBQVNULGlCQUFpQixFQUN4QjVvRixHQUFHLEVBQ0g2b0YsU0FBUyxDQUFDLEVBQ1Y1b0QsSUFBSSxFQUNKb3BELFVBQVUsQ0FBQyxFQUNYL2hELEtBQUssRUFDTEMsTUFBTSxFQUNQO0lBQ0MsSUFBSXp3QyxJQUFJO0lBQ1IsTUFBTXFTLE1BQU1tK0IsUUFBUUMsU0FBUztJQUM3QixNQUFNZ2lELFFBQVFwZ0YsT0FBTztJQUNyQixNQUFNcWdGLFFBQVEsSUFBSXI3RSxZQUFZbk8sSUFBSW5KLE1BQU0sRUFBRWd5RixRQUFRVTtJQUNsRCxJQUFJRSxZQUFZdHlELGNBQWMsRUFBRTtRQUM5QixNQUFPcmdDLElBQUl5eUYsUUFBUSxHQUFHenlGLEtBQUssR0FBR3V5RixXQUFXLEVBQUc7WUFDMUMsTUFBTUssS0FBS0YsS0FBSyxDQUFDMXlGLEVBQUU7WUFDbkIsTUFBTTZ5RixLQUFLSCxLQUFLLENBQUMxeUYsSUFBSSxFQUFFO1lBQ3ZCLE1BQU04eUYsS0FBS0osS0FBSyxDQUFDMXlGLElBQUksRUFBRTtZQUN2Qm1wQyxJQUFJLENBQUNvcEQsUUFBUSxHQUFHSyxLQUFLO1lBQ3JCenBELElBQUksQ0FBQ29wRCxVQUFVLEVBQUUsR0FBR0ssT0FBTyxLQUFLQyxNQUFNLElBQUk7WUFDMUMxcEQsSUFBSSxDQUFDb3BELFVBQVUsRUFBRSxHQUFHTSxPQUFPLEtBQUtDLE1BQU0sS0FBSztZQUMzQzNwRCxJQUFJLENBQUNvcEQsVUFBVSxFQUFFLEdBQUdPLE9BQU8sSUFBSTtRQUNqQztRQUNBLElBQUssSUFBSXhqRixJQUFJdFAsSUFBSSxHQUFHb3hGLEtBQUtXLFNBQVMxL0UsS0FBSy9DLElBQUk4aEYsSUFBSTloRixLQUFLLEVBQUc7WUFDckQ2NUIsSUFBSSxDQUFDb3BELFVBQVUsR0FBR3JwRixHQUFHLENBQUNvRyxFQUFFLEdBQUdwRyxHQUFHLENBQUNvRyxJQUFJLEVBQUUsSUFBSSxJQUFJcEcsR0FBRyxDQUFDb0csSUFBSSxFQUFFLElBQUksS0FBSztRQUNsRTtJQUNGLE9BQU87UUFDTCxNQUFPdFAsSUFBSXl5RixRQUFRLEdBQUd6eUYsS0FBSyxHQUFHdXlGLFdBQVcsRUFBRztZQUMxQyxNQUFNSyxLQUFLRixLQUFLLENBQUMxeUYsRUFBRTtZQUNuQixNQUFNNnlGLEtBQUtILEtBQUssQ0FBQzF5RixJQUFJLEVBQUU7WUFDdkIsTUFBTTh5RixLQUFLSixLQUFLLENBQUMxeUYsSUFBSSxFQUFFO1lBQ3ZCbXBDLElBQUksQ0FBQ29wRCxRQUFRLEdBQUdLLEtBQUs7WUFDckJ6cEQsSUFBSSxDQUFDb3BELFVBQVUsRUFBRSxHQUFHSyxNQUFNLEtBQUtDLE9BQU8sSUFBSTtZQUMxQzFwRCxJQUFJLENBQUNvcEQsVUFBVSxFQUFFLEdBQUdNLE1BQU0sS0FBS0MsT0FBTyxLQUFLO1lBQzNDM3BELElBQUksQ0FBQ29wRCxVQUFVLEVBQUUsR0FBR08sTUFBTSxJQUFJO1FBQ2hDO1FBQ0EsSUFBSyxJQUFJeGpGLElBQUl0UCxJQUFJLEdBQUdveEYsS0FBS1csU0FBUzEvRSxLQUFLL0MsSUFBSThoRixJQUFJOWhGLEtBQUssRUFBRztZQUNyRDY1QixJQUFJLENBQUNvcEQsVUFBVSxHQUFHcnBGLEdBQUcsQ0FBQ29HLEVBQUUsSUFBSSxLQUFLcEcsR0FBRyxDQUFDb0csSUFBSSxFQUFFLElBQUksS0FBS3BHLEdBQUcsQ0FBQ29HLElBQUksRUFBRSxJQUFJLElBQUk7UUFDeEU7SUFDRjtJQUNBLE9BQU87UUFDTHlpRixRQUFRQSxTQUFTMS9FO1FBQ2pCa2dGO0lBQ0Y7QUFDRjtBQUNBLFNBQVNRLFdBQVc3cEYsR0FBRyxFQUFFaWdDLElBQUk7SUFDM0IsSUFBSXdwRCxZQUFZdHlELGNBQWMsRUFBRTtRQUM5QixJQUFLLElBQUlyZ0MsSUFBSSxHQUFHaW5DLEtBQUsvOUIsSUFBSTdOLE1BQU0sRUFBRTJFLElBQUlpbkMsSUFBSWpuQyxJQUFLO1lBQzVDbXBDLElBQUksQ0FBQ25wQyxFQUFFLEdBQUdrSixHQUFHLENBQUNsSixFQUFFLEdBQUcsVUFBVTtRQUMvQjtJQUNGLE9BQU87UUFDTCxJQUFLLElBQUlBLElBQUksR0FBR2luQyxLQUFLLzlCLElBQUk3TixNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsSUFBSztZQUM1Q21wQyxJQUFJLENBQUNucEMsRUFBRSxHQUFHa0osR0FBRyxDQUFDbEosRUFBRSxHQUFHLFlBQVk7UUFDakM7SUFDRjtBQUNGO0VBRUMsMEJBQTBCO0FBYzNCLE1BQU1nekYsZ0JBQWdCO0FBQ3RCLE1BQU1DLGdCQUFnQjtBQUN0QixNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1DLG9CQUFvQjtBQUMxQixNQUFNQyxlQUFlLElBQUk1UTtBQUN6QixNQUFNNlEsS0FBSyxJQUFJaDhFLGFBQWE7QUFDNUIsTUFBTWk4RSxlQUFlLElBQUlqOEUsYUFBYTtJQUFDN0o7SUFBVUE7SUFBVSxDQUFDQTtJQUFVLENBQUNBO0NBQVM7QUFDaEYsU0FBUytsRix3QkFBd0J4K0MsR0FBRyxFQUFFeStDLE9BQU87SUFDM0MsSUFBSXorQyxJQUFJMCtDLGdCQUFnQixFQUFFO1FBQ3hCLE1BQU0sSUFBSWw2RSxNQUFNO0lBQ2xCO0lBQ0F3N0IsSUFBSTIrQyxjQUFjLEdBQUczK0MsSUFBSWxkLElBQUk7SUFDN0JrZCxJQUFJNCtDLGlCQUFpQixHQUFHNStDLElBQUlqZCxPQUFPO0lBQ25DaWQsSUFBSTYrQyxnQkFBZ0IsR0FBRzcrQyxJQUFJODRCLE1BQU07SUFDakM5NEIsSUFBSTgrQyxlQUFlLEdBQUc5K0MsSUFBSXJGLEtBQUs7SUFDL0JxRixJQUFJKytDLG1CQUFtQixHQUFHLytDLElBQUlzd0IsU0FBUztJQUN2Q3R3QixJQUFJZy9DLG1CQUFtQixHQUFHaC9DLElBQUloZCxTQUFTO0lBQ3ZDZ2QsSUFBSWkvQyxzQkFBc0IsR0FBR2ovQyxJQUFJdzJDLFlBQVk7SUFDN0N4MkMsSUFBSWsvQyx3QkFBd0IsR0FBR2wvQyxJQUFJbS9DLGNBQWM7SUFDakRuL0MsSUFBSW8vQyxjQUFjLEdBQUdwL0MsSUFBSS9iLElBQUk7SUFDN0IrYixJQUFJcS9DLGdCQUFnQixHQUFHci9DLElBQUkvYyxNQUFNO0lBQ2pDK2MsSUFBSXMvQyxnQkFBZ0IsR0FBR3QvQyxJQUFJOWMsTUFBTTtJQUNqQzhjLElBQUl1L0MsdUJBQXVCLEdBQUd2L0MsSUFBSXcvQyxhQUFhO0lBQy9DeC9DLElBQUl5L0MsY0FBYyxHQUFHei9DLElBQUk3UixJQUFJO0lBQzdCNlIsSUFBSTAvQyxtQkFBbUIsR0FBRzEvQyxJQUFJMWMsU0FBUztJQUN2QzBjLElBQUkyL0MsbUJBQW1CLEdBQUczL0MsSUFBSW0yQyxTQUFTO0lBQ3ZDbjJDLElBQUkwK0MsZ0JBQWdCLEdBQUc7UUFDckIxK0MsSUFBSWxkLElBQUksR0FBR2tkLElBQUkyK0MsY0FBYztRQUM3QjMrQyxJQUFJamQsT0FBTyxHQUFHaWQsSUFBSTQrQyxpQkFBaUI7UUFDbkM1K0MsSUFBSTg0QixNQUFNLEdBQUc5NEIsSUFBSTYrQyxnQkFBZ0I7UUFDakM3K0MsSUFBSXJGLEtBQUssR0FBR3FGLElBQUk4K0MsZUFBZTtRQUMvQjkrQyxJQUFJc3dCLFNBQVMsR0FBR3R3QixJQUFJKytDLG1CQUFtQjtRQUN2Qy8rQyxJQUFJaGQsU0FBUyxHQUFHZ2QsSUFBSWcvQyxtQkFBbUI7UUFDdkNoL0MsSUFBSXcyQyxZQUFZLEdBQUd4MkMsSUFBSWkvQyxzQkFBc0I7UUFDN0NqL0MsSUFBSW0vQyxjQUFjLEdBQUduL0MsSUFBSWsvQyx3QkFBd0I7UUFDakRsL0MsSUFBSS9iLElBQUksR0FBRytiLElBQUlvL0MsY0FBYztRQUM3QnAvQyxJQUFJL2MsTUFBTSxHQUFHK2MsSUFBSXEvQyxnQkFBZ0I7UUFDakNyL0MsSUFBSTljLE1BQU0sR0FBRzhjLElBQUlzL0MsZ0JBQWdCO1FBQ2pDdC9DLElBQUl3L0MsYUFBYSxHQUFHeC9DLElBQUl1L0MsdUJBQXVCO1FBQy9Ddi9DLElBQUk3UixJQUFJLEdBQUc2UixJQUFJeS9DLGNBQWM7UUFDN0J6L0MsSUFBSTFjLFNBQVMsR0FBRzBjLElBQUkwL0MsbUJBQW1CO1FBQ3ZDMS9DLElBQUltMkMsU0FBUyxHQUFHbjJDLElBQUkyL0MsbUJBQW1CO1FBQ3ZDLE9BQU8zL0MsSUFBSTArQyxnQkFBZ0I7SUFDN0I7SUFDQTErQyxJQUFJbGQsSUFBSSxHQUFHO1FBQ1QyN0QsUUFBUTM3RCxJQUFJO1FBQ1osSUFBSSxDQUFDNjdELGNBQWM7SUFDckI7SUFDQTMrQyxJQUFJamQsT0FBTyxHQUFHO1FBQ1owN0QsUUFBUTE3RCxPQUFPO1FBQ2YsSUFBSSxDQUFDNjdELGlCQUFpQjtJQUN4QjtJQUNBNStDLElBQUlzd0IsU0FBUyxHQUFHLFNBQVV0akUsQ0FBQyxFQUFFME0sQ0FBQztRQUM1QitrRixRQUFRbnVCLFNBQVMsQ0FBQ3RqRSxHQUFHME07UUFDckIsSUFBSSxDQUFDcWxGLG1CQUFtQixDQUFDL3hGLEdBQUcwTTtJQUM5QjtJQUNBc21DLElBQUlyRixLQUFLLEdBQUcsU0FBVTN0QyxDQUFDLEVBQUUwTSxDQUFDO1FBQ3hCK2tGLFFBQVE5akQsS0FBSyxDQUFDM3RDLEdBQUcwTTtRQUNqQixJQUFJLENBQUNvbEYsZUFBZSxDQUFDOXhGLEdBQUcwTTtJQUMxQjtJQUNBc21DLElBQUloZCxTQUFTLEdBQUcsU0FBVXRaLENBQUMsRUFBRUMsQ0FBQyxFQUFFckQsQ0FBQyxFQUFFbVIsQ0FBQyxFQUFFNWIsQ0FBQyxFQUFFckwsQ0FBQztRQUN4Q2l1RixRQUFRejdELFNBQVMsQ0FBQ3RaLEdBQUdDLEdBQUdyRCxHQUFHbVIsR0FBRzViLEdBQUdyTDtRQUNqQyxJQUFJLENBQUN3dUYsbUJBQW1CLENBQUN0MUUsR0FBR0MsR0FBR3JELEdBQUdtUixHQUFHNWIsR0FBR3JMO0lBQzFDO0lBQ0F3dkMsSUFBSXcyQyxZQUFZLEdBQUcsU0FBVTlzRSxDQUFDLEVBQUVDLENBQUMsRUFBRXJELENBQUMsRUFBRW1SLENBQUMsRUFBRTViLENBQUMsRUFBRXJMLENBQUM7UUFDM0NpdUYsUUFBUWpJLFlBQVksQ0FBQzlzRSxHQUFHQyxHQUFHckQsR0FBR21SLEdBQUc1YixHQUFHckw7UUFDcEMsSUFBSSxDQUFDeXVGLHNCQUFzQixDQUFDdjFFLEdBQUdDLEdBQUdyRCxHQUFHbVIsR0FBRzViLEdBQUdyTDtJQUM3QztJQUNBd3ZDLElBQUltL0MsY0FBYyxHQUFHO1FBQ25CVixRQUFRVSxjQUFjO1FBQ3RCLElBQUksQ0FBQ0Qsd0JBQXdCO0lBQy9CO0lBQ0FsL0MsSUFBSTg0QixNQUFNLEdBQUcsU0FBVXpILEtBQUs7UUFDMUJvdEIsUUFBUTNsQixNQUFNLENBQUN6SDtRQUNmLElBQUksQ0FBQ3d0QixnQkFBZ0IsQ0FBQ3h0QjtJQUN4QjtJQUNBcnhCLElBQUkvYixJQUFJLEdBQUcsU0FBVTA2QyxJQUFJO1FBQ3ZCOGYsUUFBUXg2RCxJQUFJLENBQUMwNkM7UUFDYixJQUFJLENBQUN5Z0IsY0FBYyxDQUFDemdCO0lBQ3RCO0lBQ0EzK0IsSUFBSS9jLE1BQU0sR0FBRyxTQUFVajJCLENBQUMsRUFBRTBNLENBQUM7UUFDekIra0YsUUFBUXg3RCxNQUFNLENBQUNqMkIsR0FBRzBNO1FBQ2xCLElBQUksQ0FBQzJsRixnQkFBZ0IsQ0FBQ3J5RixHQUFHME07SUFDM0I7SUFDQXNtQyxJQUFJOWMsTUFBTSxHQUFHLFNBQVVsMkIsQ0FBQyxFQUFFME0sQ0FBQztRQUN6QitrRixRQUFRdjdELE1BQU0sQ0FBQ2wyQixHQUFHME07UUFDbEIsSUFBSSxDQUFDNGxGLGdCQUFnQixDQUFDdHlGLEdBQUcwTTtJQUMzQjtJQUNBc21DLElBQUl3L0MsYUFBYSxHQUFHLFNBQVVJLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRS95RixDQUFDLEVBQUUwTSxDQUFDO1FBQ3hEK2tGLFFBQVFlLGFBQWEsQ0FBQ0ksTUFBTUMsTUFBTUMsTUFBTUMsTUFBTS95RixHQUFHME07UUFDakQsSUFBSSxDQUFDNmxGLHVCQUF1QixDQUFDSyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNL3lGLEdBQUcwTTtJQUMxRDtJQUNBc21DLElBQUk3UixJQUFJLEdBQUcsU0FBVW5oQyxDQUFDLEVBQUUwTSxDQUFDLEVBQUU4aEMsS0FBSyxFQUFFQyxNQUFNO1FBQ3RDZ2pELFFBQVF0d0QsSUFBSSxDQUFDbmhDLEdBQUcwTSxHQUFHOGhDLE9BQU9DO1FBQzFCLElBQUksQ0FBQ2drRCxjQUFjLENBQUN6eUYsR0FBRzBNLEdBQUc4aEMsT0FBT0M7SUFDbkM7SUFDQXVFLElBQUkxYyxTQUFTLEdBQUc7UUFDZG03RCxRQUFRbjdELFNBQVM7UUFDakIsSUFBSSxDQUFDbzhELG1CQUFtQjtJQUMxQjtJQUNBMS9DLElBQUltMkMsU0FBUyxHQUFHO1FBQ2RzSSxRQUFRdEksU0FBUztRQUNqQixJQUFJLENBQUN3SixtQkFBbUI7SUFDMUI7QUFDRjtBQUNBLE1BQU1LO0lBQ0p2MkYsWUFBWXcyRixhQUFhLENBQUU7UUFDekIsSUFBSSxDQUFDQSxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ3oxQyxLQUFLLEdBQUc5aEQsT0FBTytMLE1BQU0sQ0FBQztJQUM3QjtJQUNBdWhGLFVBQVVoN0UsRUFBRSxFQUFFd2dDLEtBQUssRUFBRUMsTUFBTSxFQUFFO1FBQzNCLElBQUl5a0Q7UUFDSixJQUFJLElBQUksQ0FBQzExQyxLQUFLLENBQUN4dkMsR0FBRyxLQUFLcFIsV0FBVztZQUNoQ3MyRixjQUFjLElBQUksQ0FBQzExQyxLQUFLLENBQUN4dkMsR0FBRztZQUM1QixJQUFJLENBQUNpbEYsYUFBYSxDQUFDbFgsS0FBSyxDQUFDbVgsYUFBYTFrRCxPQUFPQztRQUMvQyxPQUFPO1lBQ0x5a0QsY0FBYyxJQUFJLENBQUNELGFBQWEsQ0FBQ3hyRixNQUFNLENBQUMrbUMsT0FBT0M7WUFDL0MsSUFBSSxDQUFDK08sS0FBSyxDQUFDeHZDLEdBQUcsR0FBR2tsRjtRQUNuQjtRQUNBLE9BQU9BO0lBQ1Q7SUFDQXI0QyxPQUFPN3NDLEVBQUUsRUFBRTtRQUNULE9BQU8sSUFBSSxDQUFDd3ZDLEtBQUssQ0FBQ3h2QyxHQUFHO0lBQ3ZCO0lBQ0E2UyxRQUFRO1FBQ04sSUFBSyxNQUFNN1MsTUFBTSxJQUFJLENBQUN3dkMsS0FBSyxDQUFFO1lBQzNCLE1BQU0wMUMsY0FBYyxJQUFJLENBQUMxMUMsS0FBSyxDQUFDeHZDLEdBQUc7WUFDbEMsSUFBSSxDQUFDaWxGLGFBQWEsQ0FBQzkyQyxPQUFPLENBQUMrMkM7WUFDM0IsT0FBTyxJQUFJLENBQUMxMUMsS0FBSyxDQUFDeHZDLEdBQUc7UUFDdkI7SUFDRjtBQUNGO0FBQ0EsU0FBU21sRix5QkFBeUJuZ0QsR0FBRyxFQUFFb2dELE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxLQUFLO0lBQy9GLE1BQU0sQ0FBQ2wzRSxHQUFHQyxHQUFHckQsR0FBR21SLEdBQUdpckMsSUFBSUMsR0FBRyxHQUFHNWlCLG9CQUFvQkM7SUFDakQsSUFBSXIyQixNQUFNLEtBQUtyRCxNQUFNLEdBQUc7UUFDdEIsTUFBTXU2RSxNQUFNSixRQUFRLzJFLElBQUlnNUM7UUFDeEIsTUFBTW8rQixPQUFPajBGLEtBQUs2MUMsS0FBSyxDQUFDbStDO1FBQ3hCLE1BQU1FLE1BQU1MLFFBQVFqcEUsSUFBSWtyQztRQUN4QixNQUFNcStCLE9BQU9uMEYsS0FBSzYxQyxLQUFLLENBQUNxK0M7UUFDeEIsTUFBTUUsTUFBTSxDQUFDUixRQUFRRSxLQUFJLElBQUtqM0UsSUFBSWc1QztRQUNsQyxNQUFNdytCLFNBQVNyMEYsS0FBSytMLEdBQUcsQ0FBQy9MLEtBQUs2MUMsS0FBSyxDQUFDdStDLE9BQU9ILFNBQVM7UUFDbkQsTUFBTUssTUFBTSxDQUFDVCxRQUFRRSxLQUFJLElBQUtucEUsSUFBSWtyQztRQUNsQyxNQUFNeStCLFVBQVV2MEYsS0FBSytMLEdBQUcsQ0FBQy9MLEtBQUs2MUMsS0FBSyxDQUFDeStDLE9BQU9ILFNBQVM7UUFDcERoaEQsSUFBSXcyQyxZQUFZLENBQUMzcEYsS0FBSzBOLElBQUksQ0FBQ21QLElBQUksR0FBRyxHQUFHN2MsS0FBSzBOLElBQUksQ0FBQ2tkLElBQUlxcEUsTUFBTUU7UUFDekRoaEQsSUFBSWlMLFNBQVMsQ0FBQ20xQyxRQUFRQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNLEdBQUcsR0FBR1UsUUFBUUU7UUFDNURwaEQsSUFBSXcyQyxZQUFZLENBQUM5c0UsR0FBR0MsR0FBR3JELEdBQUdtUixHQUFHaXJDLElBQUlDO1FBQ2pDLE9BQU87WUFBQ3UrQjtZQUFRRTtTQUFRO0lBQzFCO0lBQ0EsSUFBSTEzRSxNQUFNLEtBQUsrTixNQUFNLEdBQUc7UUFDdEIsTUFBTW9wRSxNQUFNSCxRQUFRcDZFLElBQUlvOEM7UUFDeEIsTUFBTW8rQixPQUFPajBGLEtBQUs2MUMsS0FBSyxDQUFDbStDO1FBQ3hCLE1BQU1FLE1BQU1OLFFBQVE5MkUsSUFBSWc1QztRQUN4QixNQUFNcStCLE9BQU9uMEYsS0FBSzYxQyxLQUFLLENBQUNxK0M7UUFDeEIsTUFBTUUsTUFBTSxDQUFDUCxRQUFRRSxLQUFJLElBQUt0NkUsSUFBSW84QztRQUNsQyxNQUFNdytCLFNBQVNyMEYsS0FBSytMLEdBQUcsQ0FBQy9MLEtBQUs2MUMsS0FBSyxDQUFDdStDLE9BQU9ILFNBQVM7UUFDbkQsTUFBTUssTUFBTSxDQUFDVixRQUFRRSxLQUFJLElBQUtoM0UsSUFBSWc1QztRQUNsQyxNQUFNeStCLFVBQVV2MEYsS0FBSytMLEdBQUcsQ0FBQy9MLEtBQUs2MUMsS0FBSyxDQUFDeStDLE9BQU9ILFNBQVM7UUFDcERoaEQsSUFBSXcyQyxZQUFZLENBQUMsR0FBRzNwRixLQUFLME4sSUFBSSxDQUFDb1AsSUFBSTljLEtBQUswTixJQUFJLENBQUMrTCxJQUFJLEdBQUd3NkUsTUFBTUU7UUFDekRoaEQsSUFBSWlMLFNBQVMsQ0FBQ20xQyxRQUFRQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNLEdBQUcsR0FBR1ksU0FBU0Y7UUFDN0RsaEQsSUFBSXcyQyxZQUFZLENBQUM5c0UsR0FBR0MsR0FBR3JELEdBQUdtUixHQUFHaXJDLElBQUlDO1FBQ2pDLE9BQU87WUFBQ3krQjtZQUFTRjtTQUFPO0lBQzFCO0lBQ0FsaEQsSUFBSWlMLFNBQVMsQ0FBQ20xQyxRQUFRQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQyxPQUFPQyxPQUFPQyxPQUFPQztJQUNuRSxNQUFNN0osU0FBU2xxRixLQUFLcStELEtBQUssQ0FBQ3hoRCxHQUFHQztJQUM3QixNQUFNcXRFLFNBQVNucUYsS0FBS3ErRCxLQUFLLENBQUM1a0QsR0FBR21SO0lBQzdCLE9BQU87UUFBQ3MvRCxTQUFTNEo7UUFBTzNKLFNBQVM0SjtLQUFNO0FBQ3pDO0FBQ0EsTUFBTVM7SUEwQko1M0YsWUFBWSt4QyxLQUFLLEVBQUVDLE1BQU0sRUFBRTZsRCxPQUFPLENBQUU7YUF6QnBDQyxlQUFlO2FBQ2ZDLFdBQVc7YUFDWEMsZ0JBQWdCO2FBQ2hCQyxhQUFhO2FBQ2JDLGtCQUFrQjthQUNsQmxlLGFBQWF4cUQ7YUFDYjJvRSxVQUFVO2FBQ1Y1MEYsSUFBSTthQUNKME0sSUFBSTthQUNKbW9GLFFBQVE7YUFDUkMsUUFBUTthQUNSQyxjQUFjO2FBQ2RDLGNBQWM7YUFDZEMsYUFBYTthQUNiQyxvQkFBb0I5bEUsa0JBQWtCQyxJQUFJO2FBQzFDOGxFLFdBQVc7YUFDWDFGLFlBQVk7YUFDWkMsY0FBYzthQUNkMEYsY0FBYzthQUNkQyxnQkFBZ0I7YUFDaEJDLFlBQVk7YUFDWkMsY0FBYzthQUNkQyxZQUFZO2FBQ1pDLGNBQWM7YUFDZEMsZUFBZTtRQUVicEIsVUFBVSxJQUFJO1FBQ2QsSUFBSSxDQUFDN1IsT0FBTyxHQUFHLElBQUludEUsYUFBYTtZQUFDO1lBQUc7WUFBR2s1QjtZQUFPQztTQUFPO1FBQ3JELElBQUksQ0FBQ3pPLE1BQU0sR0FBR3V4RCxhQUFhMzFGLEtBQUs7SUFDbEM7SUFDQWdILFFBQVE7UUFDTixNQUFNQSxRQUFRbEgsT0FBTytMLE1BQU0sQ0FBQyxJQUFJO1FBQ2hDN0UsTUFBTTYvRSxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUM3bUYsS0FBSztRQUNsQ2dILE1BQU1vOUIsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFDcGtDLEtBQUs7UUFDaEMsT0FBT2dIO0lBQ1Q7SUFDQSt5RixtQkFBbUJqTixXQUFXdEIsU0FBUy8zRCxJQUFJLEVBQUUyRyxZQUFZLElBQUksRUFBRTtRQUM3RCxNQUFNK21CLE1BQU0sSUFBSSxDQUFDL2MsTUFBTSxDQUFDcGtDLEtBQUs7UUFDN0IsSUFBSThzRixhQUFhdEIsU0FBUzkzRCxNQUFNLEVBQUU7WUFDaEMsSUFBSSxDQUFDMEcsV0FBVztnQkFDZDZGLFlBQVk7WUFDZDtZQUNBNEQsS0FBSzZDLDZCQUE2QixDQUFDdE0sV0FBV3M3RDtZQUM5QyxNQUFNc0UsYUFBYXRFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDa0UsU0FBUyxHQUFHO1lBQzVDLE1BQU1LLGFBQWF2RSxFQUFFLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ2tFLFNBQVMsR0FBRztZQUM1Q3o0QyxHQUFHLENBQUMsRUFBRSxJQUFJNjRDO1lBQ1Y3NEMsR0FBRyxDQUFDLEVBQUUsSUFBSTg0QztZQUNWOTRDLEdBQUcsQ0FBQyxFQUFFLElBQUk2NEM7WUFDVjc0QyxHQUFHLENBQUMsRUFBRSxJQUFJODRDO1FBQ1o7UUFDQSxPQUFPOTRDO0lBQ1Q7SUFDQSs0QyxxQkFBcUI7UUFDbkIsTUFBTWx6RCxZQUFZbkQsS0FBS21ELFNBQVMsQ0FBQyxJQUFJLENBQUM2L0MsT0FBTyxFQUFFLElBQUksQ0FBQ2tULGtCQUFrQjtRQUN0RSxJQUFJLENBQUNJLHNCQUFzQixDQUFDbnpELGFBQWE7WUFBQztZQUFHO1lBQUc7WUFBRztTQUFFO0lBQ3ZEO0lBQ0FvekQsY0FBYztRQUNaLE9BQU8sSUFBSSxDQUFDaDJELE1BQU0sQ0FBQyxFQUFFLEtBQUt2MEI7SUFDNUI7SUFDQXNxRix1QkFBdUJoNUMsR0FBRyxFQUFFO1FBQzFCLElBQUksQ0FBQzBsQyxPQUFPLENBQUM3Z0YsR0FBRyxDQUFDbTdDLEtBQUs7UUFDdEIsSUFBSSxDQUFDL2MsTUFBTSxDQUFDcCtCLEdBQUcsQ0FBQzJ2RixjQUFjO0lBQ2hDO0lBQ0ExSSwwQkFBMEJILFdBQVd0QixTQUFTLzNELElBQUksRUFBRTJHLFlBQVksSUFBSSxFQUFFO1FBQ3BFLE9BQU95SixLQUFLbUQsU0FBUyxDQUFDLElBQUksQ0FBQzYvQyxPQUFPLEVBQUUsSUFBSSxDQUFDa1Qsa0JBQWtCLENBQUNqTixVQUFVMXlEO0lBQ3hFO0FBQ0Y7QUFDQSxTQUFTaWdFLG1CQUFtQmpqRCxHQUFHLEVBQUVrakQsT0FBTztJQUN0QyxJQUFJQSxtQkFBbUJ4VixXQUFXO1FBQ2hDMXRDLElBQUkyNUMsWUFBWSxDQUFDdUosU0FBUyxHQUFHO1FBQzdCO0lBQ0Y7SUFDQSxNQUFNem5ELFNBQVN5bkQsUUFBUXpuRCxNQUFNLEVBQzNCRCxRQUFRMG5ELFFBQVExbkQsS0FBSztJQUN2QixNQUFNMm5ELHFCQUFxQjFuRCxTQUFTMmlEO0lBQ3BDLE1BQU1nRixhQUFhLENBQUMzbkQsU0FBUzBuRCxrQkFBaUIsSUFBSy9FO0lBQ25ELE1BQU1pRixjQUFjRix1QkFBdUIsSUFBSUMsYUFBYUEsYUFBYTtJQUN6RSxNQUFNRSxlQUFldGpELElBQUkwNUMsZUFBZSxDQUFDbCtDLE9BQU80aUQ7SUFDaEQsSUFBSXJCLFNBQVMsR0FDWFE7SUFDRixNQUFNcnBGLE1BQU1ndkYsUUFBUXRzRixJQUFJO0lBQ3hCLE1BQU11OUIsT0FBT212RCxhQUFhMXNGLElBQUk7SUFDOUIsSUFBSTVMLEdBQUdzUCxHQUFHaXBGLGlCQUFpQkM7SUFDM0IsSUFBSU4sUUFBUTN6RixJQUFJLEtBQUt3dEIsZUFBZUMsY0FBYyxFQUFFO1FBQ2xELE1BQU1zZ0UsWUFBWXBwRixJQUFJcEUsVUFBVTtRQUNoQyxNQUFNMnpGLFNBQVMsSUFBSXBoRixZQUFZOHhCLEtBQUtwcEMsTUFBTSxFQUFFLEdBQUdvcEMsS0FBS3JrQyxVQUFVLElBQUk7UUFDbEUsTUFBTTR6RixtQkFBbUJELE9BQU9wOUYsTUFBTTtRQUN0QyxNQUFNczlGLGNBQWNub0QsUUFBUSxLQUFLO1FBQ2pDLE1BQU1pSCxRQUFRO1FBQ2QsTUFBTXFnQyxRQUFRcjNDLGlCQUFpQkosY0FBYyxHQUFHLGFBQWE7UUFDN0QsSUFBS3JnQyxJQUFJLEdBQUdBLElBQUlxNEYsYUFBYXI0RixJQUFLO1lBQ2hDdTRGLGtCQUFrQnY0RixJQUFJbzRGLGFBQWFoRixvQkFBb0IrRTtZQUN2RDVGLFVBQVU7WUFDVixJQUFLampGLElBQUksR0FBR0EsSUFBSWlwRixpQkFBaUJqcEYsSUFBSztnQkFDcEMsTUFBTXNwRixVQUFVdEcsWUFBWVA7Z0JBQzVCLElBQUlyOEUsSUFBSTtnQkFDUixNQUFNbWpGLE9BQU9ELFVBQVVELGNBQWNub0QsUUFBUW9vRCxVQUFVLElBQUk7Z0JBQzNELE1BQU1FLGVBQWVELE9BQU8sQ0FBQztnQkFDN0IsSUFBSUUsT0FBTztnQkFDWCxJQUFJQyxVQUFVO2dCQUNkLE1BQU90akYsSUFBSW9qRixjQUFjcGpGLEtBQUssRUFBRztvQkFDL0JzakYsVUFBVTl2RixHQUFHLENBQUM2b0YsU0FBUztvQkFDdkIwRyxNQUFNLENBQUNsRyxVQUFVLEdBQUd5RyxVQUFVLE1BQU12aEQsUUFBUXFnQztvQkFDNUMyZ0IsTUFBTSxDQUFDbEcsVUFBVSxHQUFHeUcsVUFBVSxLQUFLdmhELFFBQVFxZ0M7b0JBQzNDMmdCLE1BQU0sQ0FBQ2xHLFVBQVUsR0FBR3lHLFVBQVUsS0FBS3ZoRCxRQUFRcWdDO29CQUMzQzJnQixNQUFNLENBQUNsRyxVQUFVLEdBQUd5RyxVQUFVLEtBQUt2aEQsUUFBUXFnQztvQkFDM0MyZ0IsTUFBTSxDQUFDbEcsVUFBVSxHQUFHeUcsVUFBVSxJQUFJdmhELFFBQVFxZ0M7b0JBQzFDMmdCLE1BQU0sQ0FBQ2xHLFVBQVUsR0FBR3lHLFVBQVUsSUFBSXZoRCxRQUFRcWdDO29CQUMxQzJnQixNQUFNLENBQUNsRyxVQUFVLEdBQUd5RyxVQUFVLElBQUl2aEQsUUFBUXFnQztvQkFDMUMyZ0IsTUFBTSxDQUFDbEcsVUFBVSxHQUFHeUcsVUFBVSxJQUFJdmhELFFBQVFxZ0M7Z0JBQzVDO2dCQUNBLE1BQU9waUUsSUFBSW1qRixNQUFNbmpGLElBQUs7b0JBQ3BCLElBQUlxakYsU0FBUyxHQUFHO3dCQUNkQyxVQUFVOXZGLEdBQUcsQ0FBQzZvRixTQUFTO3dCQUN2QmdILE9BQU87b0JBQ1Q7b0JBQ0FOLE1BQU0sQ0FBQ2xHLFVBQVUsR0FBR3lHLFVBQVVELE9BQU90aEQsUUFBUXFnQztvQkFDN0NpaEIsU0FBUztnQkFDWDtZQUNGO1lBQ0EsTUFBT3hHLFVBQVVtRyxpQkFBa0I7Z0JBQ2pDRCxNQUFNLENBQUNsRyxVQUFVLEdBQUc7WUFDdEI7WUFDQXY5QyxJQUFJMjVDLFlBQVksQ0FBQzJKLGNBQWMsR0FBR3Q0RixJQUFJb3pGO1FBQ3hDO0lBQ0YsT0FBTyxJQUFJOEUsUUFBUTN6RixJQUFJLEtBQUt3dEIsZUFBZUcsVUFBVSxFQUFFO1FBQ3JENWlCLElBQUk7UUFDSmtwRixtQkFBbUJob0QsUUFBUTRpRCxvQkFBb0I7UUFDL0MsSUFBS3B6RixJQUFJLEdBQUdBLElBQUlvNEYsWUFBWXA0RixJQUFLO1lBQy9CbXBDLEtBQUt2bEMsR0FBRyxDQUFDc0YsSUFBSTYyQixRQUFRLENBQUNneUQsUUFBUUEsU0FBU3lHO1lBQ3ZDekcsVUFBVXlHO1lBQ1Z4akQsSUFBSTI1QyxZQUFZLENBQUMySixjQUFjLEdBQUdocEY7WUFDbENBLEtBQUs4akY7UUFDUDtRQUNBLElBQUlwekYsSUFBSXE0RixhQUFhO1lBQ25CRyxtQkFBbUJob0QsUUFBUTJuRCxxQkFBcUI7WUFDaERodkQsS0FBS3ZsQyxHQUFHLENBQUNzRixJQUFJNjJCLFFBQVEsQ0FBQ2d5RCxRQUFRQSxTQUFTeUc7WUFDdkN4akQsSUFBSTI1QyxZQUFZLENBQUMySixjQUFjLEdBQUdocEY7UUFDcEM7SUFDRixPQUFPLElBQUk0b0YsUUFBUTN6RixJQUFJLEtBQUt3dEIsZUFBZUUsU0FBUyxFQUFFO1FBQ3BEc21FLGtCQUFrQm5GO1FBQ2xCb0YsbUJBQW1CaG9ELFFBQVErbkQ7UUFDM0IsSUFBS3Y0RixJQUFJLEdBQUdBLElBQUlxNEYsYUFBYXI0RixJQUFLO1lBQ2hDLElBQUlBLEtBQUtvNEYsWUFBWTtnQkFDbkJHLGtCQUFrQko7Z0JBQ2xCSyxtQkFBbUJob0QsUUFBUStuRDtZQUM3QjtZQUNBaEcsVUFBVTtZQUNWLElBQUtqakYsSUFBSWtwRixrQkFBa0JscEYsS0FBTTtnQkFDL0I2NUIsSUFBSSxDQUFDb3BELFVBQVUsR0FBR3JwRixHQUFHLENBQUM2b0YsU0FBUztnQkFDL0I1b0QsSUFBSSxDQUFDb3BELFVBQVUsR0FBR3JwRixHQUFHLENBQUM2b0YsU0FBUztnQkFDL0I1b0QsSUFBSSxDQUFDb3BELFVBQVUsR0FBR3JwRixHQUFHLENBQUM2b0YsU0FBUztnQkFDL0I1b0QsSUFBSSxDQUFDb3BELFVBQVUsR0FBRztZQUNwQjtZQUNBdjlDLElBQUkyNUMsWUFBWSxDQUFDMkosY0FBYyxHQUFHdDRGLElBQUlvekY7UUFDeEM7SUFDRixPQUFPO1FBQ0wsTUFBTSxJQUFJNTVFLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTArRSxRQUFRM3pGLElBQUksQ0FBQyxDQUFDO0lBQ25EO0FBQ0Y7QUFDQSxTQUFTMDBGLG1CQUFtQmprRCxHQUFHLEVBQUVrakQsT0FBTztJQUN0QyxJQUFJQSxRQUFROTJFLE1BQU0sRUFBRTtRQUNsQjR6QixJQUFJaUwsU0FBUyxDQUFDaTRDLFFBQVE5MkUsTUFBTSxFQUFFLEdBQUc7UUFDakM7SUFDRjtJQUNBLE1BQU1xdkIsU0FBU3luRCxRQUFRem5ELE1BQU0sRUFDM0JELFFBQVEwbkQsUUFBUTFuRCxLQUFLO0lBQ3ZCLE1BQU0ybkQscUJBQXFCMW5ELFNBQVMyaUQ7SUFDcEMsTUFBTWdGLGFBQWEsQ0FBQzNuRCxTQUFTMG5ELGtCQUFpQixJQUFLL0U7SUFDbkQsTUFBTWlGLGNBQWNGLHVCQUF1QixJQUFJQyxhQUFhQSxhQUFhO0lBQ3pFLE1BQU1FLGVBQWV0akQsSUFBSTA1QyxlQUFlLENBQUNsK0MsT0FBTzRpRDtJQUNoRCxJQUFJckIsU0FBUztJQUNiLE1BQU03b0YsTUFBTWd2RixRQUFRdHNGLElBQUk7SUFDeEIsTUFBTXU5QixPQUFPbXZELGFBQWExc0YsSUFBSTtJQUM5QixJQUFLLElBQUk1TCxJQUFJLEdBQUdBLElBQUlxNEYsYUFBYXI0RixJQUFLO1FBQ3BDLE1BQU11NEYsa0JBQWtCdjRGLElBQUlvNEYsYUFBYWhGLG9CQUFvQitFO1FBQzVELEdBQ0NwRyxNQUFNLEVBQ1AsR0FBR0YsMkJBQTJCO1lBQzdCM29GO1lBQ0E2b0Y7WUFDQTVvRDtZQUNBcUg7WUFDQUMsUUFBUThuRDtZQUNSdkcsZUFBZTtRQUNqQixFQUFDO1FBQ0RoOUMsSUFBSTI1QyxZQUFZLENBQUMySixjQUFjLEdBQUd0NEYsSUFBSW96RjtJQUN4QztBQUNGO0FBQ0EsU0FBUzhGLGFBQWFDLFNBQVMsRUFBRTFGLE9BQU87SUFDdEMsTUFBTTJGLGFBQWE7UUFBQztRQUFlO1FBQWE7UUFBWTtRQUFlO1FBQWE7UUFBVztRQUFZO1FBQWM7UUFBNEI7UUFBUTtLQUFTO0lBQzFLLEtBQUssTUFBTWpoRixZQUFZaWhGLFdBQVk7UUFDakMsSUFBSUQsU0FBUyxDQUFDaGhGLFNBQVMsS0FBS3ZaLFdBQVc7WUFDckM2MEYsT0FBTyxDQUFDdDdFLFNBQVMsR0FBR2doRixTQUFTLENBQUNoaEYsU0FBUztRQUN6QztJQUNGO0lBQ0EsSUFBSWdoRixVQUFVRSxXQUFXLEtBQUt6NkYsV0FBVztRQUN2QzYwRixRQUFRNEYsV0FBVyxDQUFDRixVQUFVRyxXQUFXO1FBQ3pDN0YsUUFBUThGLGNBQWMsR0FBR0osVUFBVUksY0FBYztJQUNuRDtBQUNGO0FBQ0EsU0FBU0Msa0JBQWtCeGtELEdBQUc7SUFDNUJBLElBQUl3OEMsV0FBVyxHQUFHeDhDLElBQUlxMkMsU0FBUyxHQUFHO0lBQ2xDcjJDLElBQUl5a0QsUUFBUSxHQUFHO0lBQ2Z6a0QsSUFBSTBrRCxXQUFXLEdBQUc7SUFDbEIxa0QsSUFBSXdpRCxTQUFTLEdBQUc7SUFDaEJ4aUQsSUFBSTJrRCxPQUFPLEdBQUc7SUFDZDNrRCxJQUFJNGtELFFBQVEsR0FBRztJQUNmNWtELElBQUk2a0QsVUFBVSxHQUFHO0lBQ2pCN2tELElBQUk4a0Qsd0JBQXdCLEdBQUc7SUFDL0I5a0QsSUFBSTAvQixJQUFJLEdBQUc7SUFDWCxJQUFJMS9CLElBQUlxa0QsV0FBVyxLQUFLejZGLFdBQVc7UUFDakNvMkMsSUFBSXFrRCxXQUFXLENBQUMsRUFBRTtRQUNsQnJrRCxJQUFJdWtELGNBQWMsR0FBRztJQUN2QjtJQUNBLE1BQU0sRUFDSnh2RixNQUFNLEVBQ1AsR0FBR2lyQztJQUNKLElBQUlqckMsV0FBVyxVQUFVQSxXQUFXLElBQUk7UUFDdENpckMsSUFBSWpyQyxNQUFNLEdBQUc7SUFDZjtBQUNGO0FBQ0EsU0FBU2d3Rix5QkFBeUIvaEUsU0FBUyxFQUFFZ2lFLFdBQVc7SUFDdEQsSUFBSUEsYUFBYTtRQUNmLE9BQU87SUFDVDtJQUNBdjRELEtBQUs2Qyw2QkFBNkIsQ0FBQ3RNLFdBQVdzN0Q7SUFDOUMsTUFBTTJHLGNBQWNwNEYsS0FBS3E0RixNQUFNLENBQUN0a0QsWUFBWUMsVUFBVSxHQUFHekgsY0FBY0UsZ0JBQWdCO0lBQ3ZGLE9BQU9nbEQsRUFBRSxDQUFDLEVBQUUsSUFBSTJHLGVBQWUzRyxFQUFFLENBQUMsRUFBRSxJQUFJMkc7QUFDMUM7QUFDQSxNQUFNRSxrQkFBa0I7SUFBQztJQUFRO0lBQVM7Q0FBUztBQUNuRCxNQUFNQyxtQkFBbUI7SUFBQztJQUFTO0lBQVM7Q0FBUTtBQUNwRCxNQUFNQyxjQUFjLENBQUM7QUFDckIsTUFBTUMsVUFBVSxDQUFDO0FBQ2pCLE1BQU1DO0lBQ0o5N0YsWUFBWSs3RixTQUFTLEVBQUVDLFVBQVUsRUFBRWxqQixJQUFJLEVBQUUwZCxhQUFhLEVBQUU1dkMsYUFBYSxFQUFFLEVBQ3JFcTFDLHFCQUFxQixFQUNyQm5XLHFCQUFxQixJQUFJLEVBQzFCLEVBQUVvVyxtQkFBbUIsRUFBRXIwQyxVQUFVLEVBQUV1aUMsaUJBQWlCLENBQUU7UUFDckQsSUFBSSxDQUFDN3pDLEdBQUcsR0FBR3dsRDtRQUNYLElBQUksQ0FBQ25oRixPQUFPLEdBQUcsSUFBSWc5RSxpQkFBaUIsSUFBSSxDQUFDcmhELEdBQUcsQ0FBQzJLLE1BQU0sQ0FBQ25QLEtBQUssRUFBRSxJQUFJLENBQUN3RSxHQUFHLENBQUMySyxNQUFNLENBQUNsUCxNQUFNO1FBQ2pGLElBQUksQ0FBQ21xRCxVQUFVLEdBQUcsRUFBRTtRQUNwQixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNsOEQsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDbThELEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ04sVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNsakIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQzBkLGFBQWEsR0FBR0E7UUFDckIsSUFBSSxDQUFDNXZDLGFBQWEsR0FBR0E7UUFDckIsSUFBSSxDQUFDMjFDLFVBQVUsR0FBRyxFQUFFO1FBQ3BCLElBQUksQ0FBQzVQLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUM1RyxrQkFBa0IsR0FBRyxFQUFFO1FBQzVCLElBQUksQ0FBQ2lNLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUN3SyxVQUFVLEdBQUcsRUFBRTtRQUNwQixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUM5VyxrQkFBa0IsR0FBR0Esc0JBQXNCLEVBQUU7UUFDbEQsSUFBSSxDQUFDbVcscUJBQXFCLEdBQUdBO1FBQzdCLElBQUksQ0FBQzNQLGNBQWMsR0FBRyxJQUFJaUssZUFBZSxJQUFJLENBQUNDLGFBQWE7UUFDM0QsSUFBSSxDQUFDcUcsY0FBYyxHQUFHLElBQUkveUQ7UUFDMUIsSUFBSSxDQUFDb3lELG1CQUFtQixHQUFHQTtRQUMzQixJQUFJLENBQUNZLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNuMUMsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNvMUMsdUJBQXVCLEdBQUc7WUFBQyxDQUFDO1lBQUc7U0FBRTtRQUN0QyxJQUFJLENBQUNDLDBCQUEwQixHQUFHO1FBQ2xDLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsSUFBSXJ6RDtRQUM3QixJQUFJLENBQUNzZ0QsaUJBQWlCLEdBQUdBLHFCQUFxQjtJQUNoRDtJQUNBZ1QsVUFBVXBXLEtBQUssRUFBRTc1RSxJQUFJLEVBQUVrd0YsV0FBVyxJQUFJLEVBQUU7UUFDdEMsSUFBSSxPQUFPbHdGLFNBQVMsVUFBVTtZQUM1QixJQUFJLENBQUNpOUUsaUJBQWlCLEVBQUVkLHNCQUFzQnRDLE9BQU83NUU7WUFDckQsT0FBT0EsS0FBS3l5QixVQUFVLENBQUMsUUFBUSxJQUFJLENBQUNvOEQsVUFBVSxDQUFDbjlGLEdBQUcsQ0FBQ3NPLFFBQVEsSUFBSSxDQUFDMnJFLElBQUksQ0FBQ2o2RSxHQUFHLENBQUNzTztRQUMzRTtRQUNBLE9BQU9rd0Y7SUFDVDtJQUNBQyxhQUFhLEVBQ1gvakUsU0FBUyxFQUNUd1YsUUFBUSxFQUNSd3VELGVBQWUsS0FBSyxFQUNwQjd4QyxhQUFhLElBQUksRUFDbEIsRUFBRTtRQUNELE1BQU0zWixRQUFRLElBQUksQ0FBQ3dFLEdBQUcsQ0FBQzJLLE1BQU0sQ0FBQ25QLEtBQUs7UUFDbkMsTUFBTUMsU0FBUyxJQUFJLENBQUN1RSxHQUFHLENBQUMySyxNQUFNLENBQUNsUCxNQUFNO1FBQ3JDLE1BQU13ckQsaUJBQWlCLElBQUksQ0FBQ2puRCxHQUFHLENBQUNxMkMsU0FBUztRQUN6QyxJQUFJLENBQUNyMkMsR0FBRyxDQUFDcTJDLFNBQVMsR0FBR2xoQyxjQUFjO1FBQ25DLElBQUksQ0FBQ25WLEdBQUcsQ0FBQ2tuRCxRQUFRLENBQUMsR0FBRyxHQUFHMXJELE9BQU9DO1FBQy9CLElBQUksQ0FBQ3VFLEdBQUcsQ0FBQ3EyQyxTQUFTLEdBQUc0UTtRQUNyQixJQUFJRCxjQUFjO1lBQ2hCLE1BQU1HLG9CQUFvQixJQUFJLENBQUNwUixjQUFjLENBQUNDLFNBQVMsQ0FBQyxlQUFleDZDLE9BQU9DO1lBQzlFLElBQUksQ0FBQzJyRCxZQUFZLEdBQUcsSUFBSSxDQUFDcG5ELEdBQUc7WUFDNUIsSUFBSSxDQUFDbW5ELGlCQUFpQixHQUFHQSxrQkFBa0J4OEMsTUFBTTtZQUNqRCxJQUFJLENBQUMzSyxHQUFHLEdBQUdtbkQsa0JBQWtCbjJFLE9BQU87WUFDcEMsSUFBSSxDQUFDZ3ZCLEdBQUcsQ0FBQ2xkLElBQUk7WUFDYixJQUFJLENBQUNrZCxHQUFHLENBQUNoZCxTQUFTLElBQUkrYyxvQkFBb0IsSUFBSSxDQUFDcW5ELFlBQVk7UUFDN0Q7UUFDQSxJQUFJLENBQUNwbkQsR0FBRyxDQUFDbGQsSUFBSTtRQUNiMGhFLGtCQUFrQixJQUFJLENBQUN4a0QsR0FBRztRQUMxQixJQUFJaGQsV0FBVztZQUNiLElBQUksQ0FBQ2dkLEdBQUcsQ0FBQ2hkLFNBQVMsSUFBSUE7WUFDdEIsSUFBSSxDQUFDd2pFLFlBQVksR0FBR3hqRSxTQUFTLENBQUMsRUFBRTtZQUNoQyxJQUFJLENBQUN5akUsWUFBWSxHQUFHempFLFNBQVMsQ0FBQyxFQUFFO1FBQ2xDO1FBQ0EsSUFBSSxDQUFDZ2QsR0FBRyxDQUFDaGQsU0FBUyxJQUFJd1YsU0FBU3hWLFNBQVM7UUFDeEMsSUFBSSxDQUFDdWpFLGFBQWEsR0FBRy90RCxTQUFTbUMsS0FBSztRQUNuQyxJQUFJLENBQUN5N0MsYUFBYSxHQUFHcjJDLG9CQUFvQixJQUFJLENBQUNDLEdBQUc7SUFDbkQ7SUFDQTQ3QyxvQkFBb0J0QixZQUFZLEVBQUUrTSxpQkFBaUIsRUFBRUMsZ0JBQWdCLEVBQUVDLE9BQU8sRUFBRUMsZ0JBQWdCLEVBQUU7UUFDaEcsTUFBTUMsWUFBWW5OLGFBQWFtTixTQUFTO1FBQ3hDLE1BQU1DLFVBQVVwTixhQUFhb04sT0FBTztRQUNwQyxJQUFJMThGLElBQUlxOEYscUJBQXFCO1FBQzdCLE1BQU1NLGVBQWVGLFVBQVVwaEcsTUFBTTtRQUNyQyxJQUFJc2hHLGlCQUFpQjM4RixHQUFHO1lBQ3RCLE9BQU9BO1FBQ1Q7UUFDQSxNQUFNNDhGLGtCQUFrQkQsZUFBZTM4RixJQUFJbXpGLG1CQUFtQixPQUFPbUoscUJBQXFCO1FBQzFGLE1BQU1PLFVBQVVELGtCQUFrQi8wRCxLQUFLNEssR0FBRyxLQUFLeWdELGlCQUFpQjtRQUNoRSxJQUFJNEosUUFBUTtRQUNaLE1BQU1yQyxhQUFhLElBQUksQ0FBQ0EsVUFBVTtRQUNsQyxNQUFNbGpCLE9BQU8sSUFBSSxDQUFDQSxJQUFJO1FBQ3RCLElBQUl3bEIsTUFBTUM7UUFDVixNQUFPLEtBQU07WUFDWCxJQUFJVCxZQUFZMzlGLGFBQWFvQixNQUFNdThGLFFBQVFVLGNBQWMsRUFBRTtnQkFDekRWLFFBQVFXLE9BQU8sQ0FBQ2w5RixHQUFHczhGO2dCQUNuQixPQUFPdDhGO1lBQ1Q7WUFDQSxJQUFJLENBQUN3OEYsb0JBQW9CQSxpQkFBaUJ4OEYsSUFBSTtnQkFDNUMrOEYsT0FBT0wsT0FBTyxDQUFDMThGLEVBQUU7Z0JBQ2pCZzlGLFNBQVNQLFNBQVMsQ0FBQ3o4RixFQUFFLElBQUk7Z0JBQ3pCLElBQUkrOEYsU0FBUzNsRSxJQUFJQyxVQUFVLEVBQUU7b0JBQzNCLElBQUkybEUsV0FBVyxNQUFNO3dCQUNuQixJQUFJLENBQUNELEtBQUssQ0FBQy84RjtvQkFDYixPQUFPO3dCQUNMLElBQUksQ0FBQys4RixLQUFLLENBQUMvOEYsTUFBTWc5RjtvQkFDbkI7Z0JBQ0YsT0FBTztvQkFDTCxLQUFLLE1BQU1HLFlBQVlILE9BQVE7d0JBQzdCLElBQUksQ0FBQ25VLGlCQUFpQixFQUFFeEMsZ0JBQWdCOFcsVUFBVW45Rjt3QkFDbEQsTUFBTW85RixXQUFXRCxTQUFTOStELFVBQVUsQ0FBQyxRQUFRbzhELGFBQWFsakI7d0JBQzFELElBQUksQ0FBQzZsQixTQUFTdjVGLEdBQUcsQ0FBQ3M1RixXQUFXOzRCQUMzQkMsU0FBUzkvRixHQUFHLENBQUM2L0YsVUFBVWI7NEJBQ3ZCLE9BQU90OEY7d0JBQ1Q7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUNBQTtZQUNBLElBQUlBLE1BQU0yOEYsY0FBYztnQkFDdEIsT0FBTzM4RjtZQUNUO1lBQ0EsSUFBSTQ4RixtQkFBbUIsRUFBRUUsUUFBUTNKLGlCQUFpQjtnQkFDaEQsSUFBSXRyRCxLQUFLNEssR0FBRyxLQUFLb3FELFNBQVM7b0JBQ3hCUDtvQkFDQSxPQUFPdDhGO2dCQUNUO2dCQUNBODhGLFFBQVE7WUFDVjtRQUNGO0lBQ0Y7SUFDQSxDQUFDTyxtQkFBbUI7UUFDbEIsTUFBTyxJQUFJLENBQUN6QyxVQUFVLENBQUN2L0YsTUFBTSxJQUFJLElBQUksQ0FBQ2lpRyxXQUFXLENBQUU7WUFDakQsSUFBSSxDQUFDdmxFLE9BQU87UUFDZDtRQUNBLElBQUksQ0FBQzFlLE9BQU8sQ0FBQ28rRSxXQUFXLEdBQUc7UUFDM0IsSUFBSSxDQUFDemlELEdBQUcsQ0FBQ2pkLE9BQU87UUFDaEIsSUFBSSxJQUFJLENBQUNva0UsaUJBQWlCLEVBQUU7WUFDMUIsSUFBSSxDQUFDbm5ELEdBQUcsR0FBRyxJQUFJLENBQUNvbkQsWUFBWTtZQUM1QixJQUFJLENBQUNwbkQsR0FBRyxDQUFDbGQsSUFBSTtZQUNiLElBQUksQ0FBQ2tkLEdBQUcsQ0FBQ3cyQyxZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO1lBQ3JDLElBQUksQ0FBQ3gyQyxHQUFHLENBQUNpTCxTQUFTLENBQUMsSUFBSSxDQUFDazhDLGlCQUFpQixFQUFFLEdBQUc7WUFDOUMsSUFBSSxDQUFDbm5ELEdBQUcsQ0FBQ2pkLE9BQU87WUFDaEIsSUFBSSxDQUFDb2tFLGlCQUFpQixHQUFHO1FBQzNCO0lBQ0Y7SUFDQXRMLGFBQWE7UUFDWCxJQUFJLENBQUMsQ0FBQ3dNLG1CQUFtQjtRQUN6QixJQUFJLENBQUN0UyxjQUFjLENBQUNsb0UsS0FBSztRQUN6QixJQUFJLENBQUN5NEUsY0FBYyxDQUFDejRFLEtBQUs7UUFDekIsS0FBSyxNQUFNMjhCLFNBQVMsSUFBSSxDQUFDbzhDLGlCQUFpQixDQUFDejVFLE1BQU0sR0FBSTtZQUNuRCxLQUFLLE1BQU13OUIsVUFBVUgsTUFBTXI5QixNQUFNLEdBQUk7Z0JBQ25DLElBQUksT0FBT283RSxzQkFBc0IsZUFBZTU5QyxrQkFBa0I0OUMsbUJBQW1CO29CQUNuRjU5QyxPQUFPblAsS0FBSyxHQUFHbVAsT0FBT2xQLE1BQU0sR0FBRztnQkFDakM7WUFDRjtZQUNBK08sTUFBTTM4QixLQUFLO1FBQ2I7UUFDQSxJQUFJLENBQUMrNEUsaUJBQWlCLENBQUMvNEUsS0FBSztRQUM1QixJQUFJLENBQUMsQ0FBQzI2RSxVQUFVO0lBQ2xCO0lBQ0EsQ0FBQ0EsVUFBVTtRQUNULElBQUksSUFBSSxDQUFDbDNDLFVBQVUsRUFBRTtZQUNuQixNQUFNbTNDLGNBQWMsSUFBSSxDQUFDcDRDLGFBQWEsQ0FBQzRFLFlBQVksQ0FBQyxJQUFJLENBQUMzRCxVQUFVLENBQUM0RCxVQUFVLEVBQUUsSUFBSSxDQUFDNUQsVUFBVSxDQUFDNkQsVUFBVTtZQUMxRyxJQUFJc3pDLGdCQUFnQixRQUFRO2dCQUMxQixNQUFNQyxjQUFjLElBQUksQ0FBQzFvRCxHQUFHLENBQUNqckMsTUFBTTtnQkFDbkMsSUFBSSxDQUFDaXJDLEdBQUcsQ0FBQ2pyQyxNQUFNLEdBQUcwekY7Z0JBQ2xCLElBQUksQ0FBQ3pvRCxHQUFHLENBQUNpTCxTQUFTLENBQUMsSUFBSSxDQUFDakwsR0FBRyxDQUFDMkssTUFBTSxFQUFFLEdBQUc7Z0JBQ3ZDLElBQUksQ0FBQzNLLEdBQUcsQ0FBQ2pyQyxNQUFNLEdBQUcyekY7WUFDcEI7UUFDRjtJQUNGO0lBQ0FDLFlBQVlDLEdBQUcsRUFBRXY1RCxnQkFBZ0IsRUFBRTtRQUNqQyxNQUFNbU0sUUFBUW90RCxJQUFJcHRELEtBQUssSUFBSW90RCxJQUFJQyxZQUFZO1FBQzNDLE1BQU1wdEQsU0FBU210RCxJQUFJbnRELE1BQU0sSUFBSW10RCxJQUFJRSxhQUFhO1FBQzlDLElBQUlDLGFBQWFsOEYsS0FBSzRQLEdBQUcsQ0FBQzVQLEtBQUtxK0QsS0FBSyxDQUFDNzdCLGdCQUFnQixDQUFDLEVBQUUsRUFBRUEsZ0JBQWdCLENBQUMsRUFBRSxHQUFHO1FBQ2hGLElBQUkyNUQsY0FBY244RixLQUFLNFAsR0FBRyxDQUFDNVAsS0FBS3ErRCxLQUFLLENBQUM3N0IsZ0JBQWdCLENBQUMsRUFBRSxFQUFFQSxnQkFBZ0IsQ0FBQyxFQUFFLEdBQUc7UUFDakYsSUFBSTQ1RCxhQUFhenRELE9BQ2YwdEQsY0FBY3p0RDtRQUNoQixJQUFJMHRELGNBQWM7UUFDbEIsSUFBSXJULFdBQVdHO1FBQ2YsTUFBTzhTLGFBQWEsS0FBS0UsYUFBYSxLQUFLRCxjQUFjLEtBQUtFLGNBQWMsRUFBRztZQUM3RSxJQUFJeDJCLFdBQVd1MkIsWUFDYnQyQixZQUFZdTJCO1lBQ2QsSUFBSUgsYUFBYSxLQUFLRSxhQUFhLEdBQUc7Z0JBQ3BDdjJCLFdBQVd1MkIsY0FBYyxRQUFRcDhGLEtBQUtDLEtBQUssQ0FBQ204RixhQUFhLEtBQUssS0FBSyxJQUFJcDhGLEtBQUtELElBQUksQ0FBQ3E4RixhQUFhO2dCQUM5RkYsY0FBY0UsYUFBYXYyQjtZQUM3QjtZQUNBLElBQUlzMkIsY0FBYyxLQUFLRSxjQUFjLEdBQUc7Z0JBQ3RDdjJCLFlBQVl1MkIsZUFBZSxRQUFRcjhGLEtBQUtDLEtBQUssQ0FBQ284RixjQUFjLEtBQUssS0FBSyxJQUFJcjhGLEtBQUtELElBQUksQ0FBQ3M4RixlQUFlO2dCQUNuR0YsZUFBZUUsY0FBY3YyQjtZQUMvQjtZQUNBbWpCLFlBQVksSUFBSSxDQUFDQyxjQUFjLENBQUNDLFNBQVMsQ0FBQ21ULGFBQWF6MkIsVUFBVUM7WUFDakVzakIsU0FBU0gsVUFBVTlrRSxPQUFPO1lBQzFCaWxFLE9BQU9DLFNBQVMsQ0FBQyxHQUFHLEdBQUd4akIsVUFBVUM7WUFDakNzakIsT0FBT2hyQyxTQUFTLENBQUMyOUMsS0FBSyxHQUFHLEdBQUdLLFlBQVlDLGFBQWEsR0FBRyxHQUFHeDJCLFVBQVVDO1lBQ3JFaTJCLE1BQU05UyxVQUFVbnJDLE1BQU07WUFDdEJzK0MsYUFBYXYyQjtZQUNidzJCLGNBQWN2MkI7WUFDZHcyQixjQUFjQSxnQkFBZ0IsY0FBYyxjQUFjO1FBQzVEO1FBQ0EsT0FBTztZQUNMUDtZQUNBSztZQUNBQztRQUNGO0lBQ0Y7SUFDQUUsa0JBQWtCM1ksS0FBSyxFQUFFbVksR0FBRyxFQUFFO1FBQzVCLE1BQU01b0QsTUFBTSxJQUFJLENBQUNBLEdBQUc7UUFDcEIsTUFBTSxFQUNKeEUsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBR210RDtRQUNKLE1BQU1uTSxZQUFZLElBQUksQ0FBQ3A0RSxPQUFPLENBQUNvNEUsU0FBUztRQUN4QyxNQUFNNE0sZ0JBQWdCLElBQUksQ0FBQ2hsRixPQUFPLENBQUMrOUUsV0FBVztRQUM5QyxNQUFNa0gsbUJBQW1CdnBELG9CQUFvQkM7UUFDN0MsSUFBSXdLLE9BQU8rK0MsVUFBVXZvRCxRQUFRd29EO1FBQzdCLElBQUksQ0FBQ1osSUFBSXg4RSxNQUFNLElBQUl3OEUsSUFBSWh5RixJQUFJLEtBQUtneUYsSUFBSTV1RixLQUFLLEdBQUcsR0FBRztZQUM3QyxNQUFNeXZGLFVBQVViLElBQUl4OEUsTUFBTSxJQUFJdzhFLElBQUloeUYsSUFBSSxDQUFDN0wsTUFBTTtZQUM3Q3crRixXQUFXbDVFLEtBQUtvcUMsU0FBUyxDQUFDNHVDLGdCQUFnQkMsbUJBQW1CO2dCQUFDQSxpQkFBaUIxZ0csS0FBSyxDQUFDLEdBQUc7Z0JBQUk2ekY7YUFBVTtZQUN0R2p5QyxRQUFRLElBQUksQ0FBQ284QyxpQkFBaUIsQ0FBQ3QrRixHQUFHLENBQUNtaEc7WUFDbkMsSUFBSSxDQUFDai9DLE9BQU87Z0JBQ1ZBLFFBQVEsSUFBSWpYO2dCQUNaLElBQUksQ0FBQ3F6RCxpQkFBaUIsQ0FBQ2g0RixHQUFHLENBQUM2NkYsU0FBU2ovQztZQUN0QztZQUNBLE1BQU1rL0MsY0FBY2wvQyxNQUFNbGlELEdBQUcsQ0FBQ2loRztZQUM5QixJQUFJRyxlQUFlLENBQUNMLGVBQWU7Z0JBQ2pDLE1BQU14dUQsVUFBVWh1QyxLQUFLNjFDLEtBQUssQ0FBQzcxQyxLQUFLbUYsR0FBRyxDQUFDczNGLGdCQUFnQixDQUFDLEVBQUUsRUFBRUEsZ0JBQWdCLENBQUMsRUFBRSxJQUFJQSxnQkFBZ0IsQ0FBQyxFQUFFO2dCQUNuRyxNQUFNeHVELFVBQVVqdUMsS0FBSzYxQyxLQUFLLENBQUM3MUMsS0FBS21GLEdBQUcsQ0FBQ3MzRixnQkFBZ0IsQ0FBQyxFQUFFLEVBQUVBLGdCQUFnQixDQUFDLEVBQUUsSUFBSUEsZ0JBQWdCLENBQUMsRUFBRTtnQkFDbkcsSUFBSSxDQUFDelYsaUJBQWlCLEVBQUVoQixtQkFBbUJwQyxPQUFPd0QsYUFBYUUsZ0JBQWdCO2dCQUMvRSxPQUFPO29CQUNMeHBDLFFBQVErK0M7b0JBQ1I3dUQ7b0JBQ0FDO2dCQUNGO1lBQ0Y7WUFDQWtHLFNBQVMwb0Q7UUFDWDtRQUNBLElBQUksQ0FBQzFvRCxRQUFRO1lBQ1h3b0QsYUFBYSxJQUFJLENBQUN6VCxjQUFjLENBQUNDLFNBQVMsQ0FBQyxjQUFjeDZDLE9BQU9DO1lBQ2hFd29ELG1CQUFtQnVGLFdBQVd4NEUsT0FBTyxFQUFFNDNFO1FBQ3pDO1FBQ0EsSUFBSWUsZUFBZWw5RCxLQUFLekosU0FBUyxDQUFDc21FLGtCQUFrQjtZQUFDLElBQUk5dEQ7WUFBTztZQUFHO1lBQUcsQ0FBQyxJQUFJQztZQUFRO1lBQUc7U0FBRTtRQUN4Rmt1RCxlQUFlbDlELEtBQUt6SixTQUFTLENBQUMybUUsY0FBYztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRyxDQUFDbHVEO1NBQU87UUFDcEUsTUFBTXpPLFNBQVN1eEQsYUFBYTMxRixLQUFLO1FBQ2pDNmpDLEtBQUt5Qix1QkFBdUIsQ0FBQztZQUFDO1lBQUc7WUFBR3NOO1lBQU9DO1NBQU8sRUFBRWt1RCxjQUFjMzhEO1FBQ2xFLE1BQU0sQ0FBQ3doRCxNQUFNQyxNQUFNQyxNQUFNQyxLQUFLLEdBQUczaEQ7UUFDakMsTUFBTTQ4RCxhQUFhLzhGLEtBQUs2MUMsS0FBSyxDQUFDZ3NDLE9BQU9GLFNBQVM7UUFDOUMsTUFBTXFiLGNBQWNoOUYsS0FBSzYxQyxLQUFLLENBQUNpc0MsT0FBT0YsU0FBUztRQUMvQyxNQUFNcWIsYUFBYSxJQUFJLENBQUMvVCxjQUFjLENBQUNDLFNBQVMsQ0FBQyxjQUFjNFQsWUFBWUM7UUFDM0UsTUFBTUUsVUFBVUQsV0FBVzk0RSxPQUFPO1FBQ2xDLE1BQU02cEIsVUFBVTJ6QztRQUNoQixNQUFNMXpDLFVBQVUyekM7UUFDaEJzYixRQUFRejVCLFNBQVMsQ0FBQyxDQUFDejFCLFNBQVMsQ0FBQ0M7UUFDN0JpdkQsUUFBUS9tRSxTQUFTLElBQUkybUU7UUFDckIsSUFBSSxDQUFDM29ELFFBQVE7WUFDWEEsU0FBUyxJQUFJLENBQUMybkQsV0FBVyxDQUFDYSxXQUFXNytDLE1BQU0sRUFBRXpLLDJCQUEyQjZwRDtZQUN4RS9vRCxTQUFTQSxPQUFPNG5ELEdBQUc7WUFDbkIsSUFBSXArQyxTQUFTNitDLGVBQWU7Z0JBQzFCNytDLE1BQU01N0MsR0FBRyxDQUFDMjZGLFVBQVV2b0Q7WUFDdEI7UUFDRjtRQUNBK29ELFFBQVFDLHFCQUFxQixHQUFHakYseUJBQXlCaGxELG9CQUFvQmdxRCxVQUFVbkIsSUFBSTVELFdBQVc7UUFDdEc3RSx5QkFBeUI0SixTQUFTL29ELFFBQVEsR0FBRyxHQUFHQSxPQUFPeEYsS0FBSyxFQUFFd0YsT0FBT3ZGLE1BQU0sRUFBRSxHQUFHLEdBQUdELE9BQU9DO1FBQzFGc3VELFFBQVFqRix3QkFBd0IsR0FBRztRQUNuQyxNQUFNMXRGLFVBQVVxMUIsS0FBS3pKLFNBQVMsQ0FBQ2tkLDJCQUEyQjZwRCxVQUFVO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRyxDQUFDbHZEO1lBQVMsQ0FBQ0M7U0FBUTtRQUNwR2l2RCxRQUFRMVQsU0FBUyxHQUFHZ1QsZ0JBQWdCNU0sVUFBVS9ILFVBQVUsQ0FBQzEwQyxLQUFLLElBQUksRUFBRTVvQyxTQUFTZzlFLFNBQVMvM0QsSUFBSSxFQUFFbzBELFNBQVNnTTtRQUNyR3NOLFFBQVE3QyxRQUFRLENBQUMsR0FBRyxHQUFHMXJELE9BQU9DO1FBQzlCLElBQUkrTyxTQUFTLENBQUM2K0MsZUFBZTtZQUMzQixJQUFJLENBQUN0VCxjQUFjLENBQUNsdUMsTUFBTSxDQUFDO1lBQzNCMkMsTUFBTTU3QyxHQUFHLENBQUMyNkYsVUFBVU8sV0FBV24vQyxNQUFNO1FBQ3ZDO1FBQ0EsSUFBSSxDQUFDa3BDLGlCQUFpQixFQUFFaEIsbUJBQW1CcEMsT0FBT3dELGFBQWFFLGdCQUFnQjtRQUMvRSxPQUFPO1lBQ0x4cEMsUUFBUW0vQyxXQUFXbi9DLE1BQU07WUFDekI5UCxTQUFTaHVDLEtBQUs2MUMsS0FBSyxDQUFDN0g7WUFDcEJDLFNBQVNqdUMsS0FBSzYxQyxLQUFLLENBQUM1SDtRQUN0QjtJQUNGO0lBQ0F4WSxhQUFhbXVELEtBQUssRUFBRWoxQyxLQUFLLEVBQUU7UUFDekIsSUFBSSxDQUFDcTRDLGlCQUFpQixFQUFFM0MsaUJBQWlCLGFBQWFUO1FBQ3RELElBQUlqMUMsVUFBVSxJQUFJLENBQUNuM0IsT0FBTyxDQUFDbStFLFNBQVMsRUFBRTtZQUNwQyxJQUFJLENBQUNrRSx1QkFBdUIsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNyQztRQUNBLElBQUksQ0FBQ3JpRixPQUFPLENBQUNtK0UsU0FBUyxHQUFHaG5EO1FBQ3pCLElBQUksQ0FBQ3dFLEdBQUcsQ0FBQ3dpRCxTQUFTLEdBQUdobkQ7SUFDdkI7SUFDQWpaLFdBQVdrdUQsS0FBSyxFQUFFMThFLEtBQUssRUFBRTtRQUN2QixJQUFJLENBQUM4L0UsaUJBQWlCLEVBQUUzQyxpQkFBaUIsV0FBV1Q7UUFDcEQsSUFBSSxDQUFDendDLEdBQUcsQ0FBQzJrRCxPQUFPLEdBQUdRLGVBQWUsQ0FBQ3B4RixNQUFNO0lBQzNDO0lBQ0F5dUIsWUFBWWl1RCxLQUFLLEVBQUUxOEUsS0FBSyxFQUFFO1FBQ3hCLElBQUksQ0FBQzgvRSxpQkFBaUIsRUFBRTNDLGlCQUFpQixZQUFZVDtRQUNyRCxJQUFJLENBQUN6d0MsR0FBRyxDQUFDNGtELFFBQVEsR0FBR1EsZ0JBQWdCLENBQUNyeEYsTUFBTTtJQUM3QztJQUNBMHVCLGNBQWNndUQsS0FBSyxFQUFFMXJFLEtBQUssRUFBRTtRQUMxQixJQUFJLENBQUM4dUUsaUJBQWlCLEVBQUUzQyxpQkFBaUIsY0FBY1Q7UUFDdkQsSUFBSSxDQUFDendDLEdBQUcsQ0FBQzZrRCxVQUFVLEdBQUc5L0U7SUFDeEI7SUFDQTJkLFFBQVErdEQsS0FBSyxFQUFFd1osU0FBUyxFQUFFQyxTQUFTLEVBQUU7UUFDbkMsSUFBSSxDQUFDclcsaUJBQWlCLEVBQUUzQyxpQkFBaUIsUUFBUVQ7UUFDakQsTUFBTXp3QyxNQUFNLElBQUksQ0FBQ0EsR0FBRztRQUNwQixJQUFJQSxJQUFJcWtELFdBQVcsS0FBS3o2RixXQUFXO1lBQ2pDbzJDLElBQUlxa0QsV0FBVyxDQUFDNEY7WUFDaEJqcUQsSUFBSXVrRCxjQUFjLEdBQUcyRjtRQUN2QjtJQUNGO0lBQ0F2bkUsbUJBQW1COHRELEtBQUssRUFBRS81QyxNQUFNLEVBQUUsQ0FBQztJQUNuQzlULFlBQVk2dEQsS0FBSyxFQUFFMFosUUFBUSxFQUFFLENBQUM7SUFDOUJ0bkUsVUFBVTR0RCxLQUFLLEVBQUUyWixNQUFNLEVBQUU7UUFDdkIsS0FBSyxNQUFNLENBQUMzNEYsS0FBS25LLE1BQU0sSUFBSThpRyxPQUFRO1lBQ2pDLE9BQVEzNEY7Z0JBQ04sS0FBSztvQkFDSCxJQUFJLENBQUM2d0IsWUFBWSxDQUFDbXVELE9BQU9ucEY7b0JBQ3pCO2dCQUNGLEtBQUs7b0JBQ0gsSUFBSSxDQUFDaTdCLFVBQVUsQ0FBQ2t1RCxPQUFPbnBGO29CQUN2QjtnQkFDRixLQUFLO29CQUNILElBQUksQ0FBQ2s3QixXQUFXLENBQUNpdUQsT0FBT25wRjtvQkFDeEI7Z0JBQ0YsS0FBSztvQkFDSCxJQUFJLENBQUNtN0IsYUFBYSxDQUFDZ3VELE9BQU9ucEY7b0JBQzFCO2dCQUNGLEtBQUs7b0JBQ0gsSUFBSSxDQUFDbzdCLE9BQU8sQ0FBQyt0RCxPQUFPbnBGLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFO29CQUN0QztnQkFDRixLQUFLO29CQUNILElBQUksQ0FBQ3E3QixrQkFBa0IsQ0FBQzh0RCxPQUFPbnBGO29CQUMvQjtnQkFDRixLQUFLO29CQUNILElBQUksQ0FBQ3M3QixXQUFXLENBQUM2dEQsT0FBT25wRjtvQkFDeEI7Z0JBQ0YsS0FBSztvQkFDSCxJQUFJLENBQUNtOUIsT0FBTyxDQUFDZ3NELE9BQU9ucEYsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUU7b0JBQ3RDO2dCQUNGLEtBQUs7b0JBQ0gsSUFBSSxDQUFDdXNGLGlCQUFpQixFQUFFM0MsaUJBQWlCLGVBQWVUO29CQUN4RCxJQUFJLENBQUNwc0UsT0FBTyxDQUFDaytFLFdBQVcsR0FBR2o3RjtvQkFDM0I7Z0JBQ0YsS0FBSztvQkFDSCxJQUFJLENBQUN1c0YsaUJBQWlCLEVBQUUzQyxpQkFBaUIsYUFBYVQ7b0JBQ3RELElBQUksQ0FBQ3p3QyxHQUFHLENBQUMwa0QsV0FBVyxHQUFHLElBQUksQ0FBQ3JnRixPQUFPLENBQUNpK0UsU0FBUyxHQUFHaDdGO29CQUNoRDtnQkFDRixLQUFLO29CQUNILElBQUksQ0FBQ3VzRixpQkFBaUIsRUFBRTNDLGlCQUFpQiw0QkFBNEJUO29CQUNyRSxJQUFJLENBQUN6d0MsR0FBRyxDQUFDOGtELHdCQUF3QixHQUFHeDlGO29CQUNwQztnQkFDRixLQUFLO29CQUNILElBQUksQ0FBQ3VzRixpQkFBaUIsRUFBRTNDLGlCQUFpQixTQUFTVDtvQkFDbEQsSUFBSSxDQUFDcHNFLE9BQU8sQ0FBQ28rRSxXQUFXLEdBQUduN0YsUUFBUSxJQUFJLENBQUM2K0YsU0FBUyxHQUFHO29CQUNwRCxJQUFJLENBQUNBLFNBQVMsR0FBRztvQkFDakIsSUFBSSxDQUFDa0UsZUFBZTtvQkFDcEI7Z0JBQ0YsS0FBSztvQkFDSCxJQUFJLENBQUN4VyxpQkFBaUIsRUFBRTNDLGlCQUFpQixVQUFVVDtvQkFDbkQsSUFBSSxDQUFDendDLEdBQUcsQ0FBQ2pyQyxNQUFNLEdBQUcsSUFBSSxDQUFDc1AsT0FBTyxDQUFDcStFLFlBQVksR0FBRyxJQUFJLENBQUNyeUMsYUFBYSxDQUFDcTVCLFNBQVMsQ0FBQ3BpRjtvQkFDM0U7WUFDSjtRQUNGO0lBQ0Y7SUFDQSxJQUFJZ2hHLGNBQWM7UUFDaEIsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDbEMsWUFBWTtJQUM1QjtJQUNBaUUsa0JBQWtCO1FBQ2hCLE1BQU0vQixjQUFjLElBQUksQ0FBQ0EsV0FBVztRQUNwQyxJQUFJLElBQUksQ0FBQ2prRixPQUFPLENBQUNvK0UsV0FBVyxJQUFJLENBQUM2RixhQUFhO1lBQzVDLElBQUksQ0FBQ2dDLGNBQWM7UUFDckIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDam1GLE9BQU8sQ0FBQ28rRSxXQUFXLElBQUk2RixhQUFhO1lBQ25ELElBQUksQ0FBQ2lDLFlBQVk7UUFDbkI7SUFDRjtJQUNBRCxlQUFlN1osS0FBSyxFQUFFO1FBQ3BCLElBQUksSUFBSSxDQUFDNlgsV0FBVyxFQUFFO1lBQ3BCLE1BQU0sSUFBSTlqRixNQUFNO1FBQ2xCO1FBQ0EsTUFBTW9sRixhQUFhLElBQUksQ0FBQzVwRCxHQUFHLENBQUMySyxNQUFNLENBQUNuUCxLQUFLO1FBQ3hDLE1BQU1xdUQsY0FBYyxJQUFJLENBQUM3cEQsR0FBRyxDQUFDMkssTUFBTSxDQUFDbFAsTUFBTTtRQUMxQyxNQUFNK3VELFVBQVUsaUJBQWlCLElBQUksQ0FBQy9PLFVBQVU7UUFDaEQsTUFBTWdQLGdCQUFnQixJQUFJLENBQUMxVSxjQUFjLENBQUNDLFNBQVMsQ0FBQ3dVLFNBQVNaLFlBQVlDO1FBQ3pFLElBQUksQ0FBQ3pELFlBQVksR0FBRyxJQUFJLENBQUNwbUQsR0FBRztRQUM1QixNQUFNQSxNQUFNLElBQUksQ0FBQ0EsR0FBRyxHQUFHeXFELGNBQWN6NUUsT0FBTztRQUM1Q2d2QixJQUFJdzJDLFlBQVksQ0FBQyxJQUFJLENBQUM0UCxZQUFZLENBQUNubUQsWUFBWTtRQUMvQ2lrRCxhQUFhLElBQUksQ0FBQ2tDLFlBQVksRUFBRXBtRDtRQUNoQ3crQyx3QkFBd0J4K0MsS0FBSyxJQUFJLENBQUNvbUQsWUFBWTtRQUM5QyxJQUFJLENBQUN2akUsU0FBUyxDQUFDNHRELE9BQU87WUFBQztnQkFBQztnQkFBTTthQUFjO1NBQUM7SUFDL0M7SUFDQThaLGVBQWU7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDakMsV0FBVyxFQUFFO1lBQ3JCLE1BQU0sSUFBSTlqRixNQUFNO1FBQ2xCO1FBQ0EsSUFBSSxDQUFDdzdCLEdBQUcsQ0FBQzArQyxnQkFBZ0I7UUFDekJ3RixhQUFhLElBQUksQ0FBQ2xrRCxHQUFHLEVBQUUsSUFBSSxDQUFDb21ELFlBQVk7UUFDeEMsSUFBSSxDQUFDcG1ELEdBQUcsR0FBRyxJQUFJLENBQUNvbUQsWUFBWTtRQUM1QixJQUFJLENBQUNBLFlBQVksR0FBRztJQUN0QjtJQUNBc0UsUUFBUUMsUUFBUSxFQUFFO1FBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUN0bUYsT0FBTyxDQUFDbytFLFdBQVcsRUFBRTtZQUM3QjtRQUNGO1FBQ0EsSUFBSSxDQUFDa0ksVUFBVTtZQUNiQSxXQUFXO2dCQUFDO2dCQUFHO2dCQUFHLElBQUksQ0FBQzNxRCxHQUFHLENBQUMySyxNQUFNLENBQUNuUCxLQUFLO2dCQUFFLElBQUksQ0FBQ3dFLEdBQUcsQ0FBQzJLLE1BQU0sQ0FBQ2xQLE1BQU07YUFBQztRQUNsRSxPQUFPO1lBQ0xrdkQsUUFBUSxDQUFDLEVBQUUsR0FBRzk5RixLQUFLQyxLQUFLLENBQUM2OUYsUUFBUSxDQUFDLEVBQUU7WUFDcENBLFFBQVEsQ0FBQyxFQUFFLEdBQUc5OUYsS0FBS0MsS0FBSyxDQUFDNjlGLFFBQVEsQ0FBQyxFQUFFO1lBQ3BDQSxRQUFRLENBQUMsRUFBRSxHQUFHOTlGLEtBQUtELElBQUksQ0FBQys5RixRQUFRLENBQUMsRUFBRTtZQUNuQ0EsUUFBUSxDQUFDLEVBQUUsR0FBRzk5RixLQUFLRCxJQUFJLENBQUMrOUYsUUFBUSxDQUFDLEVBQUU7UUFDckM7UUFDQSxNQUFNQyxRQUFRLElBQUksQ0FBQ3ZtRixPQUFPLENBQUNvK0UsV0FBVztRQUN0QyxNQUFNMkQsZUFBZSxJQUFJLENBQUNBLFlBQVk7UUFDdEMsSUFBSSxDQUFDeUUsWUFBWSxDQUFDekUsY0FBY3dFLE9BQU8sSUFBSSxDQUFDNXFELEdBQUcsRUFBRTJxRDtRQUNqRCxJQUFJLENBQUMzcUQsR0FBRyxDQUFDbGQsSUFBSTtRQUNiLElBQUksQ0FBQ2tkLEdBQUcsQ0FBQ3cyQyxZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO1FBQ3JDLElBQUksQ0FBQ3gyQyxHQUFHLENBQUNrMkMsU0FBUyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUNsMkMsR0FBRyxDQUFDMkssTUFBTSxDQUFDblAsS0FBSyxFQUFFLElBQUksQ0FBQ3dFLEdBQUcsQ0FBQzJLLE1BQU0sQ0FBQ2xQLE1BQU07UUFDdEUsSUFBSSxDQUFDdUUsR0FBRyxDQUFDamQsT0FBTztJQUNsQjtJQUNBOG5FLGFBQWE3cUQsR0FBRyxFQUFFNHFELEtBQUssRUFBRUUsUUFBUSxFQUFFQyxRQUFRLEVBQUU7UUFDM0MsTUFBTUMsZUFBZUQsUUFBUSxDQUFDLEVBQUU7UUFDaEMsTUFBTUUsZUFBZUYsUUFBUSxDQUFDLEVBQUU7UUFDaEMsTUFBTUcsYUFBYUgsUUFBUSxDQUFDLEVBQUUsR0FBR0M7UUFDakMsTUFBTUcsY0FBY0osUUFBUSxDQUFDLEVBQUUsR0FBR0U7UUFDbEMsSUFBSUMsZUFBZSxLQUFLQyxnQkFBZ0IsR0FBRztZQUN6QztRQUNGO1FBQ0EsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ1IsTUFBTTU1RSxPQUFPLEVBQUU4NUUsVUFBVUksWUFBWUMsYUFBYVAsTUFBTVMsT0FBTyxFQUFFVCxNQUFNVSxRQUFRLEVBQUVWLE1BQU1XLFdBQVcsRUFBRVAsY0FBY0MsY0FBY0wsTUFBTS92RCxPQUFPLEVBQUUrdkQsTUFBTTl2RCxPQUFPO1FBQ3JMa0YsSUFBSWxkLElBQUk7UUFDUmtkLElBQUkwa0QsV0FBVyxHQUFHO1FBQ2xCMWtELElBQUk4a0Qsd0JBQXdCLEdBQUc7UUFDL0I5a0QsSUFBSXcyQyxZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO1FBQ2hDeDJDLElBQUlpTCxTQUFTLENBQUM2L0MsU0FBU25nRCxNQUFNLEVBQUUsR0FBRztRQUNsQzNLLElBQUlqZCxPQUFPO0lBQ2I7SUFDQXFvRSxvQkFBb0JJLE9BQU8sRUFBRVYsUUFBUSxFQUFFdHZELEtBQUssRUFBRUMsTUFBTSxFQUFFNHZELE9BQU8sRUFBRUMsUUFBUSxFQUFFQyxXQUFXLEVBQUVQLFlBQVksRUFBRUMsWUFBWSxFQUFFUSxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMxSSxJQUFJbEMsYUFBYWdDLFFBQVE3Z0QsTUFBTTtRQUMvQixJQUFJZ2hELFFBQVFYLGVBQWVTO1FBQzNCLElBQUlHLFFBQVFYLGVBQWVTO1FBQzNCLElBQUlKLFVBQVU7WUFDWixJQUFJSyxRQUFRLEtBQUtDLFFBQVEsS0FBS0QsUUFBUW53RCxRQUFRZ3VELFdBQVdodUQsS0FBSyxJQUFJb3dELFFBQVFud0QsU0FBUyt0RCxXQUFXL3RELE1BQU0sRUFBRTtnQkFDcEcsTUFBTWtQLFNBQVMsSUFBSSxDQUFDb3JDLGNBQWMsQ0FBQ0MsU0FBUyxDQUFDLGlCQUFpQng2QyxPQUFPQztnQkFDckUsTUFBTXVFLE1BQU0ySyxPQUFPMzVCLE9BQU87Z0JBQzFCZ3ZCLElBQUlpTCxTQUFTLENBQUN1K0MsWUFBWSxDQUFDbUMsT0FBTyxDQUFDQztnQkFDbkM1ckQsSUFBSThrRCx3QkFBd0IsR0FBRztnQkFDL0I5a0QsSUFBSXEyQyxTQUFTLEdBQUdpVjtnQkFDaEJ0ckQsSUFBSWtuRCxRQUFRLENBQUMsR0FBRyxHQUFHMXJELE9BQU9DO2dCQUMxQnVFLElBQUk4a0Qsd0JBQXdCLEdBQUc7Z0JBQy9CMEUsYUFBYTcrQyxPQUFPQSxNQUFNO2dCQUMxQmdoRCxRQUFRQyxRQUFRO1lBQ2xCLE9BQU87Z0JBQ0xKLFFBQVExb0UsSUFBSTtnQkFDWjBvRSxRQUFROUcsV0FBVyxHQUFHO2dCQUN0QjhHLFFBQVFoVixZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUNwQyxNQUFNdnlELE9BQU8sSUFBSTIrQztnQkFDakIzK0MsS0FBS2tLLElBQUksQ0FBQ3c5RCxPQUFPQyxPQUFPcHdELE9BQU9DO2dCQUMvQit2RCxRQUFRdm5FLElBQUksQ0FBQ0E7Z0JBQ2J1bkUsUUFBUTFHLHdCQUF3QixHQUFHO2dCQUNuQzBHLFFBQVFuVixTQUFTLEdBQUdpVjtnQkFDcEJFLFFBQVF0RSxRQUFRLENBQUN5RSxPQUFPQyxPQUFPcHdELE9BQU9DO2dCQUN0Qyt2RCxRQUFRem9FLE9BQU87WUFDakI7UUFDRjtRQUNBK25FLFNBQVNob0UsSUFBSTtRQUNiZ29FLFNBQVNwRyxXQUFXLEdBQUc7UUFDdkJvRyxTQUFTdFUsWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztRQUNyQyxJQUFJNlUsWUFBWSxXQUFXRSxhQUFhO1lBQ3RDVCxTQUFTLzFGLE1BQU0sR0FBRyxJQUFJLENBQUNzN0MsYUFBYSxDQUFDeTVCLGNBQWMsQ0FBQ3loQjtRQUN0RCxPQUFPLElBQUlGLFlBQVksY0FBYztZQUNuQ1AsU0FBUy8xRixNQUFNLEdBQUcsSUFBSSxDQUFDczdDLGFBQWEsQ0FBQzA1QixtQkFBbUIsQ0FBQ3doQjtRQUMzRDtRQUNBLE1BQU10bkUsT0FBTyxJQUFJMitDO1FBQ2pCMytDLEtBQUtrSyxJQUFJLENBQUM2OEQsY0FBY0MsY0FBY3p2RCxPQUFPQztRQUM3Q3F2RCxTQUFTN21FLElBQUksQ0FBQ0E7UUFDZDZtRSxTQUFTaEcsd0JBQXdCLEdBQUc7UUFDcENnRyxTQUFTNy9DLFNBQVMsQ0FBQ3UrQyxZQUFZbUMsT0FBT0MsT0FBT3B3RCxPQUFPQyxRQUFRdXZELGNBQWNDLGNBQWN6dkQsT0FBT0M7UUFDL0ZxdkQsU0FBUy9uRSxPQUFPO0lBQ2xCO0lBQ0FELEtBQUsydEQsS0FBSyxFQUFFO1FBQ1YsSUFBSSxJQUFJLENBQUM2WCxXQUFXLEVBQUU7WUFDcEJwRSxhQUFhLElBQUksQ0FBQ2xrRCxHQUFHLEVBQUUsSUFBSSxDQUFDb21ELFlBQVk7UUFDMUM7UUFDQSxJQUFJLENBQUNwbUQsR0FBRyxDQUFDbGQsSUFBSTtRQUNiLE1BQU0rb0UsTUFBTSxJQUFJLENBQUN4bkYsT0FBTztRQUN4QixJQUFJLENBQUN1aEYsVUFBVSxDQUFDdDBGLElBQUksQ0FBQ3U2RjtRQUNyQixJQUFJLENBQUN4bkYsT0FBTyxHQUFHd25GLElBQUlqOEYsS0FBSztRQUN4QixJQUFJLENBQUNpa0YsaUJBQWlCLEVBQUUvd0QsS0FBSzJ0RDtJQUMvQjtJQUNBMXRELFFBQVEwdEQsS0FBSyxFQUFFO1FBQ2IsSUFBSSxDQUFDb0QsaUJBQWlCLEVBQUU5d0QsUUFBUTB0RDtRQUNoQyxJQUFJLElBQUksQ0FBQ21WLFVBQVUsQ0FBQ3YvRixNQUFNLEtBQUssR0FBRztZQUNoQyxJQUFJLElBQUksQ0FBQ2lpRyxXQUFXLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQ2lDLFlBQVk7WUFDbkI7WUFDQTtRQUNGO1FBQ0EsSUFBSSxDQUFDbG1GLE9BQU8sR0FBRyxJQUFJLENBQUN1aEYsVUFBVSxDQUFDaHRELEdBQUc7UUFDbEMsSUFBSSxDQUFDb0gsR0FBRyxDQUFDamQsT0FBTztRQUNoQixJQUFJLElBQUksQ0FBQ3VsRSxXQUFXLEVBQUU7WUFDcEJwRSxhQUFhLElBQUksQ0FBQ2tDLFlBQVksRUFBRSxJQUFJLENBQUNwbUQsR0FBRztRQUMxQztRQUNBLElBQUksQ0FBQ3FxRCxlQUFlO1FBQ3BCLElBQUksQ0FBQ3hFLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNhLHVCQUF1QixDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25DLElBQUksQ0FBQ0MsMEJBQTBCLEdBQUc7SUFDcEM7SUFDQTNqRSxVQUFVeXRELEtBQUssRUFBRS9tRSxDQUFDLEVBQUVDLENBQUMsRUFBRXJELENBQUMsRUFBRW1SLENBQUMsRUFBRTViLENBQUMsRUFBRXJMLENBQUMsRUFBRTtRQUNqQyxJQUFJLENBQUNxakYsaUJBQWlCLEVBQUUxQyxzQkFBc0IsYUFBYVY7UUFDM0QsSUFBSSxDQUFDendDLEdBQUcsQ0FBQ2hkLFNBQVMsQ0FBQ3RaLEdBQUdDLEdBQUdyRCxHQUFHbVIsR0FBRzViLEdBQUdyTDtRQUNsQyxJQUFJLENBQUNrMkYsdUJBQXVCLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkMsSUFBSSxDQUFDQywwQkFBMEIsR0FBRztJQUNwQztJQUNBLytELGNBQWM2b0QsS0FBSyxFQUFFcWIsRUFBRSxFQUFFbDFGLElBQUksRUFBRW8yQixNQUFNLEVBQUU7UUFDckMsSUFBSSxDQUFDMjFDLEtBQUssR0FBRy9yRTtRQUNiLElBQUksQ0FBQ28yQixRQUFRO1lBQ1gyMUMsU0FBUy9yRSxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUlnc0U7WUFDdkIsSUFBSSxDQUFDa3BCLEdBQUcsQ0FBQ3JiLE9BQU85TjtZQUNoQjtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUNrUixpQkFBaUIsS0FBSyxNQUFNO1lBQ25DLE1BQU1rWSxpQkFBaUJELE9BQU8xcEUsSUFBSW9CLE1BQU0sR0FBRyxJQUFJLENBQUNuZixPQUFPLENBQUNtK0UsU0FBUyxHQUFHLElBQUk7WUFDeEUsSUFBSSxDQUFDM08saUJBQWlCLENBQUNoQyxTQUFTLENBQUNwQixPQUFPc0IsVUFBVSxDQUFDdEIsT0FBTyxJQUFJLENBQUN6d0MsR0FBRyxFQUFFaFQsTUFBTSxDQUFDLEVBQUUsR0FBRysrRCxnQkFBZ0IvK0QsTUFBTSxDQUFDLEVBQUUsR0FBRysrRCxnQkFBZ0IvK0QsTUFBTSxDQUFDLEVBQUUsR0FBRysrRCxnQkFBZ0IvK0QsTUFBTSxDQUFDLEVBQUUsR0FBRysrRCxnQkFBZ0JsWixrQkFBa0IsQ0FBQ3BDLE9BQU87Z0JBQUM7YUFBWTtRQUM3TjtRQUNBLElBQUksQ0FBRTlOLENBQUFBLGdCQUFnQkMsTUFBSyxHQUFJO1lBQzdCLE1BQU1vcEIsU0FBU3AxRixJQUFJLENBQUMsRUFBRSxHQUFHLElBQUlnc0U7WUFDN0IsSUFBSyxJQUFJNTNFLElBQUksR0FBR2luQyxLQUFLMHdDLEtBQUt0OEUsTUFBTSxFQUFFMkUsSUFBSWluQyxJQUFLO2dCQUN6QyxPQUFRMHdDLElBQUksQ0FBQzMzRSxJQUFJO29CQUNmLEtBQUtnOUIsUUFBUS9FLE1BQU07d0JBQ2pCK29FLE9BQU8vb0UsTUFBTSxDQUFDMC9DLElBQUksQ0FBQzMzRSxJQUFJLEVBQUUyM0UsSUFBSSxDQUFDMzNFLElBQUk7d0JBQ2xDO29CQUNGLEtBQUtnOUIsUUFBUTlFLE1BQU07d0JBQ2pCOG9FLE9BQU85b0UsTUFBTSxDQUFDeS9DLElBQUksQ0FBQzMzRSxJQUFJLEVBQUUyM0UsSUFBSSxDQUFDMzNFLElBQUk7d0JBQ2xDO29CQUNGLEtBQUtnOUIsUUFBUTdFLE9BQU87d0JBQ2xCNm9FLE9BQU94TSxhQUFhLENBQUM3YyxJQUFJLENBQUMzM0UsSUFBSSxFQUFFMjNFLElBQUksQ0FBQzMzRSxJQUFJLEVBQUUyM0UsSUFBSSxDQUFDMzNFLElBQUksRUFBRTIzRSxJQUFJLENBQUMzM0UsSUFBSSxFQUFFMjNFLElBQUksQ0FBQzMzRSxJQUFJLEVBQUUyM0UsSUFBSSxDQUFDMzNFLElBQUk7d0JBQ3JGO29CQUNGLEtBQUtnOUIsUUFBUTFFLFNBQVM7d0JBQ3BCMG9FLE9BQU8xb0UsU0FBUzt3QkFDaEI7b0JBQ0Y7d0JBQ0VzRixLQUFLLENBQUMsb0NBQW9DLEVBQUUrNUMsSUFBSSxDQUFDMzNFLElBQUksRUFBRSxDQUFDLENBQUM7d0JBQ3pEO2dCQUNKO1lBQ0Y7WUFDQTIzRSxPQUFPcXBCO1FBQ1Q7UUFDQXYvRCxLQUFLeUIsdUJBQXVCLENBQUNsQixRQUFRK1Msb0JBQW9CLElBQUksQ0FBQ0MsR0FBRyxHQUFHLElBQUksQ0FBQzM3QixPQUFPLENBQUMyb0IsTUFBTTtRQUN2RixJQUFJLENBQUM4K0QsR0FBRyxDQUFDcmIsT0FBTzlOO1FBQ2hCLElBQUksQ0FBQ3NwQixhQUFhLEdBQUd4YjtJQUN2QjtJQUNBbnRELFVBQVVtdEQsS0FBSyxFQUFFO1FBQ2YsSUFBSSxDQUFDendDLEdBQUcsQ0FBQzFjLFNBQVM7SUFDcEI7SUFDQUUsT0FBT2l0RCxLQUFLLEVBQUU5TixJQUFJLEVBQUV1cEIsY0FBYyxJQUFJLEVBQUU7UUFDdEMsTUFBTWxzRCxNQUFNLElBQUksQ0FBQ0EsR0FBRztRQUNwQixNQUFNMDhDLGNBQWMsSUFBSSxDQUFDcjRFLE9BQU8sQ0FBQ3E0RSxXQUFXO1FBQzVDMThDLElBQUkwa0QsV0FBVyxHQUFHLElBQUksQ0FBQ3JnRixPQUFPLENBQUNrK0UsV0FBVztRQUMxQyxJQUFJLElBQUksQ0FBQzhELGNBQWMsRUFBRTtZQUN2QixJQUFJLE9BQU8zSixnQkFBZ0IsWUFBWUEsYUFBYWhJLFlBQVk7Z0JBQzlELE1BQU0wQixnQkFBZ0JzRyxZQUFZakksMkJBQTJCLEtBQUt6MEMsSUFBSUMsWUFBWSxLQUFLO2dCQUN2RkQsSUFBSWxkLElBQUk7Z0JBQ1JrZCxJQUFJdzhDLFdBQVcsR0FBR0UsWUFBWWhJLFVBQVUsQ0FBQzEwQyxLQUFLLElBQUksRUFBRUUsMkJBQTJCRixNQUFNbzBDLFNBQVM5M0QsTUFBTSxFQUFFbTBEO2dCQUN0RyxJQUFJMkYsZUFBZTtvQkFDakIsTUFBTStWLFVBQVUsSUFBSXZwQjtvQkFDcEJ1cEIsUUFBUUMsT0FBTyxDQUFDenBCLE1BQU0zaUMsSUFBSUMsWUFBWSxHQUFHRSxVQUFVLEdBQUdrc0QsWUFBWSxDQUFDalc7b0JBQ25FelQsT0FBT3dwQjtnQkFDVDtnQkFDQSxJQUFJLENBQUNHLGdCQUFnQixDQUFDM3BCLE1BQU07Z0JBQzVCM2lDLElBQUlqZCxPQUFPO1lBQ2IsT0FBTztnQkFDTCxJQUFJLENBQUN1cEUsZ0JBQWdCLENBQUMzcEIsTUFBTTtZQUM5QjtRQUNGO1FBQ0EsSUFBSSxDQUFDa1IsaUJBQWlCLEVBQUVoQixtQkFBbUJwQyxPQUFPd0QsYUFBYXp3RCxNQUFNO1FBQ3JFLElBQUkwb0UsYUFBYTtZQUNmLElBQUksQ0FBQ0EsV0FBVyxDQUFDemIsT0FBTzlOLE1BQU0sSUFBSSxDQUFDdCtELE9BQU8sQ0FBQ3d4RSx5QkFBeUIsQ0FBQ3pCLFNBQVM5M0QsTUFBTSxFQUFFeWpCLG9CQUFvQixJQUFJLENBQUNDLEdBQUc7UUFDcEg7UUFDQUEsSUFBSTBrRCxXQUFXLEdBQUcsSUFBSSxDQUFDcmdGLE9BQU8sQ0FBQ2krRSxTQUFTO0lBQzFDO0lBQ0E3K0QsWUFBWWd0RCxLQUFLLEVBQUU5TixJQUFJLEVBQUU7UUFDdkIsSUFBSSxDQUFDbi9DLE1BQU0sQ0FBQ2l0RCxPQUFPOU47SUFDckI7SUFDQWovQyxLQUFLK3NELEtBQUssRUFBRTlOLElBQUksRUFBRXVwQixjQUFjLElBQUksRUFBRTtRQUNwQyxNQUFNbHNELE1BQU0sSUFBSSxDQUFDQSxHQUFHO1FBQ3BCLE1BQU15OEMsWUFBWSxJQUFJLENBQUNwNEUsT0FBTyxDQUFDbzRFLFNBQVM7UUFDeEMsTUFBTTRNLGdCQUFnQixJQUFJLENBQUNobEYsT0FBTyxDQUFDKzlFLFdBQVc7UUFDOUMsSUFBSW1LLGNBQWM7UUFDbEIsSUFBSWxELGVBQWU7WUFDakIsTUFBTWpULGdCQUFnQnFHLFVBQVVoSSwyQkFBMkIsS0FBS3owQyxJQUFJQyxZQUFZLEtBQUs7WUFDckYsSUFBSSxDQUFDNHpDLGlCQUFpQixFQUFFL3dELEtBQUsydEQ7WUFDN0J6d0MsSUFBSWxkLElBQUk7WUFDUmtkLElBQUlxMkMsU0FBUyxHQUFHb0csVUFBVS9ILFVBQVUsQ0FBQzEwQyxLQUFLLElBQUksRUFBRUUsMkJBQTJCRixNQUFNbzBDLFNBQVMvM0QsSUFBSSxFQUFFbzBEO1lBQ2hHLElBQUkyRixlQUFlO2dCQUNqQixNQUFNK1YsVUFBVSxJQUFJdnBCO2dCQUNwQnVwQixRQUFRQyxPQUFPLENBQUN6cEIsTUFBTTNpQyxJQUFJQyxZQUFZLEdBQUdFLFVBQVUsR0FBR2tzRCxZQUFZLENBQUNqVztnQkFDbkV6VCxPQUFPd3BCO1lBQ1Q7WUFDQUksY0FBYztRQUNoQjtRQUNBLE1BQU0zOEQsWUFBWSxJQUFJLENBQUN2ckIsT0FBTyxDQUFDd3hFLHlCQUF5QjtRQUN4RCxJQUFJLElBQUksQ0FBQ3dRLGNBQWMsSUFBSXoyRCxjQUFjLE1BQU07WUFDN0MsSUFBSSxJQUFJLENBQUNrMkQsYUFBYSxFQUFFO2dCQUN0QjlsRCxJQUFJdGMsSUFBSSxDQUFDaS9DLE1BQU07Z0JBQ2YsSUFBSSxDQUFDbWpCLGFBQWEsR0FBRztZQUN2QixPQUFPO2dCQUNMOWxELElBQUl0YyxJQUFJLENBQUNpL0M7WUFDWDtRQUNGO1FBQ0EsSUFBSSxDQUFDa1IsaUJBQWlCLEVBQUVoQixtQkFBbUJwQyxPQUFPd0QsYUFBYXZ3RCxJQUFJO1FBQ25FLElBQUk2b0UsYUFBYTtZQUNmdnNELElBQUlqZCxPQUFPO1lBQ1gsSUFBSSxDQUFDOHdELGlCQUFpQixFQUFFOXdELFFBQVEwdEQ7UUFDbEM7UUFDQSxJQUFJeWIsYUFBYTtZQUNmLElBQUksQ0FBQ0EsV0FBVyxDQUFDemIsT0FBTzlOLE1BQU0veUM7UUFDaEM7SUFDRjtJQUNBak0sT0FBTzhzRCxLQUFLLEVBQUU5TixJQUFJLEVBQUU7UUFDbEIsSUFBSSxDQUFDbWpCLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNwaUUsSUFBSSxDQUFDK3NELE9BQU85TjtJQUNuQjtJQUNBLytDLFdBQVc2c0QsS0FBSyxFQUFFOU4sSUFBSSxFQUFFO1FBQ3RCLElBQUksQ0FBQ2ovQyxJQUFJLENBQUMrc0QsT0FBTzlOLE1BQU07UUFDdkIsSUFBSSxDQUFDbi9DLE1BQU0sQ0FBQ2l0RCxPQUFPOU4sTUFBTTtRQUN6QixJQUFJLENBQUN1cEIsV0FBVyxDQUFDemIsT0FBTzlOO0lBQzFCO0lBQ0E5K0MsYUFBYTRzRCxLQUFLLEVBQUU5TixJQUFJLEVBQUU7UUFDeEIsSUFBSSxDQUFDbWpCLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNsaUUsVUFBVSxDQUFDNnNELE9BQU85TjtJQUN6QjtJQUNBNytDLGdCQUFnQjJzRCxLQUFLLEVBQUU5TixJQUFJLEVBQUU7UUFDM0IsSUFBSSxDQUFDLytDLFVBQVUsQ0FBQzZzRCxPQUFPOU47SUFDekI7SUFDQTUrQyxrQkFBa0Iwc0QsS0FBSyxFQUFFOU4sSUFBSSxFQUFFO1FBQzdCLElBQUksQ0FBQ21qQixhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDbGlFLFVBQVUsQ0FBQzZzRCxPQUFPOU47SUFDekI7SUFDQTMrQyxRQUFReXNELEtBQUssRUFBRTlOLElBQUksRUFBRTtRQUNuQixJQUFJLENBQUN1cEIsV0FBVyxDQUFDemIsT0FBTzlOO0lBQzFCO0lBQ0E1NkMsWUFBWTBvRCxLQUFLLEVBQUU5TixJQUFJLEVBQUU7UUFDdkIsSUFBSSxDQUFDM2lDLEdBQUcsQ0FBQ3RjLElBQUksQ0FBQ2kvQztRQUNkLElBQUksQ0FBQ2tSLGlCQUFpQixFQUFFaEIsbUJBQW1CcEMsT0FBT3dELGFBQWFsc0QsV0FBVyxFQUFFaXJELGdCQUFnQnZDO0lBQzlGO0lBQ0F4c0QsS0FBS3dzRCxLQUFLLEVBQUU7UUFDVixJQUFJLENBQUNvRCxpQkFBaUIsRUFBRXBDLDZCQUE2QixZQUFZaEI7UUFDakUsSUFBSSxDQUFDb1YsV0FBVyxHQUFHUjtJQUNyQjtJQUNBbmhFLE9BQU91c0QsS0FBSyxFQUFFO1FBQ1osSUFBSSxDQUFDb0QsaUJBQWlCLEVBQUVwQyw2QkFBNkIsWUFBWWhCO1FBQ2pFLElBQUksQ0FBQ29WLFdBQVcsR0FBR1A7SUFDckI7SUFDQW5oRSxVQUFVc3NELEtBQUssRUFBRTtRQUNmLElBQUksQ0FBQ3BzRSxPQUFPLENBQUNxOUUsVUFBVSxHQUFHO1FBQzFCLElBQUksQ0FBQ3I5RSxPQUFPLENBQUNzOUUsZUFBZSxHQUFHO1FBQy9CLElBQUksQ0FBQ3Q5RSxPQUFPLENBQUNyWCxDQUFDLEdBQUcsSUFBSSxDQUFDcVgsT0FBTyxDQUFDdzlFLEtBQUssR0FBRztRQUN0QyxJQUFJLENBQUN4OUUsT0FBTyxDQUFDM0ssQ0FBQyxHQUFHLElBQUksQ0FBQzJLLE9BQU8sQ0FBQ3k5RSxLQUFLLEdBQUc7UUFDdEMsSUFBSSxDQUFDak8saUJBQWlCLEVBQUVqRCxpQkFBaUJILE9BQU9XLHFCQUFxQixnQkFBZ0JBLHFCQUFxQixZQUFZWDtJQUN4SDtJQUNBcnNELFFBQVFxc0QsS0FBSyxFQUFFO1FBQ2IsTUFBTStiLFFBQVEsSUFBSSxDQUFDQyxnQkFBZ0I7UUFDbkMsTUFBTXpzRCxNQUFNLElBQUksQ0FBQ0EsR0FBRztRQUNwQixJQUFJLElBQUksQ0FBQzZ6QyxpQkFBaUIsRUFBRTtZQUMxQixNQUFNLEVBQ0pBLGlCQUFpQixFQUNsQixHQUFHLElBQUk7WUFDUixJQUFJMlksVUFBVTVpRyxXQUFXO2dCQUN2QmlxRixrQkFBa0JwQyw0QkFBNEIsQ0FBQyxZQUFZb0Msa0JBQWtCL0MsYUFBYSxJQUFJVyw0QkFBNEIsQ0FBQyxZQUFZaEI7WUFDekk7WUFDQW9ELGtCQUFrQjlDLGlCQUFpQixDQUFDTjtRQUN0QztRQUNBLElBQUkrYixVQUFVNWlHLFdBQVc7WUFDdkIsTUFBTXVpRyxVQUFVLElBQUl2cEI7WUFDcEIsTUFBTXpQLFlBQVluekIsSUFBSUMsWUFBWSxHQUFHRSxVQUFVO1lBQy9DLEtBQUssTUFBTSxFQUNUbmQsU0FBUyxFQUNUaDJCLENBQUMsRUFDRDBNLENBQUMsRUFDRDhuRixRQUFRLEVBQ1I3ZSxJQUFJLEVBQ0wsSUFBSTZwQixNQUFPO2dCQUNWLElBQUksQ0FBQzdwQixNQUFNO29CQUNUO2dCQUNGO2dCQUNBd3BCLFFBQVFDLE9BQU8sQ0FBQ3pwQixNQUFNLElBQUk4SyxVQUFVenFELFdBQVcwcEUsZUFBZSxDQUFDdjVCLFdBQVc3QyxTQUFTLENBQUN0akUsR0FBRzBNLEdBQUdpaEMsS0FBSyxDQUFDNm1ELFVBQVUsQ0FBQ0E7WUFDN0c7WUFDQXhoRCxJQUFJL2IsSUFBSSxDQUFDa29FO1FBQ1g7UUFDQSxPQUFPLElBQUksQ0FBQ00sZ0JBQWdCO0lBQzlCO0lBQ0Fwb0UsZUFBZW9zRCxLQUFLLEVBQUVrYyxPQUFPLEVBQUU7UUFDN0IsSUFBSSxDQUFDOVksaUJBQWlCLEVBQUUzQyxpQkFBaUIsZUFBZVQ7UUFDeEQsSUFBSSxDQUFDcHNFLE9BQU8sQ0FBQzA5RSxXQUFXLEdBQUc0SztJQUM3QjtJQUNBcm9FLGVBQWVtc0QsS0FBSyxFQUFFa2MsT0FBTyxFQUFFO1FBQzdCLElBQUksQ0FBQzlZLGlCQUFpQixFQUFFM0MsaUJBQWlCLGVBQWVUO1FBQ3hELElBQUksQ0FBQ3BzRSxPQUFPLENBQUMyOUUsV0FBVyxHQUFHMks7SUFDN0I7SUFDQXBvRSxVQUFVa3NELEtBQUssRUFBRTkxQyxLQUFLLEVBQUU7UUFDdEIsSUFBSSxDQUFDazVDLGlCQUFpQixFQUFFM0MsaUJBQWlCLFVBQVVUO1FBQ25ELElBQUksQ0FBQ3BzRSxPQUFPLENBQUM0OUUsVUFBVSxHQUFHdG5ELFFBQVE7SUFDcEM7SUFDQW5XLFdBQVdpc0QsS0FBSyxFQUFFbVIsT0FBTyxFQUFFO1FBQ3pCLElBQUksQ0FBQy9OLGlCQUFpQixFQUFFM0MsaUJBQWlCLFdBQVdUO1FBQ3BELElBQUksQ0FBQ3BzRSxPQUFPLENBQUN1OUUsT0FBTyxHQUFHLENBQUNBO0lBQzFCO0lBQ0FuOUQsUUFBUWdzRCxLQUFLLEVBQUVtYyxXQUFXLEVBQUV2eEYsSUFBSSxFQUFFO1FBQ2hDLElBQUksQ0FBQ3c0RSxpQkFBaUIsRUFBRTNDLGlCQUFpQixRQUFRVCxPQUFPYSwwQkFBMEIsV0FBV3NiLGFBQWFuYztRQUMxRyxNQUFNb2MsVUFBVSxJQUFJLENBQUNwSCxVQUFVLENBQUNuOUYsR0FBRyxDQUFDc2tHO1FBQ3BDLE1BQU12b0YsVUFBVSxJQUFJLENBQUNBLE9BQU87UUFDNUIsSUFBSSxDQUFDd29GLFNBQVM7WUFDWixNQUFNLElBQUlyb0YsTUFBTSxDQUFDLG9CQUFvQixFQUFFb29GLFlBQVksQ0FBQztRQUN0RDtRQUNBdm9GLFFBQVFvL0QsVUFBVSxHQUFHb3BCLFFBQVFwcEIsVUFBVSxJQUFJeHFEO1FBQzNDLElBQUk1VSxRQUFRby9ELFVBQVUsQ0FBQyxFQUFFLEtBQUssS0FBS3AvRCxRQUFRby9ELFVBQVUsQ0FBQyxFQUFFLEtBQUssR0FBRztZQUM5RDc2QyxLQUFLLGtDQUFrQ2drRTtRQUN6QztRQUNBLElBQUl2eEYsT0FBTyxHQUFHO1lBQ1pBLE9BQU8sQ0FBQ0E7WUFDUmdKLFFBQVF5b0YsYUFBYSxHQUFHLENBQUM7UUFDM0IsT0FBTztZQUNMem9GLFFBQVF5b0YsYUFBYSxHQUFHO1FBQzFCO1FBQ0EsSUFBSSxDQUFDem9GLE9BQU8sQ0FBQ3E3RCxJQUFJLEdBQUdtdEI7UUFDcEIsSUFBSSxDQUFDeG9GLE9BQU8sQ0FBQ205RSxRQUFRLEdBQUdubUY7UUFDeEIsSUFBSXd4RixRQUFRNXBCLFdBQVcsRUFBRTtZQUN2QjtRQUNGO1FBQ0EsTUFBTTk1RSxPQUFPMGpHLFFBQVF6dEIsVUFBVSxJQUFJO1FBQ25DLE1BQU0ydEIsV0FBV0YsUUFBUTV0QixjQUFjLEVBQUVnRCxPQUFPLENBQUMsQ0FBQyxFQUFFOTRFLEtBQUssR0FBRyxFQUFFMGpHLFFBQVFucEIsWUFBWSxDQUFDLENBQUM7UUFDcEYsSUFBSVgsT0FBTztRQUNYLElBQUk4cEIsUUFBUS9wQixLQUFLLEVBQUU7WUFDakJDLE9BQU87UUFDVCxPQUFPLElBQUk4cEIsUUFBUTlwQixJQUFJLEVBQUU7WUFDdkJBLE9BQU87UUFDVDtRQUNBLE1BQU1HLFNBQVMycEIsUUFBUTNwQixNQUFNLEdBQUcsV0FBVztRQUMzQyxJQUFJOHBCLGtCQUFrQjN4RjtRQUN0QixJQUFJQSxPQUFPMmlGLGVBQWU7WUFDeEJnUCxrQkFBa0JoUDtRQUNwQixPQUFPLElBQUkzaUYsT0FBTzRpRixlQUFlO1lBQy9CK08sa0JBQWtCL087UUFDcEI7UUFDQSxJQUFJLENBQUM1NUUsT0FBTyxDQUFDbzlFLGFBQWEsR0FBR3BtRixPQUFPMnhGO1FBQ3BDLElBQUksQ0FBQ2h0RCxHQUFHLENBQUMwL0IsSUFBSSxHQUFHLENBQUMsRUFBRXdELE9BQU8sQ0FBQyxFQUFFSCxLQUFLLENBQUMsRUFBRWlxQixnQkFBZ0IsR0FBRyxFQUFFRCxTQUFTLENBQUM7SUFDdEU7SUFDQXJvRSxxQkFBcUIrckQsS0FBSyxFQUFFbGpFLElBQUksRUFBRTtRQUNoQyxJQUFJLENBQUNzbUUsaUJBQWlCLEVBQUUzQyxpQkFBaUIscUJBQXFCVDtRQUM5RCxJQUFJLENBQUNwc0UsT0FBTyxDQUFDNjlFLGlCQUFpQixHQUFHMzBFO0lBQ25DO0lBQ0FvWCxZQUFZOHJELEtBQUssRUFBRXdjLElBQUksRUFBRTtRQUN2QixJQUFJLENBQUNwWixpQkFBaUIsRUFBRTNDLGlCQUFpQixZQUFZVDtRQUNyRCxJQUFJLENBQUNwc0UsT0FBTyxDQUFDODlFLFFBQVEsR0FBRzhLO0lBQzFCO0lBQ0Fyb0UsU0FBUzZyRCxLQUFLLEVBQUV6akYsQ0FBQyxFQUFFME0sQ0FBQyxFQUFFO1FBQ3BCLElBQUksQ0FBQ202RSxpQkFBaUIsRUFBRXpDLHFCQUFxQixnQkFBZ0JELHNCQUFzQixZQUFZVjtRQUMvRixJQUFJLENBQUNwc0UsT0FBTyxDQUFDclgsQ0FBQyxHQUFHLElBQUksQ0FBQ3FYLE9BQU8sQ0FBQ3c5RSxLQUFLLElBQUk3MEY7UUFDdkMsSUFBSSxDQUFDcVgsT0FBTyxDQUFDM0ssQ0FBQyxHQUFHLElBQUksQ0FBQzJLLE9BQU8sQ0FBQ3k5RSxLQUFLLElBQUlwb0Y7SUFDekM7SUFDQW1yQixtQkFBbUI0ckQsS0FBSyxFQUFFempGLENBQUMsRUFBRTBNLENBQUMsRUFBRTtRQUM5QixJQUFJLENBQUM4cUIsVUFBVSxDQUFDaXNELE9BQU8sQ0FBQy8yRTtRQUN4QixJQUFJLENBQUNrckIsUUFBUSxDQUFDNnJELE9BQU96akYsR0FBRzBNO0lBQzFCO0lBQ0FvckIsY0FBYzJyRCxLQUFLLEVBQUVsaEQsTUFBTSxFQUFFO1FBQzNCLElBQUksQ0FBQ3NrRCxpQkFBaUIsRUFBRTNDLGlCQUFpQixjQUFjVDtRQUN2RCxNQUFNLEVBQ0pwc0UsT0FBTyxFQUNSLEdBQUcsSUFBSTtRQUNSQSxRQUFRcTlFLFVBQVUsR0FBR255RDtRQUNyQmxyQixRQUFRczlFLGVBQWUsR0FBRzkwRixLQUFLcStELEtBQUssQ0FBQzM3QixNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRTtRQUN6RGxyQixRQUFRclgsQ0FBQyxHQUFHcVgsUUFBUXc5RSxLQUFLLEdBQUc7UUFDNUJ4OUUsUUFBUTNLLENBQUMsR0FBRzJLLFFBQVF5OUUsS0FBSyxHQUFHO0lBQzlCO0lBQ0EvOEQsU0FBUzByRCxLQUFLLEVBQUU7UUFDZCxJQUFJLENBQUM3ckQsUUFBUSxDQUFDNnJELE9BQU8sR0FBRyxJQUFJLENBQUNwc0UsT0FBTyxDQUFDdTlFLE9BQU87UUFDNUMsSUFBSSxDQUFDL04saUJBQWlCLEVBQUUxQyxzQkFBc0IsWUFBWSxJQUFJLENBQUMwQyxpQkFBaUIsQ0FBQ2xCLGNBQWMsQ0FBQyxjQUFjbEM7SUFDaEg7SUFDQSxDQUFDeWMsYUFBYSxDQUFDdnFCLElBQUksRUFBRTJtQixnQkFBZ0IsRUFBRXRtRSxTQUFTO1FBQzlDLE1BQU1tcEUsVUFBVSxJQUFJdnBCO1FBQ3BCdXBCLFFBQVFDLE9BQU8sQ0FBQ3pwQixNQUFNLElBQUk4SyxVQUFVenFELFdBQVdtZCxVQUFVLEdBQUdrc0QsWUFBWSxDQUFDL0M7UUFDekUsT0FBTzZDO0lBQ1Q7SUFDQWdCLFVBQVUxYyxLQUFLLEVBQUVqTyxTQUFTLEVBQUV4MUUsQ0FBQyxFQUFFME0sQ0FBQyxFQUFFMHpGLG9CQUFvQixFQUFFQyxzQkFBc0IsRUFBRTtRQUM5RSxNQUFNcnRELE1BQU0sSUFBSSxDQUFDQSxHQUFHO1FBQ3BCLE1BQU0zN0IsVUFBVSxJQUFJLENBQUNBLE9BQU87UUFDNUIsTUFBTXE3RCxPQUFPcjdELFFBQVFxN0QsSUFBSTtRQUN6QixNQUFNd2lCLG9CQUFvQjc5RSxRQUFRNjlFLGlCQUFpQjtRQUNuRCxNQUFNVixXQUFXbjlFLFFBQVFtOUUsUUFBUSxHQUFHbjlFLFFBQVFvOUUsYUFBYTtRQUN6RCxNQUFNNkwsaUJBQWlCcEwsb0JBQW9COWxFLGtCQUFrQlMsZ0JBQWdCO1FBQzdFLE1BQU0wd0UsaUJBQWlCLENBQUMsQ0FBRXJMLENBQUFBLG9CQUFvQjlsRSxrQkFBa0JVLGdCQUFnQjtRQUNoRixNQUFNc2xFLGNBQWMvOUUsUUFBUSs5RSxXQUFXLElBQUksQ0FBQzFpQixLQUFLRSxXQUFXO1FBQzVELE1BQU15aUIsZ0JBQWdCaCtFLFFBQVFnK0UsYUFBYSxJQUFJLENBQUMzaUIsS0FBS0UsV0FBVztRQUNoRSxJQUFJK0M7UUFDSixJQUFJLENBQUNqRCxLQUFLUixlQUFlLElBQUlxdUIsa0JBQWtCbkwsZUFBZUMsYUFBWSxLQUFNLENBQUMzaUIsS0FBS0UsV0FBVyxFQUFFO1lBQ2pHK0MsT0FBT2pELEtBQUs0QyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNtakIsVUFBVSxFQUFFampCO1FBQ2hEO1FBQ0EsSUFBSUcsUUFBU2pELENBQUFBLEtBQUtSLGVBQWUsSUFBSWtqQixlQUFlQyxhQUFZLEdBQUk7WUFDbEVyaUQsSUFBSWxkLElBQUk7WUFDUmtkLElBQUlzd0IsU0FBUyxDQUFDdGpFLEdBQUcwTTtZQUNqQnNtQyxJQUFJckYsS0FBSyxDQUFDNm1ELFVBQVUsQ0FBQ0E7WUFDckIsSUFBSSxDQUFDM04saUJBQWlCLEVBQUU3QixvQkFBb0J2QixPQUFPendDLEtBQUswL0I7WUFDeEQsSUFBSTRwQjtZQUNKLElBQUlnRSxtQkFBbUJseEUsa0JBQWtCQyxJQUFJLElBQUlpeEUsbUJBQW1CbHhFLGtCQUFrQkcsV0FBVyxFQUFFO2dCQUNqRyxJQUFJNndFLHNCQUFzQjtvQkFDeEI5RCxtQkFBbUJ0cEQsSUFBSUMsWUFBWTtvQkFDbkNELElBQUl3MkMsWUFBWSxJQUFJNFc7b0JBQ3BCLE1BQU1JLGFBQWEsSUFBSSxDQUFDLENBQUNOLGFBQWEsQ0FBQ3ZxQixNQUFNMm1CLGtCQUFrQjhEO29CQUMvRHB0RCxJQUFJdGMsSUFBSSxDQUFDOHBFO2dCQUNYLE9BQU87b0JBQ0x4dEQsSUFBSXRjLElBQUksQ0FBQ2kvQztnQkFDWDtZQUNGO1lBQ0EsSUFBSTJxQixtQkFBbUJseEUsa0JBQWtCRSxNQUFNLElBQUlneEUsbUJBQW1CbHhFLGtCQUFrQkcsV0FBVyxFQUFFO2dCQUNuRyxJQUFJOHdFLHdCQUF3QjtvQkFDMUIvRCxxQkFBcUJ0cEQsSUFBSUMsWUFBWTtvQkFDckNELElBQUl3MkMsWUFBWSxJQUFJNlc7b0JBQ3BCLE1BQU0sRUFDSjNqRixDQUFDLEVBQ0RDLENBQUMsRUFDRHJELENBQUMsRUFDRG1SLENBQUMsRUFDRixHQUFHNnhFO29CQUNKLE1BQU1tRSxzQkFBc0JoaEUsS0FBSzRDLGdCQUFnQixDQUFDZytEO29CQUNsRCxNQUFNcDZCLFNBQVN4bUMsS0FBS3pKLFNBQVMsQ0FBQzt3QkFBQ3RaO3dCQUFHQzt3QkFBR3JEO3dCQUFHbVI7d0JBQUc7d0JBQUc7cUJBQUUsRUFBRWcyRTtvQkFDbERoaEUsS0FBSzZDLDZCQUE2QixDQUFDMmpDLFFBQVFxckI7b0JBQzNDdCtDLElBQUl3aUQsU0FBUyxJQUFJMzFGLEtBQUs0UCxHQUFHLENBQUM2aEYsRUFBRSxDQUFDLEVBQUUsRUFBRUEsRUFBRSxDQUFDLEVBQUUsSUFBSWtEO29CQUMxQ3hoRCxJQUFJeGMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDMHBFLGFBQWEsQ0FBQ3ZxQixNQUFNMm1CLGtCQUFrQitEO2dCQUN6RCxPQUFPO29CQUNMcnRELElBQUl3aUQsU0FBUyxJQUFJaEI7b0JBQ2pCeGhELElBQUl4YyxNQUFNLENBQUNtL0M7Z0JBQ2I7WUFDRjtZQUNBM2lDLElBQUlqZCxPQUFPO1FBQ2IsT0FBTztZQUNMLElBQUl1cUUsbUJBQW1CbHhFLGtCQUFrQkMsSUFBSSxJQUFJaXhFLG1CQUFtQmx4RSxrQkFBa0JHLFdBQVcsRUFBRTtnQkFDakd5akIsSUFBSWtoQyxRQUFRLENBQUNzQixXQUFXeDFFLEdBQUcwTTtnQkFDM0IsSUFBSSxDQUFDbTZFLGlCQUFpQixFQUFFN0Isb0JBQW9CdkIsT0FBT3p3QyxLQUFLMC9CLE1BQU04aEIsVUFBVXgwRixHQUFHME0sR0FBRyxJQUFNc21DLElBQUkwdEQsV0FBVyxDQUFDbHJCO1lBQ3RHO1lBQ0EsSUFBSThxQixtQkFBbUJseEUsa0JBQWtCRSxNQUFNLElBQUlneEUsbUJBQW1CbHhFLGtCQUFrQkcsV0FBVyxFQUFFO2dCQUNuRyxJQUFJLElBQUksQ0FBQ3MzRCxpQkFBaUIsRUFBRTtvQkFDMUIsSUFBSSxDQUFDQSxpQkFBaUIsRUFBRTdCLG9CQUFvQnZCLE9BQU96d0MsS0FBSzAvQixNQUFNOGhCLFVBQVV4MEYsR0FBRzBNLEdBQUcsSUFBTXNtQyxJQUFJMHRELFdBQVcsQ0FBQ2xyQixZQUFZcVEsbUJBQW1CcEMsT0FBT3dELGFBQWF6d0QsTUFBTTtnQkFDL0o7Z0JBQ0F3YyxJQUFJMnRELFVBQVUsQ0FBQ25yQixXQUFXeDFFLEdBQUcwTTtZQUMvQjtRQUNGO1FBQ0EsSUFBSTZ6RixnQkFBZ0I7WUFDbEIsTUFBTWYsUUFBUSxJQUFJLENBQUNDLGdCQUFnQixLQUFLLEVBQUU7WUFDMUNELE1BQU1sN0YsSUFBSSxDQUFDO2dCQUNUMHhCLFdBQVcrYyxvQkFBb0JDO2dCQUMvQmh6QztnQkFDQTBNO2dCQUNBOG5GO2dCQUNBN2U7WUFDRjtZQUNBLElBQUksQ0FBQ2tSLGlCQUFpQixFQUFFN0Isb0JBQW9CdkIsT0FBT3p3QyxLQUFLMC9CLE1BQU04aEIsVUFBVXgwRixHQUFHME07UUFDN0U7SUFDRjtJQUNBLElBQUlrMEYsMEJBQTBCO1FBQzVCLE1BQU0sRUFDSjU4RSxTQUFTZ3ZCLEdBQUcsRUFDYixHQUFHLElBQUksQ0FBQysxQyxjQUFjLENBQUNDLFNBQVMsQ0FBQywyQkFBMkIsSUFBSTtRQUNqRWgyQyxJQUFJckYsS0FBSyxDQUFDLEtBQUs7UUFDZnFGLElBQUlraEMsUUFBUSxDQUFDLEtBQUssR0FBRztRQUNyQixNQUFNdHFFLE9BQU9vcEMsSUFBSWtMLFlBQVksQ0FBQyxHQUFHLEdBQUcsSUFBSSxJQUFJdDBDLElBQUk7UUFDaEQsSUFBSXF2RCxVQUFVO1FBQ2QsSUFBSyxJQUFJajdELElBQUksR0FBR0EsSUFBSTRMLEtBQUt2USxNQUFNLEVBQUUyRSxLQUFLLEVBQUc7WUFDdkMsSUFBSTRMLElBQUksQ0FBQzVMLEVBQUUsR0FBRyxLQUFLNEwsSUFBSSxDQUFDNUwsRUFBRSxHQUFHLEtBQUs7Z0JBQ2hDaTdELFVBQVU7Z0JBQ1Y7WUFDRjtRQUNGO1FBQ0EsT0FBT3A4QixPQUFPLElBQUksRUFBRSwyQkFBMkJvOEI7SUFDakQ7SUFDQWpoQyxTQUFTeXJELEtBQUssRUFBRW9kLE1BQU0sRUFBRTtRQUN0QixJQUFJLElBQUksQ0FBQ2hhLGlCQUFpQixFQUFFO1lBQzFCLElBQUksQ0FBQ0EsaUJBQWlCLENBQUNoQixrQkFBa0IsQ0FBQ3BDLE9BQU93RCxhQUFhanZELFFBQVEsRUFBRTZzRCxTQUFTLENBQUNwQjtZQUNsRixJQUFJLElBQUksQ0FBQ3BzRSxPQUFPLENBQUM2OUUsaUJBQWlCLEdBQUc5bEUsa0JBQWtCVSxnQkFBZ0IsRUFBRTtnQkFDdkUsSUFBSSxDQUFDKzJELGlCQUFpQixDQUFDcEMsNEJBQTRCLENBQUMsWUFBWWhCLE9BQU9rQixvREFBb0Q7WUFDN0g7UUFDRjtRQUNBLE1BQU10dEUsVUFBVSxJQUFJLENBQUNBLE9BQU87UUFDNUIsTUFBTXE3RCxPQUFPcjdELFFBQVFxN0QsSUFBSTtRQUN6QixJQUFJQSxLQUFLdUQsV0FBVyxFQUFFO1lBQ3BCLElBQUksQ0FBQzZxQixhQUFhLENBQUNyZCxPQUFPb2Q7WUFDMUIsSUFBSSxDQUFDaGEsaUJBQWlCLEVBQUVULHdCQUF3QjNDO1lBQ2hELE9BQU83bUY7UUFDVDtRQUNBLE1BQU00M0YsV0FBV245RSxRQUFRbTlFLFFBQVE7UUFDakMsSUFBSUEsYUFBYSxHQUFHO1lBQ2xCLElBQUksQ0FBQzNOLGlCQUFpQixFQUFFYixnQkFBZ0J2QztZQUN4QyxPQUFPN21GO1FBQ1Q7UUFDQSxNQUFNbzJDLE1BQU0sSUFBSSxDQUFDQSxHQUFHO1FBQ3BCLE1BQU15aEQsZ0JBQWdCcDlFLFFBQVFvOUUsYUFBYTtRQUMzQyxNQUFNTSxjQUFjMTlFLFFBQVEwOUUsV0FBVztRQUN2QyxNQUFNQyxjQUFjMzlFLFFBQVEyOUUsV0FBVztRQUN2QyxNQUFNOEssZ0JBQWdCem9GLFFBQVF5b0YsYUFBYTtRQUMzQyxNQUFNN0ssYUFBYTU5RSxRQUFRNDlFLFVBQVUsR0FBRzZLO1FBQ3hDLE1BQU1pQixlQUFlRixPQUFPeG5HLE1BQU07UUFDbEMsTUFBTSs4RSxXQUFXMUQsS0FBSzBELFFBQVE7UUFDOUIsTUFBTTRxQixhQUFhNXFCLFdBQVcsSUFBSSxDQUFDO1FBQ25DLE1BQU1RLGtCQUFrQmxFLEtBQUtrRSxlQUFlO1FBQzVDLE1BQU1xcUIsb0JBQW9Cek0sV0FBV245RSxRQUFRby9ELFVBQVUsQ0FBQyxFQUFFO1FBQzFELE1BQU15cUIsaUJBQWlCN3BGLFFBQVE2OUUsaUJBQWlCLEtBQUs5bEUsa0JBQWtCQyxJQUFJLElBQUksQ0FBQ3FqRCxLQUFLUixlQUFlLElBQUksQ0FBQzc2RCxRQUFRKzlFLFdBQVc7UUFDNUhwaUQsSUFBSWxkLElBQUk7UUFDUixJQUFJemUsUUFBUXE5RSxVQUFVLEVBQUU7WUFDdEIxaEQsSUFBSWhkLFNBQVMsSUFBSTNlLFFBQVFxOUUsVUFBVTtRQUNyQztRQUNBMWhELElBQUlzd0IsU0FBUyxDQUFDanNELFFBQVFyWCxDQUFDLEVBQUVxWCxRQUFRM0ssQ0FBQyxHQUFHMkssUUFBUTg5RSxRQUFRO1FBQ3JELElBQUkySyxnQkFBZ0IsR0FBRztZQUNyQjlzRCxJQUFJckYsS0FBSyxDQUFDc25ELFlBQVksQ0FBQztRQUN6QixPQUFPO1lBQ0xqaUQsSUFBSXJGLEtBQUssQ0FBQ3NuRCxZQUFZO1FBQ3hCO1FBQ0EsSUFBSW1MLHNCQUFzQkM7UUFDMUIsSUFBSWhwRixRQUFRKzlFLFdBQVcsRUFBRTtZQUN2QnBpRCxJQUFJbGQsSUFBSTtZQUNSLE1BQU02eUQsVUFBVXR4RSxRQUFRbzRFLFNBQVMsQ0FBQy9ILFVBQVUsQ0FBQzEwQyxLQUFLLElBQUksRUFBRUUsMkJBQTJCRixNQUFNbzBDLFNBQVMvM0QsSUFBSSxFQUFFbzBEO1lBQ3hHMmMsdUJBQXVCcnRELG9CQUFvQkM7WUFDM0NBLElBQUlqZCxPQUFPO1lBQ1hpZCxJQUFJcTJDLFNBQVMsR0FBR1Y7UUFDbEI7UUFDQSxJQUFJdHhFLFFBQVFnK0UsYUFBYSxFQUFFO1lBQ3pCcmlELElBQUlsZCxJQUFJO1lBQ1IsTUFBTTZ5RCxVQUFVdHhFLFFBQVFxNEUsV0FBVyxDQUFDaEksVUFBVSxDQUFDMTBDLEtBQUssSUFBSSxFQUFFRSwyQkFBMkJGLE1BQU1vMEMsU0FBUzkzRCxNQUFNLEVBQUVtMEQ7WUFDNUc0Yyx5QkFBeUJ0dEQsb0JBQW9CQztZQUM3Q0EsSUFBSWpkLE9BQU87WUFDWGlkLElBQUl3OEMsV0FBVyxHQUFHN0c7UUFDcEI7UUFDQSxJQUFJNk0sWUFBWW4rRSxRQUFRbStFLFNBQVM7UUFDakMsTUFBTTduRCxRQUFRdDJCLFFBQVFzOUUsZUFBZTtRQUNyQyxJQUFJaG5ELFVBQVUsS0FBSzZuRCxjQUFjLEdBQUc7WUFDbEMsTUFBTThLLGlCQUFpQmpwRixRQUFRNjlFLGlCQUFpQixHQUFHOWxFLGtCQUFrQlMsZ0JBQWdCO1lBQ3JGLElBQUl5d0UsbUJBQW1CbHhFLGtCQUFrQkUsTUFBTSxJQUFJZ3hFLG1CQUFtQmx4RSxrQkFBa0JHLFdBQVcsRUFBRTtnQkFDbkdpbUUsWUFBWSxJQUFJLENBQUMyTCxtQkFBbUI7WUFDdEM7UUFDRixPQUFPO1lBQ0wzTCxhQUFhN25EO1FBQ2Y7UUFDQSxJQUFJOG1ELGtCQUFrQixLQUFLO1lBQ3pCemhELElBQUlyRixLQUFLLENBQUM4bUQsZUFBZUE7WUFDekJlLGFBQWFmO1FBQ2Y7UUFDQXpoRCxJQUFJd2lELFNBQVMsR0FBR0E7UUFDaEIsSUFBSTlpQixLQUFLc0Qsa0JBQWtCLEVBQUU7WUFDM0IsTUFBTW9yQixRQUFRLEVBQUU7WUFDaEIsSUFBSTV5RCxRQUFRO1lBQ1osS0FBSyxNQUFNNnlELFNBQVNSLE9BQVE7Z0JBQzFCTyxNQUFNOThGLElBQUksQ0FBQys4RixNQUFNQyxPQUFPO2dCQUN4Qjl5RCxTQUFTNnlELE1BQU03eUQsS0FBSztZQUN0QjtZQUNBLE1BQU0reUQsY0FBY0gsTUFBTXRsRyxJQUFJLENBQUM7WUFDL0JrM0MsSUFBSWtoQyxRQUFRLENBQUNxdEIsYUFBYSxHQUFHO1lBQzdCLElBQUksSUFBSSxDQUFDMWEsaUJBQWlCLEtBQUssTUFBTTtnQkFDbkMsTUFBTXZCLFVBQVV0eUMsSUFBSTB0RCxXQUFXLENBQUNhO2dCQUNoQyxJQUFJLENBQUMxYSxpQkFBaUIsQ0FBQzlCLFVBQVUsQ0FBQ3RCLE9BQU8sSUFBSSxDQUFDendDLEdBQUcsRUFBRSxDQUFDc3lDLFFBQVFDLHFCQUFxQixFQUFFRCxRQUFRRSxzQkFBc0IsRUFBRSxDQUFDRixRQUFRRyx1QkFBdUIsRUFBRUgsUUFBUUksd0JBQXdCLEVBQUVVLHVCQUF1QixDQUFDM0M7WUFDak47WUFDQXBzRSxRQUFRclgsQ0FBQyxJQUFJd3VDLFFBQVF5eUQsb0JBQW9CaE07WUFDekNqaUQsSUFBSWpkLE9BQU87WUFDWCxJQUFJLENBQUMybkUsT0FBTztZQUNaLE9BQU85Z0c7UUFDVDtRQUNBLElBQUlvRCxJQUFJLEdBQ05oQztRQUNGLElBQUtBLElBQUksR0FBR0EsSUFBSStpRyxjQUFjLEVBQUUvaUcsRUFBRztZQUNqQyxNQUFNcWpHLFFBQVFSLE1BQU0sQ0FBQzdpRyxFQUFFO1lBQ3ZCLElBQUksT0FBT3FqRyxVQUFVLFVBQVU7Z0JBQzdCcmhHLEtBQUtnaEcsYUFBYUssUUFBUTdNLFdBQVc7Z0JBQ3JDO1lBQ0Y7WUFDQSxJQUFJZ04sZ0JBQWdCO1lBQ3BCLE1BQU03QixVQUFVLENBQUMwQixNQUFNSSxPQUFPLEdBQUd6TSxjQUFjLEtBQUtEO1lBQ3BELE1BQU12ZixZQUFZNnJCLE1BQU1LLFFBQVE7WUFDaEMsTUFBTUMsU0FBU04sTUFBTU0sTUFBTTtZQUMzQixJQUFJQyxTQUFTQztZQUNiLElBQUlyekQsUUFBUTZ5RCxNQUFNN3lELEtBQUs7WUFDdkIsSUFBSTRuQyxVQUFVO2dCQUNaLE1BQU0wckIsVUFBVVQsTUFBTVMsT0FBTyxJQUFJbHJCO2dCQUNqQyxNQUFNbXJCLEtBQUssQ0FBRVYsQ0FBQUEsTUFBTVMsT0FBTyxHQUFHQSxPQUFPLENBQUMsRUFBRSxHQUFHdHpELFFBQVEsR0FBRSxJQUFLeXlEO2dCQUN6RCxNQUFNZSxLQUFLRixPQUFPLENBQUMsRUFBRSxHQUFHYjtnQkFDeEJ6eUQsUUFBUXN6RCxVQUFVLENBQUNBLE9BQU8sQ0FBQyxFQUFFLEdBQUd0ekQ7Z0JBQ2hDb3pELFVBQVVHLEtBQUt0TjtnQkFDZm9OLFVBQVUsQ0FBQzdoRyxJQUFJZ2lHLEVBQUMsSUFBS3ZOO1lBQ3ZCLE9BQU87Z0JBQ0xtTixVQUFVNWhHLElBQUl5MEY7Z0JBQ2RvTixVQUFVO1lBQ1o7WUFDQSxJQUFJdmM7WUFDSixJQUFJNVMsS0FBS3lELFNBQVMsSUFBSTNuQyxRQUFRLEdBQUc7Z0JBQy9CODJDLFVBQVV0eUMsSUFBSTB0RCxXQUFXLENBQUNsckI7Z0JBQzFCLE1BQU15c0IsZ0JBQWdCM2MsUUFBUTkyQyxLQUFLLEdBQUcsT0FBT2dtRCxXQUFXQztnQkFDeEQsSUFBSWptRCxRQUFReXpELGlCQUFpQixJQUFJLENBQUNyQix1QkFBdUIsRUFBRTtvQkFDekQsTUFBTXNCLGtCQUFrQjF6RCxRQUFReXpEO29CQUNoQ1QsZ0JBQWdCO29CQUNoQnh1RCxJQUFJbGQsSUFBSTtvQkFDUmtkLElBQUlyRixLQUFLLENBQUN1MEQsaUJBQWlCO29CQUMzQk4sV0FBV007Z0JBQ2IsT0FBTyxJQUFJMXpELFVBQVV5ekQsZUFBZTtvQkFDbENMLFdBQVcsQ0FBQ3B6RCxRQUFReXpELGFBQVksSUFBSyxPQUFPek4sV0FBV0M7Z0JBQ3pEO1lBQ0Y7WUFDQSxJQUFJLElBQUksQ0FBQzRFLGNBQWMsSUFBS2dJLENBQUFBLE1BQU1jLFFBQVEsSUFBSXp2QixLQUFLRSxXQUFXLEdBQUc7Z0JBQy9ELElBQUlzdUIsa0JBQWtCLENBQUNTLFFBQVE7b0JBQzdCM3VELElBQUlraEMsUUFBUSxDQUFDc0IsV0FBV29zQixTQUFTQztvQkFDakMsSUFBSSxDQUFDaGIsaUJBQWlCLEVBQUU3QixvQkFBb0J2QixPQUFPendDLEtBQUtzeUMsVUFBVTt3QkFDaEU5TyxNQUFNO29CQUNSLElBQUk5RCxNQUFNOGhCLFdBQVdDLGVBQWVtTixTQUFTQyxTQUFTLElBQU12YyxXQUFXdHlDLElBQUkwdEQsV0FBVyxDQUFDbHJCO2dCQUN6RixPQUFPO29CQUNMLElBQUksQ0FBQzJxQixTQUFTLENBQUMxYyxPQUFPak8sV0FBV29zQixTQUFTQyxTQUFTekIsc0JBQXNCQztvQkFDekUsSUFBSXNCLFFBQVE7d0JBQ1YsTUFBTVMsZ0JBQWdCUixVQUFVcE4sV0FBV21OLE9BQU9odUIsTUFBTSxDQUFDM3pFLENBQUMsR0FBR3kwRjt3QkFDN0QsTUFBTTROLGdCQUFnQlIsVUFBVXJOLFdBQVdtTixPQUFPaHVCLE1BQU0sQ0FBQ2puRSxDQUFDLEdBQUcrbkY7d0JBQzdELElBQUksQ0FBQzBMLFNBQVMsQ0FBQzFjLE9BQU9rZSxPQUFPRCxRQUFRLEVBQUVVLGVBQWVDLGVBQWVqQyxzQkFBc0JDO29CQUM3RjtnQkFDRjtZQUNGO1lBQ0EsTUFBTWlDLFlBQVlsc0IsV0FBVzVuQyxRQUFReXlELG9CQUFvQnRCLFVBQVVHLGdCQUFnQnR4RCxRQUFReXlELG9CQUFvQnRCLFVBQVVHO1lBQ3pIOS9GLEtBQUtzaUc7WUFDTCxJQUFJZCxlQUFlO2dCQUNqQnh1RCxJQUFJamQsT0FBTztZQUNiO1FBQ0Y7UUFDQSxJQUFJcWdELFVBQVU7WUFDWi8rRCxRQUFRM0ssQ0FBQyxJQUFJMU07UUFDZixPQUFPO1lBQ0xxWCxRQUFRclgsQ0FBQyxJQUFJQSxJQUFJaTFGO1FBQ25CO1FBQ0FqaUQsSUFBSWpkLE9BQU87UUFDWCxJQUFJLENBQUMybkUsT0FBTztRQUNaLElBQUksQ0FBQzdXLGlCQUFpQixFQUFFVCx3QkFBd0IzQztRQUNoRCxPQUFPN21GO0lBQ1Q7SUFDQWtrRyxjQUFjcmQsS0FBSyxFQUFFb2QsTUFBTSxFQUFFO1FBQzNCLE1BQU03dEQsTUFBTSxJQUFJLENBQUNBLEdBQUc7UUFDcEIsTUFBTTM3QixVQUFVLElBQUksQ0FBQ0EsT0FBTztRQUM1QixNQUFNcTdELE9BQU9yN0QsUUFBUXE3RCxJQUFJO1FBQ3pCLE1BQU04aEIsV0FBV245RSxRQUFRbTlFLFFBQVE7UUFDakMsTUFBTXNMLGdCQUFnQnpvRixRQUFReW9GLGFBQWE7UUFDM0MsTUFBTWtCLGFBQWF0dUIsS0FBSzBELFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDeEMsTUFBTTJlLGNBQWMxOUUsUUFBUTA5RSxXQUFXO1FBQ3ZDLE1BQU1DLGNBQWMzOUUsUUFBUTI5RSxXQUFXO1FBQ3ZDLE1BQU1DLGFBQWE1OUUsUUFBUTQ5RSxVQUFVLEdBQUc2SztRQUN4QyxNQUFNcnBCLGFBQWFwL0QsUUFBUW8vRCxVQUFVLElBQUl4cUQ7UUFDekMsTUFBTTgwRSxlQUFlRixPQUFPeG5HLE1BQU07UUFDbEMsTUFBTWtwRyxrQkFBa0JsckYsUUFBUTY5RSxpQkFBaUIsS0FBSzlsRSxrQkFBa0JJLFNBQVM7UUFDakYsSUFBSXh4QixHQUFHcWpHLE9BQU83eUQsT0FBT2cwRDtRQUNyQixJQUFJRCxtQkFBbUIvTixhQUFhLEdBQUc7WUFDckM7UUFDRjtRQUNBLElBQUksQ0FBQ2tGLHVCQUF1QixDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25DLElBQUksQ0FBQ0MsMEJBQTBCLEdBQUc7UUFDbEMzbUQsSUFBSWxkLElBQUk7UUFDUixJQUFJemUsUUFBUXE5RSxVQUFVLEVBQUU7WUFDdEIxaEQsSUFBSWhkLFNBQVMsSUFBSTNlLFFBQVFxOUUsVUFBVTtRQUNyQztRQUNBMWhELElBQUlzd0IsU0FBUyxDQUFDanNELFFBQVFyWCxDQUFDLEVBQUVxWCxRQUFRM0ssQ0FBQyxHQUFHMkssUUFBUTg5RSxRQUFRO1FBQ3JEbmlELElBQUlyRixLQUFLLENBQUNzbkQsWUFBWTZLO1FBQ3RCLE1BQU1qWixvQkFBb0IsSUFBSSxDQUFDQSxpQkFBaUI7UUFDaEQsSUFBSSxDQUFDQSxpQkFBaUIsR0FBR0Esb0JBQW9CLElBQUlELDhCQUE4QkMsbUJBQW1CcEQsU0FBUztRQUMzRyxJQUFLemxGLElBQUksR0FBR0EsSUFBSStpRyxjQUFjLEVBQUUvaUcsRUFBRztZQUNqQ3FqRyxRQUFRUixNQUFNLENBQUM3aUcsRUFBRTtZQUNqQixJQUFJLE9BQU9xakcsVUFBVSxVQUFVO2dCQUM3Qm1CLGdCQUFnQnhCLGFBQWFLLFFBQVE3TSxXQUFXO2dCQUNoRCxJQUFJLENBQUN4aEQsR0FBRyxDQUFDc3dCLFNBQVMsQ0FBQ2svQixlQUFlO2dCQUNsQ25yRixRQUFRclgsQ0FBQyxJQUFJd2lHLGdCQUFnQnZOO2dCQUM3QjtZQUNGO1lBQ0EsTUFBTTBLLFVBQVUsQ0FBQzBCLE1BQU1JLE9BQU8sR0FBR3pNLGNBQWMsS0FBS0Q7WUFDcEQsTUFBTXpILGVBQWU1YSxLQUFLb0Msb0JBQW9CLENBQUN1c0IsTUFBTW9CLGNBQWMsQ0FBQztZQUNwRSxJQUFJLENBQUNuVixjQUFjO2dCQUNqQjF4RCxLQUFLLENBQUMsaUJBQWlCLEVBQUV5bEUsTUFBTW9CLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQztZQUNwRSxPQUFPLElBQUksSUFBSSxDQUFDcEosY0FBYyxFQUFFO2dCQUM5QixJQUFJLENBQUN2akUsSUFBSTtnQkFDVGtkLElBQUlyRixLQUFLLENBQUM2bUQsVUFBVUE7Z0JBQ3BCeGhELElBQUloZCxTQUFTLElBQUl5Z0Q7Z0JBQ2pCLElBQUksQ0FBQ21ZLG1CQUFtQixDQUFDdEI7Z0JBQ3pCLElBQUksQ0FBQ3YzRCxPQUFPO1lBQ2Q7WUFDQSxNQUFNdUssSUFBSTtnQkFBQytnRSxNQUFNN3lELEtBQUs7Z0JBQUU7YUFBRTtZQUMxQi9PLEtBQUtZLGNBQWMsQ0FBQ0MsR0FBR20yQztZQUN2QmpvQyxRQUFRbE8sQ0FBQyxDQUFDLEVBQUUsR0FBR2swRCxXQUFXbUw7WUFDMUIzc0QsSUFBSXN3QixTQUFTLENBQUM5MEIsT0FBTztZQUNyQm4zQixRQUFRclgsQ0FBQyxJQUFJd3VDLFFBQVF5bUQ7UUFDdkI7UUFDQWppRCxJQUFJamQsT0FBTztRQUNYLElBQUk4d0QsbUJBQW1CO1lBQ3JCLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUdBO1FBQzNCO0lBQ0Y7SUFDQXp1RCxhQUFhcXJELEtBQUssRUFBRWlmLE1BQU0sRUFBRUMsTUFBTSxFQUFFLENBQUM7SUFDckN0cUUsc0JBQXNCb3JELEtBQUssRUFBRWlmLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUU7UUFDL0QsTUFBTTlyRSxPQUFPLElBQUkyK0M7UUFDakIzK0MsS0FBS2tLLElBQUksQ0FBQ3loRSxLQUFLQyxLQUFLQyxNQUFNRixLQUFLRyxNQUFNRjtRQUNyQyxJQUFJLENBQUM3dkQsR0FBRyxDQUFDL2IsSUFBSSxDQUFDQTtRQUNkLElBQUksQ0FBQzR2RCxpQkFBaUIsRUFBRTlCLFdBQVd0QixPQUFPLElBQUksQ0FBQ3p3QyxHQUFHLEVBQUU0dkQsS0FBS0UsS0FBS0QsS0FBS0UsS0FBS2plLGNBQWNyQixPQUFPLElBQUksQ0FBQ3p3QyxHQUFHLEVBQUU0dkQsS0FBS0UsS0FBS0QsS0FBS0U7UUFDdEgsSUFBSSxDQUFDL3JFLE9BQU8sQ0FBQ3lzRDtJQUNmO0lBQ0F1ZixrQkFBa0J2ZixLQUFLLEVBQUVtRSxFQUFFLEVBQUU7UUFDM0IsSUFBSWU7UUFDSixJQUFJZixFQUFFLENBQUMsRUFBRSxLQUFLLGlCQUFpQjtZQUM3QixNQUFNd0IsZ0JBQWdCLElBQUksQ0FBQ0EsYUFBYSxJQUFJcjJDLG9CQUFvQixJQUFJLENBQUNDLEdBQUc7WUFDeEUsTUFBTXE2Qyx3QkFBd0I7Z0JBQzVCbUIsc0JBQXNCLENBQUN4N0MsS0FBS2l3RCxpQkFBbUIsSUFBSTFLLGVBQWV2bEQsS0FBSyxJQUFJLENBQUN5bEQsVUFBVSxFQUFFLElBQUksQ0FBQ2xqQixJQUFJLEVBQUUsSUFBSSxDQUFDMGQsYUFBYSxFQUFFLElBQUksQ0FBQzV2QyxhQUFhLEVBQUU7d0JBQ3pJcTFDLHVCQUF1QixJQUFJLENBQUNBLHFCQUFxQjt3QkFDakRuVyxvQkFBb0IsSUFBSSxDQUFDQSxrQkFBa0I7b0JBQzdDLEdBQUczbEYsV0FBV0EsV0FBVyxJQUFJLENBQUNpcUYsaUJBQWlCLEdBQUcsSUFBSUQsOEJBQThCLElBQUksQ0FBQ0MsaUJBQWlCLEVBQUVvYyxnQkFBZ0IsUUFBUTtZQUN0STtZQUNBdGEsVUFBVSxJQUFJeUUsY0FBY3hGLElBQUksSUFBSSxDQUFDNTBDLEdBQUcsRUFBRXE2Qyx1QkFBdUJqRTtRQUNuRSxPQUFPO1lBQ0xULFVBQVUsSUFBSSxDQUFDdWEsV0FBVyxDQUFDemYsT0FBT21FLEVBQUUsQ0FBQyxFQUFFLEVBQUVBLEVBQUUsQ0FBQyxFQUFFO1FBQ2hEO1FBQ0EsT0FBT2U7SUFDVDtJQUNBbHdELGdCQUFnQmdyRCxLQUFLLEVBQUUsR0FBR25nRixJQUFJLEVBQUU7UUFDOUIsSUFBSSxDQUFDdWpGLGlCQUFpQixFQUFFM0MsaUJBQWlCLGVBQWVUO1FBQ3hELElBQUksQ0FBQ3BzRSxPQUFPLENBQUNxNEUsV0FBVyxHQUFHLElBQUksQ0FBQ3NULGlCQUFpQixDQUFDdmYsT0FBT25nRjtRQUN6RCxJQUFJLENBQUMrVCxPQUFPLENBQUNnK0UsYUFBYSxHQUFHO0lBQy9CO0lBQ0ExOEQsY0FBYzhxRCxLQUFLLEVBQUUsR0FBR25nRixJQUFJLEVBQUU7UUFDNUIsSUFBSSxDQUFDdWpGLGlCQUFpQixFQUFFM0MsaUJBQWlCLGFBQWFUO1FBQ3RELElBQUksQ0FBQ3BzRSxPQUFPLENBQUNvNEUsU0FBUyxHQUFHLElBQUksQ0FBQ3VULGlCQUFpQixDQUFDdmYsT0FBT25nRjtRQUN2RCxJQUFJLENBQUMrVCxPQUFPLENBQUMrOUUsV0FBVyxHQUFHO0lBQzdCO0lBQ0F0OEQsa0JBQWtCMnFELEtBQUssRUFBRXB4QyxLQUFLLEVBQUU7UUFDOUIsSUFBSSxDQUFDdzBDLGlCQUFpQixFQUFFM0MsaUJBQWlCLGVBQWVUO1FBQ3hELElBQUksQ0FBQ3p3QyxHQUFHLENBQUN3OEMsV0FBVyxHQUFHLElBQUksQ0FBQ240RSxPQUFPLENBQUNxNEUsV0FBVyxHQUFHcjlDO1FBQ2xELElBQUksQ0FBQ2g3QixPQUFPLENBQUNnK0UsYUFBYSxHQUFHO0lBQy9CO0lBQ0F4NkQscUJBQXFCNG9ELEtBQUssRUFBRTtRQUMxQixJQUFJLENBQUNvRCxpQkFBaUIsRUFBRTNDLGlCQUFpQixlQUFlVDtRQUN4RCxJQUFJLENBQUN6d0MsR0FBRyxDQUFDdzhDLFdBQVcsR0FBRyxJQUFJLENBQUNuNEUsT0FBTyxDQUFDcTRFLFdBQVcsR0FBRztRQUNsRCxJQUFJLENBQUNyNEUsT0FBTyxDQUFDZytFLGFBQWEsR0FBRztJQUMvQjtJQUNBdDhELGdCQUFnQjBxRCxLQUFLLEVBQUVweEMsS0FBSyxFQUFFO1FBQzVCLElBQUksQ0FBQ3cwQyxpQkFBaUIsRUFBRTNDLGlCQUFpQixhQUFhVDtRQUN0RCxJQUFJLENBQUN6d0MsR0FBRyxDQUFDcTJDLFNBQVMsR0FBRyxJQUFJLENBQUNoeUUsT0FBTyxDQUFDbzRFLFNBQVMsR0FBR3A5QztRQUM5QyxJQUFJLENBQUNoN0IsT0FBTyxDQUFDKzlFLFdBQVcsR0FBRztJQUM3QjtJQUNBdDZELG1CQUFtQjJvRCxLQUFLLEVBQUU7UUFDeEIsSUFBSSxDQUFDb0QsaUJBQWlCLEVBQUUzQyxpQkFBaUIsYUFBYVQ7UUFDdEQsSUFBSSxDQUFDendDLEdBQUcsQ0FBQ3EyQyxTQUFTLEdBQUcsSUFBSSxDQUFDaHlFLE9BQU8sQ0FBQ280RSxTQUFTLEdBQUc7UUFDOUMsSUFBSSxDQUFDcDRFLE9BQU8sQ0FBQys5RSxXQUFXLEdBQUc7SUFDN0I7SUFDQThOLFlBQVl6ZixLQUFLLEVBQUVoTyxLQUFLLEVBQUVsekMsU0FBUyxJQUFJLEVBQUU7UUFDdkMsSUFBSW9tRDtRQUNKLElBQUksSUFBSSxDQUFDMlEsY0FBYyxDQUFDejNGLEdBQUcsQ0FBQzR6RSxRQUFRO1lBQ2xDa1QsVUFBVSxJQUFJLENBQUMyUSxjQUFjLENBQUNoK0YsR0FBRyxDQUFDbTZFO1FBQ3BDLE9BQU87WUFDTGtULFVBQVVxRSxrQkFBa0IsSUFBSSxDQUFDNk0sU0FBUyxDQUFDcFcsT0FBT2hPO1lBQ2xELElBQUksQ0FBQzZqQixjQUFjLENBQUMxM0YsR0FBRyxDQUFDNnpFLE9BQU9rVDtRQUNqQztRQUNBLElBQUlwbUQsUUFBUTtZQUNWb21ELFFBQVFwbUQsTUFBTSxHQUFHQTtRQUNuQjtRQUNBLE9BQU9vbUQ7SUFDVDtJQUNBenZELFlBQVl1cUQsS0FBSyxFQUFFaE8sS0FBSyxFQUFFO1FBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUM0akIsY0FBYyxFQUFFO1lBQ3hCO1FBQ0Y7UUFDQSxNQUFNcm1ELE1BQU0sSUFBSSxDQUFDQSxHQUFHO1FBQ3BCLElBQUksQ0FBQ2xkLElBQUksQ0FBQzJ0RDtRQUNWLE1BQU1rRixVQUFVLElBQUksQ0FBQ3VhLFdBQVcsQ0FBQ3pmLE9BQU9oTztRQUN4Q3ppQyxJQUFJcTJDLFNBQVMsR0FBR1YsUUFBUWpCLFVBQVUsQ0FBQzEwQyxLQUFLLElBQUksRUFBRUUsMkJBQTJCRixNQUFNbzBDLFNBQVNDLE9BQU8sRUFBRTVEO1FBQ2pHLE1BQU0wZixNQUFNandELDJCQUEyQkY7UUFDdkMsSUFBSW13RCxLQUFLO1lBQ1AsTUFBTSxFQUNKMzBELEtBQUssRUFDTEMsTUFBTSxFQUNQLEdBQUd1RSxJQUFJMkssTUFBTTtZQUNkLE1BQU0zZCxTQUFTdXhELGFBQWEzMUYsS0FBSztZQUNqQzZqQyxLQUFLeUIsdUJBQXVCLENBQUM7Z0JBQUM7Z0JBQUc7Z0JBQUdzTjtnQkFBT0M7YUFBTyxFQUFFMDBELEtBQUtuakU7WUFDekQsTUFBTSxDQUFDcUQsSUFBSUMsSUFBSUMsSUFBSUMsR0FBRyxHQUFHeEQ7WUFDekIsSUFBSSxDQUFDZ1QsR0FBRyxDQUFDa25ELFFBQVEsQ0FBQzcyRCxJQUFJQyxJQUFJQyxLQUFLRixJQUFJRyxLQUFLRjtRQUMxQyxPQUFPO1lBQ0wsSUFBSSxDQUFDMFAsR0FBRyxDQUFDa25ELFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLE1BQU07UUFDeEM7UUFDQSxJQUFJLENBQUNyVCxpQkFBaUIsRUFBRWhDLFVBQVVwQixPQUFPNEIsbUJBQW1CNUIsT0FBT29DLG1CQUFtQnBDLE9BQU93RCxhQUFhanhELFNBQVMsRUFBRTZ2RCxtQkFBbUJwQyxPQUFPd0QsYUFBYXZ3RCxJQUFJLEVBQUVzdkQsZ0JBQWdCdkM7UUFDbEwsSUFBSSxDQUFDaWEsT0FBTyxDQUFDLElBQUksQ0FBQ3JtRixPQUFPLENBQUN3eEUseUJBQXlCO1FBQ25ELElBQUksQ0FBQzl5RCxPQUFPLENBQUMwdEQ7SUFDZjtJQUNBdHFELG1CQUFtQjtRQUNqQjBDLFlBQVk7SUFDZDtJQUNBekMsaUJBQWlCO1FBQ2Z5QyxZQUFZO0lBQ2Q7SUFDQS9CLHNCQUFzQjJwRCxLQUFLLEVBQUVsaEQsTUFBTSxFQUFFaTBDLElBQUksRUFBRTtRQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDNmlCLGNBQWMsRUFBRTtZQUN4QjtRQUNGO1FBQ0EsSUFBSSxDQUFDdmpFLElBQUksQ0FBQzJ0RDtRQUNWLElBQUksQ0FBQ2pCLGtCQUFrQixDQUFDbCtFLElBQUksQ0FBQyxJQUFJLENBQUM4a0YsYUFBYTtRQUMvQyxJQUFJN21ELFFBQVE7WUFDVixJQUFJLENBQUN2TSxTQUFTLENBQUN5dEQsVUFBVWxoRDtRQUMzQjtRQUNBLElBQUksQ0FBQzZtRCxhQUFhLEdBQUdyMkMsb0JBQW9CLElBQUksQ0FBQ0MsR0FBRztRQUNqRCxJQUFJd2pDLE1BQU07WUFDUi8yQyxLQUFLeUIsdUJBQXVCLENBQUNzMUMsTUFBTSxJQUFJLENBQUM0UyxhQUFhLEVBQUUsSUFBSSxDQUFDL3hFLE9BQU8sQ0FBQzJvQixNQUFNO1lBQzFFLE1BQU0sQ0FBQ3FELElBQUlDLElBQUlDLElBQUlDLEdBQUcsR0FBR2d6QztZQUN6QixNQUFNdi9DLE9BQU8sSUFBSTIrQztZQUNqQjMrQyxLQUFLa0ssSUFBSSxDQUFDa0MsSUFBSUMsSUFBSUMsS0FBS0YsSUFBSUcsS0FBS0Y7WUFDaEMsSUFBSSxDQUFDMFAsR0FBRyxDQUFDL2IsSUFBSSxDQUFDQTtZQUNkLElBQUksQ0FBQzR2RCxpQkFBaUIsRUFBRS9CLGNBQWNyQixPQUFPLElBQUksQ0FBQ3p3QyxHQUFHLEVBQUUzUCxJQUFJRSxJQUFJRCxJQUFJRTtZQUNuRSxJQUFJLENBQUN4TSxPQUFPLENBQUN5c0Q7UUFDZjtJQUNGO0lBQ0ExcEQsb0JBQW9CMHBELEtBQUssRUFBRTtRQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDNFYsY0FBYyxFQUFFO1lBQ3hCO1FBQ0Y7UUFDQSxJQUFJLENBQUN0akUsT0FBTyxDQUFDMHREO1FBQ2IsSUFBSSxDQUFDMkYsYUFBYSxHQUFHLElBQUksQ0FBQzVHLGtCQUFrQixDQUFDNTJDLEdBQUc7SUFDbEQ7SUFDQTVSLFdBQVd5cEQsS0FBSyxFQUFFMmYsS0FBSyxFQUFFO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMvSixjQUFjLEVBQUU7WUFDeEI7UUFDRjtRQUNBLElBQUksQ0FBQ3ZqRSxJQUFJLENBQUMydEQ7UUFDVixJQUFJLElBQUksQ0FBQzZYLFdBQVcsRUFBRTtZQUNwQixJQUFJLENBQUNpQyxZQUFZO1lBQ2pCLElBQUksQ0FBQ2xtRixPQUFPLENBQUNvK0UsV0FBVyxHQUFHO1FBQzdCO1FBQ0EsTUFBTTROLGFBQWEsSUFBSSxDQUFDcndELEdBQUc7UUFDM0IsSUFBSSxDQUFDb3dELE1BQU1FLFFBQVEsRUFBRTtZQUNuQjduRSxLQUFLO1FBQ1A7UUFDQSxJQUFJMm5FLE1BQU1HLFFBQVEsRUFBRTtZQUNsQjNuRSxLQUFLO1FBQ1A7UUFDQSxNQUFNMGdFLG1CQUFtQnZwRCxvQkFBb0Jzd0Q7UUFDN0MsSUFBSUQsTUFBTTdnRSxNQUFNLEVBQUU7WUFDaEI4Z0UsV0FBV3J0RSxTQUFTLElBQUlvdEUsTUFBTTdnRSxNQUFNO1FBQ3RDO1FBQ0EsSUFBSSxDQUFDNmdFLE1BQU01c0IsSUFBSSxFQUFFO1lBQ2YsTUFBTSxJQUFJaC9ELE1BQU07UUFDbEI7UUFDQSxJQUFJZ3NGLFNBQVNqUyxhQUFhMzFGLEtBQUs7UUFDL0I2akMsS0FBS3lCLHVCQUF1QixDQUFDa2lFLE1BQU01c0IsSUFBSSxFQUFFempDLG9CQUFvQnN3RCxhQUFhRztRQUMxRSxNQUFNQyxlQUFlO1lBQUM7WUFBRztZQUFHSixXQUFXMWxELE1BQU0sQ0FBQ25QLEtBQUs7WUFBRTYwRCxXQUFXMWxELE1BQU0sQ0FBQ2xQLE1BQU07U0FBQztRQUM5RSswRCxTQUFTL2pFLEtBQUttRCxTQUFTLENBQUM0Z0UsUUFBUUMsaUJBQWlCO1lBQUM7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUM3RCxNQUFNNTFELFVBQVVodUMsS0FBS0MsS0FBSyxDQUFDMGpHLE1BQU0sQ0FBQyxFQUFFO1FBQ3BDLE1BQU0xMUQsVUFBVWp1QyxLQUFLQyxLQUFLLENBQUMwakcsTUFBTSxDQUFDLEVBQUU7UUFDcEMsTUFBTTVHLGFBQWEvOEYsS0FBSzRQLEdBQUcsQ0FBQzVQLEtBQUtELElBQUksQ0FBQzRqRyxNQUFNLENBQUMsRUFBRSxJQUFJMzFELFNBQVM7UUFDNUQsTUFBTWd2RCxjQUFjaDlGLEtBQUs0UCxHQUFHLENBQUM1UCxLQUFLRCxJQUFJLENBQUM0akcsTUFBTSxDQUFDLEVBQUUsSUFBSTExRCxTQUFTO1FBQzdELElBQUksQ0FBQ3oyQixPQUFPLENBQUMwK0Usc0JBQXNCLENBQUM7WUFBQztZQUFHO1lBQUc2RztZQUFZQztTQUFZO1FBQ25FLElBQUlXLFVBQVUsWUFBWSxJQUFJLENBQUMvTyxVQUFVO1FBQ3pDLElBQUkyVSxNQUFNeEYsS0FBSyxFQUFFO1lBQ2ZKLFdBQVcsWUFBWSxJQUFJLENBQUN0RSxZQUFZLEtBQUs7UUFDL0M7UUFDQSxNQUFNdUUsZ0JBQWdCLElBQUksQ0FBQzFVLGNBQWMsQ0FBQ0MsU0FBUyxDQUFDd1UsU0FBU1osWUFBWUM7UUFDekUsTUFBTTZHLFdBQVdqRyxjQUFjejVFLE9BQU87UUFDdEMwL0UsU0FBU3BnQyxTQUFTLENBQUMsQ0FBQ3oxQixTQUFTLENBQUNDO1FBQzlCNDFELFNBQVMxdEUsU0FBUyxJQUFJc21FO1FBQ3RCLElBQUlybEUsT0FBTyxJQUFJMitDO1FBQ2YsTUFBTSxDQUFDdnlDLElBQUlDLElBQUlDLElBQUlDLEdBQUcsR0FBRzQvRCxNQUFNNXNCLElBQUk7UUFDbkN2L0MsS0FBS2tLLElBQUksQ0FBQ2tDLElBQUlDLElBQUlDLEtBQUtGLElBQUlHLEtBQUtGO1FBQ2hDLElBQUk4L0QsTUFBTTdnRSxNQUFNLEVBQUU7WUFDaEIsTUFBTW96QyxPQUFPLElBQUlDO1lBQ2pCRCxLQUFLeXBCLE9BQU8sQ0FBQ25vRSxNQUFNLElBQUl3cEQsVUFBVTJpQixNQUFNN2dFLE1BQU07WUFDN0N0TCxPQUFPMCtDO1FBQ1Q7UUFDQSt0QixTQUFTenNFLElBQUksQ0FBQ0E7UUFDZCxJQUFJbXNFLE1BQU14RixLQUFLLEVBQUU7WUFDZixJQUFJLENBQUMzRSxVQUFVLENBQUMzMEYsSUFBSSxDQUFDO2dCQUNuQnE1QyxRQUFROC9DLGNBQWM5L0MsTUFBTTtnQkFDNUIzNUIsU0FBUzAvRTtnQkFDVDcxRDtnQkFDQUM7Z0JBQ0F1d0QsU0FBUytFLE1BQU14RixLQUFLLENBQUNTLE9BQU87Z0JBQzVCQyxVQUFVOEUsTUFBTXhGLEtBQUssQ0FBQ1UsUUFBUTtnQkFDOUJDLGFBQWE2RSxNQUFNeEYsS0FBSyxDQUFDVyxXQUFXLElBQUk7Z0JBQ3hDb0YsdUJBQXVCO1lBQ3pCO1FBQ0Y7UUFDQSxJQUFJLENBQUNQLE1BQU14RixLQUFLLElBQUksSUFBSSxDQUFDL1csaUJBQWlCLEVBQUU7WUFDMUN3YyxXQUFXN1osWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztZQUN2QzZaLFdBQVcvL0IsU0FBUyxDQUFDejFCLFNBQVNDO1lBQzlCdTFELFdBQVd2dEUsSUFBSTtRQUNqQjtRQUNBb2hFLGFBQWFtTSxZQUFZSztRQUN6QixJQUFJLENBQUMxd0QsR0FBRyxHQUFHMHdEO1FBQ1gsSUFBSSxDQUFDN2MsaUJBQWlCLEVBQUVuQyw0Q0FBNEM7WUFBQztZQUFhO1lBQWU7U0FBMkIsRUFBRVYsa0JBQWtCcWY7UUFDaEosSUFBSSxDQUFDeHRFLFNBQVMsQ0FBQzR0RCxPQUFPO1lBQUM7Z0JBQUM7Z0JBQU07YUFBYztZQUFFO2dCQUFDO2dCQUFNO2FBQUU7WUFBRTtnQkFBQztnQkFBTTthQUFFO1NBQUM7UUFDbkUsSUFBSSxDQUFDdVYsVUFBVSxDQUFDMTBGLElBQUksQ0FBQysrRjtRQUNyQixJQUFJLENBQUM1VSxVQUFVO0lBQ2pCO0lBQ0F4MEQsU0FBU3dwRCxLQUFLLEVBQUUyZixLQUFLLEVBQUU7UUFDckIsSUFBSSxDQUFDLElBQUksQ0FBQy9KLGNBQWMsRUFBRTtZQUN4QjtRQUNGO1FBQ0EsSUFBSSxDQUFDNUssVUFBVTtRQUNmLE1BQU1pVixXQUFXLElBQUksQ0FBQzF3RCxHQUFHO1FBQ3pCLE1BQU1BLE1BQU0sSUFBSSxDQUFDZ21ELFVBQVUsQ0FBQ3B0RCxHQUFHO1FBQy9CLElBQUksQ0FBQ29ILEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNBLEdBQUcsQ0FBQ2dxRCxxQkFBcUIsR0FBRztRQUNqQyxJQUFJLENBQUNuVyxpQkFBaUIsRUFBRTVDO1FBQ3hCLElBQUltZixNQUFNeEYsS0FBSyxFQUFFO1lBQ2YsSUFBSSxDQUFDekUsU0FBUyxHQUFHLElBQUksQ0FBQ0YsVUFBVSxDQUFDcnRELEdBQUc7WUFDcEMsSUFBSSxDQUFDN1YsT0FBTyxDQUFDMHREO1lBQ2IsSUFBSSxJQUFJLENBQUNvRCxpQkFBaUIsRUFBRTtnQkFDMUIsSUFBSSxDQUFDN3pDLEdBQUcsQ0FBQ2pkLE9BQU87WUFDbEI7UUFDRixPQUFPO1lBQ0wsSUFBSSxDQUFDaWQsR0FBRyxDQUFDamQsT0FBTztZQUNoQixNQUFNNnRFLGFBQWE3d0Qsb0JBQW9CLElBQUksQ0FBQ0MsR0FBRztZQUMvQyxJQUFJLENBQUNqZCxPQUFPLENBQUMwdEQ7WUFDYixJQUFJLENBQUN6d0MsR0FBRyxDQUFDbGQsSUFBSTtZQUNiLElBQUksQ0FBQ2tkLEdBQUcsQ0FBQ3cyQyxZQUFZLElBQUlvYTtZQUN6QixNQUFNakcsV0FBV3BNLGFBQWEzMUYsS0FBSztZQUNuQzZqQyxLQUFLeUIsdUJBQXVCLENBQUM7Z0JBQUM7Z0JBQUc7Z0JBQUd3aUUsU0FBUy9sRCxNQUFNLENBQUNuUCxLQUFLO2dCQUFFazFELFNBQVMvbEQsTUFBTSxDQUFDbFAsTUFBTTthQUFDLEVBQUVtMUQsWUFBWWpHO1lBQ2hHLElBQUksQ0FBQzNxRCxHQUFHLENBQUNpTCxTQUFTLENBQUN5bEQsU0FBUy9sRCxNQUFNLEVBQUUsR0FBRztZQUN2QyxJQUFJLENBQUMzSyxHQUFHLENBQUNqZCxPQUFPO1lBQ2hCLElBQUksQ0FBQzJuRSxPQUFPLENBQUNDO1FBQ2Y7SUFDRjtJQUNBempFLGdCQUFnQnVwRCxLQUFLLEVBQUV6MUUsRUFBRSxFQUFFbXpCLElBQUksRUFBRW5MLFNBQVMsRUFBRXVNLE1BQU0sRUFBRXNoRSxZQUFZLEVBQUU7UUFDaEUsSUFBSSxDQUFDLENBQUN4SSxtQkFBbUI7UUFDekI3RCxrQkFBa0IsSUFBSSxDQUFDeGtELEdBQUc7UUFDMUIsSUFBSSxDQUFDQSxHQUFHLENBQUNsZCxJQUFJO1FBQ2IsSUFBSSxDQUFDQSxJQUFJLENBQUMydEQ7UUFDVixJQUFJLElBQUksQ0FBQzJGLGFBQWEsRUFBRTtZQUN0QixJQUFJLENBQUNwMkMsR0FBRyxDQUFDdzJDLFlBQVksSUFBSSxJQUFJLENBQUNKLGFBQWE7UUFDN0M7UUFDQSxJQUFJam9ELE1BQU07WUFDUixNQUFNcU4sUUFBUXJOLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFO1lBQy9CLE1BQU1zTixTQUFTdE4sSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUU7WUFDaEMsSUFBSTBpRSxnQkFBZ0IsSUFBSSxDQUFDbEwsbUJBQW1CLEVBQUU7Z0JBQzVDM2lFLFlBQVlBLFVBQVVwNkIsS0FBSztnQkFDM0JvNkIsU0FBUyxDQUFDLEVBQUUsSUFBSW1MLElBQUksQ0FBQyxFQUFFO2dCQUN2Qm5MLFNBQVMsQ0FBQyxFQUFFLElBQUltTCxJQUFJLENBQUMsRUFBRTtnQkFDdkJBLE9BQU9BLEtBQUt2bEMsS0FBSztnQkFDakJ1bEMsSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUUsR0FBRztnQkFDcEJBLElBQUksQ0FBQyxFQUFFLEdBQUdxTjtnQkFDVnJOLElBQUksQ0FBQyxFQUFFLEdBQUdzTjtnQkFDVmhQLEtBQUs2Qyw2QkFBNkIsQ0FBQ3lRLG9CQUFvQixJQUFJLENBQUNDLEdBQUcsR0FBR3MrQztnQkFDbEUsTUFBTSxFQUNKaUksYUFBYSxFQUNkLEdBQUcsSUFBSTtnQkFDUixNQUFNeFcsY0FBY2xqRixLQUFLRCxJQUFJLENBQUM0dUMsUUFBUSxJQUFJLENBQUNnckQsWUFBWSxHQUFHRDtnQkFDMUQsTUFBTXZXLGVBQWVuakYsS0FBS0QsSUFBSSxDQUFDNnVDLFNBQVMsSUFBSSxDQUFDZ3JELFlBQVksR0FBR0Y7Z0JBQzVELElBQUksQ0FBQ3VLLGdCQUFnQixHQUFHLElBQUksQ0FBQzdRLGFBQWEsQ0FBQ3hyRixNQUFNLENBQUNzN0UsYUFBYUM7Z0JBQy9ELE1BQU0sRUFDSnJsQyxNQUFNLEVBQ04zNUIsT0FBTyxFQUNSLEdBQUcsSUFBSSxDQUFDOC9FLGdCQUFnQjtnQkFDekIsSUFBSSxDQUFDbkwsbUJBQW1CLENBQUMvMkYsR0FBRyxDQUFDb00sSUFBSTJ2QztnQkFDakMsSUFBSSxDQUFDbW1ELGdCQUFnQixDQUFDQyxRQUFRLEdBQUcsSUFBSSxDQUFDL3dELEdBQUc7Z0JBQ3pDLElBQUksQ0FBQ0EsR0FBRyxHQUFHaHZCO2dCQUNYLElBQUksQ0FBQ2d2QixHQUFHLENBQUNsZCxJQUFJO2dCQUNiLElBQUksQ0FBQ2tkLEdBQUcsQ0FBQ3cyQyxZQUFZLENBQUM4SCxFQUFFLENBQUMsRUFBRSxFQUFFLEdBQUcsR0FBRyxDQUFDQSxFQUFFLENBQUMsRUFBRSxFQUFFLEdBQUc3aUQsU0FBUzZpRCxFQUFFLENBQUMsRUFBRTtnQkFDNURrRyxrQkFBa0IsSUFBSSxDQUFDeGtELEdBQUc7WUFDNUIsT0FBTztnQkFDTHdrRCxrQkFBa0IsSUFBSSxDQUFDeGtELEdBQUc7Z0JBQzFCLElBQUksQ0FBQ2hjLE9BQU8sQ0FBQ3lzRDtnQkFDYixNQUFNeHNELE9BQU8sSUFBSTIrQztnQkFDakIzK0MsS0FBS2tLLElBQUksQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsRUFBRUEsSUFBSSxDQUFDLEVBQUUsRUFBRXFOLE9BQU9DO2dCQUNuQyxJQUFJLENBQUN1RSxHQUFHLENBQUMvYixJQUFJLENBQUNBO1lBQ2hCO1FBQ0Y7UUFDQSxJQUFJLENBQUM1ZixPQUFPLEdBQUcsSUFBSWc5RSxpQkFBaUIsSUFBSSxDQUFDcmhELEdBQUcsQ0FBQzJLLE1BQU0sQ0FBQ25QLEtBQUssRUFBRSxJQUFJLENBQUN3RSxHQUFHLENBQUMySyxNQUFNLENBQUNsUCxNQUFNO1FBQ2pGLElBQUksQ0FBQ3pZLFNBQVMsQ0FBQ3l0RCxVQUFVenREO1FBQ3pCLElBQUksQ0FBQ0EsU0FBUyxDQUFDeXRELFVBQVVsaEQ7SUFDM0I7SUFDQXBJLGNBQWNzcEQsS0FBSyxFQUFFO1FBQ25CLElBQUksSUFBSSxDQUFDcWdCLGdCQUFnQixFQUFFO1lBQ3pCLElBQUksQ0FBQzl3RCxHQUFHLENBQUNqZCxPQUFPO1lBQ2hCLElBQUksQ0FBQyxDQUFDeWxFLFVBQVU7WUFDaEIsSUFBSSxDQUFDeG9ELEdBQUcsR0FBRyxJQUFJLENBQUM4d0QsZ0JBQWdCLENBQUNDLFFBQVE7WUFDekMsT0FBTyxJQUFJLENBQUNELGdCQUFnQixDQUFDQyxRQUFRO1lBQ3JDLE9BQU8sSUFBSSxDQUFDRCxnQkFBZ0I7UUFDOUI7SUFDRjtJQUNBMXBFLHNCQUFzQnFwRCxLQUFLLEVBQUVtWSxHQUFHLEVBQUU7UUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQ3ZDLGNBQWMsRUFBRTtZQUN4QjtRQUNGO1FBQ0EsTUFBTXJzRixRQUFRNHVGLElBQUk1dUYsS0FBSztRQUN2QjR1RixNQUFNLElBQUksQ0FBQy9CLFNBQVMsQ0FBQ3BXLE9BQU9tWSxJQUFJaHlGLElBQUksRUFBRWd5RjtRQUN0Q0EsSUFBSTV1RixLQUFLLEdBQUdBO1FBQ1osTUFBTWdtQyxNQUFNLElBQUksQ0FBQ0EsR0FBRztRQUNwQixNQUFNK2pELE9BQU8sSUFBSSxDQUFDcUYsaUJBQWlCLENBQUMzWSxPQUFPbVk7UUFDM0MsTUFBTVksYUFBYXpGLEtBQUtwNUMsTUFBTTtRQUM5QjNLLElBQUlsZCxJQUFJO1FBQ1JrZCxJQUFJdzJDLFlBQVksQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7UUFDaEN4MkMsSUFBSWlMLFNBQVMsQ0FBQ3UrQyxZQUFZekYsS0FBS2xwRCxPQUFPLEVBQUVrcEQsS0FBS2pwRCxPQUFPO1FBQ3BELElBQUksQ0FBQys0QyxpQkFBaUIsRUFBRWhDLFVBQVVwQixPQUFPc0IsV0FBV3RCLE9BQU8sSUFBSSxDQUFDendDLEdBQUcsRUFBRStqRCxLQUFLbHBELE9BQU8sRUFBRWtwRCxLQUFLbHBELE9BQU8sR0FBRzJ1RCxXQUFXaHVELEtBQUssRUFBRXVvRCxLQUFLanBELE9BQU8sRUFBRWlwRCxLQUFLanBELE9BQU8sR0FBRzB1RCxXQUFXL3RELE1BQU0sRUFBRXUzQyxnQkFBZ0J2QztRQUNwTHp3QyxJQUFJamQsT0FBTztRQUNYLElBQUksQ0FBQzJuRSxPQUFPO0lBQ2Q7SUFDQWhqRSw0QkFBNEIrb0QsS0FBSyxFQUFFbVksR0FBRyxFQUFFN1IsTUFBTSxFQUFFaWEsUUFBUSxDQUFDLEVBQUVDLFFBQVEsQ0FBQyxFQUFFamEsTUFBTSxFQUFFa2EsU0FBUyxFQUFFO1FBQ3ZGLElBQUksQ0FBQyxJQUFJLENBQUM3SyxjQUFjLEVBQUU7WUFDeEI7UUFDRjtRQUNBdUMsTUFBTSxJQUFJLENBQUMvQixTQUFTLENBQUNwVyxPQUFPbVksSUFBSWh5RixJQUFJLEVBQUVneUY7UUFDdEMsTUFBTTVvRCxNQUFNLElBQUksQ0FBQ0EsR0FBRztRQUNwQkEsSUFBSWxkLElBQUk7UUFDUixNQUFNd21FLG1CQUFtQnZwRCxvQkFBb0JDO1FBQzdDQSxJQUFJaGQsU0FBUyxDQUFDK3pELFFBQVFpYSxPQUFPQyxPQUFPamEsUUFBUSxHQUFHO1FBQy9DLE1BQU0rTSxPQUFPLElBQUksQ0FBQ3FGLGlCQUFpQixDQUFDM1ksT0FBT21ZO1FBQzNDNW9ELElBQUl3MkMsWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUd1TixLQUFLbHBELE9BQU8sR0FBR3l1RCxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUV2RixLQUFLanBELE9BQU8sR0FBR3d1RCxnQkFBZ0IsQ0FBQyxFQUFFO1FBQ25HLElBQUksQ0FBQ3pWLGlCQUFpQixFQUFFaEMsVUFBVXBCO1FBQ2xDLElBQUssSUFBSXpsRixJQUFJLEdBQUdpbkMsS0FBS2kvRCxVQUFVN3FHLE1BQU0sRUFBRTJFLElBQUlpbkMsSUFBSWpuQyxLQUFLLEVBQUc7WUFDckQsTUFBTW1tRyxRQUFRMWtFLEtBQUt6SixTQUFTLENBQUNzbUUsa0JBQWtCO2dCQUFDdlM7Z0JBQVFpYTtnQkFBT0M7Z0JBQU9qYTtnQkFBUWthLFNBQVMsQ0FBQ2xtRyxFQUFFO2dCQUFFa21HLFNBQVMsQ0FBQ2xtRyxJQUFJLEVBQUU7YUFBQztZQUM3R2cxQyxJQUFJaUwsU0FBUyxDQUFDODRDLEtBQUtwNUMsTUFBTSxFQUFFd21ELEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFO1lBQzdDLElBQUksQ0FBQ3RkLGlCQUFpQixFQUFFOUIsV0FBV3RCLE9BQU8sSUFBSSxDQUFDendDLEdBQUcsRUFBRW14RCxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxHQUFHcE4sS0FBS3A1QyxNQUFNLENBQUNuUCxLQUFLLEVBQUUyMUQsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsR0FBR3BOLEtBQUtwNUMsTUFBTSxDQUFDbFAsTUFBTTtRQUNySTtRQUNBdUUsSUFBSWpkLE9BQU87UUFDWCxJQUFJLENBQUMybkUsT0FBTztRQUNaLElBQUksQ0FBQzdXLGlCQUFpQixFQUFFYixnQkFBZ0J2QztJQUMxQztJQUNBcHBELDJCQUEyQm9wRCxLQUFLLEVBQUUyZ0IsTUFBTSxFQUFFO1FBQ3hDLElBQUksQ0FBQyxJQUFJLENBQUMvSyxjQUFjLEVBQUU7WUFDeEI7UUFDRjtRQUNBLE1BQU1ybUQsTUFBTSxJQUFJLENBQUNBLEdBQUc7UUFDcEIsTUFBTXk4QyxZQUFZLElBQUksQ0FBQ3A0RSxPQUFPLENBQUNvNEUsU0FBUztRQUN4QyxNQUFNNE0sZ0JBQWdCLElBQUksQ0FBQ2hsRixPQUFPLENBQUMrOUUsV0FBVztRQUM5QyxJQUFJLENBQUN2TyxpQkFBaUIsRUFBRWhDLFVBQVVwQixPQUFPb0MsbUJBQW1CcEMsT0FBT3dELGFBQWFFLGdCQUFnQjtRQUNoRyxLQUFLLE1BQU1ycEMsU0FBU3NtRCxPQUFRO1lBQzFCLE1BQU0sRUFDSng2RixJQUFJLEVBQ0o0a0MsS0FBSyxFQUNMQyxNQUFNLEVBQ056WSxTQUFTLEVBQ1YsR0FBRzhuQjtZQUNKLE1BQU0wK0MsYUFBYSxJQUFJLENBQUN6VCxjQUFjLENBQUNDLFNBQVMsQ0FBQyxjQUFjeDZDLE9BQU9DO1lBQ3RFLE1BQU0rdkQsVUFBVWhDLFdBQVd4NEUsT0FBTztZQUNsQ3c2RSxRQUFRMW9FLElBQUk7WUFDWixNQUFNOGxFLE1BQU0sSUFBSSxDQUFDL0IsU0FBUyxDQUFDcFcsT0FBTzc1RSxNQUFNazBDO1lBQ3hDbTVDLG1CQUFtQnVILFNBQVM1QztZQUM1QjRDLFFBQVExRyx3QkFBd0IsR0FBRztZQUNuQzBHLFFBQVFuVixTQUFTLEdBQUdnVCxnQkFBZ0I1TSxVQUFVL0gsVUFBVSxDQUFDOFcsU0FBUyxJQUFJLEVBQUV0ckQsMkJBQTJCRixNQUFNbzBDLFNBQVMvM0QsSUFBSSxFQUFFbzBELFNBQVNnTTtZQUNqSStPLFFBQVF0RSxRQUFRLENBQUMsR0FBRyxHQUFHMXJELE9BQU9DO1lBQzlCK3ZELFFBQVF6b0UsT0FBTztZQUNmaWQsSUFBSWxkLElBQUk7WUFDUmtkLElBQUloZCxTQUFTLElBQUlBO1lBQ2pCZ2QsSUFBSXJGLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDZHdsRCx5QkFBeUJuZ0QsS0FBS3dwRCxXQUFXNytDLE1BQU0sRUFBRSxHQUFHLEdBQUduUCxPQUFPQyxRQUFRLEdBQUcsQ0FBQyxHQUFHLEdBQUc7WUFDaEYsSUFBSSxDQUFDbzRDLGlCQUFpQixFQUFFOUIsV0FBV3RCLE9BQU96d0MsS0FBSyxHQUFHeEUsT0FBTyxHQUFHQztZQUM1RHVFLElBQUlqZCxPQUFPO1FBQ2I7UUFDQSxJQUFJLENBQUMybkUsT0FBTztRQUNaLElBQUksQ0FBQzdXLGlCQUFpQixFQUFFYixnQkFBZ0J2QztJQUMxQztJQUNBbnBELGtCQUFrQm1wRCxLQUFLLEVBQUVoTyxLQUFLLEVBQUU7UUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQzRqQixjQUFjLEVBQUU7WUFDeEI7UUFDRjtRQUNBLE1BQU1uRCxVQUFVLElBQUksQ0FBQzJELFNBQVMsQ0FBQ3BXLE9BQU9oTztRQUN0QyxJQUFJLENBQUN5Z0IsU0FBUztZQUNadDZELEtBQUs7WUFDTDtRQUNGO1FBQ0EsSUFBSSxDQUFDckIsdUJBQXVCLENBQUNrcEQsT0FBT3lTO0lBQ3RDO0lBQ0F6N0Qsd0JBQXdCZ3BELEtBQUssRUFBRWhPLEtBQUssRUFBRXNVLE1BQU0sRUFBRUMsTUFBTSxFQUFFa2EsU0FBUyxFQUFFO1FBQy9ELElBQUksQ0FBQyxJQUFJLENBQUM3SyxjQUFjLEVBQUU7WUFDeEI7UUFDRjtRQUNBLE1BQU1uRCxVQUFVLElBQUksQ0FBQzJELFNBQVMsQ0FBQ3BXLE9BQU9oTztRQUN0QyxJQUFJLENBQUN5Z0IsU0FBUztZQUNadDZELEtBQUs7WUFDTDtRQUNGO1FBQ0EsTUFBTTRTLFFBQVEwbkQsUUFBUTFuRCxLQUFLO1FBQzNCLE1BQU1DLFNBQVN5bkQsUUFBUXpuRCxNQUFNO1FBQzdCLE1BQU12cUMsTUFBTSxFQUFFO1FBQ2QsSUFBSyxJQUFJbEcsSUFBSSxHQUFHaW5DLEtBQUtpL0QsVUFBVTdxRyxNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsS0FBSyxFQUFHO1lBQ3JEa0csSUFBSUksSUFBSSxDQUFDO2dCQUNQMHhCLFdBQVc7b0JBQUMrekQ7b0JBQVE7b0JBQUc7b0JBQUdDO29CQUFRa2EsU0FBUyxDQUFDbG1HLEVBQUU7b0JBQUVrbUcsU0FBUyxDQUFDbG1HLElBQUksRUFBRTtpQkFBQztnQkFDakVnQyxHQUFHO2dCQUNIME0sR0FBRztnQkFDSDhtQyxHQUFHaEY7Z0JBQ0hpRixHQUFHaEY7WUFDTDtRQUNGO1FBQ0EsSUFBSSxDQUFDalUsNEJBQTRCLENBQUNpcEQsT0FBT3lTLFNBQVNoeUY7SUFDcEQ7SUFDQW1nRywwQkFBMEJyeEQsR0FBRyxFQUFFO1FBQzdCLElBQUksSUFBSSxDQUFDMzdCLE9BQU8sQ0FBQ3ErRSxZQUFZLEtBQUssUUFBUTtZQUN4QzFpRCxJQUFJanJDLE1BQU0sR0FBRyxJQUFJLENBQUNzUCxPQUFPLENBQUNxK0UsWUFBWTtZQUN0QzFpRCxJQUFJaUwsU0FBUyxDQUFDakwsSUFBSTJLLE1BQU0sRUFBRSxHQUFHO1lBQzdCM0ssSUFBSWpyQyxNQUFNLEdBQUc7UUFDZjtRQUNBLE9BQU9pckMsSUFBSTJLLE1BQU07SUFDbkI7SUFDQTJtRCwwQkFBMEJwTyxPQUFPLEVBQUU7UUFDakMsSUFBSSxJQUFJLENBQUM3K0UsT0FBTyxDQUFDcStFLFlBQVksS0FBSyxRQUFRO1lBQ3hDLE9BQU9RLFFBQVE5MkUsTUFBTTtRQUN2QjtRQUNBLE1BQU0sRUFDSkEsTUFBTSxFQUNOb3ZCLEtBQUssRUFDTEMsTUFBTSxFQUNQLEdBQUd5bkQ7UUFDSixNQUFNcE4sWUFBWSxJQUFJLENBQUNDLGNBQWMsQ0FBQ0MsU0FBUyxDQUFDLGVBQWV4NkMsT0FBT0M7UUFDdEUsTUFBTXc2QyxTQUFTSCxVQUFVOWtFLE9BQU87UUFDaENpbEUsT0FBT2xoRixNQUFNLEdBQUcsSUFBSSxDQUFDc1AsT0FBTyxDQUFDcStFLFlBQVk7UUFDekN6TSxPQUFPaHJDLFNBQVMsQ0FBQzcrQixRQUFRLEdBQUc7UUFDNUI2cEUsT0FBT2xoRixNQUFNLEdBQUc7UUFDaEIsT0FBTytnRixVQUFVbnJDLE1BQU07SUFDekI7SUFDQXBqQix3QkFBd0JrcEQsS0FBSyxFQUFFeVMsT0FBTyxFQUFFO1FBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUNtRCxjQUFjLEVBQUU7WUFDeEI7UUFDRjtRQUNBLE1BQU03cUQsUUFBUTBuRCxRQUFRMW5ELEtBQUs7UUFDM0IsTUFBTUMsU0FBU3luRCxRQUFRem5ELE1BQU07UUFDN0IsTUFBTXVFLE1BQU0sSUFBSSxDQUFDQSxHQUFHO1FBQ3BCLElBQUksQ0FBQ2xkLElBQUksQ0FBQzJ0RDtRQUNWLE1BQU0sRUFDSjE3RSxNQUFNLEVBQ1AsR0FBR2lyQztRQUNKLElBQUlqckMsV0FBVyxVQUFVQSxXQUFXLElBQUk7WUFDdENpckMsSUFBSWpyQyxNQUFNLEdBQUc7UUFDZjtRQUNBaXJDLElBQUlyRixLQUFLLENBQUMsSUFBSWEsT0FBTyxDQUFDLElBQUlDO1FBQzFCLElBQUk4MUQ7UUFDSixJQUFJck8sUUFBUTkyRSxNQUFNLEVBQUU7WUFDbEJtbEYsYUFBYSxJQUFJLENBQUNELHlCQUF5QixDQUFDcE87UUFDOUMsT0FBTyxJQUFJLE9BQU9zTyxnQkFBZ0IsY0FBY3RPLG1CQUFtQnNPLGVBQWUsQ0FBQ3RPLFFBQVF0c0YsSUFBSSxFQUFFO1lBQy9GMjZGLGFBQWFyTztRQUNmLE9BQU87WUFDTCxNQUFNcE4sWUFBWSxJQUFJLENBQUNDLGNBQWMsQ0FBQ0MsU0FBUyxDQUFDLGVBQWV4NkMsT0FBT0M7WUFDdEUsTUFBTXc2QyxTQUFTSCxVQUFVOWtFLE9BQU87WUFDaENpeUUsbUJBQW1CaE4sUUFBUWlOO1lBQzNCcU8sYUFBYSxJQUFJLENBQUNGLHlCQUF5QixDQUFDcGI7UUFDOUM7UUFDQSxNQUFNajFDLFNBQVMsSUFBSSxDQUFDMm5ELFdBQVcsQ0FBQzRJLFlBQVlyeEQsMkJBQTJCRjtRQUN2RUEsSUFBSWdxRCxxQkFBcUIsR0FBR2pGLHlCQUF5QmhsRCxvQkFBb0JDLE1BQU1rakQsUUFBUThCLFdBQVc7UUFDbEcsSUFBSSxDQUFDblIsaUJBQWlCLEVBQUVoQyxVQUFVcEIsT0FBT3NCLFdBQVd0QixPQUFPendDLEtBQUssR0FBR3hFLE9BQU8sQ0FBQ0MsUUFBUSxHQUFHbzNDLG1CQUFtQnBDLE9BQU93RCxhQUFhQyxZQUFZLEVBQUVsQixnQkFBZ0J2QztRQUMzSjBQLHlCQUF5Qm5nRCxLQUFLZ0IsT0FBTzRuRCxHQUFHLEVBQUUsR0FBRyxHQUFHNW5ELE9BQU9pb0QsVUFBVSxFQUFFam9ELE9BQU9rb0QsV0FBVyxFQUFFLEdBQUcsQ0FBQ3p0RCxRQUFRRCxPQUFPQztRQUMxRyxJQUFJLENBQUNpdkQsT0FBTztRQUNaLElBQUksQ0FBQzNuRSxPQUFPLENBQUMwdEQ7SUFDZjtJQUNBanBELDZCQUE2QmlwRCxLQUFLLEVBQUV5UyxPQUFPLEVBQUVoeUYsR0FBRyxFQUFFO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUNtMUYsY0FBYyxFQUFFO1lBQ3hCO1FBQ0Y7UUFDQSxNQUFNcm1ELE1BQU0sSUFBSSxDQUFDQSxHQUFHO1FBQ3BCLElBQUl1eEQ7UUFDSixJQUFJck8sUUFBUTkyRSxNQUFNLEVBQUU7WUFDbEJtbEYsYUFBYXJPLFFBQVE5MkUsTUFBTTtRQUM3QixPQUFPO1lBQ0wsTUFBTW8wQixJQUFJMGlELFFBQVExbkQsS0FBSztZQUN2QixNQUFNaUYsSUFBSXlpRCxRQUFRem5ELE1BQU07WUFDeEIsTUFBTXE2QyxZQUFZLElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxTQUFTLENBQUMsZUFBZXgxQyxHQUFHQztZQUNsRSxNQUFNdzFDLFNBQVNILFVBQVU5a0UsT0FBTztZQUNoQ2l5RSxtQkFBbUJoTixRQUFRaU47WUFDM0JxTyxhQUFhLElBQUksQ0FBQ0YseUJBQXlCLENBQUNwYjtRQUM5QztRQUNBLElBQUksQ0FBQ3BDLGlCQUFpQixFQUFFaEMsVUFBVXBCO1FBQ2xDLEtBQUssTUFBTTN2RSxTQUFTNVAsSUFBSztZQUN2Qjh1QyxJQUFJbGQsSUFBSTtZQUNSa2QsSUFBSWhkLFNBQVMsSUFBSWxpQixNQUFNa2lCLFNBQVM7WUFDaENnZCxJQUFJckYsS0FBSyxDQUFDLEdBQUcsQ0FBQztZQUNkd2xELHlCQUF5Qm5nRCxLQUFLdXhELFlBQVl6d0YsTUFBTTlULENBQUMsRUFBRThULE1BQU1wSCxDQUFDLEVBQUVvSCxNQUFNMC9CLENBQUMsRUFBRTEvQixNQUFNMi9CLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxHQUFHO1lBQ3hGLElBQUksQ0FBQ296QyxpQkFBaUIsRUFBRTlCLFdBQVd0QixPQUFPendDLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRztZQUN6REEsSUFBSWpkLE9BQU87UUFDYjtRQUNBLElBQUksQ0FBQzh3RCxpQkFBaUIsRUFBRWIsZ0JBQWdCdkM7UUFDeEMsSUFBSSxDQUFDaWEsT0FBTztJQUNkO0lBQ0EvaUUseUJBQXlCOG9ELEtBQUssRUFBRTtRQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDNFYsY0FBYyxFQUFFO1lBQ3hCO1FBQ0Y7UUFDQSxJQUFJLENBQUN4UyxpQkFBaUIsRUFBRWhDLFVBQVVwQixPQUFPc0IsV0FBV3RCLE9BQU8sSUFBSSxDQUFDendDLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHNnlDLG1CQUFtQnBDLE9BQU93RCxhQUFhdndELElBQUksRUFBRXN2RCxnQkFBZ0J2QztRQUM5SSxJQUFJLENBQUN6d0MsR0FBRyxDQUFDa25ELFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRztRQUMzQixJQUFJLENBQUN3RCxPQUFPO0lBQ2Q7SUFDQW5rRSxVQUFVa3FELEtBQUssRUFBRXZrRSxHQUFHLEVBQUUsQ0FBQztJQUN2QnNhLGVBQWVpcUQsS0FBSyxFQUFFdmtFLEdBQUcsRUFBRWs0RSxVQUFVLEVBQUUsQ0FBQztJQUN4QzM5RCxtQkFBbUJncUQsS0FBSyxFQUFFdmtFLEdBQUcsRUFBRTtRQUM3QixJQUFJLENBQUMybkUsaUJBQWlCLEVBQUVwdEQsbUJBQW1CZ3FEO1FBQzNDLElBQUksQ0FBQ2xCLGtCQUFrQixDQUFDaitFLElBQUksQ0FBQztZQUMzQm11RCxTQUFTO1FBQ1g7SUFDRjtJQUNBLzRCLHdCQUF3QitwRCxLQUFLLEVBQUV2a0UsR0FBRyxFQUFFazRFLFVBQVUsRUFBRTtRQUM5QyxJQUFJLENBQUN2USxpQkFBaUIsRUFBRXB0RCxtQkFBbUJncUQ7UUFDM0MsSUFBSXZrRSxRQUFRLE1BQU07WUFDaEIsSUFBSSxDQUFDcWpFLGtCQUFrQixDQUFDaitFLElBQUksQ0FBQztnQkFDM0JtdUQsU0FBUyxJQUFJLENBQUNpbUMscUJBQXFCLENBQUMrTCxTQUFTLENBQUNyTjtZQUNoRDtRQUNGLE9BQU87WUFDTCxJQUFJLENBQUM3VSxrQkFBa0IsQ0FBQ2orRSxJQUFJLENBQUM7Z0JBQzNCbXVELFNBQVM7WUFDWDtRQUNGO1FBQ0EsSUFBSSxDQUFDNG1DLGNBQWMsR0FBRyxJQUFJLENBQUNxTCxnQkFBZ0I7SUFDN0M7SUFDQS9xRSxpQkFBaUI4cEQsS0FBSyxFQUFFO1FBQ3RCLElBQUksQ0FBQ29ELGlCQUFpQixFQUFFbHRELGlCQUFpQjhwRDtRQUN6QyxJQUFJLENBQUNsQixrQkFBa0IsQ0FBQzMyQyxHQUFHO1FBQzNCLElBQUksQ0FBQ3l0RCxjQUFjLEdBQUcsSUFBSSxDQUFDcUwsZ0JBQWdCO0lBQzdDO0lBQ0E5cUUsWUFBWTZwRCxLQUFLLEVBQUUsQ0FBQztJQUNwQjVwRCxVQUFVNHBELEtBQUssRUFBRSxDQUFDO0lBQ2xCeWIsWUFBWXpiLEtBQUssRUFBRTlOLElBQUksRUFBRThNLE9BQU8sRUFBRTtRQUNoQyxNQUFNbDhCLFVBQVUsSUFBSSxDQUFDbHZDLE9BQU8sQ0FBQzIrRSxXQUFXO1FBQ3hDLElBQUksSUFBSSxDQUFDNkMsV0FBVyxFQUFFO1lBQ3BCLElBQUksQ0FBQ3hoRixPQUFPLENBQUN5K0Usa0JBQWtCO1FBQ2pDO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQytDLFdBQVcsRUFBRTtZQUNyQixJQUFJLENBQUM2RSxPQUFPLENBQUNqYjtRQUNmO1FBQ0EsTUFBTXp2QyxNQUFNLElBQUksQ0FBQ0EsR0FBRztRQUNwQixJQUFJLElBQUksQ0FBQzZsRCxXQUFXLEVBQUU7WUFDcEIsSUFBSSxDQUFDdHlDLFNBQVM7Z0JBQ1osSUFBSSxJQUFJLENBQUNzeUMsV0FBVyxLQUFLUCxTQUFTO29CQUNoQ3RsRCxJQUFJL2IsSUFBSSxDQUFDMCtDLE1BQU07Z0JBQ2pCLE9BQU87b0JBQ0wzaUMsSUFBSS9iLElBQUksQ0FBQzArQztnQkFDWDtZQUNGO1lBQ0EsSUFBSSxDQUFDa2pCLFdBQVcsR0FBRztZQUNuQixJQUFJLENBQUNoUyxpQkFBaUIsRUFBRVAsMkJBQTJCN0MsT0FBT2dCLDZCQUE2QixZQUFZaEI7UUFDckcsT0FBTztZQUNMLElBQUksQ0FBQ29ELGlCQUFpQixFQUFFYixnQkFBZ0J2QztRQUMxQztRQUNBLElBQUksQ0FBQ3BzRSxPQUFPLENBQUMwK0Usc0JBQXNCLENBQUMsSUFBSSxDQUFDMStFLE9BQU8sQ0FBQ29yRSxPQUFPO0lBQzFEO0lBQ0EwZSxzQkFBc0I7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQ3hILDBCQUEwQixFQUFFO1lBQ3BDLE1BQU1uZ0YsSUFBSXU1QixvQkFBb0IsSUFBSSxDQUFDQyxHQUFHO1lBQ3RDLElBQUl4NUIsQ0FBQyxDQUFDLEVBQUUsS0FBSyxLQUFLQSxDQUFDLENBQUMsRUFBRSxLQUFLLEdBQUc7Z0JBQzVCLElBQUksQ0FBQ21nRiwwQkFBMEIsR0FBRyxJQUFJOTVGLEtBQUttRixHQUFHLENBQUNuRixLQUFLK0wsR0FBRyxDQUFDNE4sQ0FBQyxDQUFDLEVBQUUsR0FBRzNaLEtBQUsrTCxHQUFHLENBQUM0TixDQUFDLENBQUMsRUFBRTtZQUM5RSxPQUFPO2dCQUNMLE1BQU1tckYsU0FBUzlrRyxLQUFLK0wsR0FBRyxDQUFDNE4sQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUU7Z0JBQ2pELE1BQU1vckYsUUFBUS9rRyxLQUFLcStELEtBQUssQ0FBQzFrRCxDQUFDLENBQUMsRUFBRSxFQUFFQSxDQUFDLENBQUMsRUFBRTtnQkFDbkMsTUFBTXFyRixRQUFRaGxHLEtBQUtxK0QsS0FBSyxDQUFDMWtELENBQUMsQ0FBQyxFQUFFLEVBQUVBLENBQUMsQ0FBQyxFQUFFO2dCQUNuQyxJQUFJLENBQUNtZ0YsMEJBQTBCLEdBQUc5NUYsS0FBSzRQLEdBQUcsQ0FBQ20xRixPQUFPQyxTQUFTRjtZQUM3RDtRQUNGO1FBQ0EsT0FBTyxJQUFJLENBQUNoTCwwQkFBMEI7SUFDeEM7SUFDQW1MLHNCQUFzQjtRQUNwQixJQUFJLElBQUksQ0FBQ3BMLHVCQUF1QixDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUc7WUFDMUMsTUFBTSxFQUNKbEUsU0FBUyxFQUNWLEdBQUcsSUFBSSxDQUFDbitFLE9BQU87WUFDaEIsTUFBTSxFQUNKcUYsQ0FBQyxFQUNEQyxDQUFDLEVBQ0RyRCxDQUFDLEVBQ0RtUixDQUFDLEVBQ0YsR0FBRyxJQUFJLENBQUN1b0IsR0FBRyxDQUFDQyxZQUFZO1lBQ3pCLElBQUk4MkMsUUFBUUM7WUFDWixJQUFJcnRFLE1BQU0sS0FBS3JELE1BQU0sR0FBRztnQkFDdEIsTUFBTXNyRixRQUFRL2tHLEtBQUsrTCxHQUFHLENBQUM4UTtnQkFDdkIsTUFBTW1vRixRQUFRaGxHLEtBQUsrTCxHQUFHLENBQUM2ZTtnQkFDdkIsSUFBSW02RSxVQUFVQyxPQUFPO29CQUNuQixJQUFJclAsY0FBYyxHQUFHO3dCQUNuQnpMLFNBQVNDLFNBQVMsSUFBSTRhO29CQUN4QixPQUFPO3dCQUNMLE1BQU1HLGtCQUFrQkgsUUFBUXBQO3dCQUNoQ3pMLFNBQVNDLFNBQVMrYSxrQkFBa0IsSUFBSSxJQUFJQSxrQkFBa0I7b0JBQ2hFO2dCQUNGLE9BQU8sSUFBSXZQLGNBQWMsR0FBRztvQkFDMUJ6TCxTQUFTLElBQUk2YTtvQkFDYjVhLFNBQVMsSUFBSTZhO2dCQUNmLE9BQU87b0JBQ0wsTUFBTUcsbUJBQW1CSixRQUFRcFA7b0JBQ2pDLE1BQU15UCxtQkFBbUJKLFFBQVFyUDtvQkFDakN6TCxTQUFTaWIsbUJBQW1CLElBQUksSUFBSUEsbUJBQW1CO29CQUN2RGhiLFNBQVNpYixtQkFBbUIsSUFBSSxJQUFJQSxtQkFBbUI7Z0JBQ3pEO1lBQ0YsT0FBTztnQkFDTCxNQUFNTixTQUFTOWtHLEtBQUsrTCxHQUFHLENBQUM4USxJQUFJK04sSUFBSTlOLElBQUlyRDtnQkFDcEMsTUFBTXNyRixRQUFRL2tHLEtBQUtxK0QsS0FBSyxDQUFDeGhELEdBQUdDO2dCQUM1QixNQUFNa29GLFFBQVFobEcsS0FBS3ErRCxLQUFLLENBQUM1a0QsR0FBR21SO2dCQUM1QixJQUFJK3FFLGNBQWMsR0FBRztvQkFDbkJ6TCxTQUFTOGEsUUFBUUY7b0JBQ2pCM2EsU0FBUzRhLFFBQVFEO2dCQUNuQixPQUFPO29CQUNMLE1BQU1PLFdBQVcxUCxZQUFZbVA7b0JBQzdCNWEsU0FBUzhhLFFBQVFLLFdBQVdMLFFBQVFLLFdBQVc7b0JBQy9DbGIsU0FBUzRhLFFBQVFNLFdBQVdOLFFBQVFNLFdBQVc7Z0JBQ2pEO1lBQ0Y7WUFDQSxJQUFJLENBQUN4TCx1QkFBdUIsQ0FBQyxFQUFFLEdBQUczUDtZQUNsQyxJQUFJLENBQUMyUCx1QkFBdUIsQ0FBQyxFQUFFLEdBQUcxUDtRQUNwQztRQUNBLE9BQU8sSUFBSSxDQUFDMFAsdUJBQXVCO0lBQ3JDO0lBQ0E0RixpQkFBaUIzcEIsSUFBSSxFQUFFd3ZCLFdBQVcsRUFBRTtRQUNsQyxNQUFNLEVBQ0pueUQsR0FBRyxFQUNIMzdCLFNBQVMsRUFDUG0rRSxTQUFTLEVBQ1YsRUFDRixHQUFHLElBQUk7UUFDUixNQUFNLENBQUN6TCxRQUFRQyxPQUFPLEdBQUcsSUFBSSxDQUFDOGEsbUJBQW1CO1FBQ2pELElBQUkvYSxXQUFXQyxRQUFRO1lBQ3JCaDNDLElBQUl3aUQsU0FBUyxHQUFHLENBQUNBLGFBQWEsS0FBS3pMO1lBQ25DLzJDLElBQUl4YyxNQUFNLENBQUNtL0M7WUFDWDtRQUNGO1FBQ0EsTUFBTXl2QixTQUFTcHlELElBQUlza0QsV0FBVztRQUM5QixJQUFJNk4sYUFBYTtZQUNmbnlELElBQUlsZCxJQUFJO1FBQ1Y7UUFDQWtkLElBQUlyRixLQUFLLENBQUNvOEMsUUFBUUM7UUFDbEJxSCxhQUFhMzBFLENBQUMsR0FBRyxJQUFJcXRFO1FBQ3JCc0gsYUFBYTVtRSxDQUFDLEdBQUcsSUFBSXUvRDtRQUNyQixNQUFNbVYsVUFBVSxJQUFJdnBCO1FBQ3BCdXBCLFFBQVFDLE9BQU8sQ0FBQ3pwQixNQUFNMGI7UUFDdEIsSUFBSStULE9BQU8vckcsTUFBTSxHQUFHLEdBQUc7WUFDckIsTUFBTXMwQyxRQUFROXRDLEtBQUs0UCxHQUFHLENBQUNzNkUsUUFBUUM7WUFDL0JoM0MsSUFBSXFrRCxXQUFXLENBQUMrTixPQUFPbGhHLEdBQUcsQ0FBQ2xFLENBQUFBLElBQUtBLElBQUkydEM7WUFDcENxRixJQUFJdWtELGNBQWMsSUFBSTVwRDtRQUN4QjtRQUNBcUYsSUFBSXdpRCxTQUFTLEdBQUdBLGFBQWE7UUFDN0J4aUQsSUFBSXhjLE1BQU0sQ0FBQzJvRTtRQUNYLElBQUlnRyxhQUFhO1lBQ2ZueUQsSUFBSWpkLE9BQU87UUFDYjtJQUNGO0lBQ0EydUUsbUJBQW1CO1FBQ2pCLElBQUssSUFBSTFtRyxJQUFJLElBQUksQ0FBQ3VrRixrQkFBa0IsQ0FBQ2xwRixNQUFNLEdBQUcsR0FBRzJFLEtBQUssR0FBR0EsSUFBSztZQUM1RCxJQUFJLENBQUMsSUFBSSxDQUFDdWtGLGtCQUFrQixDQUFDdmtGLEVBQUUsQ0FBQ3kwRCxPQUFPLEVBQUU7Z0JBQ3ZDLE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNUO0FBQ0Y7QUFDQSxJQUFLLE1BQU1xc0MsTUFBTTFwRSxJQUFLO0lBQ3BCLElBQUltakUsZUFBZTU3RixTQUFTLENBQUNtaUcsR0FBRyxLQUFLbGlHLFdBQVc7UUFDOUMyN0YsZUFBZTU3RixTQUFTLENBQUN5NEIsR0FBRyxDQUFDMHBFLEdBQUcsQ0FBQyxHQUFHdkcsZUFBZTU3RixTQUFTLENBQUNtaUcsR0FBRztJQUNsRTtBQUNGO0VBRUMsb0NBQW9DO0FBV3JDLE1BQU11RztJQUNKLENBQUN0bkcsTUFBTSxDQUFDO0lBQ1IsQ0FBQ3VuRyxJQUFJLENBQUM7SUFDTixDQUFDNWdFLE9BQU8sQ0FBQzs7YUFDRjZnRSxVQUFVO1lBQUM7WUFBYztZQUFjO1NBQWM7O0lBQzVELE9BQU9oL0YsTUFBTWsxQixJQUFJLEVBQUU7UUFDakIsTUFBTStwRSxVQUFVLElBQUlDO1FBQ3BCLE1BQU1DLGlCQUFpQixDQUFDO1FBQ3hCLElBQUlDLGdCQUFnQjtRQUNwQixLQUFLLE1BQU0vNkUsUUFBUXk2RSxZQUFZRSxPQUFPLENBQUU7WUFDdEMsTUFBTUssVUFBVUosUUFBUUssTUFBTSxDQUFDcHFFLElBQUksQ0FBQzdRLEtBQUs7WUFDekM4NkUsY0FBYyxDQUFDOTZFLEtBQUssR0FBR2c3RTtZQUN2QkQsaUJBQWlCLElBQUlDLFFBQVF2c0csTUFBTTtRQUNyQztRQUNBLE1BQU0wRSxTQUFTLElBQUk0RSxZQUFZZ2pHO1FBQy9CLE1BQU0vN0YsT0FBTyxJQUFJaE0sV0FBV0c7UUFDNUIsTUFBTXVuRyxPQUFPLElBQUl2M0YsU0FBU2hRO1FBQzFCLElBQUk0MUUsU0FBUztRQUNiLEtBQUssTUFBTS9vRCxRQUFReTZFLFlBQVlFLE9BQU8sQ0FBRTtZQUN0QyxNQUFNSyxVQUFVRixjQUFjLENBQUM5NkUsS0FBSztZQUNwQyxNQUFNdnhCLFNBQVN1c0csUUFBUXZzRyxNQUFNO1lBQzdCaXNHLEtBQUtRLFNBQVMsQ0FBQ255QixRQUFRdDZFO1lBQ3ZCdVEsS0FBS2hJLEdBQUcsQ0FBQ2drRyxTQUFTanlCLFNBQVM7WUFDM0JBLFVBQVUsSUFBSXQ2RTtRQUNoQjtRQUNBeWlDLE9BQU82M0MsV0FBVzUxRSxPQUFPK0UsVUFBVSxFQUFFO1FBQ3JDLE9BQU8vRTtJQUNUO0lBQ0F0QixZQUFZc0IsTUFBTSxDQUFFO1FBQ2xCLElBQUksQ0FBQyxDQUFDQSxNQUFNLEdBQUdBO1FBQ2YsSUFBSSxDQUFDLENBQUN1bkcsSUFBSSxHQUFHLElBQUl2M0YsU0FBUyxJQUFJLENBQUMsQ0FBQ2hRLE1BQU07UUFDdEMsSUFBSSxDQUFDLENBQUMybUMsT0FBTyxHQUFHLElBQUlDO0lBQ3RCO0lBQ0EsQ0FBQ29oRSxVQUFVLENBQUNuOUYsS0FBSztRQUNma3pCLE9BQU9sekIsUUFBUXk4RixZQUFZRSxPQUFPLENBQUNsc0csTUFBTSxFQUFFO1FBQzNDLElBQUlzNkUsU0FBUztRQUNiLElBQUssSUFBSTMxRSxJQUFJLEdBQUdBLElBQUk0SyxPQUFPNUssSUFBSztZQUM5QjIxRSxVQUFVLElBQUksQ0FBQyxDQUFDMnhCLElBQUksQ0FBQ1UsU0FBUyxDQUFDcnlCLFVBQVU7UUFDM0M7UUFDQSxNQUFNdDZFLFNBQVMsSUFBSSxDQUFDLENBQUNpc0csSUFBSSxDQUFDVSxTQUFTLENBQUNyeUI7UUFDcEMsT0FBTyxJQUFJLENBQUMsQ0FBQ2p2QyxPQUFPLENBQUNJLE1BQU0sQ0FBQyxJQUFJbG5DLFdBQVcsSUFBSSxDQUFDLENBQUNHLE1BQU0sRUFBRTQxRSxTQUFTLEdBQUd0NkU7SUFDdkU7SUFDQSxJQUFJbTdFLGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQyxDQUFDdXhCLFVBQVUsQ0FBQztJQUMxQjtJQUNBLElBQUk1d0IsYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDLENBQUM0d0IsVUFBVSxDQUFDO0lBQzFCO0lBQ0EsSUFBSTN3QixjQUFjO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLENBQUMyd0IsVUFBVSxDQUFDO0lBQzFCO0FBQ0Y7QUFDQSxNQUFNRTtJQUNKLENBQUNsb0csTUFBTSxDQUFDO0lBQ1IsQ0FBQ3VuRyxJQUFJLENBQUM7SUFDTixDQUFDNWdFLE9BQU8sQ0FBQzs7YUFDRjZnRSxVQUFVO1lBQUM7WUFBTztZQUFjO1lBQWdCO1NBQU07O0lBQzdELE9BQU9oL0YsTUFBTWsxQixJQUFJLEVBQUU7UUFDakIsTUFBTStwRSxVQUFVLElBQUlDO1FBQ3BCLE1BQU1DLGlCQUFpQixDQUFDO1FBQ3hCLElBQUlDLGdCQUFnQjtRQUNwQixLQUFLLE1BQU0vNkUsUUFBUXE3RSxlQUFlVixPQUFPLENBQUU7WUFDekMsTUFBTUssVUFBVUosUUFBUUssTUFBTSxDQUFDcHFFLElBQUksQ0FBQzdRLEtBQUs7WUFDekM4NkUsY0FBYyxDQUFDOTZFLEtBQUssR0FBR2c3RTtZQUN2QkQsaUJBQWlCLElBQUlDLFFBQVF2c0csTUFBTTtRQUNyQztRQUNBc3NHLGlCQUFpQjtRQUNqQixJQUFJTyxtQkFDRkMsb0JBQ0FDLGlCQUFpQixJQUFJVDtRQUN2QixJQUFJbHFFLEtBQUsxMEIsS0FBSyxFQUFFO1lBQ2RtL0Ysb0JBQW9CVixRQUFRSyxNQUFNLENBQUNwcUUsS0FBSzEwQixLQUFLLENBQUNBLEtBQUs7WUFDbkRvL0YscUJBQXFCWCxRQUFRSyxNQUFNLENBQUNwcUUsS0FBSzEwQixLQUFLLENBQUNtdUUsTUFBTTtZQUNyRGt4QixrQkFBa0IsSUFBSUYsa0JBQWtCN3NHLE1BQU0sR0FBRyxJQUFJOHNHLG1CQUFtQjlzRyxNQUFNO1FBQ2hGO1FBQ0EsTUFBTTBFLFNBQVMsSUFBSTRFLFlBQVl5akc7UUFDL0IsTUFBTXg4RixPQUFPLElBQUloTSxXQUFXRztRQUM1QixNQUFNdW5HLE9BQU8sSUFBSXYzRixTQUFTaFE7UUFDMUIsSUFBSTQxRSxTQUFTO1FBQ2IyeEIsS0FBS2UsUUFBUSxDQUFDMXlCLFVBQVVsNEMsS0FBSzZxRSxhQUFhLEdBQUcsSUFBSTtRQUNqRGhCLEtBQUtRLFNBQVMsQ0FBQ255QixRQUFRO1FBQ3ZCQSxVQUFVO1FBQ1ZneUIsZ0JBQWdCO1FBQ2hCLEtBQUssTUFBTS82RSxRQUFRcTdFLGVBQWVWLE9BQU8sQ0FBRTtZQUN6QyxNQUFNSyxVQUFVRixjQUFjLENBQUM5NkUsS0FBSztZQUNwQyxNQUFNdnhCLFNBQVN1c0csUUFBUXZzRyxNQUFNO1lBQzdCc3NHLGlCQUFpQixJQUFJdHNHO1lBQ3JCaXNHLEtBQUtRLFNBQVMsQ0FBQ255QixRQUFRdDZFO1lBQ3ZCdVEsS0FBS2hJLEdBQUcsQ0FBQ2drRyxTQUFTanlCLFNBQVM7WUFDM0JBLFVBQVUsSUFBSXQ2RTtRQUNoQjtRQUNBaXNHLEtBQUtRLFNBQVMsQ0FBQ255QixTQUFTZ3lCLGdCQUFnQixHQUFHQTtRQUMzQyxJQUFJbHFFLEtBQUsxMEIsS0FBSyxFQUFFO1lBQ2R1K0YsS0FBS1EsU0FBUyxDQUFDbnlCLFFBQVF1eUIsa0JBQWtCN3NHLE1BQU07WUFDL0N1USxLQUFLaEksR0FBRyxDQUFDc2tHLG1CQUFtQnZ5QixTQUFTO1lBQ3JDQSxVQUFVLElBQUl1eUIsa0JBQWtCN3NHLE1BQU07WUFDdENpc0csS0FBS1EsU0FBUyxDQUFDbnlCLFFBQVF3eUIsbUJBQW1COXNHLE1BQU07WUFDaER1USxLQUFLaEksR0FBRyxDQUFDdWtHLG9CQUFvQnh5QixTQUFTO1lBQ3RDQSxVQUFVLElBQUl3eUIsbUJBQW1COXNHLE1BQU07UUFDekM7UUFDQXlpQyxPQUFPNjNDLFVBQVU1MUUsT0FBTytFLFVBQVUsRUFBRTtRQUNwQyxPQUFPL0UsT0FBT3dqQixxQkFBcUIsQ0FBQ295RDtJQUN0QztJQUNBbDNFLFlBQVlzQixNQUFNLENBQUU7UUFDbEIsSUFBSSxDQUFDLENBQUNBLE1BQU0sR0FBR0E7UUFDZixJQUFJLENBQUMsQ0FBQ3VuRyxJQUFJLEdBQUcsSUFBSXYzRixTQUFTLElBQUksQ0FBQyxDQUFDaFEsTUFBTTtRQUN0QyxJQUFJLENBQUMsQ0FBQzJtQyxPQUFPLEdBQUcsSUFBSUM7SUFDdEI7SUFDQSxJQUFJMmhFLGdCQUFnQjtRQUNsQixPQUFPLElBQUksQ0FBQyxDQUFDaEIsSUFBSSxDQUFDaUIsUUFBUSxDQUFDLE9BQU87SUFDcEM7SUFDQSxDQUFDUixVQUFVLENBQUNuOUYsS0FBSztRQUNma3pCLE9BQU9sekIsUUFBUXE5RixlQUFlVixPQUFPLENBQUNsc0csTUFBTSxFQUFFO1FBQzlDLElBQUlzNkUsU0FBUztRQUNiLElBQUssSUFBSTMxRSxJQUFJLEdBQUdBLElBQUk0SyxPQUFPNUssSUFBSztZQUM5QjIxRSxVQUFVLElBQUksQ0FBQyxDQUFDMnhCLElBQUksQ0FBQ1UsU0FBUyxDQUFDcnlCLFVBQVU7UUFDM0M7UUFDQSxNQUFNdDZFLFNBQVMsSUFBSSxDQUFDLENBQUNpc0csSUFBSSxDQUFDVSxTQUFTLENBQUNyeUI7UUFDcEMsT0FBTyxJQUFJLENBQUMsQ0FBQ2p2QyxPQUFPLENBQUNJLE1BQU0sQ0FBQyxJQUFJbG5DLFdBQVcsSUFBSSxDQUFDLENBQUNHLE1BQU0sRUFBRTQxRSxTQUFTLEdBQUd0NkU7SUFDdkU7SUFDQSxJQUFJNDdFLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxDQUFDOHdCLFVBQVUsQ0FBQztJQUMxQjtJQUNBLElBQUkzekIsYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDLENBQUMyekIsVUFBVSxDQUFDO0lBQzFCO0lBQ0EsSUFBSXR6QixlQUFlO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLENBQUNzekIsVUFBVSxDQUFDO0lBQzFCO0lBQ0EsSUFBSTcrRixNQUFNO1FBQ1IsT0FBTyxJQUFJLENBQUMsQ0FBQzYrRixVQUFVLENBQUM7SUFDMUI7SUFDQSxJQUFJaC9GLFFBQVE7UUFDVixJQUFJNHNFLFNBQVM7UUFDYkEsVUFBVSxJQUFJLElBQUksQ0FBQyxDQUFDMnhCLElBQUksQ0FBQ1UsU0FBUyxDQUFDcnlCO1FBQ25DLE1BQU02eUIsY0FBYyxJQUFJLENBQUMsQ0FBQ2xCLElBQUksQ0FBQ1UsU0FBUyxDQUFDcnlCO1FBQ3pDLE1BQU01c0UsUUFBUSxJQUFJLENBQUMsQ0FBQzI5QixPQUFPLENBQUNJLE1BQU0sQ0FBQyxJQUFJbG5DLFdBQVcsSUFBSSxDQUFDLENBQUNHLE1BQU0sRUFBRTQxRSxTQUFTLEdBQUc2eUI7UUFDNUU3eUIsVUFBVSxJQUFJNnlCO1FBQ2QsTUFBTUMsZUFBZSxJQUFJLENBQUMsQ0FBQ25CLElBQUksQ0FBQ1UsU0FBUyxDQUFDcnlCO1FBQzFDLE1BQU11QixTQUFTLElBQUksQ0FBQyxDQUFDeHdDLE9BQU8sQ0FBQ0ksTUFBTSxDQUFDLElBQUlsbkMsV0FBVyxJQUFJLENBQUMsQ0FBQ0csTUFBTSxFQUFFNDFFLFNBQVMsR0FBRzh5QjtRQUM3RSxPQUFPO1lBQ0wxL0Y7WUFDQW11RTtRQUNGO0lBQ0Y7QUFDRjtBQUNBLE1BQU13eEI7O2FBQ0dDLFFBQVE7WUFBQztZQUFTO1lBQVE7WUFBbUI7WUFBdUI7WUFBc0I7WUFBZTtZQUFVO1lBQWU7WUFBYTtTQUFXOzs7YUFDMUo1NUYsVUFBVTtZQUFDO1lBQVU7WUFBZ0I7U0FBVTs7O2FBQy9DdzRGLFVBQVU7WUFBQztZQUFnQjtZQUFjO1lBQVk7U0FBTzs7SUFDbkUsT0FBTyxDQUFDcUIsY0FBYyxHQUFHL21HLEtBQUtELElBQUksQ0FBQyxJQUFJLENBQUMrbUcsS0FBSyxDQUFDdHRHLE1BQU0sR0FBRyxJQUFJLEdBQUc7SUFDOUQsT0FBTyxDQUFDd3RHLFdBQVcsR0FBRyxJQUFJLENBQUMsQ0FBQ0QsY0FBYyxHQUFHLElBQUksQ0FBQzc1RixPQUFPLENBQUMxVCxNQUFNLEdBQUcsRUFBRTtJQUNyRSxPQUFPLENBQUN5dEcsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLENBQUNELFdBQVcsR0FBRyxJQUFJLElBQUksRUFBRTtJQUMzRCxPQUFPLENBQUNFLHVCQUF1QixHQUFHLElBQUksQ0FBQyxDQUFDRCxrQkFBa0IsR0FBRyxJQUFJLElBQUksRUFBRTtJQUN2RSxPQUFPLENBQUNFLGNBQWMsR0FBRyxJQUFJLENBQUMsQ0FBQ0QsdUJBQXVCLEdBQUcsSUFBSSxJQUFJLEVBQUU7SUFDbkUsQ0FBQ2hwRyxNQUFNLENBQUM7SUFDUixDQUFDMm1DLE9BQU8sQ0FBQztJQUNULENBQUM0Z0UsSUFBSSxDQUFDO0lBQ043b0csWUFBWSxFQUNWbU4sSUFBSSxFQUNKaXJFLEtBQUssRUFDTixDQUFFO1FBQ0QsSUFBSSxDQUFDLENBQUM5MkUsTUFBTSxHQUFHNkw7UUFDZixJQUFJLENBQUMsQ0FBQzg2QixPQUFPLEdBQUcsSUFBSUM7UUFDcEIsSUFBSSxDQUFDLENBQUMyZ0UsSUFBSSxHQUFHLElBQUl2M0YsU0FBUyxJQUFJLENBQUMsQ0FBQ2hRLE1BQU07UUFDdEMsSUFBSTgyRSxPQUFPO1lBQ1RuNUUsT0FBT2t2QyxNQUFNLENBQUMsSUFBSSxFQUFFaXFDO1FBQ3RCO0lBQ0Y7SUFDQSxDQUFDb3lCLFdBQVcsQ0FBQ3IrRixLQUFLO1FBQ2hCa3pCLE9BQU9sekIsUUFBUTg5RixTQUFTQyxLQUFLLENBQUN0dEcsTUFBTSxFQUFFO1FBQ3RDLE1BQU02dEcsYUFBYXJuRyxLQUFLQyxLQUFLLENBQUM4SSxRQUFRO1FBQ3RDLE1BQU11K0YsWUFBWXYrRixRQUFRLElBQUk7UUFDOUIsTUFBTXRPLFFBQVEsSUFBSSxDQUFDLENBQUNnckcsSUFBSSxDQUFDaUIsUUFBUSxDQUFDVyxlQUFlQyxZQUFZO1FBQzdELE9BQU83c0csVUFBVSxPQUFPc0MsWUFBWXRDLFVBQVU7SUFDaEQ7SUFDQSxJQUFJdzdFLFFBQVE7UUFDVixPQUFPLElBQUksQ0FBQyxDQUFDbXhCLFdBQVcsQ0FBQztJQUMzQjtJQUNBLElBQUlseEIsT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDLENBQUNreEIsV0FBVyxDQUFDO0lBQzNCO0lBQ0EsSUFBSS8wQixrQkFBa0I7UUFDcEIsT0FBTyxJQUFJLENBQUMsQ0FBQyswQixXQUFXLENBQUM7SUFDM0I7SUFDQSxJQUFJcHhCLHNCQUFzQjtRQUN4QixPQUFPLElBQUksQ0FBQyxDQUFDb3hCLFdBQVcsQ0FBQztJQUMzQjtJQUNBLElBQUlqeEIscUJBQXFCO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLENBQUNpeEIsV0FBVyxDQUFDO0lBQzNCO0lBQ0EsSUFBSWh4QixjQUFjO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLENBQUNneEIsV0FBVyxDQUFDO0lBQzNCO0lBQ0EsSUFBSS93QixTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUMsQ0FBQyt3QixXQUFXLENBQUM7SUFDM0I7SUFDQSxJQUFJcjBCLGNBQWM7UUFDaEIsT0FBTyxJQUFJLENBQUMsQ0FBQ3EwQixXQUFXLENBQUM7SUFDM0I7SUFDQSxJQUFJOXdCLFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQyxDQUFDOHdCLFdBQVcsQ0FBQztJQUMzQjtJQUNBLElBQUk3d0IsV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDLENBQUM2d0IsV0FBVyxDQUFDO0lBQzNCO0lBQ0EsQ0FBQ0csVUFBVSxDQUFDeCtGLEtBQUs7UUFDZmt6QixPQUFPbHpCLFFBQVE4OUYsU0FBUzM1RixPQUFPLENBQUMxVCxNQUFNLEVBQUU7UUFDeEMsT0FBTyxJQUFJLENBQUMsQ0FBQ2lzRyxJQUFJLENBQUMrQixVQUFVLENBQUNYLFNBQVMsQ0FBQ0UsY0FBYyxHQUFHaCtGLFFBQVE7SUFDbEU7SUFDQSxJQUFJeXRFLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQyxDQUFDK3dCLFVBQVUsQ0FBQztJQUMxQjtJQUNBLElBQUk5d0IsZUFBZTtRQUNqQixPQUFPLElBQUksQ0FBQyxDQUFDOHdCLFVBQVUsQ0FBQztJQUMxQjtJQUNBLElBQUk3d0IsVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDLENBQUM2d0IsVUFBVSxDQUFDO0lBQzFCO0lBQ0EsSUFBSTV3QixPQUFPO1FBQ1QsSUFBSTdDLFNBQVMreUIsU0FBUyxDQUFDRyxXQUFXO1FBQ2xDLE1BQU1TLFlBQVksSUFBSSxDQUFDLENBQUNoQyxJQUFJLENBQUNpQixRQUFRLENBQUM1eUI7UUFDdEMsSUFBSTJ6QixjQUFjLEdBQUc7WUFDbkIsT0FBTzFxRztRQUNUO1FBQ0ErMkUsVUFBVTtRQUNWLE1BQU02QyxPQUFPLEVBQUU7UUFDZixJQUFLLElBQUl4NEUsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7WUFDMUJ3NEUsS0FBS2x5RSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNnaEcsSUFBSSxDQUFDaUMsUUFBUSxDQUFDNXpCLFFBQVE7WUFDdENBLFVBQVU7UUFDWjtRQUNBLE9BQU82QztJQUNUO0lBQ0EsSUFBSUMsYUFBYTtRQUNmLElBQUk5QyxTQUFTK3lCLFNBQVMsQ0FBQ0ksa0JBQWtCO1FBQ3pDLE1BQU1VLFlBQVksSUFBSSxDQUFDLENBQUNsQyxJQUFJLENBQUNpQixRQUFRLENBQUM1eUI7UUFDdEMsSUFBSTZ6QixjQUFjLEdBQUc7WUFDbkIsT0FBTzVxRztRQUNUO1FBQ0ErMkUsVUFBVTtRQUNWLE1BQU04QyxhQUFhLEVBQUU7UUFDckIsSUFBSyxJQUFJejRFLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1lBQzFCeTRFLFdBQVdueUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDZ2hHLElBQUksQ0FBQytCLFVBQVUsQ0FBQzF6QixRQUFRO1lBQzlDQSxVQUFVO1FBQ1o7UUFDQSxPQUFPOEM7SUFDVDtJQUNBLElBQUlHLGtCQUFrQjtRQUNwQixJQUFJakQsU0FBUyt5QixTQUFTLENBQUNLLHVCQUF1QjtRQUM5QyxNQUFNVSxhQUFhLElBQUksQ0FBQyxDQUFDbkMsSUFBSSxDQUFDaUIsUUFBUSxDQUFDNXlCO1FBQ3ZDLElBQUk4ekIsZUFBZSxHQUFHO1lBQ3BCLE9BQU83cUc7UUFDVDtRQUNBKzJFLFVBQVU7UUFDVixNQUFNaUQsa0JBQWtCLEVBQUU7UUFDMUIsSUFBSyxJQUFJNTRFLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1lBQzFCNDRFLGdCQUFnQnR5RSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNnaEcsSUFBSSxDQUFDaUMsUUFBUSxDQUFDNXpCLFFBQVE7WUFDakRBLFVBQVU7UUFDWjtRQUNBLE9BQU9pRDtJQUNUO0lBQ0EsQ0FBQ212QixVQUFVLENBQUNuOUYsS0FBSztRQUNma3pCLE9BQU9sekIsUUFBUTg5RixTQUFTbkIsT0FBTyxDQUFDbHNHLE1BQU0sRUFBRTtRQUN4QyxJQUFJczZFLFNBQVMreUIsU0FBUyxDQUFDTSxjQUFjLEdBQUc7UUFDeEMsSUFBSyxJQUFJaHBHLElBQUksR0FBR0EsSUFBSTRLLE9BQU81SyxJQUFLO1lBQzlCMjFFLFVBQVUsSUFBSSxDQUFDLENBQUMyeEIsSUFBSSxDQUFDVSxTQUFTLENBQUNyeUIsVUFBVTtRQUMzQztRQUNBLE1BQU10NkUsU0FBUyxJQUFJLENBQUMsQ0FBQ2lzRyxJQUFJLENBQUNVLFNBQVMsQ0FBQ3J5QjtRQUNwQyxNQUFNK3pCLGFBQWEsSUFBSTlwRyxXQUFXdkU7UUFDbENxdUcsV0FBVzlsRyxHQUFHLENBQUMsSUFBSWhFLFdBQVcsSUFBSSxDQUFDLENBQUNHLE1BQU0sRUFBRTQxRSxTQUFTLEdBQUd0NkU7UUFDeEQsT0FBTyxJQUFJLENBQUMsQ0FBQ3FyQyxPQUFPLENBQUNJLE1BQU0sQ0FBQzRpRTtJQUM5QjtJQUNBLElBQUloeEIsZUFBZTtRQUNqQixPQUFPLElBQUksQ0FBQyxDQUFDcXZCLFVBQVUsQ0FBQztJQUMxQjtJQUNBLElBQUkzekIsYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDLENBQUMyekIsVUFBVSxDQUFDO0lBQzFCO0lBQ0EsSUFBSTF3QixXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsQ0FBQzB3QixVQUFVLENBQUM7SUFDMUI7SUFDQSxJQUFJNXBHLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQyxDQUFDNHBHLFVBQVUsQ0FBQztJQUMxQjtJQUNBLElBQUluOEYsT0FBTztRQUNULElBQUkrcEUsU0FBUyt5QixTQUFTLENBQUNNLGNBQWM7UUFDckMsTUFBTXJCLGdCQUFnQixJQUFJLENBQUMsQ0FBQ0wsSUFBSSxDQUFDVSxTQUFTLENBQUNyeUI7UUFDM0NBLFVBQVUsSUFBSWd5QjtRQUNkLE1BQU1nQyx1QkFBdUIsSUFBSSxDQUFDLENBQUNyQyxJQUFJLENBQUNVLFNBQVMsQ0FBQ3J5QjtRQUNsREEsVUFBVSxJQUFJZzBCO1FBQ2QsTUFBTUMsb0JBQW9CLElBQUksQ0FBQyxDQUFDdEMsSUFBSSxDQUFDVSxTQUFTLENBQUNyeUI7UUFDL0NBLFVBQVUsSUFBSWkwQjtRQUNkLE1BQU12dUcsU0FBUyxJQUFJLENBQUMsQ0FBQ2lzRyxJQUFJLENBQUNVLFNBQVMsQ0FBQ3J5QjtRQUNwQyxJQUFJdDZFLFdBQVcsR0FBRztZQUNoQixPQUFPdUQ7UUFDVDtRQUNBLE9BQU8sSUFBSWdCLFdBQVcsSUFBSSxDQUFDLENBQUNHLE1BQU0sRUFBRTQxRSxTQUFTLEdBQUd0NkU7SUFDbEQ7SUFDQXM5RSxZQUFZO1FBQ1YsSUFBSWhELFNBQVMreUIsU0FBUyxDQUFDTSxjQUFjO1FBQ3JDLE1BQU1yQixnQkFBZ0IsSUFBSSxDQUFDLENBQUNMLElBQUksQ0FBQ1UsU0FBUyxDQUFDcnlCO1FBQzNDQSxVQUFVLElBQUlneUI7UUFDZCxNQUFNZ0MsdUJBQXVCLElBQUksQ0FBQyxDQUFDckMsSUFBSSxDQUFDVSxTQUFTLENBQUNyeUI7UUFDbERBLFVBQVUsSUFBSWcwQjtRQUNkLE1BQU1DLG9CQUFvQixJQUFJLENBQUMsQ0FBQ3RDLElBQUksQ0FBQ1UsU0FBUyxDQUFDcnlCO1FBQy9DQSxVQUFVLElBQUlpMEI7UUFDZCxNQUFNdnVHLFNBQVMsSUFBSSxDQUFDLENBQUNpc0csSUFBSSxDQUFDVSxTQUFTLENBQUNyeUI7UUFDcEMsTUFBTS9wRSxPQUFPLElBQUloTSxXQUFXLElBQUksQ0FBQyxDQUFDRyxNQUFNLEVBQUU0MUUsU0FBUyxHQUFHdDZFO1FBQ3REdVEsS0FBSzhzQixJQUFJLENBQUM7UUFDVixJQUFJLENBQUMsQ0FBQzR1RSxJQUFJLENBQUNRLFNBQVMsQ0FBQ255QixRQUFRO0lBQy9CO0lBQ0EsSUFBSXFCLGNBQWM7UUFDaEIsSUFBSXJCLFNBQVMreUIsU0FBUyxDQUFDTSxjQUFjO1FBQ3JDLE1BQU1yQixnQkFBZ0IsSUFBSSxDQUFDLENBQUNMLElBQUksQ0FBQ1UsU0FBUyxDQUFDcnlCO1FBQzNDQSxVQUFVLElBQUlneUI7UUFDZCxNQUFNZ0MsdUJBQXVCLElBQUksQ0FBQyxDQUFDckMsSUFBSSxDQUFDVSxTQUFTLENBQUNyeUI7UUFDbERBLFVBQVUsSUFBSWcwQjtRQUNkLE1BQU1DLG9CQUFvQixJQUFJLENBQUMsQ0FBQ3RDLElBQUksQ0FBQ1UsU0FBUyxDQUFDcnlCO1FBQy9DLElBQUlpMEIsc0JBQXNCLEdBQUc7WUFDM0IsT0FBTztRQUNUO1FBQ0EsTUFBTUMsa0JBQWtCLElBQUlqcUcsV0FBV2dxRztRQUN2Q0MsZ0JBQWdCam1HLEdBQUcsQ0FBQyxJQUFJaEUsV0FBVyxJQUFJLENBQUMsQ0FBQ0csTUFBTSxFQUFFNDFFLFNBQVMsR0FBR2kwQjtRQUM3RCxPQUFPLElBQUl2QyxZQUFZd0MsZ0JBQWdCOXBHLE1BQU07SUFDL0M7SUFDQSxJQUFJazBFLGlCQUFpQjtRQUNuQixJQUFJMEIsU0FBUyt5QixTQUFTLENBQUNNLGNBQWM7UUFDckMsTUFBTXJCLGdCQUFnQixJQUFJLENBQUMsQ0FBQ0wsSUFBSSxDQUFDVSxTQUFTLENBQUNyeUI7UUFDM0NBLFVBQVUsSUFBSWd5QjtRQUNkLE1BQU1nQyx1QkFBdUIsSUFBSSxDQUFDLENBQUNyQyxJQUFJLENBQUNVLFNBQVMsQ0FBQ3J5QjtRQUNsRCxJQUFJZzBCLHlCQUF5QixHQUFHO1lBQzlCLE9BQU87UUFDVDtRQUNBLE1BQU1HLHFCQUFxQixJQUFJbHFHLFdBQVcrcEc7UUFDMUNHLG1CQUFtQmxtRyxHQUFHLENBQUMsSUFBSWhFLFdBQVcsSUFBSSxDQUFDLENBQUNHLE1BQU0sRUFBRTQxRSxTQUFTLEdBQUdnMEI7UUFDaEUsT0FBTyxJQUFJMUIsZUFBZTZCLG1CQUFtQi9wRyxNQUFNO0lBQ3JEO0lBQ0EsT0FBT3dJLE1BQU1tc0UsSUFBSSxFQUFFO1FBQ2pCLE1BQU1xMUIsdUJBQXVCcjFCLEtBQUtULGNBQWMsR0FBR2cwQixlQUFlMS9GLEtBQUssQ0FBQ21zRSxLQUFLVCxjQUFjLElBQUk7UUFDL0YsTUFBTSsxQixvQkFBb0J0MUIsS0FBS3NDLFdBQVcsR0FBR3F3QixZQUFZOStGLEtBQUssQ0FBQ21zRSxLQUFLc0MsV0FBVyxJQUFJO1FBQ25GLE1BQU13d0IsVUFBVSxJQUFJQztRQUNwQixNQUFNQyxpQkFBaUIsQ0FBQztRQUN4QixJQUFJQyxnQkFBZ0I7UUFDcEIsS0FBSyxNQUFNLzZFLFFBQVE4N0UsU0FBU25CLE9BQU8sQ0FBRTtZQUNuQ0csY0FBYyxDQUFDOTZFLEtBQUssR0FBRzQ2RSxRQUFRSyxNQUFNLENBQUNuekIsSUFBSSxDQUFDOW5ELEtBQUs7WUFDaEQrNkUsaUJBQWlCLElBQUlELGNBQWMsQ0FBQzk2RSxLQUFLLENBQUN2eEIsTUFBTTtRQUNsRDtRQUNBLE1BQU0rc0csaUJBQWlCTSxTQUFTLENBQUNNLGNBQWMsR0FBRyxJQUFJckIsZ0JBQWdCLElBQUtvQyxDQUFBQSx1QkFBdUJBLHFCQUFxQmpsRyxVQUFVLEdBQUcsS0FBSyxJQUFLa2xHLENBQUFBLG9CQUFvQkEsa0JBQWtCbGxHLFVBQVUsR0FBRyxLQUFLLElBQUs0dkUsQ0FBQUEsS0FBSzlvRSxJQUFJLEdBQUc4b0UsS0FBSzlvRSxJQUFJLENBQUN2USxNQUFNLEdBQUc7UUFDMU8sTUFBTTBFLFNBQVMsSUFBSTRFLFlBQVl5akc7UUFDL0IsTUFBTXg4RixPQUFPLElBQUloTSxXQUFXRztRQUM1QixNQUFNdW5HLE9BQU8sSUFBSXYzRixTQUFTaFE7UUFDMUIsSUFBSTQxRSxTQUFTO1FBQ2IsTUFBTXMwQixXQUFXdkIsU0FBU0MsS0FBSyxDQUFDdHRHLE1BQU07UUFDdEMsSUFBSTZ1RyxXQUFXLEdBQ2JDLFVBQVU7UUFDWixJQUFLLElBQUlucUcsSUFBSSxHQUFHQSxJQUFJaXFHLFVBQVVqcUcsSUFBSztZQUNqQyxNQUFNMUQsUUFBUW80RSxJQUFJLENBQUNnMEIsU0FBU0MsS0FBSyxDQUFDM29HLEVBQUUsQ0FBQztZQUNyQyxNQUFNb3FHLE9BQU85dEcsVUFBVXNDLFlBQVksT0FBT3RDLFFBQVEsT0FBTztZQUN6RDR0RyxZQUFZRSxRQUFRRDtZQUNwQkEsV0FBVztZQUNYLElBQUlBLFlBQVksS0FBS25xRyxNQUFNaXFHLFdBQVcsR0FBRztnQkFDdkMzQyxLQUFLZSxRQUFRLENBQUMxeUIsVUFBVXUwQjtnQkFDeEJBLFdBQVc7Z0JBQ1hDLFVBQVU7WUFDWjtRQUNGO1FBQ0Fyc0UsT0FBTzYzQyxXQUFXK3lCLFNBQVMsQ0FBQ0UsY0FBYyxFQUFFO1FBQzVDLEtBQUssTUFBTWg4RSxRQUFRODdFLFNBQVMzNUYsT0FBTyxDQUFFO1lBQ25DdTRGLEtBQUsrQyxVQUFVLENBQUMxMEIsUUFBUWpCLElBQUksQ0FBQzluRCxLQUFLO1lBQ2xDK29ELFVBQVU7UUFDWjtRQUNBNzNDLE9BQU82M0MsV0FBVyt5QixTQUFTLENBQUNHLFdBQVcsRUFBRTtRQUN6QyxJQUFJbjBCLEtBQUs4RCxJQUFJLEVBQUU7WUFDYjh1QixLQUFLZSxRQUFRLENBQUMxeUIsVUFBVTtZQUN4QixLQUFLLE1BQU0yMEIsU0FBUzUxQixLQUFLOEQsSUFBSSxDQUFFO2dCQUM3Qjh1QixLQUFLaUQsUUFBUSxDQUFDNTBCLFFBQVEyMEIsT0FBTztnQkFDN0IzMEIsVUFBVTtZQUNaO1FBQ0YsT0FBTztZQUNMMnhCLEtBQUtlLFFBQVEsQ0FBQzF5QixVQUFVO1lBQ3hCQSxVQUFVLElBQUk7UUFDaEI7UUFDQTczQyxPQUFPNjNDLFdBQVcreUIsU0FBUyxDQUFDSSxrQkFBa0IsRUFBRTtRQUNoRCxJQUFJcDBCLEtBQUsrRCxVQUFVLEVBQUU7WUFDbkI2dUIsS0FBS2UsUUFBUSxDQUFDMXlCLFVBQVU7WUFDeEIsS0FBSyxNQUFNbk4sU0FBU2tNLEtBQUsrRCxVQUFVLENBQUU7Z0JBQ25DNnVCLEtBQUsrQyxVQUFVLENBQUMxMEIsUUFBUW5OLE9BQU87Z0JBQy9CbU4sVUFBVTtZQUNaO1FBQ0YsT0FBTztZQUNMMnhCLEtBQUtlLFFBQVEsQ0FBQzF5QixVQUFVO1lBQ3hCQSxVQUFVLElBQUk7UUFDaEI7UUFDQTczQyxPQUFPNjNDLFdBQVcreUIsU0FBUyxDQUFDSyx1QkFBdUIsRUFBRTtRQUNyRCxJQUFJcjBCLEtBQUtrRSxlQUFlLEVBQUU7WUFDeEIwdUIsS0FBS2UsUUFBUSxDQUFDMXlCLFVBQVU7WUFDeEIsS0FBSyxNQUFNNjBCLFVBQVU5MUIsS0FBS2tFLGVBQWUsQ0FBRTtnQkFDekMwdUIsS0FBS2lELFFBQVEsQ0FBQzUwQixRQUFRNjBCLFFBQVE7Z0JBQzlCNzBCLFVBQVU7WUFDWjtRQUNGLE9BQU87WUFDTDJ4QixLQUFLZSxRQUFRLENBQUMxeUIsVUFBVTtZQUN4QkEsVUFBVSxJQUFJO1FBQ2hCO1FBQ0E3M0MsT0FBTzYzQyxXQUFXK3lCLFNBQVMsQ0FBQ00sY0FBYyxFQUFFO1FBQzVDMUIsS0FBS1EsU0FBUyxDQUFDWSxTQUFTLENBQUNNLGNBQWMsRUFBRTtRQUN6Q3J6QixVQUFVO1FBQ1YsS0FBSyxNQUFNL29ELFFBQVE4N0UsU0FBU25CLE9BQU8sQ0FBRTtZQUNuQyxNQUFNSyxVQUFVRixjQUFjLENBQUM5NkUsS0FBSztZQUNwQyxNQUFNdnhCLFNBQVN1c0csUUFBUXZzRyxNQUFNO1lBQzdCaXNHLEtBQUtRLFNBQVMsQ0FBQ255QixRQUFRdDZFO1lBQ3ZCdVEsS0FBS2hJLEdBQUcsQ0FBQ2drRyxTQUFTanlCLFNBQVM7WUFDM0JBLFVBQVUsSUFBSXQ2RTtRQUNoQjtRQUNBaXNHLEtBQUtRLFNBQVMsQ0FBQ1ksU0FBUyxDQUFDTSxjQUFjLEVBQUVyekIsU0FBUyt5QixTQUFTLENBQUNNLGNBQWMsR0FBRztRQUM3RSxJQUFJLENBQUNlLHNCQUFzQjtZQUN6QnpDLEtBQUtRLFNBQVMsQ0FBQ255QixRQUFRO1lBQ3ZCQSxVQUFVO1FBQ1osT0FBTztZQUNMLE1BQU10NkUsU0FBUzB1RyxxQkFBcUJqbEcsVUFBVTtZQUM5Q3dpRyxLQUFLUSxTQUFTLENBQUNueUIsUUFBUXQ2RTtZQUN2QnlpQyxPQUFPNjNDLFNBQVMsSUFBSXQ2RSxVQUFVMEUsT0FBTytFLFVBQVUsRUFBRTtZQUNqRDhHLEtBQUtoSSxHQUFHLENBQUMsSUFBSWhFLFdBQVdtcUcsdUJBQXVCcDBCLFNBQVM7WUFDeERBLFVBQVUsSUFBSXQ2RTtRQUNoQjtRQUNBLElBQUksQ0FBQzJ1RyxtQkFBbUI7WUFDdEIxQyxLQUFLUSxTQUFTLENBQUNueUIsUUFBUTtZQUN2QkEsVUFBVTtRQUNaLE9BQU87WUFDTCxNQUFNdDZFLFNBQVMydUcsa0JBQWtCbGxHLFVBQVU7WUFDM0N3aUcsS0FBS1EsU0FBUyxDQUFDbnlCLFFBQVF0NkU7WUFDdkJ5aUMsT0FBTzYzQyxTQUFTLElBQUl0NkUsVUFBVTBFLE9BQU8rRSxVQUFVLEVBQUU7WUFDakQ4RyxLQUFLaEksR0FBRyxDQUFDLElBQUloRSxXQUFXb3FHLG9CQUFvQnIwQixTQUFTO1lBQ3JEQSxVQUFVLElBQUl0NkU7UUFDaEI7UUFDQSxJQUFJcTVFLEtBQUs5b0UsSUFBSSxLQUFLaE4sV0FBVztZQUMzQjBvRyxLQUFLUSxTQUFTLENBQUNueUIsUUFBUTtZQUN2QkEsVUFBVTtRQUNaLE9BQU87WUFDTDJ4QixLQUFLUSxTQUFTLENBQUNueUIsUUFBUWpCLEtBQUs5b0UsSUFBSSxDQUFDdlEsTUFBTTtZQUN2Q3VRLEtBQUtoSSxHQUFHLENBQUM4d0UsS0FBSzlvRSxJQUFJLEVBQUUrcEUsU0FBUztZQUM3QkEsVUFBVSxJQUFJakIsS0FBSzlvRSxJQUFJLENBQUN2USxNQUFNO1FBQ2hDO1FBQ0F5aUMsT0FBTzYzQyxVQUFVNTFFLE9BQU8rRSxVQUFVLEVBQUU7UUFDcEMsT0FBTy9FLE9BQU93akIscUJBQXFCLENBQUNveUQ7SUFDdEM7QUFDRjtFQUVDLGtDQUFrQztBQUNuQyxNQUFNODBCO0lBQ0osT0FBTyxDQUFDQyxJQUFJLEdBQUcsS0FBSztJQUNwQixPQUFPLENBQUN4aEcsR0FBRyxHQUFHLEdBQUc7SUFDakIsV0FBV3loRyxhQUFhO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLENBQUNELElBQUk7SUFDbkI7SUFDQSxXQUFXQyxXQUFXMTNGLEdBQUcsRUFBRTtRQUN6QixJQUFJLENBQUUsUUFBTzIzRixXQUFXLGVBQWUzM0YsZUFBZTIzRixNQUFLLEtBQU0zM0YsUUFBUSxNQUFNO1lBQzdFLE1BQU0sSUFBSXVHLE1BQU07UUFDbEI7UUFDQSxJQUFJLENBQUMsQ0FBQ2t4RixJQUFJLEdBQUd6M0Y7SUFDZjtJQUNBLFdBQVc0M0YsWUFBWTtRQUNyQixPQUFPLElBQUksQ0FBQyxDQUFDM2hHLEdBQUc7SUFDbEI7SUFDQSxXQUFXMmhHLFVBQVU1M0YsR0FBRyxFQUFFO1FBQ3hCLElBQUksT0FBT0EsUUFBUSxVQUFVO1lBQzNCLE1BQU0sSUFBSXVHLE1BQU07UUFDbEI7UUFDQSxJQUFJLENBQUMsQ0FBQ3RRLEdBQUcsR0FBRytKO0lBQ2Q7QUFDRjtFQUVDLDRCQUE0QjtBQUM3QixNQUFNNjNGO0lBQ0osQ0FBQzVrRyxHQUFHLENBQUM7SUFDTCxDQUFDMEYsSUFBSSxDQUFDO0lBQ05uTixZQUFZLEVBQ1Zzc0csVUFBVSxFQUNWNXFELE9BQU8sRUFDUixDQUFFO1FBQ0QsSUFBSSxDQUFDLENBQUNqNkMsR0FBRyxHQUFHNmtHO1FBQ1osSUFBSSxDQUFDLENBQUNuL0YsSUFBSSxHQUFHdTBDO0lBQ2Y7SUFDQTZxRCxTQUFTO1FBQ1AsT0FBTyxJQUFJLENBQUMsQ0FBQ3AvRixJQUFJO0lBQ25CO0lBQ0F0TyxJQUFJYSxJQUFJLEVBQUU7UUFDUixPQUFPLElBQUksQ0FBQyxDQUFDK0gsR0FBRyxDQUFDNUksR0FBRyxDQUFDYSxTQUFTO0lBQ2hDO0lBQ0EsQ0FBQ2lXLE9BQU9oVSxRQUFRLENBQUMsR0FBRztRQUNsQixPQUFPLElBQUksQ0FBQyxDQUFDOEYsR0FBRyxDQUFDc1AsT0FBTztJQUMxQjtBQUNGO0VBRUMsMkNBQTJDO0FBRzVDLE1BQU15MUYsV0FBVzcyRixPQUFPO0FBQ3hCLE1BQU04MkY7SUFDSixDQUFDQyxTQUFTLENBQVM7SUFDbkIsQ0FBQ0MsT0FBTyxDQUFTO0lBQ2pCLENBQUNDLE9BQU8sQ0FBUztJQUNqQixDQUFDNTJDLE9BQU8sQ0FBUTtJQUNoQmgyRCxZQUFZNnNHLGVBQWUsRUFBRSxFQUMzQm50RyxJQUFJLEVBQ0p1dEMsTUFBTSxFQUNONi9ELEtBQUssRUFDTEMsUUFBUSxFQUNULENBQUU7YUFUSCxDQUFDTCxTQUFTLEdBQUc7YUFDYixDQUFDQyxPQUFPLEdBQUc7YUFDWCxDQUFDQyxPQUFPLEdBQUc7YUFDWCxDQUFDNTJDLE9BQU8sR0FBRztRQU9ULElBQUksQ0FBQyxDQUFDMDJDLFNBQVMsR0FBRyxDQUFDLENBQUVHLENBQUFBLGtCQUFrQmo5RSxvQkFBb0JFLE9BQU87UUFDbEUsSUFBSSxDQUFDLENBQUM2OEUsT0FBTyxHQUFHLENBQUMsQ0FBRUUsQ0FBQUEsa0JBQWtCajlFLG9CQUFvQkcsS0FBSztRQUM5RCxJQUFJLENBQUNyd0IsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ3V0QyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDNi9ELEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLFFBQVEsR0FBR0E7SUFDbEI7SUFDQSxJQUFJLzJDLFVBQVU7UUFDWixJQUFJLElBQUksQ0FBQyxDQUFDNDJDLE9BQU8sRUFBRTtZQUNqQixPQUFPLElBQUksQ0FBQyxDQUFDNTJDLE9BQU87UUFDdEI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNBLE9BQU8sRUFBRTtZQUNsQixPQUFPO1FBQ1Q7UUFDQSxNQUFNLEVBQ0pvZCxLQUFLLEVBQ0x5MUIsSUFBSSxFQUNMLEdBQUcsSUFBSSxDQUFDaUUsS0FBSztRQUNkLElBQUksSUFBSSxDQUFDLENBQUNKLFNBQVMsRUFBRTtZQUNuQixPQUFPN0QsTUFBTW1FLGNBQWM7UUFDN0IsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDTCxPQUFPLEVBQUU7WUFDeEIsT0FBT3Y1QixPQUFPNjVCLGVBQWU7UUFDL0I7UUFDQSxPQUFPO0lBQ1Q7SUFDQUMsWUFBWUMsUUFBUSxFQUFFbjNDLE9BQU8sRUFBRTQyQyxVQUFVLEtBQUssRUFBRTtRQUM5QyxJQUFJTyxhQUFhWCxVQUFVO1lBQ3pCcHRFLFlBQVk7UUFDZDtRQUNBLElBQUksQ0FBQyxDQUFDd3RFLE9BQU8sR0FBR0E7UUFDaEIsSUFBSSxDQUFDLENBQUM1MkMsT0FBTyxHQUFHQTtJQUNsQjtBQUNGO0FBQ0EsTUFBTW8zQztJQUNKLENBQUNDLGFBQWEsQ0FBUTtJQUN0QixDQUFDQyxNQUFNLENBQWE7SUFDcEIsQ0FBQ0MsV0FBVyxDQUFRO0lBQ3BCLENBQUNDLEtBQUssQ0FBUTtJQUNkeHRHLFlBQVltTixJQUFJLEVBQUUwL0Ysa0JBQWtCajlFLG9CQUFvQkUsT0FBTyxDQUFFO2FBSmpFLENBQUN1OUUsYUFBYSxHQUFHO2FBQ2pCLENBQUNDLE1BQU0sR0FBRyxJQUFJeGpFO2FBQ2QsQ0FBQ3lqRSxXQUFXLEdBQUc7YUFDZixDQUFDQyxLQUFLLEdBQUc7UUFFUCxJQUFJLENBQUNYLGVBQWUsR0FBR0E7UUFDdkIsSUFBSSxDQUFDbnRHLElBQUksR0FBRztRQUNaLElBQUksQ0FBQyt0RyxPQUFPLEdBQUc7UUFDZixJQUFJdGdHLFNBQVMsTUFBTTtZQUNqQjtRQUNGO1FBQ0EsSUFBSSxDQUFDek4sSUFBSSxHQUFHeU4sS0FBS3pOLElBQUk7UUFDckIsSUFBSSxDQUFDK3RHLE9BQU8sR0FBR3RnRyxLQUFLc2dHLE9BQU87UUFDM0IsSUFBSSxDQUFDLENBQUNELEtBQUssR0FBR3JnRyxLQUFLcWdHLEtBQUs7UUFDeEIsS0FBSyxNQUFNN0csU0FBU3g1RixLQUFLbWdHLE1BQU0sQ0FBRTtZQUMvQixJQUFJLENBQUMsQ0FBQ0EsTUFBTSxDQUFDbm9HLEdBQUcsQ0FBQ3doRyxNQUFNcDFGLEVBQUUsRUFBRSxJQUFJazdGLHFCQUFxQkksaUJBQWlCbEc7UUFDdkU7UUFDQSxJQUFJeDVGLEtBQUt1Z0csU0FBUyxLQUFLLE9BQU87WUFDNUIsS0FBSyxNQUFNL0csU0FBUyxJQUFJLENBQUMsQ0FBQzJHLE1BQU0sQ0FBQzVwRixNQUFNLEdBQUk7Z0JBQ3pDaWpGLE1BQU11RyxXQUFXLENBQUNWLFVBQVU7WUFDOUI7UUFDRjtRQUNBLEtBQUssTUFBTXgrQyxNQUFNN2dELEtBQUs2Z0QsRUFBRSxDQUFFO1lBQ3hCLElBQUksQ0FBQyxDQUFDcy9DLE1BQU0sQ0FBQ3p1RyxHQUFHLENBQUNtdkQsSUFBSWsvQyxXQUFXLENBQUNWLFVBQVU7UUFDN0M7UUFDQSxLQUFLLE1BQU1tQixPQUFPeGdHLEtBQUt3Z0csR0FBRyxDQUFFO1lBQzFCLElBQUksQ0FBQyxDQUFDTCxNQUFNLENBQUN6dUcsR0FBRyxDQUFDOHVHLEtBQUtULFdBQVcsQ0FBQ1YsVUFBVTtRQUM5QztRQUNBLElBQUksQ0FBQyxDQUFDZSxXQUFXLEdBQUcsSUFBSSxDQUFDSyxPQUFPO0lBQ2xDO0lBQ0EsQ0FBQ0MsNEJBQTRCLENBQUN0bEYsS0FBSztRQUNqQyxNQUFNM3JCLFNBQVMyckIsTUFBTTNyQixNQUFNO1FBQzNCLElBQUlBLFNBQVMsR0FBRztZQUNkLE9BQU87UUFDVDtRQUNBLE1BQU1reEcsV0FBV3ZsRixLQUFLLENBQUMsRUFBRTtRQUN6QixJQUFLLElBQUlobkIsSUFBSSxHQUFHQSxJQUFJM0UsUUFBUTJFLElBQUs7WUFDL0IsTUFBTXdyQyxVQUFVeGtCLEtBQUssQ0FBQ2huQixFQUFFO1lBQ3hCLElBQUluQjtZQUNKLElBQUl1TyxNQUFNK0YsT0FBTyxDQUFDcTRCLFVBQVU7Z0JBQzFCM3NDLFFBQVEsSUFBSSxDQUFDLENBQUN5dEcsNEJBQTRCLENBQUM5Z0U7WUFDN0MsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDdWdFLE1BQU0sQ0FBQ2xvRyxHQUFHLENBQUMybkMsVUFBVTtnQkFDcEMzc0MsUUFBUSxJQUFJLENBQUMsQ0FBQ2t0RyxNQUFNLENBQUN6dUcsR0FBRyxDQUFDa3VDLFNBQVNpcEIsT0FBTztZQUMzQyxPQUFPO2dCQUNMNzJCLEtBQUssQ0FBQyxrQ0FBa0MsRUFBRTROLFFBQVEsQ0FBQztnQkFDbkQsT0FBTztZQUNUO1lBQ0EsT0FBUStnRTtnQkFDTixLQUFLO29CQUNILElBQUksQ0FBQzF0RyxPQUFPO3dCQUNWLE9BQU87b0JBQ1Q7b0JBQ0E7Z0JBQ0YsS0FBSztvQkFDSCxJQUFJQSxPQUFPO3dCQUNULE9BQU87b0JBQ1Q7b0JBQ0E7Z0JBQ0YsS0FBSztvQkFDSCxPQUFPLENBQUNBO2dCQUNWO29CQUNFLE9BQU87WUFDWDtRQUNGO1FBQ0EsT0FBTzB0RyxhQUFhO0lBQ3RCO0lBQ0E5RixVQUFVckIsS0FBSyxFQUFFO1FBQ2YsSUFBSSxJQUFJLENBQUMsQ0FBQzJHLE1BQU0sQ0FBQzE3RixJQUFJLEtBQUssR0FBRztZQUMzQixPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUMrMEYsT0FBTztZQUNWM25FLEtBQUs7WUFDTCxPQUFPO1FBQ1Q7UUFDQSxJQUFJMm5FLE1BQU1waEcsSUFBSSxLQUFLLE9BQU87WUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDK25HLE1BQU0sQ0FBQ2xvRyxHQUFHLENBQUN1aEcsTUFBTXAxRixFQUFFLEdBQUc7Z0JBQy9CNHRCLEtBQUssQ0FBQyxrQ0FBa0MsRUFBRXduRSxNQUFNcDFGLEVBQUUsQ0FBQyxDQUFDO2dCQUNwRCxPQUFPO1lBQ1Q7WUFDQSxPQUFPLElBQUksQ0FBQyxDQUFDKzdGLE1BQU0sQ0FBQ3p1RyxHQUFHLENBQUM4bkcsTUFBTXAxRixFQUFFLEVBQUV5a0QsT0FBTztRQUMzQyxPQUFPLElBQUkyd0MsTUFBTXBoRyxJQUFJLEtBQUssUUFBUTtZQUNoQyxJQUFJb2hHLE1BQU1vSCxVQUFVLEVBQUU7Z0JBQ3BCLE9BQU8sSUFBSSxDQUFDLENBQUNGLDRCQUE0QixDQUFDbEgsTUFBTW9ILFVBQVU7WUFDNUQ7WUFDQSxJQUFJLENBQUNwSCxNQUFNcUgsTUFBTSxJQUFJckgsTUFBTXFILE1BQU0sS0FBSyxTQUFTO2dCQUM3QyxLQUFLLE1BQU16OEYsTUFBTW8xRixNQUFNdnlCLEdBQUcsQ0FBRTtvQkFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDazVCLE1BQU0sQ0FBQ2xvRyxHQUFHLENBQUNtTSxLQUFLO3dCQUN6QjR0QixLQUFLLENBQUMsa0NBQWtDLEVBQUU1dEIsR0FBRyxDQUFDO3dCQUM5QyxPQUFPO29CQUNUO29CQUNBLElBQUksSUFBSSxDQUFDLENBQUMrN0YsTUFBTSxDQUFDenVHLEdBQUcsQ0FBQzBTLElBQUl5a0QsT0FBTyxFQUFFO3dCQUNoQyxPQUFPO29CQUNUO2dCQUNGO2dCQUNBLE9BQU87WUFDVCxPQUFPLElBQUkyd0MsTUFBTXFILE1BQU0sS0FBSyxTQUFTO2dCQUNuQyxLQUFLLE1BQU16OEYsTUFBTW8xRixNQUFNdnlCLEdBQUcsQ0FBRTtvQkFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDazVCLE1BQU0sQ0FBQ2xvRyxHQUFHLENBQUNtTSxLQUFLO3dCQUN6QjR0QixLQUFLLENBQUMsa0NBQWtDLEVBQUU1dEIsR0FBRyxDQUFDO3dCQUM5QyxPQUFPO29CQUNUO29CQUNBLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQys3RixNQUFNLENBQUN6dUcsR0FBRyxDQUFDMFMsSUFBSXlrRCxPQUFPLEVBQUU7d0JBQ2pDLE9BQU87b0JBQ1Q7Z0JBQ0Y7Z0JBQ0EsT0FBTztZQUNULE9BQU8sSUFBSTJ3QyxNQUFNcUgsTUFBTSxLQUFLLFVBQVU7Z0JBQ3BDLEtBQUssTUFBTXo4RixNQUFNbzFGLE1BQU12eUIsR0FBRyxDQUFFO29CQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNrNUIsTUFBTSxDQUFDbG9HLEdBQUcsQ0FBQ21NLEtBQUs7d0JBQ3pCNHRCLEtBQUssQ0FBQyxrQ0FBa0MsRUFBRTV0QixHQUFHLENBQUM7d0JBQzlDLE9BQU87b0JBQ1Q7b0JBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDKzdGLE1BQU0sQ0FBQ3p1RyxHQUFHLENBQUMwUyxJQUFJeWtELE9BQU8sRUFBRTt3QkFDakMsT0FBTztvQkFDVDtnQkFDRjtnQkFDQSxPQUFPO1lBQ1QsT0FBTyxJQUFJMndDLE1BQU1xSCxNQUFNLEtBQUssVUFBVTtnQkFDcEMsS0FBSyxNQUFNejhGLE1BQU1vMUYsTUFBTXZ5QixHQUFHLENBQUU7b0JBQzFCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ2s1QixNQUFNLENBQUNsb0csR0FBRyxDQUFDbU0sS0FBSzt3QkFDekI0dEIsS0FBSyxDQUFDLGtDQUFrQyxFQUFFNXRCLEdBQUcsQ0FBQzt3QkFDOUMsT0FBTztvQkFDVDtvQkFDQSxJQUFJLElBQUksQ0FBQyxDQUFDKzdGLE1BQU0sQ0FBQ3p1RyxHQUFHLENBQUMwUyxJQUFJeWtELE9BQU8sRUFBRTt3QkFDaEMsT0FBTztvQkFDVDtnQkFDRjtnQkFDQSxPQUFPO1lBQ1Q7WUFDQTcyQixLQUFLLENBQUMsZ0NBQWdDLEVBQUV3bkUsTUFBTXFILE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDdkQsT0FBTztRQUNUO1FBQ0E3dUUsS0FBSyxDQUFDLG1CQUFtQixFQUFFd25FLE1BQU1waEcsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUN4QyxPQUFPO0lBQ1Q7SUFDQTBvRyxjQUFjMThGLEVBQUUsRUFBRXlrRCxVQUFVLElBQUksRUFBRWs0QyxhQUFhLElBQUksRUFBRTtRQUNuRCxNQUFNdkgsUUFBUSxJQUFJLENBQUMsQ0FBQzJHLE1BQU0sQ0FBQ3p1RyxHQUFHLENBQUMwUztRQUMvQixJQUFJLENBQUNvMUYsT0FBTztZQUNWeG5FLEtBQUssQ0FBQyxrQ0FBa0MsRUFBRTV0QixHQUFHLENBQUM7WUFDOUM7UUFDRjtRQUNBLElBQUkyOEYsY0FBY2w0QyxXQUFXMndDLE1BQU1vRyxRQUFRLENBQUNud0csTUFBTSxFQUFFO1lBQ2xELEtBQUssTUFBTXV4RyxXQUFXeEgsTUFBTW9HLFFBQVEsQ0FBRTtnQkFDcEMsS0FBSyxNQUFNcUIsV0FBV0QsUUFBUztvQkFDN0IsSUFBSUMsWUFBWTc4RixJQUFJO3dCQUNsQixJQUFJLENBQUMsQ0FBQys3RixNQUFNLENBQUN6dUcsR0FBRyxDQUFDdXZHLFVBQVVsQixZQUFZVixVQUFVLE9BQU87b0JBQzFEO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBN0YsTUFBTXVHLFdBQVcsQ0FBQ1YsVUFBVSxDQUFDLENBQUN4MkMsU0FBUztRQUN2QyxJQUFJLENBQUMsQ0FBQ3EzQyxhQUFhLEdBQUc7SUFDeEI7SUFDQWdCLFlBQVksRUFDVmp1RyxLQUFLLEVBQ0w4dEcsVUFBVSxFQUNYLEVBQUU7UUFDRCxJQUFJSjtRQUNKLEtBQUssTUFBTS9aLFFBQVEzekYsTUFBTztZQUN4QixPQUFRMnpGO2dCQUNOLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO29CQUNIK1osV0FBVy9aO29CQUNYO1lBQ0o7WUFDQSxNQUFNNFMsUUFBUSxJQUFJLENBQUMsQ0FBQzJHLE1BQU0sQ0FBQ3p1RyxHQUFHLENBQUNrMUY7WUFDL0IsSUFBSSxDQUFDNFMsT0FBTztnQkFDVjtZQUNGO1lBQ0EsT0FBUW1IO2dCQUNOLEtBQUs7b0JBQ0gsSUFBSSxDQUFDRyxhQUFhLENBQUNsYSxNQUFNLE1BQU1tYTtvQkFDL0I7Z0JBQ0YsS0FBSztvQkFDSCxJQUFJLENBQUNELGFBQWEsQ0FBQ2xhLE1BQU0sT0FBT21hO29CQUNoQztnQkFDRixLQUFLO29CQUNILElBQUksQ0FBQ0QsYUFBYSxDQUFDbGEsTUFBTSxDQUFDNFMsTUFBTTN3QyxPQUFPLEVBQUVrNEM7b0JBQ3pDO1lBQ0o7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDYixhQUFhLEdBQUc7SUFDeEI7SUFDQSxJQUFJaUIsdUJBQXVCO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLENBQUNmLFdBQVcsS0FBSyxRQUFRLElBQUksQ0FBQ0ssT0FBTyxPQUFPLElBQUksQ0FBQyxDQUFDTCxXQUFXO0lBQzNFO0lBQ0FnQixXQUFXO1FBQ1QsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDakIsTUFBTSxDQUFDMTdGLElBQUksRUFBRTtZQUN0QixPQUFPO1FBQ1Q7UUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDNDdGLEtBQUssRUFBRTtZQUNmLE9BQU8sSUFBSSxDQUFDLENBQUNBLEtBQUssQ0FBQ3J1RyxLQUFLO1FBQzFCO1FBQ0EsT0FBTztlQUFJLElBQUksQ0FBQyxDQUFDbXVHLE1BQU0sQ0FBQ2xwRyxJQUFJO1NBQUc7SUFDakM7SUFDQW9xRyxTQUFTajlGLEVBQUUsRUFBRTtRQUNYLE9BQU8sSUFBSSxDQUFDLENBQUMrN0YsTUFBTSxDQUFDenVHLEdBQUcsQ0FBQzBTLE9BQU87SUFDakM7SUFDQXE4RixVQUFVO1FBQ1IsSUFBSSxJQUFJLENBQUMsQ0FBQ1AsYUFBYSxLQUFLLE1BQU07WUFDaEMsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsYUFBYTtRQUM1QjtRQUNBLE1BQU05cEYsT0FBTyxJQUFJb3VEO1FBQ2pCLEtBQUssTUFBTSxDQUFDcGdFLElBQUlvMUYsTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDMkcsTUFBTSxDQUFFO1lBQ3RDL3BGLEtBQUtpc0IsTUFBTSxDQUFDLENBQUMsRUFBRWorQixHQUFHLENBQUMsRUFBRW8xRixNQUFNM3dDLE9BQU8sQ0FBQyxDQUFDO1FBQ3RDO1FBQ0EsT0FBTyxJQUFJLENBQUMsQ0FBQ3EzQyxhQUFhLEdBQUc5cEYsS0FBS2l2RCxTQUFTO0lBQzdDO0lBQ0EsQ0FBQzc4RCxPQUFPaFUsUUFBUSxDQUFDLEdBQUc7UUFDbEIsT0FBTyxJQUFJLENBQUMsQ0FBQzJyRyxNQUFNLENBQUN2MkYsT0FBTztJQUM3QjtBQUNGO0VBRUMsb0NBQW9DO0FBZXJDLE1BQU0wM0Y7SUFDSnp1RyxZQUFZMHVHLHFCQUFxQixFQUFFLEVBQ2pDQyxlQUFlLEtBQUssRUFDcEJDLGdCQUFnQixLQUFLLEVBQ3RCLENBQUU7UUFDRHZ2RSxPQUFPcXZFLHVCQUF1QjtRQUM5QixNQUFNLEVBQ0o5eEcsTUFBTSxFQUNOaXlHLFdBQVcsRUFDWEMsZUFBZSxFQUNmQywwQkFBMEIsRUFDM0IsR0FBR0w7UUFDSixJQUFJLENBQUNNLGFBQWEsR0FBRyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdIO1FBQ3hCLElBQUksQ0FBQ0ksMkJBQTJCLEdBQUdIO1FBQ25DLElBQUlGLGFBQWFqeUcsU0FBUyxHQUFHO1lBQzNCLE1BQU0wRSxTQUFTdXRHLHVCQUF1QjF0RyxjQUFjMHRHLFlBQVl4b0csVUFBVSxLQUFLd29HLFlBQVl2dEcsTUFBTSxDQUFDK0UsVUFBVSxHQUFHd29HLFlBQVl2dEcsTUFBTSxHQUFHLElBQUlILFdBQVcwdEcsYUFBYXZ0RyxNQUFNO1lBQ3RLLElBQUksQ0FBQzB0RyxhQUFhLENBQUNubkcsSUFBSSxDQUFDdkc7UUFDMUI7UUFDQSxJQUFJLENBQUM2dEcsc0JBQXNCLEdBQUdUO1FBQzlCLElBQUksQ0FBQ1UscUJBQXFCLEdBQUcsQ0FBQ1I7UUFDOUIsSUFBSSxDQUFDUyxpQkFBaUIsR0FBRyxDQUFDVjtRQUMxQixJQUFJLENBQUNXLGNBQWMsR0FBRzF5RztRQUN0QixJQUFJLENBQUMyeUcsa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsRUFBRTtRQUN2QmQsc0JBQXNCZSxnQkFBZ0IsQ0FBQyxDQUFDQyxPQUFPbmxGO1lBQzdDLElBQUksQ0FBQ29sRixjQUFjLENBQUM7Z0JBQ2xCRDtnQkFDQW5sRjtZQUNGO1FBQ0Y7UUFDQW1rRixzQkFBc0JrQixtQkFBbUIsQ0FBQyxDQUFDdjVCLFFBQVF3NUI7WUFDakQsSUFBSSxDQUFDQyxXQUFXLENBQUM7Z0JBQ2Z6NUI7Z0JBQ0F3NUI7WUFDRjtRQUNGO1FBQ0FuQixzQkFBc0JxQiwwQkFBMEIsQ0FBQ3hsRixDQUFBQTtZQUMvQyxJQUFJLENBQUNvbEYsY0FBYyxDQUFDO2dCQUNsQnBsRjtZQUNGO1FBQ0Y7UUFDQW1rRixzQkFBc0JzQiwwQkFBMEIsQ0FBQztZQUMvQyxJQUFJLENBQUNDLGtCQUFrQjtRQUN6QjtRQUNBdkIsc0JBQXNCd0IsY0FBYztJQUN0QztJQUNBUCxlQUFlLEVBQ2JELEtBQUssRUFDTG5sRixLQUFLLEVBQ04sRUFBRTtRQUNELE1BQU1qcEIsU0FBU2lwQixpQkFBaUJwcEIsY0FBY29wQixNQUFNbGtCLFVBQVUsS0FBS2trQixNQUFNanBCLE1BQU0sQ0FBQytFLFVBQVUsR0FBR2trQixNQUFNanBCLE1BQU0sR0FBRyxJQUFJSCxXQUFXb3BCLE9BQU9qcEIsTUFBTTtRQUN4SSxJQUFJb3VHLFVBQVV2dkcsV0FBVztZQUN2QixJQUFJLElBQUksQ0FBQ292RyxrQkFBa0IsRUFBRTtnQkFDM0IsSUFBSSxDQUFDQSxrQkFBa0IsQ0FBQ1ksUUFBUSxDQUFDN3VHO1lBQ25DLE9BQU87Z0JBQ0wsSUFBSSxDQUFDMHRHLGFBQWEsQ0FBQ25uRyxJQUFJLENBQUN2RztZQUMxQjtRQUNGLE9BQU87WUFDTCxNQUFNNlYsUUFBUSxJQUFJLENBQUNxNEYsYUFBYSxDQUFDaDlGLElBQUksQ0FBQyxTQUFVNDlGLFdBQVc7Z0JBQ3pELElBQUlBLFlBQVlDLE1BQU0sS0FBS1gsT0FBTztvQkFDaEMsT0FBTztnQkFDVDtnQkFDQVUsWUFBWUQsUUFBUSxDQUFDN3VHO2dCQUNyQixPQUFPO1lBQ1Q7WUFDQSs5QixPQUFPbG9CLE9BQU87UUFDaEI7SUFDRjtJQUNBLElBQUltNUYseUJBQXlCO1FBQzNCLE9BQU8sSUFBSSxDQUFDZixrQkFBa0IsRUFBRWdCLFdBQVc7SUFDN0M7SUFDQVQsWUFBWXRsRCxHQUFHLEVBQUU7UUFDZixJQUFJQSxJQUFJcWxELEtBQUssS0FBSzF2RyxXQUFXO1lBQzNCLElBQUksQ0FBQ3F2RyxhQUFhLENBQUMsRUFBRSxFQUFFZ0IsYUFBYTtnQkFDbENuNkIsUUFBUTdyQixJQUFJNnJCLE1BQU07WUFDcEI7UUFDRixPQUFPO1lBQ0wsSUFBSSxDQUFDazVCLGtCQUFrQixFQUFFaUIsYUFBYTtnQkFDcENuNkIsUUFBUTdyQixJQUFJNnJCLE1BQU07Z0JBQ2xCdzVCLE9BQU9ybEQsSUFBSXFsRCxLQUFLO1lBQ2xCO1FBQ0Y7SUFDRjtJQUNBSSxxQkFBcUI7UUFDbkIsSUFBSSxDQUFDVixrQkFBa0IsRUFBRVQ7UUFDekIsSUFBSSxDQUFDRyxnQkFBZ0IsR0FBRztJQUMxQjtJQUNBd0IsbUJBQW1CQyxNQUFNLEVBQUU7UUFDekIsTUFBTW52RyxJQUFJLElBQUksQ0FBQ2l1RyxhQUFhLENBQUM1bkcsT0FBTyxDQUFDOG9HO1FBQ3JDLElBQUludkcsS0FBSyxHQUFHO1lBQ1YsSUFBSSxDQUFDaXVHLGFBQWEsQ0FBQ3RyRCxNQUFNLENBQUMzaUQsR0FBRztRQUMvQjtJQUNGO0lBQ0FvdkcsZ0JBQWdCO1FBQ2R0eEUsT0FBTyxDQUFDLElBQUksQ0FBQ2t3RSxrQkFBa0IsRUFBRTtRQUNqQyxNQUFNcUIsZUFBZSxJQUFJLENBQUM1QixhQUFhO1FBQ3ZDLElBQUksQ0FBQ0EsYUFBYSxHQUFHO1FBQ3JCLE9BQU8sSUFBSTZCLDZCQUE2QixJQUFJLEVBQUVELGNBQWMsSUFBSSxDQUFDM0IsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDQywyQkFBMkI7SUFDckg7SUFDQTRCLGVBQWVwQixLQUFLLEVBQUV0cEYsR0FBRyxFQUFFO1FBQ3pCLElBQUlBLE9BQU8sSUFBSSxDQUFDa3FGLHNCQUFzQixFQUFFO1lBQ3RDLE9BQU87UUFDVDtRQUNBLE1BQU1JLFNBQVMsSUFBSUssa0NBQWtDLElBQUksRUFBRXJCLE9BQU90cEY7UUFDbEUsSUFBSSxDQUFDK29GLHNCQUFzQixDQUFDNkIsZ0JBQWdCLENBQUN0QixPQUFPdHBGO1FBQ3BELElBQUksQ0FBQ29wRixhQUFhLENBQUMzbkcsSUFBSSxDQUFDNm9HO1FBQ3hCLE9BQU9BO0lBQ1Q7SUFDQU8sa0JBQWtCbmxFLE1BQU0sRUFBRTtRQUN4QixJQUFJLENBQUN5akUsa0JBQWtCLEVBQUVoekMsT0FBT3p3QjtRQUNoQyxLQUFLLE1BQU00a0UsVUFBVSxJQUFJLENBQUNsQixhQUFhLENBQUNyd0csS0FBSyxDQUFDLEdBQUk7WUFDaER1eEcsT0FBT24wQyxNQUFNLENBQUN6d0I7UUFDaEI7UUFDQSxJQUFJLENBQUNxakUsc0JBQXNCLENBQUN0akUsS0FBSztJQUNuQztBQUNGO0FBQ0EsTUFBTWdsRTtJQUNKN3dHLFlBQVkrOEUsTUFBTSxFQUFFNnpCLFlBQVksRUFBRTlCLGtCQUFrQixLQUFLLEVBQUVDLDZCQUE2QixJQUFJLENBQUU7UUFDNUYsSUFBSSxDQUFDbUMsT0FBTyxHQUFHbjBCO1FBQ2YsSUFBSSxDQUFDbzBCLEtBQUssR0FBR3JDLG1CQUFtQjtRQUNoQyxJQUFJLENBQUNzQyxTQUFTLEdBQUduK0QsVUFBVTg3RCw4QkFBOEJBLDZCQUE2QjtRQUN0RixJQUFJLENBQUNDLGFBQWEsR0FBRzRCLGdCQUFnQixFQUFFO1FBQ3ZDLElBQUksQ0FBQ0wsT0FBTyxHQUFHO1FBQ2YsS0FBSyxNQUFNaG1GLFNBQVMsSUFBSSxDQUFDeWtGLGFBQWEsQ0FBRTtZQUN0QyxJQUFJLENBQUN1QixPQUFPLElBQUlobUYsTUFBTWxrQixVQUFVO1FBQ2xDO1FBQ0EsSUFBSSxDQUFDZ3JHLFNBQVMsR0FBRyxFQUFFO1FBQ25CLElBQUksQ0FBQ0MsYUFBYSxHQUFHN3FHLFFBQVFRLE9BQU87UUFDcEM4MUUsT0FBT3d5QixrQkFBa0IsR0FBRyxJQUFJO1FBQ2hDLElBQUksQ0FBQ2lCLFVBQVUsR0FBRztJQUNwQjtJQUNBTCxTQUFTNWxGLEtBQUssRUFBRTtRQUNkLElBQUksSUFBSSxDQUFDNG1GLEtBQUssRUFBRTtZQUNkO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQ0UsU0FBUyxDQUFDejBHLE1BQU0sR0FBRyxHQUFHO1lBQzdCLE1BQU0yMEcsb0JBQW9CLElBQUksQ0FBQ0YsU0FBUyxDQUFDN2tGLEtBQUs7WUFDOUMra0Ysa0JBQWtCdHFHLE9BQU8sQ0FBQztnQkFDeEJwSixPQUFPMHNCO2dCQUNQem9CLE1BQU07WUFDUjtRQUNGLE9BQU87WUFDTCxJQUFJLENBQUNrdEcsYUFBYSxDQUFDbm5HLElBQUksQ0FBQzBpQjtRQUMxQjtRQUNBLElBQUksQ0FBQ2dtRixPQUFPLElBQUlobUYsTUFBTWxrQixVQUFVO0lBQ2xDO0lBQ0EsSUFBSW1yRyxlQUFlO1FBQ2pCLE9BQU8sSUFBSSxDQUFDRixhQUFhO0lBQzNCO0lBQ0EsSUFBSXArRCxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUNrK0QsU0FBUztJQUN2QjtJQUNBLElBQUlLLG1CQUFtQjtRQUNyQixPQUFPLElBQUksQ0FBQ1AsT0FBTyxDQUFDN0IsaUJBQWlCO0lBQ3ZDO0lBQ0EsSUFBSXFDLHVCQUF1QjtRQUN6QixPQUFPLElBQUksQ0FBQ1IsT0FBTyxDQUFDOUIscUJBQXFCO0lBQzNDO0lBQ0EsSUFBSXVDLGdCQUFnQjtRQUNsQixPQUFPLElBQUksQ0FBQ1QsT0FBTyxDQUFDNUIsY0FBYztJQUNwQztJQUNBLE1BQU14bUcsT0FBTztRQUNYLElBQUksSUFBSSxDQUFDa21HLGFBQWEsQ0FBQ3B5RyxNQUFNLEdBQUcsR0FBRztZQUNqQyxNQUFNMnRCLFFBQVEsSUFBSSxDQUFDeWtGLGFBQWEsQ0FBQ3hpRixLQUFLO1lBQ3RDLE9BQU87Z0JBQ0wzdUIsT0FBTzBzQjtnQkFDUHpvQixNQUFNO1lBQ1I7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDcXZHLEtBQUssRUFBRTtZQUNkLE9BQU87Z0JBQ0x0ekcsT0FBT3NDO2dCQUNQMkIsTUFBTTtZQUNSO1FBQ0Y7UUFDQSxNQUFNeXZHLG9CQUFvQjlxRyxRQUFRK1EsYUFBYTtRQUMvQyxJQUFJLENBQUM2NUYsU0FBUyxDQUFDeHBHLElBQUksQ0FBQzBwRztRQUNwQixPQUFPQSxrQkFBa0JycUcsT0FBTztJQUNsQztJQUNBcTFELE9BQU96d0IsTUFBTSxFQUFFO1FBQ2IsSUFBSSxDQUFDcWxFLEtBQUssR0FBRztRQUNiLEtBQUssTUFBTUkscUJBQXFCLElBQUksQ0FBQ0YsU0FBUyxDQUFFO1lBQzlDRSxrQkFBa0J0cUcsT0FBTyxDQUFDO2dCQUN4QnBKLE9BQU9zQztnQkFDUDJCLE1BQU07WUFDUjtRQUNGO1FBQ0EsSUFBSSxDQUFDdXZHLFNBQVMsQ0FBQ3owRyxNQUFNLEdBQUc7SUFDMUI7SUFDQWt5RyxrQkFBa0I7UUFDaEIsSUFBSSxJQUFJLENBQUNxQyxLQUFLLEVBQUU7WUFDZDtRQUNGO1FBQ0EsSUFBSSxDQUFDQSxLQUFLLEdBQUc7SUFDZjtBQUNGO0FBQ0EsTUFBTUo7SUFDSi93RyxZQUFZKzhFLE1BQU0sRUFBRTJ5QixLQUFLLEVBQUV0cEYsR0FBRyxDQUFFO1FBQzlCLElBQUksQ0FBQzhxRixPQUFPLEdBQUduMEI7UUFDZixJQUFJLENBQUNzekIsTUFBTSxHQUFHWDtRQUNkLElBQUksQ0FBQ2tDLElBQUksR0FBR3hyRjtRQUNaLElBQUksQ0FBQ3lyRixZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDUixTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUNGLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ1gsVUFBVSxHQUFHO0lBQ3BCO0lBQ0FMLFNBQVM1bEYsS0FBSyxFQUFFO1FBQ2QsSUFBSSxJQUFJLENBQUM0bUYsS0FBSyxFQUFFO1lBQ2Q7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDRSxTQUFTLENBQUN6MEcsTUFBTSxLQUFLLEdBQUc7WUFDL0IsSUFBSSxDQUFDaTFHLFlBQVksR0FBR3RuRjtRQUN0QixPQUFPO1lBQ0wsTUFBTXVuRixxQkFBcUIsSUFBSSxDQUFDVCxTQUFTLENBQUM3a0YsS0FBSztZQUMvQ3NsRixtQkFBbUI3cUcsT0FBTyxDQUFDO2dCQUN6QnBKLE9BQU8wc0I7Z0JBQ1B6b0IsTUFBTTtZQUNSO1lBQ0EsS0FBSyxNQUFNeXZHLHFCQUFxQixJQUFJLENBQUNGLFNBQVMsQ0FBRTtnQkFDOUNFLGtCQUFrQnRxRyxPQUFPLENBQUM7b0JBQ3hCcEosT0FBT3NDO29CQUNQMkIsTUFBTTtnQkFDUjtZQUNGO1lBQ0EsSUFBSSxDQUFDdXZHLFNBQVMsQ0FBQ3owRyxNQUFNLEdBQUc7UUFDMUI7UUFDQSxJQUFJLENBQUN1MEcsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDRCxPQUFPLENBQUNULGtCQUFrQixDQUFDLElBQUk7SUFDdEM7SUFDQSxJQUFJaUIsdUJBQXVCO1FBQ3pCLE9BQU87SUFDVDtJQUNBLE1BQU01b0csT0FBTztRQUNYLElBQUksSUFBSSxDQUFDK29HLFlBQVksRUFBRTtZQUNyQixNQUFNdG5GLFFBQVEsSUFBSSxDQUFDc25GLFlBQVk7WUFDL0IsSUFBSSxDQUFDQSxZQUFZLEdBQUc7WUFDcEIsT0FBTztnQkFDTGgwRyxPQUFPMHNCO2dCQUNQem9CLE1BQU07WUFDUjtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUNxdkcsS0FBSyxFQUFFO1lBQ2QsT0FBTztnQkFDTHR6RyxPQUFPc0M7Z0JBQ1AyQixNQUFNO1lBQ1I7UUFDRjtRQUNBLE1BQU15dkcsb0JBQW9COXFHLFFBQVErUSxhQUFhO1FBQy9DLElBQUksQ0FBQzY1RixTQUFTLENBQUN4cEcsSUFBSSxDQUFDMHBHO1FBQ3BCLE9BQU9BLGtCQUFrQnJxRyxPQUFPO0lBQ2xDO0lBQ0FxMUQsT0FBT3p3QixNQUFNLEVBQUU7UUFDYixJQUFJLENBQUNxbEUsS0FBSyxHQUFHO1FBQ2IsS0FBSyxNQUFNSSxxQkFBcUIsSUFBSSxDQUFDRixTQUFTLENBQUU7WUFDOUNFLGtCQUFrQnRxRyxPQUFPLENBQUM7Z0JBQ3hCcEosT0FBT3NDO2dCQUNQMkIsTUFBTTtZQUNSO1FBQ0Y7UUFDQSxJQUFJLENBQUN1dkcsU0FBUyxDQUFDejBHLE1BQU0sR0FBRztRQUN4QixJQUFJLENBQUNzMEcsT0FBTyxDQUFDVCxrQkFBa0IsQ0FBQyxJQUFJO0lBQ3RDO0FBQ0Y7RUFFQyx1Q0FBdUM7QUFJeEMsU0FBU3NCLHdDQUF3Q0Msa0JBQWtCO0lBQ2pFLElBQUlDLHFCQUFxQjtJQUN6QixJQUFJdGhHLE1BQU11aEcsY0FBYyxlQUFlLEtBQUs1dEcsSUFBSSxDQUFDMHRHO0lBQ2pELElBQUlyaEcsS0FBSztRQUNQQSxNQUFNQSxHQUFHLENBQUMsRUFBRTtRQUNaLElBQUl1aUMsV0FBV2kvRCxlQUFleGhHO1FBQzlCdWlDLFdBQVdySyxTQUFTcUs7UUFDcEJBLFdBQVdrL0QsY0FBY2wvRDtRQUN6QkEsV0FBV20vRCxjQUFjbi9EO1FBQ3pCLE9BQU9vL0QsY0FBY3AvRDtJQUN2QjtJQUNBdmlDLE1BQU00aEcsZ0JBQWdCUDtJQUN0QixJQUFJcmhHLEtBQUs7UUFDUCxNQUFNdWlDLFdBQVdtL0QsY0FBYzFoRztRQUMvQixPQUFPMmhHLGNBQWNwL0Q7SUFDdkI7SUFDQXZpQyxNQUFNdWhHLGNBQWMsWUFBWSxLQUFLNXRHLElBQUksQ0FBQzB0RztJQUMxQyxJQUFJcmhHLEtBQUs7UUFDUEEsTUFBTUEsR0FBRyxDQUFDLEVBQUU7UUFDWixJQUFJdWlDLFdBQVdpL0QsZUFBZXhoRztRQUM5QnVpQyxXQUFXbS9ELGNBQWNuL0Q7UUFDekIsT0FBT28vRCxjQUFjcC9EO0lBQ3ZCO0lBQ0EsU0FBU2cvRCxjQUFjTSxnQkFBZ0IsRUFBRUMsS0FBSztRQUM1QyxPQUFPLElBQUkzOUQsT0FBTyxnQkFBZ0IwOUQsbUJBQW1CLGNBQWMsTUFBTSxxQkFBcUIsTUFBTSw0QkFBNEIsS0FBS0M7SUFDdkk7SUFDQSxTQUFTQyxXQUFXMXFFLFFBQVEsRUFBRW5xQyxLQUFLO1FBQ2pDLElBQUltcUMsVUFBVTtZQUNaLElBQUksQ0FBQyxpQkFBaUJ0bEMsSUFBSSxDQUFDN0UsUUFBUTtnQkFDakMsT0FBT0E7WUFDVDtZQUNBLElBQUk7Z0JBQ0YsTUFBTW9xQyxVQUFVLElBQUlDLFlBQVlGLFVBQVU7b0JBQ3hDRyxPQUFPO2dCQUNUO2dCQUNBLE1BQU03bUMsU0FBU2lnQyxjQUFjMWpDO2dCQUM3QkEsUUFBUW9xQyxRQUFRSSxNQUFNLENBQUMvbUM7Z0JBQ3ZCMndHLHFCQUFxQjtZQUN2QixFQUFFLE9BQU0sQ0FBQztRQUNYO1FBQ0EsT0FBT3AwRztJQUNUO0lBQ0EsU0FBU3kwRyxjQUFjejBHLEtBQUs7UUFDMUIsSUFBSW8wRyxzQkFBc0IsY0FBY3Z2RyxJQUFJLENBQUM3RSxRQUFRO1lBQ25EQSxRQUFRNjBHLFdBQVcsU0FBUzcwRztZQUM1QixJQUFJbzBHLG9CQUFvQjtnQkFDdEJwMEcsUUFBUTYwRyxXQUFXLGNBQWM3MEc7WUFDbkM7UUFDRjtRQUNBLE9BQU9BO0lBQ1Q7SUFDQSxTQUFTMDBHLGdCQUFnQkkscUJBQXFCO1FBQzVDLE1BQU01OUQsVUFBVSxFQUFFO1FBQ2xCLElBQUlwb0I7UUFDSixNQUFNaW1GLE9BQU9WLGNBQWMsbUNBQW1DO1FBQzlELE1BQU8sQ0FBQ3ZsRixRQUFRaW1GLEtBQUt0dUcsSUFBSSxDQUFDcXVHLHNCQUFxQixNQUFPLEtBQU07WUFDMUQsSUFBSSxHQUFHbnZHLEdBQUdxdkcsTUFBTUMsS0FBSyxHQUFHbm1GO1lBQ3hCbnBCLElBQUk4RSxTQUFTOUUsR0FBRztZQUNoQixJQUFJQSxLQUFLdXhDLFNBQVM7Z0JBQ2hCLElBQUl2eEMsTUFBTSxHQUFHO29CQUNYO2dCQUNGO2dCQUNBO1lBQ0Y7WUFDQXV4QyxPQUFPLENBQUN2eEMsRUFBRSxHQUFHO2dCQUFDcXZHO2dCQUFNQzthQUFLO1FBQzNCO1FBQ0EsTUFBTUMsUUFBUSxFQUFFO1FBQ2hCLElBQUssSUFBSXZ2RyxJQUFJLEdBQUdBLElBQUl1eEMsUUFBUW40QyxNQUFNLEVBQUUsRUFBRTRHLEVBQUc7WUFDdkMsSUFBSSxDQUFFQSxDQUFBQSxLQUFLdXhDLE9BQU0sR0FBSTtnQkFDbkI7WUFDRjtZQUNBLElBQUksQ0FBQzg5RCxNQUFNQyxLQUFLLEdBQUcvOUQsT0FBTyxDQUFDdnhDLEVBQUU7WUFDN0JzdkcsT0FBT1gsZUFBZVc7WUFDdEIsSUFBSUQsTUFBTTtnQkFDUkMsT0FBT2pxRSxTQUFTaXFFO2dCQUNoQixJQUFJdHZHLE1BQU0sR0FBRztvQkFDWHN2RyxPQUFPVixjQUFjVTtnQkFDdkI7WUFDRjtZQUNBQyxNQUFNbHJHLElBQUksQ0FBQ2lyRztRQUNiO1FBQ0EsT0FBT0MsTUFBTTF6RyxJQUFJLENBQUM7SUFDcEI7SUFDQSxTQUFTOHlHLGVBQWV0MEcsS0FBSztRQUMzQixJQUFJQSxNQUFNK2hDLFVBQVUsQ0FBQyxNQUFNO1lBQ3pCLE1BQU1tekUsUUFBUWwxRyxNQUFNc0IsS0FBSyxDQUFDLEdBQUdLLEtBQUssQ0FBQztZQUNuQyxJQUFLLElBQUkrQixJQUFJLEdBQUdBLElBQUl3eEcsTUFBTW4yRyxNQUFNLEVBQUUsRUFBRTJFLEVBQUc7Z0JBQ3JDLE1BQU15eEcsWUFBWUQsS0FBSyxDQUFDeHhHLEVBQUUsQ0FBQ3FHLE9BQU8sQ0FBQztnQkFDbkMsSUFBSW9yRyxjQUFjLENBQUMsR0FBRztvQkFDcEJELEtBQUssQ0FBQ3h4RyxFQUFFLEdBQUd3eEcsS0FBSyxDQUFDeHhHLEVBQUUsQ0FBQ3BDLEtBQUssQ0FBQyxHQUFHNnpHO29CQUM3QkQsTUFBTW4yRyxNQUFNLEdBQUcyRSxJQUFJO2dCQUNyQjtnQkFDQXd4RyxLQUFLLENBQUN4eEcsRUFBRSxHQUFHd3hHLEtBQUssQ0FBQ3h4RyxFQUFFLENBQUMrbUMsVUFBVSxDQUFDLFVBQVU7WUFDM0M7WUFDQXpxQyxRQUFRazFHLE1BQU0xekcsSUFBSSxDQUFDO1FBQ3JCO1FBQ0EsT0FBT3hCO0lBQ1Q7SUFDQSxTQUFTdTBHLGNBQWNhLFFBQVE7UUFDN0IsTUFBTUMsY0FBY0QsU0FBU3JyRyxPQUFPLENBQUM7UUFDckMsSUFBSXNyRyxnQkFBZ0IsQ0FBQyxHQUFHO1lBQ3RCLE9BQU9EO1FBQ1Q7UUFDQSxNQUFNanJFLFdBQVdpckUsU0FBUzl6RyxLQUFLLENBQUMsR0FBRyt6RztRQUNuQyxNQUFNQyxZQUFZRixTQUFTOXpHLEtBQUssQ0FBQyt6RyxjQUFjO1FBQy9DLE1BQU1yMUcsUUFBUXMxRyxVQUFVL3pHLE9BQU8sQ0FBQyxXQUFXO1FBQzNDLE9BQU9zekcsV0FBVzFxRSxVQUFVbnFDO0lBQzlCO0lBQ0EsU0FBU3cwRyxjQUFjeDBHLEtBQUs7UUFDMUIsSUFBSSxDQUFDQSxNQUFNK2hDLFVBQVUsQ0FBQyxTQUFTLHVCQUF1Qmw5QixJQUFJLENBQUM3RSxRQUFRO1lBQ2pFLE9BQU9BO1FBQ1Q7UUFDQSxPQUFPQSxNQUFNeXFDLFVBQVUsQ0FBQyxrREFBa0QsU0FBVXlNLE9BQU8sRUFBRXErRCxPQUFPLEVBQUVwckUsUUFBUSxFQUFFNWUsSUFBSTtZQUNsSCxJQUFJNGUsYUFBYSxPQUFPQSxhQUFhLEtBQUs7Z0JBQ3hDNWUsT0FBT0EsS0FBS2tmLFVBQVUsQ0FBQyxLQUFLO2dCQUM1QmxmLE9BQU9BLEtBQUtrZixVQUFVLENBQUMsc0JBQXNCLFNBQVUzYixLQUFLLEVBQUVuckIsR0FBRztvQkFDL0QsT0FBT3pDLE9BQU80bUIsWUFBWSxDQUFDcmQsU0FBUzlHLEtBQUs7Z0JBQzNDO2dCQUNBLE9BQU9reEcsV0FBV1UsU0FBU2hxRjtZQUM3QjtZQUNBLElBQUk7Z0JBQ0ZBLE9BQU9raUIsS0FBS2xpQjtZQUNkLEVBQUUsT0FBTSxDQUFDO1lBQ1QsT0FBT3NwRixXQUFXVSxTQUFTaHFGO1FBQzdCO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7RUFFQyxpQ0FBaUM7QUFLbEMsU0FBU2lxRixjQUFjQyxNQUFNLEVBQUVDLFdBQVc7SUFDeEMsTUFBTUMsVUFBVSxJQUFJQztJQUNwQixJQUFJLENBQUNILFVBQVUsQ0FBQ0MsZUFBZSxPQUFPQSxnQkFBZ0IsVUFBVTtRQUM5RCxPQUFPQztJQUNUO0lBQ0EsSUFBSyxNQUFNeHJHLE9BQU91ckcsWUFBYTtRQUM3QixNQUFNLytGLE1BQU0rK0YsV0FBVyxDQUFDdnJHLElBQUk7UUFDNUIsSUFBSXdNLFFBQVFyVSxXQUFXO1lBQ3JCcXpHLFFBQVE5OEYsTUFBTSxDQUFDMU8sS0FBS3dNO1FBQ3RCO0lBQ0Y7SUFDQSxPQUFPZy9GO0FBQ1Q7QUFDQSxTQUFTRSxrQkFBa0JuekYsR0FBRztJQUM1QixPQUFPRixJQUFJQyxLQUFLLENBQUNDLE1BQU1vaEQsVUFBVTtBQUNuQztBQUNBLFNBQVNneUMsaUNBQWlDLEVBQ3hDQyxlQUFlLEVBQ2ZOLE1BQU0sRUFDTk8sY0FBYyxFQUNkbEYsWUFBWSxFQUNiO0lBQ0MsTUFBTW1GLGVBQWU7UUFDbkJDLG9CQUFvQjtRQUNwQkMsaUJBQWlCN3pHO0lBQ25CO0lBQ0EsTUFBTXZELFNBQVMwTCxTQUFTc3JHLGdCQUFnQi8wRyxHQUFHLENBQUMsbUJBQW1CO0lBQy9ELElBQUksQ0FBQzJRLE9BQU9zdkIsU0FBUyxDQUFDbGlDLFNBQVM7UUFDN0IsT0FBT2szRztJQUNUO0lBQ0FBLGFBQWFFLGVBQWUsR0FBR3AzRztJQUMvQixJQUFJQSxVQUFVLElBQUlpM0csZ0JBQWdCO1FBQ2hDLE9BQU9DO0lBQ1Q7SUFDQSxJQUFJbkYsZ0JBQWdCLENBQUMyRSxRQUFRO1FBQzNCLE9BQU9RO0lBQ1Q7SUFDQSxJQUFJRixnQkFBZ0IvMEcsR0FBRyxDQUFDLHFCQUFxQixTQUFTO1FBQ3BELE9BQU9pMUc7SUFDVDtJQUNBLE1BQU1HLGtCQUFrQkwsZ0JBQWdCLzBHLEdBQUcsQ0FBQyx1QkFBdUI7SUFDbkUsSUFBSW8xRyxvQkFBb0IsWUFBWTtRQUNsQyxPQUFPSDtJQUNUO0lBQ0FBLGFBQWFDLGtCQUFrQixHQUFHO0lBQ2xDLE9BQU9EO0FBQ1Q7QUFDQSxTQUFTSSwwQkFBMEJOLGVBQWU7SUFDaEQsTUFBTTVCLHFCQUFxQjRCLGdCQUFnQi8wRyxHQUFHLENBQUM7SUFDL0MsSUFBSW16RyxvQkFBb0I7UUFDdEIsSUFBSTkrRCxXQUFXNitELHdDQUF3Q0M7UUFDdkQsSUFBSTkrRCxTQUFTN2dDLFFBQVEsQ0FBQyxNQUFNO1lBQzFCLElBQUk7Z0JBQ0Y2Z0MsV0FBV3hLLG1CQUFtQndLO1lBQ2hDLEVBQUUsT0FBTSxDQUFDO1FBQ1g7UUFDQSxJQUFJRCxVQUFVQyxXQUFXO1lBQ3ZCLE9BQU9BO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNpaEUsb0JBQW9CcnpFLE1BQU0sRUFBRXZnQixHQUFHO0lBQ3RDLE9BQU8sSUFBSXNnQixrQkFBa0IsQ0FBQyw0QkFBNEIsRUFBRUMsT0FBTyx3QkFBd0IsRUFBRXZnQixJQUFJLEVBQUUsQ0FBQyxFQUFFdWdCLFFBQVFBLFdBQVcsT0FBT0EsV0FBVyxLQUFLdmdCLElBQUlxZixVQUFVLENBQUM7QUFDaks7QUFDQSxTQUFTdzBFLHVCQUF1QnR6RSxNQUFNO0lBQ3BDLE9BQU9BLFdBQVcsT0FBT0EsV0FBVztBQUN0QztFQUVDLGdDQUFnQztBQWFqQyxTQUFTdXpFLG1CQUFtQmIsT0FBTyxFQUFFYyxlQUFlLEVBQUU3dUQsZUFBZTtJQUNuRSxPQUFPO1FBQ0x4aUQsUUFBUTtRQUNSdXdHO1FBQ0E3bkUsUUFBUThaLGdCQUFnQjlaLE1BQU07UUFDOUI3bkIsTUFBTTtRQUNOeXdGLGFBQWFELGtCQUFrQixZQUFZO1FBQzNDRSxVQUFVO0lBQ1o7QUFDRjtBQUNBLFNBQVNDLGVBQWVqZ0csR0FBRztJQUN6QixJQUFJQSxlQUFlclQsWUFBWTtRQUM3QixPQUFPcVQsSUFBSWxULE1BQU07SUFDbkI7SUFDQSxJQUFJa1QsZUFBZXRPLGFBQWE7UUFDOUIsT0FBT3NPO0lBQ1Q7SUFDQTJxQixLQUFLLENBQUMseUNBQXlDLEVBQUUzcUIsSUFBSSxDQUFDO0lBQ3RELE9BQU8sSUFBSXJULFdBQVdxVCxLQUFLbFQsTUFBTTtBQUNuQztBQUNBLE1BQU1vekc7SUFFSjEwRyxZQUFZSyxNQUFNLENBQUU7YUFEcEJzMEcsa0JBQWtCO1FBRWhCLElBQUksQ0FBQ3QwRyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDaXpHLE1BQU0sR0FBRyxZQUFZNXdHLElBQUksQ0FBQ3JDLE9BQU9rZ0IsR0FBRztRQUN6QyxJQUFJLENBQUNpekYsT0FBTyxHQUFHSCxjQUFjLElBQUksQ0FBQ0MsTUFBTSxFQUFFanpHLE9BQU9rekcsV0FBVztRQUM1RCxJQUFJLENBQUNoRSxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNxRixvQkFBb0IsR0FBRyxFQUFFO0lBQ2hDO0lBQ0EsSUFBSXRFLHlCQUF5QjtRQUMzQixPQUFPLElBQUksQ0FBQ2Ysa0JBQWtCLEVBQUVnQixXQUFXO0lBQzdDO0lBQ0FJLGdCQUFnQjtRQUNkdHhFLE9BQU8sQ0FBQyxJQUFJLENBQUNrd0Usa0JBQWtCLEVBQUU7UUFDakMsSUFBSSxDQUFDQSxrQkFBa0IsR0FBRyxJQUFJc0YscUJBQXFCLElBQUk7UUFDdkQsT0FBTyxJQUFJLENBQUN0RixrQkFBa0I7SUFDaEM7SUFDQXVCLGVBQWVwQixLQUFLLEVBQUV0cEYsR0FBRyxFQUFFO1FBQ3pCLElBQUlBLE9BQU8sSUFBSSxDQUFDa3FGLHNCQUFzQixFQUFFO1lBQ3RDLE9BQU87UUFDVDtRQUNBLE1BQU1JLFNBQVMsSUFBSW9FLDBCQUEwQixJQUFJLEVBQUVwRixPQUFPdHBGO1FBQzFELElBQUksQ0FBQ3d1RixvQkFBb0IsQ0FBQy9zRyxJQUFJLENBQUM2b0c7UUFDL0IsT0FBT0E7SUFDVDtJQUNBTyxrQkFBa0JubEUsTUFBTSxFQUFFO1FBQ3hCLElBQUksQ0FBQ3lqRSxrQkFBa0IsRUFBRWh6QyxPQUFPendCO1FBQ2hDLEtBQUssTUFBTTRrRSxVQUFVLElBQUksQ0FBQ2tFLG9CQUFvQixDQUFDejFHLEtBQUssQ0FBQyxHQUFJO1lBQ3ZEdXhHLE9BQU9uMEMsTUFBTSxDQUFDendCO1FBQ2hCO0lBQ0Y7QUFDRjtBQUNBLE1BQU0rb0U7SUFDSjcwRyxZQUFZKzhFLE1BQU0sQ0FBRTtRQUNsQixJQUFJLENBQUNtMEIsT0FBTyxHQUFHbjBCO1FBQ2YsSUFBSSxDQUFDZzRCLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ3hFLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ2EsU0FBUyxHQUFHO1FBQ2pCLE1BQU0vd0csU0FBUzA4RSxPQUFPMThFLE1BQU07UUFDNUIsSUFBSSxDQUFDMjBHLGdCQUFnQixHQUFHMzBHLE9BQU9pMEcsZUFBZSxJQUFJO1FBQ2xELElBQUksQ0FBQ2hGLGNBQWMsR0FBR2p2RyxPQUFPekQsTUFBTTtRQUNuQyxJQUFJLENBQUNxNEcsa0JBQWtCLEdBQUd4dUcsUUFBUStRLGFBQWE7UUFDL0MsSUFBSSxDQUFDMDlGLGFBQWEsR0FBRzcwRyxPQUFPc3VHLFlBQVksSUFBSTtRQUM1QyxJQUFJLENBQUN3RyxlQUFlLEdBQUc5MEcsT0FBT3d6RyxjQUFjO1FBQzVDLElBQUksQ0FBQyxJQUFJLENBQUNzQixlQUFlLElBQUksQ0FBQyxJQUFJLENBQUNELGFBQWEsRUFBRTtZQUNoRCxJQUFJLENBQUNBLGFBQWEsR0FBRztRQUN2QjtRQUNBLElBQUksQ0FBQ0UsZ0JBQWdCLEdBQUcsSUFBSTFwRTtRQUM1QixJQUFJLENBQUMwakUscUJBQXFCLEdBQUcsQ0FBQy91RyxPQUFPdXVHLGFBQWE7UUFDbEQsSUFBSSxDQUFDUyxpQkFBaUIsR0FBRyxDQUFDaHZHLE9BQU9zdUcsWUFBWTtRQUM3QyxNQUFNNkUsVUFBVSxJQUFJQyxRQUFRMTJCLE9BQU95MkIsT0FBTztRQUMxQyxNQUFNanpGLE1BQU1sZ0IsT0FBT2tnQixHQUFHO1FBQ3RCMnZCLE1BQU0zdkIsS0FBSzh6RixtQkFBbUJiLFNBQVMsSUFBSSxDQUFDd0IsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDSSxnQkFBZ0IsR0FBRzd6RCxJQUFJLENBQUN0UixDQUFBQTtZQUN6RjhzQyxPQUFPNDNCLGVBQWUsR0FBR2pCLGtCQUFrQnpqRSxTQUFTMXZCLEdBQUc7WUFDdkQsSUFBSSxDQUFDNnpGLHVCQUF1Qm5rRSxTQUFTblAsTUFBTSxHQUFHO2dCQUM1QyxNQUFNcXpFLG9CQUFvQmxrRSxTQUFTblAsTUFBTSxFQUFFdmdCO1lBQzdDO1lBQ0EsSUFBSSxDQUFDdzBGLE9BQU8sR0FBRzlrRSxTQUFTa0csSUFBSSxDQUFDay9ELFNBQVM7WUFDdEMsSUFBSSxDQUFDSixrQkFBa0IsQ0FBQ2h1RyxPQUFPO1lBQy9CLE1BQU0yc0csa0JBQWtCM2pFLFNBQVN1akUsT0FBTztZQUN4QyxNQUFNLEVBQ0pPLGtCQUFrQixFQUNsQkMsZUFBZSxFQUNoQixHQUFHTCxpQ0FBaUM7Z0JBQ25DQztnQkFDQU4sUUFBUXYyQixPQUFPdTJCLE1BQU07Z0JBQ3JCTyxnQkFBZ0IsSUFBSSxDQUFDc0IsZUFBZTtnQkFDcEN4RyxjQUFjLElBQUksQ0FBQ3VHLGFBQWE7WUFDbEM7WUFDQSxJQUFJLENBQUM3RixpQkFBaUIsR0FBRzBFO1lBQ3pCLElBQUksQ0FBQ3pFLGNBQWMsR0FBRzBFLG1CQUFtQixJQUFJLENBQUMxRSxjQUFjO1lBQzVELElBQUksQ0FBQzhCLFNBQVMsR0FBRzhDLDBCQUEwQk47WUFDM0MsSUFBSSxDQUFDLElBQUksQ0FBQ3hFLHFCQUFxQixJQUFJLElBQUksQ0FBQ0MsaUJBQWlCLEVBQUU7Z0JBQ3pELElBQUksQ0FBQzl5QyxNQUFNLENBQUMsSUFBSXQ3QixlQUFlO1lBQ2pDO1FBQ0YsR0FBRzQrQyxLQUFLLENBQUMsSUFBSSxDQUFDbzFCLGtCQUFrQixDQUFDanVHLE1BQU07UUFDdkMsSUFBSSxDQUFDd3BHLFVBQVUsR0FBRztJQUNwQjtJQUNBLElBQUlnQixlQUFlO1FBQ2pCLE9BQU8sSUFBSSxDQUFDeUQsa0JBQWtCLENBQUMvdEcsT0FBTztJQUN4QztJQUNBLElBQUlnc0MsV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDaytELFNBQVM7SUFDdkI7SUFDQSxJQUFJTyxnQkFBZ0I7UUFDbEIsT0FBTyxJQUFJLENBQUNyQyxjQUFjO0lBQzVCO0lBQ0EsSUFBSW1DLG1CQUFtQjtRQUNyQixPQUFPLElBQUksQ0FBQ3BDLGlCQUFpQjtJQUMvQjtJQUNBLElBQUlxQyx1QkFBdUI7UUFDekIsT0FBTyxJQUFJLENBQUN0QyxxQkFBcUI7SUFDbkM7SUFDQSxNQUFNdG1HLE9BQU87UUFDWCxNQUFNLElBQUksQ0FBQ21zRyxrQkFBa0IsQ0FBQy90RyxPQUFPO1FBQ3JDLE1BQU0sRUFDSnJKLEtBQUssRUFDTGlFLElBQUksRUFDTCxHQUFHLE1BQU0sSUFBSSxDQUFDaXpHLE9BQU8sQ0FBQ2pzRyxJQUFJO1FBQzNCLElBQUloSCxNQUFNO1lBQ1IsT0FBTztnQkFDTGpFO2dCQUNBaUU7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDeXVHLE9BQU8sSUFBSTF5RyxNQUFNd0ksVUFBVTtRQUNoQyxJQUFJLENBQUNtcUcsVUFBVSxHQUFHO1lBQ2hCbjZCLFFBQVEsSUFBSSxDQUFDazZCLE9BQU87WUFDcEJWLE9BQU8sSUFBSSxDQUFDUCxjQUFjO1FBQzVCO1FBQ0EsT0FBTztZQUNMenhHLE9BQU80MkcsZUFBZTUyRztZQUN0QmlFLE1BQU07UUFDUjtJQUNGO0lBQ0F5NkQsT0FBT3p3QixNQUFNLEVBQUU7UUFDYixJQUFJLENBQUNpcEUsT0FBTyxFQUFFeDRDLE9BQU96d0I7UUFDckIsSUFBSSxDQUFDc3BFLGdCQUFnQixDQUFDdnBFLEtBQUs7SUFDN0I7QUFDRjtBQUNBLE1BQU1pcEU7SUFDSjkwRyxZQUFZKzhFLE1BQU0sRUFBRTJ5QixLQUFLLEVBQUV0cEYsR0FBRyxDQUFFO1FBQzlCLElBQUksQ0FBQzhxRixPQUFPLEdBQUduMEI7UUFDZixJQUFJLENBQUNnNEIsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDeEUsT0FBTyxHQUFHO1FBQ2YsTUFBTWx3RyxTQUFTMDhFLE9BQU8xOEUsTUFBTTtRQUM1QixJQUFJLENBQUMyMEcsZ0JBQWdCLEdBQUczMEcsT0FBT2kwRyxlQUFlLElBQUk7UUFDbEQsSUFBSSxDQUFDZ0IsZUFBZSxHQUFHN3VHLFFBQVErUSxhQUFhO1FBQzVDLElBQUksQ0FBQzQzRixxQkFBcUIsR0FBRyxDQUFDL3VHLE9BQU91dUcsYUFBYTtRQUNsRCxJQUFJLENBQUN3RyxnQkFBZ0IsR0FBRyxJQUFJMXBFO1FBQzVCLE1BQU04bkUsVUFBVSxJQUFJQyxRQUFRMTJCLE9BQU95MkIsT0FBTztRQUMxQ0EsUUFBUTk4RixNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRWc1RixNQUFNLENBQUMsRUFBRXRwRixNQUFNLEVBQUUsQ0FBQztRQUNuRCxNQUFNN0YsTUFBTWxnQixPQUFPa2dCLEdBQUc7UUFDdEIydkIsTUFBTTN2QixLQUFLOHpGLG1CQUFtQmIsU0FBUyxJQUFJLENBQUN3QixnQkFBZ0IsRUFBRSxJQUFJLENBQUNJLGdCQUFnQixHQUFHN3pELElBQUksQ0FBQ3RSLENBQUFBO1lBQ3pGLE1BQU1zbEUsaUJBQWlCN0Isa0JBQWtCempFLFNBQVMxdkIsR0FBRztZQUNyRCxJQUFJZzFGLG1CQUFtQng0QixPQUFPNDNCLGVBQWUsRUFBRTtnQkFDN0MsTUFBTSxJQUFJNTVGLE1BQU0sQ0FBQyxnQ0FBZ0MsRUFBRXc2RixlQUFlLFlBQVksRUFBRXg0QixPQUFPNDNCLGVBQWUsQ0FBQyxFQUFFLENBQUM7WUFDNUc7WUFDQSxJQUFJLENBQUNQLHVCQUF1Qm5rRSxTQUFTblAsTUFBTSxHQUFHO2dCQUM1QyxNQUFNcXpFLG9CQUFvQmxrRSxTQUFTblAsTUFBTSxFQUFFdmdCO1lBQzdDO1lBQ0EsSUFBSSxDQUFDKzBGLGVBQWUsQ0FBQ3J1RyxPQUFPO1lBQzVCLElBQUksQ0FBQzh0RyxPQUFPLEdBQUc5a0UsU0FBU2tHLElBQUksQ0FBQ2svRCxTQUFTO1FBQ3hDLEdBQUd4MUIsS0FBSyxDQUFDLElBQUksQ0FBQ3kxQixlQUFlLENBQUN0dUcsTUFBTTtRQUNwQyxJQUFJLENBQUN3cEcsVUFBVSxHQUFHO0lBQ3BCO0lBQ0EsSUFBSWtCLHVCQUF1QjtRQUN6QixPQUFPLElBQUksQ0FBQ3RDLHFCQUFxQjtJQUNuQztJQUNBLE1BQU10bUcsT0FBTztRQUNYLE1BQU0sSUFBSSxDQUFDd3NHLGVBQWUsQ0FBQ3B1RyxPQUFPO1FBQ2xDLE1BQU0sRUFDSnJKLEtBQUssRUFDTGlFLElBQUksRUFDTCxHQUFHLE1BQU0sSUFBSSxDQUFDaXpHLE9BQU8sQ0FBQ2pzRyxJQUFJO1FBQzNCLElBQUloSCxNQUFNO1lBQ1IsT0FBTztnQkFDTGpFO2dCQUNBaUU7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDeXVHLE9BQU8sSUFBSTF5RyxNQUFNd0ksVUFBVTtRQUNoQyxJQUFJLENBQUNtcUcsVUFBVSxHQUFHO1lBQ2hCbjZCLFFBQVEsSUFBSSxDQUFDazZCLE9BQU87UUFDdEI7UUFDQSxPQUFPO1lBQ0wxeUcsT0FBTzQyRyxlQUFlNTJHO1lBQ3RCaUUsTUFBTTtRQUNSO0lBQ0Y7SUFDQXk2RCxPQUFPendCLE1BQU0sRUFBRTtRQUNiLElBQUksQ0FBQ2lwRSxPQUFPLEVBQUV4NEMsT0FBT3p3QjtRQUNyQixJQUFJLENBQUNzcEUsZ0JBQWdCLENBQUN2cEUsS0FBSztJQUM3QjtBQUNGO0VBRUMsMkJBQTJCO0FBTzVCLE1BQU0ycEUsY0FBYztBQUNwQixNQUFNQywyQkFBMkI7QUFDakMsU0FBU0MsdUJBQXVCQyxHQUFHO0lBQ2pDLE1BQU14b0csT0FBT3dvRyxJQUFJMWxFLFFBQVE7SUFDekIsSUFBSSxPQUFPOWlDLFNBQVMsVUFBVTtRQUM1QixPQUFPQTtJQUNUO0lBQ0EsT0FBT28wQixjQUFjcDBCLE1BQU03TCxNQUFNO0FBQ25DO0FBQ0EsTUFBTXMwRztJQUVKNTFHLFlBQVksRUFDVnVnQixHQUFHLEVBQ0hnekYsV0FBVyxFQUNYZSxlQUFlLEVBQ2hCLENBQUU7YUFMSEssa0JBQWtCO1FBTWhCLElBQUksQ0FBQ3AwRixHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDK3lGLE1BQU0sR0FBRyxZQUFZNXdHLElBQUksQ0FBQzZkO1FBQy9CLElBQUksQ0FBQ2l6RixPQUFPLEdBQUdILGNBQWMsSUFBSSxDQUFDQyxNQUFNLEVBQUVDO1FBQzFDLElBQUksQ0FBQ2UsZUFBZSxHQUFHQSxtQkFBbUI7UUFDMUMsSUFBSSxDQUFDdUIsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsZUFBZSxHQUFHNzJHLE9BQU8rTCxNQUFNLENBQUM7SUFDdkM7SUFDQXVsQyxRQUFRMXBDLElBQUksRUFBRTtRQUNaLE1BQU04dUcsTUFBTSxJQUFJbmxFO1FBQ2hCLE1BQU11bEUsUUFBUSxJQUFJLENBQUNGLFNBQVM7UUFDNUIsTUFBTUcsaUJBQWlCLElBQUksQ0FBQ0YsZUFBZSxDQUFDQyxNQUFNLEdBQUc7WUFDbkRKO1FBQ0Y7UUFDQUEsSUFBSS9xRyxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMyVixHQUFHO1FBQ3hCbzFGLElBQUlyQixlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlO1FBQzFDLEtBQUssTUFBTSxDQUFDdHNHLEtBQUt3TSxJQUFJLElBQUksSUFBSSxDQUFDZy9GLE9BQU8sQ0FBRTtZQUNyQ21DLElBQUlNLGdCQUFnQixDQUFDanVHLEtBQUt3TTtRQUM1QjtRQUNBLElBQUksSUFBSSxDQUFDOCtGLE1BQU0sSUFBSSxXQUFXenNHLFFBQVEsU0FBU0EsTUFBTTtZQUNuRDh1RyxJQUFJTSxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFcHZHLEtBQUs2b0csS0FBSyxDQUFDLENBQUMsRUFBRTdvRyxLQUFLdWYsR0FBRyxHQUFHLEVBQUUsQ0FBQztZQUNuRTR2RixlQUFlRSxjQUFjLEdBQUdUO1FBQ2xDLE9BQU87WUFDTE8sZUFBZUUsY0FBYyxHQUFHVjtRQUNsQztRQUNBRyxJQUFJbGxFLFlBQVksR0FBRztRQUNuQnBSLE9BQU94NEIsS0FBS3N2RyxPQUFPLEVBQUU7UUFDckJSLElBQUlwekQsT0FBTyxHQUFHO1lBQ1oxN0MsS0FBS3N2RyxPQUFPLENBQUNSLElBQUk3MEUsTUFBTTtRQUN6QjtRQUNBNjBFLElBQUlqbEUsa0JBQWtCLEdBQUcsSUFBSSxDQUFDMGxFLGFBQWEsQ0FBQ3p6RyxJQUFJLENBQUMsSUFBSSxFQUFFb3pHO1FBQ3ZESixJQUFJVSxVQUFVLEdBQUcsSUFBSSxDQUFDN0YsVUFBVSxDQUFDN3RHLElBQUksQ0FBQyxJQUFJLEVBQUVvekc7UUFDNUNDLGVBQWVNLGlCQUFpQixHQUFHenZHLEtBQUt5dkcsaUJBQWlCO1FBQ3pETixlQUFlTyxNQUFNLEdBQUcxdkcsS0FBSzB2RyxNQUFNO1FBQ25DUCxlQUFlRyxPQUFPLEdBQUd0dkcsS0FBS3N2RyxPQUFPO1FBQ3JDSCxlQUFleEYsVUFBVSxHQUFHM3BHLEtBQUsycEcsVUFBVTtRQUMzQ21GLElBQUk3a0UsSUFBSSxDQUFDO1FBQ1QsT0FBT2lsRTtJQUNUO0lBQ0F2RixXQUFXdUYsS0FBSyxFQUFFdnJELEdBQUcsRUFBRTtRQUNyQixNQUFNd3JELGlCQUFpQixJQUFJLENBQUNGLGVBQWUsQ0FBQ0MsTUFBTTtRQUNsRCxJQUFJLENBQUNDLGdCQUFnQjtZQUNuQjtRQUNGO1FBQ0FBLGVBQWV4RixVQUFVLEdBQUdobUQ7SUFDOUI7SUFDQTRyRCxjQUFjTCxLQUFLLEVBQUV2ckQsR0FBRyxFQUFFO1FBQ3hCLE1BQU13ckQsaUJBQWlCLElBQUksQ0FBQ0YsZUFBZSxDQUFDQyxNQUFNO1FBQ2xELElBQUksQ0FBQ0MsZ0JBQWdCO1lBQ25CO1FBQ0Y7UUFDQSxNQUFNTCxNQUFNSyxlQUFlTCxHQUFHO1FBQzlCLElBQUlBLElBQUlobEUsVUFBVSxJQUFJLEtBQUtxbEUsZUFBZU0saUJBQWlCLEVBQUU7WUFDM0ROLGVBQWVNLGlCQUFpQjtZQUNoQyxPQUFPTixlQUFlTSxpQkFBaUI7UUFDekM7UUFDQSxJQUFJWCxJQUFJaGxFLFVBQVUsS0FBSyxHQUFHO1lBQ3hCO1FBQ0Y7UUFDQSxJQUFJLENBQUVvbEUsQ0FBQUEsU0FBUyxJQUFJLENBQUNELGVBQWUsR0FBRztZQUNwQztRQUNGO1FBQ0EsT0FBTyxJQUFJLENBQUNBLGVBQWUsQ0FBQ0MsTUFBTTtRQUNsQyxJQUFJSixJQUFJNzBFLE1BQU0sS0FBSyxLQUFLLElBQUksQ0FBQ3d5RSxNQUFNLEVBQUU7WUFDbkMwQyxlQUFlRyxPQUFPLENBQUNSLElBQUk3MEUsTUFBTTtZQUNqQztRQUNGO1FBQ0EsTUFBTTAxRSxZQUFZYixJQUFJNzBFLE1BQU0sSUFBSTAwRTtRQUNoQyxNQUFNaUIsK0JBQStCRCxjQUFjaEIsZUFBZVEsZUFBZUUsY0FBYyxLQUFLVDtRQUNwRyxJQUFJLENBQUNnQixnQ0FBZ0NELGNBQWNSLGVBQWVFLGNBQWMsRUFBRTtZQUNoRkYsZUFBZUcsT0FBTyxDQUFDUixJQUFJNzBFLE1BQU07WUFDakM7UUFDRjtRQUNBLE1BQU12VyxRQUFRbXJGLHVCQUF1QkM7UUFDckMsSUFBSWEsY0FBY2YsMEJBQTBCO1lBQzFDLE1BQU1pQixjQUFjZixJQUFJZ0IsaUJBQWlCLENBQUM7WUFDMUMsTUFBTTVoRSxVQUFVLDJCQUEyQnp3QyxJQUFJLENBQUNveUc7WUFDaEQsSUFBSTNoRSxTQUFTO2dCQUNYaWhFLGVBQWVPLE1BQU0sQ0FBQztvQkFDcEI3RyxPQUFPcG5HLFNBQVN5c0MsT0FBTyxDQUFDLEVBQUUsRUFBRTtvQkFDNUJ4cUI7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMNFUsS0FBSyxDQUFDLDBDQUEwQyxDQUFDO2dCQUNqRDYyRSxlQUFlRyxPQUFPLENBQUM7WUFDekI7UUFDRixPQUFPLElBQUk1ckYsT0FBTztZQUNoQnlyRixlQUFlTyxNQUFNLENBQUM7Z0JBQ3BCN0csT0FBTztnQkFDUG5sRjtZQUNGO1FBQ0YsT0FBTztZQUNMeXJGLGVBQWVHLE9BQU8sQ0FBQ1IsSUFBSTcwRSxNQUFNO1FBQ25DO0lBQ0Y7SUFDQTgxRSxjQUFjYixLQUFLLEVBQUU7UUFDbkIsT0FBTyxJQUFJLENBQUNELGVBQWUsQ0FBQ0MsTUFBTSxDQUFDSixHQUFHO0lBQ3hDO0lBQ0FrQixpQkFBaUJkLEtBQUssRUFBRTtRQUN0QixPQUFPQSxTQUFTLElBQUksQ0FBQ0QsZUFBZTtJQUN0QztJQUNBZ0IsYUFBYWYsS0FBSyxFQUFFO1FBQ2xCLE1BQU1KLE1BQU0sSUFBSSxDQUFDRyxlQUFlLENBQUNDLE1BQU0sQ0FBQ0osR0FBRztRQUMzQyxPQUFPLElBQUksQ0FBQ0csZUFBZSxDQUFDQyxNQUFNO1FBQ2xDSixJQUFJOXBFLEtBQUs7SUFDWDtBQUNGO0FBQ0EsTUFBTWtyRTtJQUNKLzJHLFlBQVlLLE1BQU0sQ0FBRTtRQUNsQixJQUFJLENBQUMyMkcsT0FBTyxHQUFHMzJHO1FBQ2YsSUFBSSxDQUFDNDJHLFFBQVEsR0FBRyxJQUFJckIsZUFBZXYxRztRQUNuQyxJQUFJLENBQUM4MEcsZUFBZSxHQUFHOTBHLE9BQU93ekcsY0FBYztRQUM1QyxJQUFJLENBQUN0RSxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNxRixvQkFBb0IsR0FBRyxFQUFFO0lBQ2hDO0lBQ0FzQyw0QkFBNEJ4RyxNQUFNLEVBQUU7UUFDbEMsTUFBTW52RyxJQUFJLElBQUksQ0FBQ3F6RyxvQkFBb0IsQ0FBQ2h0RyxPQUFPLENBQUM4b0c7UUFDNUMsSUFBSW52RyxLQUFLLEdBQUc7WUFDVixJQUFJLENBQUNxekcsb0JBQW9CLENBQUMxd0QsTUFBTSxDQUFDM2lELEdBQUc7UUFDdEM7SUFDRjtJQUNBb3ZHLGdCQUFnQjtRQUNkdHhFLE9BQU8sQ0FBQyxJQUFJLENBQUNrd0Usa0JBQWtCLEVBQUU7UUFDakMsSUFBSSxDQUFDQSxrQkFBa0IsR0FBRyxJQUFJNEgsa0NBQWtDLElBQUksQ0FBQ0YsUUFBUSxFQUFFLElBQUksQ0FBQ0QsT0FBTztRQUMzRixPQUFPLElBQUksQ0FBQ3pILGtCQUFrQjtJQUNoQztJQUNBdUIsZUFBZXBCLEtBQUssRUFBRXRwRixHQUFHLEVBQUU7UUFDekIsTUFBTXNxRixTQUFTLElBQUkwRyxtQ0FBbUMsSUFBSSxDQUFDSCxRQUFRLEVBQUV2SCxPQUFPdHBGO1FBQzVFc3FGLE9BQU8yRyxRQUFRLEdBQUcsSUFBSSxDQUFDSCwyQkFBMkIsQ0FBQ3YwRyxJQUFJLENBQUMsSUFBSTtRQUM1RCxJQUFJLENBQUNpeUcsb0JBQW9CLENBQUMvc0csSUFBSSxDQUFDNm9HO1FBQy9CLE9BQU9BO0lBQ1Q7SUFDQU8sa0JBQWtCbmxFLE1BQU0sRUFBRTtRQUN4QixJQUFJLENBQUN5akUsa0JBQWtCLEVBQUVoekMsT0FBT3p3QjtRQUNoQyxLQUFLLE1BQU00a0UsVUFBVSxJQUFJLENBQUNrRSxvQkFBb0IsQ0FBQ3oxRyxLQUFLLENBQUMsR0FBSTtZQUN2RHV4RyxPQUFPbjBDLE1BQU0sQ0FBQ3p3QjtRQUNoQjtJQUNGO0FBQ0Y7QUFDQSxNQUFNcXJFO0lBQ0puM0csWUFBWXMzRyxPQUFPLEVBQUVqM0csTUFBTSxDQUFFO1FBQzNCLElBQUksQ0FBQzQyRyxRQUFRLEdBQUdLO1FBQ2hCLElBQUksQ0FBQ0MsSUFBSSxHQUFHbDNHLE9BQU9rZ0IsR0FBRztRQUN0QixJQUFJLENBQUNpM0YsY0FBYyxHQUFHRixRQUFRL21FLE9BQU8sQ0FBQztZQUNwQytsRSxtQkFBbUIsSUFBSSxDQUFDbUIsa0JBQWtCLENBQUM5MEcsSUFBSSxDQUFDLElBQUk7WUFDcEQ0ekcsUUFBUSxJQUFJLENBQUNtQixPQUFPLENBQUMvMEcsSUFBSSxDQUFDLElBQUk7WUFDOUJ3ekcsU0FBUyxJQUFJLENBQUN3QixRQUFRLENBQUNoMUcsSUFBSSxDQUFDLElBQUk7WUFDaEM2dEcsWUFBWSxJQUFJLENBQUNWLFdBQVcsQ0FBQ250RyxJQUFJLENBQUMsSUFBSTtRQUN4QztRQUNBLElBQUksQ0FBQ3N5RyxrQkFBa0IsR0FBR3h1RyxRQUFRK1EsYUFBYTtRQUMvQyxJQUFJLENBQUMwOUYsYUFBYSxHQUFHNzBHLE9BQU9zdUcsWUFBWSxJQUFJO1FBQzVDLElBQUksQ0FBQ1csY0FBYyxHQUFHanZHLE9BQU96RCxNQUFNO1FBQ25DLElBQUksQ0FBQ3U0RyxlQUFlLEdBQUc5MEcsT0FBT3d6RyxjQUFjO1FBQzVDLElBQUksQ0FBQyxJQUFJLENBQUNzQixlQUFlLElBQUksQ0FBQyxJQUFJLENBQUNELGFBQWEsRUFBRTtZQUNoRCxJQUFJLENBQUNBLGFBQWEsR0FBRztRQUN2QjtRQUNBLElBQUksQ0FBQzlGLHFCQUFxQixHQUFHO1FBQzdCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDdUksYUFBYSxHQUFHLEVBQUU7UUFDdkIsSUFBSSxDQUFDdkcsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDRixLQUFLLEdBQUc7UUFDYixJQUFJLENBQUMwRyxZQUFZLEdBQUcxM0c7UUFDcEIsSUFBSSxDQUFDaXhHLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNaLFVBQVUsR0FBRztJQUNwQjtJQUNBaUgscUJBQXFCO1FBQ25CLE1BQU1LLG1CQUFtQixJQUFJLENBQUNOLGNBQWM7UUFDNUMsTUFBTU8saUJBQWlCLElBQUksQ0FBQ2QsUUFBUSxDQUFDTCxhQUFhLENBQUNrQjtRQUNuRCxJQUFJLENBQUNiLFFBQVEsQ0FBQ3RDLGVBQWUsR0FBR2pCLGtCQUFrQnFFLGVBQWVDLFdBQVc7UUFDNUUsTUFBTUMscUJBQXFCRixlQUFlRyxxQkFBcUI7UUFDL0QsTUFBTXRFLGtCQUFrQixJQUFJSCxRQUFRd0UscUJBQXFCQSxtQkFBbUJFLFNBQVMsR0FBRy80RyxPQUFPLENBQUMsWUFBWSxJQUFJSSxLQUFLLENBQUMsV0FBV2lJLEdBQUcsQ0FBQ2xFLENBQUFBO1lBQ25JLE1BQU0sQ0FBQ3lFLEtBQUssR0FBR3dNLElBQUksR0FBR2pSLEVBQUUvRCxLQUFLLENBQUM7WUFDOUIsT0FBTztnQkFBQ3dJO2dCQUFLd00sSUFBSW5WLElBQUksQ0FBQzthQUFNO1FBQzlCLEtBQUssRUFBRTtRQUNQLE1BQU0sRUFDSjAwRyxrQkFBa0IsRUFDbEJDLGVBQWUsRUFDaEIsR0FBR0wsaUNBQWlDO1lBQ25DQztZQUNBTixRQUFRLElBQUksQ0FBQzJELFFBQVEsQ0FBQzNELE1BQU07WUFDNUJPLGdCQUFnQixJQUFJLENBQUNzQixlQUFlO1lBQ3BDeEcsY0FBYyxJQUFJLENBQUN1RyxhQUFhO1FBQ2xDO1FBQ0EsSUFBSW5CLG9CQUFvQjtZQUN0QixJQUFJLENBQUMxRSxpQkFBaUIsR0FBRztRQUMzQjtRQUNBLElBQUksQ0FBQ0MsY0FBYyxHQUFHMEUsbUJBQW1CLElBQUksQ0FBQzFFLGNBQWM7UUFDNUQsSUFBSSxDQUFDOEIsU0FBUyxHQUFHOEMsMEJBQTBCTjtRQUMzQyxJQUFJLElBQUksQ0FBQ3ZFLGlCQUFpQixFQUFFO1lBQzFCLElBQUksQ0FBQzRILFFBQVEsQ0FBQ0gsWUFBWSxDQUFDZ0I7UUFDN0I7UUFDQSxJQUFJLENBQUM3QyxrQkFBa0IsQ0FBQ2h1RyxPQUFPO0lBQ2pDO0lBQ0F5d0csUUFBUXZxRyxJQUFJLEVBQUU7UUFDWixJQUFJQSxNQUFNO1lBQ1IsSUFBSSxJQUFJLENBQUNra0csU0FBUyxDQUFDejBHLE1BQU0sR0FBRyxHQUFHO2dCQUM3QixNQUFNMjBHLG9CQUFvQixJQUFJLENBQUNGLFNBQVMsQ0FBQzdrRixLQUFLO2dCQUM5QytrRixrQkFBa0J0cUcsT0FBTyxDQUFDO29CQUN4QnBKLE9BQU9zUCxLQUFLb2QsS0FBSztvQkFDakJ6b0IsTUFBTTtnQkFDUjtZQUNGLE9BQU87Z0JBQ0wsSUFBSSxDQUFDODFHLGFBQWEsQ0FBQy92RyxJQUFJLENBQUNzRixLQUFLb2QsS0FBSztZQUNwQztRQUNGO1FBQ0EsSUFBSSxDQUFDNG1GLEtBQUssR0FBRztRQUNiLElBQUksSUFBSSxDQUFDeUcsYUFBYSxDQUFDaDdHLE1BQU0sR0FBRyxHQUFHO1lBQ2pDO1FBQ0Y7UUFDQSxLQUFLLE1BQU0yMEcscUJBQXFCLElBQUksQ0FBQ0YsU0FBUyxDQUFFO1lBQzlDRSxrQkFBa0J0cUcsT0FBTyxDQUFDO2dCQUN4QnBKLE9BQU9zQztnQkFDUDJCLE1BQU07WUFDUjtRQUNGO1FBQ0EsSUFBSSxDQUFDdXZHLFNBQVMsQ0FBQ3owRyxNQUFNLEdBQUc7SUFDMUI7SUFDQSs2RyxTQUFTNzJFLE1BQU0sRUFBRTtRQUNmLElBQUksQ0FBQysyRSxZQUFZLEdBQUcxRCxvQkFBb0JyekUsUUFBUSxJQUFJLENBQUN5MkUsSUFBSTtRQUN6RCxJQUFJLENBQUN0QyxrQkFBa0IsQ0FBQ2p1RyxNQUFNLENBQUMsSUFBSSxDQUFDNndHLFlBQVk7UUFDaEQsS0FBSyxNQUFNdEcscUJBQXFCLElBQUksQ0FBQ0YsU0FBUyxDQUFFO1lBQzlDRSxrQkFBa0J2cUcsTUFBTSxDQUFDLElBQUksQ0FBQzZ3RyxZQUFZO1FBQzVDO1FBQ0EsSUFBSSxDQUFDeEcsU0FBUyxDQUFDejBHLE1BQU0sR0FBRztRQUN4QixJQUFJLENBQUNnN0csYUFBYSxDQUFDaDdHLE1BQU0sR0FBRztJQUM5QjtJQUNBa3pHLFlBQVl0bEQsR0FBRyxFQUFFO1FBQ2YsSUFBSSxDQUFDZ21ELFVBQVUsR0FBRztZQUNoQm42QixRQUFRN3JCLElBQUk2ckIsTUFBTTtZQUNsQnc1QixPQUFPcmxELElBQUk0dEQsZ0JBQWdCLEdBQUc1dEQsSUFBSXFsRCxLQUFLLEdBQUcsSUFBSSxDQUFDUCxjQUFjO1FBQy9EO0lBQ0Y7SUFDQSxJQUFJcDhELFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQ2srRCxTQUFTO0lBQ3ZCO0lBQ0EsSUFBSUssbUJBQW1CO1FBQ3JCLE9BQU8sSUFBSSxDQUFDcEMsaUJBQWlCO0lBQy9CO0lBQ0EsSUFBSXFDLHVCQUF1QjtRQUN6QixPQUFPLElBQUksQ0FBQ3RDLHFCQUFxQjtJQUNuQztJQUNBLElBQUl1QyxnQkFBZ0I7UUFDbEIsT0FBTyxJQUFJLENBQUNyQyxjQUFjO0lBQzVCO0lBQ0EsSUFBSWtDLGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUN5RCxrQkFBa0IsQ0FBQy90RyxPQUFPO0lBQ3hDO0lBQ0EsTUFBTTRCLE9BQU87UUFDWCxNQUFNLElBQUksQ0FBQ21zRyxrQkFBa0IsQ0FBQy90RyxPQUFPO1FBQ3JDLElBQUksSUFBSSxDQUFDMndHLFlBQVksRUFBRTtZQUNyQixNQUFNLElBQUksQ0FBQ0EsWUFBWTtRQUN6QjtRQUNBLElBQUksSUFBSSxDQUFDRCxhQUFhLENBQUNoN0csTUFBTSxHQUFHLEdBQUc7WUFDakMsTUFBTTJ0QixRQUFRLElBQUksQ0FBQ3F0RixhQUFhLENBQUNwckYsS0FBSztZQUN0QyxPQUFPO2dCQUNMM3VCLE9BQU8wc0I7Z0JBQ1B6b0IsTUFBTTtZQUNSO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQ3F2RyxLQUFLLEVBQUU7WUFDZCxPQUFPO2dCQUNMdHpHLE9BQU9zQztnQkFDUDJCLE1BQU07WUFDUjtRQUNGO1FBQ0EsTUFBTXl2RyxvQkFBb0I5cUcsUUFBUStRLGFBQWE7UUFDL0MsSUFBSSxDQUFDNjVGLFNBQVMsQ0FBQ3hwRyxJQUFJLENBQUMwcEc7UUFDcEIsT0FBT0Esa0JBQWtCcnFHLE9BQU87SUFDbEM7SUFDQXExRCxPQUFPendCLE1BQU0sRUFBRTtRQUNiLElBQUksQ0FBQ3FsRSxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUM4RCxrQkFBa0IsQ0FBQ2p1RyxNQUFNLENBQUM4a0M7UUFDL0IsS0FBSyxNQUFNeWxFLHFCQUFxQixJQUFJLENBQUNGLFNBQVMsQ0FBRTtZQUM5Q0Usa0JBQWtCdHFHLE9BQU8sQ0FBQztnQkFDeEJwSixPQUFPc0M7Z0JBQ1AyQixNQUFNO1lBQ1I7UUFDRjtRQUNBLElBQUksQ0FBQ3V2RyxTQUFTLENBQUN6MEcsTUFBTSxHQUFHO1FBQ3hCLElBQUksSUFBSSxDQUFDcTZHLFFBQVEsQ0FBQ0osZ0JBQWdCLENBQUMsSUFBSSxDQUFDVyxjQUFjLEdBQUc7WUFDdkQsSUFBSSxDQUFDUCxRQUFRLENBQUNILFlBQVksQ0FBQyxJQUFJLENBQUNVLGNBQWM7UUFDaEQ7UUFDQSxJQUFJLENBQUNqSSxrQkFBa0IsR0FBRztJQUM1QjtBQUNGO0FBQ0EsTUFBTTZIO0lBQ0pwM0csWUFBWXMzRyxPQUFPLEVBQUU1SCxLQUFLLEVBQUV0cEYsR0FBRyxDQUFFO1FBQy9CLElBQUksQ0FBQzZ3RixRQUFRLEdBQUdLO1FBQ2hCLElBQUksQ0FBQ0MsSUFBSSxHQUFHRCxRQUFRLzJGLEdBQUc7UUFDdkIsSUFBSSxDQUFDODNGLFVBQVUsR0FBR2YsUUFBUS9tRSxPQUFPLENBQUM7WUFDaENtL0Q7WUFDQXRwRjtZQUNBa3dGLG1CQUFtQixJQUFJLENBQUNtQixrQkFBa0IsQ0FBQzkwRyxJQUFJLENBQUMsSUFBSTtZQUNwRDR6RyxRQUFRLElBQUksQ0FBQ21CLE9BQU8sQ0FBQy8wRyxJQUFJLENBQUMsSUFBSTtZQUM5Qnd6RyxTQUFTLElBQUksQ0FBQ3dCLFFBQVEsQ0FBQ2gxRyxJQUFJLENBQUMsSUFBSTtZQUNoQzZ0RyxZQUFZLElBQUksQ0FBQ1YsV0FBVyxDQUFDbnRHLElBQUksQ0FBQyxJQUFJO1FBQ3hDO1FBQ0EsSUFBSSxDQUFDMHVHLFNBQVMsR0FBRyxFQUFFO1FBQ25CLElBQUksQ0FBQ1EsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ1YsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDMEcsWUFBWSxHQUFHMTNHO1FBQ3BCLElBQUksQ0FBQ3F3RyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDNkcsUUFBUSxHQUFHO0lBQ2xCO0lBQ0FJLHFCQUFxQjtRQUNuQixNQUFNbEMsaUJBQWlCN0Isa0JBQWtCLElBQUksQ0FBQ3VELFFBQVEsQ0FBQ0wsYUFBYSxDQUFDLElBQUksQ0FBQ3lCLFVBQVUsR0FBR0w7UUFDdkYsSUFBSXpDLG1CQUFtQixJQUFJLENBQUMwQixRQUFRLENBQUN0QyxlQUFlLEVBQUU7WUFDcEQsSUFBSSxDQUFDa0QsWUFBWSxHQUFHLElBQUk5OEYsTUFBTSxDQUFDLGdDQUFnQyxFQUFFdzZGLGVBQWUsWUFBWSxFQUFFLElBQUksQ0FBQzBCLFFBQVEsQ0FBQ3RDLGVBQWUsQ0FBQyxFQUFFLENBQUM7WUFDL0gsSUFBSSxDQUFDZ0QsUUFBUSxDQUFDO1FBQ2hCO0lBQ0Y7SUFDQVcsU0FBUztRQUNQLElBQUksQ0FBQ2pCLFFBQVEsR0FBRyxJQUFJO0lBQ3RCO0lBQ0FLLFFBQVF2cUcsSUFBSSxFQUFFO1FBQ1osTUFBTW9kLFFBQVFwZCxLQUFLb2QsS0FBSztRQUN4QixJQUFJLElBQUksQ0FBQzhtRixTQUFTLENBQUN6MEcsTUFBTSxHQUFHLEdBQUc7WUFDN0IsTUFBTTIwRyxvQkFBb0IsSUFBSSxDQUFDRixTQUFTLENBQUM3a0YsS0FBSztZQUM5QytrRixrQkFBa0J0cUcsT0FBTyxDQUFDO2dCQUN4QnBKLE9BQU8wc0I7Z0JBQ1B6b0IsTUFBTTtZQUNSO1FBQ0YsT0FBTztZQUNMLElBQUksQ0FBQyt2RyxZQUFZLEdBQUd0bkY7UUFDdEI7UUFDQSxJQUFJLENBQUM0bUYsS0FBSyxHQUFHO1FBQ2IsS0FBSyxNQUFNSSxxQkFBcUIsSUFBSSxDQUFDRixTQUFTLENBQUU7WUFDOUNFLGtCQUFrQnRxRyxPQUFPLENBQUM7Z0JBQ3hCcEosT0FBT3NDO2dCQUNQMkIsTUFBTTtZQUNSO1FBQ0Y7UUFDQSxJQUFJLENBQUN1dkcsU0FBUyxDQUFDejBHLE1BQU0sR0FBRztRQUN4QixJQUFJLENBQUMwN0csTUFBTTtJQUNiO0lBQ0FYLFNBQVM3MkUsTUFBTSxFQUFFO1FBQ2YsSUFBSSxDQUFDKzJFLFlBQVksS0FBSzFELG9CQUFvQnJ6RSxRQUFRLElBQUksQ0FBQ3kyRSxJQUFJO1FBQzNELEtBQUssTUFBTWhHLHFCQUFxQixJQUFJLENBQUNGLFNBQVMsQ0FBRTtZQUM5Q0Usa0JBQWtCdnFHLE1BQU0sQ0FBQyxJQUFJLENBQUM2d0csWUFBWTtRQUM1QztRQUNBLElBQUksQ0FBQ3hHLFNBQVMsQ0FBQ3owRyxNQUFNLEdBQUc7UUFDeEIsSUFBSSxDQUFDaTFHLFlBQVksR0FBRztJQUN0QjtJQUNBL0IsWUFBWXRsRCxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDa25ELG9CQUFvQixFQUFFO1lBQzlCLElBQUksQ0FBQ2xCLFVBQVUsR0FBRztnQkFDaEJuNkIsUUFBUTdyQixJQUFJNnJCLE1BQU07WUFDcEI7UUFDRjtJQUNGO0lBQ0EsSUFBSXE3Qix1QkFBdUI7UUFDekIsT0FBTztJQUNUO0lBQ0EsTUFBTTVvRyxPQUFPO1FBQ1gsSUFBSSxJQUFJLENBQUMrdUcsWUFBWSxFQUFFO1lBQ3JCLE1BQU0sSUFBSSxDQUFDQSxZQUFZO1FBQ3pCO1FBQ0EsSUFBSSxJQUFJLENBQUNoRyxZQUFZLEtBQUssTUFBTTtZQUM5QixNQUFNdG5GLFFBQVEsSUFBSSxDQUFDc25GLFlBQVk7WUFDL0IsSUFBSSxDQUFDQSxZQUFZLEdBQUc7WUFDcEIsT0FBTztnQkFDTGgwRyxPQUFPMHNCO2dCQUNQem9CLE1BQU07WUFDUjtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUNxdkcsS0FBSyxFQUFFO1lBQ2QsT0FBTztnQkFDTHR6RyxPQUFPc0M7Z0JBQ1AyQixNQUFNO1lBQ1I7UUFDRjtRQUNBLE1BQU15dkcsb0JBQW9COXFHLFFBQVErUSxhQUFhO1FBQy9DLElBQUksQ0FBQzY1RixTQUFTLENBQUN4cEcsSUFBSSxDQUFDMHBHO1FBQ3BCLE9BQU9BLGtCQUFrQnJxRyxPQUFPO0lBQ2xDO0lBQ0FxMUQsT0FBT3p3QixNQUFNLEVBQUU7UUFDYixJQUFJLENBQUNxbEUsS0FBSyxHQUFHO1FBQ2IsS0FBSyxNQUFNSSxxQkFBcUIsSUFBSSxDQUFDRixTQUFTLENBQUU7WUFDOUNFLGtCQUFrQnRxRyxPQUFPLENBQUM7Z0JBQ3hCcEosT0FBT3NDO2dCQUNQMkIsTUFBTTtZQUNSO1FBQ0Y7UUFDQSxJQUFJLENBQUN1dkcsU0FBUyxDQUFDejBHLE1BQU0sR0FBRztRQUN4QixJQUFJLElBQUksQ0FBQ3E2RyxRQUFRLENBQUNKLGdCQUFnQixDQUFDLElBQUksQ0FBQ3dCLFVBQVUsR0FBRztZQUNuRCxJQUFJLENBQUNwQixRQUFRLENBQUNILFlBQVksQ0FBQyxJQUFJLENBQUN1QixVQUFVO1FBQzVDO1FBQ0EsSUFBSSxDQUFDQyxNQUFNO0lBQ2I7QUFDRjtFQUVDLCtCQUErQjtBQWdCaEMsTUFBTUMsV0FBVztBQUNqQixTQUFTQyxlQUFlQyxTQUFTO0lBQy9CLElBQUlGLFNBQVM3MUcsSUFBSSxDQUFDKzFHLFlBQVk7UUFDNUIsT0FBTyxJQUFJcDRGLElBQUlvNEY7SUFDakI7SUFDQSxNQUFNbDRGLE1BQU1wTSxRQUFRa1gsZ0JBQWdCLENBQUM7SUFDckMsT0FBTyxJQUFJaEwsSUFBSUUsSUFBSW00RixhQUFhLENBQUNEO0FBQ25DO0FBQ0EsTUFBTUU7SUFDSjM0RyxZQUFZSyxNQUFNLENBQUU7UUFDbEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDa2dCLEdBQUcsR0FBR2k0RixlQUFlbjRHLE9BQU9rZ0IsR0FBRztRQUNwQzhlLE9BQU8sSUFBSSxDQUFDOWUsR0FBRyxDQUFDaWYsUUFBUSxLQUFLLFNBQVM7UUFDdEMsSUFBSSxDQUFDK3ZFLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ3FGLG9CQUFvQixHQUFHLEVBQUU7SUFDaEM7SUFDQSxJQUFJdEUseUJBQXlCO1FBQzNCLE9BQU8sSUFBSSxDQUFDZixrQkFBa0IsRUFBRWdCLFdBQVc7SUFDN0M7SUFDQUksZ0JBQWdCO1FBQ2R0eEUsT0FBTyxDQUFDLElBQUksQ0FBQ2t3RSxrQkFBa0IsRUFBRTtRQUNqQyxJQUFJLENBQUNBLGtCQUFrQixHQUFHLElBQUlxSiwwQkFBMEIsSUFBSTtRQUM1RCxPQUFPLElBQUksQ0FBQ3JKLGtCQUFrQjtJQUNoQztJQUNBdUIsZUFBZXJvRixLQUFLLEVBQUVyQyxHQUFHLEVBQUU7UUFDekIsSUFBSUEsT0FBTyxJQUFJLENBQUNrcUYsc0JBQXNCLEVBQUU7WUFDdEMsT0FBTztRQUNUO1FBQ0EsTUFBTUYsY0FBYyxJQUFJeUksMkJBQTJCLElBQUksRUFBRXB3RixPQUFPckM7UUFDaEUsSUFBSSxDQUFDd3VGLG9CQUFvQixDQUFDL3NHLElBQUksQ0FBQ3VvRztRQUMvQixPQUFPQTtJQUNUO0lBQ0FhLGtCQUFrQm5sRSxNQUFNLEVBQUU7UUFDeEIsSUFBSSxDQUFDeWpFLGtCQUFrQixFQUFFaHpDLE9BQU96d0I7UUFDaEMsS0FBSyxNQUFNNGtFLFVBQVUsSUFBSSxDQUFDa0Usb0JBQW9CLENBQUN6MUcsS0FBSyxDQUFDLEdBQUk7WUFDdkR1eEcsT0FBT24wQyxNQUFNLENBQUN6d0I7UUFDaEI7SUFDRjtBQUNGO0FBQ0EsTUFBTThzRTtJQUNKNTRHLFlBQVkrOEUsTUFBTSxDQUFFO1FBQ2xCLElBQUksQ0FBQ3c2QixJQUFJLEdBQUd4NkIsT0FBT3g4RCxHQUFHO1FBQ3RCLElBQUksQ0FBQzR3RixLQUFLLEdBQUc7UUFDYixJQUFJLENBQUMwRyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDckgsVUFBVSxHQUFHO1FBQ2xCLE1BQU1ud0csU0FBUzA4RSxPQUFPMThFLE1BQU07UUFDNUIsSUFBSSxDQUFDaXZHLGNBQWMsR0FBR2p2RyxPQUFPekQsTUFBTTtRQUNuQyxJQUFJLENBQUMyekcsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDYSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDOEQsYUFBYSxHQUFHNzBHLE9BQU9zdUcsWUFBWSxJQUFJO1FBQzVDLElBQUksQ0FBQ3dHLGVBQWUsR0FBRzkwRyxPQUFPd3pHLGNBQWM7UUFDNUMsSUFBSSxDQUFDLElBQUksQ0FBQ3NCLGVBQWUsSUFBSSxDQUFDLElBQUksQ0FBQ0QsYUFBYSxFQUFFO1lBQ2hELElBQUksQ0FBQ0EsYUFBYSxHQUFHO1FBQ3ZCO1FBQ0EsSUFBSSxDQUFDOUYscUJBQXFCLEdBQUcsQ0FBQy91RyxPQUFPdXVHLGFBQWE7UUFDbEQsSUFBSSxDQUFDUyxpQkFBaUIsR0FBRyxDQUFDaHZHLE9BQU9zdUcsWUFBWTtRQUM3QyxJQUFJLENBQUNtSyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDeEQsZUFBZSxHQUFHN3VHLFFBQVErUSxhQUFhO1FBQzVDLElBQUksQ0FBQ3k5RixrQkFBa0IsR0FBR3h1RyxRQUFRK1EsYUFBYTtRQUMvQyxNQUFNNHNFLEtBQUtqd0UsUUFBUWtYLGdCQUFnQixDQUFDO1FBQ3BDKzRELEdBQUc5dEIsUUFBUSxDQUFDeWlELEtBQUssQ0FBQyxJQUFJLENBQUN4QixJQUFJLEVBQUVoMkQsSUFBSSxDQUFDNTZDLENBQUFBO1lBQ2hDLElBQUksQ0FBQzJvRyxjQUFjLEdBQUczb0csS0FBS2lMLElBQUk7WUFDL0IsSUFBSSxDQUFDb25HLGtCQUFrQixDQUFDNTBCLEdBQUc2MEIsZ0JBQWdCLENBQUMsSUFBSSxDQUFDMUIsSUFBSTtZQUNyRCxJQUFJLENBQUN0QyxrQkFBa0IsQ0FBQ2h1RyxPQUFPO1FBQ2pDLEdBQUd2SixDQUFBQTtZQUNELElBQUlBLE1BQU0raUMsSUFBSSxLQUFLLFVBQVU7Z0JBQzNCL2lDLFFBQVF5Mkcsb0JBQW9CLEdBQUcsSUFBSSxDQUFDb0QsSUFBSSxDQUFDbjBGLElBQUk7WUFDL0M7WUFDQSxJQUFJLENBQUN5MEYsWUFBWSxHQUFHbjZHO1lBQ3BCLElBQUksQ0FBQ3UzRyxrQkFBa0IsQ0FBQ2p1RyxNQUFNLENBQUN0SjtRQUNqQztJQUNGO0lBQ0EsSUFBSTh6RyxlQUFlO1FBQ2pCLE9BQU8sSUFBSSxDQUFDeUQsa0JBQWtCLENBQUMvdEcsT0FBTztJQUN4QztJQUNBLElBQUlnc0MsV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDaytELFNBQVM7SUFDdkI7SUFDQSxJQUFJTyxnQkFBZ0I7UUFDbEIsT0FBTyxJQUFJLENBQUNyQyxjQUFjO0lBQzVCO0lBQ0EsSUFBSW1DLG1CQUFtQjtRQUNyQixPQUFPLElBQUksQ0FBQ3BDLGlCQUFpQjtJQUMvQjtJQUNBLElBQUlxQyx1QkFBdUI7UUFDekIsT0FBTyxJQUFJLENBQUN0QyxxQkFBcUI7SUFDbkM7SUFDQSxNQUFNdG1HLE9BQU87UUFDWCxNQUFNLElBQUksQ0FBQ3dzRyxlQUFlLENBQUNwdUcsT0FBTztRQUNsQyxJQUFJLElBQUksQ0FBQ2lxRyxLQUFLLEVBQUU7WUFDZCxPQUFPO2dCQUNMdHpHLE9BQU9zQztnQkFDUDJCLE1BQU07WUFDUjtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUMrMUcsWUFBWSxFQUFFO1lBQ3JCLE1BQU0sSUFBSSxDQUFDQSxZQUFZO1FBQ3pCO1FBQ0EsTUFBTXR0RixRQUFRLElBQUksQ0FBQ3V1RixlQUFlLENBQUNod0csSUFBSTtRQUN2QyxJQUFJeWhCLFVBQVUsTUFBTTtZQUNsQixJQUFJLENBQUMrcUYsZUFBZSxHQUFHN3VHLFFBQVErUSxhQUFhO1lBQzVDLE9BQU8sSUFBSSxDQUFDMU8sSUFBSTtRQUNsQjtRQUNBLElBQUksQ0FBQ3luRyxPQUFPLElBQUlobUYsTUFBTTN0QixNQUFNO1FBQzVCLElBQUksQ0FBQzR6RyxVQUFVLEdBQUc7WUFDaEJuNkIsUUFBUSxJQUFJLENBQUNrNkIsT0FBTztZQUNwQlYsT0FBTyxJQUFJLENBQUNQLGNBQWM7UUFDNUI7UUFDQSxNQUFNaHVHLFNBQVMsSUFBSUgsV0FBV29wQixPQUFPanBCLE1BQU07UUFDM0MsT0FBTztZQUNMekQsT0FBT3lEO1lBQ1BRLE1BQU07UUFDUjtJQUNGO0lBQ0F5NkQsT0FBT3p3QixNQUFNLEVBQUU7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDZ3RFLGVBQWUsRUFBRTtZQUN6QixJQUFJLENBQUNJLE1BQU0sQ0FBQ3B0RTtZQUNaO1FBQ0Y7UUFDQSxJQUFJLENBQUNndEUsZUFBZSxDQUFDcDVELE9BQU8sQ0FBQzVUO0lBQy9CO0lBQ0FvdEUsT0FBT3B0RSxNQUFNLEVBQUU7UUFDYixJQUFJLENBQUMrckUsWUFBWSxHQUFHL3JFO1FBQ3BCLElBQUksQ0FBQ3dwRSxlQUFlLENBQUNydUcsT0FBTztJQUM5QjtJQUNBK3hHLG1CQUFtQkcsY0FBYyxFQUFFO1FBQ2pDLElBQUksQ0FBQ0wsZUFBZSxHQUFHSztRQUN2QkEsZUFBZW5yRCxFQUFFLENBQUMsWUFBWTtZQUM1QixJQUFJLENBQUNzbkQsZUFBZSxDQUFDcnVHLE9BQU87UUFDOUI7UUFDQWt5RyxlQUFlbnJELEVBQUUsQ0FBQyxPQUFPO1lBQ3ZCbXJELGVBQWV6NUQsT0FBTztZQUN0QixJQUFJLENBQUN5eEQsS0FBSyxHQUFHO1lBQ2IsSUFBSSxDQUFDbUUsZUFBZSxDQUFDcnVHLE9BQU87UUFDOUI7UUFDQWt5RyxlQUFlbnJELEVBQUUsQ0FBQyxTQUFTbGlCLENBQUFBO1lBQ3pCLElBQUksQ0FBQ290RSxNQUFNLENBQUNwdEU7UUFDZDtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUNzakUscUJBQXFCLElBQUksSUFBSSxDQUFDQyxpQkFBaUIsRUFBRTtZQUN6RCxJQUFJLENBQUM2SixNQUFNLENBQUMsSUFBSWo0RSxlQUFlO1FBQ2pDO1FBQ0EsSUFBSSxJQUFJLENBQUM0MkUsWUFBWSxFQUFFO1lBQ3JCLElBQUksQ0FBQ2lCLGVBQWUsQ0FBQ3A1RCxPQUFPLENBQUMsSUFBSSxDQUFDbTRELFlBQVk7UUFDaEQ7SUFDRjtBQUNGO0FBQ0EsTUFBTWdCO0lBQ0o3NEcsWUFBWSs4RSxNQUFNLEVBQUV0MEQsS0FBSyxFQUFFckMsR0FBRyxDQUFFO1FBQzlCLElBQUksQ0FBQ214RixJQUFJLEdBQUd4NkIsT0FBT3g4RCxHQUFHO1FBQ3RCLElBQUksQ0FBQzR3RixLQUFLLEdBQUc7UUFDYixJQUFJLENBQUMwRyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDckgsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDdUksZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ3hELGVBQWUsR0FBRzd1RyxRQUFRK1EsYUFBYTtRQUM1QyxNQUFNblgsU0FBUzA4RSxPQUFPMThFLE1BQU07UUFDNUIsSUFBSSxDQUFDK3VHLHFCQUFxQixHQUFHLENBQUMvdUcsT0FBT3V1RyxhQUFhO1FBQ2xELE1BQU14cUIsS0FBS2p3RSxRQUFRa1gsZ0JBQWdCLENBQUM7UUFDcEMsSUFBSSxDQUFDMnRGLGtCQUFrQixDQUFDNTBCLEdBQUc2MEIsZ0JBQWdCLENBQUMsSUFBSSxDQUFDMUIsSUFBSSxFQUFFO1lBQ3JEOXVGO1lBQ0FyQyxLQUFLQSxNQUFNO1FBQ2I7SUFDRjtJQUNBLElBQUlzckYsdUJBQXVCO1FBQ3pCLE9BQU8sSUFBSSxDQUFDdEMscUJBQXFCO0lBQ25DO0lBQ0EsTUFBTXRtRyxPQUFPO1FBQ1gsTUFBTSxJQUFJLENBQUN3c0csZUFBZSxDQUFDcHVHLE9BQU87UUFDbEMsSUFBSSxJQUFJLENBQUNpcUcsS0FBSyxFQUFFO1lBQ2QsT0FBTztnQkFDTHR6RyxPQUFPc0M7Z0JBQ1AyQixNQUFNO1lBQ1I7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDKzFHLFlBQVksRUFBRTtZQUNyQixNQUFNLElBQUksQ0FBQ0EsWUFBWTtRQUN6QjtRQUNBLE1BQU10dEYsUUFBUSxJQUFJLENBQUN1dUYsZUFBZSxDQUFDaHdHLElBQUk7UUFDdkMsSUFBSXloQixVQUFVLE1BQU07WUFDbEIsSUFBSSxDQUFDK3FGLGVBQWUsR0FBRzd1RyxRQUFRK1EsYUFBYTtZQUM1QyxPQUFPLElBQUksQ0FBQzFPLElBQUk7UUFDbEI7UUFDQSxJQUFJLENBQUN5bkcsT0FBTyxJQUFJaG1GLE1BQU0zdEIsTUFBTTtRQUM1QixJQUFJLENBQUM0ekcsVUFBVSxHQUFHO1lBQ2hCbjZCLFFBQVEsSUFBSSxDQUFDazZCLE9BQU87UUFDdEI7UUFDQSxNQUFNanZHLFNBQVMsSUFBSUgsV0FBV29wQixPQUFPanBCLE1BQU07UUFDM0MsT0FBTztZQUNMekQsT0FBT3lEO1lBQ1BRLE1BQU07UUFDUjtJQUNGO0lBQ0F5NkQsT0FBT3p3QixNQUFNLEVBQUU7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDZ3RFLGVBQWUsRUFBRTtZQUN6QixJQUFJLENBQUNJLE1BQU0sQ0FBQ3B0RTtZQUNaO1FBQ0Y7UUFDQSxJQUFJLENBQUNndEUsZUFBZSxDQUFDcDVELE9BQU8sQ0FBQzVUO0lBQy9CO0lBQ0FvdEUsT0FBT3B0RSxNQUFNLEVBQUU7UUFDYixJQUFJLENBQUMrckUsWUFBWSxHQUFHL3JFO1FBQ3BCLElBQUksQ0FBQ3dwRSxlQUFlLENBQUNydUcsT0FBTztJQUM5QjtJQUNBK3hHLG1CQUFtQkcsY0FBYyxFQUFFO1FBQ2pDLElBQUksQ0FBQ0wsZUFBZSxHQUFHSztRQUN2QkEsZUFBZW5yRCxFQUFFLENBQUMsWUFBWTtZQUM1QixJQUFJLENBQUNzbkQsZUFBZSxDQUFDcnVHLE9BQU87UUFDOUI7UUFDQWt5RyxlQUFlbnJELEVBQUUsQ0FBQyxPQUFPO1lBQ3ZCbXJELGVBQWV6NUQsT0FBTztZQUN0QixJQUFJLENBQUN5eEQsS0FBSyxHQUFHO1lBQ2IsSUFBSSxDQUFDbUUsZUFBZSxDQUFDcnVHLE9BQU87UUFDOUI7UUFDQWt5RyxlQUFlbnJELEVBQUUsQ0FBQyxTQUFTbGlCLENBQUFBO1lBQ3pCLElBQUksQ0FBQ290RSxNQUFNLENBQUNwdEU7UUFDZDtRQUNBLElBQUksSUFBSSxDQUFDK3JFLFlBQVksRUFBRTtZQUNyQixJQUFJLENBQUNpQixlQUFlLENBQUNwNUQsT0FBTyxDQUFDLElBQUksQ0FBQ200RCxZQUFZO1FBQ2hEO0lBQ0Y7QUFDRjtFQUVDLCtCQUErQjtBQUVoQyxNQUFNdUIsZUFBZXpqRyxPQUFPO0FBQzVCLE1BQU0wakc7SUFDSixDQUFDdmdDLElBQUksQ0FBdUI7SUFDNUIsQ0FBQ3dnQyxTQUFTLENBQUN0Z0MsS0FBSztRQUNkLE9BQU8sSUFBSSxDQUFDLENBQUNGLElBQUksQ0FBQ0UsTUFBTSxLQUFLO1lBQzNCLEdBQUd2eUUsUUFBUStRLGFBQWEsRUFBRTtZQUMxQnJLLE1BQU1pc0c7UUFDUjtJQUNGO0lBQ0F2NkcsSUFBSW02RSxLQUFLLEVBQUVoK0QsV0FBVyxJQUFJLEVBQUU7UUFDMUIsSUFBSUEsVUFBVTtZQUNaLE1BQU10VCxNQUFNLElBQUksQ0FBQyxDQUFDNHhHLFNBQVMsQ0FBQ3RnQztZQUM1QnR4RSxJQUFJUixPQUFPLENBQUNxNkMsSUFBSSxDQUFDLElBQU12bUMsU0FBU3RULElBQUl5RixJQUFJO1lBQ3hDLE9BQU87UUFDVDtRQUNBLE1BQU16RixNQUFNLElBQUksQ0FBQyxDQUFDb3hFLElBQUksQ0FBQ0UsTUFBTTtRQUM3QixJQUFJLENBQUN0eEUsT0FBT0EsSUFBSXlGLElBQUksS0FBS2lzRyxjQUFjO1lBQ3JDLE1BQU0sSUFBSXIrRixNQUFNLENBQUMsMENBQTBDLEVBQUVpK0QsTUFBTSxDQUFDLENBQUM7UUFDdkU7UUFDQSxPQUFPdHhFLElBQUl5RixJQUFJO0lBQ2pCO0lBQ0EvSCxJQUFJNHpFLEtBQUssRUFBRTtRQUNULE1BQU10eEUsTUFBTSxJQUFJLENBQUMsQ0FBQ294RSxJQUFJLENBQUNFLE1BQU07UUFDN0IsT0FBTyxDQUFDLENBQUN0eEUsT0FBT0EsSUFBSXlGLElBQUksS0FBS2lzRztJQUMvQjtJQUNBaDdELE9BQU80NkIsS0FBSyxFQUFFO1FBQ1osTUFBTXR4RSxNQUFNLElBQUksQ0FBQyxDQUFDb3hFLElBQUksQ0FBQ0UsTUFBTTtRQUM3QixJQUFJLENBQUN0eEUsT0FBT0EsSUFBSXlGLElBQUksS0FBS2lzRyxjQUFjO1lBQ3JDLE9BQU87UUFDVDtRQUNBLE9BQU8sSUFBSSxDQUFDLENBQUN0Z0MsSUFBSSxDQUFDRSxNQUFNO1FBQ3hCLE9BQU87SUFDVDtJQUNBL3hFLFFBQVEreEUsS0FBSyxFQUFFN3JFLE9BQU8sSUFBSSxFQUFFO1FBQzFCLE1BQU16RixNQUFNLElBQUksQ0FBQyxDQUFDNHhHLFNBQVMsQ0FBQ3RnQztRQUM1QnR4RSxJQUFJeUYsSUFBSSxHQUFHQTtRQUNYekYsSUFBSVQsT0FBTztJQUNiO0lBQ0FtZCxRQUFRO1FBQ04sSUFBSyxNQUFNNDBELFNBQVMsSUFBSSxDQUFDLENBQUNGLElBQUksQ0FBRTtZQUM5QixNQUFNLEVBQ0ozckUsSUFBSSxFQUNMLEdBQUcsSUFBSSxDQUFDLENBQUMyckUsSUFBSSxDQUFDRSxNQUFNO1lBQ3JCN3JFLE1BQU13VixRQUFRNVk7UUFDaEI7UUFDQSxJQUFJLENBQUMsQ0FBQyt1RSxJQUFJLEdBQUc3NUUsT0FBTytMLE1BQU0sQ0FBQztJQUM3QjtJQUNBLENBQUMsQ0FBQzJLLE9BQU9oVSxRQUFRLENBQUMsR0FBRztRQUNuQixJQUFLLE1BQU1xM0UsU0FBUyxJQUFJLENBQUMsQ0FBQ0YsSUFBSSxDQUFFO1lBQzlCLE1BQU0sRUFDSjNyRSxJQUFJLEVBQ0wsR0FBRyxJQUFJLENBQUMsQ0FBQzJyRSxJQUFJLENBQUNFLE1BQU07WUFDckIsSUFBSTdyRSxTQUFTaXNHLGNBQWM7Z0JBQ3pCO1lBQ0Y7WUFDQSxNQUFNO2dCQUFDcGdDO2dCQUFPN3JFO2FBQUs7UUFDckI7SUFDRjs7YUF2REEsQ0FBQzJyRSxJQUFJLEdBQUc3NUUsT0FBTytMLE1BQU0sQ0FBQzs7QUF3RHhCO0VBRUMsOEJBQThCO0FBWS9CLE1BQU11dUcsMEJBQTBCO0FBQ2hDLE1BQU1DLG9CQUFvQjtBQUMxQixNQUFNQztJQUNKLENBQUN4OEIsVUFBVSxDQUEyQjtJQUN0QyxDQUFDdGlDLFNBQVMsQ0FBUTtJQUNsQixDQUFDKytELG1CQUFtQixDQUFTO0lBQzdCLENBQUNDLG9CQUFvQixDQUF1QztJQUM1RCxDQUFDQyxJQUFJLENBQVE7SUFDYixDQUFDQyxnQkFBZ0IsQ0FBUTtJQUN6QixDQUFDem5FLFVBQVUsQ0FBSztJQUNoQixDQUFDRCxTQUFTLENBQUs7SUFDZixDQUFDdStELE1BQU0sQ0FBUTtJQUNmLENBQUNvSixhQUFhLENBQVE7SUFDdEIsQ0FBQzNvRSxRQUFRLENBQUs7SUFDZCxDQUFDRCxLQUFLLENBQUs7SUFDWCxDQUFDNm9FLFVBQVUsQ0FBdUI7SUFDbEMsQ0FBQ0MsbUJBQW1CLENBQU07SUFDMUIsQ0FBQ0MsaUJBQWlCLENBQVE7SUFDMUIsQ0FBQ2pyRSxRQUFRLENBQU07SUFDZixDQUFDa3JFLGlCQUFpQixDQUFpQjtJQUNuQyxDQUFDM2dGLFNBQVMsQ0FBUTtJQUNsQixPQUFPLENBQUM0Z0YsV0FBVyxHQUFHLElBQUlyd0UsTUFBTTtJQUNoQyxPQUFPLENBQUNzd0UsY0FBYyxHQUFHLElBQUl0d0UsTUFBTTtJQUNuQyxPQUFPLENBQUN1d0UsY0FBYyxHQUFHLElBQUluMUcsVUFBVTtJQUN2QyxPQUFPLENBQUNvMUcsV0FBVyxHQUFHLEtBQUs7SUFDM0IsT0FBTyxDQUFDQyxpQkFBaUIsR0FBRyxJQUFJM2xHLE1BQU07SUFDdEM1VSxZQUFZLEVBQ1ZpNkcsaUJBQWlCLEVBQ2pCdC9ELFNBQVMsRUFDVDVMLFFBQVEsRUFDVCxDQUFFO2FBM0JILENBQUNrdUMsVUFBVSxHQUFHeDJFLFFBQVErUSxhQUFhO2FBQ25DLENBQUNtakMsU0FBUyxHQUFHO2FBQ2IsQ0FBQysrRCxtQkFBbUIsR0FBRzthQUN2QixDQUFDQyxvQkFBb0IsR0FBRyxDQUFDLENBQUM1NEcsV0FBV3k1RyxhQUFhLEVBQUVoK0M7YUFDcEQsQ0FBQ285QyxJQUFJLEdBQUc7YUFDUixDQUFDQyxnQkFBZ0IsR0FBRzthQUNwQixDQUFDem5FLFVBQVUsR0FBRzthQUNkLENBQUNELFNBQVMsR0FBRzthQUNiLENBQUN1K0QsTUFBTSxHQUFHO2FBQ1YsQ0FBQ29KLGFBQWEsR0FBRzthQUNqQixDQUFDM29FLFFBQVEsR0FBRzthQUNaLENBQUNELEtBQUssR0FBRzthQUNULENBQUM2b0UsVUFBVSxHQUFHOTZHLE9BQU8rTCxNQUFNLENBQUM7YUFDNUIsQ0FBQ2d2RyxtQkFBbUIsR0FBRyxFQUFFO2FBQ3pCLENBQUNDLGlCQUFpQixHQUFHO2FBQ3JCLENBQUNqckUsUUFBUSxHQUFHLEVBQUU7YUFDZCxDQUFDa3JFLGlCQUFpQixHQUFHLElBQUloMUc7YUFDekIsQ0FBQ3EwQixTQUFTLEdBQUc7UUFXWCxJQUFJMGdGLDZCQUE2QnQ4QixnQkFBZ0I7WUFDL0MsSUFBSSxDQUFDLENBQUNzOEIsaUJBQWlCLEdBQUdBO1FBQzVCLE9BQU8sSUFBSSxPQUFPQSxzQkFBc0IsVUFBVTtZQUNoRCxJQUFJLENBQUMsQ0FBQ0EsaUJBQWlCLEdBQUcsSUFBSXQ4QixlQUFlO2dCQUMzQ2wxRCxPQUFNbTFELFVBQVU7b0JBQ2RBLFdBQVdXLE9BQU8sQ0FBQzA3QjtvQkFDbkJyOEIsV0FBVzd6RSxLQUFLO2dCQUNsQjtZQUNGO1FBQ0YsT0FBTztZQUNMLE1BQU0sSUFBSWdSLE1BQU07UUFDbEI7UUFDQSxJQUFJLENBQUMsQ0FBQzQvQixTQUFTLEdBQUcsSUFBSSxDQUFDLENBQUNtL0QsYUFBYSxHQUFHbi9EO1FBQ3hDLElBQUksQ0FBQyxDQUFDekosS0FBSyxHQUFHbkMsU0FBU21DLEtBQUssR0FBR2lHLFlBQVlDLFVBQVU7UUFDckQsSUFBSSxDQUFDLENBQUNqRyxRQUFRLEdBQUdwQyxTQUFTb0MsUUFBUTtRQUNsQyxJQUFJLENBQUMsQ0FBQzBvRSxnQkFBZ0IsR0FBRztZQUN2Qi9xRSxLQUFLO1lBQ0w2ckQsWUFBWTtZQUNacGtELEtBQUs7UUFDUDtRQUNBLE1BQU0sRUFDSnBFLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxLQUFLLEVBQ0xDLEtBQUssRUFDTixHQUFHdkQsU0FBU2tELE9BQU87UUFDcEIsSUFBSSxDQUFDLENBQUMxWSxTQUFTLEdBQUc7WUFBQztZQUFHO1lBQUc7WUFBRyxDQUFDO1lBQUcsQ0FBQzhZO1lBQU9DLFFBQVFGO1NBQVc7UUFDM0QsSUFBSSxDQUFDLENBQUNELFNBQVMsR0FBR0E7UUFDbEIsSUFBSSxDQUFDLENBQUNDLFVBQVUsR0FBR0E7UUFDbkJxbkUsVUFBVSxDQUFDZ0IseUJBQXlCO1FBQ3BDOWpFLG1CQUFtQmdFLFdBQVc1TDtRQUM5QixJQUFJLENBQUMsQ0FBQ2t1QyxVQUFVLENBQUMvMUUsT0FBTyxDQUFDd3pHLE9BQU8sQ0FBQztZQUMvQmpCLFVBQVUsQ0FBQ2MsaUJBQWlCLENBQUNuOEQsTUFBTSxDQUFDLElBQUk7WUFDeEMsSUFBSSxDQUFDLENBQUN5N0QsZ0JBQWdCLEdBQUc7WUFDekIsSUFBSSxDQUFDLENBQUNFLFVBQVUsR0FBRztRQUNyQixHQUFHbDZCLEtBQUssQ0FBQyxLQUFPO0lBQ2xCO0lBQ0EsV0FBVzg2QixnQkFBZ0I7UUFDekIsTUFBTSxFQUNKbDRFLFNBQVMsRUFDVEMsU0FBUyxFQUNWLEdBQUdWLGlCQUFpQkssUUFBUTtRQUM3QixPQUFPakMsT0FBTyxJQUFJLEVBQUUsaUJBQWlCLElBQUkwSixJQUFJO1lBQUM7Z0JBQUM7Z0JBQWMsQ0FBQyxFQUFFckgsYUFBYUMsWUFBWSxjQUFjLEdBQUcsVUFBVSxDQUFDO2FBQUM7WUFBRTtnQkFBQztnQkFBYSxDQUFDLEVBQUVELGFBQWFDLFlBQVkscUJBQXFCLEdBQUcsU0FBUyxDQUFDO2FBQUM7U0FBQztJQUN4TTtJQUNBNkwsU0FBUztRQUNQLE1BQU1xc0UsT0FBTztZQUNYLElBQUksQ0FBQyxDQUFDbEssTUFBTSxDQUFDNW5HLElBQUksR0FBR3k0QyxJQUFJLENBQUMsQ0FBQyxFQUN4QjFqRCxLQUFLLEVBQ0xpRSxJQUFJLEVBQ0w7Z0JBQ0MsSUFBSUEsTUFBTTtvQkFDUixJQUFJLENBQUMsQ0FBQ203RSxVQUFVLENBQUNoMkUsT0FBTztvQkFDeEI7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDLENBQUMyeUcsSUFBSSxLQUFLLzdHLE1BQU0rN0csSUFBSTtnQkFDekIzNkcsT0FBT2t2QyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM0ckUsVUFBVSxFQUFFbDhHLE1BQU0wdUMsTUFBTTtnQkFDNUMsSUFBSSxDQUFDLENBQUNzdUUsWUFBWSxDQUFDaDlHLE1BQU13UyxLQUFLO2dCQUM5QnVxRztZQUNGLEdBQUcsSUFBSSxDQUFDLENBQUMzOUIsVUFBVSxDQUFDajJFLE1BQU07UUFDNUI7UUFDQSxJQUFJLENBQUMsQ0FBQzBwRyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUN1SixpQkFBaUIsQ0FBQzVFLFNBQVM7UUFDaERvRSxVQUFVLENBQUNjLGlCQUFpQixDQUFDOW5HLEdBQUcsQ0FBQyxJQUFJO1FBQ3JDbW9HO1FBQ0EsT0FBTyxJQUFJLENBQUMsQ0FBQzM5QixVQUFVLENBQUMvMUUsT0FBTztJQUNqQztJQUNBc29DLE9BQU8sRUFDTFQsUUFBUSxFQUNSK3JFLFdBQVcsSUFBSSxFQUNoQixFQUFFO1FBQ0QsTUFBTTVwRSxRQUFRbkMsU0FBU21DLEtBQUssR0FBR2lHLFlBQVlDLFVBQVU7UUFDckQsTUFBTWpHLFdBQVdwQyxTQUFTb0MsUUFBUTtRQUNsQyxJQUFJQSxhQUFhLElBQUksQ0FBQyxDQUFDQSxRQUFRLEVBQUU7WUFDL0IycEU7WUFDQSxJQUFJLENBQUMsQ0FBQzNwRSxRQUFRLEdBQUdBO1lBQ2pCd0YsbUJBQW1CLElBQUksQ0FBQyxDQUFDbWpFLGFBQWEsRUFBRTtnQkFDdEMzb0U7WUFDRjtRQUNGO1FBQ0EsSUFBSUQsVUFBVSxJQUFJLENBQUMsQ0FBQ0EsS0FBSyxFQUFFO1lBQ3pCNHBFO1lBQ0EsSUFBSSxDQUFDLENBQUM1cEUsS0FBSyxHQUFHQTtZQUNkLE1BQU1yNkIsU0FBUztnQkFDYmk0QixLQUFLO2dCQUNMNnJELFlBQVk7Z0JBQ1pwa0QsS0FBS2tqRSxVQUFVLENBQUNzQixNQUFNLENBQUMsSUFBSSxDQUFDLENBQUNuQixJQUFJO1lBQ25DO1lBQ0EsS0FBSyxNQUFNOXFFLE9BQU8sSUFBSSxDQUFDLENBQUNFLFFBQVEsQ0FBRTtnQkFDaENuNEIsT0FBTzhqRixVQUFVLEdBQUcsSUFBSSxDQUFDLENBQUN1ZixpQkFBaUIsQ0FBQ3I3RyxHQUFHLENBQUNpd0M7Z0JBQ2hEajRCLE9BQU9pNEIsR0FBRyxHQUFHQTtnQkFDYixJQUFJLENBQUMsQ0FBQ2tzRSxNQUFNLENBQUNua0c7WUFDZjtRQUNGO0lBQ0Y7SUFDQTBsRCxTQUFTO1FBQ1AsTUFBTTArQyxVQUFVLElBQUloNkUsZUFBZTtRQUNuQyxJQUFJLENBQUMsQ0FBQ3l2RSxNQUFNLEVBQUVuMEMsT0FBTzArQyxTQUFTcDdCLE1BQU0sS0FBTztRQUMzQyxJQUFJLENBQUMsQ0FBQzZ3QixNQUFNLEdBQUc7UUFDZixJQUFJLENBQUMsQ0FBQ3p6QixVQUFVLENBQUNqMkUsTUFBTSxDQUFDaTBHO0lBQzFCO0lBQ0EsSUFBSWpzRSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsUUFBUTtJQUN2QjtJQUNBLElBQUlnckUsc0JBQXNCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLENBQUNBLG1CQUFtQjtJQUNsQztJQUNBLENBQUNhLFlBQVksQ0FBQ3hxRyxLQUFLO1FBQ2pCLElBQUksSUFBSSxDQUFDLENBQUNxcEcsbUJBQW1CLEVBQUU7WUFDN0I7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDRyxnQkFBZ0IsQ0FBQ3RqRSxHQUFHLEtBQUtrakUsVUFBVSxDQUFDc0IsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDbkIsSUFBSTtRQUMzRCxNQUFNNXFFLFdBQVcsSUFBSSxDQUFDLENBQUNBLFFBQVEsRUFDN0JnckUsc0JBQXNCLElBQUksQ0FBQyxDQUFDQSxtQkFBbUI7UUFDakQsS0FBSyxNQUFNcm1HLFFBQVF0RCxNQUFPO1lBQ3hCLElBQUkyK0IsU0FBU3B5QyxNQUFNLEdBQUcyOEcseUJBQXlCO2dCQUM3Q3A2RSxLQUFLO2dCQUNMLElBQUksQ0FBQyxDQUFDdTZFLG1CQUFtQixHQUFHO2dCQUM1QjtZQUNGO1lBQ0EsSUFBSS9sRyxLQUFLNnRCLEdBQUcsS0FBS3JoQyxXQUFXO2dCQUMxQixJQUFJd1QsS0FBS3BPLElBQUksS0FBSyw2QkFBNkJvTyxLQUFLcE8sSUFBSSxLQUFLLHNCQUFzQjtvQkFDakYsTUFBTTJwQyxTQUFTLElBQUksQ0FBQyxDQUFDeUwsU0FBUztvQkFDOUIsSUFBSSxDQUFDLENBQUNBLFNBQVMsR0FBR2h3QyxTQUFTMkksYUFBYSxDQUFDO29CQUN6QyxJQUFJLENBQUMsQ0FBQ3FuQyxTQUFTLENBQUM5QixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO29CQUM5QixJQUFJa0IsS0FBS3BDLEVBQUUsRUFBRTt3QkFDWCxJQUFJLENBQUMsQ0FBQ29wQyxTQUFTLENBQUNwTixZQUFZLENBQUMsTUFBTSxDQUFDLEVBQUU1NUIsS0FBS3BDLEVBQUUsQ0FBQyxDQUFDO29CQUNqRDtvQkFDQTI5QixPQUFPeDRCLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQ2lrQyxTQUFTO2dCQUMvQixPQUFPLElBQUlobkMsS0FBS3BPLElBQUksS0FBSyxvQkFBb0I7b0JBQzNDLElBQUksQ0FBQyxDQUFDbzFDLFNBQVMsR0FBRyxJQUFJLENBQUMsQ0FBQ0EsU0FBUyxDQUFDaWlCLFVBQVU7Z0JBQzlDO2dCQUNBO1lBQ0Y7WUFDQW85QyxvQkFBb0JueUcsSUFBSSxDQUFDOEwsS0FBSzZ0QixHQUFHO1lBQ2pDLElBQUksQ0FBQyxDQUFDMDVFLFVBQVUsQ0FBQ3ZuRztRQUNuQjtJQUNGO0lBQ0EsQ0FBQ3VuRyxVQUFVLENBQUNDLElBQUk7UUFDZCxNQUFNQyxVQUFVendHLFNBQVMySSxhQUFhLENBQUM7UUFDdkMsTUFBTTRtRyxvQkFBb0I7WUFDeEJ0eUMsT0FBTztZQUNQMGUsYUFBYTtZQUNiKzBCLFNBQVNGLEtBQUszNUUsR0FBRyxLQUFLO1lBQ3RCODVFLFFBQVFILEtBQUtHLE1BQU07WUFDbkJ2akIsVUFBVTtRQUNaO1FBQ0EsSUFBSSxDQUFDLENBQUMvb0QsUUFBUSxDQUFDbm5DLElBQUksQ0FBQ3V6RztRQUNwQixNQUFNbmlELEtBQUtqMkIsS0FBS3pKLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQ0EsU0FBUyxFQUFFNGhGLEtBQUs1aEYsU0FBUztRQUN6RCxJQUFJcXVDLFFBQVF4a0UsS0FBS200RyxLQUFLLENBQUN0aUQsRUFBRSxDQUFDLEVBQUUsRUFBRUEsRUFBRSxDQUFDLEVBQUU7UUFDbkMsTUFBTTN1RCxRQUFRLElBQUksQ0FBQyxDQUFDeXZHLFVBQVUsQ0FBQ29CLEtBQUtLLFFBQVEsQ0FBQztRQUM3QyxJQUFJbHhHLE1BQU1xdkUsUUFBUSxFQUFFO1lBQ2xCL1IsU0FBU3hrRSxLQUFLMDBCLEVBQUUsR0FBRztRQUNyQjtRQUNBLElBQUlpZ0QsYUFBYSxJQUFJLENBQUMsQ0FBQzRoQyxvQkFBb0IsSUFBSXJ2RyxNQUFNbXhHLGdCQUFnQixJQUFJbnhHLE1BQU15dEUsVUFBVTtRQUN6RkEsYUFBYTBoQyxVQUFVa0IsYUFBYSxDQUFDOTdHLEdBQUcsQ0FBQ2s1RSxlQUFlQTtRQUN4RCxNQUFNMmpDLGFBQWF0NEcsS0FBS3ErRCxLQUFLLENBQUN4SSxFQUFFLENBQUMsRUFBRSxFQUFFQSxFQUFFLENBQUMsRUFBRTtRQUMxQyxNQUFNMGlELGFBQWFELGFBQWFqQyxVQUFVLENBQUNtQyxTQUFTLENBQUM3akMsWUFBWXp0RSxPQUFPLElBQUksQ0FBQyxDQUFDc3ZHLElBQUk7UUFDbEYsSUFBSXZ5QyxNQUFNL3BCO1FBQ1YsSUFBSXNxQixVQUFVLEdBQUc7WUFDZlAsT0FBT3BPLEVBQUUsQ0FBQyxFQUFFO1lBQ1ozYixNQUFNMmIsRUFBRSxDQUFDLEVBQUUsR0FBRzBpRDtRQUNoQixPQUFPO1lBQ0x0MEMsT0FBT3BPLEVBQUUsQ0FBQyxFQUFFLEdBQUcwaUQsYUFBYXY0RyxLQUFLeTRHLEdBQUcsQ0FBQ2owQztZQUNyQ3RxQixNQUFNMmIsRUFBRSxDQUFDLEVBQUUsR0FBRzBpRCxhQUFhdjRHLEtBQUswNEcsR0FBRyxDQUFDbDBDO1FBQ3RDO1FBQ0EsTUFBTW0wQyxpQkFBaUI7UUFDdkIsTUFBTUMsV0FBV1osUUFBUTl3RyxLQUFLO1FBQzlCLElBQUksSUFBSSxDQUFDLENBQUNxd0MsU0FBUyxLQUFLLElBQUksQ0FBQyxDQUFDbS9ELGFBQWEsRUFBRTtZQUMzQ2tDLFNBQVMzMEMsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU1BLE9BQU8sSUFBSSxDQUFDLENBQUNsMUIsU0FBUyxFQUFFbTFCLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMvRDAwQyxTQUFTMStELEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNQSxNQUFNLElBQUksQ0FBQyxDQUFDbEwsVUFBVSxFQUFFazFCLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNoRSxPQUFPO1lBQ0wwMEMsU0FBUzMwQyxJQUFJLEdBQUcsQ0FBQyxFQUFFMDBDLGVBQWUsRUFBRTEwQyxLQUFLQyxPQUFPLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDeEQwMEMsU0FBUzErRCxHQUFHLEdBQUcsQ0FBQyxFQUFFeStELGVBQWUsRUFBRXorRCxJQUFJZ3FCLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUN4RDtRQUNBMDBDLFNBQVNqa0IsUUFBUSxHQUFHLENBQUMsRUFBRWdrQixlQUFlLEVBQUUsQ0FBQ3RDLFVBQVUsQ0FBQ2EsV0FBVyxHQUFHb0IsVUFBUyxFQUFHcDBDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUM3RjAwQyxTQUFTamtDLFVBQVUsR0FBR0E7UUFDdEJtaUMsa0JBQWtCbmlCLFFBQVEsR0FBRzJqQjtRQUM3Qk4sUUFBUTd0RSxZQUFZLENBQUMsUUFBUTtRQUM3QjZ0RSxRQUFRL3VFLFdBQVcsR0FBRzh1RSxLQUFLMzVFLEdBQUc7UUFDOUI0NUUsUUFBUTNnRSxHQUFHLEdBQUcwZ0UsS0FBSzFnRSxHQUFHO1FBQ3RCLElBQUksSUFBSSxDQUFDLENBQUNrL0Qsb0JBQW9CLEVBQUU7WUFDOUJ5QixRQUFRYSxPQUFPLENBQUNULFFBQVEsR0FBR2x4RyxNQUFNNHhHLDBCQUEwQixJQUFJZixLQUFLSyxRQUFRO1FBQzlFO1FBQ0EsSUFBSTV6QyxVQUFVLEdBQUc7WUFDZnN5QyxrQkFBa0J0eUMsS0FBSyxHQUFHQSxRQUFTLE9BQU14a0UsS0FBSzAwQixFQUFFO1FBQ2xEO1FBQ0EsSUFBSXFrRixrQkFBa0I7UUFDdEIsSUFBSWhCLEtBQUszNUUsR0FBRyxDQUFDNWtDLE1BQU0sR0FBRyxHQUFHO1lBQ3ZCdS9HLGtCQUFrQjtRQUNwQixPQUFPLElBQUloQixLQUFLMzVFLEdBQUcsS0FBSyxPQUFPMjVFLEtBQUs1aEYsU0FBUyxDQUFDLEVBQUUsS0FBSzRoRixLQUFLNWhGLFNBQVMsQ0FBQyxFQUFFLEVBQUU7WUFDdEUsTUFBTTZpRixZQUFZaDVHLEtBQUsrTCxHQUFHLENBQUNnc0csS0FBSzVoRixTQUFTLENBQUMsRUFBRSxHQUMxQzhpRixZQUFZajVHLEtBQUsrTCxHQUFHLENBQUNnc0csS0FBSzVoRixTQUFTLENBQUMsRUFBRTtZQUN4QyxJQUFJNmlGLGNBQWNDLGFBQWFqNUcsS0FBSzRQLEdBQUcsQ0FBQ29wRyxXQUFXQyxhQUFhajVHLEtBQUttRixHQUFHLENBQUM2ekcsV0FBV0MsYUFBYSxLQUFLO2dCQUNwR0Ysa0JBQWtCO1lBQ3BCO1FBQ0Y7UUFDQSxJQUFJQSxpQkFBaUI7WUFDbkJqQyxrQkFBa0I1ekIsV0FBVyxHQUFHaDhFLE1BQU1xdkUsUUFBUSxHQUFHd2hDLEtBQUtucEUsTUFBTSxHQUFHbXBFLEtBQUtwcEUsS0FBSztRQUMzRTtRQUNBLElBQUksQ0FBQyxDQUFDbW9FLGlCQUFpQixDQUFDLzBHLEdBQUcsQ0FBQ2kyRyxTQUFTbEI7UUFDckMsSUFBSSxDQUFDLENBQUNMLGdCQUFnQixDQUFDL3FFLEdBQUcsR0FBR3NzRTtRQUM3QixJQUFJLENBQUMsQ0FBQ3ZCLGdCQUFnQixDQUFDbGYsVUFBVSxHQUFHdWY7UUFDcEMsSUFBSSxDQUFDLENBQUNjLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQ25CLGdCQUFnQjtRQUNuQyxJQUFJSyxrQkFBa0JtQixPQUFPLEVBQUU7WUFDN0IsSUFBSSxDQUFDLENBQUMxZ0UsU0FBUyxDQUFDamtDLE1BQU0sQ0FBQzBrRztRQUN6QjtRQUNBLElBQUlsQixrQkFBa0JvQixNQUFNLEVBQUU7WUFDNUIsTUFBTWdCLEtBQUszeEcsU0FBUzJJLGFBQWEsQ0FBQztZQUNsQ2dwRyxHQUFHL3VFLFlBQVksQ0FBQyxRQUFRO1lBQ3hCLElBQUksQ0FBQyxDQUFDb04sU0FBUyxDQUFDamtDLE1BQU0sQ0FBQzRsRztRQUN6QjtJQUNGO0lBQ0EsQ0FBQ3RCLE1BQU0sQ0FBQ25rRyxNQUFNO1FBQ1osTUFBTSxFQUNKaTRCLEdBQUcsRUFDSDZyRCxVQUFVLEVBQ1Zwa0QsR0FBRyxFQUNKLEdBQUcxL0I7UUFDSixNQUFNLEVBQ0p2TSxLQUFLLEVBQ04sR0FBR3drQztRQUNKLElBQUl2VixZQUFZO1FBQ2hCLElBQUlrZ0YsVUFBVSxDQUFDYSxXQUFXLEdBQUcsR0FBRztZQUM5Qi9nRixZQUFZLENBQUMsTUFBTSxFQUFFLElBQUlrZ0YsVUFBVSxDQUFDYSxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQ3BEO1FBQ0EsSUFBSTNmLFdBQVdyVSxXQUFXLEtBQUssS0FBS3FVLFdBQVcwZ0IsT0FBTyxFQUFFO1lBQ3RELE1BQU0sRUFDSnRqQyxVQUFVLEVBQ1gsR0FBR3p0RTtZQUNKLE1BQU0sRUFDSmc4RSxXQUFXLEVBQ1h5UixRQUFRLEVBQ1QsR0FBRzRDO1lBQ0o4ZSxVQUFVLENBQUM4QyxhQUFhLENBQUNobUUsS0FBS3doRCxXQUFXLElBQUksQ0FBQyxDQUFDN21ELEtBQUssRUFBRTZtQztZQUN0RCxNQUFNLEVBQ0pobUMsS0FBSyxFQUNOLEdBQUd3RSxJQUFJMHRELFdBQVcsQ0FBQ24xRCxJQUFJekMsV0FBVztZQUNuQyxJQUFJMEYsUUFBUSxHQUFHO2dCQUNieFksWUFBWSxDQUFDLE9BQU8sRUFBRStzRCxjQUFjLElBQUksQ0FBQyxDQUFDcDFDLEtBQUssR0FBR2EsTUFBTSxFQUFFLEVBQUV4WSxVQUFVLENBQUM7WUFDekU7UUFDRjtRQUNBLElBQUlvaEUsV0FBVy95QixLQUFLLEtBQUssR0FBRztZQUMxQnJ1QyxZQUFZLENBQUMsT0FBTyxFQUFFb2hFLFdBQVcveUIsS0FBSyxDQUFDLEtBQUssRUFBRXJ1QyxVQUFVLENBQUM7UUFDM0Q7UUFDQSxJQUFJQSxVQUFVMzhCLE1BQU0sR0FBRyxHQUFHO1lBQ3hCME4sTUFBTWl2QixTQUFTLEdBQUdBO1FBQ3BCO0lBQ0Y7SUFDQSxPQUFPaWpGLFVBQVU7UUFDZixJQUFJLElBQUksQ0FBQyxDQUFDakMsaUJBQWlCLENBQUMzb0csSUFBSSxHQUFHLEdBQUc7WUFDcEM7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDdW9HLFdBQVcsQ0FBQy8xRixLQUFLO1FBQ3ZCLEtBQUssTUFBTSxFQUNUODhCLE1BQU0sRUFDUCxJQUFJLElBQUksQ0FBQyxDQUFDazVELGNBQWMsQ0FBQzEyRixNQUFNLEdBQUk7WUFDbEN3OUIsT0FBT2x2QyxNQUFNO1FBQ2Y7UUFDQSxJQUFJLENBQUMsQ0FBQ29vRyxjQUFjLENBQUNoMkYsS0FBSztJQUM1QjtJQUNBLE9BQU8sQ0FBQzIyRixNQUFNLENBQUNuQixPQUFPLElBQUk7UUFDeEIsSUFBSXJqRSxNQUFNLElBQUksQ0FBQyxDQUFDNmpFLGNBQWMsQ0FBQ3Y3RyxHQUFHLENBQUMrNkcsU0FBUztRQUM1QyxJQUFJLENBQUNyakUsS0FBSztZQUNSLE1BQU0ySyxTQUFTdjJDLFNBQVMySSxhQUFhLENBQUM7WUFDdEM0dEMsT0FBT3hHLFNBQVMsR0FBRztZQUNuQndHLE9BQU8wNEQsSUFBSSxHQUFHQTtZQUNkanZHLFNBQVN3ckMsSUFBSSxDQUFDei9CLE1BQU0sQ0FBQ3dxQztZQUNyQjNLLE1BQU0ySyxPQUFPQyxVQUFVLENBQUMsTUFBTTtnQkFDNUJzN0QsT0FBTztnQkFDUHI3RCxvQkFBb0I7WUFDdEI7WUFDQSxJQUFJLENBQUMsQ0FBQ2c1RCxjQUFjLENBQUNqMUcsR0FBRyxDQUFDeTBHLE1BQU1yakU7WUFDL0IsSUFBSSxDQUFDLENBQUM4akUsY0FBYyxDQUFDbDFHLEdBQUcsQ0FBQ294QyxLQUFLO2dCQUM1QjNrQyxNQUFNO2dCQUNOMGtFLFFBQVE7WUFDVjtRQUNGO1FBQ0EsT0FBTy8vQjtJQUNUO0lBQ0EsT0FBTyxDQUFDZ21FLGFBQWEsQ0FBQ2htRSxHQUFHLEVBQUUza0MsSUFBSSxFQUFFMGtFLE1BQU07UUFDckMsTUFBTW9tQyxTQUFTLElBQUksQ0FBQyxDQUFDckMsY0FBYyxDQUFDeDdHLEdBQUcsQ0FBQzAzQztRQUN4QyxJQUFJM2tDLFNBQVM4cUcsT0FBTzlxRyxJQUFJLElBQUkwa0UsV0FBV29tQyxPQUFPcG1DLE1BQU0sRUFBRTtZQUNwRDtRQUNGO1FBQ0EvL0IsSUFBSTAvQixJQUFJLEdBQUcsQ0FBQyxFQUFFcmtFLEtBQUssR0FBRyxFQUFFMGtFLE9BQU8sQ0FBQztRQUNoQ29tQyxPQUFPOXFHLElBQUksR0FBR0E7UUFDZDhxRyxPQUFPcG1DLE1BQU0sR0FBR0E7SUFDbEI7SUFDQSxPQUFPLENBQUNta0MseUJBQXlCO1FBQy9CLElBQUksSUFBSSxDQUFDLENBQUNILFdBQVcsS0FBSyxNQUFNO1lBQzlCO1FBQ0Y7UUFDQSxNQUFNeHJFLE1BQU1ua0MsU0FBUzJJLGFBQWEsQ0FBQztRQUNuQ3c3QixJQUFJeGtDLEtBQUssQ0FBQ3l1QyxPQUFPLEdBQUc7UUFDcEJqSyxJQUFJeGtDLEtBQUssQ0FBQ3F5RyxVQUFVLEdBQUc7UUFDdkI3dEUsSUFBSXhrQyxLQUFLLENBQUN5dEYsUUFBUSxHQUFHO1FBQ3JCanBELElBQUl4a0MsS0FBSyxDQUFDNHlDLFFBQVEsR0FBRztRQUNyQnBPLElBQUl6QyxXQUFXLEdBQUc7UUFDbEIxaEMsU0FBU3dyQyxJQUFJLENBQUN6L0IsTUFBTSxDQUFDbzRCO1FBQ3JCLElBQUksQ0FBQyxDQUFDd3JFLFdBQVcsR0FBR3hyRSxJQUFJNmYscUJBQXFCLEdBQUczYyxNQUFNO1FBQ3REbEQsSUFBSTk4QixNQUFNO0lBQ1o7SUFDQSxPQUFPLENBQUM0cEcsU0FBUyxDQUFDN2pDLFVBQVUsRUFBRXp0RSxLQUFLLEVBQUVzdkcsSUFBSTtRQUN2QyxNQUFNZ0QsZUFBZSxJQUFJLENBQUMsQ0FBQ3pDLFdBQVcsQ0FBQ3Q3RyxHQUFHLENBQUNrNUU7UUFDM0MsSUFBSTZrQyxjQUFjO1lBQ2hCLE9BQU9BO1FBQ1Q7UUFDQSxNQUFNcm1FLE1BQU0sSUFBSSxDQUFDLENBQUN3a0UsTUFBTSxDQUFDbkI7UUFDekJyakUsSUFBSTJLLE1BQU0sQ0FBQ25QLEtBQUssR0FBR3dFLElBQUkySyxNQUFNLENBQUNsUCxNQUFNLEdBQUd3bkU7UUFDdkMsSUFBSSxDQUFDLENBQUMrQyxhQUFhLENBQUNobUUsS0FBS2lqRSxtQkFBbUJ6aEM7UUFDNUMsTUFBTThrQyxVQUFVdG1FLElBQUkwdEQsV0FBVyxDQUFDO1FBQ2hDLE1BQU1ycUIsU0FBU2lqQyxRQUFRQyxxQkFBcUI7UUFDNUMsTUFBTWhqQyxVQUFVMTJFLEtBQUsrTCxHQUFHLENBQUMwdEcsUUFBUUUsc0JBQXNCO1FBQ3ZEeG1FLElBQUkySyxNQUFNLENBQUNuUCxLQUFLLEdBQUd3RSxJQUFJMkssTUFBTSxDQUFDbFAsTUFBTSxHQUFHO1FBQ3ZDLElBQUlnckUsUUFBUTtRQUNaLElBQUlwakMsUUFBUTtZQUNWb2pDLFFBQVFwakMsU0FBVUEsQ0FBQUEsU0FBU0UsT0FBTTtRQUNuQyxPQUFPO1lBQ0wsSUFBSTkzQyxpQkFBaUJLLFFBQVEsQ0FBQ0ssU0FBUyxFQUFFO2dCQUN2Q3ZELEtBQUsscUVBQXFFO1lBQzVFO1lBQ0EsSUFBSTcwQixNQUFNc3ZFLE1BQU0sRUFBRTtnQkFDaEJvakMsUUFBUTF5RyxNQUFNc3ZFLE1BQU07WUFDdEIsT0FBTyxJQUFJdHZFLE1BQU13dkUsT0FBTyxFQUFFO2dCQUN4QmtqQyxRQUFRLElBQUkxeUcsTUFBTXd2RSxPQUFPO1lBQzNCO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQ3FnQyxXQUFXLENBQUNoMUcsR0FBRyxDQUFDNHlFLFlBQVlpbEM7UUFDbEMsT0FBT0E7SUFDVDtBQUNGO0VBRUMsdUJBQXVCO0FBbUR4QixNQUFNQyw4QkFBOEI7QUFDcEMsU0FBU0MsWUFBWXp5RyxNQUFNLENBQUMsQ0FBQztJQUMzQixJQUFJLE9BQU9BLFFBQVEsWUFBWUEsZUFBZTRWLEtBQUs7UUFDakQ1VixNQUFNO1lBQ0o4VixLQUFLOVY7UUFDUDtJQUNGLE9BQU8sSUFBSUEsZUFBZXZFLGVBQWVBLFlBQVlnVCxNQUFNLENBQUN6TyxNQUFNO1FBQ2hFQSxNQUFNO1lBQ0owQyxNQUFNMUM7UUFDUjtJQUNGO0lBQ0EsTUFBTTB5RyxPQUFPLElBQUlDO0lBQ2pCLE1BQU0sRUFDSnI4QixLQUFLLEVBQ04sR0FBR284QjtJQUNKLE1BQU01OEYsTUFBTTlWLElBQUk4VixHQUFHLEdBQUc2NUQsV0FBVzN2RSxJQUFJOFYsR0FBRyxJQUFJO0lBQzVDLE1BQU1wVCxPQUFPMUMsSUFBSTBDLElBQUksR0FBR210RSxZQUFZN3ZFLElBQUkwQyxJQUFJLElBQUk7SUFDaEQsTUFBTW9tRyxjQUFjOW9HLElBQUk4b0csV0FBVyxJQUFJO0lBQ3ZDLE1BQU1lLGtCQUFrQjdwRyxJQUFJNnBHLGVBQWUsS0FBSztJQUNoRCxNQUFNK0ksV0FBVzV5RyxJQUFJNHlHLFFBQVEsSUFBSTtJQUNqQyxNQUFNQyxpQkFBaUI3eUcsSUFBSXl2RCxLQUFLLFlBQVlxakQsd0JBQXdCOXlHLElBQUl5dkQsS0FBSyxHQUFHO0lBQ2hGLE1BQU0yNUMsaUJBQWlCcmtHLE9BQU9zdkIsU0FBUyxDQUFDcjBCLElBQUlvcEcsY0FBYyxLQUFLcHBHLElBQUlvcEcsY0FBYyxHQUFHLElBQUlwcEcsSUFBSW9wRyxjQUFjLEdBQUcsS0FBSztJQUNsSCxJQUFJMkosU0FBUy95RyxJQUFJK3lHLE1BQU0sWUFBWUMsWUFBWWh6RyxJQUFJK3lHLE1BQU0sR0FBRztJQUM1RCxNQUFNNytFLFlBQVlsMEIsSUFBSWswQixTQUFTO0lBQy9CLE1BQU0rK0UsYUFBYSxPQUFPanpHLElBQUlpekcsVUFBVSxLQUFLLFlBQVksQ0FBQzVxRSxhQUFhcm9DLElBQUlpekcsVUFBVSxJQUFJanpHLElBQUlpekcsVUFBVSxHQUFHO0lBQzFHLE1BQU1DLFVBQVVsakMsa0JBQWtCaHdFLElBQUlrekcsT0FBTztJQUM3QyxNQUFNQyxhQUFhbnpHLElBQUltekcsVUFBVSxLQUFLO0lBQ3RDLE1BQU1DLG9CQUFvQnB6RyxJQUFJb3pHLGlCQUFpQixJQUFLeHVGLENBQUFBLFdBQVdvMUQsd0JBQXdCM0Usb0JBQW1CO0lBQzFHLE1BQU1nK0IsU0FBU3JqQyxrQkFBa0Jod0UsSUFBSXF6RyxNQUFNO0lBQzNDLE1BQU1DLHNCQUFzQnRqQyxrQkFBa0Jod0UsSUFBSXN6RyxtQkFBbUI7SUFDckUsTUFBTUMsMEJBQTBCdnpHLElBQUl1ekcsdUJBQXVCLElBQUszdUYsQ0FBQUEsV0FBV3ExRCw4QkFBOEJmLDBCQUF5QjtJQUNsSSxNQUFNczZCLFVBQVV4akMsa0JBQWtCaHdFLElBQUl3ekcsT0FBTztJQUM3QyxNQUFNQyxjQUFjenpHLElBQUl5ekcsV0FBVyxJQUFLN3VGLENBQUFBLFdBQVdzMUQsa0JBQWtCZCxjQUFhO0lBQ2xGLE1BQU1zNkIsZUFBZTF6RyxJQUFJMnpHLFlBQVksS0FBSztJQUMxQyxNQUFNQyxlQUFlN3VHLE9BQU9zdkIsU0FBUyxDQUFDcjBCLElBQUk0ekcsWUFBWSxLQUFLNXpHLElBQUk0ekcsWUFBWSxHQUFHLENBQUMsSUFBSTV6RyxJQUFJNHpHLFlBQVksR0FBRyxDQUFDO0lBQ3ZHLE1BQU10OEUsa0JBQWtCdDNCLElBQUlzM0IsZUFBZSxLQUFLO0lBQ2hELE1BQU1FLDZCQUE2QixPQUFPeDNCLElBQUl3M0IsMEJBQTBCLEtBQUssWUFBWXgzQixJQUFJdzNCLDBCQUEwQixHQUFHLENBQUM1UztJQUMzSCxNQUFNOFMsMEJBQTBCLE9BQU8xM0IsSUFBSTAzQix1QkFBdUIsS0FBSyxZQUFZMTNCLElBQUkwM0IsdUJBQXVCLEdBQUcsQ0FBQzlTLFlBQWEyUyxDQUFBQSxpQkFBaUJLLFFBQVEsQ0FBQ0ssU0FBUyxJQUFJLENBQUMzaEMsV0FBV3U5RyxNQUFNO0lBQ3hMLE1BQU1DLHVCQUF1Qi91RyxPQUFPc3ZCLFNBQVMsQ0FBQ3IwQixJQUFJOHpHLG9CQUFvQixJQUFJOXpHLElBQUk4ekcsb0JBQW9CLEdBQUcsQ0FBQztJQUN0RyxNQUFNOW9DLGtCQUFrQixPQUFPaHJFLElBQUlnckUsZUFBZSxLQUFLLFlBQVlockUsSUFBSWdyRSxlQUFlLEdBQUdwbUQ7SUFDekYsTUFBTStwRCxzQkFBc0IzdUUsSUFBSTJ1RSxtQkFBbUIsS0FBSztJQUN4RCxNQUFNb2xDLFlBQVkvekcsSUFBSSt6RyxTQUFTLEtBQUs7SUFDcEMsTUFBTWpxQyxnQkFBZ0I5cEUsSUFBSThwRSxhQUFhLElBQUl4ekUsV0FBVzRKLFFBQVE7SUFDOUQsTUFBTWdrRyxlQUFlbGtHLElBQUlra0csWUFBWSxLQUFLO0lBQzFDLE1BQU1DLGdCQUFnQm5rRyxJQUFJbWtHLGFBQWEsS0FBSztJQUM1QyxNQUFNNlAsbUJBQW1CaDBHLElBQUlnMEcsZ0JBQWdCLEtBQUs7SUFDbEQsTUFBTUMsU0FBU2owRyxJQUFJaTBHLE1BQU0sS0FBSztJQUM5QixNQUFNQyxnQkFBZ0JsMEcsSUFBSWswRyxhQUFhLElBQUt0dkYsQ0FBQUEsV0FBV2sxRCxvQkFBb0IvRSxnQkFBZTtJQUMxRixNQUFNby9CLGdCQUFnQm4wRyxJQUFJbTBHLGFBQWEsSUFBS3Z2RixDQUFBQSxXQUFXaTFELG9CQUFvQjFELGdCQUFlO0lBQzFGLE1BQU14QixZQUFZMzBFLElBQUkyMEUsU0FBUyxLQUFLO0lBQ3BDLE1BQU15L0IsVUFBVXAwRyxJQUFJbzBHLE9BQU8sS0FBSztJQUNoQyxNQUFNamlILFNBQVMwZ0gsaUJBQWlCQSxlQUFlMWdILE1BQU0sR0FBRzZOLElBQUk3TixNQUFNLElBQUlzUztJQUN0RSxNQUFNNHZHLGlCQUFpQixPQUFPcjBHLElBQUlxMEcsY0FBYyxLQUFLLFlBQVlyMEcsSUFBSXEwRyxjQUFjLEdBQUcsQ0FBQ3p2RixZQUFZLENBQUNvbUQ7SUFDcEcsTUFBTXNwQyxpQkFBaUIsT0FBT3QwRyxJQUFJczBHLGNBQWMsS0FBSyxZQUFZdDBHLElBQUlzMEcsY0FBYyxHQUFHLENBQUMsQ0FBRWxCLENBQUFBLHNCQUFzQi85Qix3QkFBd0JrK0IsNEJBQTRCcjZCLDhCQUE4QnU2QixnQkFBZ0JyNkIsa0JBQWtCODVCLFdBQVdJLHVCQUF1QkUsV0FBV2x1RSxnQkFBZ0I0dEUsU0FBU2h6RyxTQUFTcWxDLE9BQU8sS0FBS0QsZ0JBQWdCZ3VFLHFCQUFxQnB6RyxTQUFTcWxDLE9BQU8sS0FBS0QsZ0JBQWdCa3VFLFNBQVN0ekcsU0FBU3FsQyxPQUFPO0lBQ2phLE1BQU13a0MsZUFBZTtJQUNyQjUxQyxrQkFBa0JEO0lBQ2xCLE1BQU1xZ0YsbUJBQW1CO1FBQ3ZCeG9CLGVBQWUsSUFBSW1vQixjQUFjO1lBQy9CcHFDO1lBQ0E2SztRQUNGO1FBQ0F4NEIsZUFBZSxJQUFJZzRELGNBQWM7WUFDL0I3OUI7WUFDQXhNO1FBQ0Y7UUFDQTBxQyxtQkFBbUJGLGlCQUFpQixPQUFPLElBQUlsQixrQkFBa0I7WUFDL0RuK0UsU0FBU2krRTtZQUNUaitCLGNBQWNrK0I7UUFDaEI7UUFDQXNCLHlCQUF5QkgsaUJBQWlCLE9BQU8sSUFBSWYsd0JBQXdCO1lBQzNFdCtFLFNBQVNxK0U7UUFDWDtRQUNBb0IsYUFBYUosaUJBQWlCLE9BQU8sSUFBSWIsWUFBWTtZQUNuRHgrRSxTQUFTdStFO1FBQ1g7SUFDRjtJQUNBLElBQUksQ0FBQ1QsUUFBUTtRQUNYQSxTQUFTQyxVQUFVenlHLE1BQU0sQ0FBQztZQUN4QjJ6QjtZQUNBc3RFLE1BQU1ELG9CQUFvQkUsVUFBVTtRQUN0QztRQUNBaVIsS0FBS2lDLE9BQU8sR0FBRzVCO0lBQ2pCO0lBQ0EsTUFBTTZCLFlBQVk7UUFDaEJ0K0I7UUFDQXUrQixZQUFZO1FBQ1pueUc7UUFDQWt3RztRQUNBb0I7UUFDQTVLO1FBQ0FqM0c7UUFDQThnSDtRQUNBYztRQUNBZSxrQkFBa0I7WUFDaEJsQjtZQUNBNW9DO1lBQ0Ewb0M7WUFDQXA4RTtZQUNBRTtZQUNBRTtZQUNBbzhFO1lBQ0FubEM7WUFDQTBsQztZQUNBRDtZQUNBRTtZQUNBcEI7WUFDQUc7WUFDQUM7WUFDQUU7UUFDRjtJQUNGO0lBQ0EsTUFBTXVCLGtCQUFrQjtRQUN0QmpyQztRQUNBbXFDO1FBQ0FscUM7UUFDQWlyQyxlQUFlO1lBQ2JoQjtZQUNBRDtRQUNGO0lBQ0Y7SUFDQWhCLE9BQU90MkcsT0FBTyxDQUFDcTZDLElBQUksQ0FBQztRQUNsQixJQUFJNDdELEtBQUt1QyxTQUFTLEVBQUU7WUFDbEIsTUFBTSxJQUFJM2tHLE1BQU07UUFDbEI7UUFDQSxJQUFJeWlHLE9BQU9rQyxTQUFTLEVBQUU7WUFDcEIsTUFBTSxJQUFJM2tHLE1BQU07UUFDbEI7UUFDQSxNQUFNNGtHLGtCQUFrQm5DLE9BQU9vQyxjQUFjLENBQUNwaUMsZUFBZSxDQUFDLGlCQUFpQjZoQyxXQUFXbHlHLE9BQU87WUFBQ0EsS0FBSzdMLE1BQU07U0FBQyxHQUFHO1FBQ2pILElBQUl1K0c7UUFDSixJQUFJdkMsZ0JBQWdCO1lBQ2xCdUMsZ0JBQWdCLElBQUlwUix1QkFBdUI2TyxnQkFBZ0I7Z0JBQ3pEM087Z0JBQ0FDO1lBQ0Y7UUFDRixPQUFPLElBQUksQ0FBQ3poRyxNQUFNO1lBQ2hCLElBQUksQ0FBQ29ULEtBQUs7Z0JBQ1IsTUFBTSxJQUFJeEYsTUFBTTtZQUNsQjtZQUNBLE1BQU0ra0csZ0JBQWdCL3ZFLGdCQUFnQnh2QixPQUFPbTBGLGlCQUFpQnJsRixXQUFXc3BGLGdCQUFnQjVCO1lBQ3pGOEksZ0JBQWdCLElBQUlDLGNBQWM7Z0JBQ2hDdi9GO2dCQUNBM2pCO2dCQUNBMjJHO2dCQUNBZTtnQkFDQVQ7Z0JBQ0FsRjtnQkFDQUM7WUFDRjtRQUNGO1FBQ0EsT0FBTytRLGdCQUFnQnArRCxJQUFJLENBQUN3K0QsQ0FBQUE7WUFDMUIsSUFBSTVDLEtBQUt1QyxTQUFTLEVBQUU7Z0JBQ2xCLE1BQU0sSUFBSTNrRyxNQUFNO1lBQ2xCO1lBQ0EsSUFBSXlpRyxPQUFPa0MsU0FBUyxFQUFFO2dCQUNwQixNQUFNLElBQUkza0csTUFBTTtZQUNsQjtZQUNBLE1BQU02a0csaUJBQWlCLElBQUl6akMsZUFBZTRFLE9BQU9nL0IsVUFBVXZDLE9BQU92UixJQUFJO1lBQ3RFLE1BQU0rVCxZQUFZLElBQUlDLGdCQUFnQkwsZ0JBQWdCekMsTUFBTTBDLGVBQWVMLGlCQUFpQlIsa0JBQWtCNS9CO1lBQzlHKzlCLEtBQUsrQyxVQUFVLEdBQUdGO1lBQ2xCSixlQUFlOXVFLElBQUksQ0FBQyxTQUFTO1FBQy9CO0lBQ0YsR0FBRyt1QyxLQUFLLENBQUNzOUIsS0FBS2dELFdBQVcsQ0FBQ241RyxNQUFNO0lBQ2hDLE9BQU9tMkc7QUFDVDtBQUNBLE1BQU1DO0lBQ0osT0FBTyxDQUFDcjhCLEtBQUssR0FBRyxFQUFFO0lBUWxCLElBQUk3NUUsVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDaTVHLFdBQVcsQ0FBQ2o1RyxPQUFPO0lBQ2pDO0lBQ0EsTUFBTXc0QyxVQUFVO1FBQ2QsSUFBSSxDQUFDZ2dFLFNBQVMsR0FBRztRQUNqQixJQUFJO1lBQ0YsSUFBSSxJQUFJLENBQUNOLE9BQU8sRUFBRW5ULE1BQU07Z0JBQ3RCLElBQUksQ0FBQ21ULE9BQU8sQ0FBQ2dCLGVBQWUsR0FBRztZQUNqQztZQUNBLE1BQU0sSUFBSSxDQUFDRixVQUFVLEVBQUV4Z0U7UUFDekIsRUFBRSxPQUFPblgsSUFBSTtZQUNYLElBQUksSUFBSSxDQUFDNjJFLE9BQU8sRUFBRW5ULE1BQU07Z0JBQ3RCLE9BQU8sSUFBSSxDQUFDbVQsT0FBTyxDQUFDZ0IsZUFBZTtZQUNyQztZQUNBLE1BQU03M0U7UUFDUjtRQUNBLElBQUksQ0FBQzIzRSxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDZCxPQUFPLEVBQUUxL0Q7UUFDZCxJQUFJLENBQUMwL0QsT0FBTyxHQUFHO0lBQ2pCO0lBQ0EsTUFBTWp5RCxVQUFVO1FBQ2QsT0FBTyxJQUFJLENBQUMreUQsVUFBVSxDQUFDL3lELE9BQU87SUFDaEM7O2FBN0JBZ3pELGNBQWMxNUcsUUFBUStRLGFBQWE7YUFDbkMwb0csYUFBYTthQUNiZCxVQUFVO2FBQ1ZyK0IsUUFBUSxDQUFDLENBQUMsRUFBRXE4Qix1QkFBdUIsQ0FBQ3I4QixLQUFLLEdBQUcsQ0FBQzthQUM3QzIrQixZQUFZO2FBQ1pXLGFBQWE7YUFDYjdQLGFBQWE7O0FBd0JmO0FBQ0EsTUFBTStNO0lBQ0osQ0FBQ3RnQyxVQUFVLENBQTJCO0lBQ3RDLENBQUNxakMsd0JBQXdCLENBQU07SUFDL0IsQ0FBQ0Msd0JBQXdCLENBQU07SUFDL0IsQ0FBQ0MsaUJBQWlCLENBQU07SUFDeEIsQ0FBQ0MsY0FBYyxDQUFNO0lBQ3JCemdILFlBQVlwRCxNQUFNLEVBQUVpeUcsV0FBVyxFQUFFQyxrQkFBa0IsS0FBSyxFQUFFQyw2QkFBNkIsSUFBSSxDQUFFO2FBTDdGLENBQUM5eEIsVUFBVSxHQUFHeDJFLFFBQVErUSxhQUFhO2FBQ25DLENBQUM4b0csd0JBQXdCLEdBQUcsRUFBRTthQUM5QixDQUFDQyx3QkFBd0IsR0FBRyxFQUFFO2FBQzlCLENBQUNDLGlCQUFpQixHQUFHLEVBQUU7YUFDdkIsQ0FBQ0MsY0FBYyxHQUFHLEVBQUU7UUFFbEIsSUFBSSxDQUFDN2pILE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNpeUcsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUNDLGVBQWUsR0FBR0E7UUFDdkIsSUFBSSxDQUFDQywwQkFBMEIsR0FBR0E7SUFDcEM7SUFDQVUsaUJBQWlCeDBCLFFBQVEsRUFBRTtRQUN6QixJQUFJLENBQUMsQ0FBQ3dsQyxjQUFjLENBQUM1NEcsSUFBSSxDQUFDb3pFO0lBQzVCO0lBQ0EyMEIsb0JBQW9CMzBCLFFBQVEsRUFBRTtRQUM1QixJQUFJLENBQUMsQ0FBQ3VsQyxpQkFBaUIsQ0FBQzM0RyxJQUFJLENBQUNvekU7SUFDL0I7SUFDQTgwQiwyQkFBMkI5MEIsUUFBUSxFQUFFO1FBQ25DLElBQUksQ0FBQyxDQUFDc2xDLHdCQUF3QixDQUFDMTRHLElBQUksQ0FBQ296RTtJQUN0QztJQUNBKzBCLDJCQUEyQi8wQixRQUFRLEVBQUU7UUFDbkMsSUFBSSxDQUFDLENBQUNxbEMsd0JBQXdCLENBQUN6NEcsSUFBSSxDQUFDb3pFO0lBQ3RDO0lBQ0F5bEMsWUFBWWhSLEtBQUssRUFBRW5sRixLQUFLLEVBQUU7UUFDeEIsS0FBSyxNQUFNMHdELFlBQVksSUFBSSxDQUFDLENBQUN3bEMsY0FBYyxDQUFFO1lBQzNDeGxDLFNBQVN5MEIsT0FBT25sRjtRQUNsQjtJQUNGO0lBQ0FvMkYsZUFBZXRxQyxNQUFNLEVBQUV3NUIsS0FBSyxFQUFFO1FBQzVCLElBQUksQ0FBQyxDQUFDNXlCLFVBQVUsQ0FBQy8xRSxPQUFPLENBQUNxNkMsSUFBSSxDQUFDO1lBQzVCLEtBQUssTUFBTTA1QixZQUFZLElBQUksQ0FBQyxDQUFDdWxDLGlCQUFpQixDQUFFO2dCQUM5Q3ZsQyxTQUFTNUUsUUFBUXc1QjtZQUNuQjtRQUNGO0lBQ0Y7SUFDQStRLHNCQUFzQnIyRixLQUFLLEVBQUU7UUFDM0IsSUFBSSxDQUFDLENBQUMweUQsVUFBVSxDQUFDLzFFLE9BQU8sQ0FBQ3E2QyxJQUFJLENBQUM7WUFDNUIsS0FBSyxNQUFNMDVCLFlBQVksSUFBSSxDQUFDLENBQUNzbEMsd0JBQXdCLENBQUU7Z0JBQ3JEdGxDLFNBQVMxd0Q7WUFDWDtRQUNGO0lBQ0Y7SUFDQXMyRix3QkFBd0I7UUFDdEIsSUFBSSxDQUFDLENBQUM1akMsVUFBVSxDQUFDLzFFLE9BQU8sQ0FBQ3E2QyxJQUFJLENBQUM7WUFDNUIsS0FBSyxNQUFNMDVCLFlBQVksSUFBSSxDQUFDLENBQUNxbEMsd0JBQXdCLENBQUU7Z0JBQ3JEcmxDO1lBQ0Y7UUFDRjtJQUNGO0lBQ0FpMUIsaUJBQWlCO1FBQ2YsSUFBSSxDQUFDLENBQUNqekIsVUFBVSxDQUFDaDJFLE9BQU87SUFDMUI7SUFDQStwRyxpQkFBaUJ0QixLQUFLLEVBQUV0cEYsR0FBRyxFQUFFO1FBQzNCZ1osWUFBWTtJQUNkO0lBQ0F5TSxRQUFRLENBQUM7QUFDWDtBQUNBLE1BQU1pMUU7SUFDSjlnSCxZQUFZK2dILE9BQU8sRUFBRWYsU0FBUyxDQUFFO1FBQzlCLElBQUksQ0FBQ2dCLFFBQVEsR0FBR0Q7UUFDaEIsSUFBSSxDQUFDYixVQUFVLEdBQUdGO0lBQ3BCO0lBQ0EsSUFBSXZ4RSxvQkFBb0I7UUFDdEIsT0FBTyxJQUFJLENBQUN5eEUsVUFBVSxDQUFDenhFLGlCQUFpQjtJQUMxQztJQUNBLElBQUkrbkQsZ0JBQWdCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDMHBCLFVBQVUsQ0FBQzFwQixhQUFhO0lBQ3RDO0lBQ0EsSUFBSTV2QyxnQkFBZ0I7UUFDbEIsT0FBTyxJQUFJLENBQUNzNUQsVUFBVSxDQUFDdDVELGFBQWE7SUFDdEM7SUFDQSxJQUFJcTZELFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQ0QsUUFBUSxDQUFDQyxRQUFRO0lBQy9CO0lBQ0EsSUFBSUMsZUFBZTtRQUNqQixPQUFPLElBQUksQ0FBQ0YsUUFBUSxDQUFDRSxZQUFZO0lBQ25DO0lBQ0EsSUFBSUMsWUFBWTtRQUNkLE9BQU8vZ0YsT0FBTyxJQUFJLEVBQUUsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDOC9FLFVBQVUsQ0FBQ2tCLFdBQVc7SUFDaEU7SUFDQSxJQUFJQyxhQUFhO1FBQ2YsT0FBTyxJQUFJLENBQUNuQixVQUFVLENBQUNrQixXQUFXO0lBQ3BDO0lBQ0FFLFFBQVF6ekQsVUFBVSxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDcXlELFVBQVUsQ0FBQ29CLE9BQU8sQ0FBQ3p6RDtJQUNqQztJQUNBMHpELGFBQWFDLEdBQUcsRUFBRTtRQUNoQixPQUFPLElBQUksQ0FBQ3RCLFVBQVUsQ0FBQ3FCLFlBQVksQ0FBQ0M7SUFDdEM7SUFDQUMsa0JBQWtCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDdkIsVUFBVSxDQUFDdUIsZUFBZTtJQUN4QztJQUNBQyxlQUFlbndHLEVBQUUsRUFBRTtRQUNqQixPQUFPLElBQUksQ0FBQzJ1RyxVQUFVLENBQUN3QixjQUFjLENBQUNud0c7SUFDeEM7SUFDQW93RyxnQkFBZ0I7UUFDZCxPQUFPLElBQUksQ0FBQ3pCLFVBQVUsQ0FBQ3lCLGFBQWE7SUFDdEM7SUFDQUMsZ0JBQWdCO1FBQ2QsT0FBTyxJQUFJLENBQUMxQixVQUFVLENBQUMwQixhQUFhO0lBQ3RDO0lBQ0FDLGNBQWM7UUFDWixPQUFPLElBQUksQ0FBQzNCLFVBQVUsQ0FBQzJCLFdBQVc7SUFDcEM7SUFDQUMsdUJBQXVCO1FBQ3JCLE9BQU8sSUFBSSxDQUFDNUIsVUFBVSxDQUFDNEIsb0JBQW9CO0lBQzdDO0lBQ0FDLGdCQUFnQjtRQUNkLE9BQU8sSUFBSSxDQUFDN0IsVUFBVSxDQUFDNkIsYUFBYTtJQUN0QztJQUNBQyxpQkFBaUI7UUFDZixPQUFPLElBQUksQ0FBQzlCLFVBQVUsQ0FBQzhCLGNBQWM7SUFDdkM7SUFDQXB0RCxxQkFBcUJuQixLQUFLLEVBQUV3dUQsaUJBQWlCLEVBQUU7UUFDN0MsT0FBTyxJQUFJLENBQUMvQixVQUFVLENBQUN0ckQsb0JBQW9CLENBQUNuQixPQUFPd3VEO0lBQ3JEO0lBQ0FDLGVBQWU7UUFDYixPQUFPLElBQUksQ0FBQ2hDLFVBQVUsQ0FBQ2lDLGVBQWU7SUFDeEM7SUFDQUMsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDbEMsVUFBVSxDQUFDa0MsVUFBVTtJQUNuQztJQUNBQyx5QkFBeUIsRUFDdkJwMUUsU0FBUyxTQUFTLEVBQ25CLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDTixNQUFNLEVBQ0o0L0QsZUFBZSxFQUNoQixHQUFHLElBQUksQ0FBQ3FULFVBQVUsQ0FBQ29DLGtCQUFrQixDQUFDcjFFO1FBQ3ZDLE9BQU8sSUFBSSxDQUFDaXpFLFVBQVUsQ0FBQ21DLHdCQUF3QixDQUFDeFY7SUFDbEQ7SUFDQTBWLGlCQUFpQjtRQUNmLE9BQU8sSUFBSSxDQUFDckMsVUFBVSxDQUFDcUMsY0FBYztJQUN2QztJQUNBQyxjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUN0QyxVQUFVLENBQUNzQyxXQUFXO0lBQ3BDO0lBQ0FDLGNBQWM7UUFDWixPQUFPLElBQUksQ0FBQ3ZDLFVBQVUsQ0FBQ3VDLFdBQVc7SUFDcEM7SUFDQXQxRCxVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUMreUQsVUFBVSxDQUFDL3lELE9BQU87SUFDaEM7SUFDQXUxRCxlQUFlO1FBQ2IsT0FBTyxJQUFJLENBQUN4QyxVQUFVLENBQUN3QyxZQUFZO0lBQ3JDO0lBQ0FDLGtCQUFrQjtRQUNoQixPQUFPLElBQUksQ0FBQ3pDLFVBQVUsQ0FBQzBDLHNCQUFzQixDQUFDMTdHLE9BQU87SUFDdkQ7SUFDQXMxRyxRQUFRcUcsa0JBQWtCLEtBQUssRUFBRTtRQUMvQixPQUFPLElBQUksQ0FBQzNDLFVBQVUsQ0FBQzRDLFlBQVksQ0FBQ0QsbUJBQW1CLElBQUksQ0FBQzFCLFNBQVM7SUFDdkU7SUFDQXpoRSxVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUNxakUsV0FBVyxDQUFDcmpFLE9BQU87SUFDakM7SUFDQXNqRSxpQkFBaUJ4QixHQUFHLEVBQUU7UUFDcEIsT0FBTyxJQUFJLENBQUN0QixVQUFVLENBQUM4QyxnQkFBZ0IsQ0FBQ3hCO0lBQzFDO0lBQ0EsSUFBSS9CLGdCQUFnQjtRQUNsQixPQUFPLElBQUksQ0FBQ1MsVUFBVSxDQUFDVCxhQUFhO0lBQ3RDO0lBQ0EsSUFBSXNELGNBQWM7UUFDaEIsT0FBTyxJQUFJLENBQUM3QyxVQUFVLENBQUM2QyxXQUFXO0lBQ3BDO0lBQ0FFLGtCQUFrQjtRQUNoQixPQUFPLElBQUksQ0FBQy9DLFVBQVUsQ0FBQytDLGVBQWU7SUFDeEM7SUFDQUMsZUFBZTtRQUNiLE9BQU8sSUFBSSxDQUFDaEQsVUFBVSxDQUFDZ0QsWUFBWTtJQUNyQztJQUNBQyx5QkFBeUI7UUFDdkIsT0FBTyxJQUFJLENBQUNqRCxVQUFVLENBQUNpRCxzQkFBc0I7SUFDL0M7QUFDRjtBQUNBLE1BQU1DO0lBQ0osQ0FBQ0MsY0FBYyxDQUFTO0lBQ3hCcmpILFlBQVkrc0QsU0FBUyxFQUFFdTJELFFBQVEsRUFBRXRELFNBQVMsRUFBRXRCLFNBQVMsS0FBSyxDQUFFO2FBRDVELENBQUMyRSxjQUFjLEdBQUc7UUFFaEIsSUFBSSxDQUFDRSxVQUFVLEdBQUd4MkQ7UUFDbEIsSUFBSSxDQUFDeTJELFNBQVMsR0FBR0Y7UUFDakIsSUFBSSxDQUFDcEQsVUFBVSxHQUFHRjtRQUNsQixJQUFJLENBQUN5RCxNQUFNLEdBQUcvRSxTQUFTLElBQUk3cUUsY0FBYztRQUN6QyxJQUFJLENBQUM2dkUsT0FBTyxHQUFHaEY7UUFDZixJQUFJLENBQUMxaUIsVUFBVSxHQUFHZ2tCLFVBQVVoa0IsVUFBVTtRQUN0QyxJQUFJLENBQUNsakIsSUFBSSxHQUFHLElBQUl1Z0M7UUFDaEIsSUFBSSxDQUFDc0ssYUFBYSxHQUFHLElBQUk3NUU7UUFDekIsSUFBSSxDQUFDNDFFLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNrRSxjQUFjLEdBQUc7SUFDeEI7SUFDQSxJQUFJLzFELGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQzAxRCxVQUFVLEdBQUc7SUFDM0I7SUFDQSxJQUFJbDBDLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ20wQyxTQUFTLENBQUNuMEMsTUFBTTtJQUM5QjtJQUNBLElBQUlteUMsTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDZ0MsU0FBUyxDQUFDaEMsR0FBRztJQUMzQjtJQUNBLElBQUl2d0UsV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDdXlFLFNBQVMsQ0FBQ3Z5RSxRQUFRO0lBQ2hDO0lBQ0EsSUFBSTQzRCxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUMyYSxTQUFTLENBQUMzYSxJQUFJO0lBQzVCO0lBQ0FnYixZQUFZLEVBQ1YzeUUsS0FBSyxFQUNMQyxXQUFXLElBQUksQ0FBQ2srQixNQUFNLEVBQ3RCaitCLFVBQVUsQ0FBQyxFQUNYQyxVQUFVLENBQUMsRUFDWEMsV0FBVyxLQUFLLEVBQ2pCLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDTixPQUFPLElBQUlQLGFBQWE7WUFDdEJDLFNBQVMsSUFBSSxDQUFDNjNELElBQUk7WUFDbEI1M0QsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkJDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1FBQ0Y7SUFDRjtJQUNBd3lFLGVBQWUsRUFDYjcyRSxTQUFTLFNBQVMsRUFDbkIsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUNOLE1BQU0sRUFDSjQvRCxlQUFlLEVBQ2hCLEdBQUcsSUFBSSxDQUFDcVQsVUFBVSxDQUFDb0Msa0JBQWtCLENBQUNyMUU7UUFDdkMsT0FBTyxJQUFJLENBQUNpekUsVUFBVSxDQUFDNEQsY0FBYyxDQUFDLElBQUksQ0FBQ1AsVUFBVSxFQUFFMVc7SUFDekQ7SUFDQXFWLGVBQWU7UUFDYixPQUFPLElBQUksQ0FBQ2hDLFVBQVUsQ0FBQzZELGdCQUFnQixDQUFDLElBQUksQ0FBQ1IsVUFBVTtJQUN6RDtJQUNBLElBQUkzOEQsZ0JBQWdCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDczVELFVBQVUsQ0FBQ3Q1RCxhQUFhO0lBQ3RDO0lBQ0EsSUFBSXU2RCxZQUFZO1FBQ2QsT0FBTy9nRixPQUFPLElBQUksRUFBRSxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUM4L0UsVUFBVSxDQUFDa0IsV0FBVztJQUNoRTtJQUNBLE1BQU00QyxTQUFTO1FBQ2IsT0FBTyxJQUFJLENBQUM5RCxVQUFVLENBQUNrQixXQUFXLEVBQUV6MEUsUUFBUSxDQUFDLElBQUksQ0FBQzQyRSxVQUFVLENBQUMsSUFBSTtJQUNuRTtJQUNBaDFFLE9BQU8sRUFDTDAxRSxhQUFhLEVBQ2IvaUUsU0FBUytpRSxjQUFjL2lFLE1BQU0sRUFDN0JuUyxRQUFRLEVBQ1I5QixTQUFTLFNBQVMsRUFDbEJpM0UsaUJBQWlCNXpGLGVBQWVFLE1BQU0sRUFDdEMrSSxZQUFZLElBQUksRUFDaEJteUIsYUFBYSxJQUFJLEVBQ2pCeTRELCtCQUErQixJQUFJLEVBQ25Dam9CLHNCQUFzQixJQUFJLEVBQzFCcjBDLGFBQWEsSUFBSSxFQUNqQnU4RCx5QkFBeUIsSUFBSSxFQUM3QnY2RCxZQUFZLEtBQUssRUFDakJ3NkQsbUJBQW1CLEtBQUssRUFDeEJ0bUIsbUJBQW1CLElBQUksRUFDeEIsRUFBRTtRQUNELElBQUksQ0FBQzBsQixNQUFNLEVBQUUzdkUsS0FBSztRQUNsQixNQUFNd3dFLGFBQWEsSUFBSSxDQUFDcEUsVUFBVSxDQUFDb0Msa0JBQWtCLENBQUNyMUUsUUFBUWkzRSxnQkFBZ0JFLHdCQUF3QnY2RDtRQUN0RyxNQUFNLEVBQ0pnakQsZUFBZSxFQUNmL00sUUFBUSxFQUNULEdBQUd3a0I7UUFDSixJQUFJLENBQUMsQ0FBQ2pCLGNBQWMsR0FBRztRQUN2QmMsaUNBQWlDLElBQUksQ0FBQ2pFLFVBQVUsQ0FBQ21DLHdCQUF3QixDQUFDeFY7UUFDMUUsSUFBSTBYLGNBQWMsSUFBSSxDQUFDWixhQUFhLENBQUM5a0gsR0FBRyxDQUFDaWhHO1FBQ3pDLElBQUksQ0FBQ3lrQixhQUFhO1lBQ2hCQSxjQUFjdGxILE9BQU8rTCxNQUFNLENBQUM7WUFDNUIsSUFBSSxDQUFDMjRHLGFBQWEsQ0FBQ3grRyxHQUFHLENBQUMyNkYsVUFBVXlrQjtRQUNuQztRQUNBLElBQUlBLFlBQVlDLHlCQUF5QixFQUFFO1lBQ3pDcjVELGFBQWFvNUQsWUFBWUMseUJBQXlCO1lBQ2xERCxZQUFZQyx5QkFBeUIsR0FBRztRQUMxQztRQUNBLE1BQU1DLGNBQWMsQ0FBQyxDQUFFNVgsQ0FBQUEsa0JBQWtCajlFLG9CQUFvQkcsS0FBSztRQUNsRSxJQUFJLENBQUN3MEYsWUFBWUcsc0JBQXNCLEVBQUU7WUFDdkNILFlBQVlHLHNCQUFzQixHQUFHaitHLFFBQVErUSxhQUFhO1lBQzFEK3NHLFlBQVkxekIsWUFBWSxHQUFHO2dCQUN6Qm9OLFNBQVMsRUFBRTtnQkFDWEQsV0FBVyxFQUFFO2dCQUNiMm1CLFdBQVc7Z0JBQ1hDLGdCQUFnQjtZQUNsQjtZQUNBLElBQUksQ0FBQ25CLE1BQU0sRUFBRTN2RSxLQUFLO1lBQ2xCLElBQUksQ0FBQyt3RSxpQkFBaUIsQ0FBQ1A7UUFDekI7UUFDQSxNQUFNUSxvQkFBb0JDLFFBQVEsSUFBSSxDQUFDckIsT0FBTyxJQUFJM2lILFdBQVdpa0gsY0FBYyxFQUFFeG9EO1FBQzdFLE1BQU15b0QseUJBQXlCLENBQUMsSUFBSSxDQUFDckIsY0FBYyxJQUFLUyxDQUFBQSxvQkFBb0JTLGlCQUFnQjtRQUM1RixNQUFNaHVDLFdBQVdwNUUsQ0FBQUE7WUFDZjZtSCxZQUFZVyxXQUFXLENBQUM5bUUsTUFBTSxDQUFDK21FO1lBQy9CLElBQUlGLHdCQUF3QjtnQkFDMUIsTUFBTXJCLGlCQUFpQnVCLG1CQUFtQkMsR0FBRyxFQUFFaDdCLGtCQUFrQi91RTtnQkFDakUsSUFBSXVvRyxnQkFBZ0I7b0JBQ2xCLElBQUl1QixtQkFBbUJybkIsT0FBTyxFQUFFO3dCQUM5QnFuQixtQkFBbUJybkIsT0FBTyxDQUFDdW5CLGlCQUFpQixDQUFDekIsZ0JBQWdCdUIsbUJBQW1CQyxHQUFHLENBQUNoN0IsaUJBQWlCLENBQUNGLGlCQUFpQjtvQkFDekg7b0JBQ0EsSUFBSW02QixrQkFBa0I7d0JBQ3BCLElBQUksQ0FBQ1QsY0FBYyxHQUFHQTtvQkFDeEI7Z0JBQ0Y7WUFDRjtZQUNBLElBQUlhLGFBQWE7Z0JBQ2YsSUFBSSxDQUFDLENBQUNwQixjQUFjLEdBQUc7WUFDekI7WUFDQSxJQUFJLENBQUMsQ0FBQ2lDLFVBQVU7WUFDaEIsSUFBSTVuSCxPQUFPO2dCQUNUeW5ILG1CQUFtQmxvQyxVQUFVLENBQUNqMkUsTUFBTSxDQUFDdEo7Z0JBQ3JDLElBQUksQ0FBQzZuSCxrQkFBa0IsQ0FBQztvQkFDdEJoQjtvQkFDQXo0RSxRQUFRcHVDLGlCQUFpQnFkLFFBQVFyZCxRQUFRLElBQUlxZCxNQUFNcmQ7Z0JBQ3JEO1lBQ0YsT0FBTztnQkFDTHluSCxtQkFBbUJsb0MsVUFBVSxDQUFDaDJFLE9BQU87WUFDdkM7WUFDQSxJQUFJLElBQUksQ0FBQ3c4RyxNQUFNLEVBQUU7Z0JBQ2YsSUFBSSxDQUFDQSxNQUFNLENBQUN4dkUsT0FBTyxDQUFDO2dCQUNwQixJQUFJLENBQUN3dkUsTUFBTSxDQUFDeHZFLE9BQU8sQ0FBQztnQkFDcEIsSUFBSWx6QyxXQUFXeWtILEtBQUssRUFBRWhwRCxTQUFTO29CQUM3Qno3RCxXQUFXeWtILEtBQUssQ0FBQy95RyxHQUFHLENBQUMsSUFBSSxDQUFDbzdDLFVBQVUsRUFBRSxJQUFJLENBQUM0MUQsTUFBTTtnQkFDbkQ7WUFDRjtRQUNGO1FBQ0EsTUFBTTBCLHFCQUFxQixJQUFJTSxtQkFBbUI7WUFDaER6cUcsVUFBVTg3RDtZQUNWamdFLFFBQVE7Z0JBQ05xcUM7Z0JBQ0EraUU7Z0JBQ0E3NUIsbUJBQW1CNjZCLHlCQUF5QixJQUFJdi9CLHdCQUF3QnhrQyxRQUFRcWpFLFlBQVkxekIsWUFBWSxDQUFDajBGLE1BQU0sRUFBRWtvSCxxQkFBcUI7Z0JBQ3RJLzFFO2dCQUNBeFY7Z0JBQ0FteUI7WUFDRjtZQUNBb3RCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZrakIsWUFBWSxJQUFJLENBQUNBLFVBQVU7WUFDM0JFO1lBQ0FyTCxjQUFjMHpCLFlBQVkxekIsWUFBWTtZQUN0QzlqQyxXQUFXLElBQUksQ0FBQ3cyRCxVQUFVO1lBQzFCL3NCLGVBQWUsSUFBSSxDQUFDMHBCLFVBQVUsQ0FBQzFwQixhQUFhO1lBQzVDNXZDLGVBQWUsSUFBSSxDQUFDczVELFVBQVUsQ0FBQ3Q1RCxhQUFhO1lBQzVDOCtELDBCQUEwQixDQUFDakI7WUFDM0IvRixRQUFRLElBQUksQ0FBQ2dGLE9BQU87WUFDcEI3N0Q7WUFDQXUzQixXQUFXLElBQUksQ0FBQzhnQyxVQUFVLENBQUM5Z0MsU0FBUztZQUNwQzJlO1FBQ0Y7UUFDQ3dtQixDQUFBQSxZQUFZVyxXQUFXLEtBQUssSUFBSXR3RyxLQUFJLEVBQUduQyxHQUFHLENBQUMweUc7UUFDNUMsTUFBTVEsYUFBYVIsbUJBQW1CaEksSUFBSTtRQUMxQzEyRyxRQUFReVQsR0FBRyxDQUFDO1lBQUNxcUcsWUFBWUcsc0JBQXNCLENBQUN4OUcsT0FBTztZQUFFaTlHO1NBQTZCLEVBQUU1aUUsSUFBSSxDQUFDLENBQUMsQ0FBQ2c4QyxjQUFjdEIsc0JBQXNCO1lBQ2pJLElBQUksSUFBSSxDQUFDeWpCLFNBQVMsRUFBRTtnQkFDbEI1b0M7Z0JBQ0E7WUFDRjtZQUNBLElBQUksQ0FBQzJzQyxNQUFNLEVBQUUzdkUsS0FBSztZQUNsQixJQUFJLENBQUVtb0QsQ0FBQUEsc0JBQXNCNFEsZUFBZSxHQUFHQSxlQUFjLEdBQUk7Z0JBQzlELE1BQU0sSUFBSTl4RixNQUFNLGdGQUFnRjtZQUNsRztZQUNBb3FHLG1CQUFtQlMsa0JBQWtCLENBQUM7Z0JBQ3BDcm9CO2dCQUNBdEI7WUFDRjtZQUNBa3BCLG1CQUFtQlUsbUJBQW1CO1FBQ3hDLEdBQUdobUMsS0FBSyxDQUFDL0k7UUFDVCxPQUFPNnVDO0lBQ1Q7SUFDQUcsZ0JBQWdCLEVBQ2Q3NEUsU0FBUyxTQUFTLEVBQ2xCaTNFLGlCQUFpQjV6RixlQUFlRSxNQUFNLEVBQ3RDNHpGLHlCQUF5QixJQUFJLEVBQzdCdjZELFlBQVksS0FBSyxFQUNsQixHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ04sU0FBU2c4RDtZQUNQLElBQUl0QixZQUFZMXpCLFlBQVksQ0FBQzh6QixTQUFTLEVBQUU7Z0JBQ3RDSixZQUFZd0Isb0JBQW9CLENBQUM5K0csT0FBTyxDQUFDczlHLFlBQVkxekIsWUFBWTtnQkFDakUwekIsWUFBWVcsV0FBVyxDQUFDOW1FLE1BQU0sQ0FBQzRuRTtZQUNqQztRQUNGO1FBQ0EsTUFBTTFCLGFBQWEsSUFBSSxDQUFDcEUsVUFBVSxDQUFDb0Msa0JBQWtCLENBQUNyMUUsUUFBUWkzRSxnQkFBZ0JFLHdCQUF3QnY2RCxXQUFXO1FBQ2pILElBQUkwNkQsY0FBYyxJQUFJLENBQUNaLGFBQWEsQ0FBQzlrSCxHQUFHLENBQUN5bEgsV0FBV3hrQixRQUFRO1FBQzVELElBQUksQ0FBQ3lrQixhQUFhO1lBQ2hCQSxjQUFjdGxILE9BQU8rTCxNQUFNLENBQUM7WUFDNUIsSUFBSSxDQUFDMjRHLGFBQWEsQ0FBQ3grRyxHQUFHLENBQUNtL0csV0FBV3hrQixRQUFRLEVBQUV5a0I7UUFDOUM7UUFDQSxJQUFJeUI7UUFDSixJQUFJLENBQUN6QixZQUFZd0Isb0JBQW9CLEVBQUU7WUFDckNDLGFBQWEvbUgsT0FBTytMLE1BQU0sQ0FBQztZQUMzQmc3RyxXQUFXSCxtQkFBbUIsR0FBR0E7WUFDakN0QixZQUFZd0Isb0JBQW9CLEdBQUd0L0csUUFBUStRLGFBQWE7WUFDdkQrc0csQ0FBQUEsWUFBWVcsV0FBVyxLQUFLLElBQUl0d0csS0FBSSxFQUFHbkMsR0FBRyxDQUFDdXpHO1lBQzVDekIsWUFBWTF6QixZQUFZLEdBQUc7Z0JBQ3pCb04sU0FBUyxFQUFFO2dCQUNYRCxXQUFXLEVBQUU7Z0JBQ2IybUIsV0FBVztnQkFDWEMsZ0JBQWdCO1lBQ2xCO1lBQ0EsSUFBSSxDQUFDbkIsTUFBTSxFQUFFM3ZFLEtBQUs7WUFDbEIsSUFBSSxDQUFDK3dFLGlCQUFpQixDQUFDUDtRQUN6QjtRQUNBLE9BQU9DLFlBQVl3QixvQkFBb0IsQ0FBQzcrRyxPQUFPO0lBQ2pEO0lBQ0ErK0csa0JBQWtCLEVBQ2hCQyx1QkFBdUIsS0FBSyxFQUM1QkMsdUJBQXVCLEtBQUssRUFDN0IsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUNOLE1BQU1DLDBCQUEwQjtRQUNoQyxPQUFPLElBQUksQ0FBQ2xHLFVBQVUsQ0FBQ04sY0FBYyxDQUFDbmlDLGNBQWMsQ0FBQyxrQkFBa0I7WUFDckUxd0IsV0FBVyxJQUFJLENBQUN3MkQsVUFBVTtZQUMxQjJDLHNCQUFzQkEseUJBQXlCO1lBQy9DQyxzQkFBc0JBLHlCQUF5QjtRQUNqRCxHQUFHO1lBQ0RFLGVBQWVEO1lBQ2Z4MEcsTUFBS3k2QixXQUFXO2dCQUNkLE9BQU9BLFlBQVloOEIsS0FBSyxDQUFDelQsTUFBTTtZQUNqQztRQUNGO0lBQ0Y7SUFDQTBwSCxlQUFlenZHLFNBQVMsQ0FBQyxDQUFDLEVBQUU7UUFDMUIsSUFBSSxJQUFJLENBQUNxcEcsVUFBVSxDQUFDa0IsV0FBVyxFQUFFO1lBQy9CLE9BQU8sSUFBSSxDQUFDNEMsTUFBTSxHQUFHemlFLElBQUksQ0FBQ2pWLENBQUFBLE1BQU9GLFFBQVFDLFdBQVcsQ0FBQ0M7UUFDdkQ7UUFDQSxNQUFNNnNFLGlCQUFpQixJQUFJLENBQUM4TSxpQkFBaUIsQ0FBQ3B2RztRQUM5QyxPQUFPLElBQUlwUSxRQUFRLFNBQVVRLE9BQU8sRUFBRUQsTUFBTTtZQUMxQyxTQUFTNHpHO2dCQUNQbEssT0FBTzVuRyxJQUFJLEdBQUd5NEMsSUFBSSxDQUFDLFNBQVUsRUFDM0IxakQsS0FBSyxFQUNMaUUsSUFBSSxFQUNMO29CQUNDLElBQUlBLE1BQU07d0JBQ1JtRixRQUFRb2xDO3dCQUNSO29CQUNGO29CQUNBQSxZQUFZdXRFLElBQUksS0FBSy83RyxNQUFNKzdHLElBQUk7b0JBQy9CMzZHLE9BQU9rdkMsTUFBTSxDQUFDOUIsWUFBWUUsTUFBTSxFQUFFMXVDLE1BQU0wdUMsTUFBTTtvQkFDOUNGLFlBQVloOEIsS0FBSyxDQUFDeEksSUFBSSxJQUFJaEssTUFBTXdTLEtBQUs7b0JBQ3JDdXFHO2dCQUNGLEdBQUc1ekc7WUFDTDtZQUNBLE1BQU0wcEcsU0FBU3lJLGVBQWU5RCxTQUFTO1lBQ3ZDLE1BQU1ocEUsY0FBYztnQkFDbEJoOEIsT0FBTyxFQUFFO2dCQUNUazhCLFFBQVF0dEMsT0FBTytMLE1BQU0sQ0FBQztnQkFDdEI0dUcsTUFBTTtZQUNSO1lBQ0FnQjtRQUNGO0lBQ0Y7SUFDQTJMLGdCQUFnQjtRQUNkLE9BQU8sSUFBSSxDQUFDckcsVUFBVSxDQUFDcUcsYUFBYSxDQUFDLElBQUksQ0FBQ2hELFVBQVU7SUFDdEQ7SUFDQWlELFdBQVc7UUFDVCxJQUFJLENBQUM5RyxTQUFTLEdBQUc7UUFDakIsTUFBTStHLFNBQVMsRUFBRTtRQUNqQixLQUFLLE1BQU1sQyxlQUFlLElBQUksQ0FBQ1osYUFBYSxDQUFDamdHLE1BQU0sR0FBSTtZQUNyRCxJQUFJLENBQUM2aEcsa0JBQWtCLENBQUM7Z0JBQ3RCaEI7Z0JBQ0F6NEUsUUFBUSxJQUFJL3dCLE1BQU07Z0JBQ2xCMnJHLE9BQU87WUFDVDtZQUNBLElBQUluQyxZQUFZd0Isb0JBQW9CLEVBQUU7Z0JBQ3BDO1lBQ0Y7WUFDQSxLQUFLLE1BQU1aLHNCQUFzQlosWUFBWVcsV0FBVyxDQUFFO2dCQUN4RHVCLE9BQU81K0csSUFBSSxDQUFDczlHLG1CQUFtQndCLFNBQVM7Z0JBQ3hDeEIsbUJBQW1CNW9ELE1BQU07WUFDM0I7UUFDRjtRQUNBLElBQUksQ0FBQ3VjLElBQUksQ0FBQzEwRCxLQUFLO1FBQ2YsSUFBSSxDQUFDLENBQUNpL0YsY0FBYyxHQUFHO1FBQ3ZCLE9BQU81OEcsUUFBUXlULEdBQUcsQ0FBQ3VzRztJQUNyQjtJQUNBakssUUFBUW9LLGFBQWEsS0FBSyxFQUFFO1FBQzFCLElBQUksQ0FBQyxDQUFDdkQsY0FBYyxHQUFHO1FBQ3ZCLE1BQU12a0MsVUFBVSxJQUFJLENBQUMsQ0FBQ3dtQyxVQUFVO1FBQ2hDLElBQUlzQixjQUFjOW5DLFNBQVM7WUFDekIsSUFBSSxDQUFDMmtDLE1BQU0sS0FBSyxJQUFJNXZFO1FBQ3RCO1FBQ0EsT0FBT2lyQztJQUNUO0lBQ0EsQ0FBQ3dtQyxVQUFVO1FBQ1QsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDakMsY0FBYyxJQUFJLElBQUksQ0FBQzNELFNBQVMsRUFBRTtZQUMzQyxPQUFPO1FBQ1Q7UUFDQSxLQUFLLE1BQU0sRUFDVHdGLFdBQVcsRUFDWHIwQixZQUFZLEVBQ2IsSUFBSSxJQUFJLENBQUM4eUIsYUFBYSxDQUFDamdHLE1BQU0sR0FBSTtZQUNoQyxJQUFJd2hHLFlBQVl0ekcsSUFBSSxHQUFHLEtBQUssQ0FBQ2kvRSxhQUFhOHpCLFNBQVMsRUFBRTtnQkFDbkQsT0FBTztZQUNUO1FBQ0Y7UUFDQSxJQUFJLENBQUNoQixhQUFhLENBQUN2L0YsS0FBSztRQUN4QixJQUFJLENBQUMwMEQsSUFBSSxDQUFDMTBELEtBQUs7UUFDZixJQUFJLENBQUMsQ0FBQ2kvRixjQUFjLEdBQUc7UUFDdkIsT0FBTztJQUNUO0lBQ0F3RCxpQkFBaUJ0cEIsWUFBWSxFQUFFdUMsUUFBUSxFQUFFO1FBQ3ZDLE1BQU15a0IsY0FBYyxJQUFJLENBQUNaLGFBQWEsQ0FBQzlrSCxHQUFHLENBQUNpaEc7UUFDM0MsSUFBSSxDQUFDeWtCLGFBQWE7WUFDaEI7UUFDRjtRQUNBLElBQUksQ0FBQ2QsTUFBTSxFQUFFeHZFLFFBQVE7UUFDckJzd0UsWUFBWUcsc0JBQXNCLEVBQUV6OUcsUUFBUXMyRjtJQUM5QztJQUNBdXBCLGlCQUFpQkMsaUJBQWlCLEVBQUV4QyxXQUFXLEVBQUU7UUFDL0MsSUFBSyxJQUFJaGpILElBQUksR0FBR2luQyxLQUFLdStFLGtCQUFrQm5xSCxNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsSUFBSztZQUMxRGdqSCxZQUFZMXpCLFlBQVksQ0FBQ29OLE9BQU8sQ0FBQ3AyRixJQUFJLENBQUNrL0csa0JBQWtCOW9CLE9BQU8sQ0FBQzE4RixFQUFFO1lBQ2xFZ2pILFlBQVkxekIsWUFBWSxDQUFDbU4sU0FBUyxDQUFDbjJGLElBQUksQ0FBQ2svRyxrQkFBa0Ivb0IsU0FBUyxDQUFDejhGLEVBQUU7UUFDeEU7UUFDQWdqSCxZQUFZMXpCLFlBQVksQ0FBQzh6QixTQUFTLEdBQUdvQyxrQkFBa0JwQyxTQUFTO1FBQ2hFSixZQUFZMXpCLFlBQVksQ0FBQyt6QixjQUFjLEdBQUdtQyxrQkFBa0JuQyxjQUFjO1FBQzFFLEtBQUssTUFBTU8sc0JBQXNCWixZQUFZVyxXQUFXLENBQUU7WUFDeERDLG1CQUFtQlUsbUJBQW1CO1FBQ3hDO1FBQ0EsSUFBSWtCLGtCQUFrQnBDLFNBQVMsRUFBRTtZQUMvQixJQUFJLENBQUMsQ0FBQ1csVUFBVTtRQUNsQjtJQUNGO0lBQ0FULGtCQUFrQixFQUNoQmhZLGVBQWUsRUFDZi9NLFFBQVEsRUFDUmtuQiw2QkFBNkIsRUFDN0JwMEMsV0FBVyxFQUNaLEVBQUU7UUFDRCxNQUFNLEVBQ0puckUsR0FBRyxFQUNIckIsUUFBUSxFQUNULEdBQUc0Z0g7UUFDSixNQUFNN04saUJBQWlCLElBQUksQ0FBQytHLFVBQVUsQ0FBQ04sY0FBYyxDQUFDbmlDLGNBQWMsQ0FBQyxtQkFBbUI7WUFDdEYxd0IsV0FBVyxJQUFJLENBQUN3MkQsVUFBVTtZQUMxQnQyRSxRQUFRNC9EO1lBQ1IvTTtZQUNBcnhELG1CQUFtQmhuQztZQUNuQm1yRTtRQUNGLEdBQUd4c0U7UUFDSCxNQUFNc3FHLFNBQVN5SSxlQUFlOUQsU0FBUztRQUN2QyxNQUFNa1AsY0FBYyxJQUFJLENBQUNaLGFBQWEsQ0FBQzlrSCxHQUFHLENBQUNpaEc7UUFDM0N5a0IsWUFBWTBDLFlBQVksR0FBR3ZXO1FBQzNCLE1BQU1rSyxPQUFPO1lBQ1hsSyxPQUFPNW5HLElBQUksR0FBR3k0QyxJQUFJLENBQUMsQ0FBQyxFQUNsQjFqRCxLQUFLLEVBQ0xpRSxJQUFJLEVBQ0w7Z0JBQ0MsSUFBSUEsTUFBTTtvQkFDUnlpSCxZQUFZMEMsWUFBWSxHQUFHO29CQUMzQjtnQkFDRjtnQkFDQSxJQUFJLElBQUksQ0FBQy9HLFVBQVUsQ0FBQ1IsU0FBUyxFQUFFO29CQUM3QjtnQkFDRjtnQkFDQSxJQUFJLENBQUNvSCxnQkFBZ0IsQ0FBQ2pwSCxPQUFPMG1IO2dCQUM3QjNKO1lBQ0YsR0FBRzl1RSxDQUFBQTtnQkFDRHk0RSxZQUFZMEMsWUFBWSxHQUFHO2dCQUMzQixJQUFJLElBQUksQ0FBQy9HLFVBQVUsQ0FBQ1IsU0FBUyxFQUFFO29CQUM3QjtnQkFDRjtnQkFDQSxJQUFJNkUsWUFBWTF6QixZQUFZLEVBQUU7b0JBQzVCMHpCLFlBQVkxekIsWUFBWSxDQUFDOHpCLFNBQVMsR0FBRztvQkFDckMsS0FBSyxNQUFNUSxzQkFBc0JaLFlBQVlXLFdBQVcsQ0FBRTt3QkFDeERDLG1CQUFtQlUsbUJBQW1CO29CQUN4QztvQkFDQSxJQUFJLENBQUMsQ0FBQ1AsVUFBVTtnQkFDbEI7Z0JBQ0EsSUFBSWYsWUFBWUcsc0JBQXNCLEVBQUU7b0JBQ3RDSCxZQUFZRyxzQkFBc0IsQ0FBQzE5RyxNQUFNLENBQUM4a0M7Z0JBQzVDLE9BQU8sSUFBSXk0RSxZQUFZd0Isb0JBQW9CLEVBQUU7b0JBQzNDeEIsWUFBWXdCLG9CQUFvQixDQUFDLytHLE1BQU0sQ0FBQzhrQztnQkFDMUMsT0FBTztvQkFDTCxNQUFNQTtnQkFDUjtZQUNGO1FBQ0Y7UUFDQTh1RTtJQUNGO0lBQ0EySyxtQkFBbUIsRUFDakJoQixXQUFXLEVBQ1h6NEUsTUFBTSxFQUNONDZFLFFBQVEsS0FBSyxFQUNkLEVBQUU7UUFDRCxJQUFJLENBQUNuQyxZQUFZMEMsWUFBWSxFQUFFO1lBQzdCO1FBQ0Y7UUFDQSxJQUFJMUMsWUFBWUMseUJBQXlCLEVBQUU7WUFDekNyNUQsYUFBYW81RCxZQUFZQyx5QkFBeUI7WUFDbERELFlBQVlDLHlCQUF5QixHQUFHO1FBQzFDO1FBQ0EsSUFBSSxDQUFDa0MsT0FBTztZQUNWLElBQUluQyxZQUFZVyxXQUFXLENBQUN0ekcsSUFBSSxHQUFHLEdBQUc7Z0JBQ3BDO1lBQ0Y7WUFDQSxJQUFJazZCLGtCQUFrQjhHLDZCQUE2QjtnQkFDakQsSUFBSXMwRSxRQUFRaks7Z0JBQ1osSUFBSW54RSxPQUFPK0csVUFBVSxHQUFHLEtBQUsvRyxPQUFPK0csVUFBVSxHQUFHLE1BQU07b0JBQ3JEcTBFLFNBQVNwN0UsT0FBTytHLFVBQVU7Z0JBQzVCO2dCQUNBMHhFLFlBQVlDLHlCQUF5QixHQUFHN3RELFdBQVc7b0JBQ2pENHRELFlBQVlDLHlCQUF5QixHQUFHO29CQUN4QyxJQUFJLENBQUNlLGtCQUFrQixDQUFDO3dCQUN0QmhCO3dCQUNBejRFO3dCQUNBNDZFLE9BQU87b0JBQ1Q7Z0JBQ0YsR0FBR1E7Z0JBQ0g7WUFDRjtRQUNGO1FBQ0EzQyxZQUFZMEMsWUFBWSxDQUFDMXFELE1BQU0sQ0FBQyxJQUFJdDdCLGVBQWU2SyxPQUFPNXZCLE9BQU8sR0FBRzJqRSxLQUFLLENBQUMsS0FBTztRQUNqRjBrQyxZQUFZMEMsWUFBWSxHQUFHO1FBQzNCLElBQUksSUFBSSxDQUFDL0csVUFBVSxDQUFDUixTQUFTLEVBQUU7WUFDN0I7UUFDRjtRQUNBLEtBQUssTUFBTSxDQUFDeUgsYUFBYUMsZUFBZSxJQUFJLElBQUksQ0FBQ3pELGFBQWEsQ0FBRTtZQUM5RCxJQUFJeUQsbUJBQW1CN0MsYUFBYTtnQkFDbEMsSUFBSSxDQUFDWixhQUFhLENBQUN2bEUsTUFBTSxDQUFDK29FO2dCQUMxQjtZQUNGO1FBQ0Y7UUFDQSxJQUFJLENBQUMzSyxPQUFPO0lBQ2Q7SUFDQSxJQUFJL29DLFFBQVE7UUFDVixPQUFPLElBQUksQ0FBQ2d3QyxNQUFNO0lBQ3BCO0FBQ0Y7QUFDQSxNQUFNaEc7SUFDSixDQUFDeGdDLFVBQVUsQ0FBMkI7SUFDdEMsQ0FBQzJpQyxjQUFjLENBQVE7SUFDdkIsQ0FBQzNULElBQUksQ0FBUTtJQUNiLENBQUNvYixTQUFTLENBQVE7SUFDbEIsT0FBTyxDQUFDQyxZQUFZLEdBQUcsRUFBRTtJQUN6QixPQUFPLENBQUNDLGdCQUFnQixHQUFHLE1BQU07SUFDakMsT0FBTyxDQUFDQyxXQUFXLEdBQUcsSUFBSXRpSCxVQUFVO0lBQ3BDLE1BQU87UUFDTCxJQUFJbXFCLFVBQVU7WUFDWixJQUFJLENBQUMsQ0FBQ2s0RixnQkFBZ0IsR0FBRztZQUN6QnZiLG9CQUFvQkksU0FBUyxLQUFLO1FBQ3BDO1FBQ0EsSUFBSSxDQUFDcWIsYUFBYSxHQUFHLENBQUMvbkYsU0FBU2dvRjtZQUM3QixNQUFNam5HLE9BQU9KLElBQUlDLEtBQUssQ0FBQ29mO1lBQ3ZCLElBQUksQ0FBQ2pmLE1BQU1raEQsVUFBVWxoRCxLQUFLa2hELE1BQU0sS0FBSyxRQUFRO2dCQUMzQyxPQUFPO1lBQ1Q7WUFDQSxNQUFNenZELFFBQVEsSUFBSW1PLElBQUlxbkcsVUFBVWpuRztZQUNoQyxPQUFPQSxLQUFLa2hELE1BQU0sS0FBS3p2RCxNQUFNeXZELE1BQU07UUFDckM7UUFDQSxJQUFJLENBQUNnbUQsaUJBQWlCLEdBQUdwbkcsQ0FBQUE7WUFDdkIsTUFBTXFuRyxVQUFVLENBQUMsY0FBYyxFQUFFcm5HLElBQUksR0FBRyxDQUFDO1lBQ3pDLE9BQU9GLElBQUl3bkcsZUFBZSxDQUFDLElBQUk5bEUsS0FBSztnQkFBQzZsRTthQUFRLEVBQUU7Z0JBQzdDcmlILE1BQU07WUFDUjtRQUNGO1FBQ0EsSUFBSSxDQUFDdWlILFFBQVEsR0FBR2p4RyxDQUFBQTtZQUNkNjlCLFdBQVc7WUFDWCxJQUFJLENBQUM3OUIsUUFBUW8xRixNQUFNO2dCQUNqQixNQUFNLElBQUlseEYsTUFBTTtZQUNsQjtZQUNBLE9BQU8sSUFBSSxDQUFDL1AsTUFBTSxDQUFDNkw7UUFDckI7SUFDRixDQUFDO0lBQ0Q3VyxZQUFZLEVBQ1ZOLE9BQU8sSUFBSSxFQUNYdXNHLE9BQU8sSUFBSSxFQUNYdHRFLFlBQVlJLG1CQUFtQixFQUNoQyxHQUFHLENBQUMsQ0FBQyxDQUFFO2FBdENSLENBQUNrK0MsVUFBVSxHQUFHeDJFLFFBQVErUSxhQUFhO2FBQ25DLENBQUNvb0csY0FBYyxHQUFHO2FBQ2xCLENBQUMzVCxJQUFJLEdBQUc7YUFDUixDQUFDb2IsU0FBUyxHQUFHO1FBb0NYLElBQUksQ0FBQzNuSCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDZ2dILFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUMvZ0YsU0FBUyxHQUFHQTtRQUNqQixJQUFJc3RFLE1BQU07WUFDUixJQUFJd1IsVUFBVSxDQUFDK0osV0FBVyxDQUFDcGlILEdBQUcsQ0FBQzZtRyxPQUFPO2dCQUNwQyxNQUFNLElBQUlseEYsTUFBTTtZQUNsQjtZQUNBMGlHLFVBQVUsQ0FBQytKLFdBQVcsQ0FBQ3JpSCxHQUFHLENBQUM4bUcsTUFBTSxJQUFJO1lBQ3JDLElBQUksQ0FBQyxDQUFDOGIsa0JBQWtCLENBQUM5YjtRQUMzQixPQUFPO1lBQ0wsSUFBSSxDQUFDLENBQUN4d0MsVUFBVTtRQUNsQjtJQUNGO0lBQ0EsSUFBSXYwRCxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUMsQ0FBQysxRSxVQUFVLENBQUMvMUUsT0FBTztJQUNqQztJQUNBLENBQUNELE9BQU87UUFDTixJQUFJLENBQUMsQ0FBQ2cyRSxVQUFVLENBQUNoMkUsT0FBTztRQUN4QixJQUFJLENBQUMsQ0FBQzI0RyxjQUFjLENBQUM5dUUsSUFBSSxDQUFDLGFBQWE7WUFDckNuUyxXQUFXLElBQUksQ0FBQ0EsU0FBUztRQUMzQjtJQUNGO0lBQ0EsSUFBSXN0RSxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsSUFBSTtJQUNuQjtJQUNBLElBQUkyVCxpQkFBaUI7UUFDbkIsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsY0FBYztJQUM3QjtJQUNBLENBQUNtSSxrQkFBa0IsQ0FBQzliLElBQUk7UUFDdEIsSUFBSSxDQUFDLENBQUNBLElBQUksR0FBR0E7UUFDYixJQUFJLENBQUMsQ0FBQzJULGNBQWMsR0FBRyxJQUFJempDLGVBQWUsUUFBUSxVQUFVOHZCO1FBQzVELElBQUksQ0FBQyxDQUFDMlQsY0FBYyxDQUFDNXhELEVBQUUsQ0FBQyxTQUFTLEtBQU87UUFDeEMsSUFBSSxDQUFDLENBQUMvbUQsT0FBTztJQUNmO0lBQ0EsQ0FBQ3cwRCxVQUFVO1FBQ1QsSUFBSWdpRCxVQUFVLENBQUM4SixnQkFBZ0IsSUFBSTlKLFVBQVUsQ0FBQ3VLLDhCQUE4QixFQUFFO1lBQzVFLElBQUksQ0FBQyxDQUFDQyxlQUFlO1lBQ3JCO1FBQ0Y7UUFDQSxJQUFJLEVBQ0Y3YixTQUFTLEVBQ1YsR0FBR3FSO1FBQ0osSUFBSTtZQUNGLElBQUksQ0FBQ0EsVUFBVWdLLGFBQWEsQ0FBQ3J6RyxPQUFPaW1FLFFBQVEsRUFBRSt4QixZQUFZO2dCQUN4REEsWUFBWXFSLFVBQVVrSyxpQkFBaUIsQ0FBQyxJQUFJdG5HLElBQUkrckYsV0FBV2g0RixPQUFPaW1FLFFBQVEsRUFBRWozRCxJQUFJO1lBQ2xGO1lBQ0EsTUFBTW82RixTQUFTLElBQUlyUixPQUFPQyxXQUFXO2dCQUNuQzdtRyxNQUFNO1lBQ1I7WUFDQSxNQUFNcTZHLGlCQUFpQixJQUFJempDLGVBQWUsUUFBUSxVQUFVcWhDO1lBQzVELE1BQU0wSyxpQkFBaUI7Z0JBQ3JCejhFLEdBQUdJLEtBQUs7Z0JBQ1IrekUsZUFBZWxnRSxPQUFPO2dCQUN0Qjg5RCxPQUFPbmlDLFNBQVM7Z0JBQ2hCLElBQUksSUFBSSxDQUFDcWtDLFNBQVMsRUFBRTtvQkFDbEIsSUFBSSxDQUFDLENBQUN6aUMsVUFBVSxDQUFDajJFLE1BQU0sQ0FBQyxJQUFJK1QsTUFBTTtnQkFDcEMsT0FBTztvQkFDTCxJQUFJLENBQUMsQ0FBQ2t0RyxlQUFlO2dCQUN2QjtZQUNGO1lBQ0EsTUFBTXg4RSxLQUFLLElBQUlDO1lBQ2Y4eEUsT0FBT3p4RSxnQkFBZ0IsQ0FBQyxTQUFTO2dCQUMvQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNzN0UsU0FBUyxFQUFFO29CQUNwQmE7Z0JBQ0Y7WUFDRixHQUFHO2dCQUNEdjhFLFFBQVFGLEdBQUdFLE1BQU07WUFDbkI7WUFDQWkwRSxlQUFlNXhELEVBQUUsQ0FBQyxRQUFRN2dELENBQUFBO2dCQUN4QnMrQixHQUFHSSxLQUFLO2dCQUNSLElBQUksSUFBSSxDQUFDNnpFLFNBQVMsSUFBSSxDQUFDdnlHLE1BQU07b0JBQzNCKzZHO29CQUNBO2dCQUNGO2dCQUNBLElBQUksQ0FBQyxDQUFDdEksY0FBYyxHQUFHQTtnQkFDdkIsSUFBSSxDQUFDLENBQUMzVCxJQUFJLEdBQUd1UjtnQkFDYixJQUFJLENBQUMsQ0FBQzZKLFNBQVMsR0FBRzdKO2dCQUNsQixJQUFJLENBQUMsQ0FBQ3YyRyxPQUFPO1lBQ2Y7WUFDQTI0RyxlQUFlNXhELEVBQUUsQ0FBQyxTQUFTN2dELENBQUFBO2dCQUN6QnMrQixHQUFHSSxLQUFLO2dCQUNSLElBQUksSUFBSSxDQUFDNnpFLFNBQVMsRUFBRTtvQkFDbEJ3STtvQkFDQTtnQkFDRjtnQkFDQSxJQUFJO29CQUNGQztnQkFDRixFQUFFLE9BQU07b0JBQ04sSUFBSSxDQUFDLENBQUNGLGVBQWU7Z0JBQ3ZCO1lBQ0Y7WUFDQSxNQUFNRSxXQUFXO2dCQUNmLE1BQU1DLFVBQVUsSUFBSWpuSDtnQkFDcEJ5K0csZUFBZTl1RSxJQUFJLENBQUMsUUFBUXMzRSxTQUFTO29CQUFDQSxRQUFROW1ILE1BQU07aUJBQUM7WUFDdkQ7WUFDQTZtSDtZQUNBO1FBQ0YsRUFBRSxPQUFNO1lBQ05ucEYsS0FBSztRQUNQO1FBQ0EsSUFBSSxDQUFDLENBQUNpcEYsZUFBZTtJQUN2QjtJQUNBLENBQUNBLGVBQWU7UUFDZCxJQUFJLENBQUN4SyxVQUFVLENBQUM4SixnQkFBZ0IsRUFBRTtZQUNoQ3BvRixLQUFLO1lBQ0xzK0UsVUFBVSxDQUFDOEosZ0JBQWdCLEdBQUc7UUFDaEM7UUFDQTlKLFVBQVU0SyxzQkFBc0IsQ0FBQzltRSxJQUFJLENBQUMrbUUsQ0FBQUE7WUFDcEMsSUFBSSxJQUFJLENBQUM1SSxTQUFTLEVBQUU7Z0JBQ2xCLElBQUksQ0FBQyxDQUFDemlDLFVBQVUsQ0FBQ2oyRSxNQUFNLENBQUMsSUFBSStULE1BQU07Z0JBQ2xDO1lBQ0Y7WUFDQSxNQUFNa3hGLE9BQU8sSUFBSW54QjtZQUNqQixJQUFJLENBQUMsQ0FBQ214QixJQUFJLEdBQUdBO1lBQ2IsTUFBTTE2RixLQUFLLENBQUMsSUFBSSxFQUFFa3NHLFVBQVUsQ0FBQzZKLFlBQVksR0FBRyxDQUFDO1lBQzdDLE1BQU1pQixnQkFBZ0IsSUFBSXBzQyxlQUFlNXFFLEtBQUssV0FBV0EsSUFBSTA2RjtZQUM3RHFjLHFCQUFxQkUsS0FBSyxDQUFDRCxlQUFldGM7WUFDMUMsSUFBSSxDQUFDLENBQUMyVCxjQUFjLEdBQUcsSUFBSXpqQyxlQUFlNXFFLElBQUlBLEtBQUssV0FBVzA2RjtZQUM5RCxJQUFJLENBQUMsQ0FBQ2hsRyxPQUFPO1FBQ2YsR0FBRzQ0RSxLQUFLLENBQUMvekMsQ0FBQUE7WUFDUCxJQUFJLENBQUMsQ0FBQ214QyxVQUFVLENBQUNqMkUsTUFBTSxDQUFDLElBQUkrVCxNQUFNLENBQUMsZ0NBQWdDLEVBQUUrd0IsT0FBTzV2QixPQUFPLENBQUMsRUFBRSxDQUFDO1FBQ3pGO0lBQ0Y7SUFDQXdqQyxVQUFVO1FBQ1IsSUFBSSxDQUFDZ2dFLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUMsQ0FBQzJILFNBQVMsRUFBRWhzQztRQUNqQixJQUFJLENBQUMsQ0FBQ2dzQyxTQUFTLEdBQUc7UUFDbEI1SixVQUFVLENBQUMrSixXQUFXLENBQUNwcEUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDNnRELElBQUk7UUFDeEMsSUFBSSxDQUFDLENBQUNBLElBQUksR0FBRztRQUNiLElBQUksQ0FBQyxDQUFDMlQsY0FBYyxFQUFFbGdFO1FBQ3RCLElBQUksQ0FBQyxDQUFDa2dFLGNBQWMsR0FBRztJQUN6QjtJQUNBLE9BQU81MEcsT0FBTzZMLE1BQU0sRUFBRTtRQUNwQixNQUFNNHhHLGFBQWEsSUFBSSxDQUFDLENBQUNqQixXQUFXLENBQUMzb0gsR0FBRyxDQUFDZ1ksUUFBUW8xRjtRQUNqRCxJQUFJd2MsWUFBWTtZQUNkLElBQUlBLFdBQVdySSxlQUFlLEVBQUU7Z0JBQzlCLE1BQU0sSUFBSXJsRyxNQUFNLHdEQUF3RDtZQUMxRTtZQUNBLE9BQU8wdEc7UUFDVDtRQUNBLE9BQU8sSUFBSWhMLFVBQVU1bUc7SUFDdkI7SUFDQSxXQUFXdTFGLFlBQVk7UUFDckIsSUFBSUosb0JBQW9CSSxTQUFTLEVBQUU7WUFDakMsT0FBT0osb0JBQW9CSSxTQUFTO1FBQ3RDO1FBQ0EsTUFBTSxJQUFJcnhGLE1BQU07SUFDbEI7SUFDQSxXQUFXLENBQUNpdEcsOEJBQThCO1FBQ3hDLElBQUk7WUFDRixPQUFPam5ILFdBQVcybkgsV0FBVyxFQUFFSix3QkFBd0I7UUFDekQsRUFBRSxPQUFNO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFDQSxXQUFXRCx5QkFBeUI7UUFDbEMsTUFBTU0sU0FBUztZQUNiLElBQUksSUFBSSxDQUFDLENBQUNYLDhCQUE4QixFQUFFO2dCQUN4QyxPQUFPLElBQUksQ0FBQyxDQUFDQSw4QkFBOEI7WUFDN0M7WUFDQSxNQUFNeEssU0FBUyxNQUFNLE1BQU0sQ0FDM0IscUJBQXFCLEdBQ3JCLGNBQWMsR0FDZCxJQUFJLENBQUNwUixTQUFTO1lBQ2QsT0FBT29SLE9BQU84SyxvQkFBb0I7UUFDcEM7UUFDQSxPQUFPbG9GLE9BQU8sSUFBSSxFQUFFLDBCQUEwQnVvRjtJQUNoRDtBQUNGO0FBQ0EsTUFBTTFJO0lBQ0osQ0FBQzJJLGNBQWMsQ0FBYTtJQUM1QixDQUFDQyxTQUFTLENBQWE7SUFDdkIsQ0FBQ0MsWUFBWSxDQUFhO0lBQzFCLENBQUNDLFlBQVksQ0FBYTtJQUMxQixDQUFDQyxrQkFBa0IsQ0FBUTtJQUMzQmhwSCxZQUFZNC9HLGNBQWMsRUFBRW1ELFdBQVcsRUFBRWxELGFBQWEsRUFBRWhwRyxNQUFNLEVBQUVveUcsT0FBTyxFQUFFN3BDLFNBQVMsQ0FBRTthQUxwRixDQUFDd3BDLGNBQWMsR0FBRyxJQUFJOStFO2FBQ3RCLENBQUMrK0UsU0FBUyxHQUFHLElBQUkvK0U7YUFDakIsQ0FBQ2cvRSxZQUFZLEdBQUcsSUFBSWgvRTthQUNwQixDQUFDaS9FLFlBQVksR0FBRyxJQUFJai9FO2FBQ3BCLENBQUNrL0Usa0JBQWtCLEdBQUc7UUFFcEIsSUFBSSxDQUFDcEosY0FBYyxHQUFHQTtRQUN0QixJQUFJLENBQUNtRCxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQy9tQixVQUFVLEdBQUcsSUFBSXFkO1FBQ3RCLElBQUksQ0FBQzZQLFVBQVUsR0FBRyxJQUFJNzBDLFdBQVc7WUFDL0JFLGVBQWUxOUQsT0FBTzA5RCxhQUFhO1lBQ25DQyxjQUFjMzlELE9BQU8yOUQsWUFBWTtRQUNuQztRQUNBLElBQUksQ0FBQ2lyQyxhQUFhLEdBQUc1b0csT0FBTzRvRyxhQUFhO1FBQ3pDLElBQUksQ0FBQzBKLE9BQU8sR0FBR3R5RztRQUNmLElBQUksQ0FBQzIvRSxhQUFhLEdBQUd5eUIsUUFBUXp5QixhQUFhO1FBQzFDLElBQUksQ0FBQzV2QyxhQUFhLEdBQUdxaUUsUUFBUXJpRSxhQUFhO1FBQzFDLElBQUksQ0FBQ3E0RCxpQkFBaUIsR0FBR2dLLFFBQVFoSyxpQkFBaUI7UUFDbEQsSUFBSSxDQUFDQyx1QkFBdUIsR0FBRytKLFFBQVEvSix1QkFBdUI7UUFDOUQsSUFBSSxDQUFDQyxXQUFXLEdBQUc4SixRQUFROUosV0FBVztRQUN0QyxJQUFJLENBQUNPLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUMwSixpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLGNBQWMsR0FBR3hKO1FBQ3RCLElBQUksQ0FBQ3lKLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUMzRyxzQkFBc0IsR0FBR244RyxRQUFRK1EsYUFBYTtRQUNuRCxJQUFJLENBQUM0bkUsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNvcUMsbUJBQW1CO0lBQzFCO0lBQ0EsQ0FBQ0MsaUJBQWlCLENBQUMvcEgsSUFBSSxFQUFFeU4sT0FBTyxJQUFJO1FBQ2xDLE1BQU11OEcsZ0JBQWdCLElBQUksQ0FBQyxDQUFDZCxjQUFjLENBQUMvcEgsR0FBRyxDQUFDYTtRQUMvQyxJQUFJZ3FILGVBQWU7WUFDakIsT0FBT0E7UUFDVDtRQUNBLE1BQU14aUgsVUFBVSxJQUFJLENBQUMwNEcsY0FBYyxDQUFDcGlDLGVBQWUsQ0FBQzk5RSxNQUFNeU47UUFDMUQsSUFBSSxDQUFDLENBQUN5N0csY0FBYyxDQUFDempILEdBQUcsQ0FBQ3pGLE1BQU13SDtRQUMvQixPQUFPQTtJQUNUO0lBQ0EsSUFBSXVuQyxvQkFBb0I7UUFDdEIsT0FBT3JPLE9BQU8sSUFBSSxFQUFFLHFCQUFxQixJQUFJc3lDO0lBQy9DO0lBQ0E0dkMsbUJBQW1CcjFFLE1BQU0sRUFBRWkzRSxpQkFBaUI1ekYsZUFBZUUsTUFBTSxFQUFFNHpGLHlCQUF5QixJQUFJLEVBQUV2NkQsWUFBWSxLQUFLLEVBQUU4L0QsV0FBVyxLQUFLLEVBQUU7UUFDckksSUFBSTljLGtCQUFrQmo5RSxvQkFBb0JFLE9BQU87UUFDakQsSUFBSWszRixnQ0FBZ0N2MEM7UUFDcEMsT0FBUXhsQztZQUNOLEtBQUs7Z0JBQ0g0L0Qsa0JBQWtCajlFLG9CQUFvQkMsR0FBRztnQkFDekM7WUFDRixLQUFLO2dCQUNIO1lBQ0YsS0FBSztnQkFDSGc5RSxrQkFBa0JqOUUsb0JBQW9CRyxLQUFLO2dCQUMzQztZQUNGO2dCQUNFb1AsS0FBSyxDQUFDLHFDQUFxQyxFQUFFOE4sT0FBTyxDQUFDO1FBQ3pEO1FBQ0EsTUFBTXdCLG9CQUFvQm8rRCxrQkFBa0JqOUUsb0JBQW9CRyxLQUFLLElBQUlxMEYsa0NBQWtDL3dDLHlCQUF5Qit3Qyx5QkFBeUIsSUFBSSxDQUFDMzFFLGlCQUFpQjtRQUNuTCxPQUFReTFFO1lBQ04sS0FBSzV6RixlQUFlQyxPQUFPO2dCQUN6QnM4RSxtQkFBbUJqOUUsb0JBQW9CTyxtQkFBbUI7Z0JBQzFEO1lBQ0YsS0FBS0csZUFBZUUsTUFBTTtnQkFDeEI7WUFDRixLQUFLRixlQUFlRyxZQUFZO2dCQUM5Qm84RSxtQkFBbUJqOUUsb0JBQW9CSyxpQkFBaUI7Z0JBQ3hEO1lBQ0YsS0FBS0ssZUFBZUksY0FBYztnQkFDaENtOEUsbUJBQW1CajlFLG9CQUFvQk0sbUJBQW1CO2dCQUMxRDgyRixnQ0FBZ0N2NEUsa0JBQWtCNmtDLFlBQVk7Z0JBQzlEO1lBQ0Y7Z0JBQ0VuMEMsS0FBSyxDQUFDLDZDQUE2QyxFQUFFK2tGLGVBQWUsQ0FBQztRQUN6RTtRQUNBLElBQUlyNkQsV0FBVztZQUNiZ2pELG1CQUFtQmo5RSxvQkFBb0JRLFVBQVU7UUFDbkQ7UUFDQSxJQUFJdTVGLFVBQVU7WUFDWjljLG1CQUFtQmo5RSxvQkFBb0JTLE1BQU07UUFDL0M7UUFDQSxNQUFNLEVBQ0orakQsS0FBS3hCLFdBQVcsRUFDaEJydkQsTUFBTXFtRyxlQUFlLEVBQ3RCLEdBQUduN0Usa0JBQWtCbWtDLFdBQVc7UUFDakMsTUFBTWkzQyxjQUFjO1lBQUNoZDtZQUFpQm1hLDhCQUE4QnpqRyxJQUFJO1lBQUVxbUc7U0FBZ0I7UUFDMUYsT0FBTztZQUNML2M7WUFDQS9NLFVBQVUrcEIsWUFBWXhxSCxJQUFJLENBQUM7WUFDM0Iybkg7WUFDQXAwQztRQUNGO0lBQ0Y7SUFDQWx6QixVQUFVO1FBQ1IsSUFBSSxJQUFJLENBQUMwcEUsaUJBQWlCLEVBQUU7WUFDMUIsT0FBTyxJQUFJLENBQUNBLGlCQUFpQixDQUFDbGlILE9BQU87UUFDdkM7UUFDQSxJQUFJLENBQUN3NEcsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQzBKLGlCQUFpQixHQUFHM2lILFFBQVErUSxhQUFhO1FBQzlDLElBQUksQ0FBQyxDQUFDd3hHLGtCQUFrQixFQUFFaGlILE9BQU8sSUFBSStULE1BQU07UUFDM0MsTUFBTTByRyxTQUFTLEVBQUU7UUFDakIsS0FBSyxNQUFNOTdFLFFBQVEsSUFBSSxDQUFDLENBQUNrK0UsU0FBUyxDQUFDbmxHLE1BQU0sR0FBSTtZQUMzQytpRyxPQUFPNStHLElBQUksQ0FBQzhpQyxLQUFLNjdFLFFBQVE7UUFDM0I7UUFDQSxJQUFJLENBQUMsQ0FBQ3FDLFNBQVMsQ0FBQ3prRyxLQUFLO1FBQ3JCLElBQUksQ0FBQyxDQUFDMGtHLFlBQVksQ0FBQzFrRyxLQUFLO1FBQ3hCLElBQUksQ0FBQyxDQUFDMmtHLFlBQVksQ0FBQzNrRyxLQUFLO1FBQ3hCLElBQUksSUFBSSxDQUFDeGhCLGNBQWMsQ0FBQyxzQkFBc0I7WUFDNUMsSUFBSSxDQUFDNnJDLGlCQUFpQixDQUFDeWtDLGFBQWE7UUFDdEM7UUFDQSxNQUFNNDJDLGFBQWEsSUFBSSxDQUFDbEssY0FBYyxDQUFDcGlDLGVBQWUsQ0FBQyxhQUFhO1FBQ3BFaXBDLE9BQU81K0csSUFBSSxDQUFDaWlIO1FBQ1pyakgsUUFBUXlULEdBQUcsQ0FBQ3VzRyxRQUFRbGxFLElBQUksQ0FBQztZQUN2QixJQUFJLENBQUN5NkMsVUFBVSxDQUFDNTNFLEtBQUs7WUFDckIsSUFBSSxDQUFDOGtHLFVBQVUsQ0FBQzlrRyxLQUFLO1lBQ3JCLElBQUksQ0FBQyxDQUFDd2tHLGNBQWMsQ0FBQ3hrRyxLQUFLO1lBQzFCLElBQUksQ0FBQ3dpQyxhQUFhLENBQUNsSCxPQUFPO1lBQzFCKzVELFVBQVUrQyxPQUFPO1lBQ2pCLElBQUksQ0FBQzZNLGNBQWMsRUFBRXBZLGtCQUFrQixJQUFJaHdFLGVBQWU7WUFDMUQsSUFBSSxDQUFDMitFLGNBQWMsRUFBRWxnRTtZQUNyQixJQUFJLENBQUNrZ0UsY0FBYyxHQUFHO1lBQ3RCLElBQUksQ0FBQ3dKLGlCQUFpQixDQUFDbmlILE9BQU87UUFDaEMsR0FBRyxJQUFJLENBQUNtaUgsaUJBQWlCLENBQUNwaUgsTUFBTTtRQUNoQyxPQUFPLElBQUksQ0FBQ29pSCxpQkFBaUIsQ0FBQ2xpSCxPQUFPO0lBQ3ZDO0lBQ0FzaUgsc0JBQXNCO1FBQ3BCLE1BQU0sRUFDSjVKLGNBQWMsRUFDZG1ELFdBQVcsRUFDWixHQUFHLElBQUk7UUFDUm5ELGVBQWU1eEQsRUFBRSxDQUFDLGFBQWEsQ0FBQzdnRCxNQUFNNDhHO1lBQ3BDMXFGLE9BQU8sSUFBSSxDQUFDZ3FGLGNBQWMsRUFBRTtZQUM1QixJQUFJLENBQUNDLFdBQVcsR0FBRyxJQUFJLENBQUNELGNBQWMsQ0FBQzFZLGFBQWE7WUFDcEQsSUFBSSxDQUFDMlksV0FBVyxDQUFDOVksVUFBVSxHQUFHaG1ELENBQUFBO2dCQUM1QixJQUFJLENBQUMrK0QsYUFBYSxHQUFHO29CQUNuQmx6QyxRQUFRN3JCLElBQUk2ckIsTUFBTTtvQkFDbEJ3NUIsT0FBT3JsRCxJQUFJcWxELEtBQUs7Z0JBQ2xCO1lBQ0Y7WUFDQWthLEtBQUtuckMsTUFBTSxHQUFHO2dCQUNaLElBQUksQ0FBQzBxQyxXQUFXLENBQUN4Z0gsSUFBSSxHQUFHeTRDLElBQUksQ0FBQyxTQUFVLEVBQ3JDMWpELEtBQUssRUFDTGlFLElBQUksRUFDTDtvQkFDQyxJQUFJQSxNQUFNO3dCQUNSaW9ILEtBQUtoZ0gsS0FBSzt3QkFDVjtvQkFDRjtvQkFDQXMxQixPQUFPeGhDLGlCQUFpQnFJLGFBQWE7b0JBQ3JDNmpILEtBQUt4ckMsT0FBTyxDQUFDLElBQUlwOUUsV0FBV3RELFFBQVEsR0FBRzt3QkFBQ0E7cUJBQU07Z0JBQ2hELEdBQUdnaUYsS0FBSyxDQUFDL3pDLENBQUFBO29CQUNQaStFLEtBQUtyc0gsS0FBSyxDQUFDb3VDO2dCQUNiO1lBQ0Y7WUFDQWkrRSxLQUFLbHJDLFFBQVEsR0FBRy95QyxDQUFBQTtnQkFDZCxJQUFJLENBQUN3OUUsV0FBVyxDQUFDL3NELE1BQU0sQ0FBQ3p3QjtnQkFDeEJpK0UsS0FBS3ByQyxLQUFLLENBQUNrQixLQUFLLENBQUNtcUMsQ0FBQUE7b0JBQ2YsSUFBSSxJQUFJLENBQUN0SyxTQUFTLEVBQUU7d0JBQ2xCO29CQUNGO29CQUNBLE1BQU1zSztnQkFDUjtZQUNGO1FBQ0Y7UUFDQXBLLGVBQWU1eEQsRUFBRSxDQUFDLHNCQUFzQixPQUFNN2dEO1lBQzVDLE1BQU0sSUFBSSxDQUFDbThHLFdBQVcsQ0FBQzlYLFlBQVk7WUFDbkMsTUFBTSxFQUNKRSxvQkFBb0IsRUFDcEJELGdCQUFnQixFQUNoQkUsYUFBYSxFQUNkLEdBQUcsSUFBSSxDQUFDMlgsV0FBVztZQUNwQixJQUFJLENBQUM1WCx3QkFBd0IsQ0FBQ0Qsa0JBQWtCO2dCQUM5QyxJQUFJLElBQUksQ0FBQzhYLGFBQWEsRUFBRTtvQkFDdEJ4RyxZQUFZdlMsVUFBVSxHQUFHLElBQUksQ0FBQytZLGFBQWE7Z0JBQzdDO2dCQUNBLElBQUksQ0FBQ0QsV0FBVyxDQUFDOVksVUFBVSxHQUFHaG1ELENBQUFBO29CQUM1QnU0RCxZQUFZdlMsVUFBVSxHQUFHO3dCQUN2Qm42QixRQUFRN3JCLElBQUk2ckIsTUFBTTt3QkFDbEJ3NUIsT0FBT3JsRCxJQUFJcWxELEtBQUs7b0JBQ2xCO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPO2dCQUNMNkI7Z0JBQ0FEO2dCQUNBRTtZQUNGO1FBQ0Y7UUFDQWlPLGVBQWU1eEQsRUFBRSxDQUFDLGtCQUFrQixDQUFDN2dELE1BQU00OEc7WUFDekMxcUYsT0FBTyxJQUFJLENBQUNncUYsY0FBYyxFQUFFO1lBQzVCLE1BQU1qWixjQUFjLElBQUksQ0FBQ2laLGNBQWMsQ0FBQ3ZZLGNBQWMsQ0FBQzNqRyxLQUFLdWlHLEtBQUssRUFBRXZpRyxLQUFLaVosR0FBRztZQUMzRSxJQUFJLENBQUNncUYsYUFBYTtnQkFDaEIyWixLQUFLaGdILEtBQUs7Z0JBQ1Y7WUFDRjtZQUNBZ2dILEtBQUtuckMsTUFBTSxHQUFHO2dCQUNad3hCLFlBQVl0bkcsSUFBSSxHQUFHeTRDLElBQUksQ0FBQyxTQUFVLEVBQ2hDMWpELEtBQUssRUFDTGlFLElBQUksRUFDTDtvQkFDQyxJQUFJQSxNQUFNO3dCQUNSaW9ILEtBQUtoZ0gsS0FBSzt3QkFDVjtvQkFDRjtvQkFDQXMxQixPQUFPeGhDLGlCQUFpQnFJLGFBQWE7b0JBQ3JDNmpILEtBQUt4ckMsT0FBTyxDQUFDLElBQUlwOUUsV0FBV3RELFFBQVEsR0FBRzt3QkFBQ0E7cUJBQU07Z0JBQ2hELEdBQUdnaUYsS0FBSyxDQUFDL3pDLENBQUFBO29CQUNQaStFLEtBQUtyc0gsS0FBSyxDQUFDb3VDO2dCQUNiO1lBQ0Y7WUFDQWkrRSxLQUFLbHJDLFFBQVEsR0FBRy95QyxDQUFBQTtnQkFDZHNrRSxZQUFZN3pDLE1BQU0sQ0FBQ3p3QjtnQkFDbkJpK0UsS0FBS3ByQyxLQUFLLENBQUNrQixLQUFLLENBQUNtcUMsQ0FBQUE7b0JBQ2YsSUFBSSxJQUFJLENBQUN0SyxTQUFTLEVBQUU7d0JBQ2xCO29CQUNGO29CQUNBLE1BQU1zSztnQkFDUjtZQUNGO1FBQ0Y7UUFDQXBLLGVBQWU1eEQsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUMzQit5RCxPQUFPLEVBQ1I7WUFDQyxJQUFJLENBQUNrSixTQUFTLEdBQUdsSixRQUFRRSxRQUFRO1lBQ2pDLElBQUksQ0FBQ0csV0FBVyxHQUFHTCxRQUFRbUosVUFBVTtZQUNyQyxPQUFPbkosUUFBUW1KLFVBQVU7WUFDekJuSCxZQUFZNUMsV0FBVyxDQUFDbDVHLE9BQU8sQ0FBQyxJQUFJNjVHLGlCQUFpQkMsU0FBUyxJQUFJO1FBQ3BFO1FBQ0FuQixlQUFlNXhELEVBQUUsQ0FBQyxnQkFBZ0J6bEIsQ0FBQUE7WUFDaEN3NkUsWUFBWTVDLFdBQVcsQ0FBQ241RyxNQUFNLENBQUNrMUUsV0FBVzN6QztRQUM1QztRQUNBcTNFLGVBQWU1eEQsRUFBRSxDQUFDLG1CQUFtQnpsQixDQUFBQTtZQUNuQyxJQUFJLENBQUMsQ0FBQ3lnRixrQkFBa0IsR0FBR3ZpSCxRQUFRK1EsYUFBYTtZQUNoRCxJQUFJO2dCQUNGLElBQUksQ0FBQ3VyRyxZQUFZMUMsVUFBVSxFQUFFO29CQUMzQixNQUFNbmtDLFdBQVczekM7Z0JBQ25CO2dCQUNBLE1BQU00aEYsaUJBQWlCOU0sQ0FBQUE7b0JBQ3JCLElBQUlBLG9CQUFvQnRpRyxPQUFPO3dCQUM3QixJQUFJLENBQUMsQ0FBQ2l1RyxrQkFBa0IsQ0FBQ2hpSCxNQUFNLENBQUNxMkc7b0JBQ2xDLE9BQU87d0JBQ0wsSUFBSSxDQUFDLENBQUMyTCxrQkFBa0IsQ0FBQy9oSCxPQUFPLENBQUM7NEJBQy9CbzJHO3dCQUNGO29CQUNGO2dCQUNGO2dCQUNBMEYsWUFBWTFDLFVBQVUsQ0FBQzhKLGdCQUFnQjVoRixHQUFHOUgsSUFBSTtZQUNoRCxFQUFFLE9BQU8ycEYsS0FBSztnQkFDWixJQUFJLENBQUMsQ0FBQ3BCLGtCQUFrQixDQUFDaGlILE1BQU0sQ0FBQ29qSDtZQUNsQztZQUNBLE9BQU8sSUFBSSxDQUFDLENBQUNwQixrQkFBa0IsQ0FBQzloSCxPQUFPO1FBQ3pDO1FBQ0EwNEcsZUFBZTV4RCxFQUFFLENBQUMsY0FBYzdnRCxDQUFBQTtZQUM5QjQxRyxZQUFZdlMsVUFBVSxHQUFHO2dCQUN2Qm42QixRQUFRbHBFLEtBQUt2USxNQUFNO2dCQUNuQml6RyxPQUFPMWlHLEtBQUt2USxNQUFNO1lBQ3BCO1lBQ0EsSUFBSSxDQUFDZ21ILHNCQUFzQixDQUFDMzdHLE9BQU8sQ0FBQ2tHO1FBQ3RDO1FBQ0F5eUcsZUFBZTV4RCxFQUFFLENBQUMsbUJBQW1CN2dELENBQUFBO1lBQ25DLElBQUksSUFBSSxDQUFDdXlHLFNBQVMsRUFBRTtnQkFDbEI7WUFDRjtZQUNBLE1BQU0vMEUsT0FBTyxJQUFJLENBQUMsQ0FBQ2srRSxTQUFTLENBQUNocUgsR0FBRyxDQUFDc08sS0FBSzQvQyxTQUFTO1lBQy9DcGlCLEtBQUtrOEUsZ0JBQWdCLENBQUMxNUcsS0FBS293RixZQUFZLEVBQUVwd0YsS0FBSzJ5RixRQUFRO1FBQ3hEO1FBQ0E4ZixlQUFlNXhELEVBQUUsQ0FBQyxhQUFhLENBQUMsQ0FBQ3o4QyxJQUFJaE0sTUFBTThrSCxhQUFhO1lBQ3RELElBQUksSUFBSSxDQUFDM0ssU0FBUyxFQUFFO2dCQUNsQixPQUFPO1lBQ1Q7WUFDQSxJQUFJLElBQUksQ0FBQzFqQixVQUFVLENBQUM1MkYsR0FBRyxDQUFDbU0sS0FBSztnQkFDM0IsT0FBTztZQUNUO1lBQ0EsT0FBUWhNO2dCQUNOLEtBQUs7b0JBQ0gsSUFBSSxXQUFXOGtILGNBQWM7d0JBQzNCLE1BQU1DLGdCQUFnQkQsYUFBYTNzSCxLQUFLO3dCQUN4Q3loQyxLQUFLLENBQUMsMkJBQTJCLEVBQUVtckYsY0FBYyxDQUFDO3dCQUNsRCxJQUFJLENBQUN0dUIsVUFBVSxDQUFDLzBGLE9BQU8sQ0FBQ3NLLElBQUkrNEc7d0JBQzVCO29CQUNGO29CQUNBLE1BQU1yeUMsV0FBVyxJQUFJZ3lCLFNBQVNvZ0I7b0JBQzlCLE1BQU1seUMsY0FBYyxJQUFJLENBQUNneEMsT0FBTyxDQUFDekssTUFBTSxJQUFJMzlHLFdBQVd5NUcsYUFBYSxFQUFFaCtDLFVBQVUsQ0FBQ3laLE1BQU0xMUQsTUFBUXhmLFdBQVd5NUcsYUFBYSxDQUFDK1AsU0FBUyxDQUFDdDBDLE1BQU0xMUQsT0FBTztvQkFDOUksTUFBTTAxRCxPQUFPLElBQUkrQixlQUFlQyxVQUFVRSxhQUFha3lDLGFBQWFqeUMsS0FBSyxFQUFFaXlDLGFBQWFoeUMsb0JBQW9CO29CQUM1RyxJQUFJLENBQUM2d0MsVUFBVSxDQUFDdm1ILElBQUksQ0FBQ3N6RSxNQUFNNEosS0FBSyxDQUFDLElBQU0rL0IsZUFBZXBpQyxlQUFlLENBQUMsZ0JBQWdCOzRCQUNwRmpzRTt3QkFDRixJQUFJbXBHLE9BQU8sQ0FBQzt3QkFDVixJQUFJLENBQUN6a0MsS0FBS21ELG1CQUFtQixJQUFJbkQsS0FBSzlvRSxJQUFJLEVBQUU7NEJBQzFDOG9FLEtBQUtpRSxTQUFTO3dCQUNoQjt3QkFDQSxJQUFJLENBQUM4aEIsVUFBVSxDQUFDLzBGLE9BQU8sQ0FBQ3NLLElBQUkwa0U7b0JBQzlCO29CQUNBO2dCQUNGLEtBQUs7b0JBQ0gsTUFBTSxFQUNKdTBDLFFBQVEsRUFDVCxHQUFHSDtvQkFDSmhyRixPQUFPbXJGLFVBQVU7b0JBQ2pCLEtBQUssTUFBTUMsYUFBYSxJQUFJLENBQUMsQ0FBQzVCLFNBQVMsQ0FBQ25sRyxNQUFNLEdBQUk7d0JBQ2hELEtBQUssTUFBTSxHQUFHdlcsS0FBSyxJQUFJczlHLFVBQVUzeEMsSUFBSSxDQUFFOzRCQUNyQyxJQUFJM3JFLE1BQU1xMEcsUUFBUWdKLFVBQVU7Z0NBQzFCOzRCQUNGOzRCQUNBLElBQUksQ0FBQ3I5RyxLQUFLdTlHLE9BQU8sRUFBRTtnQ0FDakIsT0FBTzs0QkFDVDs0QkFDQSxJQUFJLENBQUMxdUIsVUFBVSxDQUFDLzBGLE9BQU8sQ0FBQ3NLLElBQUl0TCxnQkFBZ0JrSDs0QkFDNUMsT0FBT0EsS0FBS3U5RyxPQUFPO3dCQUNyQjtvQkFDRjtvQkFDQTtnQkFDRixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSCxJQUFJLENBQUMxdUIsVUFBVSxDQUFDLzBGLE9BQU8sQ0FBQ3NLLElBQUk4NEc7b0JBQzVCO2dCQUNGO29CQUNFLE1BQU0sSUFBSXR2RyxNQUFNLENBQUMsK0JBQStCLEVBQUV4VixLQUFLLENBQUM7WUFDNUQ7WUFDQSxPQUFPO1FBQ1Q7UUFDQXE2RyxlQUFlNXhELEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQ3o4QyxJQUFJdzdDLFdBQVd4bkQsTUFBTW15RSxVQUFVO1lBQ3hELElBQUksSUFBSSxDQUFDZ29DLFNBQVMsRUFBRTtnQkFDbEI7WUFDRjtZQUNBLE1BQU0rSyxZQUFZLElBQUksQ0FBQyxDQUFDNUIsU0FBUyxDQUFDaHFILEdBQUcsQ0FBQ2t1RDtZQUN0QyxJQUFJMDlELFVBQVUzeEMsSUFBSSxDQUFDMXpFLEdBQUcsQ0FBQ21NLEtBQUs7Z0JBQzFCO1lBQ0Y7WUFDQSxJQUFJazVHLFVBQVU5RyxhQUFhLENBQUMveEcsSUFBSSxLQUFLLEdBQUc7Z0JBQ3RDOGxFLFdBQVcvMEQsUUFBUTVZO2dCQUNuQjtZQUNGO1lBQ0EsT0FBUXhFO2dCQUNOLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSGtsSCxVQUFVM3hDLElBQUksQ0FBQzd4RSxPQUFPLENBQUNzSyxJQUFJbW1FO29CQUMzQjtnQkFDRjtvQkFDRSxNQUFNLElBQUkzOEQsTUFBTSxDQUFDLHdCQUF3QixFQUFFeFYsS0FBSyxDQUFDO1lBQ3JEO1FBQ0Y7UUFDQXE2RyxlQUFlNXhELEVBQUUsQ0FBQyxlQUFlN2dELENBQUFBO1lBQy9CLElBQUksSUFBSSxDQUFDdXlHLFNBQVMsRUFBRTtnQkFDbEI7WUFDRjtZQUNBcUQsWUFBWXZTLFVBQVUsR0FBRztnQkFDdkJuNkIsUUFBUWxwRSxLQUFLa3BFLE1BQU07Z0JBQ25CdzVCLE9BQU8xaUcsS0FBSzBpRyxLQUFLO1lBQ25CO1FBQ0Y7UUFDQStQLGVBQWU1eEQsRUFBRSxDQUFDLG1CQUFtQixPQUFNN2dEO1lBQ3pDLElBQUksSUFBSSxDQUFDdXlHLFNBQVMsRUFBRTtnQkFDbEIsTUFBTSxJQUFJM2tHLE1BQU07WUFDbEI7WUFDQSxNQUFNa3VHLFVBQVUsSUFBSSxDQUFDOTdHLEtBQUs1SCxJQUFJLENBQUM7WUFDL0IsSUFBSSxDQUFDMGpILFNBQVM7Z0JBQ1osTUFBTSxJQUFJbHVHLE1BQU0sQ0FBQyxFQUFFNU4sS0FBSzVILElBQUksQ0FBQyx1REFBdUQsQ0FBQztZQUN2RjtZQUNBLE9BQU8wakgsUUFBUS80RSxLQUFLLENBQUMvaUM7UUFDdkI7SUFDRjtJQUNBZ2dELFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQ3l5RCxjQUFjLENBQUNwaUMsZUFBZSxDQUFDLFdBQVc7SUFDeEQ7SUFDQWtsQyxlQUFlO1FBQ2IsSUFBSSxJQUFJLENBQUNqMEUsaUJBQWlCLENBQUM3OEIsSUFBSSxJQUFJLEdBQUc7WUFDcEN1dEIsS0FBSyw2REFBNkQ7UUFDcEU7UUFDQSxNQUFNLEVBQ0oxM0IsR0FBRyxFQUNIckIsUUFBUSxFQUNULEdBQUcsSUFBSSxDQUFDcW9DLGlCQUFpQixDQUFDNmtDLFlBQVk7UUFDdkMsT0FBTyxJQUFJLENBQUNzc0MsY0FBYyxDQUFDcGlDLGVBQWUsQ0FBQyxnQkFBZ0I7WUFDekQyakMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDQyxXQUFXO1lBQzdCSCxVQUFVLElBQUksQ0FBQ2dKLFNBQVM7WUFDeEJ4N0UsbUJBQW1CaG5DO1lBQ25CeXJDLFVBQVUsSUFBSSxDQUFDbzJFLFdBQVcsRUFBRXAyRSxZQUFZO1FBQzFDLEdBQUc5c0MsVUFBVXMwRyxPQUFPLENBQUM7WUFDbkIsSUFBSSxDQUFDanNFLGlCQUFpQixDQUFDeWtDLGFBQWE7UUFDdEM7SUFDRjtJQUNBb3VDLFFBQVF6ekQsVUFBVSxFQUFFO1FBQ2xCLElBQUksQ0FBQ3IrQyxPQUFPc3ZCLFNBQVMsQ0FBQyt1QixlQUFlQSxjQUFjLEtBQUtBLGFBQWEsSUFBSSxDQUFDbzhELFNBQVMsRUFBRTtZQUNuRixPQUFPeGpILFFBQVFPLE1BQU0sQ0FBQyxJQUFJK1QsTUFBTTtRQUNsQztRQUNBLE1BQU1neUMsWUFBWWMsYUFBYSxHQUM3QjY3RCxnQkFBZ0IsSUFBSSxDQUFDLENBQUNaLFlBQVksQ0FBQ2pxSCxHQUFHLENBQUNrdUQ7UUFDekMsSUFBSTI4RCxlQUFlO1lBQ2pCLE9BQU9BO1FBQ1Q7UUFDQSxNQUFNeGlILFVBQVUsSUFBSSxDQUFDMDRHLGNBQWMsQ0FBQ3BpQyxlQUFlLENBQUMsV0FBVztZQUM3RHp3QjtRQUNGLEdBQUd4TCxJQUFJLENBQUMraEUsQ0FBQUE7WUFDTixJQUFJLElBQUksQ0FBQzVELFNBQVMsRUFBRTtnQkFDbEIsTUFBTSxJQUFJM2tHLE1BQU07WUFDbEI7WUFDQSxJQUFJdW9HLFNBQVNxSCxNQUFNLEVBQUU7Z0JBQ25CLElBQUksQ0FBQyxDQUFDNUIsWUFBWSxDQUFDNWpILEdBQUcsQ0FBQ20rRyxTQUFTcUgsTUFBTSxFQUFFOThEO1lBQzFDO1lBQ0EsTUFBTWxqQixPQUFPLElBQUl5NEUsYUFBYXIyRCxXQUFXdTJELFVBQVUsSUFBSSxFQUFFLElBQUksQ0FBQzZGLE9BQU8sQ0FBQ3pLLE1BQU07WUFDNUUsSUFBSSxDQUFDLENBQUNtSyxTQUFTLENBQUMxakgsR0FBRyxDQUFDNG5ELFdBQVdwaUI7WUFDL0IsT0FBT0E7UUFDVDtRQUNBLElBQUksQ0FBQyxDQUFDbStFLFlBQVksQ0FBQzNqSCxHQUFHLENBQUM0bkQsV0FBVzdsRDtRQUNsQyxPQUFPQTtJQUNUO0lBQ0FxNkcsYUFBYUMsR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQzltQyxXQUFXOG1DLE1BQU07WUFDcEIsT0FBTy82RyxRQUFRTyxNQUFNLENBQUMsSUFBSStULE1BQU07UUFDbEM7UUFDQSxPQUFPLElBQUksQ0FBQzZrRyxjQUFjLENBQUNwaUMsZUFBZSxDQUFDLGdCQUFnQjtZQUN6RHR5QyxLQUFLczJFLElBQUl0MkUsR0FBRztZQUNaeXZDLEtBQUs2bUMsSUFBSTdtQyxHQUFHO1FBQ2Q7SUFDRjtJQUNBbXBDLGVBQWUvMkQsU0FBUyxFQUFFOWYsTUFBTSxFQUFFO1FBQ2hDLE9BQU8sSUFBSSxDQUFDMnlFLGNBQWMsQ0FBQ3BpQyxlQUFlLENBQUMsa0JBQWtCO1lBQzNEendCO1lBQ0E5ZjtRQUNGO0lBQ0Y7SUFDQWcyRSxrQkFBa0I7UUFDaEIsT0FBTyxJQUFJLENBQUMsQ0FBQ3dHLGlCQUFpQixDQUFDO0lBQ2pDO0lBQ0F2RyxlQUFlO1FBQ2IsT0FBTyxJQUFJLENBQUMsQ0FBQ3VHLGlCQUFpQixDQUFDO0lBQ2pDO0lBQ0F0Ryx5QkFBeUI7UUFDdkIsT0FBTyxJQUFJLENBQUN2RCxjQUFjLENBQUNwaUMsZUFBZSxDQUFDLDBCQUEwQjtJQUN2RTtJQUNBaWtDLGtCQUFrQjtRQUNoQixPQUFPLElBQUksQ0FBQzdCLGNBQWMsQ0FBQ3BpQyxlQUFlLENBQUMsbUJBQW1CO0lBQ2hFO0lBQ0Fra0MsZUFBZW53RyxFQUFFLEVBQUU7UUFDakIsSUFBSSxPQUFPQSxPQUFPLFVBQVU7WUFDMUIsT0FBTzlLLFFBQVFPLE1BQU0sQ0FBQyxJQUFJK1QsTUFBTTtRQUNsQztRQUNBLE9BQU8sSUFBSSxDQUFDNmtHLGNBQWMsQ0FBQ3BpQyxlQUFlLENBQUMsa0JBQWtCO1lBQzNEanNFO1FBQ0Y7SUFDRjtJQUNBb3dHLGdCQUFnQjtRQUNkLE9BQU8sSUFBSSxDQUFDL0IsY0FBYyxDQUFDcGlDLGVBQWUsQ0FBQyxpQkFBaUI7SUFDOUQ7SUFDQW9rQyxnQkFBZ0I7UUFDZCxPQUFPLElBQUksQ0FBQ2hDLGNBQWMsQ0FBQ3BpQyxlQUFlLENBQUMsaUJBQWlCO0lBQzlEO0lBQ0Fxa0MsY0FBYztRQUNaLE9BQU8sSUFBSSxDQUFDakMsY0FBYyxDQUFDcGlDLGVBQWUsQ0FBQyxlQUFlO0lBQzVEO0lBQ0Fza0MsdUJBQXVCO1FBQ3JCLE9BQU8sSUFBSSxDQUFDbEMsY0FBYyxDQUFDcGlDLGVBQWUsQ0FBQyx3QkFBd0I7SUFDckU7SUFDQXVrQyxnQkFBZ0I7UUFDZCxPQUFPLElBQUksQ0FBQ25DLGNBQWMsQ0FBQ3BpQyxlQUFlLENBQUMsaUJBQWlCO0lBQzlEO0lBQ0F3a0MsaUJBQWlCO1FBQ2YsT0FBTyxJQUFJLENBQUNwQyxjQUFjLENBQUNwaUMsZUFBZSxDQUFDLGtCQUFrQjtJQUMvRDtJQUNBNW9CLHFCQUFxQm5CLEtBQUssRUFBRXd1RCxpQkFBaUIsRUFBRTtRQUM3QyxPQUFPLElBQUksQ0FBQ3JDLGNBQWMsQ0FBQ3BpQyxlQUFlLENBQUMsd0JBQXdCO1lBQ2pFL3BCO1lBQ0F3dUQ7UUFDRjtJQUNGO0lBQ0FFLGtCQUFrQjtRQUNoQixPQUFPLElBQUksQ0FBQyxDQUFDc0gsaUJBQWlCLENBQUM7SUFDakM7SUFDQTFGLGlCQUFpQmgzRCxTQUFTLEVBQUU7UUFDMUIsT0FBTyxJQUFJLENBQUM2eUQsY0FBYyxDQUFDcGlDLGVBQWUsQ0FBQyxvQkFBb0I7WUFDN0R6d0I7UUFDRjtJQUNGO0lBQ0F3NUQsY0FBY3g1RCxTQUFTLEVBQUU7UUFDdkIsT0FBTyxJQUFJLENBQUM2eUQsY0FBYyxDQUFDcGlDLGVBQWUsQ0FBQyxpQkFBaUI7WUFDMUR6d0I7UUFDRjtJQUNGO0lBQ0FxMUQsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDeEMsY0FBYyxDQUFDcGlDLGVBQWUsQ0FBQyxjQUFjO0lBQzNEO0lBQ0E2a0MseUJBQXlCeFYsZUFBZSxFQUFFO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLENBQUM0YyxpQkFBaUIsQ0FBQyw0QkFBNEJsb0UsSUFBSSxDQUFDcDBDLENBQUFBLE9BQVEsSUFBSWlnRyxzQkFBc0JqZ0csTUFBTTAvRjtJQUMxRztJQUNBMFYsaUJBQWlCO1FBQ2YsT0FBTyxJQUFJLENBQUMzQyxjQUFjLENBQUNwaUMsZUFBZSxDQUFDLGtCQUFrQjtJQUMvRDtJQUNBZ2xDLGNBQWM7UUFDWixNQUFNOWlILE9BQU8sZUFDWGdxSCxnQkFBZ0IsSUFBSSxDQUFDLENBQUNkLGNBQWMsQ0FBQy9wSCxHQUFHLENBQUNhO1FBQzNDLElBQUlncUgsZUFBZTtZQUNqQixPQUFPQTtRQUNUO1FBQ0EsTUFBTXhpSCxVQUFVLElBQUksQ0FBQzA0RyxjQUFjLENBQUNwaUMsZUFBZSxDQUFDOTlFLE1BQU0sTUFBTTZoRCxJQUFJLENBQUNxcEUsQ0FBQUEsVUFBWTtnQkFDL0U1ckYsTUFBTTRyRixPQUFPLENBQUMsRUFBRTtnQkFDaEJubEgsVUFBVW1sSCxPQUFPLENBQUMsRUFBRSxHQUFHLElBQUl2ZSxTQUFTdWUsT0FBTyxDQUFDLEVBQUUsSUFBSTtnQkFDbEQ3Yiw0QkFBNEIsSUFBSSxDQUFDdWEsV0FBVyxFQUFFcDJFLFlBQVk7Z0JBQzFEeStELGVBQWUsSUFBSSxDQUFDMlgsV0FBVyxFQUFFM1gsaUJBQWlCO1lBQ3BEO1FBQ0EsSUFBSSxDQUFDLENBQUNpWCxjQUFjLENBQUN6akgsR0FBRyxDQUFDekYsTUFBTXdIO1FBQy9CLE9BQU9BO0lBQ1Q7SUFDQXU3RyxjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUM3QyxjQUFjLENBQUNwaUMsZUFBZSxDQUFDLGVBQWU7SUFDNUQ7SUFDQSxNQUFNc2xDLGFBQWFELGtCQUFrQixLQUFLLEVBQUU7UUFDMUMsSUFBSSxJQUFJLENBQUNuRCxTQUFTLEVBQUU7WUFDbEI7UUFDRjtRQUNBLE1BQU0sSUFBSSxDQUFDRSxjQUFjLENBQUNwaUMsZUFBZSxDQUFDLFdBQVc7UUFDckQsS0FBSyxNQUFNN3lDLFFBQVEsSUFBSSxDQUFDLENBQUNrK0UsU0FBUyxDQUFDbmxHLE1BQU0sR0FBSTtZQUMzQyxNQUFNbW5HLG9CQUFvQmxnRixLQUFLNnhFLE9BQU87WUFDdEMsSUFBSSxDQUFDcU8sbUJBQW1CO2dCQUN0QixNQUFNLElBQUk5dkcsTUFBTSxDQUFDLG1CQUFtQixFQUFFNHZCLEtBQUtrakIsVUFBVSxDQUFDLHdCQUF3QixDQUFDO1lBQ2pGO1FBQ0Y7UUFDQSxJQUFJLENBQUNtdUMsVUFBVSxDQUFDNTNFLEtBQUs7UUFDckIsSUFBSSxDQUFDeStGLGlCQUFpQjtZQUNwQixJQUFJLENBQUNxRyxVQUFVLENBQUM5a0csS0FBSztRQUN2QjtRQUNBLElBQUksQ0FBQyxDQUFDd2tHLGNBQWMsQ0FBQ3hrRyxLQUFLO1FBQzFCLElBQUksQ0FBQ3dpQyxhQUFhLENBQUNsSCxPQUFPLENBQUM7UUFDM0IrNUQsVUFBVStDLE9BQU87SUFDbkI7SUFDQXdHLGlCQUFpQnhCLEdBQUcsRUFBRTtRQUNwQixJQUFJLENBQUM5bUMsV0FBVzhtQyxNQUFNO1lBQ3BCLE9BQU87UUFDVDtRQUNBLE1BQU1tSixTQUFTbkosSUFBSTdtQyxHQUFHLEtBQUssSUFBSSxDQUFDLEVBQUU2bUMsSUFBSXQyRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFczJFLElBQUl0MkUsR0FBRyxDQUFDLENBQUMsRUFBRXMyRSxJQUFJN21DLEdBQUcsQ0FBQyxDQUFDO1FBQ3RFLE9BQU8sSUFBSSxDQUFDLENBQUNvdUMsWUFBWSxDQUFDbHFILEdBQUcsQ0FBQzhySCxXQUFXO0lBQzNDO0FBQ0Y7QUFDQSxNQUFNRztJQUNKLENBQUMzRixrQkFBa0IsQ0FBUTtJQUczQm5sSCxZQUFZbWxILGtCQUFrQixDQUFFO2FBSGhDLENBQUNBLGtCQUFrQixHQUFHO2FBQ3RCNEYsYUFBYTthQUNiNVUsVUFBVTtRQUVSLElBQUksQ0FBQyxDQUFDZ1Asa0JBQWtCLEdBQUdBO0lBQzdCO0lBQ0EsSUFBSWorRyxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUMsQ0FBQ2krRyxrQkFBa0IsQ0FBQ2xvQyxVQUFVLENBQUMvMUUsT0FBTztJQUNwRDtJQUNBcTFELE9BQU8xcEIsYUFBYSxDQUFDLEVBQUU7UUFDckIsSUFBSSxDQUFDLENBQUNzeUUsa0JBQWtCLENBQUM1b0QsTUFBTSxDQUFDLE1BQU0xcEI7SUFDeEM7SUFDQSxJQUFJK3hFLGlCQUFpQjtRQUNuQixNQUFNLEVBQ0pBLGNBQWMsRUFDZixHQUFHLElBQUksQ0FBQyxDQUFDTyxrQkFBa0IsQ0FBQ3QwQixZQUFZO1FBQ3pDLElBQUksQ0FBQyt6QixnQkFBZ0I7WUFDbkIsT0FBTztRQUNUO1FBQ0EsTUFBTSxFQUNKMW9CLG1CQUFtQixFQUNwQixHQUFHLElBQUksQ0FBQyxDQUFDaXBCLGtCQUFrQjtRQUM1QixPQUFPUCxlQUFlb0csSUFBSSxJQUFJcEcsZUFBZTFqRSxNQUFNLElBQUlnN0MscUJBQXFCdHFGLE9BQU87SUFDckY7QUFDRjtBQUNBLE1BQU02ekc7SUFDSixDQUFDd0YsR0FBRyxDQUFRO0lBQ1osT0FBTyxDQUFDQyxXQUFXLEdBQUcsSUFBSUMsVUFBVTtJQUNwQ25ySCxZQUFZLEVBQ1ZnYixRQUFRLEVBQ1JuRSxNQUFNLEVBQ05paUUsSUFBSSxFQUNKa2pCLFVBQVUsRUFDVkUsbUJBQW1CLEVBQ25CckwsWUFBWSxFQUNaOWpDLFNBQVMsRUFDVHlwQyxhQUFhLEVBQ2I1dkMsYUFBYSxFQUNiOCtELDJCQUEyQixLQUFLLEVBQ2hDaEgsU0FBUyxLQUFLLEVBQ2Q3MkQsYUFBYSxJQUFJLEVBQ2pCdTNCLFlBQVksS0FBSyxFQUNqQjJlLG1CQUFtQixJQUFJLEVBQ3hCLENBQUU7YUFqQkgsQ0FBQ2t0QixHQUFHLEdBQUc7UUFrQkwsSUFBSSxDQUFDandHLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDbkUsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ2lpRSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDa2pCLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDRSxtQkFBbUIsR0FBR0E7UUFDM0IsSUFBSSxDQUFDa3ZCLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUN2NkIsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUMweUIsVUFBVSxHQUFHeDJEO1FBQ2xCLElBQUksQ0FBQ3lwQyxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQzV2QyxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQzg4RCxPQUFPLEdBQUdoRjtRQUNmLElBQUksQ0FBQzcyRCxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ3dqRSxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLHFCQUFxQixHQUFHO1FBQzdCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MseUJBQXlCLEdBQUc5Riw2QkFBNkIsUUFBUSxnQkFBa0I7UUFDeEYsSUFBSSxDQUFDK0YsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ3h1QyxVQUFVLEdBQUd4MkUsUUFBUStRLGFBQWE7UUFDdkMsSUFBSSxDQUFDMmxHLElBQUksR0FBRyxJQUFJMk4sV0FBVyxJQUFJO1FBQy9CLElBQUksQ0FBQ1ksWUFBWSxHQUFHLElBQUksQ0FBQ252RCxNQUFNLENBQUM1NUQsSUFBSSxDQUFDLElBQUk7UUFDekMsSUFBSSxDQUFDZ3BILGNBQWMsR0FBRyxJQUFJLENBQUNDLFNBQVMsQ0FBQ2pwSCxJQUFJLENBQUMsSUFBSTtRQUM5QyxJQUFJLENBQUNrcEgsa0JBQWtCLEdBQUcsSUFBSSxDQUFDQyxhQUFhLENBQUNucEgsSUFBSSxDQUFDLElBQUk7UUFDdEQsSUFBSSxDQUFDb3BILFVBQVUsR0FBRyxJQUFJLENBQUNDLEtBQUssQ0FBQ3JwSCxJQUFJLENBQUMsSUFBSTtRQUN0QyxJQUFJLENBQUNzcEgsT0FBTyxHQUFHcDFHLE9BQU9xcUMsTUFBTTtRQUM1QixJQUFJLENBQUNnckUsY0FBYyxHQUFHcjFHLE9BQU9xcUMsTUFBTSxHQUFHLE9BQU9ycUMsT0FBT290RyxhQUFhO1FBQ2pFLElBQUksQ0FBQ2tJLFVBQVUsR0FBRy9zQztRQUNsQixJQUFJLENBQUNndEMsa0JBQWtCLEdBQUd2MUcsT0FBT3V6RSxpQkFBaUI7UUFDbEQsSUFBSSxDQUFDaWlDLGlCQUFpQixHQUFHdHVCO0lBQzNCO0lBQ0EsSUFBSTRvQixZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMxcEMsVUFBVSxDQUFDLzFFLE9BQU8sQ0FBQzI0RSxLQUFLLENBQUMsWUFBYTtJQUNwRDtJQUNBK2xDLG1CQUFtQixFQUNqQnJvQixlQUFlLEtBQUssRUFDcEJ0QixxQkFBcUIsRUFDdEIsRUFBRTtRQUNELElBQUksSUFBSSxDQUFDd3ZCLFNBQVMsRUFBRTtZQUNsQjtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUNRLE9BQU8sRUFBRTtZQUNoQixJQUFJeEcsbUJBQW1CLENBQUN5RixXQUFXLENBQUM5bEgsR0FBRyxDQUFDLElBQUksQ0FBQzZtSCxPQUFPLEdBQUc7Z0JBQ3JELE1BQU0sSUFBSWx4RyxNQUFNLHFFQUFxRSw2REFBNkQ7WUFDcEo7WUFDQTBxRyxtQkFBbUIsQ0FBQ3lGLFdBQVcsQ0FBQ3o0RyxHQUFHLENBQUMsSUFBSSxDQUFDdzVHLE9BQU87UUFDbEQ7UUFDQSxJQUFJLElBQUksQ0FBQ3ZJLE9BQU8sSUFBSTNpSCxXQUFXaWtILGNBQWMsRUFBRXhvRCxTQUFTO1lBQ3RELElBQUksQ0FBQ3NoQyxPQUFPLEdBQUcvOEYsV0FBV2lrSCxjQUFjLENBQUNoNkcsTUFBTSxDQUFDLElBQUksQ0FBQ3U0RyxVQUFVO1lBQy9ELElBQUksQ0FBQ3psQixPQUFPLENBQUN3dUIsSUFBSSxDQUFDLElBQUksQ0FBQ3o3QixZQUFZO1lBQ25DLElBQUksQ0FBQ2lOLE9BQU8sQ0FBQ1UsY0FBYyxHQUFHLElBQUksQ0FBQ1YsT0FBTyxDQUFDeXVCLGlCQUFpQjtRQUM5RDtRQUNBLE1BQU0sRUFDSng5RSxRQUFRLEVBQ1J4VixTQUFTLEVBQ1RteUIsVUFBVSxFQUNWMCtCLGlCQUFpQixFQUNsQixHQUFHLElBQUksQ0FBQ3Z6RSxNQUFNO1FBQ2YsTUFBTW90RyxnQkFBZ0IsSUFBSSxDQUFDaUksY0FBYyxJQUFJLElBQUksQ0FBQ0QsT0FBTyxDQUFDOXFFLFVBQVUsQ0FBQyxNQUFNO1lBQ3pFczdELE9BQU87WUFDUHI3RCxvQkFBb0IsQ0FBQyxJQUFJLENBQUMrcUUsVUFBVTtRQUN0QztRQUNBLElBQUksQ0FBQy9HLEdBQUcsR0FBRyxJQUFJdHBCLGVBQWVtb0IsZUFBZSxJQUFJLENBQUNqb0IsVUFBVSxFQUFFLElBQUksQ0FBQ2xqQixJQUFJLEVBQUUsSUFBSSxDQUFDMGQsYUFBYSxFQUFFLElBQUksQ0FBQzV2QyxhQUFhLEVBQUU7WUFDL0dxMUM7UUFDRixHQUFHLElBQUksQ0FBQ0MsbUJBQW1CLEVBQUUsSUFBSSxDQUFDcjBDLFVBQVUsRUFBRXVpQztRQUM5QyxJQUFJLENBQUNnN0IsR0FBRyxDQUFDOW5CLFlBQVksQ0FBQztZQUNwQi9qRTtZQUNBd1Y7WUFDQXd1RDtZQUNBN3hDO1FBQ0Y7UUFDQSxJQUFJLENBQUMwL0QsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0csYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0QscUJBQXFCO0lBQzVCO0lBQ0EvdUQsT0FBTzcrRCxRQUFRLElBQUksRUFBRW0xQyxhQUFhLENBQUMsRUFBRTtRQUNuQyxJQUFJLENBQUN3NEUsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDSSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDckcsR0FBRyxFQUFFaHpCO1FBQ1YsSUFBSSxJQUFJLENBQUMsQ0FBQzY0QixHQUFHLEVBQUU7WUFDYjcyRyxPQUFPbzRHLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDdkIsR0FBRztZQUNyQyxJQUFJLENBQUMsQ0FBQ0EsR0FBRyxHQUFHO1FBQ2Q7UUFDQXhGLG1CQUFtQixDQUFDeUYsV0FBVyxDQUFDOXNFLE1BQU0sQ0FBQyxJQUFJLENBQUM2dEUsT0FBTztRQUNuRHZ1SCxVQUFVLElBQUlrMUMsNEJBQTRCLENBQUMsMEJBQTBCLEVBQUUsSUFBSSxDQUFDMndFLFVBQVUsR0FBRyxFQUFFLENBQUMsRUFBRTF3RTtRQUM5RixJQUFJLENBQUM3M0IsUUFBUSxDQUFDdGQ7UUFDZCxJQUFJLENBQUN5L0csSUFBSSxDQUFDaEgsT0FBTyxHQUFHejRHO0lBQ3RCO0lBQ0Ftb0gsc0JBQXNCO1FBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMwRixhQUFhLEVBQUU7WUFDdkIsSUFBSSxDQUFDRCxxQkFBcUIsS0FBSyxJQUFJLENBQUNLLGNBQWM7WUFDbEQ7UUFDRjtRQUNBLElBQUksQ0FBQ3ZHLEdBQUcsQ0FBQ2g3QixpQkFBaUIsRUFBRXRELG9CQUFvQixJQUFJLENBQUMrSixZQUFZLENBQUNvTixPQUFPLENBQUNyaEcsTUFBTTtRQUNoRixJQUFJLENBQUNraEcsT0FBTyxFQUFFMnVCLG1CQUFtQixJQUFJLENBQUM1N0IsWUFBWTtRQUNsRCxJQUFJLElBQUksQ0FBQ3c2QixPQUFPLEVBQUU7WUFDaEI7UUFDRjtRQUNBLElBQUksQ0FBQ08sU0FBUztJQUNoQjtJQUNBQSxZQUFZO1FBQ1YsSUFBSSxDQUFDUCxPQUFPLEdBQUc7UUFDZixJQUFJLElBQUksQ0FBQ0ksU0FBUyxFQUFFO1lBQ2xCO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQ3RPLElBQUksQ0FBQzROLFVBQVUsRUFBRTtZQUN4QixJQUFJLENBQUM1TixJQUFJLENBQUM0TixVQUFVLENBQUMsSUFBSSxDQUFDYyxrQkFBa0I7UUFDOUMsT0FBTztZQUNMLElBQUksQ0FBQ0MsYUFBYTtRQUNwQjtJQUNGO0lBQ0FBLGdCQUFnQjtRQUNkLElBQUksSUFBSSxDQUFDTix5QkFBeUIsRUFBRTtZQUNsQyxJQUFJLENBQUMsQ0FBQ1AsR0FBRyxHQUFHNzJHLE9BQU9zNEcscUJBQXFCLENBQUM7Z0JBQ3ZDLElBQUksQ0FBQyxDQUFDekIsR0FBRyxHQUFHO2dCQUNaLElBQUksQ0FBQ2MsVUFBVSxHQUFHbHNDLEtBQUssQ0FBQyxJQUFJLENBQUM2ckMsWUFBWTtZQUMzQztRQUNGLE9BQU87WUFDTGpsSCxRQUFRUSxPQUFPLEdBQUdzNkMsSUFBSSxDQUFDLElBQUksQ0FBQ3dxRSxVQUFVLEVBQUVsc0MsS0FBSyxDQUFDLElBQUksQ0FBQzZyQyxZQUFZO1FBQ2pFO0lBQ0Y7SUFDQSxNQUFNTSxRQUFRO1FBQ1osSUFBSSxJQUFJLENBQUNQLFNBQVMsRUFBRTtZQUNsQjtRQUNGO1FBQ0EsSUFBSSxDQUFDTCxlQUFlLEdBQUcsSUFBSSxDQUFDaEcsR0FBRyxDQUFDanpCLG1CQUFtQixDQUFDLElBQUksQ0FBQ3RCLFlBQVksRUFBRSxJQUFJLENBQUN1NkIsZUFBZSxFQUFFLElBQUksQ0FBQ08sY0FBYyxFQUFFLElBQUksQ0FBQzd0QixPQUFPLEVBQUUsSUFBSSxDQUFDdXVCLGlCQUFpQjtRQUN0SixJQUFJLElBQUksQ0FBQ2pCLGVBQWUsS0FBSyxJQUFJLENBQUN2NkIsWUFBWSxDQUFDbU4sU0FBUyxDQUFDcGhHLE1BQU0sRUFBRTtZQUMvRCxJQUFJLENBQUN5dUgsT0FBTyxHQUFHO1lBQ2YsSUFBSSxJQUFJLENBQUN4NkIsWUFBWSxDQUFDOHpCLFNBQVMsRUFBRTtnQkFDL0IsSUFBSSxDQUFDUyxHQUFHLENBQUNoekIsVUFBVTtnQkFDbkJxekIsbUJBQW1CLENBQUN5RixXQUFXLENBQUM5c0UsTUFBTSxDQUFDLElBQUksQ0FBQzZ0RSxPQUFPO2dCQUNuRCxJQUFJLENBQUNqeEcsUUFBUTtZQUNmO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsTUFBTS9HLFVBQVU7QUFDaEIsTUFBTTA0RyxRQUFRO0VBRWIsdUNBQXVDO0FBSXhDLE1BQU1DO0lBQ0osQ0FBQzF1RSxNQUFNLENBQVE7SUFDZixDQUFDMnVFLFlBQVksQ0FBUTtJQUNyQixDQUFDQyxZQUFZLENBQUM7SUFDZCxDQUFDQyxRQUFRLENBQVE7SUFDakIsQ0FBQ0MsdUJBQXVCLENBQVM7SUFDakMsQ0FBQ0MsaUJBQWlCLENBQVM7SUFDM0IsQ0FBQ2h4RSxNQUFNLENBQVE7SUFDZixDQUFDd04sUUFBUSxDQUFDO0lBQ1YsQ0FBQ3lqRSxjQUFjLENBQVE7SUFDdkIsQ0FBQ3R0RSxTQUFTLENBQVE7SUFDbEIsT0FBTyxDQUFDdXRFLFNBQVMsR0FBRyxLQUFLO0lBQ3pCLFdBQVcza0UsbUJBQW1CO1FBQzVCLE9BQU9wb0IsT0FBTyxJQUFJLEVBQUUsb0JBQW9CLElBQUlta0IsZ0JBQWdCO1lBQUM7Z0JBQUM7b0JBQUM7b0JBQVU7aUJBQWE7Z0JBQUVxb0UsWUFBWTFzSCxTQUFTLENBQUNrdEgseUJBQXlCO2FBQUM7WUFBRTtnQkFBQztvQkFBQztvQkFBSztpQkFBUTtnQkFBRVIsWUFBWTFzSCxTQUFTLENBQUNtdEgsd0JBQXdCO2FBQUM7WUFBRTtnQkFBQztvQkFBQztvQkFBYTtvQkFBYztvQkFBaUI7aUJBQWlCO2dCQUFFVCxZQUFZMXNILFNBQVMsQ0FBQ290SCxXQUFXO2FBQUM7WUFBRTtnQkFBQztvQkFBQztvQkFBVztvQkFBYTtvQkFBZTtpQkFBZ0I7Z0JBQUVWLFlBQVkxc0gsU0FBUyxDQUFDcXRILGVBQWU7YUFBQztZQUFFO2dCQUFDO29CQUFDO29CQUFRO2lCQUFXO2dCQUFFWCxZQUFZMXNILFNBQVMsQ0FBQ3N0SCxnQkFBZ0I7YUFBQztZQUFFO2dCQUFDO29CQUFDO29CQUFPO2lCQUFVO2dCQUFFWixZQUFZMXNILFNBQVMsQ0FBQ3V0SCxVQUFVO2FBQUM7U0FBQztJQUM3Z0I7SUFDQXp0SCxZQUFZLEVBQ1ZpOEMsU0FBUyxJQUFJLEVBQ2IyRCxZQUFZLElBQUksRUFDakIsQ0FBRTthQWpCSCxDQUFDMUIsTUFBTSxHQUFHO2FBQ1YsQ0FBQzJ1RSxZQUFZLEdBQUc7YUFFaEIsQ0FBQ0UsUUFBUSxHQUFHO2FBQ1osQ0FBQ0MsdUJBQXVCLEdBQUc7YUFDM0IsQ0FBQ0MsaUJBQWlCLEdBQUc7YUFDckIsQ0FBQ2h4RSxNQUFNLEdBQUc7YUFFVixDQUFDaXhFLGNBQWMsR0FBRzthQUNsQixDQUFDdHRFLFNBQVMsR0FBRztRQVNYLElBQUkzRCxRQUFRO1lBQ1YsSUFBSSxDQUFDLENBQUNneEUsaUJBQWlCLEdBQUc7WUFDMUIsSUFBSSxDQUFDLENBQUNoeEUsTUFBTSxHQUFHQTtRQUNqQixPQUFPO1lBQ0wsSUFBSSxDQUFDLENBQUNneEUsaUJBQWlCLEdBQUc7UUFDNUI7UUFDQSxJQUFJLENBQUMsQ0FBQ3J0RSxTQUFTLEdBQUczRCxRQUFRYyxjQUFjNkM7UUFDeEMsSUFBSSxDQUFDLENBQUM2SixRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUM3SixTQUFTLENBQUNxSyxTQUFTO1FBQzFDLElBQUksQ0FBQyxDQUFDNmlFLFlBQVksR0FBRzd3RSxRQUFRckcsT0FBT2lXLGlCQUFpQixJQUFJLENBQUMsQ0FBQ2pNLFNBQVMsRUFBRW1ILGdCQUFnQnJqQyxTQUFTOWhCLE9BQU8vRCxTQUFTO1FBQy9HK3VILFlBQVksQ0FBQ08sU0FBUyxLQUFLbHVILE9BQU91OUMsTUFBTSxDQUFDO1lBQ3ZDa3hFLE1BQU07WUFDTkMsT0FBTztZQUNQQyxNQUFNO1lBQ05DLEtBQUs7WUFDTEMsUUFBUTtRQUNWO0lBQ0Y7SUFDQWx2RSxlQUFlO1FBQ2IsTUFBTVYsU0FBUyxJQUFJLENBQUMsQ0FBQ0EsTUFBTSxHQUFHdnpDLFNBQVMySSxhQUFhLENBQUM7UUFDckQ0cUMsT0FBT3hELFNBQVMsR0FBRztRQUNuQndELE9BQU9DLFFBQVEsR0FBRztRQUNsQkQsT0FBTzNRLFlBQVksQ0FBQyxnQkFBZ0I7UUFDcEMyUSxPQUFPb2dCLFlBQVksR0FBRztRQUN0QixJQUFJLElBQUksQ0FBQyxDQUFDcmlCLE1BQU0sRUFBRTtZQUNoQmlDLE9BQU9xZ0IsWUFBWSxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQ3RpQixNQUFNLENBQUMxcUMsRUFBRSxDQUFDLHFCQUFxQixDQUFDO1FBQ2pFO1FBQ0EsTUFBTW82QixTQUFTLElBQUksQ0FBQyxDQUFDaVUsU0FBUyxDQUFDNUMsT0FBTztRQUN0Q2tCLE9BQU9uUyxnQkFBZ0IsQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDZ2lGLFlBQVksQ0FBQ3BySCxJQUFJLENBQUMsSUFBSSxHQUFHO1lBQzlEZ3BDO1FBQ0Y7UUFDQXVTLE9BQU9uUyxnQkFBZ0IsQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDaWlGLE9BQU8sQ0FBQ3JySCxJQUFJLENBQUMsSUFBSSxHQUFHO1lBQzNEZ3BDO1FBQ0Y7UUFDQSxNQUFNc2lGLFNBQVMsSUFBSSxDQUFDLENBQUNwQixZQUFZLEdBQUdsaUgsU0FBUzJJLGFBQWEsQ0FBQztRQUMzRDI2RyxPQUFPdnpFLFNBQVMsR0FBRztRQUNuQnV6RSxPQUFPQyxVQUFVLEdBQUc7UUFDcEJELE9BQU8zakgsS0FBSyxDQUFDa3pELGVBQWUsR0FBRyxJQUFJLENBQUMsQ0FBQ3N2RCxZQUFZO1FBQ2pENXVFLE9BQU94bkMsTUFBTSxDQUFDdTNHO1FBQ2QsT0FBTy92RTtJQUNUO0lBQ0Fpd0UscUJBQXFCO1FBQ25CLE1BQU1wQixXQUFXLElBQUksQ0FBQyxDQUFDQSxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUNxQixlQUFlO1FBQ3ZEckIsU0FBU3NCLGVBQWUsR0FBRztRQUMzQnRCLFNBQVN1QixjQUFjLEdBQUc7UUFDMUIsT0FBT3ZCO0lBQ1Q7SUFDQSxDQUFDcUIsZUFBZTtRQUNkLE1BQU10L0UsTUFBTW5rQyxTQUFTMkksYUFBYSxDQUFDO1FBQ25DLE1BQU1xNEIsU0FBUyxJQUFJLENBQUMsQ0FBQ2lVLFNBQVMsQ0FBQzVDLE9BQU87UUFDdENsTyxJQUFJL0MsZ0JBQWdCLENBQUMsZUFBZXVJLGVBQWU7WUFDakQzSTtRQUNGO1FBQ0FtRCxJQUFJNEwsU0FBUyxHQUFHO1FBQ2hCNUwsSUFBSXkvRSxJQUFJLEdBQUc7UUFDWHovRSxJQUFJMC9FLG1CQUFtQixHQUFHO1FBQzFCMS9FLElBQUl1L0UsZUFBZSxHQUFHO1FBQ3RCdi9FLElBQUl2QixZQUFZLENBQUMsZ0JBQWdCO1FBQ2pDLElBQUksSUFBSSxDQUFDLENBQUMwTyxNQUFNLEVBQUU7WUFDaEJuTixJQUFJdjlCLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMwcUMsTUFBTSxDQUFDMXFDLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQztRQUNwRDtRQUNBLEtBQUssTUFBTSxDQUFDN1IsTUFBTWsyQyxNQUFNLElBQUksSUFBSSxDQUFDLENBQUNnSyxTQUFTLENBQUNtSCxlQUFlLENBQUU7WUFDM0QsTUFBTTdJLFNBQVN2ekMsU0FBUzJJLGFBQWEsQ0FBQztZQUN0QzRxQyxPQUFPQyxRQUFRLEdBQUc7WUFDbEJELE9BQU9xd0UsSUFBSSxHQUFHO1lBQ2Ryd0UsT0FBTzNRLFlBQVksQ0FBQyxjQUFjcUk7WUFDbENzSSxPQUFPdUIsS0FBSyxHQUFHLy9DO1lBQ2Z3K0MsT0FBTzNRLFlBQVksQ0FBQyxnQkFBZ0JxL0UsWUFBWSxDQUFDTyxTQUFTLENBQUN6dEgsS0FBSztZQUNoRSxNQUFNdXVILFNBQVN0akgsU0FBUzJJLGFBQWEsQ0FBQztZQUN0QzRxQyxPQUFPeG5DLE1BQU0sQ0FBQ3UzRztZQUNkQSxPQUFPdnpFLFNBQVMsR0FBRztZQUNuQnV6RSxPQUFPM2pILEtBQUssQ0FBQ2t6RCxlQUFlLEdBQUc1bkI7WUFDL0JzSSxPQUFPdXdFLFlBQVksR0FBRzc0RSxVQUFVLElBQUksQ0FBQyxDQUFDazNFLFlBQVk7WUFDbEQ1dUUsT0FBT25TLGdCQUFnQixDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUMyaUYsV0FBVyxDQUFDL3JILElBQUksQ0FBQyxJQUFJLEVBQUVpekMsUUFBUTtnQkFDcEVqSztZQUNGO1lBQ0FtRCxJQUFJcDRCLE1BQU0sQ0FBQ3duQztRQUNiO1FBQ0FwUCxJQUFJL0MsZ0JBQWdCLENBQUMsV0FBVyxJQUFJLENBQUMsQ0FBQ2lpRixPQUFPLENBQUNyckgsSUFBSSxDQUFDLElBQUksR0FBRztZQUN4RGdwQztRQUNGO1FBQ0EsT0FBT21EO0lBQ1Q7SUFDQSxDQUFDNC9FLFdBQVcsQ0FBQzk0RSxLQUFLLEVBQUV4SSxLQUFLO1FBQ3ZCQSxNQUFNcUgsZUFBZTtRQUNyQixJQUFJLENBQUMsQ0FBQ2dWLFFBQVEsQ0FBQzJFLFFBQVEsQ0FBQyxnQ0FBZ0M7WUFDdEQvdEQsUUFBUSxJQUFJO1lBQ1prRixNQUFNOHJCLDJCQUEyQlMsZUFBZTtZQUNoRGowQixPQUFPKzNDO1FBQ1Q7UUFDQSxJQUFJLENBQUMrNEUsV0FBVyxDQUFDLzRFO0lBQ25CO0lBQ0F5M0UseUJBQXlCamdGLEtBQUssRUFBRTtRQUM5QixJQUFJQSxNQUFNaHdDLE1BQU0sS0FBSyxJQUFJLENBQUMsQ0FBQzhnRCxNQUFNLEVBQUU7WUFDakMsSUFBSSxDQUFDLENBQUM2dkUsWUFBWSxDQUFDM2dGO1lBQ25CO1FBQ0Y7UUFDQSxNQUFNd0ksUUFBUXhJLE1BQU1od0MsTUFBTSxDQUFDdXdDLFlBQVksQ0FBQztRQUN4QyxJQUFJLENBQUNpSSxPQUFPO1lBQ1Y7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDODRFLFdBQVcsQ0FBQzk0RSxPQUFPeEk7SUFDM0I7SUFDQWtnRixZQUFZbGdGLEtBQUssRUFBRTtRQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUN3aEYsaUJBQWlCLEVBQUU7WUFDNUIsSUFBSSxDQUFDLENBQUNiLFlBQVksQ0FBQzNnRjtZQUNuQjtRQUNGO1FBQ0EsSUFBSUEsTUFBTWh3QyxNQUFNLEtBQUssSUFBSSxDQUFDLENBQUM4Z0QsTUFBTSxFQUFFO1lBQ2pDLElBQUksQ0FBQyxDQUFDNnVFLFFBQVEsQ0FBQy94RSxVQUFVLEVBQUV1VDtZQUMzQjtRQUNGO1FBQ0FuaEIsTUFBTWh3QyxNQUFNLENBQUN5eEgsV0FBVyxFQUFFdGdFO0lBQzVCO0lBQ0FnL0QsZ0JBQWdCbmdGLEtBQUssRUFBRTtRQUNyQixJQUFJQSxNQUFNaHdDLE1BQU0sS0FBSyxJQUFJLENBQUMsQ0FBQzJ2SCxRQUFRLEVBQUUveEUsY0FBYzVOLE1BQU1od0MsTUFBTSxLQUFLLElBQUksQ0FBQyxDQUFDOGdELE1BQU0sRUFBRTtZQUNoRixJQUFJLElBQUksQ0FBQyxDQUFDMHdFLGlCQUFpQixFQUFFO2dCQUMzQixJQUFJLENBQUN4Qix5QkFBeUI7WUFDaEM7WUFDQTtRQUNGO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDd0IsaUJBQWlCLEVBQUU7WUFDNUIsSUFBSSxDQUFDLENBQUNiLFlBQVksQ0FBQzNnRjtRQUNyQjtRQUNBQSxNQUFNaHdDLE1BQU0sQ0FBQzB4SCxlQUFlLEVBQUV2Z0U7SUFDaEM7SUFDQWkvRCxpQkFBaUJwZ0YsS0FBSyxFQUFFO1FBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ3doRixpQkFBaUIsRUFBRTtZQUM1QixJQUFJLENBQUMsQ0FBQ2IsWUFBWSxDQUFDM2dGO1lBQ25CO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQzIvRSxRQUFRLENBQUMveEUsVUFBVSxFQUFFdVQ7SUFDN0I7SUFDQWsvRCxXQUFXcmdGLEtBQUssRUFBRTtRQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUN3aEYsaUJBQWlCLEVBQUU7WUFDNUIsSUFBSSxDQUFDLENBQUNiLFlBQVksQ0FBQzNnRjtZQUNuQjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUMyL0UsUUFBUSxDQUFDeDhDLFNBQVMsRUFBRWhpQjtJQUM1QjtJQUNBLENBQUN5L0QsT0FBTyxDQUFDNWdGLEtBQUs7UUFDWncvRSxZQUFZcGtFLGdCQUFnQixDQUFDbGtELElBQUksQ0FBQyxJQUFJLEVBQUU4b0M7SUFDMUM7SUFDQSxDQUFDMmdGLFlBQVksQ0FBQzNnRixLQUFLO1FBQ2pCLElBQUksSUFBSSxDQUFDLENBQUN3aEYsaUJBQWlCLEVBQUU7WUFDM0IsSUFBSSxDQUFDL3dFLFlBQVk7WUFDakI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDbXZFLHVCQUF1QixHQUFHNS9FLE1BQU0yaEYsTUFBTSxLQUFLO1FBQ2pELElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzdCLGNBQWMsRUFBRTtZQUN6QixJQUFJLENBQUMsQ0FBQ0EsY0FBYyxHQUFHLElBQUl4aEY7WUFDM0J0M0IsT0FBTzIzQixnQkFBZ0IsQ0FBQyxlQUFlLElBQUksQ0FBQyxDQUFDa1IsV0FBVyxDQUFDdDZDLElBQUksQ0FBQyxJQUFJLEdBQUc7Z0JBQ25FZ3BDLFFBQVEsSUFBSSxDQUFDLENBQUNpVSxTQUFTLENBQUN3TCxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM4aEUsY0FBYztZQUM3RDtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNodkUsTUFBTSxDQUFDa2dCLFlBQVksR0FBRztRQUM1QixJQUFJLElBQUksQ0FBQyxDQUFDMnVELFFBQVEsRUFBRTtZQUNsQixJQUFJLENBQUMsQ0FBQ0EsUUFBUSxDQUFDbDBFLFNBQVMsQ0FBQzdtQyxNQUFNLENBQUM7WUFDaEM7UUFDRjtRQUNBLE1BQU15VixPQUFPLElBQUksQ0FBQyxDQUFDc2xHLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQ3FCLGVBQWU7UUFDbkQsSUFBSSxDQUFDLENBQUNsd0UsTUFBTSxDQUFDeG5DLE1BQU0sQ0FBQytRO0lBQ3RCO0lBQ0EsQ0FBQ3cxQixXQUFXLENBQUM3UCxLQUFLO1FBQ2hCLElBQUksSUFBSSxDQUFDLENBQUMyL0UsUUFBUSxFQUFFcmtFLFNBQVN0YixNQUFNaHdDLE1BQU0sR0FBRztZQUMxQztRQUNGO1FBQ0EsSUFBSSxDQUFDeWdELFlBQVk7SUFDbkI7SUFDQUEsZUFBZTtRQUNiLElBQUksQ0FBQyxDQUFDa3ZFLFFBQVEsRUFBRWwwRSxVQUFVcG1DLElBQUk7UUFDOUIsSUFBSSxDQUFDLENBQUN5ckMsTUFBTSxDQUFDa2dCLFlBQVksR0FBRztRQUM1QixJQUFJLENBQUMsQ0FBQzh1RCxjQUFjLEVBQUVyaEY7UUFDdEIsSUFBSSxDQUFDLENBQUNxaEYsY0FBYyxHQUFHO0lBQ3pCO0lBQ0EsSUFBSSxDQUFDMEIsaUJBQWlCO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLENBQUM3QixRQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ0EsUUFBUSxDQUFDbDBFLFNBQVMsQ0FBQzZQLFFBQVEsQ0FBQztJQUM5RDtJQUNBMGtFLDRCQUE0QjtRQUMxQixJQUFJLElBQUksQ0FBQyxDQUFDSCxpQkFBaUIsRUFBRTtZQUMzQjtRQUNGO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDMkIsaUJBQWlCLEVBQUU7WUFDNUIsSUFBSSxDQUFDLENBQUMzeUUsTUFBTSxFQUFFeVo7WUFDZDtRQUNGO1FBQ0EsSUFBSSxDQUFDN1gsWUFBWTtRQUNqQixJQUFJLENBQUMsQ0FBQ0ssTUFBTSxDQUFDcVEsS0FBSyxDQUFDO1lBQ2pCbWlCLGVBQWU7WUFDZjFVLGNBQWMsSUFBSSxDQUFDLENBQUNneEQsdUJBQXVCO1FBQzdDO0lBQ0Y7SUFDQTJCLFlBQVkvNEUsS0FBSyxFQUFFO1FBQ2pCLElBQUksSUFBSSxDQUFDLENBQUNpM0UsWUFBWSxFQUFFO1lBQ3RCLElBQUksQ0FBQyxDQUFDQSxZQUFZLENBQUN2aUgsS0FBSyxDQUFDa3pELGVBQWUsR0FBRzVuQjtRQUM3QztRQUNBLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ20zRSxRQUFRLEVBQUU7WUFDbkI7UUFDRjtRQUNBLE1BQU14ckgsSUFBSSxJQUFJLENBQUMsQ0FBQ3ErQyxTQUFTLENBQUNtSCxlQUFlLENBQUNyakMsTUFBTTtRQUNoRCxLQUFLLE1BQU1rcEIsU0FBUyxJQUFJLENBQUMsQ0FBQ21nRixRQUFRLENBQUNwZ0YsUUFBUSxDQUFFO1lBQzNDQyxNQUFNNmhGLFlBQVksR0FBR2x0SCxFQUFFSyxJQUFJLEdBQUcvRCxLQUFLLEtBQUsrM0MsTUFBTWlXLFdBQVc7UUFDM0Q7SUFDRjtJQUNBbk0sVUFBVTtRQUNSLElBQUksQ0FBQyxDQUFDeEIsTUFBTSxFQUFFbHNDO1FBQ2QsSUFBSSxDQUFDLENBQUNrc0MsTUFBTSxHQUFHO1FBQ2YsSUFBSSxDQUFDLENBQUMydUUsWUFBWSxHQUFHO1FBQ3JCLElBQUksQ0FBQyxDQUFDRSxRQUFRLEVBQUUvNkc7UUFDaEIsSUFBSSxDQUFDLENBQUMrNkcsUUFBUSxHQUFHO0lBQ25CO0FBQ0Y7QUFDQSxNQUFNaUM7SUFDSixDQUFDdmlILEtBQUssQ0FBUTtJQUNkLENBQUN3dkMsTUFBTSxDQUFRO0lBQ2YsQ0FBQzJELFNBQVMsQ0FBUTtJQUNsQixPQUFPLENBQUN1dEUsU0FBUyxHQUFHLEtBQUs7SUFDekJudEgsWUFBWWk4QyxNQUFNLENBQUU7YUFKcEIsQ0FBQ3h2QyxLQUFLLEdBQUc7YUFDVCxDQUFDd3ZDLE1BQU0sR0FBRzthQUNWLENBQUMyRCxTQUFTLEdBQUc7UUFHWCxJQUFJLENBQUMsQ0FBQzNELE1BQU0sR0FBR0E7UUFDZixJQUFJLENBQUMsQ0FBQzJELFNBQVMsR0FBRzNELE9BQU9jLFVBQVU7UUFDbkNpeUUsaUJBQWlCLENBQUM3QixTQUFTLEtBQUtsdUgsT0FBT3U5QyxNQUFNLENBQUM7WUFDNUNDLFVBQVU7WUFDVkUsS0FBSztRQUNQO0lBQ0Y7SUFDQWlDLGVBQWU7UUFDYixJQUFJLElBQUksQ0FBQyxDQUFDbnlDLEtBQUssRUFBRTtZQUNmLE9BQU8sSUFBSSxDQUFDLENBQUNBLEtBQUs7UUFDcEI7UUFDQSxNQUFNLEVBQ0p3eEMsVUFBVSxFQUNWZ3hFLFNBQVMsRUFDVEMsVUFBVSxFQUNYLEdBQUcsSUFBSSxDQUFDLENBQUNqekUsTUFBTTtRQUNoQixNQUFNeHZDLFFBQVEsSUFBSSxDQUFDLENBQUNBLEtBQUssR0FBRzlCLFNBQVMySSxhQUFhLENBQUM7UUFDbkQ3RyxNQUFNbEgsSUFBSSxHQUFHO1FBQ2JrSCxNQUFNNU8sS0FBSyxHQUFHcXhILGNBQWM7UUFDNUJ6aUgsTUFBTWl1QyxTQUFTLEdBQUc7UUFDbEJqdUMsTUFBTTB4QyxRQUFRLEdBQUc7UUFDakIxeEMsTUFBTThnQyxZQUFZLENBQUMsZ0JBQWdCeWhGLGlCQUFpQixDQUFDN0IsU0FBUyxDQUFDbHZFLFdBQVc7UUFDMUV4eEMsTUFBTXMvQixnQkFBZ0IsQ0FBQyxTQUFTO1lBQzlCLElBQUksQ0FBQyxDQUFDNlQsU0FBUyxDQUFDNkssWUFBWSxDQUFDd2tFLFdBQVd4aUgsTUFBTTVPLEtBQUs7UUFDckQsR0FBRztZQUNEOHRDLFFBQVEsSUFBSSxDQUFDLENBQUNpVSxTQUFTLENBQUM1QyxPQUFPO1FBQ2pDO1FBQ0EsT0FBT3Z3QztJQUNUO0lBQ0EraUMsT0FBTzN4QyxLQUFLLEVBQUU7UUFDWixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM0TyxLQUFLLEVBQUU7WUFDaEI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDQSxLQUFLLENBQUM1TyxLQUFLLEdBQUdBO0lBQ3RCO0lBQ0E2aEQsVUFBVTtRQUNSLElBQUksQ0FBQyxDQUFDanpDLEtBQUssRUFBRXVGO1FBQ2IsSUFBSSxDQUFDLENBQUN2RixLQUFLLEdBQUc7SUFDaEI7SUFDQW94QyxlQUFlLENBQUM7QUFDbEI7QUFFQSxzRUFBc0U7QUFDdEUsSUFBSXN4RSxtQkFBbUJ0ekgsaUNBQW1CQSxDQUFDO0FBQzNDLDBFQUEwRTtBQUMxRSxJQUFJdXpILHVCQUF1QnZ6SCxpQ0FBbUJBLENBQUM7RUFDOUMsa0NBQWtDO0FBR25DLFNBQVN3ekgsY0FBYzdySCxDQUFDO0lBQ3RCLE9BQU9KLEtBQUtDLEtBQUssQ0FBQ0QsS0FBSzRQLEdBQUcsQ0FBQyxHQUFHNVAsS0FBS21GLEdBQUcsQ0FBQyxHQUFHL0UsTUFBTSxLQUFLakQsUUFBUSxDQUFDLElBQUl3aUMsUUFBUSxDQUFDLEdBQUc7QUFDaEY7QUFDQSxTQUFTdXNGLGNBQWMvckgsQ0FBQztJQUN0QixPQUFPSCxLQUFLNFAsR0FBRyxDQUFDLEdBQUc1UCxLQUFLbUYsR0FBRyxDQUFDLEtBQUssTUFBTWhGO0FBQ3pDO0FBQ0EsTUFBTWdzSDtJQUNKLE9BQU9DLE9BQU8sQ0FBQzN5RyxHQUFHNU0sR0FBRzhNLEdBQUc5RixFQUFFLEVBQUU7UUFDMUIsT0FBTztZQUFDO1lBQUssSUFBSTdULEtBQUttRixHQUFHLENBQUMsR0FBRyxNQUFNc1UsSUFBSSxPQUFPRSxJQUFJLE9BQU85TSxJQUFJZ0g7U0FBRztJQUNsRTtJQUNBLE9BQU93NEcsT0FBTyxDQUFDdHNGLEVBQUUsRUFBRTtRQUNqQixPQUFPO1lBQUM7WUFBUTtZQUFHO1lBQUc7WUFBRyxJQUFJQTtTQUFFO0lBQ2pDO0lBQ0EsT0FBT3VzRixNQUFNLENBQUN2c0YsRUFBRSxFQUFFO1FBQ2hCLE9BQU87WUFBQztZQUFPQTtZQUFHQTtZQUFHQTtTQUFFO0lBQ3pCO0lBQ0EsT0FBT3dzRixNQUFNLENBQUN4c0YsRUFBRSxFQUFFO1FBQ2hCQSxJQUFJbXNGLGNBQWNuc0Y7UUFDbEIsT0FBTztZQUFDQTtZQUFHQTtZQUFHQTtTQUFFO0lBQ2xCO0lBQ0EsT0FBT3lzRixPQUFPLENBQUN6c0YsRUFBRSxFQUFFO1FBQ2pCLE1BQU0wc0YsSUFBSVIsY0FBY2xzRjtRQUN4QixPQUFPLENBQUMsQ0FBQyxFQUFFMHNGLEVBQUUsRUFBRUEsRUFBRSxFQUFFQSxFQUFFLENBQUM7SUFDeEI7SUFDQSxPQUFPQyxNQUFNLENBQUM1c0YsR0FBR0MsR0FBR2pqQixFQUFFLEVBQUU7UUFDdEIsT0FBTztZQUFDO1lBQUssTUFBTWdqQixJQUFJLE9BQU9DLElBQUksT0FBT2pqQjtTQUFFO0lBQzdDO0lBQ0EsT0FBTzZ2RyxRQUFRbjZFLEtBQUssRUFBRTtRQUNwQixPQUFPQSxNQUFNbnVDLEdBQUcsQ0FBQzZuSDtJQUNuQjtJQUNBLE9BQU9VLFNBQVNwNkUsS0FBSyxFQUFFO1FBQ3JCLE9BQU8sQ0FBQyxDQUFDLEVBQUVBLE1BQU1udUMsR0FBRyxDQUFDNG5ILGVBQWVod0gsSUFBSSxDQUFDLElBQUksQ0FBQztJQUNoRDtJQUNBLE9BQU80d0gsU0FBUztRQUNkLE9BQU87SUFDVDtJQUNBLE9BQU9DLFFBQVE7UUFDYixPQUFPO1lBQUM7U0FBSztJQUNmO0lBQ0EsT0FBT0MsU0FBUyxDQUFDdHpHLEdBQUc1TSxHQUFHOE0sR0FBRzlGLEVBQUUsRUFBRTtRQUM1QixPQUFPO1lBQUM7WUFBTyxJQUFJN1QsS0FBS21GLEdBQUcsQ0FBQyxHQUFHc1UsSUFBSTVGO1lBQUksSUFBSTdULEtBQUttRixHQUFHLENBQUMsR0FBR3dVLElBQUk5RjtZQUFJLElBQUk3VCxLQUFLbUYsR0FBRyxDQUFDLEdBQUcwSCxJQUFJZ0g7U0FBRztJQUN4RjtJQUNBLE9BQU9tNUcsU0FBUyxDQUFDdnpHLEdBQUc1TSxHQUFHOE0sR0FBRzlGLEVBQUUsRUFBRTtRQUM1QixPQUFPO1lBQUNxNEcsY0FBYyxJQUFJbHNILEtBQUttRixHQUFHLENBQUMsR0FBR3NVLElBQUk1RjtZQUFLcTRHLGNBQWMsSUFBSWxzSCxLQUFLbUYsR0FBRyxDQUFDLEdBQUd3VSxJQUFJOUY7WUFBS3E0RyxjQUFjLElBQUlsc0gsS0FBS21GLEdBQUcsQ0FBQyxHQUFHMEgsSUFBSWdIO1NBQUk7SUFDOUg7SUFDQSxPQUFPbzVHLFVBQVVDLFVBQVUsRUFBRTtRQUMzQixNQUFNbjNFLE1BQU0sSUFBSSxDQUFDZzNFLFFBQVEsQ0FBQ0csWUFBWW54SCxLQUFLLENBQUM7UUFDNUMsT0FBTyxJQUFJLENBQUM2d0gsUUFBUSxDQUFDNzJFO0lBQ3ZCO0lBQ0EsT0FBT28zRSxTQUFTLENBQUNydEYsR0FBR0MsR0FBR2pqQixFQUFFLEVBQUU7UUFDekIsTUFBTXJELElBQUksSUFBSXFtQjtRQUNkLE1BQU1ubUIsSUFBSSxJQUFJb21CO1FBQ2QsTUFBTWx6QixJQUFJLElBQUlpUTtRQUNkLE1BQU1qSixJQUFJN1QsS0FBS21GLEdBQUcsQ0FBQ3NVLEdBQUdFLEdBQUc5TTtRQUN6QixPQUFPO1lBQUM7WUFBUTRNO1lBQUdFO1lBQUc5TTtZQUFHZ0g7U0FBRTtJQUM3QjtBQUNGO0FBQ0EsTUFBTXU1RyxjQUFlLG1DQUFtQyxHQUFHLFFBQVMsQ0FBMEs7QUFDOU8sTUFBTUMsY0FBZSxtQ0FBbUMsR0FBRyxRQUFTLENBQThDO0VBRWpILCtCQUErQjtBQUdoQyxNQUFNQztJQUNKMWxILE9BQU8rbUMsS0FBSyxFQUFFQyxNQUFNLEVBQUUyK0UsaUJBQWlCLEtBQUssRUFBRTtRQUM1QyxJQUFJNStFLFNBQVMsS0FBS0MsVUFBVSxHQUFHO1lBQzdCLE1BQU0sSUFBSWozQixNQUFNO1FBQ2xCO1FBQ0EsTUFBTWttQyxNQUFNLElBQUksQ0FBQzJ2RSxVQUFVLENBQUM7UUFDNUIzdkUsSUFBSTFULFlBQVksQ0FBQyxXQUFXO1FBQzVCLElBQUksQ0FBQ29qRixnQkFBZ0I7WUFDbkIxdkUsSUFBSTFULFlBQVksQ0FBQyxTQUFTLENBQUMsRUFBRXdFLE1BQU0sRUFBRSxDQUFDO1lBQ3RDa1AsSUFBSTFULFlBQVksQ0FBQyxVQUFVLENBQUMsRUFBRXlFLE9BQU8sRUFBRSxDQUFDO1FBQzFDO1FBQ0FpUCxJQUFJMVQsWUFBWSxDQUFDLHVCQUF1QjtRQUN4QzBULElBQUkxVCxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRXdFLE1BQU0sQ0FBQyxFQUFFQyxPQUFPLENBQUM7UUFDcEQsT0FBT2lQO0lBQ1Q7SUFDQTN0QyxjQUFjL04sSUFBSSxFQUFFO1FBQ2xCLElBQUksT0FBT0EsU0FBUyxVQUFVO1lBQzVCLE1BQU0sSUFBSXdWLE1BQU07UUFDbEI7UUFDQSxPQUFPLElBQUksQ0FBQzYxRyxVQUFVLENBQUNyckg7SUFDekI7SUFDQXFySCxXQUFXcnJILElBQUksRUFBRTtRQUNmNjVCLFlBQVk7SUFDZDtBQUNGO0FBQ0EsTUFBTXl4RixzQkFBc0JIO0lBQzFCRSxXQUFXcnJILElBQUksRUFBRTtRQUNmLE9BQU9vRixTQUFTMmtDLGVBQWUsQ0FBQ0ksUUFBUW5xQztJQUMxQztBQUNGO0VBRUMsb0NBQW9DO0FBa0JyQyxNQUFNdXJILHFDQUFxQztBQUMzQyxNQUFNQyx1QkFBdUIsSUFBSTVGO0FBQ2pDLE1BQU02RixrQkFBa0IsSUFBSTVuRixPQUFPNm5GLGlCQUFpQixLQUFLLEtBQUs7QUFDOUQsTUFBTUM7SUFDSixPQUFPbG1ILE9BQU93akMsVUFBVSxFQUFFO1FBQ3hCLE1BQU1vekQsVUFBVXB6RCxXQUFXcmhDLElBQUksQ0FBQ3FpRSxjQUFjO1FBQzlDLE9BQVFveUI7WUFDTixLQUFLbHVFLGVBQWVFLElBQUk7Z0JBQ3RCLE9BQU8sSUFBSXU5RixzQkFBc0IzaUY7WUFDbkMsS0FBSzlhLGVBQWVDLElBQUk7Z0JBQ3RCLE9BQU8sSUFBSXk5RixzQkFBc0I1aUY7WUFDbkMsS0FBSzlhLGVBQWVlLE1BQU07Z0JBQ3hCLE1BQU00OEYsWUFBWTdpRixXQUFXcmhDLElBQUksQ0FBQ2trSCxTQUFTO2dCQUMzQyxPQUFRQTtvQkFDTixLQUFLO3dCQUNILE9BQU8sSUFBSUMsNEJBQTRCOWlGO29CQUN6QyxLQUFLO3dCQUNILElBQUlBLFdBQVdyaEMsSUFBSSxDQUFDb2tILFdBQVcsRUFBRTs0QkFDL0IsT0FBTyxJQUFJQyxtQ0FBbUNoakY7d0JBQ2hELE9BQU8sSUFBSUEsV0FBV3JoQyxJQUFJLENBQUNza0gsUUFBUSxFQUFFOzRCQUNuQyxPQUFPLElBQUlDLGdDQUFnQ2xqRjt3QkFDN0M7d0JBQ0EsT0FBTyxJQUFJbWpGLGtDQUFrQ25qRjtvQkFDL0MsS0FBSzt3QkFDSCxPQUFPLElBQUlvakYsOEJBQThCcGpGO29CQUMzQyxLQUFLO3dCQUNILE9BQU8sSUFBSXFqRixpQ0FBaUNyakY7Z0JBQ2hEO2dCQUNBLE9BQU8sSUFBSXNqRix3QkFBd0J0akY7WUFDckMsS0FBSzlhLGVBQWV4QyxLQUFLO2dCQUN2QixPQUFPLElBQUk2Z0csdUJBQXVCdmpGO1lBQ3BDLEtBQUs5YSxlQUFlNUMsUUFBUTtnQkFDMUIsT0FBTyxJQUFJa2hHLDBCQUEwQnhqRjtZQUN2QyxLQUFLOWEsZUFBZUcsSUFBSTtnQkFDdEIsT0FBTyxJQUFJbytGLHNCQUFzQnpqRjtZQUNuQyxLQUFLOWEsZUFBZUksTUFBTTtnQkFDeEIsT0FBTyxJQUFJbytGLHdCQUF3QjFqRjtZQUNyQyxLQUFLOWEsZUFBZUssTUFBTTtnQkFDeEIsT0FBTyxJQUFJbytGLHdCQUF3QjNqRjtZQUNyQyxLQUFLOWEsZUFBZU8sUUFBUTtnQkFDMUIsT0FBTyxJQUFJbStGLDBCQUEwQjVqRjtZQUN2QyxLQUFLOWEsZUFBZVcsS0FBSztnQkFDdkIsT0FBTyxJQUFJZytGLHVCQUF1QjdqRjtZQUNwQyxLQUFLOWEsZUFBZXpDLEdBQUc7Z0JBQ3JCLE9BQU8sSUFBSXFoRyxxQkFBcUI5akY7WUFDbEMsS0FBSzlhLGVBQWVNLE9BQU87Z0JBQ3pCLE9BQU8sSUFBSXUrRix5QkFBeUIvakY7WUFDdEMsS0FBSzlhLGVBQWUzQyxTQUFTO2dCQUMzQixPQUFPLElBQUl5aEcsMkJBQTJCaGtGO1lBQ3hDLEtBQUs5YSxlQUFlUSxTQUFTO2dCQUMzQixPQUFPLElBQUl1K0YsMkJBQTJCamtGO1lBQ3hDLEtBQUs5YSxlQUFlUyxRQUFRO2dCQUMxQixPQUFPLElBQUl1K0YsMEJBQTBCbGtGO1lBQ3ZDLEtBQUs5YSxlQUFlVSxTQUFTO2dCQUMzQixPQUFPLElBQUl1K0YsMkJBQTJCbmtGO1lBQ3hDLEtBQUs5YSxlQUFlMUMsS0FBSztnQkFDdkIsT0FBTyxJQUFJNGhHLHVCQUF1QnBrRjtZQUNwQyxLQUFLOWEsZUFBZVksY0FBYztnQkFDaEMsT0FBTyxJQUFJdStGLGdDQUFnQ3JrRjtZQUM3QztnQkFDRSxPQUFPLElBQUlza0Ysa0JBQWtCdGtGO1FBQ2pDO0lBQ0Y7QUFDRjtBQUNBLE1BQU1za0Y7SUFDSixDQUFDQyxPQUFPLENBQVE7SUFDaEIsQ0FBQ0MsU0FBUyxDQUFTO0lBQ25CLENBQUNDLFlBQVksQ0FBUTtJQUNyQmp6SCxZQUFZd3VDLFVBQVUsRUFBRSxFQUN0QjBrRixlQUFlLEtBQUssRUFDcEJDLGVBQWUsS0FBSyxFQUNwQkMsdUJBQXVCLEtBQUssRUFDN0IsR0FBRyxDQUFDLENBQUMsQ0FBRTthQVBSLENBQUNMLE9BQU8sR0FBRzthQUNYLENBQUNDLFNBQVMsR0FBRzthQUNiLENBQUNDLFlBQVksR0FBRztRQU1kLElBQUksQ0FBQ0MsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUMvbEgsSUFBSSxHQUFHcWhDLFdBQVdyaEMsSUFBSTtRQUMzQixJQUFJLENBQUMrOUMsS0FBSyxHQUFHMWMsV0FBVzBjLEtBQUs7UUFDN0IsSUFBSSxDQUFDbGQsV0FBVyxHQUFHUSxXQUFXUixXQUFXO1FBQ3pDLElBQUksQ0FBQ3FsRixlQUFlLEdBQUc3a0YsV0FBVzZrRixlQUFlO1FBQ2pELElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc5a0YsV0FBVzhrRixrQkFBa0I7UUFDdkQsSUFBSSxDQUFDQyxXQUFXLEdBQUcva0YsV0FBVytrRixXQUFXO1FBQ3pDLElBQUksQ0FBQ0MsVUFBVSxHQUFHaGxGLFdBQVdnbEYsVUFBVTtRQUN2QyxJQUFJLENBQUMva0YsaUJBQWlCLEdBQUdELFdBQVdDLGlCQUFpQjtRQUNyRCxJQUFJLENBQUNnbEYsYUFBYSxHQUFHamxGLFdBQVdpbEYsYUFBYTtRQUM3QyxJQUFJLENBQUNDLGVBQWUsR0FBR2xsRixXQUFXa2xGLGVBQWU7UUFDakQsSUFBSSxDQUFDeFEsWUFBWSxHQUFHMTBFLFdBQVcwMEUsWUFBWTtRQUMzQyxJQUFJLENBQUN5USxhQUFhLEdBQUdubEYsV0FBV29sRixZQUFZO1FBQzVDLElBQUksQ0FBQzFrRixNQUFNLEdBQUdWLFdBQVdVLE1BQU07UUFDL0IsSUFBSWdrRixjQUFjO1lBQ2hCLElBQUksQ0FBQ3Y0RSxTQUFTLEdBQUcsSUFBSSxDQUFDazVFLGdCQUFnQixDQUFDVjtRQUN6QztRQUNBLElBQUlDLHNCQUFzQjtZQUN4QixJQUFJLENBQUNVLHFCQUFxQjtRQUM1QjtJQUNGO0lBQ0EsT0FBT0MsY0FBYyxFQUNuQnorRCxXQUFXLEVBQ1g2SCxRQUFRLEVBQ1QsRUFBRTtRQUNELE9BQU8sQ0FBQyxDQUFFN0gsQ0FBQUEsYUFBYTl6QixPQUFPMjdCLFVBQVUzN0IsR0FBRTtJQUM1QztJQUNBLElBQUl3eUYsY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQzdtSCxJQUFJLENBQUM4bUgsVUFBVTtJQUM3QjtJQUNBLElBQUlDLGVBQWU7UUFDakIsT0FBT3BCLGtCQUFrQmlCLGFBQWEsQ0FBQyxJQUFJLENBQUM1bUgsSUFBSSxLQUFLLElBQUksQ0FBQ3NtSCxhQUFhLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQ1UsV0FBVztJQUMvRjtJQUNBLElBQUlDLGNBQWM7UUFDaEIsTUFBTSxFQUNKam5ILElBQUksRUFDTCxHQUFHLElBQUk7UUFDUixNQUFNOHVDLFNBQVMsSUFBSSxDQUFDeE4saUJBQWlCLEVBQUUrbkIsVUFBVXJwRCxLQUFLb0UsRUFBRTtRQUN4RCxJQUFJMHFDLFFBQVE7WUFDVixPQUFPQSxPQUFPa1IsT0FBTztRQUN2QjtRQUNBLE9BQU9oZ0Q7SUFDVDtJQUNBLElBQUlrbkgsbUJBQW1CO1FBQ3JCLE9BQU8sSUFBSSxDQUFDWixhQUFhLElBQUksSUFBSSxDQUFDYSxlQUFlO0lBQ25EO0lBQ0EsSUFBSWgzRCx3QkFBd0I7UUFDMUIsTUFBTXJoQixTQUFTLElBQUksQ0FBQ3hOLGlCQUFpQixFQUFFK25CLFVBQVUsSUFBSSxDQUFDcnBELElBQUksQ0FBQ29FLEVBQUU7UUFDN0QsSUFBSTBxQyxRQUFRO1lBQ1YsT0FBT0EsT0FBTzR6QiwyQkFBMkI7UUFDM0M7UUFDQSxNQUFNLEVBQ0owa0QsVUFBVSxFQUNWQyxRQUFRLEVBQ1I5dkYsSUFBSSxFQUNMLEdBQUcsSUFBSSxDQUFDdjNCLElBQUk7UUFDYixJQUFJODNFLE9BQU8sQ0FBQ2oyRTtRQUNaLElBQUlrMkUsT0FBTyxDQUFDbDJFO1FBQ1osSUFBSXVsSCxZQUFZMzNILFVBQVUsR0FBRztZQUMzQixJQUFLLElBQUkyRSxJQUFJLEdBQUdBLElBQUlnekgsV0FBVzMzSCxNQUFNLEVBQUUyRSxLQUFLLEVBQUc7Z0JBQzdDLElBQUlnekgsVUFBVSxDQUFDaHpILElBQUksRUFBRSxHQUFHMmpGLE1BQU07b0JBQzVCQSxPQUFPcXZDLFVBQVUsQ0FBQ2h6SCxJQUFJLEVBQUU7b0JBQ3hCMGpGLE9BQU9zdkMsVUFBVSxDQUFDaHpILElBQUksRUFBRTtnQkFDMUIsT0FBTyxJQUFJZ3pILFVBQVUsQ0FBQ2h6SCxJQUFJLEVBQUUsS0FBSzJqRixNQUFNO29CQUNyQ0QsT0FBTzdoRixLQUFLNFAsR0FBRyxDQUFDaXlFLE1BQU1zdkMsVUFBVSxDQUFDaHpILElBQUksRUFBRTtnQkFDekM7WUFDRjtZQUNBLE9BQU87Z0JBQUMwakY7Z0JBQU1DO2FBQUs7UUFDckI7UUFDQSxJQUFJc3ZDLFVBQVU1M0gsVUFBVSxHQUFHO1lBQ3pCLEtBQUssTUFBTTYzSCxXQUFXRCxTQUFVO2dCQUM5QixJQUFLLElBQUlqekgsSUFBSSxHQUFHaW5DLEtBQUtpc0YsUUFBUTczSCxNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsS0FBSyxFQUFHO29CQUNuRCxJQUFJa3pILE9BQU8sQ0FBQ2x6SCxJQUFJLEVBQUUsR0FBRzJqRixNQUFNO3dCQUN6QkEsT0FBT3V2QyxPQUFPLENBQUNsekgsSUFBSSxFQUFFO3dCQUNyQjBqRixPQUFPd3ZDLE9BQU8sQ0FBQ2x6SCxFQUFFO29CQUNuQixPQUFPLElBQUlrekgsT0FBTyxDQUFDbHpILElBQUksRUFBRSxLQUFLMmpGLE1BQU07d0JBQ2xDRCxPQUFPN2hGLEtBQUs0UCxHQUFHLENBQUNpeUUsTUFBTXd2QyxPQUFPLENBQUNsekgsRUFBRTtvQkFDbEM7Z0JBQ0Y7WUFDRjtZQUNBLElBQUkwakYsU0FBU2oyRSxVQUFVO2dCQUNyQixPQUFPO29CQUFDaTJFO29CQUFNQztpQkFBSztZQUNyQjtRQUNGO1FBQ0EsSUFBSXhnRCxNQUFNO1lBQ1IsT0FBTztnQkFBQ0EsSUFBSSxDQUFDLEVBQUU7Z0JBQUVBLElBQUksQ0FBQyxFQUFFO2FBQUM7UUFDM0I7UUFDQSxPQUFPO0lBQ1Q7SUFDQWd3RixnQkFBZ0IzcUQsS0FBSyxFQUFFO1FBQ3JCLE1BQU0sRUFDSnAvQixNQUFNLEVBQ0prK0QsSUFBSSxFQUNMLEVBQ0Q5NUQsVUFBVSxFQUNSa0QsU0FBUyxFQUNQRSxTQUFTLEVBQ1RDLFVBQVUsRUFDVkMsS0FBSyxFQUNMQyxLQUFLLEVBQ04sRUFDRixFQUNGLEdBQUcsSUFBSSxDQUFDcEQsTUFBTTtRQUNmNjZCLEtBQUssQ0FBQyxFQUFFLEdBQUc4K0IsSUFBSSxDQUFDLEVBQUUsR0FBRzkrQixLQUFLLENBQUMsRUFBRSxHQUFHOCtCLElBQUksQ0FBQyxFQUFFO1FBQ3ZDOStCLEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBT0EsQ0FBQUEsS0FBSyxDQUFDLEVBQUUsR0FBRzEzQixLQUFJLElBQUtGO1FBQ3RDNDNCLEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBT0EsQ0FBQUEsS0FBSyxDQUFDLEVBQUUsR0FBR3ozQixLQUFJLElBQUtGO1FBQ3RDLE9BQU8yM0I7SUFDVDtJQUNBLElBQUlvcUQsY0FBYztRQUNoQixNQUFNLEVBQ0pobkgsSUFBSSxFQUNMLEdBQUcsSUFBSTtRQUNSLE9BQU8sSUFBSSxDQUFDc2hDLGlCQUFpQixDQUFDbWlCLFdBQVcsQ0FBQyxDQUFDLEVBQUVqZ0MsdUJBQXVCLEVBQUV4akIsS0FBS29FLEVBQUUsQ0FBQyxDQUFDLEdBQUdxN0QsT0FBT0MsWUFBWTEvRCxLQUFLbW9ELFdBQVcsRUFBRTl6QixPQUFPO0lBQ2hJO0lBQ0EsSUFBSTJ5RixZQUFZL3FHLElBQUksRUFBRTtRQUNwQixNQUFNLEVBQ0pqYyxJQUFJLEVBQ0wsR0FBRyxJQUFJO1FBQ1IsTUFBTXkvRCxRQUFRO1lBQ1p6WCxTQUFTLENBQUMvckM7WUFDVnlqRCxVQUFVempELFFBQVE7UUFDcEI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDcWxCLGlCQUFpQixDQUFDMGxDLFlBQVksQ0FBQ2huRSxLQUFLb0UsRUFBRSxFQUFFO1lBQ2hEcTdEO1FBQ0YsSUFBSTtZQUNGLElBQUksQ0FBQ24rQixpQkFBaUIsQ0FBQ3BCLFFBQVEsQ0FBQyxDQUFDLEVBQUUxYyx1QkFBdUIsRUFBRXhqQixLQUFLb0UsRUFBRSxDQUFDLENBQUMsRUFBRTtnQkFDckVBLElBQUlwRSxLQUFLb0UsRUFBRTtnQkFDWGkrRCxnQkFBZ0JyaUUsS0FBS3FpRSxjQUFjO2dCQUNuQ3ppQixXQUFXLElBQUksQ0FBQzdkLE1BQU0sQ0FBQ3ZFLElBQUksQ0FBQzQ0RSxVQUFVO2dCQUN0QzMyQztnQkFDQXZYLFVBQVVsb0QsS0FBS2tvRCxRQUFRO2dCQUN2QitPLGtCQUFrQixJQUFJaDdCO1lBQ3hCO1FBQ0Y7UUFDQSxJQUFJLENBQUNoZ0IsTUFBTTtZQUNULElBQUksQ0FBQ3VyRyxXQUFXO1FBQ2xCO0lBQ0Y7SUFDQUEsY0FBYztRQUNYLEtBQUksQ0FBQyxDQUFDMUIsWUFBWSxFQUFFcm1ELFNBQVMsSUFBSSxDQUFDQSxLQUFLLEdBQUc1NkQ7UUFDM0MsSUFBSSxDQUFDLENBQUNpaEgsWUFBWSxHQUFHLElBQUksQ0FBQ3JtRCxLQUFLLEdBQUc7SUFDcEM7SUFDQTBFLGFBQWF6NkQsTUFBTSxFQUFFO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUM4akMsU0FBUyxFQUFFO1lBQ25CO1FBQ0Y7UUFDQSxJQUFJOWpDLE9BQU82dEIsSUFBSSxFQUFFO1lBQ2YsSUFBSSxDQUFDLENBQUNxdUYsT0FBTyxLQUFLO2dCQUNoQnJ1RixNQUFNLElBQUksQ0FBQ3YzQixJQUFJLENBQUN1M0IsSUFBSSxDQUFDdmxDLEtBQUssQ0FBQztZQUM3QjtRQUNGO1FBQ0EsTUFBTSxFQUNKdWxDLElBQUksRUFDSmtvQyxPQUFPZ29ELFFBQVEsRUFDaEIsR0FBRy85RztRQUNKLElBQUk2dEIsTUFBTTtZQUNSLElBQUksQ0FBQyxDQUFDbXdGLGFBQWEsQ0FBQ253RjtRQUN0QjtRQUNBLElBQUlrb0MsUUFBUSxJQUFJLENBQUMsQ0FBQ3FtRCxZQUFZLEVBQUVybUQsU0FBUyxJQUFJLENBQUNBLEtBQUs7UUFDbkQsSUFBSSxDQUFDQSxTQUFTZ29ELFVBQVV4ckcsTUFBTTtZQUM1QixJQUFJLENBQUMwckcsWUFBWSxDQUFDRjtZQUNsQmhvRCxRQUFRLElBQUksQ0FBQyxDQUFDcW1ELFlBQVksQ0FBQ3JtRCxLQUFLO1FBQ2xDO1FBQ0EsSUFBSSxDQUFDQSxPQUFPO1lBQ1Y7UUFDRjtRQUNBQSxNQUFNMEUsWUFBWSxDQUFDejZEO1FBQ25CLElBQUkrOUcsVUFBVXovRCxTQUFTO1lBQ3JCeVgsTUFBTTU2RCxNQUFNO1lBQ1osSUFBSSxDQUFDLENBQUNpaEgsWUFBWSxHQUFHO1lBQ3JCLElBQUksQ0FBQ3JtRCxLQUFLLEdBQUc7UUFDZjtJQUNGO0lBQ0Ftb0QsY0FBYztRQUNaLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ2hDLE9BQU8sRUFBRTtZQUNsQjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUM4QixhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM5QixPQUFPLENBQUNydUYsSUFBSTtRQUN0QyxJQUFJLENBQUMsQ0FBQ3V1RixZQUFZLEVBQUVybUQsTUFBTW1vRDtRQUMxQixJQUFJLENBQUMsQ0FBQ2hDLE9BQU8sR0FBRztJQUNsQjtJQUNBLENBQUM4QixhQUFhLENBQUNud0YsSUFBSTtRQUNqQixNQUFNLEVBQ0ppVyxXQUFXLEVBQ1Ryd0MsS0FBSyxFQUNOLEVBQ0Q2QyxNQUFNLEVBQ0p1M0IsTUFBTXN3RixXQUFXLEVBQ2pCN2pGLFFBQVEsRUFDVCxFQUNEakMsUUFBUSxFQUNOSCxVQUFVLEVBQ1JrRCxTQUFTLEVBQ1BFLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxLQUFLLEVBQ0xDLEtBQUssRUFDTixFQUNGLEVBQ0YsRUFDRixHQUFHLElBQUk7UUFDUjBpRixhQUFhOXdFLE9BQU8sR0FBRyxNQUFNeGY7UUFDN0JwNkIsTUFBTSs4RCxJQUFJLEdBQUcsQ0FBQyxFQUFFLE1BQU8zaUMsQ0FBQUEsSUFBSSxDQUFDLEVBQUUsR0FBRzJOLEtBQUksSUFBS0YsVUFBVSxDQUFDLENBQUM7UUFDdEQ3bkMsTUFBTWd6QyxHQUFHLEdBQUcsQ0FBQyxFQUFFLE1BQU9sTCxDQUFBQSxhQUFhMU4sSUFBSSxDQUFDLEVBQUUsR0FBRzROLEtBQUksSUFBS0YsV0FBVyxDQUFDLENBQUM7UUFDbkUsSUFBSWpCLGFBQWEsR0FBRztZQUNsQjdtQyxNQUFNeW5DLEtBQUssR0FBRyxDQUFDLEVBQUUsTUFBT3JOLENBQUFBLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLElBQUl5TixVQUFVLENBQUMsQ0FBQztZQUN6RDduQyxNQUFNMG5DLE1BQU0sR0FBRyxDQUFDLEVBQUUsTUFBT3ROLENBQUFBLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLElBQUkwTixXQUFXLENBQUMsQ0FBQztRQUM3RCxPQUFPO1lBQ0wsSUFBSSxDQUFDNmlGLFdBQVcsQ0FBQzlqRjtRQUNuQjtJQUNGO0lBQ0EwaUYsaUJBQWlCVixZQUFZLEVBQUU7UUFDN0IsTUFBTSxFQUNKaG1ILElBQUksRUFDSitoQyxRQUFRLEVBQ052RSxJQUFJLEVBQ0pvRSxRQUFRLEVBQ1QsRUFDRixHQUFHLElBQUk7UUFDUixNQUFNNEwsWUFBWWh3QyxTQUFTMkksYUFBYSxDQUFDO1FBQ3pDcW5DLFVBQVVwTixZQUFZLENBQUMsc0JBQXNCcGdDLEtBQUtvRSxFQUFFO1FBQ3BELElBQUksQ0FBRSxLQUFJLFlBQVl1Z0gsdUJBQXNCLEtBQU0sQ0FBRSxLQUFJLFlBQVlYLHFCQUFvQixHQUFJO1lBQzFGeDJFLFVBQVV3RCxRQUFRLEdBQUc7UUFDdkI7UUFDQSxNQUFNLEVBQ0o3ekMsS0FBSyxFQUNOLEdBQUdxd0M7UUFDSnJ3QyxNQUFNNDRELE1BQU0sR0FBRyxJQUFJLENBQUNoMEIsTUFBTSxDQUFDZzBCLE1BQU07UUFDakMsSUFBSSxDQUFDaDBCLE1BQU0sQ0FBQ2cwQixNQUFNLElBQUk7UUFDdEIsSUFBSS8xRCxLQUFLK25ILGVBQWUsRUFBRTtZQUN4QnY2RSxVQUFVOEUsS0FBSyxHQUFHdHlDLEtBQUsrbkgsZUFBZTtRQUN4QztRQUNBLElBQUkvbkgsS0FBS2dvSCxRQUFRLEVBQUU7WUFDakJ4NkUsVUFBVTlCLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7UUFDMUI7UUFDQSxJQUFJLENBQUN0RixLQUFLdTNCLElBQUksSUFBSSxJQUFJLFlBQVlxdEYsd0JBQXdCO1lBQ3hELE1BQU0sRUFDSjVnRixRQUFRLEVBQ1QsR0FBR2hrQztZQUNKLElBQUksQ0FBQ0EsS0FBS2k2RixZQUFZLElBQUlqMkQsYUFBYSxHQUFHO2dCQUN4QyxJQUFJLENBQUM4akYsV0FBVyxDQUFDOWpGLFVBQVV3SjtZQUM3QjtZQUNBLE9BQU9BO1FBQ1Q7UUFDQSxNQUFNLEVBQ0o1SSxLQUFLLEVBQ0xDLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJLENBQUNtaEYsZ0JBQWdCaG1ILEtBQUtpb0gsV0FBVyxDQUFDcmpGLEtBQUssR0FBRyxHQUFHO1lBQy9Dem5DLE1BQU0rcUgsV0FBVyxHQUFHLENBQUMsRUFBRWxvSCxLQUFLaW9ILFdBQVcsQ0FBQ3JqRixLQUFLLENBQUMsRUFBRSxDQUFDO1lBQ2pELE1BQU11akYsbUJBQW1Cbm9ILEtBQUtpb0gsV0FBVyxDQUFDRyxzQkFBc0I7WUFDaEUsTUFBTUMsaUJBQWlCcm9ILEtBQUtpb0gsV0FBVyxDQUFDSyxvQkFBb0I7WUFDNUQsSUFBSUgsbUJBQW1CLEtBQUtFLGlCQUFpQixHQUFHO2dCQUM5QyxNQUFNRSxTQUFTLENBQUMsS0FBSyxFQUFFSixpQkFBaUIsdUNBQXVDLEVBQUVFLGVBQWUsK0JBQStCLENBQUM7Z0JBQ2hJbHJILE1BQU1xckgsWUFBWSxHQUFHRDtZQUN2QixPQUFPLElBQUksSUFBSSxZQUFZbEUsb0NBQW9DO2dCQUM3RCxNQUFNa0UsU0FBUyxDQUFDLEtBQUssRUFBRTNqRixNQUFNLHVDQUF1QyxFQUFFQyxPQUFPLCtCQUErQixDQUFDO2dCQUM3RzFuQyxNQUFNcXJILFlBQVksR0FBR0Q7WUFDdkI7WUFDQSxPQUFRdm9ILEtBQUtpb0gsV0FBVyxDQUFDOXFILEtBQUs7Z0JBQzVCLEtBQUt5c0IsMEJBQTBCQyxLQUFLO29CQUNsQzFzQixNQUFNOHFILFdBQVcsR0FBRztvQkFDcEI7Z0JBQ0YsS0FBS3IrRiwwQkFBMEJFLE1BQU07b0JBQ25DM3NCLE1BQU04cUgsV0FBVyxHQUFHO29CQUNwQjtnQkFDRixLQUFLcitGLDBCQUEwQkcsT0FBTztvQkFDcENpSSxLQUFLO29CQUNMO2dCQUNGLEtBQUtwSSwwQkFBMEJJLEtBQUs7b0JBQ2xDZ0ksS0FBSztvQkFDTDtnQkFDRixLQUFLcEksMEJBQTBCN0MsU0FBUztvQkFDdEM1cEIsTUFBTXNySCxpQkFBaUIsR0FBRztvQkFDMUI7Z0JBQ0Y7b0JBQ0U7WUFDSjtZQUNBLE1BQU1DLGNBQWMxb0gsS0FBSzBvSCxXQUFXLElBQUk7WUFDeEMsSUFBSUEsYUFBYTtnQkFDZixJQUFJLENBQUMsQ0FBQzdDLFNBQVMsR0FBRztnQkFDbEIxb0gsTUFBTXVySCxXQUFXLEdBQUc3eUYsS0FBS0MsWUFBWSxDQUFDNHlGLFdBQVcsQ0FBQyxFQUFFLEdBQUcsR0FBR0EsV0FBVyxDQUFDLEVBQUUsR0FBRyxHQUFHQSxXQUFXLENBQUMsRUFBRSxHQUFHO1lBQ2pHLE9BQU87Z0JBQ0x2ckgsTUFBTStxSCxXQUFXLEdBQUc7WUFDdEI7UUFDRjtRQUNBLE1BQU0zd0YsT0FBTzFCLEtBQUtrRCxhQUFhLENBQUM7WUFBQy80QixLQUFLdTNCLElBQUksQ0FBQyxFQUFFO1lBQUVpRyxLQUFLaytELElBQUksQ0FBQyxFQUFFLEdBQUcxN0YsS0FBS3UzQixJQUFJLENBQUMsRUFBRSxHQUFHaUcsS0FBS2srRCxJQUFJLENBQUMsRUFBRTtZQUFFMTdGLEtBQUt1M0IsSUFBSSxDQUFDLEVBQUU7WUFBRWlHLEtBQUtrK0QsSUFBSSxDQUFDLEVBQUUsR0FBRzE3RixLQUFLdTNCLElBQUksQ0FBQyxFQUFFLEdBQUdpRyxLQUFLaytELElBQUksQ0FBQyxFQUFFO1NBQUM7UUFDcEosTUFBTSxFQUNKMTJELFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxLQUFLLEVBQ0xDLEtBQUssRUFDTixHQUFHdkQsU0FBU2tELE9BQU87UUFDcEIzbkMsTUFBTSs4RCxJQUFJLEdBQUcsQ0FBQyxFQUFFLE1BQU8zaUMsQ0FBQUEsSUFBSSxDQUFDLEVBQUUsR0FBRzJOLEtBQUksSUFBS0YsVUFBVSxDQUFDLENBQUM7UUFDdEQ3bkMsTUFBTWd6QyxHQUFHLEdBQUcsQ0FBQyxFQUFFLE1BQU81WSxDQUFBQSxJQUFJLENBQUMsRUFBRSxHQUFHNE4sS0FBSSxJQUFLRixXQUFXLENBQUMsQ0FBQztRQUN0RCxNQUFNLEVBQ0pqQixRQUFRLEVBQ1QsR0FBR2hrQztRQUNKLElBQUlBLEtBQUtpNkYsWUFBWSxJQUFJajJELGFBQWEsR0FBRztZQUN2QzdtQyxNQUFNeW5DLEtBQUssR0FBRyxDQUFDLEVBQUUsTUFBTUEsUUFBUUksVUFBVSxDQUFDLENBQUM7WUFDM0M3bkMsTUFBTTBuQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLE1BQU1BLFNBQVNJLFdBQVcsQ0FBQyxDQUFDO1FBQ2hELE9BQU87WUFDTCxJQUFJLENBQUM2aUYsV0FBVyxDQUFDOWpGLFVBQVV3SjtRQUM3QjtRQUNBLE9BQU9BO0lBQ1Q7SUFDQXM2RSxZQUFZcnRELEtBQUssRUFBRWp0QixZQUFZLElBQUksQ0FBQ0EsU0FBUyxFQUFFO1FBQzdDLElBQUksQ0FBQyxJQUFJLENBQUN4dEMsSUFBSSxDQUFDdTNCLElBQUksRUFBRTtZQUNuQjtRQUNGO1FBQ0EsTUFBTSxFQUNKeU4sU0FBUyxFQUNUQyxVQUFVLEVBQ1gsR0FBRyxJQUFJLENBQUNsRCxNQUFNLENBQUNILFFBQVEsQ0FBQ2tELE9BQU87UUFDaEMsSUFBSSxFQUNGRixLQUFLLEVBQ0xDLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJNDFCLFFBQVEsUUFBUSxHQUFHO1lBQ3JCLENBQUM3MUIsT0FBT0MsT0FBTyxHQUFHO2dCQUFDQTtnQkFBUUQ7YUFBTTtRQUNuQztRQUNBNEksVUFBVXJ3QyxLQUFLLENBQUN5bkMsS0FBSyxHQUFHLENBQUMsRUFBRSxNQUFNQSxRQUFRSSxVQUFVLENBQUMsQ0FBQztRQUNyRHdJLFVBQVVyd0MsS0FBSyxDQUFDMG5DLE1BQU0sR0FBRyxDQUFDLEVBQUUsTUFBTUEsU0FBU0ksV0FBVyxDQUFDLENBQUM7UUFDeER1SSxVQUFVcE4sWUFBWSxDQUFDLHNCQUFzQixDQUFDLE1BQU1xNkIsS0FBSSxJQUFLO0lBQy9EO0lBQ0EsSUFBSWt1RCxpQkFBaUI7UUFDbkIsTUFBTUMsV0FBVyxDQUFDQyxRQUFRQyxXQUFXN29GO1lBQ25DLE1BQU13SSxRQUFReEksTUFBTTJoRixNQUFNLENBQUNpSCxPQUFPO1lBQ2xDLE1BQU0vRyxZQUFZcjVFLEtBQUssQ0FBQyxFQUFFO1lBQzFCLE1BQU1zZ0YsYUFBYXRnRixNQUFNejJDLEtBQUssQ0FBQztZQUMvQml1QyxNQUFNaHdDLE1BQU0sQ0FBQ2tOLEtBQUssQ0FBQzJySCxVQUFVLEdBQUcxRyxlQUFlLENBQUMsQ0FBQyxFQUFFTixVQUFVLEtBQUssQ0FBQyxDQUFDLENBQUNpSDtZQUNyRSxJQUFJLENBQUN6bkYsaUJBQWlCLENBQUNwQixRQUFRLENBQUMsSUFBSSxDQUFDbGdDLElBQUksQ0FBQ29FLEVBQUUsRUFBRTtnQkFDNUMsQ0FBQzBrSCxVQUFVLEVBQUUxRyxlQUFlLENBQUMsQ0FBQyxFQUFFTixVQUFVLElBQUksQ0FBQyxDQUFDLENBQUNpSDtZQUNuRDtRQUNGO1FBQ0EsT0FBTzkxRixPQUFPLElBQUksRUFBRSxrQkFBa0I7WUFDcEM3MUIsU0FBUzZpQyxDQUFBQTtnQkFDUCxNQUFNLEVBQ0o3aUMsT0FBTyxFQUNSLEdBQUc2aUMsTUFBTTJoRixNQUFNO2dCQUNoQixNQUFNdC9FLFNBQVNsbEMsVUFBVSxNQUFNO2dCQUMvQixJQUFJLENBQUNvd0MsU0FBUyxDQUFDcndDLEtBQUssQ0FBQzJyQyxVQUFVLEdBQUd4RyxTQUFTLFdBQVc7Z0JBQ3RELElBQUksQ0FBQ2hCLGlCQUFpQixDQUFDcEIsUUFBUSxDQUFDLElBQUksQ0FBQ2xnQyxJQUFJLENBQUNvRSxFQUFFLEVBQUU7b0JBQzVDNGtILFFBQVExbUY7b0JBQ1IybUYsU0FBUzdySCxZQUFZLEtBQUtBLFlBQVk7Z0JBQ3hDO1lBQ0Y7WUFDQTZvRSxPQUFPaG1DLENBQUFBO2dCQUNMLElBQUksQ0FBQ3FCLGlCQUFpQixDQUFDcEIsUUFBUSxDQUFDLElBQUksQ0FBQ2xnQyxJQUFJLENBQUNvRSxFQUFFLEVBQUU7b0JBQzVDNmtILFNBQVMsQ0FBQ2hwRixNQUFNMmhGLE1BQU0sQ0FBQzM3QyxLQUFLO2dCQUM5QjtZQUNGO1lBQ0EzakMsUUFBUXJDLENBQUFBO2dCQUNOLE1BQU0sRUFDSnFDLE1BQU0sRUFDUCxHQUFHckMsTUFBTTJoRixNQUFNO2dCQUNoQixJQUFJLENBQUNwMEUsU0FBUyxDQUFDcndDLEtBQUssQ0FBQzJyQyxVQUFVLEdBQUd4RyxTQUFTLFdBQVc7Z0JBQ3RELElBQUksQ0FBQ2hCLGlCQUFpQixDQUFDcEIsUUFBUSxDQUFDLElBQUksQ0FBQ2xnQyxJQUFJLENBQUNvRSxFQUFFLEVBQUU7b0JBQzVDNmtILFNBQVMzbUY7b0JBQ1QwbUYsUUFBUTFtRjtnQkFDVjtZQUNGO1lBQ0E4ZSxPQUFPbmhCLENBQUFBO2dCQUNMdXBCLFdBQVcsSUFBTXZwQixNQUFNaHdDLE1BQU0sQ0FBQ214RCxLQUFLLENBQUM7d0JBQ2xDbWlCLGVBQWU7b0JBQ2pCLElBQUk7WUFDTjtZQUNBMmxELFVBQVVqcEYsQ0FBQUE7Z0JBQ1JBLE1BQU1od0MsTUFBTSxDQUFDcWlELEtBQUssR0FBR3JTLE1BQU0yaEYsTUFBTSxDQUFDc0gsUUFBUTtZQUM1QztZQUNBQyxVQUFVbHBGLENBQUFBO2dCQUNSQSxNQUFNaHdDLE1BQU0sQ0FBQ3EvRCxRQUFRLEdBQUdydkIsTUFBTTJoRixNQUFNLENBQUN1SCxRQUFRO1lBQy9DO1lBQ0Fub0gsVUFBVWkvQixDQUFBQTtnQkFDUixJQUFJLENBQUNtcEYsWUFBWSxDQUFDbnBGLE1BQU1od0MsTUFBTSxFQUFFZ3dDLE1BQU0yaEYsTUFBTSxDQUFDNWdILFFBQVE7WUFDdkQ7WUFDQWl5RSxTQUFTaHpDLENBQUFBO2dCQUNQMm9GLFNBQVMsV0FBVyxtQkFBbUIzb0Y7WUFDekM7WUFDQTRsRCxXQUFXNWxELENBQUFBO2dCQUNUMm9GLFNBQVMsYUFBYSxtQkFBbUIzb0Y7WUFDM0M7WUFDQSt5QyxTQUFTL3lDLENBQUFBO2dCQUNQMm9GLFNBQVMsV0FBVyxTQUFTM29GO1lBQy9CO1lBQ0FvcEYsV0FBV3BwRixDQUFBQTtnQkFDVDJvRixTQUFTLGFBQWEsU0FBUzNvRjtZQUNqQztZQUNBeW9GLGFBQWF6b0YsQ0FBQUE7Z0JBQ1gyb0YsU0FBUyxlQUFlLGVBQWUzb0Y7WUFDekM7WUFDQTZsRCxhQUFhN2xELENBQUFBO2dCQUNYMm9GLFNBQVMsZUFBZSxlQUFlM29GO1lBQ3pDO1lBQ0ErRCxVQUFVL0QsQ0FBQUE7Z0JBQ1IsTUFBTXc2QixRQUFReDZCLE1BQU0yaEYsTUFBTSxDQUFDNTlFLFFBQVE7Z0JBQ25DLElBQUksQ0FBQzhqRixXQUFXLENBQUNydEQ7Z0JBQ2pCLElBQUksQ0FBQ241QixpQkFBaUIsQ0FBQ3BCLFFBQVEsQ0FBQyxJQUFJLENBQUNsZ0MsSUFBSSxDQUFDb0UsRUFBRSxFQUFFO29CQUM1QzQvQixVQUFVeTJCO2dCQUNaO1lBQ0Y7UUFDRjtJQUNGO0lBQ0E2dUQsMEJBQTBCQyxPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUMxQyxNQUFNQyxnQkFBZ0IsSUFBSSxDQUFDZCxjQUFjO1FBQ3pDLEtBQUssTUFBTXAySCxRQUFRVCxPQUFPbUYsSUFBSSxDQUFDdXlILFFBQVE1SCxNQUFNLEVBQUc7WUFDOUMsTUFBTWo1RCxTQUFTNGdFLE9BQU8sQ0FBQ2gzSCxLQUFLLElBQUlrM0gsYUFBYSxDQUFDbDNILEtBQUs7WUFDbkRvMkQsU0FBUzZnRTtRQUNYO0lBQ0Y7SUFDQUUsNEJBQTRCOXBGLE9BQU8sRUFBRTtRQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDMm1GLGVBQWUsRUFBRTtZQUN6QjtRQUNGO1FBQ0EsTUFBTXhtRixhQUFhLElBQUksQ0FBQ3VCLGlCQUFpQixDQUFDbWlCLFdBQVcsQ0FBQyxJQUFJLENBQUN6akQsSUFBSSxDQUFDb0UsRUFBRTtRQUNsRSxJQUFJLENBQUMyN0IsWUFBWTtZQUNmO1FBQ0Y7UUFDQSxNQUFNMHBGLGdCQUFnQixJQUFJLENBQUNkLGNBQWM7UUFDekMsS0FBSyxNQUFNLENBQUMxNEMsWUFBWTJ4QyxPQUFPLElBQUk5dkgsT0FBTzhYLE9BQU8sQ0FBQ20yQixZQUFhO1lBQzdELE1BQU00b0IsU0FBUzhnRSxhQUFhLENBQUN4NUMsV0FBVztZQUN4QyxJQUFJdG5CLFFBQVE7Z0JBQ1YsTUFBTWdoRSxhQUFhO29CQUNqQi9ILFFBQVE7d0JBQ04sQ0FBQzN4QyxXQUFXLEVBQUUyeEM7b0JBQ2hCO29CQUNBM3hILFFBQVEydkM7Z0JBQ1Y7Z0JBQ0Erb0IsT0FBT2doRTtnQkFDUCxPQUFPNXBGLFVBQVUsQ0FBQ2t3QyxXQUFXO1lBQy9CO1FBQ0Y7SUFDRjtJQUNBMDJDLHdCQUF3QjtRQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDbjVFLFNBQVMsRUFBRTtZQUNuQjtRQUNGO1FBQ0EsTUFBTSxFQUNKNDVFLFVBQVUsRUFDWCxHQUFHLElBQUksQ0FBQ3BuSCxJQUFJO1FBQ2IsSUFBSSxDQUFDb25ILFlBQVk7WUFDZjtRQUNGO1FBQ0EsTUFBTSxDQUFDd0MsU0FBU0MsU0FBU0MsU0FBU0MsUUFBUSxHQUFHLElBQUksQ0FBQy9wSCxJQUFJLENBQUN1M0IsSUFBSSxDQUFDajlCLEdBQUcsQ0FBQ2xFLENBQUFBLElBQUtILEtBQUtxNEYsTUFBTSxDQUFDbDRGO1FBQ2pGLElBQUlneEgsV0FBVzMzSCxNQUFNLEtBQUssR0FBRztZQUMzQixNQUFNLENBQUMrdkUsS0FBS0gsS0FBS0MsS0FBS0MsSUFBSSxHQUFHNm5ELFdBQVdqekYsUUFBUSxDQUFDLEdBQUc7WUFDcEQsSUFBSTIxRixZQUFZdHFELE9BQU91cUQsWUFBWTFxRCxPQUFPdXFELFlBQVl0cUQsT0FBT3VxRCxZQUFZdHFELEtBQUs7Z0JBQzVFO1lBQ0Y7UUFDRjtRQUNBLE1BQU0sRUFDSnBpRSxLQUFLLEVBQ04sR0FBRyxJQUFJLENBQUNxd0MsU0FBUztRQUNsQixJQUFJdzhFO1FBQ0osSUFBSSxJQUFJLENBQUMsQ0FBQ25FLFNBQVMsRUFBRTtZQUNuQixNQUFNLEVBQ0o2QyxXQUFXLEVBQ1hSLFdBQVcsRUFDWixHQUFHL3FIO1lBQ0pBLE1BQU0rcUgsV0FBVyxHQUFHO1lBQ3BCOEIsWUFBWTtnQkFBQztnQkFBaUMsQ0FBQyx1Q0FBdUMsQ0FBQztnQkFBRSxDQUFDLDhDQUE4QyxDQUFDO2dCQUFFLENBQUMsOEJBQThCLEVBQUV0QixZQUFZLGdCQUFnQixFQUFFUixZQUFZLEVBQUUsQ0FBQzthQUFDO1lBQzFOLElBQUksQ0FBQzE2RSxTQUFTLENBQUM5QixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1FBQy9CO1FBQ0EsTUFBTXMvQixRQUFRa2xGLFVBQVVGO1FBQ3hCLE1BQU0va0YsU0FBU2tsRixVQUFVRjtRQUN6QixNQUFNLEVBQ0p4RCxVQUFVLEVBQ1gsR0FBRyxJQUFJO1FBQ1IsTUFBTXZ5RSxNQUFNdXlFLFdBQVdsZ0gsYUFBYSxDQUFDO1FBQ3JDMnRDLElBQUlwSSxTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1FBQ2xCd3VDLElBQUkxVCxZQUFZLENBQUMsU0FBUztRQUMxQjBULElBQUkxVCxZQUFZLENBQUMsVUFBVTtRQUMzQjBULElBQUlzdEUsSUFBSSxHQUFHO1FBQ1gsTUFBTXJ0QyxPQUFPc3lDLFdBQVdsZ0gsYUFBYSxDQUFDO1FBQ3RDMnRDLElBQUl2cUMsTUFBTSxDQUFDd3FFO1FBQ1gsTUFBTWsyQyxXQUFXNUQsV0FBV2xnSCxhQUFhLENBQUM7UUFDMUMsTUFBTS9CLEtBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDcEUsSUFBSSxDQUFDb0UsRUFBRSxDQUFDLENBQUM7UUFDckM2bEgsU0FBUzdwRixZQUFZLENBQUMsTUFBTWg4QjtRQUM1QjZsSCxTQUFTN3BGLFlBQVksQ0FBQyxpQkFBaUI7UUFDdkMyekMsS0FBS3hxRSxNQUFNLENBQUMwZ0g7UUFDWixJQUFLLElBQUk3MUgsSUFBSSxHQUFHaW5DLEtBQUsrckYsV0FBVzMzSCxNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsS0FBSyxFQUFHO1lBQ3RELE1BQU1vckUsTUFBTTRuRCxVQUFVLENBQUNoekgsRUFBRTtZQUN6QixNQUFNaXJFLE1BQU0rbkQsVUFBVSxDQUFDaHpILElBQUksRUFBRTtZQUM3QixNQUFNa3JFLE1BQU04bkQsVUFBVSxDQUFDaHpILElBQUksRUFBRTtZQUM3QixNQUFNbXJFLE1BQU02bkQsVUFBVSxDQUFDaHpILElBQUksRUFBRTtZQUM3QixNQUFNbWpDLE9BQU84dUYsV0FBV2xnSCxhQUFhLENBQUM7WUFDdEMsTUFBTS9QLElBQUksQ0FBQ2twRSxNQUFNc3FELE9BQU0sSUFBS2hsRjtZQUM1QixNQUFNOWhDLElBQUksQ0FBQ2luSCxVQUFVMXFELEdBQUUsSUFBS3g2QjtZQUM1QixNQUFNcWxGLFlBQVksQ0FBQzFxRCxNQUFNRixHQUFFLElBQUsxNkI7WUFDaEMsTUFBTXVsRixhQUFhLENBQUM5cUQsTUFBTUUsR0FBRSxJQUFLMTZCO1lBQ2pDdE4sS0FBSzZJLFlBQVksQ0FBQyxLQUFLaHFDO1lBQ3ZCbWhDLEtBQUs2SSxZQUFZLENBQUMsS0FBS3Q5QjtZQUN2QnkwQixLQUFLNkksWUFBWSxDQUFDLFNBQVM4cEY7WUFDM0IzeUYsS0FBSzZJLFlBQVksQ0FBQyxVQUFVK3BGO1lBQzVCRixTQUFTMWdILE1BQU0sQ0FBQ2d1QjtZQUNoQnl5RixXQUFXdHZILEtBQUssQ0FBQyw0Q0FBNEMsRUFBRXRFLEVBQUUsS0FBSyxFQUFFME0sRUFBRSxTQUFTLEVBQUVvbkgsVUFBVSxVQUFVLEVBQUVDLFdBQVcsR0FBRyxDQUFDO1FBQzVIO1FBQ0EsSUFBSSxJQUFJLENBQUMsQ0FBQ3RFLFNBQVMsRUFBRTtZQUNuQm1FLFVBQVV0dkgsSUFBSSxDQUFDLENBQUMsWUFBWSxDQUFDO1lBQzdCeUMsTUFBTWl0SCxlQUFlLEdBQUdKLFVBQVU5M0gsSUFBSSxDQUFDO1FBQ3pDO1FBQ0EsSUFBSSxDQUFDczdDLFNBQVMsQ0FBQ2prQyxNQUFNLENBQUN1cUM7UUFDdEIsSUFBSSxDQUFDdEcsU0FBUyxDQUFDcndDLEtBQUssQ0FBQzhzSCxRQUFRLEdBQUcsQ0FBQyxLQUFLLEVBQUU3bEgsR0FBRyxDQUFDLENBQUM7SUFDL0M7SUFDQXVqSCxhQUFhMEMsWUFBWSxJQUFJLEVBQUU7UUFDN0IsTUFBTSxFQUNKcnFILElBQUksRUFDTCxHQUFHLElBQUk7UUFDUixJQUFJbW9ELGFBQWE4TztRQUNqQixJQUFJb3pELFdBQVc7WUFDYmxpRSxjQUFjO2dCQUNaOXpCLEtBQUtnMkYsVUFBVXB1RyxJQUFJO1lBQ3JCO1lBQ0FnN0MsbUJBQW1Cb3pELFVBQVVydUYsSUFBSTtRQUNuQyxPQUFPO1lBQ0xtc0IsY0FBY25vRCxLQUFLbW9ELFdBQVc7WUFDOUI4TyxtQkFBbUJqM0QsS0FBS2kzRCxnQkFBZ0I7UUFDMUM7UUFDQSxNQUFNd0ksUUFBUSxJQUFJLENBQUMsQ0FBQ3FtRCxZQUFZLEdBQUcsSUFBSWxCLHVCQUF1QjtZQUM1RDVrSCxNQUFNO2dCQUNKeW9DLE9BQU96b0MsS0FBS3lvQyxLQUFLO2dCQUNqQjZoRixVQUFVdHFILEtBQUtzcUgsUUFBUTtnQkFDdkJyekQ7Z0JBQ0E5TztnQkFDQTZILFVBQVVod0QsS0FBS2d3RCxRQUFRO2dCQUN2QnU2RCxZQUFZdnFILEtBQUt1M0IsSUFBSTtnQkFDckIwd0YsYUFBYTtnQkFDYjdqSCxJQUFJLENBQUMsTUFBTSxFQUFFcEUsS0FBS29FLEVBQUUsQ0FBQyxDQUFDO2dCQUN0QjQvQixVQUFVaGtDLEtBQUtna0MsUUFBUTtnQkFDdkJna0YsVUFBVTtZQUNaO1lBQ0FubkYsYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFDN0JrQixRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQnJrQixVQUFVO2dCQUFDLElBQUk7YUFBQztRQUNsQjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUNxa0IsTUFBTSxDQUFDeW9GLGVBQWUsRUFBRTtZQUNoQyxJQUFJLENBQUN6b0YsTUFBTSxDQUFDSixHQUFHLENBQUNwNEIsTUFBTSxDQUFDazJELE1BQU1yK0IsTUFBTTtRQUNyQztJQUNGO0lBQ0EsSUFBSStsRixrQkFBa0I7UUFDcEIsT0FBTyxDQUFDLENBQUUsS0FBSSxDQUFDLENBQUNyQixZQUFZLElBQUksSUFBSSxDQUFDcm1ELEtBQUssSUFBSSxJQUFJLENBQUN6L0QsSUFBSSxDQUFDa29ELFFBQVE7SUFDbEU7SUFDQSxJQUFJdWlFLG9CQUFvQjtRQUN0QixPQUFPLElBQUksQ0FBQyxDQUFDM0UsWUFBWTtJQUMzQjtJQUNBMWtGLFNBQVM7UUFDUG5QLFlBQVk7SUFDZDtJQUNBeTRGLG1CQUFtQm40SCxJQUFJLEVBQUVvNEgsU0FBUyxJQUFJLEVBQUU7UUFDdEMsTUFBTUMsU0FBUyxFQUFFO1FBQ2pCLElBQUksSUFBSSxDQUFDcEUsYUFBYSxFQUFFO1lBQ3RCLE1BQU1xRSxXQUFXLElBQUksQ0FBQ3JFLGFBQWEsQ0FBQ2owSCxLQUFLO1lBQ3pDLElBQUlzNEgsVUFBVTtnQkFDWixLQUFLLE1BQU0sRUFDVHJ0RixJQUFJLEVBQ0pwNUIsRUFBRSxFQUNGMG1ILFlBQVksRUFDYixJQUFJRCxTQUFVO29CQUNiLElBQUlydEYsU0FBUyxDQUFDLEdBQUc7d0JBQ2Y7b0JBQ0Y7b0JBQ0EsSUFBSXA1QixPQUFPdW1ILFFBQVE7d0JBQ2pCO29CQUNGO29CQUNBLE1BQU1JLGNBQWMsT0FBT0QsaUJBQWlCLFdBQVdBLGVBQWU7b0JBQ3RFLE1BQU1FLGFBQWF4dEgsU0FBUzIwQyxhQUFhLENBQUMsQ0FBQyxrQkFBa0IsRUFBRS90QyxHQUFHLEVBQUUsQ0FBQztvQkFDckUsSUFBSTRtSCxjQUFjLENBQUNwSCxxQkFBcUIzckgsR0FBRyxDQUFDK3lILGFBQWE7d0JBQ3ZEaDVGLEtBQUssQ0FBQywwQ0FBMEMsRUFBRTV0QixHQUFHLENBQUM7d0JBQ3REO29CQUNGO29CQUNBd21ILE9BQU9sd0gsSUFBSSxDQUFDO3dCQUNWMEo7d0JBQ0EybUg7d0JBQ0FDO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPSjtRQUNUO1FBQ0EsS0FBSyxNQUFNSSxjQUFjeHRILFNBQVN5dEgsaUJBQWlCLENBQUMxNEgsTUFBTztZQUN6RCxNQUFNLEVBQ0p3NEgsV0FBVyxFQUNaLEdBQUdDO1lBQ0osTUFBTTVtSCxLQUFLNG1ILFdBQVd4cUYsWUFBWSxDQUFDO1lBQ25DLElBQUlwOEIsT0FBT3VtSCxRQUFRO2dCQUNqQjtZQUNGO1lBQ0EsSUFBSSxDQUFDL0cscUJBQXFCM3JILEdBQUcsQ0FBQyt5SCxhQUFhO2dCQUN6QztZQUNGO1lBQ0FKLE9BQU9sd0gsSUFBSSxDQUFDO2dCQUNWMEo7Z0JBQ0EybUg7Z0JBQ0FDO1lBQ0Y7UUFDRjtRQUNBLE9BQU9KO0lBQ1Q7SUFDQWo2RSxPQUFPO1FBQ0wsSUFBSSxJQUFJLENBQUNuRCxTQUFTLEVBQUU7WUFDbEIsSUFBSSxDQUFDQSxTQUFTLENBQUNsTCxNQUFNLEdBQUc7UUFDMUI7UUFDQSxJQUFJLENBQUNtOUIsS0FBSyxFQUFFeXJEO0lBQ2Q7SUFDQXo2RSxPQUFPO1FBQ0wsSUFBSSxJQUFJLENBQUNqRCxTQUFTLEVBQUU7WUFDbEIsSUFBSSxDQUFDQSxTQUFTLENBQUNsTCxNQUFNLEdBQUc7UUFDMUI7UUFDQSxJQUFJLENBQUNtOUIsS0FBSyxFQUFFMHJEO0lBQ2Q7SUFDQUMsNEJBQTRCO1FBQzFCLE9BQU8sSUFBSSxDQUFDNTlFLFNBQVM7SUFDdkI7SUFDQTY5RSxtQkFBbUI7UUFDakIsTUFBTUMsV0FBVyxJQUFJLENBQUNGLHlCQUF5QjtRQUMvQyxJQUFJNXBILE1BQU0rRixPQUFPLENBQUMrakgsV0FBVztZQUMzQixLQUFLLE1BQU0xckYsV0FBVzByRixTQUFVO2dCQUM5QjFyRixRQUFROEwsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztZQUN4QjtRQUNGLE9BQU87WUFDTGdtSCxTQUFTNS9FLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7UUFDekI7SUFDRjtJQUNBaW1ILHFCQUFxQjtRQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDMUUsV0FBVyxFQUFFO1lBQ3JCO1FBQ0Y7UUFDQSxNQUFNLEVBQ0oyRSxzQkFBc0I3MEcsSUFBSSxFQUMxQjNXLE1BQU0sRUFDSm9FLElBQUkyaUQsTUFBTSxFQUNYLEVBQ0YsR0FBRyxJQUFJO1FBQ1IsSUFBSSxDQUFDdlosU0FBUyxDQUFDNU8sZ0JBQWdCLENBQUMsWUFBWTtZQUMxQyxJQUFJLENBQUNpQyxXQUFXLENBQUN5YixRQUFRLEVBQUUyRSxTQUFTLDhCQUE4QjtnQkFDaEUvdEQsUUFBUSxJQUFJO2dCQUNaeWpCO2dCQUNBb3dDO2dCQUNBRSxxQkFBcUI7WUFDdkI7UUFDRjtJQUNGO0lBQ0EsSUFBSXJpQixRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUM1a0MsSUFBSSxDQUFDdTNCLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDdjNCLElBQUksQ0FBQ3UzQixJQUFJLENBQUMsRUFBRTtJQUM5QztJQUNBLElBQUlzTixTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUM3a0MsSUFBSSxDQUFDdTNCLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDdjNCLElBQUksQ0FBQ3UzQixJQUFJLENBQUMsRUFBRTtJQUM5QztBQUNGO0FBQ0EsTUFBTWswRixnQ0FBZ0M5RjtJQUNwQzl5SCxZQUFZd3VDLFVBQVUsQ0FBRTtRQUN0QixLQUFLLENBQUNBLFlBQVk7WUFDaEIwa0YsY0FBYztZQUNkQyxjQUFjO1FBQ2hCO1FBQ0EsSUFBSSxDQUFDbDNFLE1BQU0sR0FBR3pOLFdBQVd5TixNQUFNO0lBQ2pDO0lBQ0ExTixTQUFTO1FBQ1AsSUFBSSxDQUFDb00sU0FBUyxDQUFDRCxTQUFTLEdBQUc7UUFDM0IsT0FBTyxJQUFJLENBQUNDLFNBQVM7SUFDdkI7SUFDQWsrRSxzQkFBc0I7UUFDcEIsTUFBTSxFQUNKNThFLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJLENBQUNBLE9BQU9pWixVQUFVLEVBQUU7WUFDdEI7UUFDRjtRQUNBLElBQUksQ0FBQzQvRCxZQUFZLENBQUM3NEUsT0FBT0csT0FBTztRQUNoQyxJQUFJLENBQUN3N0UsaUJBQWlCLENBQUNockQsS0FBSyxDQUFDa3NELG1CQUFtQjtJQUNsRDtJQUNBLElBQUl6RSxtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUNaLGFBQWEsSUFBSSxJQUFJLENBQUN4M0UsTUFBTSxDQUFDaVosVUFBVTtJQUNyRDtJQUNBLElBQUlvSSx3QkFBd0I7UUFDMUIsT0FBTyxJQUFJLENBQUNyaEIsTUFBTSxDQUFDNHpCLDJCQUEyQjtJQUNoRDtJQUNBLElBQUlza0QsY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQ2w0RSxNQUFNLENBQUNHLE9BQU8sQ0FBQ2h6QixJQUFJO0lBQ2pDO0lBQ0EsSUFBSStxRyxZQUFZL3FHLElBQUksRUFBRTtRQUNwQixJQUFJLENBQUM2eUIsTUFBTSxDQUFDRyxPQUFPLEdBQUdoekI7UUFDdEIsSUFBSSxDQUFDQSxNQUFNO1lBQ1QsSUFBSSxDQUFDdXJHLFdBQVc7UUFDbEI7SUFDRjtJQUNBLElBQUlQLGNBQWM7UUFDaEIsT0FBTyxJQUFJLENBQUNuNEUsTUFBTSxDQUFDa1IsT0FBTztJQUM1QjtJQUNBbjdDLFNBQVM7UUFDUCxJQUFJLENBQUMyb0MsU0FBUyxDQUFDM29DLE1BQU07UUFDckIsSUFBSSxDQUFDMm9DLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNnNkUsV0FBVztJQUNsQjtBQUNGO0FBQ0EsTUFBTXhELDhCQUE4QjJCO0lBQ2xDOXlILFlBQVl3dUMsVUFBVSxFQUFFN3VDLFVBQVUsSUFBSSxDQUFFO1FBQ3RDLEtBQUssQ0FBQzZ1QyxZQUFZO1lBQ2hCMGtGLGNBQWM7WUFDZEMsY0FBYyxDQUFDLENBQUN4ekgsU0FBU3d6SDtZQUN6QkMsc0JBQXNCO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDMkYsYUFBYSxHQUFHdnFGLFdBQVdyaEMsSUFBSSxDQUFDNHJILGFBQWE7SUFDcEQ7SUFDQXhxRixTQUFTO1FBQ1AsTUFBTSxFQUNKcGhDLElBQUksRUFDSjZnQyxXQUFXLEVBQ1osR0FBRyxJQUFJO1FBQ1IsTUFBTWdyRixPQUFPcnVILFNBQVMySSxhQUFhLENBQUM7UUFDcEMwbEgsS0FBS3pyRixZQUFZLENBQUMsbUJBQW1CcGdDLEtBQUtvRSxFQUFFO1FBQzVDLElBQUkwbkgsVUFBVTtRQUNkLElBQUk5ckgsS0FBS29ULEdBQUcsRUFBRTtZQUNaeXRCLFlBQVlJLGlCQUFpQixDQUFDNHFGLE1BQU03ckgsS0FBS29ULEdBQUcsRUFBRXBULEtBQUtraEMsU0FBUztZQUM1RDRxRixVQUFVO1FBQ1osT0FBTyxJQUFJOXJILEtBQUsyb0QsTUFBTSxFQUFFO1lBQ3RCLElBQUksQ0FBQ29qRSxnQkFBZ0IsQ0FBQ0YsTUFBTTdySCxLQUFLMm9ELE1BQU0sRUFBRTNvRCxLQUFLZ3NILFlBQVk7WUFDMURGLFVBQVU7UUFDWixPQUFPLElBQUk5ckgsS0FBS2lzSCxVQUFVLEVBQUU7WUFDMUIsSUFBSSxDQUFDLENBQUNDLGNBQWMsQ0FBQ0wsTUFBTTdySCxLQUFLaXNILFVBQVUsRUFBRWpzSCxLQUFLZ3NILFlBQVksRUFBRWhzSCxLQUFLbXNILGNBQWM7WUFDbEZMLFVBQVU7UUFDWixPQUFPLElBQUk5ckgsS0FBS2toRyxXQUFXLEVBQUU7WUFDM0IsSUFBSSxDQUFDLENBQUNrckIsZUFBZSxDQUFDUCxNQUFNN3JILEtBQUtraEcsV0FBVyxFQUFFbGhHLEtBQUtnc0gsWUFBWTtZQUMvREYsVUFBVTtRQUNaLE9BQU8sSUFBSTlySCxLQUFLdTlCLElBQUksRUFBRTtZQUNwQixJQUFJLENBQUM4dUYsU0FBUyxDQUFDUixNQUFNN3JILEtBQUt1OUIsSUFBSSxFQUFFdjlCLEtBQUtnc0gsWUFBWTtZQUNqREYsVUFBVTtRQUNaLE9BQU87WUFDTCxJQUFJOXJILEtBQUt1cEgsT0FBTyxJQUFLdnBILENBQUFBLEtBQUt1cEgsT0FBTyxDQUFDK0MsTUFBTSxJQUFJdHNILEtBQUt1cEgsT0FBTyxDQUFDLFdBQVcsSUFBSXZwSCxLQUFLdXBILE9BQU8sQ0FBQyxhQUFhLEtBQUssSUFBSSxDQUFDaEQsZUFBZSxJQUFJLElBQUksQ0FBQ3hRLFlBQVksRUFBRTtnQkFDaEosSUFBSSxDQUFDd1csYUFBYSxDQUFDVixNQUFNN3JIO2dCQUN6QjhySCxVQUFVO1lBQ1o7WUFDQSxJQUFJOXJILEtBQUt3c0gsU0FBUyxFQUFFO2dCQUNsQixJQUFJLENBQUNDLG9CQUFvQixDQUFDWixNQUFNN3JILEtBQUt3c0gsU0FBUztnQkFDOUNWLFVBQVU7WUFDWixPQUFPLElBQUksSUFBSSxDQUFDRixhQUFhLElBQUksQ0FBQ0UsU0FBUztnQkFDekMsSUFBSSxDQUFDTyxTQUFTLENBQUNSLE1BQU07Z0JBQ3JCQyxVQUFVO1lBQ1o7UUFDRjtRQUNBLElBQUksQ0FBQ3QrRSxTQUFTLENBQUM5QixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1FBQzdCLElBQUl3bUgsU0FBUztZQUNYLElBQUksQ0FBQ3QrRSxTQUFTLENBQUNqa0MsTUFBTSxDQUFDc2lIO1FBQ3hCO1FBQ0EsT0FBTyxJQUFJLENBQUNyK0UsU0FBUztJQUN2QjtJQUNBLENBQUNrL0UsZUFBZTtRQUNkLElBQUksQ0FBQ2wvRSxTQUFTLENBQUNwTixZQUFZLENBQUMsc0JBQXNCO0lBQ3BEO0lBQ0Fpc0YsVUFBVVIsSUFBSSxFQUFFYyxXQUFXLEVBQUVYLGVBQWUsRUFBRSxFQUFFO1FBQzlDSCxLQUFLNTFHLElBQUksR0FBRyxJQUFJLENBQUM0cUIsV0FBVyxDQUFDK3JGLGtCQUFrQixDQUFDRDtRQUNoRGQsS0FBS2dCLE9BQU8sR0FBRztZQUNiLElBQUlGLGFBQWE7Z0JBQ2YsSUFBSSxDQUFDOXJGLFdBQVcsQ0FBQ2lzRixlQUFlLENBQUNIO1lBQ25DO1lBQ0EsT0FBTztRQUNUO1FBQ0EsSUFBSUEsZUFBZUEsZ0JBQWdCLElBQUk7WUFDckMsSUFBSSxDQUFDLENBQUNELGVBQWU7UUFDdkI7UUFDQSxJQUFJVixjQUFjO1lBQ2hCSCxLQUFLdjVFLEtBQUssR0FBRzA1RTtRQUNmO0lBQ0Y7SUFDQUQsaUJBQWlCRixJQUFJLEVBQUVsakUsTUFBTSxFQUFFcWpFLGVBQWUsRUFBRSxFQUFFO1FBQ2hESCxLQUFLNTFHLElBQUksR0FBRyxJQUFJLENBQUM0cUIsV0FBVyxDQUFDa3NGLFlBQVksQ0FBQztRQUMxQ2xCLEtBQUtnQixPQUFPLEdBQUc7WUFDYixJQUFJLENBQUNoc0YsV0FBVyxDQUFDbXNGLGtCQUFrQixDQUFDcmtFO1lBQ3BDLE9BQU87UUFDVDtRQUNBLElBQUlxakUsY0FBYztZQUNoQkgsS0FBS3Y1RSxLQUFLLEdBQUcwNUU7UUFDZjtRQUNBLElBQUksQ0FBQyxDQUFDVSxlQUFlO0lBQ3ZCO0lBQ0EsQ0FBQ1IsY0FBYyxDQUFDTCxJQUFJLEVBQUVJLFVBQVUsRUFBRUQsZUFBZSxFQUFFLEVBQUV6dUYsT0FBTyxJQUFJO1FBQzlEc3VGLEtBQUs1MUcsSUFBSSxHQUFHLElBQUksQ0FBQzRxQixXQUFXLENBQUNrc0YsWUFBWSxDQUFDO1FBQzFDLElBQUlkLFdBQVc1NUUsV0FBVyxFQUFFO1lBQzFCdzVFLEtBQUt2NUUsS0FBSyxHQUFHMjVFLFdBQVc1NUUsV0FBVztRQUNyQyxPQUFPLElBQUkyNUUsY0FBYztZQUN2QkgsS0FBS3Y1RSxLQUFLLEdBQUcwNUU7UUFDZjtRQUNBSCxLQUFLZ0IsT0FBTyxHQUFHO1lBQ2IsSUFBSSxDQUFDM0csZUFBZSxFQUFFK0csbUJBQW1CaEIsV0FBV3p2SCxPQUFPLEVBQUV5dkgsV0FBV2xtRixRQUFRLEVBQUV4STtZQUNsRixPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUMsQ0FBQ212RixlQUFlO0lBQ3ZCO0lBQ0EsQ0FBQ04sZUFBZSxDQUFDUCxJQUFJLEVBQUVsakUsTUFBTSxFQUFFcWpFLGVBQWUsRUFBRTtRQUM5Q0gsS0FBSzUxRyxJQUFJLEdBQUcsSUFBSSxDQUFDNHFCLFdBQVcsQ0FBQ2tzRixZQUFZLENBQUM7UUFDMUNsQixLQUFLZ0IsT0FBTyxHQUFHO1lBQ2IsSUFBSSxDQUFDaHNGLFdBQVcsQ0FBQ3FzRixrQkFBa0IsQ0FBQ3ZrRTtZQUNwQyxPQUFPO1FBQ1Q7UUFDQSxJQUFJcWpFLGNBQWM7WUFDaEJILEtBQUt2NUUsS0FBSyxHQUFHMDVFO1FBQ2Y7UUFDQSxJQUFJLENBQUMsQ0FBQ1UsZUFBZTtJQUN2QjtJQUNBSCxjQUFjVixJQUFJLEVBQUU3ckgsSUFBSSxFQUFFO1FBQ3hCNnJILEtBQUs1MUcsSUFBSSxHQUFHLElBQUksQ0FBQzRxQixXQUFXLENBQUNrc0YsWUFBWSxDQUFDO1FBQzFDLE1BQU16eUgsTUFBTSxJQUFJcWlDLElBQUk7WUFBQztnQkFBQztnQkFBVTthQUFVO1lBQUU7Z0JBQUM7Z0JBQVk7YUFBWTtZQUFFO2dCQUFDO2dCQUFjO2FBQWM7U0FBQztRQUNyRyxLQUFLLE1BQU1wcUMsUUFBUVQsT0FBT21GLElBQUksQ0FBQytJLEtBQUt1cEgsT0FBTyxFQUFHO1lBQzVDLE1BQU1WLFNBQVN2dUgsSUFBSTVJLEdBQUcsQ0FBQ2E7WUFDdkIsSUFBSSxDQUFDczJILFFBQVE7Z0JBQ1g7WUFDRjtZQUNBZ0QsSUFBSSxDQUFDaEQsT0FBTyxHQUFHO2dCQUNiLElBQUksQ0FBQ2hvRixXQUFXLENBQUN5YixRQUFRLEVBQUUyRSxTQUFTLDBCQUEwQjtvQkFDNUQvdEQsUUFBUSxJQUFJO29CQUNaMHVILFFBQVE7d0JBQ054OUcsSUFBSXBFLEtBQUtvRSxFQUFFO3dCQUNYN1I7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsT0FBTztZQUNUO1FBQ0Y7UUFDQSxJQUFJeU4sS0FBS2dzSCxZQUFZLEVBQUU7WUFDckJILEtBQUt2NUUsS0FBSyxHQUFHdHlDLEtBQUtnc0gsWUFBWTtRQUNoQztRQUNBLElBQUksQ0FBQ0gsS0FBS2dCLE9BQU8sRUFBRTtZQUNqQmhCLEtBQUtnQixPQUFPLEdBQUcsSUFBTTtRQUN2QjtRQUNBLElBQUksQ0FBQyxDQUFDSCxlQUFlO0lBQ3ZCO0lBQ0FELHFCQUFxQlosSUFBSSxFQUFFVyxTQUFTLEVBQUU7UUFDcEMsTUFBTVcsbUJBQW1CdEIsS0FBS2dCLE9BQU87UUFDckMsSUFBSSxDQUFDTSxrQkFBa0I7WUFDckJ0QixLQUFLNTFHLElBQUksR0FBRyxJQUFJLENBQUM0cUIsV0FBVyxDQUFDa3NGLFlBQVksQ0FBQztRQUM1QztRQUNBLElBQUksQ0FBQyxDQUFDTCxlQUFlO1FBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUNsRyxhQUFhLEVBQUU7WUFDdkJ4MEYsS0FBSyxDQUFDLHlEQUF5RCxDQUFDLEdBQUc7WUFDbkUsSUFBSSxDQUFDbTdGLGtCQUFrQjtnQkFDckJ0QixLQUFLZ0IsT0FBTyxHQUFHLElBQU07WUFDdkI7WUFDQTtRQUNGO1FBQ0FoQixLQUFLZ0IsT0FBTyxHQUFHO1lBQ2JNO1lBQ0EsTUFBTSxFQUNKdkMsUUFBUXdDLGVBQWUsRUFDdkJDLE1BQU1DLGFBQWEsRUFDbkJDLE9BQU8sRUFDUixHQUFHZjtZQUNKLE1BQU1nQixZQUFZLEVBQUU7WUFDcEIsSUFBSUosZ0JBQWdCMzlILE1BQU0sS0FBSyxLQUFLNjlILGNBQWM3OUgsTUFBTSxLQUFLLEdBQUc7Z0JBQzlELE1BQU1nK0gsV0FBVyxJQUFJaG1ILElBQUk2bEg7Z0JBQ3pCLEtBQUssTUFBTUksYUFBYU4sZ0JBQWlCO29CQUN2QyxNQUFNeEMsU0FBUyxJQUFJLENBQUNwRSxhQUFhLENBQUNrSCxVQUFVLElBQUksRUFBRTtvQkFDbEQsS0FBSyxNQUFNLEVBQ1R0cEgsRUFBRSxFQUNILElBQUl3bUgsT0FBUTt3QkFDWDZDLFNBQVNub0gsR0FBRyxDQUFDbEI7b0JBQ2Y7Z0JBQ0Y7Z0JBQ0EsS0FBSyxNQUFNd21ILFVBQVU5NEgsT0FBT3lrQixNQUFNLENBQUMsSUFBSSxDQUFDaXdHLGFBQWEsRUFBRztvQkFDdEQsS0FBSyxNQUFNbUgsU0FBUy9DLE9BQVE7d0JBQzFCLElBQUk2QyxTQUFTeDFILEdBQUcsQ0FBQzAxSCxNQUFNdnBILEVBQUUsTUFBTW1wSCxTQUFTOzRCQUN0Q0MsVUFBVTl5SCxJQUFJLENBQUNpekg7d0JBQ2pCO29CQUNGO2dCQUNGO1lBQ0YsT0FBTztnQkFDTCxLQUFLLE1BQU0vQyxVQUFVOTRILE9BQU95a0IsTUFBTSxDQUFDLElBQUksQ0FBQ2l3RyxhQUFhLEVBQUc7b0JBQ3REZ0gsVUFBVTl5SCxJQUFJLElBQUlrd0g7Z0JBQ3BCO1lBQ0Y7WUFDQSxNQUFNL3FGLFVBQVUsSUFBSSxDQUFDeUIsaUJBQWlCO1lBQ3RDLE1BQU1zc0YsU0FBUyxFQUFFO1lBQ2pCLEtBQUssTUFBTUQsU0FBU0gsVUFBVztnQkFDN0IsTUFBTSxFQUNKcHBILEVBQUUsRUFDSCxHQUFHdXBIO2dCQUNKQyxPQUFPbHpILElBQUksQ0FBQzBKO2dCQUNaLE9BQVF1cEgsTUFBTXYxSCxJQUFJO29CQUNoQixLQUFLO3dCQUNIOzRCQUNFLE1BQU0xSCxRQUFRaTlILE1BQU03bkQsWUFBWSxJQUFJOzRCQUNwQ2ptQyxRQUFRSyxRQUFRLENBQUM5N0IsSUFBSTtnQ0FDbkIxVDs0QkFDRjs0QkFDQTt3QkFDRjtvQkFDRixLQUFLO29CQUNMLEtBQUs7d0JBQ0g7NEJBQ0UsTUFBTUEsUUFBUWk5SCxNQUFNN25ELFlBQVksS0FBSzZuRCxNQUFNN0MsWUFBWTs0QkFDdkRqckYsUUFBUUssUUFBUSxDQUFDOTdCLElBQUk7Z0NBQ25CMVQ7NEJBQ0Y7NEJBQ0E7d0JBQ0Y7b0JBQ0YsS0FBSztvQkFDTCxLQUFLO3dCQUNIOzRCQUNFLE1BQU1BLFFBQVFpOUgsTUFBTTduRCxZQUFZLElBQUk7NEJBQ3BDam1DLFFBQVFLLFFBQVEsQ0FBQzk3QixJQUFJO2dDQUNuQjFUOzRCQUNGOzRCQUNBO3dCQUNGO29CQUNGO3dCQUNFO2dCQUNKO2dCQUNBLE1BQU1zNkgsYUFBYXh0SCxTQUFTMjBDLGFBQWEsQ0FBQyxDQUFDLGtCQUFrQixFQUFFL3RDLEdBQUcsRUFBRSxDQUFDO2dCQUNyRSxJQUFJLENBQUM0bUgsWUFBWTtvQkFDZjtnQkFDRixPQUFPLElBQUksQ0FBQ3BILHFCQUFxQjNySCxHQUFHLENBQUMreUgsYUFBYTtvQkFDaERoNUYsS0FBSyxDQUFDLDRDQUE0QyxFQUFFNXRCLEdBQUcsQ0FBQztvQkFDeEQ7Z0JBQ0Y7Z0JBQ0E0bUgsV0FBVzZDLGFBQWEsQ0FBQyxJQUFJQyxNQUFNO1lBQ3JDO1lBQ0EsSUFBSSxJQUFJLENBQUN2SCxlQUFlLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQzFsRixXQUFXLENBQUN5YixRQUFRLEVBQUUyRSxTQUFTLDBCQUEwQjtvQkFDNUQvdEQsUUFBUSxJQUFJO29CQUNaMHVILFFBQVE7d0JBQ054OUcsSUFBSTt3QkFDSjZpRSxLQUFLMm1EO3dCQUNMcjdILE1BQU07b0JBQ1I7Z0JBQ0Y7WUFDRjtZQUNBLE9BQU87UUFDVDtJQUNGO0FBQ0Y7QUFDQSxNQUFNMHhILDhCQUE4QjBCO0lBQ2xDOXlILFlBQVl3dUMsVUFBVSxDQUFFO1FBQ3RCLEtBQUssQ0FBQ0EsWUFBWTtZQUNoQjBrRixjQUFjO1FBQ2hCO0lBQ0Y7SUFDQTNrRixTQUFTO1FBQ1AsSUFBSSxDQUFDb00sU0FBUyxDQUFDOUIsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztRQUM3QixNQUFNNHVDLFFBQVExMkMsU0FBUzJJLGFBQWEsQ0FBQztRQUNyQyt0QyxNQUFNNTJDLEdBQUcsR0FBRyxJQUFJLENBQUM2b0gsa0JBQWtCLEdBQUcsZ0JBQWdCLElBQUksQ0FBQ25tSCxJQUFJLENBQUN6TixJQUFJLENBQUM2TixXQUFXLEtBQUs7UUFDckY4ekMsTUFBTTlULFlBQVksQ0FBQyxnQkFBZ0I7UUFDbkM4VCxNQUFNOVQsWUFBWSxDQUFDLGtCQUFrQjNtQixLQUFLb3FDLFNBQVMsQ0FBQztZQUNsRHpyRCxNQUFNLElBQUksQ0FBQzRILElBQUksQ0FBQ3pOLElBQUk7UUFDdEI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDeU4sSUFBSSxDQUFDa29ELFFBQVEsSUFBSSxJQUFJLENBQUM2K0QsWUFBWSxFQUFFO1lBQzVDLElBQUksQ0FBQ1ksWUFBWTtRQUNuQjtRQUNBLElBQUksQ0FBQ242RSxTQUFTLENBQUNqa0MsTUFBTSxDQUFDMnFDO1FBQ3RCLE9BQU8sSUFBSSxDQUFDMUcsU0FBUztJQUN2QjtBQUNGO0FBQ0EsTUFBTW0zRSxnQ0FBZ0NnQjtJQUNwQ3ZrRixTQUFTO1FBQ1AsT0FBTyxJQUFJLENBQUNvTSxTQUFTO0lBQ3ZCO0lBQ0F1Z0YseUJBQXlCbnVGLE9BQU8sRUFBRTtRQUNoQyxJQUFJLElBQUksQ0FBQzUvQixJQUFJLENBQUNpNkYsWUFBWSxFQUFFO1lBQzFCLElBQUlyNkQsUUFBUStoRixlQUFlLEVBQUUvOUMsYUFBYSxVQUFVO2dCQUNsRGhrQyxRQUFRK2hGLGVBQWUsQ0FBQ3IvRSxNQUFNLEdBQUc7WUFDbkM7WUFDQTFDLFFBQVEwQyxNQUFNLEdBQUc7UUFDbkI7SUFDRjtJQUNBMHJGLGdCQUFnQi90RixLQUFLLEVBQUU7UUFDckIsT0FBT3BMLGlCQUFpQkssUUFBUSxDQUFDRyxLQUFLLEdBQUc0SyxNQUFNMFgsT0FBTyxHQUFHMVgsTUFBTXlYLE9BQU87SUFDeEU7SUFDQXUyRSxrQkFBa0JydUYsT0FBTyxFQUFFc3VGLFdBQVcsRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUVDLFdBQVcsRUFBRTtRQUN4RSxJQUFJRixTQUFTanBILFFBQVEsQ0FBQyxVQUFVO1lBQzlCMDZCLFFBQVFoQixnQkFBZ0IsQ0FBQ3V2RixVQUFVbHVGLENBQUFBO2dCQUNqQyxJQUFJLENBQUNZLFdBQVcsQ0FBQ3liLFFBQVEsRUFBRTJFLFNBQVMsMEJBQTBCO29CQUM1RC90RCxRQUFRLElBQUk7b0JBQ1owdUgsUUFBUTt3QkFDTng5RyxJQUFJLElBQUksQ0FBQ3BFLElBQUksQ0FBQ29FLEVBQUU7d0JBQ2hCN1IsTUFBTTY3SDt3QkFDTjE5SCxPQUFPMjlILFlBQVlwdUY7d0JBQ25CNWdCLE9BQU80Z0IsTUFBTTJYLFFBQVE7d0JBQ3JCMDJFLFVBQVUsSUFBSSxDQUFDTixlQUFlLENBQUMvdEY7b0JBQ2pDO2dCQUNGO1lBQ0Y7UUFDRixPQUFPO1lBQ0xMLFFBQVFoQixnQkFBZ0IsQ0FBQ3V2RixVQUFVbHVGLENBQUFBO2dCQUNqQyxJQUFJa3VGLGFBQWEsUUFBUTtvQkFDdkIsSUFBSSxDQUFDRCxZQUFZSyxPQUFPLElBQUksQ0FBQ3R1RixNQUFNaTVCLGFBQWEsRUFBRTt3QkFDaEQ7b0JBQ0Y7b0JBQ0FnMUQsWUFBWUssT0FBTyxHQUFHO2dCQUN4QixPQUFPLElBQUlKLGFBQWEsU0FBUztvQkFDL0IsSUFBSUQsWUFBWUssT0FBTyxFQUFFO3dCQUN2QjtvQkFDRjtvQkFDQUwsWUFBWUssT0FBTyxHQUFHO2dCQUN4QjtnQkFDQSxJQUFJLENBQUNGLGFBQWE7b0JBQ2hCO2dCQUNGO2dCQUNBLElBQUksQ0FBQ3h0RixXQUFXLENBQUN5YixRQUFRLEVBQUUyRSxTQUFTLDBCQUEwQjtvQkFDNUQvdEQsUUFBUSxJQUFJO29CQUNaMHVILFFBQVE7d0JBQ054OUcsSUFBSSxJQUFJLENBQUNwRSxJQUFJLENBQUNvRSxFQUFFO3dCQUNoQjdSLE1BQU02N0g7d0JBQ04xOUgsT0FBTzI5SCxZQUFZcHVGO29CQUNyQjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBdXVGLG1CQUFtQjV1RixPQUFPLEVBQUVzdUYsV0FBVyxFQUFFdHpILEtBQUssRUFBRW5JLE1BQU0sRUFBRTtRQUN0RCxLQUFLLE1BQU0sQ0FBQzA3SCxVQUFVQyxVQUFVLElBQUl4ekgsTUFBTztZQUN6QyxJQUFJd3pILGNBQWMsWUFBWSxJQUFJLENBQUNwdUgsSUFBSSxDQUFDdXBILE9BQU8sRUFBRSxDQUFDNkUsVUFBVSxFQUFFO2dCQUM1RCxJQUFJQSxjQUFjLFdBQVdBLGNBQWMsUUFBUTtvQkFDakRGLGdCQUFnQjt3QkFDZEssU0FBUztvQkFDWDtnQkFDRjtnQkFDQSxJQUFJLENBQUNOLGlCQUFpQixDQUFDcnVGLFNBQVNzdUYsYUFBYUMsVUFBVUMsV0FBVzM3SDtnQkFDbEUsSUFBSTI3SCxjQUFjLFdBQVcsQ0FBQyxJQUFJLENBQUNwdUgsSUFBSSxDQUFDdXBILE9BQU8sRUFBRWtGLE1BQU07b0JBQ3JELElBQUksQ0FBQ1IsaUJBQWlCLENBQUNydUYsU0FBU3N1RixhQUFhLFFBQVEsUUFBUTtnQkFDL0QsT0FBTyxJQUFJRSxjQUFjLFVBQVUsQ0FBQyxJQUFJLENBQUNwdUgsSUFBSSxDQUFDdXBILE9BQU8sRUFBRW1GLE9BQU87b0JBQzVELElBQUksQ0FBQ1QsaUJBQWlCLENBQUNydUYsU0FBU3N1RixhQUFhLFNBQVMsU0FBUztnQkFDakU7WUFDRjtRQUNGO0lBQ0Y7SUFDQVMsb0JBQW9CL3VGLE9BQU8sRUFBRTtRQUMzQixNQUFNNkksUUFBUSxJQUFJLENBQUN6b0MsSUFBSSxDQUFDcXdELGVBQWUsSUFBSTtRQUMzQ3p3QixRQUFRemlDLEtBQUssQ0FBQ2t6RCxlQUFlLEdBQUc1bkIsVUFBVSxPQUFPLGdCQUFnQjVTLEtBQUtDLFlBQVksQ0FBQzJTLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFO0lBQ2pIO0lBQ0FtbUYsY0FBY2h2RixPQUFPLEVBQUU7UUFDckIsTUFBTWl2RixpQkFBaUI7WUFBQztZQUFRO1lBQVU7U0FBUTtRQUNsRCxNQUFNLEVBQ0pDLFNBQVMsRUFDVixHQUFHLElBQUksQ0FBQzl1SCxJQUFJLENBQUMrdUgscUJBQXFCO1FBQ25DLE1BQU1ua0MsV0FBVyxJQUFJLENBQUM1cUYsSUFBSSxDQUFDK3VILHFCQUFxQixDQUFDbmtDLFFBQVEsSUFBSSs0QjtRQUM3RCxNQUFNeG1ILFFBQVF5aUMsUUFBUXppQyxLQUFLO1FBQzNCLElBQUk2eEg7UUFDSixNQUFNdnNDLGNBQWM7UUFDcEIsTUFBTXdzQyxvQkFBb0I3NEgsQ0FBQUEsSUFBS0gsS0FBSzYxQyxLQUFLLENBQUMsS0FBSzExQyxLQUFLO1FBQ3BELElBQUksSUFBSSxDQUFDNEosSUFBSSxDQUFDa3ZILFNBQVMsRUFBRTtZQUN2QixNQUFNcnFGLFNBQVM1dUMsS0FBSytMLEdBQUcsQ0FBQyxJQUFJLENBQUNoQyxJQUFJLENBQUN1M0IsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUN2M0IsSUFBSSxDQUFDdTNCLElBQUksQ0FBQyxFQUFFLEdBQUdrckQ7WUFDaEUsTUFBTTBzQyxnQkFBZ0JsNUgsS0FBSzYxQyxLQUFLLENBQUNqSCxTQUFVdmlCLENBQUFBLGNBQWNzb0UsUUFBTyxNQUFPO1lBQ3ZFLE1BQU00a0IsYUFBYTNxRSxTQUFTc3FGO1lBQzVCSCxtQkFBbUIvNEgsS0FBS21GLEdBQUcsQ0FBQ3d2RixVQUFVcWtDLGtCQUFrQnpmLGFBQWFsdEY7UUFDdkUsT0FBTztZQUNMLE1BQU11aUIsU0FBUzV1QyxLQUFLK0wsR0FBRyxDQUFDLElBQUksQ0FBQ2hDLElBQUksQ0FBQ3UzQixJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ3YzQixJQUFJLENBQUN1M0IsSUFBSSxDQUFDLEVBQUUsR0FBR2tyRDtZQUNoRXVzQyxtQkFBbUIvNEgsS0FBS21GLEdBQUcsQ0FBQ3d2RixVQUFVcWtDLGtCQUFrQnBxRixTQUFTdmlCO1FBQ25FO1FBQ0FubEIsTUFBTXl0RixRQUFRLEdBQUcsQ0FBQyxLQUFLLEVBQUVva0MsaUJBQWlCLCtCQUErQixDQUFDO1FBQzFFN3hILE1BQU1zckMsS0FBSyxHQUFHNVMsS0FBS0MsWUFBWSxDQUFDZzVGLFNBQVMsQ0FBQyxFQUFFLEVBQUVBLFNBQVMsQ0FBQyxFQUFFLEVBQUVBLFNBQVMsQ0FBQyxFQUFFO1FBQ3hFLElBQUksSUFBSSxDQUFDOXVILElBQUksQ0FBQ292SCxhQUFhLEtBQUssTUFBTTtZQUNwQ2p5SCxNQUFNa3lILFNBQVMsR0FBR1IsY0FBYyxDQUFDLElBQUksQ0FBQzd1SCxJQUFJLENBQUNvdkgsYUFBYSxDQUFDO1FBQzNEO0lBQ0Y7SUFDQWhHLGFBQWF4cEYsT0FBTyxFQUFFMHZGLFVBQVUsRUFBRTtRQUNoQyxJQUFJQSxZQUFZO1lBQ2QxdkYsUUFBUVEsWUFBWSxDQUFDLFlBQVk7UUFDbkMsT0FBTztZQUNMUixRQUFRVSxlQUFlLENBQUM7UUFDMUI7UUFDQVYsUUFBUVEsWUFBWSxDQUFDLGlCQUFpQmt2RjtJQUN4QztBQUNGO0FBQ0EsTUFBTW5MLG9DQUFvQ1E7SUFDeEM5eEgsWUFBWXd1QyxVQUFVLENBQUU7UUFDdEIsTUFBTTBrRixlQUFlMWtGLFdBQVcra0YsV0FBVyxJQUFJL2tGLFdBQVdyaEMsSUFBSSxDQUFDaTZGLFlBQVksSUFBSSxDQUFDNTRELFdBQVdyaEMsSUFBSSxDQUFDdXZILGFBQWEsSUFBSSxDQUFDLENBQUNsdUYsV0FBV3JoQyxJQUFJLENBQUN3dkgsVUFBVTtRQUM3SSxLQUFLLENBQUNudUYsWUFBWTtZQUNoQjBrRjtRQUNGO0lBQ0Y7SUFDQTBKLHNCQUFzQm44RyxJQUFJLEVBQUV6WSxHQUFHLEVBQUVuSyxLQUFLLEVBQUVnL0gsWUFBWSxFQUFFO1FBQ3BELE1BQU03dkYsVUFBVSxJQUFJLENBQUN5QixpQkFBaUI7UUFDdEMsS0FBSyxNQUFNMUIsV0FBVyxJQUFJLENBQUM4cUYsa0JBQWtCLENBQUNwM0csS0FBSy9nQixJQUFJLEVBQUUrZ0IsS0FBS2xQLEVBQUUsRUFBRztZQUNqRSxJQUFJdzdCLFFBQVFvckYsVUFBVSxFQUFFO2dCQUN0QnByRixRQUFRb3JGLFVBQVUsQ0FBQ253SCxJQUFJLEdBQUduSztZQUM1QjtZQUNBbXZDLFFBQVFLLFFBQVEsQ0FBQ04sUUFBUXg3QixFQUFFLEVBQUU7Z0JBQzNCLENBQUNzckgsYUFBYSxFQUFFaC9IO1lBQ2xCO1FBQ0Y7SUFDRjtJQUNBMHdDLFNBQVM7UUFDUCxNQUFNdkIsVUFBVSxJQUFJLENBQUN5QixpQkFBaUI7UUFDdEMsTUFBTWw5QixLQUFLLElBQUksQ0FBQ3BFLElBQUksQ0FBQ29FLEVBQUU7UUFDdkIsSUFBSSxDQUFDb3BDLFNBQVMsQ0FBQzlCLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7UUFDN0IsSUFBSXM2QixVQUFVO1FBQ2QsSUFBSSxJQUFJLENBQUN3bUYsV0FBVyxFQUFFO1lBQ3BCLE1BQU1ybUYsYUFBYUYsUUFBUUcsUUFBUSxDQUFDNTdCLElBQUk7Z0JBQ3RDMVQsT0FBTyxJQUFJLENBQUNzUCxJQUFJLENBQUN3dkgsVUFBVTtZQUM3QjtZQUNBLElBQUl0d0YsY0FBY2EsV0FBV3J2QyxLQUFLLElBQUk7WUFDdEMsTUFBTWkvSCxTQUFTOXZGLFFBQVFHLFFBQVEsQ0FBQzU3QixJQUFJO2dCQUNsQ3dySCxXQUFXLElBQUksQ0FBQzV2SCxJQUFJLENBQUMydkgsTUFBTTtZQUM3QixHQUFHQyxTQUFTO1lBQ1osSUFBSUQsVUFBVXp3RixZQUFZenZDLE1BQU0sR0FBR2tnSSxRQUFRO2dCQUN6Q3p3RixjQUFjQSxZQUFZbHRDLEtBQUssQ0FBQyxHQUFHMjlIO1lBQ3JDO1lBQ0EsSUFBSUUsdUJBQXVCOXZGLFdBQVcrdkYsY0FBYyxJQUFJLElBQUksQ0FBQzl2SCxJQUFJLENBQUNrL0IsV0FBVyxFQUFFaHRDLEtBQUssU0FBUztZQUM3RixJQUFJMjlILHdCQUF3QixJQUFJLENBQUM3dkgsSUFBSSxDQUFDK3ZILElBQUksRUFBRTtnQkFDMUNGLHVCQUF1QkEscUJBQXFCMTBGLFVBQVUsQ0FBQyxRQUFRO1lBQ2pFO1lBQ0EsTUFBTSt5RixjQUFjO2dCQUNsQjhCLFdBQVc5d0Y7Z0JBQ1g0d0YsZ0JBQWdCRDtnQkFDaEJJLG9CQUFvQjtnQkFDcEJDLFdBQVc7Z0JBQ1gzQixTQUFTO1lBQ1g7WUFDQSxJQUFJLElBQUksQ0FBQ3Z1SCxJQUFJLENBQUNrdkgsU0FBUyxFQUFFO2dCQUN2QnR2RixVQUFVcGlDLFNBQVMySSxhQUFhLENBQUM7Z0JBQ2pDeTVCLFFBQVFWLFdBQVcsR0FBRzJ3Rix3QkFBd0Izd0Y7Z0JBQzlDLElBQUksSUFBSSxDQUFDbC9CLElBQUksQ0FBQ213SCxXQUFXLEVBQUU7b0JBQ3pCdndGLFFBQVF6aUMsS0FBSyxDQUFDaXpILFNBQVMsR0FBRztnQkFDNUI7WUFDRixPQUFPO2dCQUNMeHdGLFVBQVVwaUMsU0FBUzJJLGFBQWEsQ0FBQztnQkFDakN5NUIsUUFBUXhuQyxJQUFJLEdBQUcsSUFBSSxDQUFDNEgsSUFBSSxDQUFDa3dHLFFBQVEsR0FBRyxhQUFhO2dCQUNqRHR3RSxRQUFRUSxZQUFZLENBQUMsU0FBU3l2Rix3QkFBd0Izd0Y7Z0JBQ3RELElBQUksSUFBSSxDQUFDbC9CLElBQUksQ0FBQ213SCxXQUFXLEVBQUU7b0JBQ3pCdndGLFFBQVF6aUMsS0FBSyxDQUFDa3pILFNBQVMsR0FBRztnQkFDNUI7WUFDRjtZQUNBLElBQUksSUFBSSxDQUFDcndILElBQUksQ0FBQ2k2RixZQUFZLEVBQUU7Z0JBQzFCcjZELFFBQVEwQyxNQUFNLEdBQUc7WUFDbkI7WUFDQXNoRixxQkFBcUJ0K0csR0FBRyxDQUFDczZCO1lBQ3pCQSxRQUFRUSxZQUFZLENBQUMsbUJBQW1CaDhCO1lBQ3hDdzdCLFFBQVEwdkIsUUFBUSxHQUFHLElBQUksQ0FBQ3R2RCxJQUFJLENBQUNzd0gsUUFBUTtZQUNyQzF3RixRQUFRcnRDLElBQUksR0FBRyxJQUFJLENBQUN5TixJQUFJLENBQUMwdEgsU0FBUztZQUNsQzl0RixRQUFRb1IsUUFBUSxHQUFHO1lBQ25CLE1BQU0sRUFDSnUvRSxjQUFjLEVBQ2RDLFlBQVksRUFDWkMsUUFBUSxFQUNULEdBQUcsSUFBSSxDQUFDendILElBQUk7WUFDYixNQUFNMHdILGdCQUFnQixDQUFDLENBQUNGLGdCQUFnQixJQUFJLENBQUNqSyxlQUFlO1lBQzVELElBQUlnSyxnQkFBZ0I7Z0JBQ2xCM3dGLFFBQVEwUyxLQUFLLEdBQUdpK0U7WUFDbEI7WUFDQSxJQUFJLENBQUNuSCxZQUFZLENBQUN4cEYsU0FBUyxJQUFJLENBQUM1L0IsSUFBSSxDQUFDZ0IsUUFBUTtZQUM3QyxJQUFJMnVILFFBQVE7Z0JBQ1YvdkYsUUFBUW5rQyxTQUFTLEdBQUdrMEg7WUFDdEI7WUFDQS92RixRQUFRaEIsZ0JBQWdCLENBQUMsU0FBU3FCLENBQUFBO2dCQUNoQ0osUUFBUUssUUFBUSxDQUFDOTdCLElBQUk7b0JBQ25CMVQsT0FBT3V2QyxNQUFNaHdDLE1BQU0sQ0FBQ1MsS0FBSztnQkFDM0I7Z0JBQ0EsSUFBSSxDQUFDKytILHFCQUFxQixDQUFDN3ZGLFNBQVMsU0FBU0ssTUFBTWh3QyxNQUFNLENBQUNTLEtBQUssRUFBRTtnQkFDakV3OUgsWUFBWTRCLGNBQWMsR0FBRztZQUMvQjtZQUNBbHdGLFFBQVFoQixnQkFBZ0IsQ0FBQyxhQUFhcUIsQ0FBQUE7Z0JBQ3BDLE1BQU02bEMsZUFBZSxJQUFJLENBQUM5bEUsSUFBSSxDQUFDMndILGlCQUFpQixJQUFJO2dCQUNwRC93RixRQUFRbHZDLEtBQUssR0FBR3c5SCxZQUFZOEIsU0FBUyxHQUFHbHFEO2dCQUN4Q29vRCxZQUFZNEIsY0FBYyxHQUFHO1lBQy9CO1lBQ0EsSUFBSWMsZUFBZTN3RixDQUFBQTtnQkFDakIsTUFBTSxFQUNKNnZGLGNBQWMsRUFDZixHQUFHNUI7Z0JBQ0osSUFBSTRCLG1CQUFtQixRQUFRQSxtQkFBbUI5OEgsV0FBVztvQkFDM0RpdEMsTUFBTWh3QyxNQUFNLENBQUNTLEtBQUssR0FBR28vSDtnQkFDdkI7Z0JBQ0E3dkYsTUFBTWh3QyxNQUFNLENBQUM0Z0ksVUFBVSxHQUFHO1lBQzVCO1lBQ0EsSUFBSSxJQUFJLENBQUN0SyxlQUFlLElBQUksSUFBSSxDQUFDeFEsWUFBWSxFQUFFO2dCQUM3Q24yRSxRQUFRaEIsZ0JBQWdCLENBQUMsU0FBU3FCLENBQUFBO29CQUNoQyxJQUFJaXVGLFlBQVlLLE9BQU8sRUFBRTt3QkFDdkI7b0JBQ0Y7b0JBQ0EsTUFBTSxFQUNKdCtILE1BQU0sRUFDUCxHQUFHZ3dDO29CQUNKLElBQUl5d0YsZUFBZTt3QkFDakJ6Z0ksT0FBT21JLElBQUksR0FBR280SDt3QkFDZCxJQUFJQyxVQUFVOzRCQUNaeGdJLE9BQU95RSxJQUFJLEdBQUcrN0g7d0JBQ2hCO29CQUNGO29CQUNBLElBQUl2QyxZQUFZOEIsU0FBUyxFQUFFO3dCQUN6QixNQUFNdC9ILFFBQVF3OUgsWUFBWThCLFNBQVM7d0JBQ25DLElBQUlVLGVBQWU7NEJBQ2pCLElBQUlGLGlCQUFpQixRQUFRO2dDQUMzQixNQUFNeDBGLE9BQU8sSUFBSUMsS0FBS3ZyQztnQ0FDdEIsTUFBTWsxRyxRQUFRO29DQUFDNXBFLEtBQUs4MEYsUUFBUTtvQ0FBSTkwRixLQUFLKzBGLFVBQVU7b0NBQUkvMEYsS0FBS2cxRixVQUFVO2lDQUFHO2dDQUNyRS9nSSxPQUFPUyxLQUFLLEdBQUdrMUcsTUFBTXRyRyxHQUFHLENBQUN1UCxDQUFBQSxJQUFLQSxFQUFFelcsUUFBUSxHQUFHd2lDLFFBQVEsQ0FBQyxHQUFHLE1BQU0xakMsSUFBSSxDQUFDOzRCQUNwRSxPQUFPO2dDQUNMakMsT0FBT1MsS0FBSyxHQUFHLElBQUl1ckMsS0FBS3ZyQyxRQUFRbXpILGlCQUFpQm9OLFdBQVcsR0FBRzUrSCxLQUFLLENBQUNtK0gsaUJBQWlCLFNBQVMsTUFBTSxLQUFLLEVBQUUsQ0FBQyxFQUFFOzRCQUNqSDt3QkFDRixPQUFPOzRCQUNMdmdJLE9BQU9TLEtBQUssR0FBR0E7d0JBQ2pCO29CQUNGO29CQUNBdzlILFlBQVkrQixrQkFBa0IsR0FBR2hnSSxPQUFPUyxLQUFLO29CQUM3Q3c5SCxZQUFZZ0MsU0FBUyxHQUFHO29CQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDbHdILElBQUksQ0FBQ3VwSCxPQUFPLEVBQUVtRixPQUFPO3dCQUM3QlIsWUFBWUssT0FBTyxHQUFHO29CQUN4QjtnQkFDRjtnQkFDQTN1RixRQUFRaEIsZ0JBQWdCLENBQUMscUJBQXFCNHFGLENBQUFBO29CQUM1QyxJQUFJLENBQUN1RSx3QkFBd0IsQ0FBQ3ZFLFFBQVF2NUgsTUFBTTtvQkFDNUMsTUFBTXM1SCxVQUFVO3dCQUNkNzRILE9BQU11dkMsS0FBSzs0QkFDVGl1RixZQUFZOEIsU0FBUyxHQUFHL3ZGLE1BQU0yaEYsTUFBTSxDQUFDbHhILEtBQUssSUFBSTs0QkFDOUMsSUFBSSxDQUFDZ2dJLGVBQWU7Z0NBQ2xCN3dGLFFBQVFLLFFBQVEsQ0FBQzk3QixJQUFJO29DQUNuQjFULE9BQU93OUgsWUFBWThCLFNBQVMsQ0FBQzU4SCxRQUFRO2dDQUN2Qzs0QkFDRjs0QkFDQTZzQyxNQUFNaHdDLE1BQU0sQ0FBQ1MsS0FBSyxHQUFHdzlILFlBQVk4QixTQUFTO3dCQUM1Qzt3QkFDQUYsZ0JBQWU3dkYsS0FBSzs0QkFDbEIsTUFBTSxFQUNKNnZGLGNBQWMsRUFDZixHQUFHN3ZGLE1BQU0yaEYsTUFBTTs0QkFDaEJzTSxZQUFZNEIsY0FBYyxHQUFHQTs0QkFDN0IsSUFBSUEsbUJBQW1CLFFBQVFBLG1CQUFtQjk4SCxhQUFhaXRDLE1BQU1od0MsTUFBTSxLQUFLdU4sU0FBU2crQyxhQUFhLEVBQUU7Z0NBQ3RHdmIsTUFBTWh3QyxNQUFNLENBQUNTLEtBQUssR0FBR28vSDs0QkFDdkI7NEJBQ0EsTUFBTTl2SCxPQUFPO2dDQUNYOHZIOzRCQUNGOzRCQUNBLElBQUlZLGVBQWU7Z0NBQ2pCMXdILEtBQUt0UCxLQUFLLEdBQUdvL0g7NEJBQ2Y7NEJBQ0Fqd0YsUUFBUUssUUFBUSxDQUFDOTdCLElBQUlwRTt3QkFDdkI7d0JBQ0FreEgsVUFBU2p4RixLQUFLOzRCQUNaQSxNQUFNaHdDLE1BQU0sQ0FBQ2toSSxpQkFBaUIsSUFBSWx4RixNQUFNMmhGLE1BQU0sQ0FBQ3NQLFFBQVE7d0JBQ3pEO3dCQUNBdEIsV0FBVzN2RixDQUFBQTs0QkFDVCxNQUFNLEVBQ0oydkYsU0FBUyxFQUNWLEdBQUczdkYsTUFBTTJoRixNQUFNOzRCQUNoQixNQUFNLEVBQ0ozeEgsTUFBTSxFQUNQLEdBQUdnd0M7NEJBQ0osSUFBSTJ2RixjQUFjLEdBQUc7Z0NBQ25CMy9ILE9BQU9xd0MsZUFBZSxDQUFDO2dDQUN2Qjs0QkFDRjs0QkFDQXJ3QyxPQUFPbXdDLFlBQVksQ0FBQyxhQUFhd3ZGOzRCQUNqQyxJQUFJbC9ILFFBQVF3OUgsWUFBWThCLFNBQVM7NEJBQ2pDLElBQUksQ0FBQ3QvSCxTQUFTQSxNQUFNakIsTUFBTSxJQUFJbWdJLFdBQVc7Z0NBQ3ZDOzRCQUNGOzRCQUNBbC9ILFFBQVFBLE1BQU1zQixLQUFLLENBQUMsR0FBRzQ5SDs0QkFDdkIzL0gsT0FBT1MsS0FBSyxHQUFHdzlILFlBQVk4QixTQUFTLEdBQUd0L0g7NEJBQ3ZDbXZDLFFBQVFLLFFBQVEsQ0FBQzk3QixJQUFJO2dDQUNuQjFUOzRCQUNGOzRCQUNBLElBQUksQ0FBQ213QyxXQUFXLENBQUN5YixRQUFRLEVBQUUyRSxTQUFTLDBCQUEwQjtnQ0FDNUQvdEQsUUFBUSxJQUFJO2dDQUNaMHVILFFBQVE7b0NBQ054OUc7b0NBQ0E3UixNQUFNO29DQUNON0I7b0NBQ0EwZ0ksWUFBWTtvQ0FDWmxCLFdBQVc7b0NBQ1htQixVQUFVcGhJLE9BQU9xaEksY0FBYztvQ0FDL0JDLFFBQVF0aEksT0FBT3VoSSxZQUFZO2dDQUM3Qjs0QkFDRjt3QkFDRjtvQkFDRjtvQkFDQSxJQUFJLENBQUNsSSx5QkFBeUIsQ0FBQ0MsU0FBU0M7Z0JBQzFDO2dCQUNBNXBGLFFBQVFoQixnQkFBZ0IsQ0FBQyxXQUFXcUIsQ0FBQUE7b0JBQ2xDaXVGLFlBQVlnQyxTQUFTLEdBQUc7b0JBQ3hCLElBQUlBLFlBQVksQ0FBQztvQkFDakIsSUFBSWp3RixNQUFNcGxDLEdBQUcsS0FBSyxVQUFVO3dCQUMxQnExSCxZQUFZO29CQUNkLE9BQU8sSUFBSWp3RixNQUFNcGxDLEdBQUcsS0FBSyxXQUFXLENBQUMsSUFBSSxDQUFDbUYsSUFBSSxDQUFDa3ZILFNBQVMsRUFBRTt3QkFDeERnQixZQUFZO29CQUNkLE9BQU8sSUFBSWp3RixNQUFNcGxDLEdBQUcsS0FBSyxPQUFPO3dCQUM5QnF6SCxZQUFZZ0MsU0FBUyxHQUFHO29CQUMxQjtvQkFDQSxJQUFJQSxjQUFjLENBQUMsR0FBRzt3QkFDcEI7b0JBQ0Y7b0JBQ0EsTUFBTSxFQUNKeC9ILEtBQUssRUFDTixHQUFHdXZDLE1BQU1od0MsTUFBTTtvQkFDaEIsSUFBSWkrSCxZQUFZK0Isa0JBQWtCLEtBQUt2L0gsT0FBTzt3QkFDNUM7b0JBQ0Y7b0JBQ0F3OUgsWUFBWStCLGtCQUFrQixHQUFHdi9IO29CQUNqQ3c5SCxZQUFZOEIsU0FBUyxHQUFHdC9IO29CQUN4QixJQUFJLENBQUNtd0MsV0FBVyxDQUFDeWIsUUFBUSxFQUFFMkUsU0FBUywwQkFBMEI7d0JBQzVEL3RELFFBQVEsSUFBSTt3QkFDWjB1SCxRQUFROzRCQUNOeDlHOzRCQUNBN1IsTUFBTTs0QkFDTjdCOzRCQUNBMGdJLFlBQVk7NEJBQ1psQjs0QkFDQW1CLFVBQVVweEYsTUFBTWh3QyxNQUFNLENBQUNxaEksY0FBYzs0QkFDckNDLFFBQVF0eEYsTUFBTWh3QyxNQUFNLENBQUN1aEksWUFBWTt3QkFDbkM7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsTUFBTUMsZ0JBQWdCYjtnQkFDdEJBLGVBQWU7Z0JBQ2ZoeEYsUUFBUWhCLGdCQUFnQixDQUFDLFFBQVFxQixDQUFBQTtvQkFDL0IsSUFBSSxDQUFDaXVGLFlBQVlLLE9BQU8sSUFBSSxDQUFDdHVGLE1BQU1pNUIsYUFBYSxFQUFFO3dCQUNoRDtvQkFDRjtvQkFDQSxJQUFJLENBQUMsSUFBSSxDQUFDbDVELElBQUksQ0FBQ3VwSCxPQUFPLEVBQUVrRixNQUFNO3dCQUM1QlAsWUFBWUssT0FBTyxHQUFHO29CQUN4QjtvQkFDQSxNQUFNLEVBQ0p0K0gsTUFBTSxFQUNQLEdBQUdnd0M7b0JBQ0osSUFBSSxFQUNGdnZDLEtBQUssRUFDTixHQUFHVDtvQkFDSixJQUFJeWdJLGVBQWU7d0JBQ2pCLElBQUloZ0ksU0FBUzgvSCxpQkFBaUIsUUFBUTs0QkFDcEMsTUFBTTVxQixRQUFRbDFHLE1BQU0yQixLQUFLLENBQUMsS0FBS2lJLEdBQUcsQ0FBQ3VQLENBQUFBLElBQUsxTyxTQUFTME8sR0FBRzs0QkFDcERuWixRQUFRLElBQUl1ckMsS0FBSyxNQUFNLEdBQUcsR0FBRzJwRSxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxJQUFJLEdBQUd0K0YsT0FBTzs0QkFDdkVyWCxPQUFPeUUsSUFBSSxHQUFHO3dCQUNoQixPQUFPOzRCQUNMLElBQUksQ0FBQ2hFLE1BQU13VSxRQUFRLENBQUMsTUFBTTtnQ0FDeEJ4VSxRQUFRLENBQUMsRUFBRUEsTUFBTSxNQUFNLENBQUM7NEJBQzFCOzRCQUNBQSxRQUFRLElBQUl1ckMsS0FBS3ZyQyxPQUFPNFcsT0FBTzt3QkFDakM7d0JBQ0FyWCxPQUFPbUksSUFBSSxHQUFHO29CQUNoQjtvQkFDQTgxSCxZQUFZOEIsU0FBUyxHQUFHdC9IO29CQUN4QixJQUFJdzlILFlBQVkrQixrQkFBa0IsS0FBS3YvSCxPQUFPO3dCQUM1QyxJQUFJLENBQUNtd0MsV0FBVyxDQUFDeWIsUUFBUSxFQUFFMkUsU0FBUywwQkFBMEI7NEJBQzVEL3RELFFBQVEsSUFBSTs0QkFDWjB1SCxRQUFRO2dDQUNOeDlHO2dDQUNBN1IsTUFBTTtnQ0FDTjdCO2dDQUNBMGdJLFlBQVk7Z0NBQ1psQixXQUFXaEMsWUFBWWdDLFNBQVM7Z0NBQ2hDbUIsVUFBVXB4RixNQUFNaHdDLE1BQU0sQ0FBQ3FoSSxjQUFjO2dDQUNyQ0MsUUFBUXR4RixNQUFNaHdDLE1BQU0sQ0FBQ3VoSSxZQUFZOzRCQUNuQzt3QkFDRjtvQkFDRjtvQkFDQUMsY0FBY3h4RjtnQkFDaEI7Z0JBQ0EsSUFBSSxJQUFJLENBQUNqZ0MsSUFBSSxDQUFDdXBILE9BQU8sRUFBRW1JLFdBQVc7b0JBQ2hDOXhGLFFBQVFoQixnQkFBZ0IsQ0FBQyxlQUFlcUIsQ0FBQUE7d0JBQ3RDaXVGLFlBQVkrQixrQkFBa0IsR0FBRzt3QkFDakMsTUFBTSxFQUNKandILElBQUksRUFDSi9QLE1BQU0sRUFDUCxHQUFHZ3dDO3dCQUNKLE1BQU0sRUFDSnZ2QyxLQUFLLEVBQ0w0Z0ksY0FBYyxFQUNkRSxZQUFZLEVBQ2IsR0FBR3ZoSTt3QkFDSixJQUFJb2hJLFdBQVdDLGdCQUNiQyxTQUFTQzt3QkFDWCxPQUFRdnhGLE1BQU0weEYsU0FBUzs0QkFDckIsS0FBSztnQ0FDSDtvQ0FDRSxNQUFNbnlHLFFBQVE5dUIsTUFBTW0xQyxTQUFTLENBQUMsR0FBR3lyRixnQkFBZ0I5eEcsS0FBSyxDQUFDO29DQUN2RCxJQUFJQSxPQUFPO3dDQUNUNnhHLFlBQVk3eEcsS0FBSyxDQUFDLEVBQUUsQ0FBQy92QixNQUFNO29DQUM3QjtvQ0FDQTtnQ0FDRjs0QkFDRixLQUFLO2dDQUNIO29DQUNFLE1BQU0rdkIsUUFBUTl1QixNQUFNbTFDLFNBQVMsQ0FBQ3lyRixnQkFBZ0I5eEcsS0FBSyxDQUFDO29DQUNwRCxJQUFJQSxPQUFPO3dDQUNUK3hHLFVBQVUveEcsS0FBSyxDQUFDLEVBQUUsQ0FBQy92QixNQUFNO29DQUMzQjtvQ0FDQTtnQ0FDRjs0QkFDRixLQUFLO2dDQUNILElBQUk2aEksbUJBQW1CRSxjQUFjO29DQUNuQ0gsWUFBWTtnQ0FDZDtnQ0FDQTs0QkFDRixLQUFLO2dDQUNILElBQUlDLG1CQUFtQkUsY0FBYztvQ0FDbkNELFVBQVU7Z0NBQ1o7Z0NBQ0E7d0JBQ0o7d0JBQ0F0eEYsTUFBTW1ILGNBQWM7d0JBQ3BCLElBQUksQ0FBQ3ZHLFdBQVcsQ0FBQ3liLFFBQVEsRUFBRTJFLFNBQVMsMEJBQTBCOzRCQUM1RC90RCxRQUFRLElBQUk7NEJBQ1owdUgsUUFBUTtnQ0FDTng5RztnQ0FDQTdSLE1BQU07Z0NBQ043QjtnQ0FDQWtoSSxRQUFRNXhILFFBQVE7Z0NBQ2hCb3hILFlBQVk7Z0NBQ1pDO2dDQUNBRTs0QkFDRjt3QkFDRjtvQkFDRjtnQkFDRjtnQkFDQSxJQUFJLENBQUMvQyxrQkFBa0IsQ0FBQzV1RixTQUFTc3VGLGFBQWE7b0JBQUM7d0JBQUM7d0JBQVM7cUJBQVE7b0JBQUU7d0JBQUM7d0JBQVE7cUJBQU87b0JBQUU7d0JBQUM7d0JBQWE7cUJBQWE7b0JBQUU7d0JBQUM7d0JBQWM7cUJBQWM7b0JBQUU7d0JBQUM7d0JBQWM7cUJBQWE7b0JBQUU7d0JBQUM7d0JBQVc7cUJBQVc7aUJBQUMsRUFBRWp1RixDQUFBQSxRQUFTQSxNQUFNaHdDLE1BQU0sQ0FBQ1MsS0FBSztZQUN0TztZQUNBLElBQUlrZ0ksY0FBYztnQkFDaEJoeEYsUUFBUWhCLGdCQUFnQixDQUFDLFFBQVFneUY7WUFDbkM7WUFDQSxJQUFJLElBQUksQ0FBQzV3SCxJQUFJLENBQUMrdkgsSUFBSSxFQUFFO2dCQUNsQixNQUFNOEIsYUFBYSxJQUFJLENBQUM3eEgsSUFBSSxDQUFDdTNCLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDdjNCLElBQUksQ0FBQ3UzQixJQUFJLENBQUMsRUFBRTtnQkFDeEQsTUFBTXU2RixZQUFZRCxhQUFhbEM7Z0JBQy9CL3ZGLFFBQVE4TCxTQUFTLENBQUNwbUMsR0FBRyxDQUFDO2dCQUN0QnM2QixRQUFRemlDLEtBQUssQ0FBQzQwSCxhQUFhLEdBQUcsQ0FBQyxLQUFLLEVBQUVELFVBQVUscUNBQXFDLENBQUM7WUFDeEY7UUFDRixPQUFPO1lBQ0xseUYsVUFBVXBpQyxTQUFTMkksYUFBYSxDQUFDO1lBQ2pDeTVCLFFBQVFWLFdBQVcsR0FBRyxJQUFJLENBQUNsL0IsSUFBSSxDQUFDd3ZILFVBQVU7WUFDMUM1dkYsUUFBUXppQyxLQUFLLENBQUM2MEgsYUFBYSxHQUFHO1lBQzlCcHlGLFFBQVF6aUMsS0FBSyxDQUFDQyxPQUFPLEdBQUc7WUFDeEIsSUFBSSxJQUFJLENBQUM0QyxJQUFJLENBQUNpNkYsWUFBWSxFQUFFO2dCQUMxQnI2RCxRQUFRMEMsTUFBTSxHQUFHO1lBQ25CO1FBQ0Y7UUFDQSxJQUFJLENBQUNzc0YsYUFBYSxDQUFDaHZGO1FBQ25CLElBQUksQ0FBQyt1RixtQkFBbUIsQ0FBQy91RjtRQUN6QixJQUFJLENBQUM4cEYsMkJBQTJCLENBQUM5cEY7UUFDakMsSUFBSSxDQUFDNE4sU0FBUyxDQUFDamtDLE1BQU0sQ0FBQ3EyQjtRQUN0QixPQUFPLElBQUksQ0FBQzROLFNBQVM7SUFDdkI7QUFDRjtBQUNBLE1BQU1rM0UseUNBQXlDQztJQUM3Qzl4SCxZQUFZd3VDLFVBQVUsQ0FBRTtRQUN0QixLQUFLLENBQUNBLFlBQVk7WUFDaEIwa0YsY0FBYyxDQUFDLENBQUMxa0YsV0FBV3JoQyxJQUFJLENBQUNpNkYsWUFBWTtRQUM5QztJQUNGO0FBQ0Y7QUFDQSxNQUFNc3FCLHdDQUF3Q0k7SUFDNUM5eEgsWUFBWXd1QyxVQUFVLENBQUU7UUFDdEIsS0FBSyxDQUFDQSxZQUFZO1lBQ2hCMGtGLGNBQWMxa0YsV0FBVytrRixXQUFXO1FBQ3RDO0lBQ0Y7SUFDQWhsRixTQUFTO1FBQ1AsTUFBTXZCLFVBQVUsSUFBSSxDQUFDeUIsaUJBQWlCO1FBQ3RDLE1BQU10aEMsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTW9FLEtBQUtwRSxLQUFLb0UsRUFBRTtRQUNsQixJQUFJMVQsUUFBUW12QyxRQUFRRyxRQUFRLENBQUM1N0IsSUFBSTtZQUMvQjFULE9BQU9zUCxLQUFLK3FILFdBQVcsS0FBSy9xSCxLQUFLd3ZILFVBQVU7UUFDN0MsR0FBRzkrSCxLQUFLO1FBQ1IsSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDN0JBLFFBQVFBLFVBQVU7WUFDbEJtdkMsUUFBUUssUUFBUSxDQUFDOTdCLElBQUk7Z0JBQ25CMVQ7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDODhDLFNBQVMsQ0FBQzlCLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUMsMEJBQTBCO1FBQ3ZELE1BQU1zNkIsVUFBVXBpQyxTQUFTMkksYUFBYSxDQUFDO1FBQ3ZDeTlHLHFCQUFxQnQrRyxHQUFHLENBQUNzNkI7UUFDekJBLFFBQVFRLFlBQVksQ0FBQyxtQkFBbUJoOEI7UUFDeEN3N0IsUUFBUTB2QixRQUFRLEdBQUd0dkQsS0FBS3N3SCxRQUFRO1FBQ2hDLElBQUksQ0FBQ2xILFlBQVksQ0FBQ3hwRixTQUFTLElBQUksQ0FBQzUvQixJQUFJLENBQUNnQixRQUFRO1FBQzdDNCtCLFFBQVF4bkMsSUFBSSxHQUFHO1FBQ2Z3bkMsUUFBUXJ0QyxJQUFJLEdBQUd5TixLQUFLMHRILFNBQVM7UUFDN0IsSUFBSWg5SCxPQUFPO1lBQ1RrdkMsUUFBUVEsWUFBWSxDQUFDLFdBQVc7UUFDbEM7UUFDQVIsUUFBUVEsWUFBWSxDQUFDLGVBQWVwZ0MsS0FBSytxSCxXQUFXO1FBQ3BEbnJGLFFBQVFvUixRQUFRLEdBQUc7UUFDbkJwUixRQUFRaEIsZ0JBQWdCLENBQUMsVUFBVXFCLENBQUFBO1lBQ2pDLE1BQU0sRUFDSjF0QyxJQUFJLEVBQ0pndUMsT0FBTyxFQUNSLEdBQUdOLE1BQU1od0MsTUFBTTtZQUNoQixLQUFLLE1BQU1naUksWUFBWSxJQUFJLENBQUN2SCxrQkFBa0IsQ0FBQ240SCxNQUFNNlIsSUFBSztnQkFDeEQsTUFBTTh0SCxhQUFhM3hGLFdBQVcweEYsU0FBU2xILFdBQVcsS0FBSy9xSCxLQUFLK3FILFdBQVc7Z0JBQ3ZFLElBQUlrSCxTQUFTakgsVUFBVSxFQUFFO29CQUN2QmlILFNBQVNqSCxVQUFVLENBQUN6cUYsT0FBTyxHQUFHMnhGO2dCQUNoQztnQkFDQXJ5RixRQUFRSyxRQUFRLENBQUMreEYsU0FBUzd0SCxFQUFFLEVBQUU7b0JBQzVCMVQsT0FBT3doSTtnQkFDVDtZQUNGO1lBQ0FyeUYsUUFBUUssUUFBUSxDQUFDOTdCLElBQUk7Z0JBQ25CMVQsT0FBTzZ2QztZQUNUO1FBQ0Y7UUFDQVgsUUFBUWhCLGdCQUFnQixDQUFDLGFBQWFxQixDQUFBQTtZQUNwQyxNQUFNNmxDLGVBQWU5bEUsS0FBSzJ3SCxpQkFBaUIsSUFBSTtZQUMvQzF3RixNQUFNaHdDLE1BQU0sQ0FBQ3N3QyxPQUFPLEdBQUd1bEMsaUJBQWlCOWxFLEtBQUsrcUgsV0FBVztRQUMxRDtRQUNBLElBQUksSUFBSSxDQUFDeEUsZUFBZSxJQUFJLElBQUksQ0FBQ3hRLFlBQVksRUFBRTtZQUM3Q24yRSxRQUFRaEIsZ0JBQWdCLENBQUMscUJBQXFCNHFGLENBQUFBO2dCQUM1QyxNQUFNRCxVQUFVO29CQUNkNzRILE9BQU11dkMsS0FBSzt3QkFDVEEsTUFBTWh3QyxNQUFNLENBQUNzd0MsT0FBTyxHQUFHTixNQUFNMmhGLE1BQU0sQ0FBQ2x4SCxLQUFLLEtBQUs7d0JBQzlDbXZDLFFBQVFLLFFBQVEsQ0FBQzk3QixJQUFJOzRCQUNuQjFULE9BQU91dkMsTUFBTWh3QyxNQUFNLENBQUNzd0MsT0FBTzt3QkFDN0I7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDK29GLHlCQUF5QixDQUFDQyxTQUFTQztZQUMxQztZQUNBLElBQUksQ0FBQ2dGLGtCQUFrQixDQUFDNXVGLFNBQVMsTUFBTTtnQkFBQztvQkFBQztvQkFBVTtpQkFBVztnQkFBRTtvQkFBQztvQkFBVTtpQkFBUztnQkFBRTtvQkFBQztvQkFBUztpQkFBUTtnQkFBRTtvQkFBQztvQkFBUTtpQkFBTztnQkFBRTtvQkFBQztvQkFBYTtpQkFBYTtnQkFBRTtvQkFBQztvQkFBYztpQkFBYztnQkFBRTtvQkFBQztvQkFBYztpQkFBYTtnQkFBRTtvQkFBQztvQkFBVztpQkFBVzthQUFDLEVBQUVLLENBQUFBLFFBQVNBLE1BQU1od0MsTUFBTSxDQUFDc3dDLE9BQU87UUFDL1E7UUFDQSxJQUFJLENBQUNvdUYsbUJBQW1CLENBQUMvdUY7UUFDekIsSUFBSSxDQUFDOHBGLDJCQUEyQixDQUFDOXBGO1FBQ2pDLElBQUksQ0FBQzROLFNBQVMsQ0FBQ2prQyxNQUFNLENBQUNxMkI7UUFDdEIsT0FBTyxJQUFJLENBQUM0TixTQUFTO0lBQ3ZCO0FBQ0Y7QUFDQSxNQUFNNjJFLDJDQUEyQ007SUFDL0M5eEgsWUFBWXd1QyxVQUFVLENBQUU7UUFDdEIsS0FBSyxDQUFDQSxZQUFZO1lBQ2hCMGtGLGNBQWMxa0YsV0FBVytrRixXQUFXO1FBQ3RDO0lBQ0Y7SUFDQWhsRixTQUFTO1FBQ1AsSUFBSSxDQUFDb00sU0FBUyxDQUFDOUIsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQywwQkFBMEI7UUFDdkQsTUFBTXU2QixVQUFVLElBQUksQ0FBQ3lCLGlCQUFpQjtRQUN0QyxNQUFNdGhDLE9BQU8sSUFBSSxDQUFDQSxJQUFJO1FBQ3RCLE1BQU1vRSxLQUFLcEUsS0FBS29FLEVBQUU7UUFDbEIsSUFBSTFULFFBQVFtdkMsUUFBUUcsUUFBUSxDQUFDNTdCLElBQUk7WUFDL0IxVCxPQUFPc1AsS0FBS3d2SCxVQUFVLEtBQUt4dkgsS0FBS215SCxXQUFXO1FBQzdDLEdBQUd6aEksS0FBSztRQUNSLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCQSxRQUFRQSxVQUFVc1AsS0FBS215SCxXQUFXO1lBQ2xDdHlGLFFBQVFLLFFBQVEsQ0FBQzk3QixJQUFJO2dCQUNuQjFUO1lBQ0Y7UUFDRjtRQUNBLElBQUlBLE9BQU87WUFDVCxLQUFLLE1BQU0waEksU0FBUyxJQUFJLENBQUMxSCxrQkFBa0IsQ0FBQzFxSCxLQUFLMHRILFNBQVMsRUFBRXRwSCxJQUFLO2dCQUMvRHk3QixRQUFRSyxRQUFRLENBQUNreUYsTUFBTWh1SCxFQUFFLEVBQUU7b0JBQ3pCMVQsT0FBTztnQkFDVDtZQUNGO1FBQ0Y7UUFDQSxNQUFNa3ZDLFVBQVVwaUMsU0FBUzJJLGFBQWEsQ0FBQztRQUN2Q3k5RyxxQkFBcUJ0K0csR0FBRyxDQUFDczZCO1FBQ3pCQSxRQUFRUSxZQUFZLENBQUMsbUJBQW1CaDhCO1FBQ3hDdzdCLFFBQVEwdkIsUUFBUSxHQUFHdHZELEtBQUtzd0gsUUFBUTtRQUNoQyxJQUFJLENBQUNsSCxZQUFZLENBQUN4cEYsU0FBUyxJQUFJLENBQUM1L0IsSUFBSSxDQUFDZ0IsUUFBUTtRQUM3QzQrQixRQUFReG5DLElBQUksR0FBRztRQUNmd25DLFFBQVFydEMsSUFBSSxHQUFHeU4sS0FBSzB0SCxTQUFTO1FBQzdCLElBQUloOUgsT0FBTztZQUNUa3ZDLFFBQVFRLFlBQVksQ0FBQyxXQUFXO1FBQ2xDO1FBQ0FSLFFBQVFvUixRQUFRLEdBQUc7UUFDbkJwUixRQUFRaEIsZ0JBQWdCLENBQUMsVUFBVXFCLENBQUFBO1lBQ2pDLE1BQU0sRUFDSjF0QyxJQUFJLEVBQ0pndUMsT0FBTyxFQUNSLEdBQUdOLE1BQU1od0MsTUFBTTtZQUNoQixLQUFLLE1BQU1taUksU0FBUyxJQUFJLENBQUMxSCxrQkFBa0IsQ0FBQ240SCxNQUFNNlIsSUFBSztnQkFDckR5N0IsUUFBUUssUUFBUSxDQUFDa3lGLE1BQU1odUgsRUFBRSxFQUFFO29CQUN6QjFULE9BQU87Z0JBQ1Q7WUFDRjtZQUNBbXZDLFFBQVFLLFFBQVEsQ0FBQzk3QixJQUFJO2dCQUNuQjFULE9BQU82dkM7WUFDVDtRQUNGO1FBQ0FYLFFBQVFoQixnQkFBZ0IsQ0FBQyxhQUFhcUIsQ0FBQUE7WUFDcEMsTUFBTTZsQyxlQUFlOWxFLEtBQUsyd0gsaUJBQWlCO1lBQzNDMXdGLE1BQU1od0MsTUFBTSxDQUFDc3dDLE9BQU8sR0FBR3VsQyxpQkFBaUIsUUFBUUEsaUJBQWlCOXlFLGFBQWE4eUUsaUJBQWlCOWxFLEtBQUtteUgsV0FBVztRQUNqSDtRQUNBLElBQUksSUFBSSxDQUFDNUwsZUFBZSxJQUFJLElBQUksQ0FBQ3hRLFlBQVksRUFBRTtZQUM3QyxNQUFNc2MsaUJBQWlCcnlILEtBQUtteUgsV0FBVztZQUN2Q3Z5RixRQUFRaEIsZ0JBQWdCLENBQUMscUJBQXFCNHFGLENBQUFBO2dCQUM1QyxNQUFNRCxVQUFVO29CQUNkNzRILE9BQU91dkMsQ0FBQUE7d0JBQ0wsTUFBTU0sVUFBVTh4RixtQkFBbUJweUYsTUFBTTJoRixNQUFNLENBQUNseEgsS0FBSzt3QkFDckQsS0FBSyxNQUFNMGhJLFNBQVMsSUFBSSxDQUFDMUgsa0JBQWtCLENBQUN6cUYsTUFBTWh3QyxNQUFNLENBQUNzQyxJQUFJLEVBQUc7NEJBQzlELE1BQU0yL0gsYUFBYTN4RixXQUFXNnhGLE1BQU1odUgsRUFBRSxLQUFLQTs0QkFDM0MsSUFBSWd1SCxNQUFNcEgsVUFBVSxFQUFFO2dDQUNwQm9ILE1BQU1wSCxVQUFVLENBQUN6cUYsT0FBTyxHQUFHMnhGOzRCQUM3Qjs0QkFDQXJ5RixRQUFRSyxRQUFRLENBQUNreUYsTUFBTWh1SCxFQUFFLEVBQUU7Z0NBQ3pCMVQsT0FBT3doSTs0QkFDVDt3QkFDRjtvQkFDRjtnQkFDRjtnQkFDQSxJQUFJLENBQUM1SSx5QkFBeUIsQ0FBQ0MsU0FBU0M7WUFDMUM7WUFDQSxJQUFJLENBQUNnRixrQkFBa0IsQ0FBQzV1RixTQUFTLE1BQU07Z0JBQUM7b0JBQUM7b0JBQVU7aUJBQVc7Z0JBQUU7b0JBQUM7b0JBQVU7aUJBQVM7Z0JBQUU7b0JBQUM7b0JBQVM7aUJBQVE7Z0JBQUU7b0JBQUM7b0JBQVE7aUJBQU87Z0JBQUU7b0JBQUM7b0JBQWE7aUJBQWE7Z0JBQUU7b0JBQUM7b0JBQWM7aUJBQWM7Z0JBQUU7b0JBQUM7b0JBQWM7aUJBQWE7Z0JBQUU7b0JBQUM7b0JBQVc7aUJBQVc7YUFBQyxFQUFFSyxDQUFBQSxRQUFTQSxNQUFNaHdDLE1BQU0sQ0FBQ3N3QyxPQUFPO1FBQy9RO1FBQ0EsSUFBSSxDQUFDb3VGLG1CQUFtQixDQUFDL3VGO1FBQ3pCLElBQUksQ0FBQzhwRiwyQkFBMkIsQ0FBQzlwRjtRQUNqQyxJQUFJLENBQUM0TixTQUFTLENBQUNqa0MsTUFBTSxDQUFDcTJCO1FBQ3RCLE9BQU8sSUFBSSxDQUFDNE4sU0FBUztJQUN2QjtBQUNGO0FBQ0EsTUFBTWczRSwwQ0FBMENSO0lBQzlDbnhILFlBQVl3dUMsVUFBVSxDQUFFO1FBQ3RCLEtBQUssQ0FBQ0EsWUFBWTtZQUNoQjJrRixjQUFjM2tGLFdBQVdyaEMsSUFBSSxDQUFDdXZILGFBQWE7UUFDN0M7SUFDRjtJQUNBbnVGLFNBQVM7UUFDUCxNQUFNb00sWUFBWSxLQUFLLENBQUNwTTtRQUN4Qm9NLFVBQVU5QixTQUFTLENBQUNwbUMsR0FBRyxDQUFDLDBCQUEwQjtRQUNsRCxNQUFNZ3RILGNBQWM5a0YsVUFBVTQxQixTQUFTO1FBQ3ZDLElBQUksSUFBSSxDQUFDbWpELGVBQWUsSUFBSSxJQUFJLENBQUN4USxZQUFZLElBQUl1YyxhQUFhO1lBQzVELElBQUksQ0FBQzVJLDJCQUEyQixDQUFDNEk7WUFDakNBLFlBQVkxekYsZ0JBQWdCLENBQUMscUJBQXFCNHFGLENBQUFBO2dCQUNoRCxJQUFJLENBQUNGLHlCQUF5QixDQUFDLENBQUMsR0FBR0U7WUFDckM7UUFDRjtRQUNBLE9BQU9oOEU7SUFDVDtBQUNGO0FBQ0EsTUFBTWkzRSxzQ0FBc0NFO0lBQzFDOXhILFlBQVl3dUMsVUFBVSxDQUFFO1FBQ3RCLEtBQUssQ0FBQ0EsWUFBWTtZQUNoQjBrRixjQUFjMWtGLFdBQVcra0YsV0FBVztRQUN0QztJQUNGO0lBQ0FobEYsU0FBUztRQUNQLElBQUksQ0FBQ29NLFNBQVMsQ0FBQzlCLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7UUFDN0IsTUFBTXU2QixVQUFVLElBQUksQ0FBQ3lCLGlCQUFpQjtRQUN0QyxNQUFNbDlCLEtBQUssSUFBSSxDQUFDcEUsSUFBSSxDQUFDb0UsRUFBRTtRQUN2QixNQUFNMjdCLGFBQWFGLFFBQVFHLFFBQVEsQ0FBQzU3QixJQUFJO1lBQ3RDMVQsT0FBTyxJQUFJLENBQUNzUCxJQUFJLENBQUN3dkgsVUFBVTtRQUM3QjtRQUNBLE1BQU0rQyxnQkFBZ0IvMEgsU0FBUzJJLGFBQWEsQ0FBQztRQUM3Q3k5RyxxQkFBcUJ0K0csR0FBRyxDQUFDaXRIO1FBQ3pCQSxjQUFjbnlGLFlBQVksQ0FBQyxtQkFBbUJoOEI7UUFDOUNtdUgsY0FBY2pqRSxRQUFRLEdBQUcsSUFBSSxDQUFDdHZELElBQUksQ0FBQ3N3SCxRQUFRO1FBQzNDLElBQUksQ0FBQ2xILFlBQVksQ0FBQ21KLGVBQWUsSUFBSSxDQUFDdnlILElBQUksQ0FBQ2dCLFFBQVE7UUFDbkR1eEgsY0FBY2hnSSxJQUFJLEdBQUcsSUFBSSxDQUFDeU4sSUFBSSxDQUFDMHRILFNBQVM7UUFDeEM2RSxjQUFjdmhGLFFBQVEsR0FBRztRQUN6QixJQUFJd2hGLGtCQUFrQixJQUFJLENBQUN4eUgsSUFBSSxDQUFDeXlILEtBQUssSUFBSSxJQUFJLENBQUN6eUgsSUFBSSxDQUFDeE4sT0FBTyxDQUFDL0MsTUFBTSxHQUFHO1FBQ3BFLElBQUksQ0FBQyxJQUFJLENBQUN1USxJQUFJLENBQUN5eUgsS0FBSyxFQUFFO1lBQ3BCRixjQUFjOXRILElBQUksR0FBRyxJQUFJLENBQUN6RSxJQUFJLENBQUN4TixPQUFPLENBQUMvQyxNQUFNO1lBQzdDLElBQUksSUFBSSxDQUFDdVEsSUFBSSxDQUFDMHlILFdBQVcsRUFBRTtnQkFDekJILGNBQWNJLFFBQVEsR0FBRztZQUMzQjtRQUNGO1FBQ0FKLGNBQWMzekYsZ0JBQWdCLENBQUMsYUFBYXFCLENBQUFBO1lBQzFDLE1BQU02bEMsZUFBZSxJQUFJLENBQUM5bEUsSUFBSSxDQUFDMndILGlCQUFpQjtZQUNoRCxLQUFLLE1BQU1sd0YsVUFBVTh4RixjQUFjLy9ILE9BQU8sQ0FBRTtnQkFDMUNpdUMsT0FBT0MsUUFBUSxHQUFHRCxPQUFPL3ZDLEtBQUssS0FBS28xRTtZQUNyQztRQUNGO1FBQ0EsS0FBSyxNQUFNcmxDLFVBQVUsSUFBSSxDQUFDemdDLElBQUksQ0FBQ3hOLE9BQU8sQ0FBRTtZQUN0QyxNQUFNb2dJLGdCQUFnQnAxSCxTQUFTMkksYUFBYSxDQUFDO1lBQzdDeXNILGNBQWMxekYsV0FBVyxHQUFHdUIsT0FBT295RixZQUFZO1lBQy9DRCxjQUFjbGlJLEtBQUssR0FBRyt2QyxPQUFPc3FGLFdBQVc7WUFDeEMsSUFBSWhyRixXQUFXcnZDLEtBQUssQ0FBQ3dVLFFBQVEsQ0FBQ3U3QixPQUFPc3FGLFdBQVcsR0FBRztnQkFDakQ2SCxjQUFjeHlGLFlBQVksQ0FBQyxZQUFZO2dCQUN2Q295RixrQkFBa0I7WUFDcEI7WUFDQUQsY0FBY2hwSCxNQUFNLENBQUNxcEg7UUFDdkI7UUFDQSxJQUFJRSxtQkFBbUI7UUFDdkIsSUFBSU4saUJBQWlCO1lBQ25CLE1BQU1PLG9CQUFvQnYxSCxTQUFTMkksYUFBYSxDQUFDO1lBQ2pENHNILGtCQUFrQnJpSSxLQUFLLEdBQUc7WUFDMUJxaUksa0JBQWtCM3lGLFlBQVksQ0FBQyxVQUFVO1lBQ3pDMnlGLGtCQUFrQjN5RixZQUFZLENBQUMsWUFBWTtZQUMzQ215RixjQUFjcjNELE9BQU8sQ0FBQzYzRDtZQUN0QkQsbUJBQW1CO2dCQUNqQkMsa0JBQWtCbHVILE1BQU07Z0JBQ3hCMHRILGNBQWN0a0QsbUJBQW1CLENBQUMsU0FBUzZrRDtnQkFDM0NBLG1CQUFtQjtZQUNyQjtZQUNBUCxjQUFjM3pGLGdCQUFnQixDQUFDLFNBQVNrMEY7UUFDMUM7UUFDQSxNQUFNOXlGLFdBQVdnekYsQ0FBQUE7WUFDZixNQUFNemdJLE9BQU95Z0ksV0FBVyxVQUFVO1lBQ2xDLE1BQU0sRUFDSnhnSSxPQUFPLEVBQ1BtZ0ksUUFBUSxFQUNULEdBQUdKO1lBQ0osSUFBSSxDQUFDSSxVQUFVO2dCQUNiLE9BQU9uZ0ksUUFBUW11QyxhQUFhLEtBQUssQ0FBQyxJQUFJLE9BQU9udUMsT0FBTyxDQUFDQSxRQUFRbXVDLGFBQWEsQ0FBQyxDQUFDcHVDLEtBQUs7WUFDbkY7WUFDQSxPQUFPaVAsTUFBTXpPLFNBQVMsQ0FBQ29MLE1BQU0sQ0FBQ3JQLElBQUksQ0FBQzBELFNBQVNpdUMsQ0FBQUEsU0FBVUEsT0FBT0MsUUFBUSxFQUFFcG1DLEdBQUcsQ0FBQ21tQyxDQUFBQSxTQUFVQSxNQUFNLENBQUNsdUMsS0FBSztRQUNuRztRQUNBLElBQUkwZ0ksaUJBQWlCanpGLFNBQVM7UUFDOUIsTUFBTWt6RixXQUFXanpGLENBQUFBO1lBQ2YsTUFBTXp0QyxVQUFVeXRDLE1BQU1od0MsTUFBTSxDQUFDdUMsT0FBTztZQUNwQyxPQUFPZ1AsTUFBTXpPLFNBQVMsQ0FBQ3VILEdBQUcsQ0FBQ3hMLElBQUksQ0FBQzBELFNBQVNpdUMsQ0FBQUEsU0FBVztvQkFDbERveUYsY0FBY3B5RixPQUFPdkIsV0FBVztvQkFDaEM2ckYsYUFBYXRxRixPQUFPL3ZDLEtBQUs7Z0JBQzNCO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQzYxSCxlQUFlLElBQUksSUFBSSxDQUFDeFEsWUFBWSxFQUFFO1lBQzdDd2MsY0FBYzN6RixnQkFBZ0IsQ0FBQyxxQkFBcUI0cUYsQ0FBQUE7Z0JBQ2xELE1BQU1ELFVBQVU7b0JBQ2Q3NEgsT0FBTXV2QyxLQUFLO3dCQUNUNnlGO3dCQUNBLE1BQU1waUksUUFBUXV2QyxNQUFNMmhGLE1BQU0sQ0FBQ2x4SCxLQUFLO3dCQUNoQyxNQUFNNmxCLFNBQVMsSUFBSTlPLElBQUlqRyxNQUFNK0YsT0FBTyxDQUFDN1csU0FBU0EsUUFBUTs0QkFBQ0E7eUJBQU07d0JBQzdELEtBQUssTUFBTSt2QyxVQUFVOHhGLGNBQWMvL0gsT0FBTyxDQUFFOzRCQUMxQ2l1QyxPQUFPQyxRQUFRLEdBQUducUIsT0FBT3RlLEdBQUcsQ0FBQ3dvQyxPQUFPL3ZDLEtBQUs7d0JBQzNDO3dCQUNBbXZDLFFBQVFLLFFBQVEsQ0FBQzk3QixJQUFJOzRCQUNuQjFULE9BQU9zdkMsU0FBUzt3QkFDbEI7d0JBQ0FpekYsaUJBQWlCanpGLFNBQVM7b0JBQzVCO29CQUNBbXpGLG1CQUFrQmx6RixLQUFLO3dCQUNyQnN5RixjQUFjSSxRQUFRLEdBQUc7b0JBQzNCO29CQUNBOXRILFFBQU9vN0IsS0FBSzt3QkFDVixNQUFNenRDLFVBQVUrL0gsY0FBYy8vSCxPQUFPO3dCQUNyQyxNQUFNd00sUUFBUWloQyxNQUFNMmhGLE1BQU0sQ0FBQy84RyxNQUFNO3dCQUNqQ3JTLE9BQU8sQ0FBQ3dNLE1BQU0sQ0FBQzBoQyxRQUFRLEdBQUc7d0JBQzFCNnhGLGNBQWMxdEgsTUFBTSxDQUFDN0Y7d0JBQ3JCLElBQUl4TSxRQUFRL0MsTUFBTSxHQUFHLEdBQUc7NEJBQ3RCLE1BQU0yRSxJQUFJb04sTUFBTXpPLFNBQVMsQ0FBQ3FnSSxTQUFTLENBQUN0a0ksSUFBSSxDQUFDMEQsU0FBU2l1QyxDQUFBQSxTQUFVQSxPQUFPQyxRQUFROzRCQUMzRSxJQUFJdHNDLE1BQU0sQ0FBQyxHQUFHO2dDQUNaNUIsT0FBTyxDQUFDLEVBQUUsQ0FBQ2t1QyxRQUFRLEdBQUc7NEJBQ3hCO3dCQUNGO3dCQUNBYixRQUFRSyxRQUFRLENBQUM5N0IsSUFBSTs0QkFDbkIxVCxPQUFPc3ZDLFNBQVM7NEJBQ2hCOThCLE9BQU9nd0gsU0FBU2p6Rjt3QkFDbEI7d0JBQ0FnekYsaUJBQWlCanpGLFNBQVM7b0JBQzVCO29CQUNBL29CLE9BQU1ncEIsS0FBSzt3QkFDVCxNQUFPc3lGLGNBQWM5aUksTUFBTSxLQUFLLEVBQUc7NEJBQ2pDOGlJLGNBQWMxdEgsTUFBTSxDQUFDO3dCQUN2Qjt3QkFDQWc3QixRQUFRSyxRQUFRLENBQUM5N0IsSUFBSTs0QkFDbkIxVCxPQUFPOzRCQUNQd1MsT0FBTyxFQUFFO3dCQUNYO3dCQUNBK3ZILGlCQUFpQmp6RixTQUFTO29CQUM1QjtvQkFDQWlxQyxRQUFPaHFDLEtBQUs7d0JBQ1YsTUFBTSxFQUNKamhDLEtBQUssRUFDTDZ6SCxZQUFZLEVBQ1o5SCxXQUFXLEVBQ1osR0FBRzlxRixNQUFNMmhGLE1BQU0sQ0FBQzMzQyxNQUFNO3dCQUN2QixNQUFNb3BELGNBQWNkLGNBQWMveUYsUUFBUSxDQUFDeGdDLE1BQU07d0JBQ2pELE1BQU00ekgsZ0JBQWdCcDFILFNBQVMySSxhQUFhLENBQUM7d0JBQzdDeXNILGNBQWMxekYsV0FBVyxHQUFHMnpGO3dCQUM1QkQsY0FBY2xpSSxLQUFLLEdBQUdxNkg7d0JBQ3RCLElBQUlzSSxhQUFhOzRCQUNmQSxZQUFZbDFELE1BQU0sQ0FBQ3kwRDt3QkFDckIsT0FBTzs0QkFDTEwsY0FBY2hwSCxNQUFNLENBQUNxcEg7d0JBQ3ZCO3dCQUNBL3lGLFFBQVFLLFFBQVEsQ0FBQzk3QixJQUFJOzRCQUNuQjFULE9BQU9zdkMsU0FBUzs0QkFDaEI5OEIsT0FBT2d3SCxTQUFTanpGO3dCQUNsQjt3QkFDQWd6RixpQkFBaUJqekYsU0FBUztvQkFDNUI7b0JBQ0E5OEIsT0FBTSs4QixLQUFLO3dCQUNULE1BQU0sRUFDSi84QixLQUFLLEVBQ04sR0FBRys4QixNQUFNMmhGLE1BQU07d0JBQ2hCLE1BQU8yUSxjQUFjOWlJLE1BQU0sS0FBSyxFQUFHOzRCQUNqQzhpSSxjQUFjMXRILE1BQU0sQ0FBQzt3QkFDdkI7d0JBQ0EsS0FBSyxNQUFNMkIsUUFBUXRELE1BQU87NEJBQ3hCLE1BQU0sRUFDSjJ2SCxZQUFZLEVBQ1o5SCxXQUFXLEVBQ1osR0FBR3ZrSDs0QkFDSixNQUFNb3NILGdCQUFnQnAxSCxTQUFTMkksYUFBYSxDQUFDOzRCQUM3Q3lzSCxjQUFjMXpGLFdBQVcsR0FBRzJ6Rjs0QkFDNUJELGNBQWNsaUksS0FBSyxHQUFHcTZIOzRCQUN0QndILGNBQWNocEgsTUFBTSxDQUFDcXBIO3dCQUN2Qjt3QkFDQSxJQUFJTCxjQUFjLy9ILE9BQU8sQ0FBQy9DLE1BQU0sR0FBRyxHQUFHOzRCQUNwQzhpSSxjQUFjLy9ILE9BQU8sQ0FBQyxFQUFFLENBQUNrdUMsUUFBUSxHQUFHO3dCQUN0Qzt3QkFDQWIsUUFBUUssUUFBUSxDQUFDOTdCLElBQUk7NEJBQ25CMVQsT0FBT3N2QyxTQUFTOzRCQUNoQjk4QixPQUFPZ3dILFNBQVNqekY7d0JBQ2xCO3dCQUNBZ3pGLGlCQUFpQmp6RixTQUFTO29CQUM1QjtvQkFDQXN6RixTQUFRcnpGLEtBQUs7d0JBQ1gsTUFBTXF6RixVQUFVLElBQUk3ckgsSUFBSXc0QixNQUFNMmhGLE1BQU0sQ0FBQzBSLE9BQU87d0JBQzVDLEtBQUssTUFBTTd5RixVQUFVUixNQUFNaHdDLE1BQU0sQ0FBQ3VDLE9BQU8sQ0FBRTs0QkFDekNpdUMsT0FBT0MsUUFBUSxHQUFHNHlGLFFBQVFyN0gsR0FBRyxDQUFDd29DLE9BQU96aEMsS0FBSzt3QkFDNUM7d0JBQ0E2Z0MsUUFBUUssUUFBUSxDQUFDOTdCLElBQUk7NEJBQ25CMVQsT0FBT3N2QyxTQUFTO3dCQUNsQjt3QkFDQWl6RixpQkFBaUJqekYsU0FBUztvQkFDNUI7b0JBQ0F1ekYsVUFBU3R6RixLQUFLO3dCQUNaQSxNQUFNaHdDLE1BQU0sQ0FBQ3EvRCxRQUFRLEdBQUcsQ0FBQ3J2QixNQUFNMmhGLE1BQU0sQ0FBQzJSLFFBQVE7b0JBQ2hEO2dCQUNGO2dCQUNBLElBQUksQ0FBQ2pLLHlCQUF5QixDQUFDQyxTQUFTQztZQUMxQztZQUNBK0ksY0FBYzN6RixnQkFBZ0IsQ0FBQyxTQUFTcUIsQ0FBQUE7Z0JBQ3RDLE1BQU04cUYsY0FBYy9xRixTQUFTO2dCQUM3QixNQUFNNHhGLFNBQVM1eEYsU0FBUztnQkFDeEJILFFBQVFLLFFBQVEsQ0FBQzk3QixJQUFJO29CQUNuQjFULE9BQU9xNkg7Z0JBQ1Q7Z0JBQ0E5cUYsTUFBTW1ILGNBQWM7Z0JBQ3BCLElBQUksQ0FBQ3ZHLFdBQVcsQ0FBQ3liLFFBQVEsRUFBRTJFLFNBQVMsMEJBQTBCO29CQUM1RC90RCxRQUFRLElBQUk7b0JBQ1owdUgsUUFBUTt3QkFDTng5Rzt3QkFDQTdSLE1BQU07d0JBQ043QixPQUFPdWlJO3dCQUNQckI7d0JBQ0E0QixVQUFVekk7d0JBQ1ZxRyxZQUFZO3dCQUNabEIsV0FBVzt3QkFDWHJQLFNBQVM7b0JBQ1g7Z0JBQ0Y7WUFDRjtZQUNBLElBQUksQ0FBQzJOLGtCQUFrQixDQUFDK0QsZUFBZSxNQUFNO2dCQUFDO29CQUFDO29CQUFTO2lCQUFRO2dCQUFFO29CQUFDO29CQUFRO2lCQUFPO2dCQUFFO29CQUFDO29CQUFhO2lCQUFhO2dCQUFFO29CQUFDO29CQUFjO2lCQUFjO2dCQUFFO29CQUFDO29CQUFjO2lCQUFhO2dCQUFFO29CQUFDO29CQUFXO2lCQUFXO2dCQUFFO29CQUFDO29CQUFTO2lCQUFTO2dCQUFFO29CQUFDO29CQUFTO2lCQUFXO2FBQUMsRUFBRXR5RixDQUFBQSxRQUFTQSxNQUFNaHdDLE1BQU0sQ0FBQ1MsS0FBSztRQUNqUixPQUFPO1lBQ0w2aEksY0FBYzN6RixnQkFBZ0IsQ0FBQyxTQUFTLFNBQVVxQixLQUFLO2dCQUNyREosUUFBUUssUUFBUSxDQUFDOTdCLElBQUk7b0JBQ25CMVQsT0FBT3N2QyxTQUFTO2dCQUNsQjtZQUNGO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQ2hnQyxJQUFJLENBQUN5eUgsS0FBSyxFQUFFO1lBQ25CLElBQUksQ0FBQzdELGFBQWEsQ0FBQzJEO1FBQ3JCLE9BQU8sQ0FBQztRQUNSLElBQUksQ0FBQzVELG1CQUFtQixDQUFDNEQ7UUFDekIsSUFBSSxDQUFDN0ksMkJBQTJCLENBQUM2STtRQUNqQyxJQUFJLENBQUMva0YsU0FBUyxDQUFDamtDLE1BQU0sQ0FBQ2dwSDtRQUN0QixPQUFPLElBQUksQ0FBQy9rRixTQUFTO0lBQ3ZCO0FBQ0Y7QUFDQSxNQUFNbzNFLCtCQUErQmU7SUFDbkM5eUgsWUFBWXd1QyxVQUFVLENBQUU7UUFDdEIsTUFBTSxFQUNKcmhDLElBQUksRUFDSjBkLFFBQVEsRUFDUnFrQixNQUFNLEVBQ1AsR0FBR1Y7UUFDSixNQUFNcVIsb0JBQW9CLENBQUMsQ0FBQzNRLE9BQU95b0YsZUFBZTtRQUNsRCxLQUFLLENBQUNucEYsWUFBWTtZQUNoQjBrRixjQUFjLENBQUNyekUscUJBQXFCaXpFLGtCQUFrQmlCLGFBQWEsQ0FBQzVtSDtRQUN0RTtRQUNBLElBQUksQ0FBQzBkLFFBQVEsR0FBR0E7UUFDaEIsSUFBSWcxQixxQkFBcUJpekUsa0JBQWtCaUIsYUFBYSxDQUFDNW1ILE9BQU87WUFDOUQsTUFBTXkvRCxRQUFRLElBQUksQ0FBQ0EsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDZzBELFdBQVc7WUFDNUMsS0FBSyxNQUFNN3pGLFdBQVdsaUIsU0FBVTtnQkFDOUJraUIsUUFBUTYvQixLQUFLLEdBQUdBO1lBQ2xCO1FBQ0YsT0FBTztZQUNMLElBQUksQ0FBQ0EsS0FBSyxHQUFHO1FBQ2Y7SUFDRjtJQUNBLENBQUNnMEQsV0FBVztRQUNWLE9BQU8sSUFBSUMsYUFBYTtZQUN0QmxtRixXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6Qi9FLE9BQU8sSUFBSSxDQUFDem9DLElBQUksQ0FBQ3lvQyxLQUFLO1lBQ3RCNmhGLFVBQVUsSUFBSSxDQUFDdHFILElBQUksQ0FBQ3NxSCxRQUFRO1lBQzVCcnpELGtCQUFrQixJQUFJLENBQUNqM0QsSUFBSSxDQUFDaTNELGdCQUFnQixJQUFJLElBQUksQ0FBQ2ozRCxJQUFJLENBQUNnM0QsWUFBWTtZQUN0RTdPLGFBQWEsSUFBSSxDQUFDbm9ELElBQUksQ0FBQ21vRCxXQUFXO1lBQ2xDNkgsVUFBVSxJQUFJLENBQUNod0QsSUFBSSxDQUFDZ3dELFFBQVE7WUFDNUJ6NEIsTUFBTSxJQUFJLENBQUN2M0IsSUFBSSxDQUFDdTNCLElBQUk7WUFDcEJnekYsWUFBWSxJQUFJLENBQUN2cUgsSUFBSSxDQUFDdXFILFVBQVUsSUFBSTtZQUNwQ3hvRixRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQnJrQixVQUFVLElBQUksQ0FBQ0EsUUFBUTtZQUN2QmpnQixNQUFNLElBQUksQ0FBQ3VDLElBQUksQ0FBQ3ZDLElBQUk7WUFDcEJxN0MsZ0JBQWdCLElBQUksQ0FBQy9XLE1BQU0sQ0FBQ3lvRixlQUFlO1FBQzdDO0lBQ0Y7SUFDQXBwRixTQUFTO1FBQ1AsTUFBTSxFQUNKb00sU0FBUyxFQUNWLEdBQUcsSUFBSTtRQUNSQSxVQUFVOUIsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztRQUN4QmtvQyxVQUFVNHpFLElBQUksR0FBRztRQUNqQixNQUFNM2hELFFBQVEsSUFBSSxDQUFDQSxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUNnMEQsV0FBVztRQUM1QyxNQUFNN3JFLGFBQWEsRUFBRTtRQUNyQixLQUFLLE1BQU1ob0IsV0FBVyxJQUFJLENBQUNsaUIsUUFBUSxDQUFFO1lBQ25Da2lCLFFBQVE2L0IsS0FBSyxHQUFHQTtZQUNoQjcvQixRQUFRNE4sU0FBUyxDQUFDMmpCLFlBQVksR0FBRztZQUNqQ3ZKLFdBQVdsdEQsSUFBSSxDQUFDa2xDLFFBQVE1L0IsSUFBSSxDQUFDb0UsRUFBRTtZQUMvQnc3QixRQUFReXJGLGdCQUFnQjtRQUMxQjtRQUNBLElBQUksQ0FBQzc5RSxTQUFTLENBQUNwTixZQUFZLENBQUMsaUJBQWlCd25CLFdBQVd0dEQsR0FBRyxDQUFDOEosQ0FBQUEsS0FBTSxDQUFDLEVBQUUrNEIsaUJBQWlCLEVBQUUvNEIsR0FBRyxDQUFDLEVBQUVsUyxJQUFJLENBQUM7UUFDbkcsT0FBTyxJQUFJLENBQUNzN0MsU0FBUztJQUN2QjtBQUNGO0FBQ0EsTUFBTWttRjtJQUNKLENBQUM1NkUsY0FBYyxDQUFRO0lBQ3ZCLENBQUM2NkUsWUFBWSxDQUE0QjtJQUN6QyxDQUFDQyxTQUFTLENBQXlCO0lBQ25DLENBQUNDLFNBQVMsQ0FBeUI7SUFDbkMsQ0FBQ0MsV0FBVyxDQUEyQjtJQUN2QyxDQUFDcnJGLEtBQUssQ0FBUTtJQUNkLENBQUMrRSxTQUFTLENBQVE7SUFDbEIsQ0FBQzJhLFdBQVcsQ0FBUTtJQUNwQixDQUFDNHJFLE9BQU8sQ0FBUTtJQUNoQixDQUFDcjJHLFFBQVEsQ0FBUTtJQUNqQixDQUFDcWtCLE1BQU0sQ0FBUTtJQUNmLENBQUN3b0YsVUFBVSxDQUFRO0lBQ25CLENBQUN5SixNQUFNLENBQVM7SUFDaEIsQ0FBQ3YwRCxLQUFLLENBQVE7SUFDZCxDQUFDdzBELG9CQUFvQixDQUFRO0lBQzdCLENBQUNsa0YsUUFBUSxDQUFRO0lBQ2pCLENBQUNta0YsYUFBYSxDQUFRO0lBQ3RCLENBQUMvakUscUJBQXFCLENBQVE7SUFDOUIsQ0FBQ0YsYUFBYSxDQUFRO0lBQ3RCLENBQUMxNEIsSUFBSSxDQUFRO0lBQ2IsQ0FBQ3k0QixRQUFRLENBQVE7SUFDakIsQ0FBQ3M2RCxRQUFRLENBQVE7SUFDakIsQ0FBQzFFLE9BQU8sQ0FBUTtJQUNoQixDQUFDdU8sVUFBVSxDQUFTO0lBQ3BCLENBQUNDLFlBQVksQ0FBUTtJQUNyQixDQUFDcE4sV0FBVyxDQUFRO0lBQ3BCbjBILFlBQVksRUFDVjI2QyxTQUFTLEVBQ1QvRSxLQUFLLEVBQ0wvcUIsUUFBUSxFQUNSNHNHLFFBQVEsRUFDUnJ6RCxnQkFBZ0IsRUFDaEI5TyxXQUFXLEVBQ1g2SCxRQUFRLEVBQ1JqdUIsTUFBTSxFQUNOeEssSUFBSSxFQUNKZ3pGLFVBQVUsRUFDVjlzSCxJQUFJLEVBQ0pxN0MsaUJBQWlCLElBQUksRUFDdEIsQ0FBRTthQXZDSCxDQUFDQSxjQUFjLEdBQUc7YUFDbEIsQ0FBQzY2RSxZQUFZLEdBQUcsSUFBSSxDQUFDLENBQUM5UyxPQUFPLENBQUNyckgsSUFBSSxDQUFDLElBQUk7YUFDdkMsQ0FBQ28rSCxTQUFTLEdBQUcsSUFBSSxDQUFDLENBQUNuakYsSUFBSSxDQUFDajdDLElBQUksQ0FBQyxJQUFJO2FBQ2pDLENBQUNxK0gsU0FBUyxHQUFHLElBQUksQ0FBQyxDQUFDbGpGLElBQUksQ0FBQ243QyxJQUFJLENBQUMsSUFBSTthQUNqQyxDQUFDcytILFdBQVcsR0FBRyxJQUFJLENBQUMsQ0FBQ3J5RSxNQUFNLENBQUNqc0QsSUFBSSxDQUFDLElBQUk7YUFDckMsQ0FBQ2l6QyxLQUFLLEdBQUc7YUFDVCxDQUFDK0UsU0FBUyxHQUFHO2FBQ2IsQ0FBQzJhLFdBQVcsR0FBRzthQUNmLENBQUM0ckUsT0FBTyxHQUFHO2FBQ1gsQ0FBQ3IyRyxRQUFRLEdBQUc7YUFDWixDQUFDcWtCLE1BQU0sR0FBRzthQUNWLENBQUN3b0YsVUFBVSxHQUFHO2FBQ2QsQ0FBQ3lKLE1BQU0sR0FBRzthQUNWLENBQUN2MEQsS0FBSyxHQUFHO2FBQ1QsQ0FBQ3cwRCxvQkFBb0IsR0FBRzthQUN4QixDQUFDbGtGLFFBQVEsR0FBRzthQUNaLENBQUNta0YsYUFBYSxHQUFHO2FBQ2pCLENBQUMvakUscUJBQXFCLEdBQUc7YUFDekIsQ0FBQ0YsYUFBYSxHQUFHO2FBQ2pCLENBQUMxNEIsSUFBSSxHQUFHO2FBQ1IsQ0FBQ3k0QixRQUFRLEdBQUc7YUFDWixDQUFDczZELFFBQVEsR0FBRzthQUNaLENBQUMxRSxPQUFPLEdBQUc7YUFDWCxDQUFDdU8sVUFBVSxHQUFHO2FBQ2QsQ0FBQ0MsWUFBWSxHQUFHO2FBQ2hCLENBQUNwTixXQUFXLEdBQUc7UUFlYixJQUFJLENBQUMsQ0FBQ3g1RSxTQUFTLEdBQUdBO1FBQ2xCLElBQUksQ0FBQyxDQUFDODhFLFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUNuaUUsV0FBVyxHQUFHQTtRQUNwQixJQUFJLENBQUMsQ0FBQzZILFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUNqdUIsTUFBTSxHQUFHQTtRQUNmLElBQUksQ0FBQyxDQUFDMEcsS0FBSyxHQUFHQTtRQUNkLElBQUksQ0FBQyxDQUFDbFIsSUFBSSxHQUFHQTtRQUNiLElBQUksQ0FBQyxDQUFDZ3pGLFVBQVUsR0FBR0E7UUFDbkIsSUFBSSxDQUFDLENBQUM3c0csUUFBUSxHQUFHQTtRQUNqQixJQUFJLENBQUMsQ0FBQ283QixjQUFjLEdBQUdBO1FBQ3ZCLElBQUksQ0FBQyxDQUFDczdFLFlBQVksR0FBRzEyRyxRQUFRLENBQUMsRUFBRTtRQUNoQyxJQUFJLENBQUMsQ0FBQ3EyRyxPQUFPLEdBQUd0c0YsY0FBY0MsWUFBWSxDQUFDdXZCO1FBQzNDLElBQUksQ0FBQ285RCxPQUFPLEdBQUczMkcsU0FBU3BvQixPQUFPLENBQUMyUCxDQUFBQSxJQUFLQSxFQUFFbW1ILHlCQUF5QjtRQUNoRSxJQUFJdHlFLGdCQUFnQjtZQUNsQixJQUFJLENBQUM2eUUsbUJBQW1CO1FBQzFCLE9BQU87WUFDTCxJQUFJLENBQUMsQ0FBQzJJLGlCQUFpQjtZQUN2QixJQUFJLENBQUMsQ0FBQzltRixTQUFTLENBQUNsTCxNQUFNLEdBQUc7WUFDekIsSUFBSTdrQyxNQUFNO2dCQUNSLElBQUksQ0FBQyxDQUFDZ2tELE1BQU07WUFDZDtRQUNGO0lBQ0Y7SUFDQSxDQUFDNnlFLGlCQUFpQjtRQUNoQixJQUFJLElBQUksQ0FBQyxDQUFDTCxvQkFBb0IsRUFBRTtZQUM5QjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNBLG9CQUFvQixHQUFHLElBQUkxMUY7UUFDakMsTUFBTSxFQUNKQyxNQUFNLEVBQ1AsR0FBRyxJQUFJLENBQUMsQ0FBQ3kxRixvQkFBb0I7UUFDOUIsS0FBSyxNQUFNcjBGLFdBQVcsSUFBSSxDQUFDeTBGLE9BQU8sQ0FBRTtZQUNsQ3owRixRQUFRaEIsZ0JBQWdCLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQ2sxRixXQUFXLEVBQUU7Z0JBQ25EdDFGO1lBQ0Y7WUFDQW9CLFFBQVFoQixnQkFBZ0IsQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLENBQUNpMUYsU0FBUyxFQUFFO2dCQUN4RHIxRjtZQUNGO1lBQ0FvQixRQUFRaEIsZ0JBQWdCLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxDQUFDZzFGLFNBQVMsRUFBRTtnQkFDeERwMUY7WUFDRjtZQUNBb0IsUUFBUThMLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7UUFDeEI7UUFDQSxLQUFLLE1BQU1zNkIsV0FBVyxJQUFJLENBQUMsQ0FBQ2xpQixRQUFRLENBQUU7WUFDcENraUIsUUFBUTROLFNBQVMsRUFBRTVPLGlCQUFpQixXQUFXLElBQUksQ0FBQyxDQUFDKzBGLFlBQVksRUFBRTtnQkFDakVuMUY7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxDQUFDKzFGLHdCQUF3QjtRQUN2QixNQUFNMzBGLFVBQVUsSUFBSSxDQUFDLENBQUNsaUIsUUFBUSxDQUFDcnRCLElBQUksQ0FBQzRVLENBQUFBLElBQUtBLEVBQUVpaUgsZ0JBQWdCO1FBQzNELElBQUksQ0FBQ3RuRixTQUFTO1lBQ1o7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDdXdCLHFCQUFxQixHQUFHdndCLFFBQVEybkYsZUFBZSxDQUFDM25GLFFBQVF1d0IscUJBQXFCO0lBQ3JGO0lBQ0F3N0Qsc0JBQXNCO1FBQ3BCLElBQUksSUFBSSxDQUFDLENBQUN1SSxhQUFhLEVBQUU7WUFDdkI7UUFDRjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQy9qRSxxQkFBcUIsRUFBRTtZQUNoQyxJQUFJLENBQUMsQ0FBQ29rRSx3QkFBd0I7UUFDaEM7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNwa0UscUJBQXFCLEVBQUU7WUFDaEM7UUFDRjtRQUNBLE1BQU0sRUFDSjN4QixNQUFNLEVBQ1AsR0FBRyxJQUFJLENBQUMsQ0FBQ3kxRixvQkFBb0IsR0FBRyxJQUFJMTFGO1FBQ3JDLE1BQU1pMkYsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUNKLFlBQVksQ0FBQzNKLGlCQUFpQjtRQUMzRCxNQUFNZ0ssY0FBYztZQUNsQixJQUFJLENBQUMsQ0FBQzM3RSxjQUFjLENBQUN1SCxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsTUFBTXJ0RCxXQUFXLENBQUN3aEk7UUFDbEU7UUFDQSxNQUFNRSxZQUFZO1lBQ2hCLElBQUksQ0FBQyxDQUFDNTdFLGNBQWMsQ0FBQ3VILGtCQUFrQixDQUFDLElBQUksRUFBRSxPQUFPLE1BQU0sQ0FBQ20wRTtRQUM5RDtRQUNBLE1BQU1HLFlBQVk7WUFDaEIsSUFBSSxDQUFDLENBQUM3N0UsY0FBYyxDQUFDdUgsa0JBQWtCLENBQUMsSUFBSSxFQUFFLE9BQU87UUFDdkQ7UUFDQSxJQUFJLENBQUNtMEUsY0FBYztZQUNqQixNQUFNempGLFNBQVMsSUFBSSxDQUFDLENBQUNtakYsYUFBYSxHQUFHMTJILFNBQVMySSxhQUFhLENBQUM7WUFDNUQ0cUMsT0FBT3hELFNBQVMsR0FBRztZQUNuQixNQUFNcW5GLGtCQUFrQixJQUFJLENBQUMsQ0FBQ1IsWUFBWSxDQUFDNW1GLFNBQVM7WUFDcER1RCxPQUFPNXpDLEtBQUssQ0FBQzQ0RCxNQUFNLEdBQUc2K0QsZ0JBQWdCejNILEtBQUssQ0FBQzQ0RCxNQUFNLEdBQUc7WUFDckRobEIsT0FBT0MsUUFBUSxHQUFHO1lBQ2xCRCxPQUFPb2dCLFlBQVksR0FBRztZQUN0QnBnQixPQUFPcWdCLFlBQVksR0FBRztZQUN0QnJnQixPQUFPM1EsWUFBWSxDQUFDLGdCQUFnQjtZQUNwQyxJQUFJLENBQUMsQ0FBQ29oRixXQUFXO1lBQ2pCLElBQUksQ0FBQyxDQUFDcVQsMkJBQTJCO1lBQ2pDOWpGLE9BQU9uUyxnQkFBZ0IsQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDKzBGLFlBQVksRUFBRTtnQkFDckRuMUY7WUFDRjtZQUNBdVMsT0FBT25TLGdCQUFnQixDQUFDLFNBQVM2MUYsYUFBYTtnQkFDNUNqMkY7WUFDRjtZQUNBdVMsT0FBT25TLGdCQUFnQixDQUFDLGdCQUFnQjgxRixXQUFXO2dCQUNqRGwyRjtZQUNGO1lBQ0F1UyxPQUFPblMsZ0JBQWdCLENBQUMsZ0JBQWdCKzFGLFdBQVc7Z0JBQ2pEbjJGO1lBQ0Y7WUFDQW8yRixnQkFBZ0JFLEtBQUssQ0FBQy9qRjtRQUN4QixPQUFPO1lBQ0wsSUFBSSxDQUFDLENBQUNtakYsYUFBYSxHQUFHLElBQUksQ0FBQyxDQUFDRSxZQUFZLENBQUM1bUYsU0FBUztZQUNsRCxLQUFLLE1BQU01TixXQUFXLElBQUksQ0FBQ3kwRixPQUFPLENBQUU7Z0JBQ2xDejBGLFFBQVF1eEIsWUFBWSxHQUFHO2dCQUN2QnZ4QixRQUFRd3hCLFlBQVksR0FBRztnQkFDdkJ4eEIsUUFBUWhCLGdCQUFnQixDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUMrMEYsWUFBWSxFQUFFO29CQUN0RG4xRjtnQkFDRjtnQkFDQW9CLFFBQVFoQixnQkFBZ0IsQ0FBQyxTQUFTNjFGLGFBQWE7b0JBQzdDajJGO2dCQUNGO2dCQUNBb0IsUUFBUWhCLGdCQUFnQixDQUFDLGdCQUFnQjgxRixXQUFXO29CQUNsRGwyRjtnQkFDRjtnQkFDQW9CLFFBQVFoQixnQkFBZ0IsQ0FBQyxnQkFBZ0IrMUYsV0FBVztvQkFDbERuMkY7Z0JBQ0Y7Z0JBQ0FvQixRQUFROEwsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztZQUN4QjtRQUNGO0lBQ0Y7SUFDQSxDQUFDdXZILDJCQUEyQjtRQUMxQixJQUFJLElBQUksQ0FBQyxDQUFDVCxZQUFZLENBQUMzSixpQkFBaUIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDMkosWUFBWSxDQUFDdGxGLE1BQU0sRUFBRTtZQUN0RTtRQUNGO1FBQ0EsSUFBSSxDQUFDNjhFLG1CQUFtQjtRQUN4QixNQUFNLENBQUN2MUgsR0FBRzBNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQ3F0RCxxQkFBcUI7UUFDMUMsTUFBTSxFQUNKaHpELEtBQUssRUFDTixHQUFHLElBQUksQ0FBQyxDQUFDKzJILGFBQWE7UUFDdkIvMkgsTUFBTSs4RCxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUU5akUsRUFBRSxFQUFFLENBQUM7UUFDMUIrRyxNQUFNZ3pDLEdBQUcsR0FBRyxDQUFDLEtBQUssRUFBRXJ0QyxFQUFFLDhCQUE4QixDQUFDO0lBQ3ZEO0lBQ0EsQ0FBQzArRyxXQUFXO1FBQ1YsSUFBSSxJQUFJLENBQUMsQ0FBQzRTLFlBQVksQ0FBQzNKLGlCQUFpQixFQUFFO1lBQ3hDO1FBQ0Y7UUFDQSxJQUFJLENBQUNrQixtQkFBbUI7UUFDeEIsSUFBSSxDQUFDLENBQUN1SSxhQUFhLENBQUMvMkgsS0FBSyxDQUFDa3pELGVBQWUsR0FBRyxJQUFJLENBQUNELGtCQUFrQixJQUFJO0lBQ3pFO0lBQ0EsSUFBSUEscUJBQXFCO1FBQ3ZCLE1BQU0sRUFDSjNuQixLQUFLLEVBQ0xtRCxPQUFPLEVBQ1IsR0FBRyxJQUFJLENBQUMsQ0FBQ3dvRixZQUFZLENBQUNuTixXQUFXO1FBQ2xDLElBQUksQ0FBQ3grRSxPQUFPO1lBQ1YsT0FBTztRQUNUO1FBQ0EsT0FBTyxJQUFJLENBQUMsQ0FBQzFHLE1BQU0sQ0FBQ3lvRixlQUFlLENBQUNscUUsZ0JBQWdCLENBQUM3WCxPQUFPbUQ7SUFDOUQ7SUFDQWd6QixxQkFBcUI7UUFDbkJwVixXQUFXO1lBQ1QsSUFBSSxDQUFDLENBQUMwcUUsYUFBYSxFQUFFOXlFO1FBQ3ZCLEdBQUc7SUFDTDtJQUNBcEIsVUFBVTtRQUNSLE1BQU0sRUFDSmdRLFFBQVEsRUFDUnZuQixLQUFLLEVBQ0xtRCxPQUFPLEVBQ1BvckIsWUFBWSxFQUNaQyxnQkFBZ0IsRUFDakIsR0FBRyxJQUFJLENBQUMsQ0FBQ205RCxZQUFZLENBQUNuTixXQUFXO1FBQ2xDLE9BQU87WUFDTDkrRCxhQUFhO2dCQUNYOXpCLEtBQUssSUFBSSxDQUFDNGEsT0FBTztZQUNuQjtZQUNBK2dCO1lBQ0F2bkI7WUFDQW1EO1lBQ0FvckI7WUFDQUM7UUFDRjtJQUNGO0lBQ0EsSUFBSTJMLHFCQUFxQjtRQUN2QixPQUFPLElBQUksQ0FBQyxDQUFDc3hELGFBQWE7SUFDNUI7SUFDQSxJQUFJamxGLFVBQVU7UUFDWixJQUFJLENBQUMsQ0FBQyszRSxXQUFXLEtBQUssSUFBSSxDQUFDLENBQUNvTixZQUFZLENBQUNwTixXQUFXO1FBQ3BELE9BQU8sSUFBSSxDQUFDLENBQUNBLFdBQVc7SUFDMUI7SUFDQSxJQUFJLzNFLFFBQVFoekIsSUFBSSxFQUFFO1FBQ2hCLElBQUlBLFNBQVMsSUFBSSxDQUFDZ3pCLE9BQU8sRUFBRTtZQUN6QjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNtbEYsWUFBWSxDQUFDcE4sV0FBVyxHQUFHLElBQUksQ0FBQyxDQUFDQSxXQUFXLEdBQUcvcUc7SUFDdkQ7SUFDQSxJQUFJMGpELDJCQUEyQjtRQUM3QixPQUFPLElBQUksQ0FBQyxDQUFDeTBELFlBQVksQ0FBQ3IyRSxLQUFLLENBQUN5RCxxQkFBcUI7SUFDdkQ7SUFDQXVQLHVCQUF1QixFQUNyQnJ3QixRQUFRLEVBQ1Jzd0IsUUFBUSxFQUNULEVBQUU7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNrakUsYUFBYSxFQUFFO1lBQ3hCO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQ0EsYUFBYSxDQUFDeG9GLFNBQVMsQ0FBQytWLE1BQU0sQ0FBQyxZQUFZL2dCO1FBQ2pELElBQUksQ0FBQyxDQUFDd3pGLGFBQWEsQ0FBQ2pqRSxZQUFZLEdBQUdEO0lBQ3JDO0lBQ0FpTyx5QkFBeUJ2K0IsUUFBUSxFQUFFO1FBQ2pDLElBQUksQ0FBQyxDQUFDd3pGLGFBQWEsQ0FBQ3hvRixTQUFTLENBQUMrVixNQUFNLENBQUMsWUFBWS9nQjtJQUNuRDtJQUNBLElBQUlpaUMsdUJBQXVCO1FBQ3pCLElBQUksSUFBSSxDQUFDLENBQUMxUyxhQUFhLEVBQUU7WUFDdkIsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsYUFBYTtRQUM1QjtRQUNBLE1BQU0sRUFDSjc1RCxDQUFDLEVBQ0QwTSxDQUFDLEVBQ0QraEMsTUFBTSxFQUNQLEdBQUcsSUFBSSxDQUFDLENBQUNxdkYsYUFBYSxDQUFDMXlFLHFCQUFxQjtRQUM3QyxNQUFNLEVBQ0pwckQsR0FBR3U2RCxPQUFPLEVBQ1Y3dEQsR0FBRzh0RCxPQUFPLEVBQ1Zoc0IsT0FBT2dvQixXQUFXLEVBQ2xCL25CLFFBQVFnb0IsWUFBWSxFQUNyQixHQUFHLElBQUksQ0FBQyxDQUFDdW5FLFlBQVksQ0FBQ3IyRSxLQUFLLENBQUN5RCxxQkFBcUI7UUFDbEQsT0FBTztZQUFFcHJELENBQUFBLElBQUl1NkQsT0FBTSxJQUFLL0Q7WUFBYzlwRCxDQUFBQSxJQUFJK2hDLFNBQVMrckIsT0FBTSxJQUFLL0Q7U0FBYTtJQUM3RTtJQUNBLElBQUk4VixxQkFBcUJoc0MsR0FBRyxFQUFFO1FBQzVCLElBQUksQ0FBQyxDQUFDczVCLGFBQWEsR0FBR3Q1QjtJQUN4QjtJQUNBazZCLDBCQUEwQjtRQUN4QixPQUFPLElBQUksQ0FBQyxDQUFDWixhQUFhLEtBQUs7SUFDakM7SUFDQSxJQUFJRSx3QkFBd0I7UUFDMUIsT0FBTyxJQUFJLENBQUMsQ0FBQ0EscUJBQXFCO0lBQ3BDO0lBQ0EsSUFBSUsscUJBQXFCO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLENBQUMwakUsYUFBYSxDQUFDMXlFLHFCQUFxQixHQUFHNWMsS0FBSyxHQUFHLElBQUksQ0FBQys2Qix3QkFBd0IsQ0FBQy82QixLQUFLO0lBQ2hHO0lBQ0EyYSxZQUFZL3NELE9BQU8sRUFBRTtRQUNuQixNQUFNLENBQUNndEQsTUFBTUMsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDd1EsYUFBYSxJQUFJLElBQUksQ0FBQ0UscUJBQXFCLENBQUM3MUQsR0FBRyxDQUFDbEUsQ0FBQUEsSUFBS0EsSUFBSTtRQUNwRixNQUFNbTdELG1CQUFtQixJQUFJLENBQUNvTyx3QkFBd0I7UUFDdEQsTUFBTSxFQUNKdnBFLEdBQUd1NkQsT0FBTyxFQUNWN3RELEdBQUc4dEQsT0FBTyxFQUNWaHNCLE9BQU9nb0IsV0FBVyxFQUNsQi9uQixRQUFRZ29CLFlBQVksRUFDckIsR0FBRzBFO1FBQ0osSUFBSSxDQUFDLENBQUN6WSxjQUFjLENBQUM0RyxVQUFVLENBQUMsTUFBTSxJQUFJLEVBQUVpUixVQUFVblIsT0FBT29OLGFBQWFnRSxVQUFVblIsT0FBT29OLGNBQWM7WUFDdkcsR0FBR3I2RCxPQUFPO1lBQ1YrK0Q7UUFDRjtJQUNGO0lBQ0Fud0IsU0FBUztRQUNQLElBQUksSUFBSSxDQUFDLENBQUNxK0IsS0FBSyxFQUFFO1lBQ2Y7UUFDRjtRQUNBLE1BQU1BLFFBQVEsSUFBSSxDQUFDLENBQUNBLEtBQUssR0FBR2ppRSxTQUFTMkksYUFBYSxDQUFDO1FBQ25EczVELE1BQU1seUIsU0FBUyxHQUFHO1FBQ2xCLElBQUksSUFBSSxDQUFDLENBQUM5RSxLQUFLLEVBQUU7WUFDZixNQUFNbUUsWUFBWTZ5QixNQUFNdGlFLEtBQUssQ0FBQzQzSCxZQUFZLEdBQUdsL0YsS0FBS0MsWUFBWSxJQUFJLElBQUksQ0FBQyxDQUFDMlMsS0FBSztZQUM3RWczQixNQUFNdGlFLEtBQUssQ0FBQ2t6RCxlQUFlLEdBQUcsQ0FBQyxtQkFBbUIsRUFBRXpqQixVQUFVLFlBQVksQ0FBQztRQUM3RTtRQUNBLE1BQU1vb0YsU0FBU3gzSCxTQUFTMkksYUFBYSxDQUFDO1FBQ3RDNnVILE9BQU96bkYsU0FBUyxHQUFHO1FBQ25CLElBQUksSUFBSSxDQUFDLENBQUMrOEUsUUFBUSxFQUFFajJGLEtBQUs7WUFDdkIsTUFBTWllLFFBQVE5MEMsU0FBUzJJLGFBQWEsQ0FBQztZQUNyQ21zQyxNQUFNL0UsU0FBUyxHQUFHO1lBQ2xCeW5GLE9BQU96ckgsTUFBTSxDQUFDK29DO1lBQ2IsR0FDQ2hGLEtBQUtnRixNQUFNaEYsR0FBRyxFQUNkalosS0FBS2llLE1BQU1wVCxXQUFXLEVBQ3ZCLEdBQUcsSUFBSSxDQUFDLENBQUNvckYsUUFBUTtRQUNwQjtRQUNBN3FELE1BQU1sMkQsTUFBTSxDQUFDeXJIO1FBQ2IsSUFBSSxJQUFJLENBQUMsQ0FBQ2pCLE9BQU8sRUFBRTtZQUNqQixNQUFNOThELG1CQUFtQno1RCxTQUFTMkksYUFBYSxDQUFDO1lBQ2hEOHdELGlCQUFpQjFwQixTQUFTLEdBQUc7WUFDN0IwcEIsaUJBQWlCNzJCLFlBQVksQ0FBQyxnQkFBZ0I7WUFDOUM2MkIsaUJBQWlCNzJCLFlBQVksQ0FBQyxrQkFBa0IzbUIsS0FBS29xQyxTQUFTLENBQUM7Z0JBQzdEa3dFLFNBQVMsSUFBSSxDQUFDLENBQUNBLE9BQU8sQ0FBQ3pzSCxPQUFPO1lBQ2hDO1lBQ0EydkQsaUJBQWlCZytELFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQ2xCLE9BQU8sQ0FBQzlDLFdBQVc7WUFDckQrRCxPQUFPenJILE1BQU0sQ0FBQzB0RDtRQUNoQjtRQUNBNXBCLGVBQWU7WUFDYnR4QyxNQUFNLElBQUksQ0FBQyxDQUFDQSxJQUFJLElBQUksSUFBSSxDQUFDLENBQUNvc0QsV0FBVyxDQUFDOXpCLEdBQUc7WUFDekNpWixLQUFLLElBQUksQ0FBQyxDQUFDNmEsV0FBVyxFQUFFN2E7WUFDeEJDLFdBQVc7UUFDYixHQUFHa3lCO1FBQ0gsSUFBSSxDQUFDLENBQUNqeUIsU0FBUyxDQUFDamtDLE1BQU0sQ0FBQ2syRDtJQUN6QjtJQUNBLElBQUksQ0FBQzFqRSxJQUFJO1FBQ1AsTUFBTWkwRCxXQUFXLElBQUksQ0FBQyxDQUFDQSxRQUFRO1FBQy9CLE1BQU03SCxjQUFjLElBQUksQ0FBQyxDQUFDQSxXQUFXO1FBQ3JDLElBQUk2SCxVQUFVMzdCLE9BQVEsRUFBQzh6QixhQUFhOXpCLE9BQU84ekIsWUFBWTl6QixHQUFHLEtBQUsyN0IsU0FBUzM3QixHQUFHLEdBQUc7WUFDNUUsT0FBTyxJQUFJLENBQUMsQ0FBQzI3QixRQUFRLENBQUNqMEQsSUFBSSxJQUFJO1FBQ2hDO1FBQ0EsT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFDNnVGLFFBQVE7UUFDWCxPQUFPLElBQUksQ0FBQyxDQUFDN3VGLElBQUksRUFBRXdqQyxZQUFZcGlDLE9BQU95dEYsWUFBWTtJQUNwRDtJQUNBLElBQUksQ0FBQ2trQyxTQUFTO1FBQ1osT0FBTyxJQUFJLENBQUMsQ0FBQy95SCxJQUFJLEVBQUV3akMsWUFBWXBpQyxPQUFPc3JDLFNBQVM7SUFDakQ7SUFDQSxDQUFDeXNGLGdCQUFnQixDQUFDajVHLElBQUk7UUFDcEIsTUFBTWs1RyxhQUFhLEVBQUU7UUFDckIsTUFBTUMsZUFBZTtZQUNuQi9nRyxLQUFLcFk7WUFDTGxnQixNQUFNO2dCQUNKeEosTUFBTTtnQkFDTmd0QyxZQUFZO29CQUNWK04sS0FBSztnQkFDUDtnQkFDQTlOLFVBQVU7b0JBQUM7d0JBQ1RqdEMsTUFBTTt3QkFDTml0QyxVQUFVMjFGO29CQUNaO2lCQUFFO1lBQ0o7UUFDRjtRQUNBLE1BQU1FLGlCQUFpQjtZQUNyQmw0SCxPQUFPO2dCQUNMc3JDLE9BQU8sSUFBSSxDQUFDLENBQUNxbUYsU0FBUztnQkFDdEJsa0MsVUFBVSxJQUFJLENBQUMsQ0FBQ0EsUUFBUSxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDQSxRQUFRLENBQUMsK0JBQStCLENBQUMsR0FBRztZQUN2RjtRQUNGO1FBQ0EsS0FBSyxNQUFNaDlDLFFBQVEzeEIsS0FBSzVwQixLQUFLLENBQUMsTUFBTztZQUNuQzhpSSxXQUFXejZILElBQUksQ0FBQztnQkFDZG5JLE1BQU07Z0JBQ043QixPQUFPazlDO2dCQUNQck8sWUFBWTgxRjtZQUNkO1FBQ0Y7UUFDQSxPQUFPRDtJQUNUO0lBQ0EsQ0FBQ3ZVLE9BQU8sQ0FBQzVnRixLQUFLO1FBQ1osSUFBSUEsTUFBTXdYLE1BQU0sSUFBSXhYLE1BQU0yWCxRQUFRLElBQUkzWCxNQUFNeVgsT0FBTyxJQUFJelgsTUFBTTBYLE9BQU8sRUFBRTtZQUNwRTtRQUNGO1FBQ0EsSUFBSTFYLE1BQU1wbEMsR0FBRyxLQUFLLFdBQVdvbEMsTUFBTXBsQyxHQUFHLEtBQUssWUFBWSxJQUFJLENBQUMsQ0FBQ201SCxNQUFNLEVBQUU7WUFDbkUsSUFBSSxDQUFDLENBQUN2eUUsTUFBTTtRQUNkO0lBQ0Y7SUFDQTBpQixhQUFhLEVBQ1g1c0MsSUFBSSxFQUNKa29DLEtBQUssRUFDTHpYLE9BQU8sRUFDUixFQUFFO1FBQ0QsSUFBSSxJQUFJLENBQUMsQ0FBQ2xQLGNBQWMsRUFBRTtZQUN4QixJQUFJa1AsU0FBUztnQkFDWCxJQUFJLENBQUNuakQsTUFBTTtnQkFDWCxJQUFJLENBQUMsQ0FBQ21pSCxXQUFXLEdBQUc7WUFDdEIsT0FBTyxJQUFJdm5ELE9BQU87Z0JBQ2hCLElBQUlBLE1BQU16WCxPQUFPLEVBQUU7b0JBQ2pCLElBQUksQ0FBQ25qRCxNQUFNO2dCQUNiLE9BQU87b0JBQ0wsSUFBSSxDQUFDLENBQUMyOEcsV0FBVztvQkFDakIsSUFBSSxDQUFDLENBQUN3RixXQUFXLEdBQUd2bkQsTUFBTXhqRCxJQUFJO2dCQUNoQztZQUNGO1lBQ0EsSUFBSXNiLE1BQU07Z0JBQ1IsSUFBSSxDQUFDLENBQUM0NEIscUJBQXFCLEdBQUc7Z0JBQzlCLElBQUksQ0FBQyxDQUFDb2tFLHdCQUF3QjtnQkFDOUIsSUFBSSxDQUFDLENBQUNNLDJCQUEyQjtZQUNuQztZQUNBO1FBQ0Y7UUFDQSxJQUFJN3NFLFdBQVd5WCxPQUFPelgsU0FBUztZQUM3QixJQUFJLENBQUNuakQsTUFBTTtZQUNYO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQ3l2SCxpQkFBaUI7UUFDdkIsSUFBSSxDQUFDLENBQUMxTyxPQUFPLEtBQUs7WUFDaEJ6OUQsYUFBYSxJQUFJLENBQUMsQ0FBQ0EsV0FBVztZQUM5QjZILFVBQVUsSUFBSSxDQUFDLENBQUNBLFFBQVE7UUFDMUI7UUFDQSxJQUFJejRCLE1BQU07WUFDUixJQUFJLENBQUMsQ0FBQ3dZLFFBQVEsR0FBRztRQUNuQjtRQUNBLElBQUkwdkIsU0FBU0EsTUFBTXhqRCxJQUFJLEVBQUU7WUFDdkIsSUFBSSxDQUFDLENBQUMrekMsUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDa2xFLGdCQUFnQixDQUFDejFELE1BQU14akQsSUFBSTtZQUNsRCxJQUFJLENBQUMsQ0FBQzgzRyxPQUFPLEdBQUd0c0YsY0FBY0MsWUFBWSxDQUFDKzNCLE1BQU16akMsSUFBSTtZQUNyRCxJQUFJLENBQUMsQ0FBQ21zQixXQUFXLEdBQUc7UUFDdEI7UUFDQSxJQUFJLENBQUMsQ0FBQ3NYLEtBQUssRUFBRTU2RDtRQUNiLElBQUksQ0FBQyxDQUFDNDZELEtBQUssR0FBRztJQUNoQjtJQUNBbW9ELGNBQWM7UUFDWixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNoQyxPQUFPLEVBQUU7WUFDbEI7UUFDRjtRQUNDLEdBQ0N6OUQsYUFBYSxJQUFJLENBQUMsQ0FBQ0EsV0FBVyxFQUM5QjZILFVBQVUsSUFBSSxDQUFDLENBQUNBLFFBQVEsRUFDekIsR0FBRyxJQUFJLENBQUMsQ0FBQzQxRCxPQUFPO1FBQ2pCLElBQUksQ0FBQyxDQUFDQSxPQUFPLEdBQUc7UUFDaEIsSUFBSSxDQUFDLENBQUNubUQsS0FBSyxFQUFFNTZEO1FBQ2IsSUFBSSxDQUFDLENBQUM0NkQsS0FBSyxHQUFHO1FBQ2QsSUFBSSxDQUFDLENBQUMxdkIsUUFBUSxHQUFHO0lBQ25CO0lBQ0FsckMsU0FBUztRQUNQLElBQUksQ0FBQyxDQUFDb3ZILG9CQUFvQixFQUFFdjFGO1FBQzVCLElBQUksQ0FBQyxDQUFDdTFGLG9CQUFvQixHQUFHO1FBQzdCLElBQUksQ0FBQyxDQUFDeDBELEtBQUssRUFBRTU2RDtRQUNiLElBQUksQ0FBQyxDQUFDNDZELEtBQUssR0FBRztRQUNkLElBQUksQ0FBQyxDQUFDMDBELFVBQVUsR0FBRztRQUNuQixJQUFJLENBQUMsQ0FBQ0gsTUFBTSxHQUFHO1FBQ2YsSUFBSSxDQUFDLENBQUNFLGFBQWEsRUFBRXJ2SDtRQUNyQixJQUFJLENBQUMsQ0FBQ3F2SCxhQUFhLEdBQUc7UUFDdEIsSUFBSSxJQUFJLENBQUNHLE9BQU8sRUFBRTtZQUNoQixLQUFLLE1BQU16MEYsV0FBVyxJQUFJLENBQUN5MEYsT0FBTyxDQUFFO2dCQUNsQ3owRixRQUFROEwsU0FBUyxDQUFDN21DLE1BQU0sQ0FBQztZQUMzQjtRQUNGO0lBQ0Y7SUFDQSxDQUFDeXdILFdBQVc7UUFDVixJQUFJLElBQUksQ0FBQyxDQUFDdmxGLFFBQVEsS0FBSyxNQUFNO1lBQzNCO1FBQ0Y7UUFDQSxNQUFNLEVBQ0p2UyxNQUFNLEVBQ0prK0QsSUFBSSxFQUNMLEVBQ0Q5NUQsVUFBVSxFQUNSa0QsU0FBUyxFQUNQRSxTQUFTLEVBQ1RDLFVBQVUsRUFDVkMsS0FBSyxFQUNMQyxLQUFLLEVBQ04sRUFDRixFQUNGLEdBQUcsSUFBSSxDQUFDLENBQUNwRCxNQUFNO1FBQ2hCLElBQUl3ekYsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQ2hMLFVBQVU7UUFDdEMsSUFBSWh6RixPQUFPZytGLGdCQUFnQixJQUFJLENBQUMsQ0FBQ2hMLFVBQVUsR0FBRyxJQUFJLENBQUMsQ0FBQ2h6RixJQUFJO1FBQ3hELEtBQUssTUFBTXFJLFdBQVcsSUFBSSxDQUFDLENBQUNsaUIsUUFBUSxDQUFFO1lBQ3BDLElBQUksQ0FBQzZaLFFBQVExQixLQUFLbUQsU0FBUyxDQUFDNEcsUUFBUTUvQixJQUFJLENBQUN1M0IsSUFBSSxFQUFFQSxVQUFVLE1BQU07Z0JBQzdEQSxPQUFPcUksUUFBUTUvQixJQUFJLENBQUN1M0IsSUFBSTtnQkFDeEJnK0YsZ0JBQWdCO2dCQUNoQjtZQUNGO1FBQ0Y7UUFDQSxNQUFNQyxpQkFBaUIzL0YsS0FBS2tELGFBQWEsQ0FBQztZQUFDeEIsSUFBSSxDQUFDLEVBQUU7WUFBRW1rRSxJQUFJLENBQUMsRUFBRSxHQUFHbmtFLElBQUksQ0FBQyxFQUFFLEdBQUdta0UsSUFBSSxDQUFDLEVBQUU7WUFBRW5rRSxJQUFJLENBQUMsRUFBRTtZQUFFbWtFLElBQUksQ0FBQyxFQUFFLEdBQUdua0UsSUFBSSxDQUFDLEVBQUUsR0FBR21rRSxJQUFJLENBQUMsRUFBRTtTQUFDO1FBQ3RILE1BQU0rNUIsb0NBQW9DO1FBQzFDLE1BQU03b0UsY0FBYzJvRSxnQkFBZ0JoK0YsSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUUsR0FBR2srRixvQ0FBb0M7UUFDNUYsTUFBTUMsWUFBWUYsY0FBYyxDQUFDLEVBQUUsR0FBRzVvRTtRQUN0QyxNQUFNK29FLFdBQVdILGNBQWMsQ0FBQyxFQUFFO1FBQ2xDLElBQUksQ0FBQyxDQUFDemxGLFFBQVEsR0FBRztZQUFDLE1BQU8ybEYsQ0FBQUEsWUFBWXh3RixLQUFJLElBQUtGO1lBQVcsTUFBTzJ3RixDQUFBQSxXQUFXeHdGLEtBQUksSUFBS0Y7U0FBVztRQUMvRixNQUFNLEVBQ0o5bkMsS0FBSyxFQUNOLEdBQUcsSUFBSSxDQUFDLENBQUNxd0MsU0FBUztRQUNuQnJ3QyxNQUFNKzhELElBQUksR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUNucUIsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDcEM1eUMsTUFBTWd6QyxHQUFHLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDSixRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNyQztJQUNBLENBQUMwUixNQUFNO1FBQ0wsSUFBSSxJQUFJLENBQUMsQ0FBQzNJLGNBQWMsRUFBRTtZQUN4QixJQUFJLENBQUMsQ0FBQ0EsY0FBYyxDQUFDdUgsa0JBQWtCLENBQUMsSUFBSSxFQUFFO1lBQzlDO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQzJ6RSxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQ0EsTUFBTTtRQUM1QixJQUFJLElBQUksQ0FBQyxDQUFDQSxNQUFNLEVBQUU7WUFDaEIsSUFBSSxDQUFDLENBQUNyakYsSUFBSTtZQUNWLElBQUksQ0FBQyxDQUFDbkQsU0FBUyxDQUFDNU8sZ0JBQWdCLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQ2sxRixXQUFXO1lBQzNELElBQUksQ0FBQyxDQUFDdG1GLFNBQVMsQ0FBQzVPLGdCQUFnQixDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUMrMEYsWUFBWTtRQUNoRSxPQUFPO1lBQ0wsSUFBSSxDQUFDLENBQUNsakYsSUFBSTtZQUNWLElBQUksQ0FBQyxDQUFDakQsU0FBUyxDQUFDeWdDLG1CQUFtQixDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUM2bEQsV0FBVztZQUM5RCxJQUFJLENBQUMsQ0FBQ3RtRixTQUFTLENBQUN5Z0MsbUJBQW1CLENBQUMsV0FBVyxJQUFJLENBQUMsQ0FBQzBsRCxZQUFZO1FBQ25FO0lBQ0Y7SUFDQSxDQUFDaGpGLElBQUk7UUFDSCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM4dUIsS0FBSyxFQUFFO1lBQ2hCLElBQUksQ0FBQ3IrQixNQUFNO1FBQ2I7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDeTVELFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUMsQ0FBQ3k2QixXQUFXO1lBQ2pCLElBQUksQ0FBQyxDQUFDOW5GLFNBQVMsQ0FBQ2xMLE1BQU0sR0FBRztZQUN6QixJQUFJLENBQUMsQ0FBQ2tMLFNBQVMsQ0FBQ3J3QyxLQUFLLENBQUM0NEQsTUFBTSxHQUFHNTZELFNBQVMsSUFBSSxDQUFDLENBQUNxeUMsU0FBUyxDQUFDcndDLEtBQUssQ0FBQzQ0RCxNQUFNLElBQUk7UUFDMUUsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDaStELE1BQU0sRUFBRTtZQUN2QixJQUFJLENBQUMsQ0FBQ3htRixTQUFTLENBQUM5QixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1FBQ2hDO0lBQ0Y7SUFDQSxDQUFDbXJDLElBQUk7UUFDSCxJQUFJLENBQUMsQ0FBQ2pELFNBQVMsQ0FBQzlCLFNBQVMsQ0FBQzdtQyxNQUFNLENBQUM7UUFDakMsSUFBSSxJQUFJLENBQUMsQ0FBQ212SCxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUNuNUIsU0FBUyxFQUFFO1lBQ25DO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQ3J0RCxTQUFTLENBQUNsTCxNQUFNLEdBQUc7UUFDekIsSUFBSSxDQUFDLENBQUNrTCxTQUFTLENBQUNyd0MsS0FBSyxDQUFDNDRELE1BQU0sR0FBRzU2RCxTQUFTLElBQUksQ0FBQyxDQUFDcXlDLFNBQVMsQ0FBQ3J3QyxLQUFLLENBQUM0NEQsTUFBTSxJQUFJO0lBQzFFO0lBQ0FvMUQsWUFBWTtRQUNWLElBQUksQ0FBQyxDQUFDZ0osVUFBVSxHQUFHLElBQUksQ0FBQ3Q1QixTQUFTO1FBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ3M1QixVQUFVLEVBQUU7WUFDckI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDM21GLFNBQVMsQ0FBQ2xMLE1BQU0sR0FBRztJQUMzQjtJQUNBNG9GLFlBQVk7UUFDVixJQUFJLElBQUksQ0FBQyxDQUFDcHlFLGNBQWMsRUFBRTtZQUN4QjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUN3N0UsaUJBQWlCO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ0gsVUFBVSxFQUFFO1lBQ3JCO1FBQ0Y7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMxMEQsS0FBSyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxDQUFDOXVCLElBQUk7UUFDWjtRQUNBLElBQUksQ0FBQyxDQUFDd2pGLFVBQVUsR0FBRztRQUNuQixJQUFJLENBQUMsQ0FBQzNtRixTQUFTLENBQUNsTCxNQUFNLEdBQUc7SUFDM0I7SUFDQSxJQUFJdTRELFlBQVk7UUFDZCxJQUFJLElBQUksQ0FBQyxDQUFDL2hELGNBQWMsRUFBRTtZQUN4QixPQUFPO1FBQ1Q7UUFDQSxPQUFPLElBQUksQ0FBQyxDQUFDdEwsU0FBUyxDQUFDbEwsTUFBTSxLQUFLO0lBQ3BDO0FBQ0Y7QUFDQSxNQUFNdWlGLGtDQUFrQ2M7SUFDdEM5eUgsWUFBWXd1QyxVQUFVLENBQUU7UUFDdEIsS0FBSyxDQUFDQSxZQUFZO1lBQ2hCMGtGLGNBQWM7WUFDZEMsY0FBYztRQUNoQjtRQUNBLElBQUksQ0FBQzltRixXQUFXLEdBQUdtQyxXQUFXcmhDLElBQUksQ0FBQ2svQixXQUFXO1FBQzlDLElBQUksQ0FBQzAyRixZQUFZLEdBQUd2MEYsV0FBV3JoQyxJQUFJLENBQUM0MUgsWUFBWTtRQUNoRCxJQUFJLENBQUNwSyxvQkFBb0IsR0FBRy9uRyxxQkFBcUJFLFFBQVE7SUFDM0Q7SUFDQXlkLFNBQVM7UUFDUCxJQUFJLENBQUNvTSxTQUFTLENBQUM5QixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1FBQzdCLElBQUksSUFBSSxDQUFDNDVCLFdBQVcsRUFBRTtZQUNwQixNQUFNMWlDLFVBQVVnQixTQUFTMkksYUFBYSxDQUFDO1lBQ3ZDM0osUUFBUWt2QyxTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1lBQ3RCOUksUUFBUTRqQyxZQUFZLENBQUMsUUFBUTtZQUM3QixLQUFLLE1BQU13TixRQUFRLElBQUksQ0FBQzFPLFdBQVcsQ0FBRTtnQkFDbkMsTUFBTTIyRixXQUFXcjRILFNBQVMySSxhQUFhLENBQUM7Z0JBQ3hDMHZILFNBQVMzMkYsV0FBVyxHQUFHME87Z0JBQ3ZCcHhDLFFBQVErTSxNQUFNLENBQUNzc0g7WUFDakI7WUFDQSxJQUFJLENBQUNyb0YsU0FBUyxDQUFDamtDLE1BQU0sQ0FBQy9NO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ3dELElBQUksQ0FBQ2tvRCxRQUFRLElBQUksSUFBSSxDQUFDNitELFlBQVksRUFBRTtZQUM1QyxJQUFJLENBQUNZLFlBQVk7UUFDbkI7UUFDQSxJQUFJLENBQUM0RCxrQkFBa0I7UUFDdkIsT0FBTyxJQUFJLENBQUMvOUUsU0FBUztJQUN2QjtBQUNGO0FBQ0EsTUFBTXMzRSw4QkFBOEJhO0lBQ2xDLENBQUMvM0UsSUFBSSxDQUFRO0lBQ2IvNkMsWUFBWXd1QyxVQUFVLENBQUU7UUFDdEIsS0FBSyxDQUFDQSxZQUFZO1lBQ2hCMGtGLGNBQWM7WUFDZEMsY0FBYztRQUNoQjthQUxGLENBQUNwNEUsSUFBSSxHQUFHO0lBTVI7SUFDQXhNLFNBQVM7UUFDUCxJQUFJLENBQUNvTSxTQUFTLENBQUM5QixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1FBQzdCLE1BQU0sRUFDSnRGLElBQUksRUFDSjRrQyxLQUFLLEVBQ0xDLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixNQUFNaVAsTUFBTSxJQUFJLENBQUN1eUUsVUFBVSxDQUFDeG9ILE1BQU0sQ0FBQyttQyxPQUFPQyxRQUFRO1FBQ2xELE1BQU0rSSxPQUFPLElBQUksQ0FBQyxDQUFDQSxJQUFJLEdBQUcsSUFBSSxDQUFDeTRFLFVBQVUsQ0FBQ2xnSCxhQUFhLENBQUM7UUFDeER5bkMsS0FBS3hOLFlBQVksQ0FBQyxNQUFNcGdDLEtBQUt1M0IsSUFBSSxDQUFDLEVBQUUsR0FBR3YzQixLQUFLODFILGVBQWUsQ0FBQyxFQUFFO1FBQzlEbG9GLEtBQUt4TixZQUFZLENBQUMsTUFBTXBnQyxLQUFLdTNCLElBQUksQ0FBQyxFQUFFLEdBQUd2M0IsS0FBSzgxSCxlQUFlLENBQUMsRUFBRTtRQUM5RGxvRixLQUFLeE4sWUFBWSxDQUFDLE1BQU1wZ0MsS0FBS3UzQixJQUFJLENBQUMsRUFBRSxHQUFHdjNCLEtBQUs4MUgsZUFBZSxDQUFDLEVBQUU7UUFDOURsb0YsS0FBS3hOLFlBQVksQ0FBQyxNQUFNcGdDLEtBQUt1M0IsSUFBSSxDQUFDLEVBQUUsR0FBR3YzQixLQUFLODFILGVBQWUsQ0FBQyxFQUFFO1FBQzlEbG9GLEtBQUt4TixZQUFZLENBQUMsZ0JBQWdCcGdDLEtBQUtpb0gsV0FBVyxDQUFDcmpGLEtBQUssSUFBSTtRQUM1RGdKLEtBQUt4TixZQUFZLENBQUMsVUFBVTtRQUM1QndOLEtBQUt4TixZQUFZLENBQUMsUUFBUTtRQUMxQjBULElBQUl2cUMsTUFBTSxDQUFDcWtDO1FBQ1gsSUFBSSxDQUFDSixTQUFTLENBQUNqa0MsTUFBTSxDQUFDdXFDO1FBQ3RCLElBQUksQ0FBQzl6QyxLQUFLa29ELFFBQVEsSUFBSSxJQUFJLENBQUM2K0QsWUFBWSxFQUFFO1lBQ3ZDLElBQUksQ0FBQ1ksWUFBWTtRQUNuQjtRQUNBLE9BQU8sSUFBSSxDQUFDbjZFLFNBQVM7SUFDdkI7SUFDQTQ5RSw0QkFBNEI7UUFDMUIsT0FBTyxJQUFJLENBQUMsQ0FBQ3g5RSxJQUFJO0lBQ25CO0lBQ0F5OUUsbUJBQW1CO1FBQ2pCLElBQUksQ0FBQzc5RSxTQUFTLENBQUM5QixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO0lBQy9CO0FBQ0Y7QUFDQSxNQUFNeS9HLGdDQUFnQ1k7SUFDcEMsQ0FBQ29RLE1BQU0sQ0FBUTtJQUNmbGpJLFlBQVl3dUMsVUFBVSxDQUFFO1FBQ3RCLEtBQUssQ0FBQ0EsWUFBWTtZQUNoQjBrRixjQUFjO1lBQ2RDLGNBQWM7UUFDaEI7YUFMRixDQUFDK1AsTUFBTSxHQUFHO0lBTVY7SUFDQTMwRixTQUFTO1FBQ1AsSUFBSSxDQUFDb00sU0FBUyxDQUFDOUIsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztRQUM3QixNQUFNLEVBQ0p0RixJQUFJLEVBQ0o0a0MsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBRyxJQUFJO1FBQ1IsTUFBTWlQLE1BQU0sSUFBSSxDQUFDdXlFLFVBQVUsQ0FBQ3hvSCxNQUFNLENBQUMrbUMsT0FBT0MsUUFBUTtRQUNsRCxNQUFNcWpGLGNBQWNsb0gsS0FBS2lvSCxXQUFXLENBQUNyakYsS0FBSztRQUMxQyxNQUFNbXhGLFNBQVMsSUFBSSxDQUFDLENBQUNBLE1BQU0sR0FBRyxJQUFJLENBQUMxUCxVQUFVLENBQUNsZ0gsYUFBYSxDQUFDO1FBQzVENHZILE9BQU8zMUYsWUFBWSxDQUFDLEtBQUs4bkYsY0FBYztRQUN2QzZOLE9BQU8zMUYsWUFBWSxDQUFDLEtBQUs4bkYsY0FBYztRQUN2QzZOLE9BQU8zMUYsWUFBWSxDQUFDLFNBQVN3RSxRQUFRc2pGO1FBQ3JDNk4sT0FBTzMxRixZQUFZLENBQUMsVUFBVXlFLFNBQVNxakY7UUFDdkM2TixPQUFPMzFGLFlBQVksQ0FBQyxnQkFBZ0I4bkYsZUFBZTtRQUNuRDZOLE9BQU8zMUYsWUFBWSxDQUFDLFVBQVU7UUFDOUIyMUYsT0FBTzMxRixZQUFZLENBQUMsUUFBUTtRQUM1QjBULElBQUl2cUMsTUFBTSxDQUFDd3NIO1FBQ1gsSUFBSSxDQUFDdm9GLFNBQVMsQ0FBQ2prQyxNQUFNLENBQUN1cUM7UUFDdEIsSUFBSSxDQUFDOXpDLEtBQUtrb0QsUUFBUSxJQUFJLElBQUksQ0FBQzYrRCxZQUFZLEVBQUU7WUFDdkMsSUFBSSxDQUFDWSxZQUFZO1FBQ25CO1FBQ0EsT0FBTyxJQUFJLENBQUNuNkUsU0FBUztJQUN2QjtJQUNBNDlFLDRCQUE0QjtRQUMxQixPQUFPLElBQUksQ0FBQyxDQUFDMkssTUFBTTtJQUNyQjtJQUNBMUssbUJBQW1CO1FBQ2pCLElBQUksQ0FBQzc5RSxTQUFTLENBQUM5QixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO0lBQy9CO0FBQ0Y7QUFDQSxNQUFNMC9HLGdDQUFnQ1c7SUFDcEMsQ0FBQ3FRLE1BQU0sQ0FBUTtJQUNmbmpJLFlBQVl3dUMsVUFBVSxDQUFFO1FBQ3RCLEtBQUssQ0FBQ0EsWUFBWTtZQUNoQjBrRixjQUFjO1lBQ2RDLGNBQWM7UUFDaEI7YUFMRixDQUFDZ1EsTUFBTSxHQUFHO0lBTVY7SUFDQTUwRixTQUFTO1FBQ1AsSUFBSSxDQUFDb00sU0FBUyxDQUFDOUIsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztRQUM3QixNQUFNLEVBQ0p0RixJQUFJLEVBQ0o0a0MsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBRyxJQUFJO1FBQ1IsTUFBTWlQLE1BQU0sSUFBSSxDQUFDdXlFLFVBQVUsQ0FBQ3hvSCxNQUFNLENBQUMrbUMsT0FBT0MsUUFBUTtRQUNsRCxNQUFNcWpGLGNBQWNsb0gsS0FBS2lvSCxXQUFXLENBQUNyakYsS0FBSztRQUMxQyxNQUFNb3hGLFNBQVMsSUFBSSxDQUFDLENBQUNBLE1BQU0sR0FBRyxJQUFJLENBQUMzUCxVQUFVLENBQUNsZ0gsYUFBYSxDQUFDO1FBQzVENnZILE9BQU81MUYsWUFBWSxDQUFDLE1BQU13RSxRQUFRO1FBQ2xDb3hGLE9BQU81MUYsWUFBWSxDQUFDLE1BQU15RSxTQUFTO1FBQ25DbXhGLE9BQU81MUYsWUFBWSxDQUFDLE1BQU13RSxRQUFRLElBQUlzakYsY0FBYztRQUNwRDhOLE9BQU81MUYsWUFBWSxDQUFDLE1BQU15RSxTQUFTLElBQUlxakYsY0FBYztRQUNyRDhOLE9BQU81MUYsWUFBWSxDQUFDLGdCQUFnQjhuRixlQUFlO1FBQ25EOE4sT0FBTzUxRixZQUFZLENBQUMsVUFBVTtRQUM5QjQxRixPQUFPNTFGLFlBQVksQ0FBQyxRQUFRO1FBQzVCMFQsSUFBSXZxQyxNQUFNLENBQUN5c0g7UUFDWCxJQUFJLENBQUN4b0YsU0FBUyxDQUFDamtDLE1BQU0sQ0FBQ3VxQztRQUN0QixJQUFJLENBQUM5ekMsS0FBS2tvRCxRQUFRLElBQUksSUFBSSxDQUFDNitELFlBQVksRUFBRTtZQUN2QyxJQUFJLENBQUNZLFlBQVk7UUFDbkI7UUFDQSxPQUFPLElBQUksQ0FBQ242RSxTQUFTO0lBQ3ZCO0lBQ0E0OUUsNEJBQTRCO1FBQzFCLE9BQU8sSUFBSSxDQUFDLENBQUM0SyxNQUFNO0lBQ3JCO0lBQ0EzSyxtQkFBbUI7UUFDakIsSUFBSSxDQUFDNzlFLFNBQVMsQ0FBQzlCLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7SUFDL0I7QUFDRjtBQUNBLE1BQU0yL0csa0NBQWtDVTtJQUN0QyxDQUFDc1EsUUFBUSxDQUFRO0lBQ2pCcGpJLFlBQVl3dUMsVUFBVSxDQUFFO1FBQ3RCLEtBQUssQ0FBQ0EsWUFBWTtZQUNoQjBrRixjQUFjO1lBQ2RDLGNBQWM7UUFDaEI7YUFMRixDQUFDaVEsUUFBUSxHQUFHO1FBTVYsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNDLGNBQWMsR0FBRztJQUN4QjtJQUNBLzBGLFNBQVM7UUFDUCxJQUFJLENBQUNvTSxTQUFTLENBQUM5QixTQUFTLENBQUNwbUMsR0FBRyxDQUFDLElBQUksQ0FBQzR3SCxrQkFBa0I7UUFDcEQsTUFBTSxFQUNKbDJILE1BQU0sRUFDSnUzQixJQUFJLEVBQ0o2K0YsUUFBUSxFQUNSbk8sV0FBVyxFQUNYLy9ELFFBQVEsRUFDVCxFQUNEdGpCLEtBQUssRUFDTEMsTUFBTSxFQUNQLEdBQUcsSUFBSTtRQUNSLElBQUksQ0FBQ3V4RixVQUFVO1lBQ2IsT0FBTyxJQUFJLENBQUM1b0YsU0FBUztRQUN2QjtRQUNBLE1BQU1zRyxNQUFNLElBQUksQ0FBQ3V5RSxVQUFVLENBQUN4b0gsTUFBTSxDQUFDK21DLE9BQU9DLFFBQVE7UUFDbEQsSUFBSXd4RixTQUFTLEVBQUU7UUFDZixJQUFLLElBQUlqaUksSUFBSSxHQUFHaW5DLEtBQUsrNkYsU0FBUzNtSSxNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsS0FBSyxFQUFHO1lBQ3BELE1BQU1nQyxJQUFJZ2dJLFFBQVEsQ0FBQ2hpSSxFQUFFLEdBQUdtakMsSUFBSSxDQUFDLEVBQUU7WUFDL0IsTUFBTXowQixJQUFJeTBCLElBQUksQ0FBQyxFQUFFLEdBQUc2K0YsUUFBUSxDQUFDaGlJLElBQUksRUFBRTtZQUNuQ2lpSSxPQUFPMzdILElBQUksQ0FBQyxDQUFDLEVBQUV0RSxFQUFFLENBQUMsRUFBRTBNLEVBQUUsQ0FBQztRQUN6QjtRQUNBdXpILFNBQVNBLE9BQU9ua0ksSUFBSSxDQUFDO1FBQ3JCLE1BQU0rakksV0FBVyxJQUFJLENBQUMsQ0FBQ0EsUUFBUSxHQUFHLElBQUksQ0FBQzVQLFVBQVUsQ0FBQ2xnSCxhQUFhLENBQUMsSUFBSSxDQUFDZ3dILGNBQWM7UUFDbkZGLFNBQVM3MUYsWUFBWSxDQUFDLFVBQVVpMkY7UUFDaENKLFNBQVM3MUYsWUFBWSxDQUFDLGdCQUFnQjZuRixZQUFZcmpGLEtBQUssSUFBSTtRQUMzRHF4RixTQUFTNzFGLFlBQVksQ0FBQyxVQUFVO1FBQ2hDNjFGLFNBQVM3MUYsWUFBWSxDQUFDLFFBQVE7UUFDOUIwVCxJQUFJdnFDLE1BQU0sQ0FBQzBzSDtRQUNYLElBQUksQ0FBQ3pvRixTQUFTLENBQUNqa0MsTUFBTSxDQUFDdXFDO1FBQ3RCLElBQUksQ0FBQ29VLFlBQVksSUFBSSxDQUFDNitELFlBQVksRUFBRTtZQUNsQyxJQUFJLENBQUNZLFlBQVk7UUFDbkI7UUFDQSxPQUFPLElBQUksQ0FBQ242RSxTQUFTO0lBQ3ZCO0lBQ0E0OUUsNEJBQTRCO1FBQzFCLE9BQU8sSUFBSSxDQUFDLENBQUM2SyxRQUFRO0lBQ3ZCO0lBQ0E1SyxtQkFBbUI7UUFDakIsSUFBSSxDQUFDNzlFLFNBQVMsQ0FBQzlCLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7SUFDL0I7QUFDRjtBQUNBLE1BQU04L0csaUNBQWlDSDtJQUNyQ3B5SCxZQUFZd3VDLFVBQVUsQ0FBRTtRQUN0QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDNjBGLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO0lBQ3hCO0FBQ0Y7QUFDQSxNQUFNalIsK0JBQStCUztJQUNuQzl5SCxZQUFZd3VDLFVBQVUsQ0FBRTtRQUN0QixLQUFLLENBQUNBLFlBQVk7WUFDaEIwa0YsY0FBYztZQUNkQyxjQUFjO1FBQ2hCO0lBQ0Y7SUFDQTVrRixTQUFTO1FBQ1AsSUFBSSxDQUFDb00sU0FBUyxDQUFDOUIsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztRQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDdEYsSUFBSSxDQUFDa29ELFFBQVEsSUFBSSxJQUFJLENBQUM2K0QsWUFBWSxFQUFFO1lBQzVDLElBQUksQ0FBQ1ksWUFBWTtRQUNuQjtRQUNBLE9BQU8sSUFBSSxDQUFDbjZFLFNBQVM7SUFDdkI7QUFDRjtBQUNBLE1BQU0yM0UsNkJBQTZCUTtJQUNqQyxDQUFDMlEscUJBQXFCLENBQVE7SUFDOUIsQ0FBQ0MsU0FBUyxDQUFNO0lBQ2hCMWpJLFlBQVl3dUMsVUFBVSxDQUFFO1FBQ3RCLEtBQUssQ0FBQ0EsWUFBWTtZQUNoQjBrRixjQUFjO1lBQ2RDLGNBQWM7UUFDaEI7YUFORixDQUFDc1EscUJBQXFCLEdBQUc7YUFDekIsQ0FBQ0MsU0FBUyxHQUFHLEVBQUU7UUFNYixJQUFJLENBQUNMLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQzNLLG9CQUFvQixHQUFHLElBQUksQ0FBQ3hySCxJQUFJLENBQUNuUixFQUFFLEtBQUssaUJBQWlCNDBCLHFCQUFxQkcsU0FBUyxHQUFHSCxxQkFBcUJLLEdBQUc7SUFDekg7SUFDQSxDQUFDdWxCLFlBQVksQ0FBQ3JGLFFBQVEsRUFBRXpNLElBQUk7UUFDMUIsT0FBUXlNO1lBQ04sS0FBSztnQkFDSCxPQUFPO29CQUNMNVgsV0FBVyxDQUFDLHFCQUFxQixFQUFFLENBQUNtTCxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRUEsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUM7b0JBQ3JFcU4sT0FBT3JOLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFO29CQUN4QnNOLFFBQVF0TixJQUFJLENBQUMsRUFBRSxHQUFHQSxJQUFJLENBQUMsRUFBRTtnQkFDM0I7WUFDRixLQUFLO2dCQUNILE9BQU87b0JBQ0xuTCxXQUFXLENBQUMsc0JBQXNCLEVBQUUsQ0FBQ21MLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFQSxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQztvQkFDdEVxTixPQUFPck4sSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUU7b0JBQ3hCc04sUUFBUXROLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFO2dCQUMzQjtZQUNGLEtBQUs7Z0JBQ0gsT0FBTztvQkFDTG5MLFdBQVcsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDbUwsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUVBLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDO29CQUN0RXFOLE9BQU9yTixJQUFJLENBQUMsRUFBRSxHQUFHQSxJQUFJLENBQUMsRUFBRTtvQkFDeEJzTixRQUFRdE4sSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUU7Z0JBQzNCO1lBQ0Y7Z0JBQ0UsT0FBTztvQkFDTG5MLFdBQVcsQ0FBQyxVQUFVLEVBQUUsQ0FBQ21MLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFQSxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQztvQkFDMURxTixPQUFPck4sSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUU7b0JBQ3hCc04sUUFBUXROLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFO2dCQUMzQjtRQUNKO0lBQ0Y7SUFDQTZKLFNBQVM7UUFDUCxJQUFJLENBQUNvTSxTQUFTLENBQUM5QixTQUFTLENBQUNwbUMsR0FBRyxDQUFDLElBQUksQ0FBQzR3SCxrQkFBa0I7UUFDcEQsTUFBTSxFQUNKbDJILE1BQU0sRUFDSnUzQixJQUFJLEVBQ0p5TSxRQUFRLEVBQ1JxakYsUUFBUSxFQUNSWSxXQUFXLEVBQ1gvL0QsUUFBUSxFQUNULEVBQ0YsR0FBRyxJQUFJO1FBQ1IsTUFBTSxFQUNKOTdCLFNBQVMsRUFDVHdZLEtBQUssRUFDTEMsTUFBTSxFQUNQLEdBQUcsSUFBSSxDQUFDLENBQUN3RSxZQUFZLENBQUNyRixVQUFVek07UUFDakMsTUFBTXVjLE1BQU0sSUFBSSxDQUFDdXlFLFVBQVUsQ0FBQ3hvSCxNQUFNLENBQUMrbUMsT0FBT0MsUUFBUTtRQUNsRCxNQUFNN08sSUFBSSxJQUFJLENBQUMsQ0FBQ3NnRyxxQkFBcUIsR0FBRyxJQUFJLENBQUNqUSxVQUFVLENBQUNsZ0gsYUFBYSxDQUFDO1FBQ3RFMnRDLElBQUl2cUMsTUFBTSxDQUFDeXNCO1FBQ1hBLEVBQUVvSyxZQUFZLENBQUMsZ0JBQWdCNm5GLFlBQVlyakYsS0FBSyxJQUFJO1FBQ3BENU8sRUFBRW9LLFlBQVksQ0FBQyxrQkFBa0I7UUFDakNwSyxFQUFFb0ssWUFBWSxDQUFDLG1CQUFtQjtRQUNsQ3BLLEVBQUVvSyxZQUFZLENBQUMscUJBQXFCO1FBQ3BDcEssRUFBRW9LLFlBQVksQ0FBQyxVQUFVO1FBQ3pCcEssRUFBRW9LLFlBQVksQ0FBQyxRQUFRO1FBQ3ZCcEssRUFBRW9LLFlBQVksQ0FBQyxhQUFhaFU7UUFDNUIsSUFBSyxJQUFJaDRCLElBQUksR0FBR2luQyxLQUFLZ3NGLFNBQVM1M0gsTUFBTSxFQUFFMkUsSUFBSWluQyxJQUFJam5DLElBQUs7WUFDakQsTUFBTTZoSSxXQUFXLElBQUksQ0FBQzVQLFVBQVUsQ0FBQ2xnSCxhQUFhLENBQUMsSUFBSSxDQUFDZ3dILGNBQWM7WUFDbEUsSUFBSSxDQUFDLENBQUNJLFNBQVMsQ0FBQzc3SCxJQUFJLENBQUN1N0g7WUFDckJBLFNBQVM3MUYsWUFBWSxDQUFDLFVBQVVpbkYsUUFBUSxDQUFDanpILEVBQUUsQ0FBQ2xDLElBQUksQ0FBQztZQUNqRDhqQyxFQUFFenNCLE1BQU0sQ0FBQzBzSDtRQUNYO1FBQ0EsSUFBSSxDQUFDL3RFLFlBQVksSUFBSSxDQUFDNitELFlBQVksRUFBRTtZQUNsQyxJQUFJLENBQUNZLFlBQVk7UUFDbkI7UUFDQSxJQUFJLENBQUNuNkUsU0FBUyxDQUFDamtDLE1BQU0sQ0FBQ3VxQztRQUN0QixJQUFJLENBQUN5M0Usa0JBQWtCO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLzlFLFNBQVM7SUFDdkI7SUFDQTIyQixhQUFhejZELE1BQU0sRUFBRTtRQUNuQixLQUFLLENBQUN5NkQsYUFBYXo2RDtRQUNuQixNQUFNLEVBQ0o4c0gsU0FBUyxFQUNUSCxNQUFNLEVBQ045K0YsSUFBSSxFQUNMLEdBQUc3dEI7UUFDSixNQUFNc3NCLElBQUksSUFBSSxDQUFDLENBQUNzZ0cscUJBQXFCO1FBQ3JDLElBQUlFLGFBQWEsR0FBRztZQUNsQnhnRyxFQUFFb0ssWUFBWSxDQUFDLGdCQUFnQm8yRixhQUFhO1FBQzlDO1FBQ0EsSUFBSUgsUUFBUTtZQUNWLElBQUssSUFBSWppSSxJQUFJLEdBQUdpbkMsS0FBSyxJQUFJLENBQUMsQ0FBQ2s3RixTQUFTLENBQUM5bUksTUFBTSxFQUFFMkUsSUFBSWluQyxJQUFJam5DLElBQUs7Z0JBQ3hELElBQUksQ0FBQyxDQUFDbWlJLFNBQVMsQ0FBQ25pSSxFQUFFLENBQUNnc0MsWUFBWSxDQUFDLFVBQVVpMkYsTUFBTSxDQUFDamlJLEVBQUUsQ0FBQ2xDLElBQUksQ0FBQztZQUMzRDtRQUNGO1FBQ0EsSUFBSXFsQyxNQUFNO1lBQ1IsTUFBTSxFQUNKbkwsU0FBUyxFQUNUd1ksS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBRyxJQUFJLENBQUMsQ0FBQ3dFLFlBQVksQ0FBQyxJQUFJLENBQUNycEMsSUFBSSxDQUFDZ2tDLFFBQVEsRUFBRXpNO1lBQzNDLE1BQU1qZCxPQUFPMGIsRUFBRWtzQixhQUFhO1lBQzVCNW5DLEtBQUs4bEIsWUFBWSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUV3RSxNQUFNLENBQUMsRUFBRUMsT0FBTyxDQUFDO1lBQ3JEN08sRUFBRW9LLFlBQVksQ0FBQyxhQUFhaFU7UUFDOUI7SUFDRjtJQUNBZy9GLDRCQUE0QjtRQUMxQixPQUFPLElBQUksQ0FBQyxDQUFDbUwsU0FBUztJQUN4QjtJQUNBbEwsbUJBQW1CO1FBQ2pCLElBQUksQ0FBQzc5RSxTQUFTLENBQUM5QixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO0lBQy9CO0FBQ0Y7QUFDQSxNQUFNKy9HLG1DQUFtQ007SUFDdkM5eUgsWUFBWXd1QyxVQUFVLENBQUU7UUFDdEIsS0FBSyxDQUFDQSxZQUFZO1lBQ2hCMGtGLGNBQWM7WUFDZEMsY0FBYztZQUNkQyxzQkFBc0I7UUFDeEI7UUFDQSxJQUFJLENBQUN1RixvQkFBb0IsR0FBRy9uRyxxQkFBcUJHLFNBQVM7SUFDNUQ7SUFDQXdkLFNBQVM7UUFDUCxNQUFNLEVBQ0pwaEMsTUFBTSxFQUNKZ3NILFlBQVksRUFDWjlqRSxRQUFRLEVBQ1QsRUFDRixHQUFHLElBQUk7UUFDUixJQUFJLENBQUNBLFlBQVksSUFBSSxDQUFDNitELFlBQVksRUFBRTtZQUNsQyxJQUFJLENBQUNZLFlBQVk7UUFDbkI7UUFDQSxJQUFJLENBQUNuNkUsU0FBUyxDQUFDOUIsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztRQUM3QixJQUFJLENBQUNpbUgsa0JBQWtCO1FBQ3ZCLElBQUlTLGNBQWM7WUFDaEIsTUFBTXlLLE9BQU9qNUgsU0FBUzJJLGFBQWEsQ0FBQztZQUNwQ3N3SCxLQUFLL3FGLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7WUFDbkJteEgsS0FBS3YzRixXQUFXLEdBQUc4c0Y7WUFDbkIsSUFBSSxDQUFDeCtFLFNBQVMsQ0FBQ2prQyxNQUFNLENBQUNrdEg7UUFDeEI7UUFDQSxPQUFPLElBQUksQ0FBQ2pwRixTQUFTO0lBQ3ZCO0FBQ0Y7QUFDQSxNQUFNODNFLG1DQUFtQ0s7SUFDdkM5eUgsWUFBWXd1QyxVQUFVLENBQUU7UUFDdEIsS0FBSyxDQUFDQSxZQUFZO1lBQ2hCMGtGLGNBQWM7WUFDZEMsY0FBYztZQUNkQyxzQkFBc0I7UUFDeEI7SUFDRjtJQUNBN2tGLFNBQVM7UUFDUCxNQUFNLEVBQ0pwaEMsTUFBTSxFQUNKZ3NILFlBQVksRUFDWjlqRSxRQUFRLEVBQ1QsRUFDRixHQUFHLElBQUk7UUFDUixJQUFJLENBQUNBLFlBQVksSUFBSSxDQUFDNitELFlBQVksRUFBRTtZQUNsQyxJQUFJLENBQUNZLFlBQVk7UUFDbkI7UUFDQSxJQUFJLENBQUNuNkUsU0FBUyxDQUFDOUIsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztRQUM3QixJQUFJMG1ILGNBQWM7WUFDaEIsTUFBTTBLLFlBQVlsNUgsU0FBUzJJLGFBQWEsQ0FBQztZQUN6Q3V3SCxVQUFVaHJGLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7WUFDeEJveEgsVUFBVXgzRixXQUFXLEdBQUc4c0Y7WUFDeEIsSUFBSSxDQUFDeCtFLFNBQVMsQ0FBQ2prQyxNQUFNLENBQUNtdEg7UUFDeEI7UUFDQSxPQUFPLElBQUksQ0FBQ2xwRixTQUFTO0lBQ3ZCO0FBQ0Y7QUFDQSxNQUFNKzNFLGtDQUFrQ0k7SUFDdEM5eUgsWUFBWXd1QyxVQUFVLENBQUU7UUFDdEIsS0FBSyxDQUFDQSxZQUFZO1lBQ2hCMGtGLGNBQWM7WUFDZEMsY0FBYztZQUNkQyxzQkFBc0I7UUFDeEI7SUFDRjtJQUNBN2tGLFNBQVM7UUFDUCxNQUFNLEVBQ0pwaEMsTUFBTSxFQUNKZ3NILFlBQVksRUFDWjlqRSxRQUFRLEVBQ1QsRUFDRixHQUFHLElBQUk7UUFDUixJQUFJLENBQUNBLFlBQVksSUFBSSxDQUFDNitELFlBQVksRUFBRTtZQUNsQyxJQUFJLENBQUNZLFlBQVk7UUFDbkI7UUFDQSxJQUFJLENBQUNuNkUsU0FBUyxDQUFDOUIsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztRQUM3QixJQUFJMG1ILGNBQWM7WUFDaEIsTUFBTTBLLFlBQVlsNUgsU0FBUzJJLGFBQWEsQ0FBQztZQUN6Q3V3SCxVQUFVaHJGLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7WUFDeEJveEgsVUFBVXgzRixXQUFXLEdBQUc4c0Y7WUFDeEIsSUFBSSxDQUFDeCtFLFNBQVMsQ0FBQ2prQyxNQUFNLENBQUNtdEg7UUFDeEI7UUFDQSxPQUFPLElBQUksQ0FBQ2xwRixTQUFTO0lBQ3ZCO0FBQ0Y7QUFDQSxNQUFNZzRFLG1DQUFtQ0c7SUFDdkM5eUgsWUFBWXd1QyxVQUFVLENBQUU7UUFDdEIsS0FBSyxDQUFDQSxZQUFZO1lBQ2hCMGtGLGNBQWM7WUFDZEMsY0FBYztZQUNkQyxzQkFBc0I7UUFDeEI7SUFDRjtJQUNBN2tGLFNBQVM7UUFDUCxNQUFNLEVBQ0pwaEMsTUFBTSxFQUNKZ3NILFlBQVksRUFDWjlqRSxRQUFRLEVBQ1QsRUFDRixHQUFHLElBQUk7UUFDUixJQUFJLENBQUNBLFlBQVksSUFBSSxDQUFDNitELFlBQVksRUFBRTtZQUNsQyxJQUFJLENBQUNZLFlBQVk7UUFDbkI7UUFDQSxJQUFJLENBQUNuNkUsU0FBUyxDQUFDOUIsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztRQUM3QixJQUFJMG1ILGNBQWM7WUFDaEIsTUFBTTJLLFlBQVluNUgsU0FBUzJJLGFBQWEsQ0FBQztZQUN6Q3d3SCxVQUFVanJGLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7WUFDeEJxeEgsVUFBVXozRixXQUFXLEdBQUc4c0Y7WUFDeEIsSUFBSSxDQUFDeCtFLFNBQVMsQ0FBQ2prQyxNQUFNLENBQUNvdEg7UUFDeEI7UUFDQSxPQUFPLElBQUksQ0FBQ25wRixTQUFTO0lBQ3ZCO0FBQ0Y7QUFDQSxNQUFNaTRFLCtCQUErQkU7SUFDbkM5eUgsWUFBWXd1QyxVQUFVLENBQUU7UUFDdEIsS0FBSyxDQUFDQSxZQUFZO1lBQ2hCMGtGLGNBQWM7WUFDZEMsY0FBYztRQUNoQjtRQUNBLElBQUksQ0FBQ3dGLG9CQUFvQixHQUFHL25HLHFCQUFxQkksS0FBSztJQUN4RDtJQUNBdWQsU0FBUztRQUNQLElBQUksQ0FBQ29NLFNBQVMsQ0FBQzlCLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7UUFDN0IsSUFBSSxDQUFDa29DLFNBQVMsQ0FBQ3BOLFlBQVksQ0FBQyxRQUFRO1FBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUNwZ0MsSUFBSSxDQUFDa29ELFFBQVEsSUFBSSxJQUFJLENBQUM2K0QsWUFBWSxFQUFFO1lBQzVDLElBQUksQ0FBQ1ksWUFBWTtRQUNuQjtRQUNBLElBQUksQ0FBQzRELGtCQUFrQjtRQUN2QixPQUFPLElBQUksQ0FBQy85RSxTQUFTO0lBQ3ZCO0FBQ0Y7QUFDQSxNQUFNazRFLHdDQUF3Q0M7SUFDNUMsQ0FBQzBPLE9BQU8sQ0FBUTtJQUNoQnhoSSxZQUFZd3VDLFVBQVUsQ0FBRTtRQUN0QixLQUFLLENBQUNBLFlBQVk7WUFDaEIwa0YsY0FBYztRQUNoQjthQUpGLENBQUNzTyxPQUFPLEdBQUc7UUFLVCxNQUFNLEVBQ0oxL0UsSUFBSSxFQUNMLEdBQUcsSUFBSSxDQUFDMzBDLElBQUk7UUFDYixJQUFJLENBQUMrbEMsUUFBUSxHQUFHNE8sS0FBSzVPLFFBQVE7UUFDN0IsSUFBSSxDQUFDdnBDLE9BQU8sR0FBR200QyxLQUFLbjRDLE9BQU87UUFDM0IsSUFBSSxDQUFDcWtDLFdBQVcsQ0FBQ3liLFFBQVEsRUFBRTJFLFNBQVMsNEJBQTRCO1lBQzlEL3RELFFBQVEsSUFBSTtZQUNaLEdBQUd5aEQsSUFBSTtRQUNUO0lBQ0Y7SUFDQXZULFNBQVM7UUFDUCxJQUFJLENBQUNvTSxTQUFTLENBQUM5QixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1FBQzdCLE1BQU0sRUFDSmtvQyxTQUFTLEVBQ1R4dEMsSUFBSSxFQUNMLEdBQUcsSUFBSTtRQUNSLElBQUlxMEg7UUFDSixJQUFJcjBILEtBQUt1dkgsYUFBYSxJQUFJdnZILEtBQUswckYsU0FBUyxLQUFLLEdBQUc7WUFDOUMyb0MsVUFBVTcySCxTQUFTMkksYUFBYSxDQUFDO1FBQ25DLE9BQU87WUFDTGt1SCxVQUFVNzJILFNBQVMySSxhQUFhLENBQUM7WUFDakNrdUgsUUFBUS8ySCxHQUFHLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQzZvSCxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsYUFBYTV3SCxJQUFJLENBQUN5SyxLQUFLek4sSUFBSSxJQUFJLGNBQWMsVUFBVSxJQUFJLENBQUM7WUFDbEgsSUFBSXlOLEtBQUswckYsU0FBUyxJQUFJMXJGLEtBQUswckYsU0FBUyxHQUFHLEdBQUc7Z0JBQ3hDMm9DLFFBQVFsM0gsS0FBSyxHQUFHLENBQUMsZ0JBQWdCLEVBQUVsSCxLQUFLNjFDLEtBQUssQ0FBQzlyQyxLQUFLMHJGLFNBQVMsR0FBRyxLQUFLLEdBQUcsQ0FBQztZQUMxRTtRQUNGO1FBQ0Eyb0MsUUFBUXoxRixnQkFBZ0IsQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDZzRGLFFBQVEsQ0FBQ3BoSSxJQUFJLENBQUMsSUFBSTtRQUM3RCxJQUFJLENBQUMsQ0FBQzYrSCxPQUFPLEdBQUdBO1FBQ2hCLE1BQU0sRUFDSmgvRixLQUFLLEVBQ04sR0FBR1IsaUJBQWlCSyxRQUFRO1FBQzdCc1ksVUFBVTVPLGdCQUFnQixDQUFDLFdBQVd5ZSxDQUFBQTtZQUNwQyxJQUFJQSxJQUFJeGlELEdBQUcsS0FBSyxXQUFZdzZCLENBQUFBLFFBQVFnb0IsSUFBSTFGLE9BQU8sR0FBRzBGLElBQUkzRixPQUFPLEdBQUc7Z0JBQzlELElBQUksQ0FBQyxDQUFDay9FLFFBQVE7WUFDaEI7UUFDRjtRQUNBLElBQUksQ0FBQzUySCxLQUFLa29ELFFBQVEsSUFBSSxJQUFJLENBQUM2K0QsWUFBWSxFQUFFO1lBQ3ZDLElBQUksQ0FBQ1ksWUFBWTtRQUNuQixPQUFPO1lBQ0wwTSxRQUFRM29GLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7UUFDeEI7UUFDQWtvQyxVQUFVamtDLE1BQU0sQ0FBQzhxSDtRQUNqQixPQUFPN21GO0lBQ1Q7SUFDQTQ5RSw0QkFBNEI7UUFDMUIsT0FBTyxJQUFJLENBQUMsQ0FBQ2lKLE9BQU87SUFDdEI7SUFDQWhKLG1CQUFtQjtRQUNqQixJQUFJLENBQUM3OUUsU0FBUyxDQUFDOUIsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztJQUMvQjtJQUNBLENBQUNzeEgsUUFBUTtRQUNQLElBQUksQ0FBQzFRLGVBQWUsRUFBRStHLG1CQUFtQixJQUFJLENBQUN6d0gsT0FBTyxFQUFFLElBQUksQ0FBQ3VwQyxRQUFRO0lBQ3RFO0FBQ0Y7QUFDQSxNQUFNOHdGO0lBQ0osQ0FBQ0Msb0JBQW9CLENBQVE7SUFDN0IsQ0FBQy9uQyxtQkFBbUIsQ0FBUTtJQUM1QixDQUFDenRELGlCQUFpQixDQUFRO0lBQzFCLENBQUN5MUYsbUJBQW1CLENBQWE7SUFDakMsQ0FBQ0MsZUFBZSxDQUFRO0lBQ3hCLENBQUNuMkYsV0FBVyxDQUFRO0lBQ3BCaHVDLFlBQVksRUFDVjh1QyxHQUFHLEVBQ0htMUYsb0JBQW9CLEVBQ3BCL25DLG1CQUFtQixFQUNuQmtvQyx5QkFBeUIsRUFDekJ6NUYsSUFBSSxFQUNKb0UsUUFBUSxFQUNSbzFGLGVBQWUsRUFDZmwrRSxjQUFjLEVBQ2RqWSxXQUFXLEVBQ1hTLGlCQUFpQixFQUNsQixDQUFFO2FBakJILENBQUN3MUYsb0JBQW9CLEdBQUc7YUFDeEIsQ0FBQy9uQyxtQkFBbUIsR0FBRzthQUN2QixDQUFDenRELGlCQUFpQixHQUFHO2FBQ3JCLENBQUN5MUYsbUJBQW1CLEdBQUcsSUFBSXA2RjthQUMzQixDQUFDcTZGLGVBQWUsR0FBRzthQUNuQixDQUFDbjJGLFdBQVcsR0FBRztRQWFiLElBQUksQ0FBQ2MsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQyxDQUFDbTFGLG9CQUFvQixHQUFHQTtRQUM3QixJQUFJLENBQUMsQ0FBQy9uQyxtQkFBbUIsR0FBR0E7UUFDNUIsSUFBSSxDQUFDLENBQUNpb0MsZUFBZSxHQUFHQSxtQkFBbUI7UUFDM0MsSUFBSSxDQUFDLENBQUNuMkYsV0FBVyxHQUFHQSxlQUFlO1FBQ25DLElBQUksQ0FBQyxDQUFDUyxpQkFBaUIsR0FBR0EscUJBQXFCLElBQUlpa0M7UUFDbkQsSUFBSSxDQUFDL25DLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNvRSxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ20wQixNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNtaEUsMEJBQTBCLEdBQUdEO1FBQ2xDLElBQUksQ0FBQ3pNLGVBQWUsR0FBRzF4RSxrQkFBa0I7SUFDM0M7SUFDQXErRSx5QkFBeUI7UUFDdkIsT0FBTyxJQUFJLENBQUMsQ0FBQ0osbUJBQW1CLENBQUN0eUgsSUFBSSxHQUFHO0lBQzFDO0lBQ0EsTUFBTSxDQUFDMnlILGFBQWEsQ0FBQ3gzRixPQUFPLEVBQUV4N0IsRUFBRSxFQUFFaXpILGFBQWE7UUFDN0MsTUFBTUMsaUJBQWlCMTNGLFFBQVFpTyxVQUFVLElBQUlqTztRQUM3QyxNQUFNMmpCLGVBQWUrekUsZUFBZWx6SCxFQUFFLEdBQUcsQ0FBQyxFQUFFKzRCLGlCQUFpQixFQUFFLzRCLEdBQUcsQ0FBQztRQUNuRSxNQUFNbXpILGlCQUFpQixNQUFNLElBQUksQ0FBQyxDQUFDUCxlQUFlLEVBQUVRLGtCQUFrQmowRTtRQUN0RSxJQUFJZzBFLGdCQUFnQjtZQUNsQixLQUFLLE1BQU0sQ0FBQzE4SCxLQUFLbkssTUFBTSxJQUFJNm1JLGVBQWdCO2dCQUN6Q0QsZUFBZWwzRixZQUFZLENBQUN2bEMsS0FBS25LO1lBQ25DO1FBQ0Y7UUFDQSxJQUFJMm1JLGVBQWU7WUFDakJBLGNBQWM1K0csRUFBRSxDQUFDLENBQUMsR0FBRyswQixTQUFTLENBQUNzbkYsS0FBSyxDQUFDbDFGO1FBQ3ZDLE9BQU87WUFDTCxJQUFJLENBQUMrQixHQUFHLENBQUNwNEIsTUFBTSxDQUFDcTJCO1lBQ2hCLElBQUksQ0FBQyxDQUFDazNGLG9CQUFvQixFQUFFVyxpQkFBaUIsSUFBSSxDQUFDOTFGLEdBQUcsRUFBRS9CLFNBQVMwM0YsZ0JBQWdCO1FBQ2xGO0lBQ0Y7SUFDQSxNQUFNbDJGLE9BQU8xM0IsTUFBTSxFQUFFO1FBQ25CLE1BQU0sRUFDSmd1SCxXQUFXLEVBQ1osR0FBR2h1SDtRQUNKLE1BQU1xMEMsUUFBUSxJQUFJLENBQUNwYyxHQUFHO1FBQ3RCNkgsbUJBQW1CdVUsT0FBTyxJQUFJLENBQUNuYyxRQUFRO1FBQ3ZDLE1BQU0rMUYsa0JBQWtCLElBQUloN0Y7UUFDNUIsTUFBTWk3RixnQkFBZ0I7WUFDcEI1M0gsTUFBTTtZQUNOKzlDO1lBQ0FsZCxhQUFhLElBQUksQ0FBQyxDQUFDQSxXQUFXO1lBQzlCcWxGLGlCQUFpQng4RyxPQUFPdzhHLGVBQWU7WUFDdkNDLG9CQUFvQno4RyxPQUFPeThHLGtCQUFrQixJQUFJO1lBQ2pEQyxhQUFhMThHLE9BQU8wOEcsV0FBVyxLQUFLO1lBQ3BDQyxZQUFZLElBQUkzQztZQUNoQnBpRixtQkFBbUIsSUFBSSxDQUFDLENBQUNBLGlCQUFpQjtZQUMxQ2dsRixlQUFlNThHLE9BQU80OEcsYUFBYSxLQUFLO1lBQ3hDQyxpQkFBaUI3OEcsT0FBTzY4RyxlQUFlLEtBQUs7WUFDNUN4USxjQUFjcnNHLE9BQU9xc0csWUFBWTtZQUNqQzBRLGNBQWMvOEcsT0FBTys4RyxZQUFZO1lBQ2pDMWtGLFFBQVEsSUFBSTtZQUNacmtCLFVBQVU7UUFDWjtRQUNBLEtBQUssTUFBTTFkLFFBQVEwM0gsWUFBYTtZQUM5QixJQUFJMTNILEtBQUs2M0gsTUFBTSxFQUFFO2dCQUNmO1lBQ0Y7WUFDQSxNQUFNQyxvQkFBb0I5M0gsS0FBS3FpRSxjQUFjLEtBQUs5N0MsZUFBZXhDLEtBQUs7WUFDdEUsSUFBSSxDQUFDK3pHLG1CQUFtQjtnQkFDdEIsSUFBSTkzSCxLQUFLdTNCLElBQUksQ0FBQyxFQUFFLEtBQUt2M0IsS0FBS3UzQixJQUFJLENBQUMsRUFBRSxJQUFJdjNCLEtBQUt1M0IsSUFBSSxDQUFDLEVBQUUsS0FBS3YzQixLQUFLdTNCLElBQUksQ0FBQyxFQUFFLEVBQUU7b0JBQ2xFO2dCQUNGO1lBQ0YsT0FBTztnQkFDTCxNQUFNN1osV0FBV2k2RyxnQkFBZ0JqbUksR0FBRyxDQUFDc08sS0FBS29FLEVBQUU7Z0JBQzVDLElBQUksQ0FBQ3NaLFVBQVU7b0JBQ2I7Z0JBQ0Y7Z0JBQ0FrNkcsY0FBY2w2RyxRQUFRLEdBQUdBO1lBQzNCO1lBQ0FrNkcsY0FBYzUzSCxJQUFJLEdBQUdBO1lBQ3JCLE1BQU00L0IsVUFBVW1rRix5QkFBeUJsbUgsTUFBTSxDQUFDKzVIO1lBQ2hELElBQUksQ0FBQ2g0RixRQUFRbW1GLFlBQVksRUFBRTtnQkFDekI7WUFDRjtZQUNBLElBQUksQ0FBQytSLHFCQUFxQjkzSCxLQUFLa29ELFFBQVEsRUFBRTtnQkFDdkMsTUFBTXhxQyxXQUFXaTZHLGdCQUFnQmptSSxHQUFHLENBQUNzTyxLQUFLa29ELFFBQVE7Z0JBQ2xELElBQUksQ0FBQ3hxQyxVQUFVO29CQUNiaTZHLGdCQUFnQjMvSCxHQUFHLENBQUNnSSxLQUFLa29ELFFBQVEsRUFBRTt3QkFBQ3RvQjtxQkFBUTtnQkFDOUMsT0FBTztvQkFDTGxpQixTQUFTaGpCLElBQUksQ0FBQ2tsQztnQkFDaEI7WUFDRjtZQUNBLE1BQU1tNEYsV0FBV240RixRQUFRd0IsTUFBTTtZQUMvQixJQUFJcGhDLEtBQUtzaUMsTUFBTSxFQUFFO2dCQUNmeTFGLFNBQVM1NkgsS0FBSyxDQUFDMnJDLFVBQVUsR0FBRztZQUM5QjtZQUNBLE1BQU0sSUFBSSxDQUFDLENBQUNzdUYsYUFBYSxDQUFDVyxVQUFVLzNILEtBQUtvRSxFQUFFLEVBQUV3ekgsY0FBY2w2RyxRQUFRO1lBQ25Fa2lCLFFBQVE2cUYsaUJBQWlCLEVBQUVockQsT0FBT2tzRDtZQUNsQyxJQUFJL3JGLFFBQVFpbkYsV0FBVyxFQUFFO2dCQUN2QixJQUFJLENBQUMsQ0FBQ2tRLG1CQUFtQixDQUFDLytILEdBQUcsQ0FBQzRuQyxRQUFRNS9CLElBQUksQ0FBQ29FLEVBQUUsRUFBRXc3QjtnQkFDL0MsSUFBSSxDQUFDczNGLDBCQUEwQixFQUFFaHFFLHdCQUF3QnR0QjtZQUMzRDtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNvNEYsc0JBQXNCO0lBQzlCO0lBQ0EsTUFBTUMsbUJBQW1CUCxXQUFXLEVBQUU7UUFDcEMsTUFBTUUsZ0JBQWdCO1lBQ3BCNTNILE1BQU07WUFDTis5QyxPQUFPLElBQUksQ0FBQ3BjLEdBQUc7WUFDZmQsYUFBYSxJQUFJLENBQUMsQ0FBQ0EsV0FBVztZQUM5QndsRixZQUFZLElBQUkzQztZQUNoQjNoRixRQUFRLElBQUk7UUFDZDtRQUNBLEtBQUssTUFBTS9oQyxRQUFRMDNILFlBQWE7WUFDOUIxM0gsS0FBS2lvSCxXQUFXLEtBQUs0TyxnQkFBZ0JxQixtQkFBbUI7WUFDeEROLGNBQWM1M0gsSUFBSSxHQUFHQTtZQUNyQixNQUFNNC9CLFVBQVVta0YseUJBQXlCbG1ILE1BQU0sQ0FBQys1SDtZQUNoRCxJQUFJLENBQUNoNEYsUUFBUW1tRixZQUFZLEVBQUU7Z0JBQ3pCO1lBQ0Y7WUFDQSxNQUFNZ1MsV0FBV240RixRQUFRd0IsTUFBTTtZQUMvQixNQUFNLElBQUksQ0FBQyxDQUFDZzJGLGFBQWEsQ0FBQ1csVUFBVS8zSCxLQUFLb0UsRUFBRSxFQUFFO1FBQy9DO0lBQ0Y7SUFDQWkrQixPQUFPLEVBQ0xULFFBQVEsRUFDVCxFQUFFO1FBQ0QsTUFBTW1jLFFBQVEsSUFBSSxDQUFDcGMsR0FBRztRQUN0QixJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEI0SCxtQkFBbUJ1VSxPQUFPO1lBQ3hCL1osVUFBVXBDLFNBQVNvQyxRQUFRO1FBQzdCO1FBQ0EsSUFBSSxDQUFDLENBQUNnMEYsc0JBQXNCO1FBQzVCajZFLE1BQU16YixNQUFNLEdBQUc7SUFDakI7SUFDQSxDQUFDMDFGLHNCQUFzQjtRQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNqcEMsbUJBQW1CLEVBQUU7WUFDOUI7UUFDRjtRQUNBLE1BQU1oeEMsUUFBUSxJQUFJLENBQUNwYyxHQUFHO1FBQ3RCLEtBQUssTUFBTSxDQUFDdjlCLElBQUkydkMsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDZzdDLG1CQUFtQixDQUFFO1lBQ3BELE1BQU1udkQsVUFBVW1lLE1BQU01TCxhQUFhLENBQUMsQ0FBQyxxQkFBcUIsRUFBRS90QyxHQUFHLEVBQUUsQ0FBQztZQUNsRSxJQUFJLENBQUN3N0IsU0FBUztnQkFDWjtZQUNGO1lBQ0FtVSxPQUFPeEcsU0FBUyxHQUFHO1lBQ25CLE1BQU0sRUFDSk0sVUFBVSxFQUNYLEdBQUdqTztZQUNKLElBQUksQ0FBQ2lPLFlBQVk7Z0JBQ2ZqTyxRQUFRcjJCLE1BQU0sQ0FBQ3dxQztZQUNqQixPQUFPLElBQUlsRyxXQUFXKzFCLFFBQVEsS0FBSyxVQUFVO2dCQUMzQy8xQixXQUFXc3FGLFdBQVcsQ0FBQ3BrRjtZQUN6QixPQUFPLElBQUksQ0FBQ2xHLFdBQVduQyxTQUFTLENBQUM2UCxRQUFRLENBQUMsc0JBQXNCO2dCQUM5RDFOLFdBQVdzd0IsTUFBTSxDQUFDcHFCO1lBQ3BCLE9BQU87Z0JBQ0xsRyxXQUFXaW5GLEtBQUssQ0FBQy9nRjtZQUNuQjtZQUNBLE1BQU1xa0YscUJBQXFCLElBQUksQ0FBQyxDQUFDckIsbUJBQW1CLENBQUNybEksR0FBRyxDQUFDMFM7WUFDekQsSUFBSSxDQUFDZzBILG9CQUFvQjtnQkFDdkI7WUFDRjtZQUNBLElBQUlBLG1CQUFtQkMsWUFBWSxFQUFFO2dCQUNuQyxJQUFJLENBQUNuQiwwQkFBMEIsRUFBRTdwRSxpQkFBaUJqcEQsSUFBSXc3QixRQUFReDdCLEVBQUUsRUFBRTJ2QztnQkFDbEVxa0YsbUJBQW1CQyxZQUFZLEdBQUc7WUFDcEMsT0FBTztnQkFDTEQsbUJBQW1CcmtGLE1BQU0sR0FBR0E7WUFDOUI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDZzdDLG1CQUFtQixDQUFDOTNFLEtBQUs7SUFDakM7SUFDQXFoSCx5QkFBeUI7UUFDdkIsT0FBTzkySCxNQUFNcVcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDay9HLG1CQUFtQixDQUFDeGdILE1BQU07SUFDcEQ7SUFDQWdpSCxzQkFBc0JuMEgsRUFBRSxFQUFFO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLENBQUMyeUgsbUJBQW1CLENBQUNybEksR0FBRyxDQUFDMFM7SUFDdkM7SUFDQTgvRCxrQkFBa0JwMUIsTUFBTSxFQUFFO1FBQ3hCLE1BQU0sRUFDSm5OLEdBQUcsRUFDSixHQUFHLElBQUk7UUFDUixNQUFNLEVBQ0p2OUIsRUFBRSxFQUNGNC9CLFFBQVEsRUFDVCxHQUFHOEs7UUFDSixNQUFNbFAsVUFBVSxJQUFJNnJGLHdCQUF3QjtZQUMxQ3pySCxNQUFNO2dCQUNKb0U7Z0JBQ0FtekIsTUFBTXVYLE9BQU8weUIsVUFBVTtnQkFDdkJ4OUI7WUFDRjtZQUNBOEs7WUFDQWlQLE9BQU9wYztZQUNQSSxRQUFRLElBQUk7WUFDWnVrRixlQUFlLENBQUMsQ0FBQyxJQUFJLENBQUNrRSxlQUFlO1lBQ3JDM3BGLGFBQWEsSUFBSSxDQUFDLENBQUNBLFdBQVc7WUFDOUJTLG1CQUFtQixJQUFJLENBQUMsQ0FBQ0EsaUJBQWlCO1FBQzVDO1FBQ0EsTUFBTWszRixjQUFjNTRGLFFBQVF3QixNQUFNO1FBQ2xDTyxJQUFJcDRCLE1BQU0sQ0FBQ2l2SDtRQUNYLElBQUksQ0FBQyxDQUFDMUIsb0JBQW9CLEVBQUVXLGlCQUFpQjkxRixLQUFLNjJGLGFBQWFBLGFBQWE7UUFDNUU1NEYsUUFBUThyRixtQkFBbUI7UUFDM0IsT0FBTzlyRjtJQUNUO0lBQ0EsV0FBV3M0RixzQkFBc0I7UUFDL0IsT0FBT2psRyxPQUFPLElBQUksRUFBRSx1QkFBdUJuaEMsT0FBT3U5QyxNQUFNLENBQUM7WUFDdkR6SyxPQUFPO1lBQ1A2ekYsVUFBVTtZQUNWdDdILE9BQU95c0IsMEJBQTBCQyxLQUFLO1lBQ3RDd3BFLFdBQVc7Z0JBQUM7YUFBRTtZQUNkKzBCLHdCQUF3QjtZQUN4QkUsc0JBQXNCO1FBQ3hCO0lBQ0Y7QUFDRjtFQUVDLG1DQUFtQztBQVVwQyxNQUFNb1EsY0FBYztBQUNwQixNQUFNQyx1QkFBdUJsa0U7SUFDM0IsQ0FBQ2o0RCxPQUFPLENBQU07SUFDZCxDQUFDbzhILFdBQVcsQ0FBdUI7SUFDbkMsQ0FBQ0MsVUFBVSxDQUFRO0lBQ25CLENBQUNqdUMsUUFBUSxDQUFDOzthQUVIa3VDLDBCQUEwQjs7O2FBQzFCQyxtQkFBbUI7OzthQUNuQkMsZ0JBQWdCOzs7YUFDaEJDLG1CQUFtQjs7SUFDMUIsV0FBVzU5RSxtQkFBbUI7UUFDNUIsTUFBTW5yRCxRQUFReW9JLGVBQWU1bEksU0FBUztRQUN0QyxNQUFNdW9ELGVBQWV0eUMsQ0FBQUEsUUFBUUEsTUFBSzJ6QyxPQUFPO1FBQ3pDLE1BQU1iLFFBQVF6RCwwQkFBMEI4QyxlQUFlO1FBQ3ZELE1BQU1ZLE1BQU0xRCwwQkFBMEIrQyxhQUFhO1FBQ25ELE9BQU9ub0IsT0FBTyxJQUFJLEVBQUUsb0JBQW9CLElBQUlta0IsZ0JBQWdCO1lBQUM7Z0JBQUM7b0JBQUM7b0JBQVU7b0JBQWM7b0JBQVU7aUJBQWE7Z0JBQUVsbkQsTUFBTTB4RCxjQUFjO2dCQUFFO29CQUNwSS9KLFNBQVM7Z0JBQ1g7YUFBRTtZQUFFO2dCQUFDO29CQUFDO29CQUFjO29CQUFrQjtvQkFBVTtpQkFBYTtnQkFBRTNuRCxNQUFNMHhELGNBQWM7YUFBQztZQUFFO2dCQUFDO29CQUFDO29CQUFhO2lCQUFnQjtnQkFBRTF4RCxNQUFNZ3BJLGVBQWU7Z0JBQUU7b0JBQzVJeC9ILE1BQU07d0JBQUMsQ0FBQ29pRDt3QkFBTztxQkFBRTtvQkFDakJoRSxTQUFTd0Q7Z0JBQ1g7YUFBRTtZQUFFO2dCQUFDO29CQUFDO29CQUFrQjtpQkFBc0I7Z0JBQUVwckQsTUFBTWdwSSxlQUFlO2dCQUFFO29CQUNyRXgvSCxNQUFNO3dCQUFDLENBQUNxaUQ7d0JBQUs7cUJBQUU7b0JBQ2ZqRSxTQUFTd0Q7Z0JBQ1g7YUFBRTtZQUFFO2dCQUFDO29CQUFDO29CQUFjO2lCQUFpQjtnQkFBRXByRCxNQUFNZ3BJLGVBQWU7Z0JBQUU7b0JBQzVEeC9ILE1BQU07d0JBQUNvaUQ7d0JBQU87cUJBQUU7b0JBQ2hCaEUsU0FBU3dEO2dCQUNYO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBbUI7aUJBQXVCO2dCQUFFcHJELE1BQU1ncEksZUFBZTtnQkFBRTtvQkFDdkV4L0gsTUFBTTt3QkFBQ3FpRDt3QkFBSztxQkFBRTtvQkFDZGpFLFNBQVN3RDtnQkFDWDthQUFFO1lBQUU7Z0JBQUM7b0JBQUM7b0JBQVc7aUJBQWM7Z0JBQUVwckQsTUFBTWdwSSxlQUFlO2dCQUFFO29CQUN0RHgvSCxNQUFNO3dCQUFDO3dCQUFHLENBQUNvaUQ7cUJBQU07b0JBQ2pCaEUsU0FBU3dEO2dCQUNYO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBZ0I7aUJBQW9CO2dCQUFFcHJELE1BQU1ncEksZUFBZTtnQkFBRTtvQkFDakV4L0gsTUFBTTt3QkFBQzt3QkFBRyxDQUFDcWlEO3FCQUFJO29CQUNmakUsU0FBU3dEO2dCQUNYO2FBQUU7WUFBRTtnQkFBQztvQkFBQztvQkFBYTtpQkFBZ0I7Z0JBQUVwckQsTUFBTWdwSSxlQUFlO2dCQUFFO29CQUMxRHgvSCxNQUFNO3dCQUFDO3dCQUFHb2lEO3FCQUFNO29CQUNoQmhFLFNBQVN3RDtnQkFDWDthQUFFO1lBQUU7Z0JBQUM7b0JBQUM7b0JBQWtCO2lCQUFzQjtnQkFBRXByRCxNQUFNZ3BJLGVBQWU7Z0JBQUU7b0JBQ3JFeC9ILE1BQU07d0JBQUM7d0JBQUdxaUQ7cUJBQUk7b0JBQ2RqRSxTQUFTd0Q7Z0JBQ1g7YUFBRTtTQUFDO0lBQ0w7O2FBQ09nYyxRQUFROzs7YUFDUjNQLGNBQWNsa0MscUJBQXFCRSxRQUFROztJQUNsRDl3QixZQUFZNlcsTUFBTSxDQUFFO1FBQ2xCLEtBQUssQ0FBQztZQUNKLEdBQUdBLE1BQU07WUFDVG5YLE1BQU07UUFDUjthQWhERixDQUFDaUssT0FBTyxHQUFHO2FBQ1gsQ0FBQ284SCxXQUFXLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQ3gwSCxFQUFFLENBQUMsT0FBTyxDQUFDO2FBQ2xDLENBQUN5MEgsVUFBVSxHQUFHO2FBRWRNLGVBQWU7UUE2Q2IsSUFBSSxDQUFDMXdGLEtBQUssR0FBRy8rQixPQUFPKytCLEtBQUssSUFBSWt3RixlQUFlSyxhQUFhLElBQUl2a0UsaUJBQWlCK0MsaUJBQWlCO1FBQy9GLElBQUksQ0FBQyxDQUFDb3pCLFFBQVEsR0FBR2xoRixPQUFPa2hGLFFBQVEsSUFBSSt0QyxlQUFlTSxnQkFBZ0I7UUFDbkUsSUFBSSxDQUFDLElBQUksQ0FBQ254RSxtQkFBbUIsRUFBRTtZQUM3QixJQUFJLENBQUNsWSxVQUFVLENBQUMrVCxTQUFTLENBQUM7UUFDNUI7SUFDRjtJQUNBLE9BQU8ySyxXQUFXQyxJQUFJLEVBQUU5YixTQUFTLEVBQUU7UUFDakNnaUIsaUJBQWlCbkcsVUFBVSxDQUFDQyxNQUFNOWI7UUFDbEMsTUFBTXQxQyxRQUFRK3JDLGlCQUFpQjFyQyxTQUFTMjZELGVBQWU7UUFDdkQsSUFBSSxDQUFDNGdFLGdCQUFnQixHQUFHM2dFLFdBQVdqN0QsTUFBTWs3RCxnQkFBZ0IsQ0FBQztJQUM1RDtJQUNBLE9BQU96UCxvQkFBb0J4d0QsSUFBSSxFQUFFMUgsS0FBSyxFQUFFO1FBQ3RDLE9BQVEwSDtZQUNOLEtBQUs4ckIsMkJBQTJCRyxhQUFhO2dCQUMzQ3MwRyxlQUFlTSxnQkFBZ0IsR0FBR3ZvSTtnQkFDbEM7WUFDRixLQUFLd3pCLDJCQUEyQkksY0FBYztnQkFDNUNxMEcsZUFBZUssYUFBYSxHQUFHdG9JO2dCQUMvQjtRQUNKO0lBQ0Y7SUFDQTRzRCxhQUFhbGxELElBQUksRUFBRTFILEtBQUssRUFBRTtRQUN4QixPQUFRMEg7WUFDTixLQUFLOHJCLDJCQUEyQkcsYUFBYTtnQkFDM0MsSUFBSSxDQUFDLENBQUMrMEcsY0FBYyxDQUFDMW9JO2dCQUNyQjtZQUNGLEtBQUt3ekIsMkJBQTJCSSxjQUFjO2dCQUM1QyxJQUFJLENBQUMsQ0FBQ2s5RixXQUFXLENBQUM5d0g7Z0JBQ2xCO1FBQ0o7SUFDRjtJQUNBLFdBQVc2MUQsNEJBQTRCO1FBQ3JDLE9BQU87WUFBQztnQkFBQ3JpQywyQkFBMkJHLGFBQWE7Z0JBQUVzMEcsZUFBZU0sZ0JBQWdCO2FBQUM7WUFBRTtnQkFBQy8wRywyQkFBMkJJLGNBQWM7Z0JBQUVxMEcsZUFBZUssYUFBYSxJQUFJdmtFLGlCQUFpQitDLGlCQUFpQjthQUFDO1NBQUM7SUFDdk07SUFDQSxJQUFJeE4scUJBQXFCO1FBQ3ZCLE9BQU87WUFBQztnQkFBQzlsQywyQkFBMkJHLGFBQWE7Z0JBQUUsSUFBSSxDQUFDLENBQUN1bUUsUUFBUTthQUFDO1lBQUU7Z0JBQUMxbUUsMkJBQTJCSSxjQUFjO2dCQUFFLElBQUksQ0FBQ21rQixLQUFLO2FBQUM7U0FBQztJQUM5SDtJQUNBLElBQUlrMUIsaUJBQWlCO1FBQ25CLElBQUksQ0FBQ3c3RCxZQUFZLEtBQUssSUFBSXRYLGlCQUFpQixJQUFJO1FBQy9DLE9BQU87WUFBQztnQkFBQztnQkFBZSxJQUFJLENBQUNzWCxZQUFZO2FBQUM7U0FBQztJQUM3QztJQUNBLElBQUlyWCxZQUFZO1FBQ2QsT0FBTzU5RiwyQkFBMkJJLGNBQWM7SUFDbEQ7SUFDQSxDQUFDODBHLGNBQWMsQ0FBQ3h1QyxRQUFRO1FBQ3RCLE1BQU15dUMsY0FBYzUwSCxDQUFBQTtZQUNsQixJQUFJLENBQUM2MEgsU0FBUyxDQUFDbjhILEtBQUssQ0FBQ3l0RixRQUFRLEdBQUcsQ0FBQyxLQUFLLEVBQUVubUYsS0FBSywrQkFBK0IsQ0FBQztZQUM3RSxJQUFJLENBQUNpMUQsU0FBUyxDQUFDLEdBQUcsQ0FBRWoxRCxDQUFBQSxPQUFPLElBQUksQ0FBQyxDQUFDbW1GLFFBQVEsSUFBSSxJQUFJLENBQUNod0IsV0FBVztZQUM3RCxJQUFJLENBQUMsQ0FBQ2d3QixRQUFRLEdBQUdubUY7WUFDakIsSUFBSSxDQUFDLENBQUM4MEgsbUJBQW1CO1FBQzNCO1FBQ0EsTUFBTUMsZ0JBQWdCLElBQUksQ0FBQyxDQUFDNXVDLFFBQVE7UUFDcEMsSUFBSSxDQUFDNWtDLFdBQVcsQ0FBQztZQUNmdlAsS0FBSzRpRixZQUFZN2pJLElBQUksQ0FBQyxJQUFJLEVBQUVvMUY7WUFDNUJsMEMsTUFBTTJpRixZQUFZN2pJLElBQUksQ0FBQyxJQUFJLEVBQUVna0k7WUFDN0I3aUYsTUFBTSxJQUFJLENBQUMvRyxVQUFVLENBQUN1YSxRQUFRLENBQUMzMEQsSUFBSSxDQUFDLElBQUksQ0FBQ282QyxVQUFVLEVBQUUsSUFBSTtZQUN6RGdILFVBQVU7WUFDVngrQyxNQUFNOHJCLDJCQUEyQkcsYUFBYTtZQUM5Q3d5QixxQkFBcUI7WUFDckJDLFVBQVU7UUFDWjtJQUNGO0lBQ0F5WixpQkFBaUI7UUFDZixJQUFJLENBQUMrb0UsU0FBUyxDQUFDbjhILEtBQUssQ0FBQ3NyQyxLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLO1FBQ3ZDLElBQUksQ0FBQzB3RixZQUFZLEVBQUU5MkYsT0FBTyxJQUFJLENBQUNvRyxLQUFLO1FBQ3BDLEtBQUssQ0FBQzhuQjtJQUNSO0lBQ0EsQ0FBQ2l4RCxXQUFXLENBQUMvNEUsS0FBSztRQUNoQixNQUFNbWdGLFdBQVc2USxDQUFBQTtZQUNmLElBQUksQ0FBQ2h4RixLQUFLLEdBQUdneEY7WUFDYixJQUFJLENBQUNscEUsY0FBYztRQUNyQjtRQUNBLE1BQU1tcEUsYUFBYSxJQUFJLENBQUNqeEYsS0FBSztRQUM3QixJQUFJLENBQUN1ZCxXQUFXLENBQUM7WUFDZnZQLEtBQUtteUUsU0FBU3B6SCxJQUFJLENBQUMsSUFBSSxFQUFFaXpDO1lBQ3pCaU8sTUFBTWt5RSxTQUFTcHpILElBQUksQ0FBQyxJQUFJLEVBQUVra0k7WUFDMUIvaUYsTUFBTSxJQUFJLENBQUMvRyxVQUFVLENBQUN1YSxRQUFRLENBQUMzMEQsSUFBSSxDQUFDLElBQUksQ0FBQ282QyxVQUFVLEVBQUUsSUFBSTtZQUN6RGdILFVBQVU7WUFDVngrQyxNQUFNOHJCLDJCQUEyQkksY0FBYztZQUMvQ3V5QixxQkFBcUI7WUFDckJDLFVBQVU7UUFDWjtJQUNGO0lBQ0FvaUYsZ0JBQWdCOWlJLENBQUMsRUFBRTBNLENBQUMsRUFBRTtRQUNwQixJQUFJLENBQUM4c0MsVUFBVSxDQUFDeU0sd0JBQXdCLENBQUNqbUQsR0FBRzBNLEdBQUc7SUFDakQ7SUFDQWc0RCx3QkFBd0I7UUFDdEIsTUFBTS8yQixRQUFRLElBQUksQ0FBQzYyQixXQUFXO1FBQzlCLE9BQU87WUFBQyxDQUFDKzlELGVBQWVJLGdCQUFnQixHQUFHaDFGO1lBQU8sQ0FBRTQwRixDQUFBQSxlQUFlSSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsQ0FBQ251QyxRQUFRLElBQUk3bUQ7U0FBTTtJQUNoSDtJQUNBa29CLFVBQVU7UUFDUixJQUFJLENBQUMsSUFBSSxDQUFDbHFCLE1BQU0sRUFBRTtZQUNoQjtRQUNGO1FBQ0EsS0FBSyxDQUFDa3FCO1FBQ04sSUFBSSxJQUFJLENBQUN0cUIsR0FBRyxLQUFLLE1BQU07WUFDckI7UUFDRjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUMwMUIsZUFBZSxFQUFFO1lBQ3pCLElBQUksQ0FBQ3QxQixNQUFNLENBQUN6OEIsR0FBRyxDQUFDLElBQUk7UUFDdEI7SUFDRjtJQUNBbzhELGlCQUFpQjtRQUNmLElBQUksQ0FBQyxLQUFLLENBQUNBLGtCQUFrQjtZQUMzQixPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUNpNEQsVUFBVSxDQUFDanVGLFNBQVMsQ0FBQzdtQyxNQUFNLENBQUM7UUFDakMsSUFBSSxDQUFDeTBILFNBQVMsQ0FBQ00sZUFBZSxHQUFHO1FBQ2pDLElBQUksQ0FBQ3BoRSxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDNzJCLEdBQUcsQ0FBQ3JCLGVBQWUsQ0FBQztRQUN6QixJQUFJLENBQUMsQ0FBQ3U0RixVQUFVLEdBQUcsSUFBSXQ2RjtRQUN2QixNQUFNQyxTQUFTLElBQUksQ0FBQ29SLFVBQVUsQ0FBQ3FPLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQzQ2RSxVQUFVO1FBQzlELElBQUksQ0FBQ1MsU0FBUyxDQUFDMTZGLGdCQUFnQixDQUFDLFdBQVcsSUFBSSxDQUFDaTdGLGdCQUFnQixDQUFDcmtJLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDM0VncEM7UUFDRjtRQUNBLElBQUksQ0FBQzg2RixTQUFTLENBQUMxNkYsZ0JBQWdCLENBQUMsU0FBUyxJQUFJLENBQUNrN0YsY0FBYyxDQUFDdGtJLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDdkVncEM7UUFDRjtRQUNBLElBQUksQ0FBQzg2RixTQUFTLENBQUMxNkYsZ0JBQWdCLENBQUMsUUFBUSxJQUFJLENBQUNtN0YsYUFBYSxDQUFDdmtJLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDckVncEM7UUFDRjtRQUNBLElBQUksQ0FBQzg2RixTQUFTLENBQUMxNkYsZ0JBQWdCLENBQUMsU0FBUyxJQUFJLENBQUNvN0YsY0FBYyxDQUFDeGtJLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDdkVncEM7UUFDRjtRQUNBLElBQUksQ0FBQzg2RixTQUFTLENBQUMxNkYsZ0JBQWdCLENBQUMsU0FBUyxJQUFJLENBQUNxN0YsY0FBYyxDQUFDemtJLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDdkVncEM7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBbWpDLGtCQUFrQjtRQUNoQixJQUFJLENBQUMsS0FBSyxDQUFDQSxtQkFBbUI7WUFDNUIsT0FBTztRQUNUO1FBQ0EsSUFBSSxDQUFDZzRELFVBQVUsQ0FBQ2p1RixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1FBQzlCLElBQUksQ0FBQ2cwSCxTQUFTLENBQUNNLGVBQWUsR0FBRztRQUNqQyxJQUFJLENBQUNqNEYsR0FBRyxDQUFDdkIsWUFBWSxDQUFDLHlCQUF5QixJQUFJLENBQUMsQ0FBQ3c0RixXQUFXO1FBQ2hFLElBQUksQ0FBQ3BnRSxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDLENBQUNxZ0UsVUFBVSxFQUFFbjZGO1FBQ2xCLElBQUksQ0FBQyxDQUFDbTZGLFVBQVUsR0FBRztRQUNuQixJQUFJLENBQUNsM0YsR0FBRyxDQUFDeWYsS0FBSyxDQUFDO1lBQ2JtaUIsZUFBZTtRQUNqQjtRQUNBLElBQUksQ0FBQzdtQixTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDM2EsTUFBTSxDQUFDSixHQUFHLENBQUMrSixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1FBQzlCLE9BQU87SUFDVDtJQUNBMHpELFFBQVEvNEIsS0FBSyxFQUFFO1FBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQ29RLG1CQUFtQixFQUFFO1lBQzdCO1FBQ0Y7UUFDQSxLQUFLLENBQUMyb0IsUUFBUS80QjtRQUNkLElBQUlBLE1BQU1od0MsTUFBTSxLQUFLLElBQUksQ0FBQ3FwSSxTQUFTLEVBQUU7WUFDbkMsSUFBSSxDQUFDQSxTQUFTLENBQUNsNEUsS0FBSztRQUN0QjtJQUNGO0lBQ0FxZ0IsVUFBVXJnQixLQUFLLEVBQUU7UUFDZixJQUFJLElBQUksQ0FBQ3hjLEtBQUssRUFBRTtZQUNkO1FBQ0Y7UUFDQSxJQUFJLENBQUM4OEIsY0FBYztRQUNuQixJQUFJdGdCLE9BQU87WUFDVCxJQUFJLENBQUNrNEUsU0FBUyxDQUFDbDRFLEtBQUs7UUFDdEI7UUFDQSxJQUFJLElBQUksQ0FBQ3NWLGVBQWUsRUFBRUksWUFBWTtZQUNwQyxJQUFJLENBQUMyQixNQUFNO1FBQ2I7UUFDQSxJQUFJLENBQUMvQixlQUFlLEdBQUc7SUFDekI7SUFDQS9aLFVBQVU7UUFDUixPQUFPLENBQUMsSUFBSSxDQUFDMjhFLFNBQVMsSUFBSSxJQUFJLENBQUNBLFNBQVMsQ0FBQ1ksU0FBUyxDQUFDdDBGLElBQUksT0FBTztJQUNoRTtJQUNBL2dDLFNBQVM7UUFDUCxJQUFJLENBQUM2M0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksSUFBSSxDQUFDM2EsTUFBTSxFQUFFO1lBQ2YsSUFBSSxDQUFDQSxNQUFNLENBQUNxa0IsZUFBZSxDQUFDO1lBQzVCLElBQUksQ0FBQ3JrQixNQUFNLENBQUNKLEdBQUcsQ0FBQytKLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7UUFDaEM7UUFDQSxLQUFLLENBQUNUO0lBQ1I7SUFDQSxDQUFDczFILFdBQVc7UUFDVixNQUFNaG1JLFNBQVMsRUFBRTtRQUNqQixJQUFJLENBQUNtbEksU0FBUyxDQUFDcjVILFNBQVM7UUFDeEIsSUFBSW02SCxZQUFZO1FBQ2hCLEtBQUssTUFBTTM2RixTQUFTLElBQUksQ0FBQzY1RixTQUFTLENBQUNlLFVBQVUsQ0FBRTtZQUM3QyxJQUFJRCxXQUFXcDRFLGFBQWEvbUMsS0FBS2duQyxTQUFTLElBQUl4aUIsTUFBTW1rQyxRQUFRLEtBQUssTUFBTTtnQkFDckU7WUFDRjtZQUNBenZFLE9BQU91RyxJQUFJLENBQUNpK0gsZUFBZSxDQUFDMkIsY0FBYyxDQUFDNzZGO1lBQzNDMjZGLFlBQVkzNkY7UUFDZDtRQUNBLE9BQU90ckMsT0FBT2pDLElBQUksQ0FBQztJQUNyQjtJQUNBLENBQUNxbkksbUJBQW1CO1FBQ2xCLE1BQU0sQ0FBQzNzRSxhQUFhQyxhQUFhLEdBQUcsSUFBSSxDQUFDMEUsZ0JBQWdCO1FBQ3pELElBQUloNkI7UUFDSixJQUFJLElBQUksQ0FBQzgvQixlQUFlLEVBQUU7WUFDeEI5L0IsT0FBTyxJQUFJLENBQUNvSyxHQUFHLENBQUM2ZixxQkFBcUI7UUFDdkMsT0FBTztZQUNMLE1BQU0sRUFDSmEsWUFBWSxFQUNaMWdCLEdBQUcsRUFDSixHQUFHLElBQUk7WUFDUixNQUFNNDRGLGVBQWU1NEYsSUFBSXhrQyxLQUFLLENBQUNDLE9BQU87WUFDdEMsTUFBTW85SCxrQkFBa0I3NEYsSUFBSStKLFNBQVMsQ0FBQzZQLFFBQVEsQ0FBQztZQUMvQzVaLElBQUkrSixTQUFTLENBQUM3bUMsTUFBTSxDQUFDO1lBQ3JCODhCLElBQUl4a0MsS0FBSyxDQUFDQyxPQUFPLEdBQUc7WUFDcEJpbEQsYUFBYTFnQixHQUFHLENBQUNwNEIsTUFBTSxDQUFDLElBQUksQ0FBQ280QixHQUFHO1lBQ2hDcEssT0FBT29LLElBQUk2ZixxQkFBcUI7WUFDaEM3ZixJQUFJOThCLE1BQU07WUFDVjg4QixJQUFJeGtDLEtBQUssQ0FBQ0MsT0FBTyxHQUFHbTlIO1lBQ3BCNTRGLElBQUkrSixTQUFTLENBQUMrVixNQUFNLENBQUMsVUFBVSs0RTtRQUNqQztRQUNBLElBQUksSUFBSSxDQUFDeDJGLFFBQVEsR0FBRyxRQUFRLElBQUksQ0FBQzAwQixjQUFjLEdBQUcsS0FBSztZQUNyRCxJQUFJLENBQUM5ekIsS0FBSyxHQUFHck4sS0FBS3FOLEtBQUssR0FBR2dvQjtZQUMxQixJQUFJLENBQUMvbkIsTUFBTSxHQUFHdE4sS0FBS3NOLE1BQU0sR0FBR2dvQjtRQUM5QixPQUFPO1lBQ0wsSUFBSSxDQUFDam9CLEtBQUssR0FBR3JOLEtBQUtzTixNQUFNLEdBQUcrbkI7WUFDM0IsSUFBSSxDQUFDL25CLE1BQU0sR0FBR3ROLEtBQUtxTixLQUFLLEdBQUdpb0I7UUFDN0I7UUFDQSxJQUFJLENBQUM4TCxpQkFBaUI7SUFDeEI7SUFDQWhPLFNBQVM7UUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDMkssWUFBWSxJQUFJO1lBQ3hCO1FBQ0Y7UUFDQSxLQUFLLENBQUMzSztRQUNOLElBQUksQ0FBQ2dYLGVBQWU7UUFDcEIsTUFBTTg0RCxZQUFZLElBQUksQ0FBQyxDQUFDaitILE9BQU87UUFDL0IsTUFBTWsrSCxVQUFVLElBQUksQ0FBQyxDQUFDbCtILE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQzI5SCxXQUFXLEdBQUdRLE9BQU87UUFDM0QsSUFBSUYsY0FBY0MsU0FBUztZQUN6QjtRQUNGO1FBQ0EsTUFBTUUsVUFBVTMrRyxDQUFBQTtZQUNkLElBQUksQ0FBQyxDQUFDemYsT0FBTyxHQUFHeWY7WUFDaEIsSUFBSSxDQUFDQSxNQUFNO2dCQUNULElBQUksQ0FBQ3BYLE1BQU07Z0JBQ1g7WUFDRjtZQUNBLElBQUksQ0FBQyxDQUFDZzJILFVBQVU7WUFDaEIsSUFBSSxDQUFDanJGLFVBQVUsQ0FBQ3FjLE9BQU8sQ0FBQyxJQUFJO1lBQzVCLElBQUksQ0FBQyxDQUFDc3RFLG1CQUFtQjtRQUMzQjtRQUNBLElBQUksQ0FBQ3Z6RSxXQUFXLENBQUM7WUFDZnZQLEtBQUs7Z0JBQ0hta0YsUUFBUUY7WUFDVjtZQUNBaGtGLE1BQU07Z0JBQ0pra0YsUUFBUUg7WUFDVjtZQUNBN2pGLFVBQVU7UUFDWjtRQUNBLElBQUksQ0FBQyxDQUFDMmlGLG1CQUFtQjtJQUMzQjtJQUNBbnRFLDBCQUEwQjtRQUN4QixPQUFPLElBQUksQ0FBQ2tKLFlBQVk7SUFDMUI7SUFDQWhOLGtCQUFrQjtRQUNoQixJQUFJLENBQUNvWixjQUFjO1FBQ25CLElBQUksQ0FBQzQzRCxTQUFTLENBQUNsNEUsS0FBSztJQUN0QjtJQUNBcUQsUUFBUXhrQixLQUFLLEVBQUU7UUFDYixJQUFJQSxNQUFNaHdDLE1BQU0sS0FBSyxJQUFJLENBQUMweEMsR0FBRyxJQUFJMUIsTUFBTXBsQyxHQUFHLEtBQUssU0FBUztZQUN0RCxJQUFJLENBQUN5dEQsZUFBZTtZQUNwQnJvQixNQUFNbUgsY0FBYztRQUN0QjtJQUNGO0lBQ0F5eUYsaUJBQWlCNTVGLEtBQUssRUFBRTtRQUN0QjA0RixlQUFldDlFLGdCQUFnQixDQUFDbGtELElBQUksQ0FBQyxJQUFJLEVBQUU4b0M7SUFDN0M7SUFDQTY1RixlQUFlNzVGLEtBQUssRUFBRTtRQUNwQixJQUFJLENBQUN5YyxTQUFTLEdBQUc7SUFDbkI7SUFDQXE5RSxjQUFjOTVGLEtBQUssRUFBRTtRQUNuQixJQUFJLENBQUN5YyxTQUFTLEdBQUc7SUFDbkI7SUFDQXM5RSxlQUFlLzVGLEtBQUssRUFBRTtRQUNwQixJQUFJLENBQUM4QixNQUFNLENBQUNKLEdBQUcsQ0FBQytKLFNBQVMsQ0FBQytWLE1BQU0sQ0FBQyxtQkFBbUIsSUFBSSxDQUFDOUUsT0FBTztJQUNsRTtJQUNBNm1CLGlCQUFpQjtRQUNmLElBQUksQ0FBQzgxRCxTQUFTLENBQUNsNUYsWUFBWSxDQUFDLFFBQVE7UUFDcEMsSUFBSSxDQUFDazVGLFNBQVMsQ0FBQ2g1RixlQUFlLENBQUM7SUFDakM7SUFDQW1qQyxnQkFBZ0I7UUFDZCxJQUFJLENBQUM2MUQsU0FBUyxDQUFDbDVGLFlBQVksQ0FBQyxRQUFRO1FBQ3BDLElBQUksQ0FBQ2s1RixTQUFTLENBQUNsNUYsWUFBWSxDQUFDLGtCQUFrQjtJQUNoRDtJQUNBLElBQUlzakMsbUJBQW1CO1FBQ3JCLE9BQU87SUFDVDtJQUNBdGlDLFNBQVM7UUFDUCxJQUFJLElBQUksQ0FBQ08sR0FBRyxFQUFFO1lBQ1osT0FBTyxJQUFJLENBQUNBLEdBQUc7UUFDakI7UUFDQSxJQUFJNDNCLE9BQU9DO1FBQ1gsSUFBSSxJQUFJLENBQUNoRCxPQUFPLElBQUksSUFBSSxDQUFDMU8sbUJBQW1CLEVBQUU7WUFDNUN5UixRQUFRLElBQUksQ0FBQ25qRSxDQUFDO1lBQ2RvakUsUUFBUSxJQUFJLENBQUMxMkQsQ0FBQztRQUNoQjtRQUNBLEtBQUssQ0FBQ3MrQjtRQUNOLElBQUksQ0FBQ2s0RixTQUFTLEdBQUc5N0gsU0FBUzJJLGFBQWEsQ0FBQztRQUN4QyxJQUFJLENBQUNtekgsU0FBUyxDQUFDL3JGLFNBQVMsR0FBRztRQUMzQixJQUFJLENBQUMrckYsU0FBUyxDQUFDbDVGLFlBQVksQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDdzRGLFdBQVc7UUFDbkQsSUFBSSxDQUFDVSxTQUFTLENBQUNsNUYsWUFBWSxDQUFDLGdCQUFnQjtRQUM1QyxJQUFJLENBQUNrNUYsU0FBUyxDQUFDbDVGLFlBQVksQ0FBQyxtQkFBbUI7UUFDL0MsSUFBSSxDQUFDcWpDLGFBQWE7UUFDbEIsSUFBSSxDQUFDNjFELFNBQVMsQ0FBQ00sZUFBZSxHQUFHO1FBQ2pDLE1BQU0sRUFDSno4SCxLQUFLLEVBQ04sR0FBRyxJQUFJLENBQUNtOEgsU0FBUztRQUNsQm44SCxNQUFNeXRGLFFBQVEsR0FBRyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQ0EsUUFBUSxDQUFDLCtCQUErQixDQUFDO1FBQ3hFenRGLE1BQU1zckMsS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSztRQUN4QixJQUFJLENBQUM5RyxHQUFHLENBQUNwNEIsTUFBTSxDQUFDLElBQUksQ0FBQyt2SCxTQUFTO1FBQzlCLElBQUksQ0FBQ0ssVUFBVSxHQUFHbjhILFNBQVMySSxhQUFhLENBQUM7UUFDekMsSUFBSSxDQUFDd3pILFVBQVUsQ0FBQ2p1RixTQUFTLENBQUNwbUMsR0FBRyxDQUFDLFdBQVc7UUFDekMsSUFBSSxDQUFDcThCLEdBQUcsQ0FBQ3A0QixNQUFNLENBQUMsSUFBSSxDQUFDb3dILFVBQVU7UUFDL0IsSUFBSSxJQUFJLENBQUNuakUsT0FBTyxJQUFJLElBQUksQ0FBQzFPLG1CQUFtQixFQUFFO1lBQzVDLE1BQU0sQ0FBQzhFLGFBQWFDLGFBQWEsR0FBRyxJQUFJLENBQUMwRSxnQkFBZ0I7WUFDekQsSUFBSSxJQUFJLENBQUN6SixtQkFBbUIsRUFBRTtnQkFDNUIsTUFBTSxFQUNKL1gsUUFBUSxFQUNULEdBQUcsSUFBSSxDQUFDNG1CLFlBQVk7Z0JBQ3JCLElBQUksQ0FBQzdLLElBQUlDLEdBQUcsR0FBRyxJQUFJLENBQUMrTyxxQkFBcUI7Z0JBQ3pDLENBQUNoUCxJQUFJQyxHQUFHLEdBQUcsSUFBSSxDQUFDMk8sdUJBQXVCLENBQUM1TyxJQUFJQztnQkFDNUMsTUFBTSxDQUFDL21CLFdBQVdDLFdBQVcsR0FBRyxJQUFJLENBQUNreUIsY0FBYztnQkFDbkQsTUFBTSxDQUFDanlCLE9BQU9DLE1BQU0sR0FBRyxJQUFJLENBQUNpeUIsZUFBZTtnQkFDM0MsSUFBSTVYLE1BQU1DO2dCQUNWLE9BQVEsSUFBSSxDQUFDemIsUUFBUTtvQkFDbkIsS0FBSzt3QkFDSHdiLE9BQU8rWixRQUFRLENBQUN4cEIsUUFBUSxDQUFDLEVBQUUsR0FBRzdLLEtBQUksSUFBS0Y7d0JBQ3ZDeWEsT0FBTytaLFFBQVEsSUFBSSxDQUFDMzBCLE1BQU0sR0FBRyxDQUFDa0wsUUFBUSxDQUFDLEVBQUUsR0FBRzVLLEtBQUksSUFBS0Y7d0JBQ3JEO29CQUNGLEtBQUs7d0JBQ0h1YSxPQUFPK1osUUFBUSxDQUFDeHBCLFFBQVEsQ0FBQyxFQUFFLEdBQUc3SyxLQUFJLElBQUtGO3dCQUN2Q3lhLE9BQU8rWixRQUFRLENBQUN6cEIsUUFBUSxDQUFDLEVBQUUsR0FBRzVLLEtBQUksSUFBS0Y7d0JBQ3ZDLENBQUM2bUIsSUFBSUMsR0FBRyxHQUFHOzRCQUFDQTs0QkFBSSxDQUFDRDt5QkFBRzt3QkFDcEI7b0JBQ0YsS0FBSzt3QkFDSHRNLE9BQU8rWixRQUFRLElBQUksQ0FBQzMwQixLQUFLLEdBQUcsQ0FBQ21MLFFBQVEsQ0FBQyxFQUFFLEdBQUc3SyxLQUFJLElBQUtGO3dCQUNwRHlhLE9BQU8rWixRQUFRLENBQUN6cEIsUUFBUSxDQUFDLEVBQUUsR0FBRzVLLEtBQUksSUFBS0Y7d0JBQ3ZDLENBQUM2bUIsSUFBSUMsR0FBRyxHQUFHOzRCQUFDLENBQUNEOzRCQUFJLENBQUNDO3lCQUFHO3dCQUNyQjtvQkFDRixLQUFLO3dCQUNIdk0sT0FBTytaLFFBQVEsQ0FBQ3hwQixRQUFRLENBQUMsRUFBRSxHQUFHN0ssUUFBUSxJQUFJLENBQUNMLE1BQU0sR0FBR0ksVUFBUyxJQUFLRDt3QkFDbEV5YSxPQUFPK1osUUFBUSxDQUFDenBCLFFBQVEsQ0FBQyxFQUFFLEdBQUc1SyxRQUFRLElBQUksQ0FBQ1AsS0FBSyxHQUFHSSxTQUFRLElBQUtDO3dCQUNoRSxDQUFDNm1CLElBQUlDLEdBQUcsR0FBRzs0QkFBQyxDQUFDQTs0QkFBSUQ7eUJBQUc7d0JBQ3BCO2dCQUNKO2dCQUNBLElBQUksQ0FBQ3NOLEtBQUssQ0FBQzVaLE9BQU9vTixhQUFhbk4sT0FBT29OLGNBQWNmLElBQUlDO1lBQzFELE9BQU87Z0JBQ0wsSUFBSSxDQUFDdU4sZUFBZSxDQUFDQyxPQUFPQztZQUM5QjtZQUNBLElBQUksQ0FBQyxDQUFDcWhFLFVBQVU7WUFDaEIsSUFBSSxDQUFDcmlFLFlBQVksR0FBRztZQUNwQixJQUFJLENBQUM4Z0UsU0FBUyxDQUFDTSxlQUFlLEdBQUc7UUFDbkMsT0FBTztZQUNMLElBQUksQ0FBQ3BoRSxZQUFZLEdBQUc7WUFDcEIsSUFBSSxDQUFDOGdFLFNBQVMsQ0FBQ00sZUFBZSxHQUFHO1FBQ25DO1FBQ0EsT0FBTyxJQUFJLENBQUNqNEYsR0FBRztJQUNqQjtJQUNBLE9BQU8sQ0FBQzI0RixjQUFjLENBQUMzL0csSUFBSTtRQUN6QixPQUFPLENBQUNBLEtBQUtxbkMsUUFBUSxLQUFLL21DLEtBQUtnbkMsU0FBUyxHQUFHdG5DLEtBQUttZ0gsU0FBUyxHQUFHbmdILEtBQUt1L0csU0FBUyxFQUFFLytGLFVBQVUsQ0FBQ3U5RixhQUFhO0lBQ3RHO0lBQ0F1QixlQUFlaDZGLEtBQUssRUFBRTtRQUNwQixNQUFNd2xCLGdCQUFnQnhsQixNQUFNd2xCLGFBQWEsSUFBSXgrQyxPQUFPdytDLGFBQWE7UUFDakUsTUFBTSxFQUNKYSxLQUFLLEVBQ04sR0FBR2I7UUFDSixJQUFJYSxNQUFNNzJELE1BQU0sS0FBSyxLQUFLNjJELEtBQUssQ0FBQyxFQUFFLEtBQUssY0FBYztZQUNuRDtRQUNGO1FBQ0FybUIsTUFBTW1ILGNBQWM7UUFDcEIsTUFBTTJkLFFBQVE0ekUsZUFBZSxDQUFDb0Msa0JBQWtCLENBQUN0MUUsY0FBY3pGLE9BQU8sQ0FBQyxXQUFXLElBQUk3a0IsVUFBVSxDQUFDdTlGLGFBQWE7UUFDOUcsSUFBSSxDQUFDM3pFLE9BQU87WUFDVjtRQUNGO1FBQ0EsTUFBTXZDLFlBQVl2N0MsT0FBT3c3QyxZQUFZO1FBQ3JDLElBQUksQ0FBQ0QsVUFBVWlLLFVBQVUsRUFBRTtZQUN6QjtRQUNGO1FBQ0EsSUFBSSxDQUFDNnNFLFNBQVMsQ0FBQ3I1SCxTQUFTO1FBQ3hCdWlELFVBQVV3NEUsa0JBQWtCO1FBQzVCLE1BQU1qdUUsUUFBUXZLLFVBQVVrSyxVQUFVLENBQUM7UUFDbkMsSUFBSSxDQUFDM0gsTUFBTTcvQyxRQUFRLENBQUMsT0FBTztZQUN6QjZuRCxNQUFNa3VFLFVBQVUsQ0FBQ3o5SCxTQUFTc2tDLGNBQWMsQ0FBQ2lqQjtZQUN6QyxJQUFJLENBQUN1MEUsU0FBUyxDQUFDcjVILFNBQVM7WUFDeEJ1aUQsVUFBVTA0RSxlQUFlO1lBQ3pCO1FBQ0Y7UUFDQSxNQUFNLEVBQ0pDLGNBQWMsRUFDZEMsV0FBVyxFQUNaLEdBQUdydUU7UUFDSixNQUFNc3VFLGVBQWUsRUFBRTtRQUN2QixNQUFNQyxjQUFjLEVBQUU7UUFDdEIsSUFBSUgsZUFBZW41RSxRQUFRLEtBQUsvbUMsS0FBS2duQyxTQUFTLEVBQUU7WUFDOUMsTUFBTWxnQixTQUFTbzVGLGVBQWVqNUUsYUFBYTtZQUMzQ281RSxZQUFZNWdJLElBQUksQ0FBQ3lnSSxlQUFlTCxTQUFTLENBQUM5b0ksS0FBSyxDQUFDb3BJLGFBQWFqZ0csVUFBVSxDQUFDdTlGLGFBQWE7WUFDckYsSUFBSTMyRixXQUFXLElBQUksQ0FBQ3UzRixTQUFTLEVBQUU7Z0JBQzdCLElBQUlubEksU0FBU2tuSTtnQkFDYixLQUFLLE1BQU01N0YsU0FBUyxJQUFJLENBQUM2NUYsU0FBUyxDQUFDZSxVQUFVLENBQUU7b0JBQzdDLElBQUk1NkYsVUFBVXNDLFFBQVE7d0JBQ3BCNXRDLFNBQVNtbkk7d0JBQ1Q7b0JBQ0Y7b0JBQ0FubkksT0FBT3VHLElBQUksQ0FBQ2krSCxlQUFlLENBQUMyQixjQUFjLENBQUM3NkY7Z0JBQzdDO1lBQ0Y7WUFDQTQ3RixhQUFhM2dJLElBQUksQ0FBQ3lnSSxlQUFlTCxTQUFTLENBQUM5b0ksS0FBSyxDQUFDLEdBQUdvcEksYUFBYWpnRyxVQUFVLENBQUN1OUYsYUFBYTtRQUMzRixPQUFPLElBQUl5QyxtQkFBbUIsSUFBSSxDQUFDN0IsU0FBUyxFQUFFO1lBQzVDLElBQUlubEksU0FBU2tuSTtZQUNiLElBQUlqbkksSUFBSTtZQUNSLEtBQUssTUFBTXFyQyxTQUFTLElBQUksQ0FBQzY1RixTQUFTLENBQUNlLFVBQVUsQ0FBRTtnQkFDN0MsSUFBSWptSSxRQUFRZ25JLGFBQWE7b0JBQ3ZCam5JLFNBQVNtbkk7Z0JBQ1g7Z0JBQ0FubkksT0FBT3VHLElBQUksQ0FBQ2krSCxlQUFlLENBQUMyQixjQUFjLENBQUM3NkY7WUFDN0M7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDampDLE9BQU8sR0FBRyxDQUFDLEVBQUU2K0gsYUFBYW5wSSxJQUFJLENBQUMsTUFBTSxFQUFFNnlELE1BQU0sRUFBRXUyRSxZQUFZcHBJLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDN0UsSUFBSSxDQUFDLENBQUMyb0ksVUFBVTtRQUNoQixNQUFNVSxXQUFXLElBQUlDO1FBQ3JCLElBQUlDLGVBQWV4bEksS0FBS2dOLFVBQVUsQ0FBQ280SCxhQUFhL2dJLEdBQUcsQ0FBQ3N6QyxDQUFBQSxPQUFRQSxLQUFLbitDLE1BQU07UUFDdkUsS0FBSyxNQUFNLEVBQ1RvK0MsVUFBVSxFQUNYLElBQUksSUFBSSxDQUFDeXJGLFNBQVMsQ0FBQ2UsVUFBVSxDQUFFO1lBQzlCLElBQUl4c0YsV0FBV21VLFFBQVEsS0FBSy9tQyxLQUFLZ25DLFNBQVMsRUFBRTtnQkFDMUMsTUFBTXh5RCxTQUFTbytDLFdBQVdpdEYsU0FBUyxDQUFDcnJJLE1BQU07Z0JBQzFDLElBQUlnc0ksZ0JBQWdCaHNJLFFBQVE7b0JBQzFCOHJJLFNBQVNHLFFBQVEsQ0FBQzd0RixZQUFZNHRGO29CQUM5QkYsU0FBU0ksTUFBTSxDQUFDOXRGLFlBQVk0dEY7b0JBQzVCO2dCQUNGO2dCQUNBQSxnQkFBZ0Joc0k7WUFDbEI7UUFDRjtRQUNBK3lELFVBQVVvNUUsZUFBZTtRQUN6QnA1RSxVQUFVcTVFLFFBQVEsQ0FBQ047SUFDckI7SUFDQSxDQUFDVixVQUFVO1FBQ1QsSUFBSSxDQUFDdkIsU0FBUyxDQUFDd0MsZUFBZTtRQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUN0L0gsT0FBTyxFQUFFO1lBQ2xCO1FBQ0Y7UUFDQSxLQUFLLE1BQU1veEMsUUFBUSxJQUFJLENBQUMsQ0FBQ3B4QyxPQUFPLENBQUNuSyxLQUFLLENBQUMsTUFBTztZQUM1QyxNQUFNc3ZDLE1BQU1ua0MsU0FBUzJJLGFBQWEsQ0FBQztZQUNuQ3c3QixJQUFJcDRCLE1BQU0sQ0FBQ3FrQyxPQUFPcHdDLFNBQVNza0MsY0FBYyxDQUFDOEwsUUFBUXB3QyxTQUFTMkksYUFBYSxDQUFDO1lBQ3pFLElBQUksQ0FBQ216SCxTQUFTLENBQUMvdkgsTUFBTSxDQUFDbzRCO1FBQ3hCO0lBQ0Y7SUFDQSxDQUFDbzZGLGdCQUFnQjtRQUNmLE9BQU8sSUFBSSxDQUFDLENBQUN2L0gsT0FBTyxDQUFDMitCLFVBQVUsQ0FBQyxRQUFRO0lBQzFDO0lBQ0EsT0FBTyxDQUFDNC9GLGtCQUFrQixDQUFDditILE9BQU87UUFDaEMsT0FBT0EsUUFBUTIrQixVQUFVLENBQUMsS0FBSztJQUNqQztJQUNBLElBQUkwb0MsYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDeTFELFNBQVM7SUFDdkI7SUFDQTkzRCxhQUFhO1FBQ1gsTUFBTXc2RCxVQUFVckQsZUFBZUksZ0JBQWdCLEdBQUcsSUFBSSxDQUFDbitELFdBQVc7UUFDbEUsT0FBTyxJQUFJLENBQUN3RyxPQUFPLENBQUM0NkQsU0FBU0E7SUFDL0I7SUFDQSxhQUFhbjJFLFlBQVk3bEQsSUFBSSxFQUFFK2hDLE1BQU0sRUFBRTBRLFNBQVMsRUFBRTtRQUNoRCxJQUFJaXZELGNBQWM7UUFDbEIsSUFBSTFoRyxnQkFBZ0I2a0gsMkJBQTJCO1lBQzdDLE1BQU0sRUFDSjdrSCxNQUFNLEVBQ0ordUgsdUJBQXVCLEVBQ3JCbmtDLFFBQVEsRUFDUmtrQyxTQUFTLEVBQ1YsRUFDRHYzRixJQUFJLEVBQ0p5TSxRQUFRLEVBQ1I1L0IsRUFBRSxFQUNGOGpELFFBQVEsRUFDUjhILFFBQVEsRUFDUjdILFdBQVcsRUFDWDZPLFlBQVksRUFDWkMsZ0JBQWdCLEVBQ2pCLEVBQ0QvM0IsV0FBVyxFQUNYMDJGLFlBQVksRUFDWjd6RixRQUFRLEVBQ052RSxNQUFNLEVBQ0prakIsVUFBVSxFQUNYLEVBQ0YsRUFDRixHQUFHMWdEO1lBQ0osSUFBSSxDQUFDay9CLGVBQWVBLFlBQVl6dkMsTUFBTSxLQUFLLEdBQUc7Z0JBQzVDLE9BQU87WUFDVDtZQUNBaXlHLGNBQWMxaEcsT0FBTztnQkFDbkJxaUUsZ0JBQWdCNStDLHFCQUFxQkUsUUFBUTtnQkFDN0M4a0IsT0FBT2puQyxNQUFNcVcsSUFBSSxDQUFDaTNHO2dCQUNsQmxrQztnQkFDQWw2RixPQUFPd3VDLFlBQVlodEMsSUFBSSxDQUFDO2dCQUN4QjY5QyxVQUFVNmxGO2dCQUNWaDJFLFdBQVdjLGFBQWE7Z0JBQ3hCbnBCLE1BQU1BLEtBQUt2bEMsS0FBSyxDQUFDO2dCQUNqQmd5QztnQkFDQThqQixxQkFBcUIxakQ7Z0JBQ3JCQTtnQkFDQTRqRCxTQUFTO2dCQUNURTtnQkFDQWpaLFNBQVNrWixhQUFhOXpCLE9BQU87Z0JBQzdCMjdCO2dCQUNBZ0g7Z0JBQ0FDO1lBQ0Y7UUFDRjtRQUNBLE1BQU1ub0IsU0FBUyxNQUFNLEtBQUssQ0FBQytXLFlBQVk3bEQsTUFBTStoQyxRQUFRMFE7UUFDckQzRCxPQUFPLENBQUM4N0MsUUFBUSxHQUFHNXFGLEtBQUs0cUYsUUFBUTtRQUNoQzk3QyxPQUFPckcsS0FBSyxHQUFHNVMsS0FBS0MsWUFBWSxJQUFJOTFCLEtBQUt5b0MsS0FBSztRQUM5Q3FHLE9BQU8sQ0FBQ3R5QyxPQUFPLEdBQUdtOEgsZUFBZSxDQUFDb0Msa0JBQWtCLENBQUMvNkgsS0FBS3RQLEtBQUs7UUFDL0RvK0MsT0FBTzZuQixZQUFZLEdBQUcrcUM7UUFDdEIsSUFBSTFoRyxLQUFLaXZDLE9BQU8sRUFBRTtZQUNoQkgsT0FBTyt2QixjQUFjLENBQUM3K0Q7UUFDeEI7UUFDQSxPQUFPOHVDO0lBQ1Q7SUFDQTBJLFVBQVUwWCxlQUFlLEtBQUssRUFBRTtRQUM5QixJQUFJLElBQUksQ0FBQ3ZTLE9BQU8sSUFBSTtZQUNsQixPQUFPO1FBQ1Q7UUFDQSxJQUFJLElBQUksQ0FBQ3FMLE9BQU8sRUFBRTtZQUNoQixPQUFPLElBQUksQ0FBQ29hLGdCQUFnQjtRQUM5QjtRQUNBLE1BQU0zNUIsUUFBUWdzQixpQkFBaUJ3QixhQUFhLENBQUMvZCxPQUFPLENBQUMsSUFBSSxDQUFDbWYsZUFBZSxHQUFHbnVCLGlCQUFpQixJQUFJLENBQUNvd0YsU0FBUyxFQUFFN3dGLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUs7UUFDL0gsTUFBTStjLGFBQWExekQsT0FBT2t2QyxNQUFNLENBQUMsS0FBSyxDQUFDd1csVUFBVTBYLGVBQWU7WUFDOUR6bUI7WUFDQW1pRCxVQUFVLElBQUksQ0FBQyxDQUFDQSxRQUFRO1lBQ3hCbDZGLE9BQU8sSUFBSSxDQUFDLENBQUNxckksZ0JBQWdCO1FBQy9CO1FBQ0EsSUFBSSxDQUFDM3FGLFVBQVUsQ0FBQ29VO1FBQ2hCLElBQUkwSixjQUFjO1lBQ2hCMUosV0FBVytjLE1BQU0sR0FBRztZQUNwQixPQUFPL2M7UUFDVDtRQUNBLElBQUksSUFBSSxDQUFDc0MsbUJBQW1CLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ20wRSxpQkFBaUIsQ0FBQ3oyRSxhQUFhO1lBQ3BFLE9BQU87UUFDVDtRQUNBQSxXQUFXcGhELEVBQUUsR0FBRyxJQUFJLENBQUMwakQsbUJBQW1CO1FBQ3hDLE9BQU90QztJQUNUO0lBQ0EsQ0FBQ3kyRSxpQkFBaUIsQ0FBQ3oyRSxVQUFVO1FBQzNCLE1BQU0sRUFDSjkwRCxLQUFLLEVBQ0xrNkYsUUFBUSxFQUNSbmlELEtBQUssRUFDTG1YLFNBQVMsRUFDVixHQUFHLElBQUksQ0FBQytXLFlBQVk7UUFDckIsT0FBTyxJQUFJLENBQUNvSSxnQkFBZ0IsSUFBSSxJQUFJLENBQUMzRSxhQUFhLElBQUk1VSxXQUFXOTBELEtBQUssS0FBS0EsU0FBUzgwRCxXQUFXb2xDLFFBQVEsS0FBS0EsWUFBWXBsQyxXQUFXL2MsS0FBSyxDQUFDcGpDLElBQUksQ0FBQyxDQUFDcUssR0FBR3RiLElBQU1zYixNQUFNKzRCLEtBQUssQ0FBQ3IwQyxFQUFFLEtBQUtveEQsV0FBVzVGLFNBQVMsS0FBS0E7SUFDdE07SUFDQXNOLHdCQUF3QmpGLFVBQVUsRUFBRTtRQUNsQyxNQUFNenJELFVBQVUsS0FBSyxDQUFDMHdELHdCQUF3QmpGO1FBQzlDLElBQUksQ0FBQ3pyRCxTQUFTO1lBQ1osT0FBTztRQUNUO1FBQ0EsTUFBTSxFQUNKVyxLQUFLLEVBQ04sR0FBR1g7UUFDSlcsTUFBTXl0RixRQUFRLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUNBLFFBQVEsQ0FBQywrQkFBK0IsQ0FBQztRQUN4RXp0RixNQUFNc3JDLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUs7UUFDeEJqc0MsUUFBUXMvSCxlQUFlO1FBQ3ZCLEtBQUssTUFBTWx1RixRQUFRLElBQUksQ0FBQyxDQUFDcHhDLE9BQU8sQ0FBQ25LLEtBQUssQ0FBQyxNQUFPO1lBQzVDLE1BQU1zdkMsTUFBTW5rQyxTQUFTMkksYUFBYSxDQUFDO1lBQ25DdzdCLElBQUlwNEIsTUFBTSxDQUFDcWtDLE9BQU9wd0MsU0FBU3NrQyxjQUFjLENBQUM4TCxRQUFRcHdDLFNBQVMySSxhQUFhLENBQUM7WUFDekUzSixRQUFRK00sTUFBTSxDQUFDbzRCO1FBQ2pCO1FBQ0FzbUIsV0FBV2tjLFlBQVksQ0FBQztZQUN0QjVzQyxNQUFNLElBQUksQ0FBQ2lxQyxVQUFVO1lBQ3JCL0IsT0FBTyxJQUFJLENBQUM3dkIsVUFBVSxDQUFDOEMsaUJBQWlCLE1BQU0sSUFBSSxDQUFDcXNCLGdCQUFnQixHQUFHLElBQUksQ0FBQzl2QixPQUFPLEdBQUc7Z0JBQ25GaHpCLE1BQU0sSUFBSSxDQUFDLENBQUN6ZixPQUFPO1lBQ3JCO1FBQ0Y7UUFDQSxPQUFPQTtJQUNUO0lBQ0E0bkUsdUJBQXVCbmMsVUFBVSxFQUFFO1FBQ2pDLEtBQUssQ0FBQ21jLHVCQUF1Qm5jO1FBQzdCQSxXQUFXMi9ELFdBQVc7SUFDeEI7QUFDRjtFQUVDLDBDQUEwQztBQU0zQyxNQUFNc1U7O2FBQ0cvdUYsWUFBWTs7SUFDbkJndkYsWUFBWTtRQUNWbHFHLFlBQVk7SUFDZDtJQUNBLElBQUlraEIsTUFBTTtRQUNSbGhCLFlBQVk7SUFDZDtJQUNBdWxCLFVBQVV5bUMsS0FBSyxFQUFFbStDLFNBQVMsRUFBRTtRQUMxQm5xRyxZQUFZO0lBQ2Q7SUFDQSxPQUFPb3FHLFNBQVMvK0gsR0FBRyxFQUFFd3VELEVBQUUsRUFBRUMsRUFBRSxFQUFFN2hCLEVBQUUsRUFBRUMsRUFBRSxFQUFFNU0sSUFBSSxFQUFFO1FBQ3pDQSxTQUFTLElBQUk3eEIsYUFBYXBPLElBQUk3TixNQUFNO1FBQ3BDLElBQUssSUFBSTJFLElBQUksR0FBR2luQyxLQUFLLzlCLElBQUk3TixNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsS0FBSyxFQUFHO1lBQy9DbXBDLElBQUksQ0FBQ25wQyxFQUFFLEdBQUcwM0QsS0FBS3h1RCxHQUFHLENBQUNsSixFQUFFLEdBQUc4MUM7WUFDeEIzTSxJQUFJLENBQUNucEMsSUFBSSxFQUFFLEdBQUcyM0QsS0FBS3p1RCxHQUFHLENBQUNsSixJQUFJLEVBQUUsR0FBRysxQztRQUNsQztRQUNBLE9BQU81TTtJQUNUO0lBQ0EsT0FBTysrRixnQkFBZ0JoL0gsR0FBRyxFQUFFd3VELEVBQUUsRUFBRUMsRUFBRSxFQUFFN2hCLEVBQUUsRUFBRUMsRUFBRSxFQUFFNU0sSUFBSSxFQUFFO1FBQ2hEQSxTQUFTLElBQUk3eEIsYUFBYXBPLElBQUk3TixNQUFNO1FBQ3BDLElBQUssSUFBSTJFLElBQUksR0FBR2luQyxLQUFLLzlCLElBQUk3TixNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsS0FBSyxFQUFHO1lBQy9DbXBDLElBQUksQ0FBQ25wQyxFQUFFLEdBQUcwM0QsS0FBS3h1RCxHQUFHLENBQUNsSixJQUFJLEVBQUUsR0FBRzgxQztZQUM1QjNNLElBQUksQ0FBQ25wQyxJQUFJLEVBQUUsR0FBRzIzRCxLQUFLenVELEdBQUcsQ0FBQ2xKLEVBQUUsR0FBRysxQztRQUM5QjtRQUNBLE9BQU81TTtJQUNUO0lBQ0EsT0FBT2cvRixXQUFXai9ILEdBQUcsRUFBRXd1RCxFQUFFLEVBQUVDLEVBQUUsRUFBRXh1QixJQUFJLEVBQUU7UUFDbkNBLFNBQVMsSUFBSTd4QixhQUFhcE8sSUFBSTdOLE1BQU07UUFDcEMsSUFBSyxJQUFJMkUsSUFBSSxHQUFHaW5DLEtBQUsvOUIsSUFBSTdOLE1BQU0sRUFBRTJFLElBQUlpbkMsSUFBSWpuQyxLQUFLLEVBQUc7WUFDL0NtcEMsSUFBSSxDQUFDbnBDLEVBQUUsR0FBRzAzRCxLQUFLeHVELEdBQUcsQ0FBQ2xKLEVBQUU7WUFDckJtcEMsSUFBSSxDQUFDbnBDLElBQUksRUFBRSxHQUFHMjNELEtBQUt6dUQsR0FBRyxDQUFDbEosSUFBSSxFQUFFO1FBQy9CO1FBQ0EsT0FBT21wQztJQUNUO0lBQ0EsT0FBT2kvRixTQUFTcG1JLENBQUMsRUFBRTtRQUNqQixPQUFPSCxLQUFLNjFDLEtBQUssQ0FBQzExQyxJQUFJO0lBQ3hCO0lBQ0EsT0FBT214SCxnQkFBZ0JueEgsQ0FBQyxFQUFFME0sQ0FBQyxFQUFFOHBELFdBQVcsRUFBRUMsWUFBWSxFQUFFN29CLFFBQVEsRUFBRTtRQUNoRSxPQUFRQTtZQUNOLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQyxJQUFJbGhDLElBQUk4cEQ7b0JBQWF4MkQsSUFBSXkyRDtpQkFBYTtZQUNoRCxLQUFLO2dCQUNILE9BQU87b0JBQUMsSUFBSXoyRCxJQUFJdzJEO29CQUFhLElBQUk5cEQsSUFBSStwRDtpQkFBYTtZQUNwRCxLQUFLO2dCQUNILE9BQU87b0JBQUMvcEQsSUFBSThwRDtvQkFBYSxJQUFJeDJELElBQUl5MkQ7aUJBQWE7WUFDaEQ7Z0JBQ0UsT0FBTztvQkFBQ3oyRCxJQUFJdzJEO29CQUFhOXBELElBQUkrcEQ7aUJBQWE7UUFDOUM7SUFDRjtJQUNBLE9BQU80dkUsb0JBQW9Ccm1JLENBQUMsRUFBRTBNLENBQUMsRUFBRWtoQyxRQUFRLEVBQUU7UUFDekMsT0FBUUE7WUFDTixLQUFLO2dCQUNILE9BQU87b0JBQUMsSUFBSWxoQztvQkFBRzFNO2lCQUFFO1lBQ25CLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQyxJQUFJQTtvQkFBRyxJQUFJME07aUJBQUU7WUFDdkIsS0FBSztnQkFDSCxPQUFPO29CQUFDQTtvQkFBRyxJQUFJMU07aUJBQUU7WUFDbkI7Z0JBQ0UsT0FBTztvQkFBQ0E7b0JBQUcwTTtpQkFBRTtRQUNqQjtJQUNGO0lBQ0EsT0FBTzQ1SCxtQkFBbUIvaUcsRUFBRSxFQUFFQyxFQUFFLEVBQUVFLEVBQUUsRUFBRUUsRUFBRSxFQUFFRCxFQUFFLEVBQUVFLEVBQUUsRUFBRTtRQUNoRCxPQUFPO1lBQUVOLENBQUFBLEtBQUssSUFBSUcsRUFBQyxJQUFLO1lBQUlGLENBQUFBLEtBQUssSUFBSUksRUFBQyxJQUFLO1lBQUksS0FBSUYsS0FBS0MsRUFBQyxJQUFLO1lBQUksS0FBSUMsS0FBS0MsRUFBQyxJQUFLO1lBQUlILENBQUFBLEtBQUtDLEVBQUMsSUFBSztZQUFJQyxDQUFBQSxLQUFLQyxFQUFDLElBQUs7U0FBRTtJQUNuSDtBQUNGO0VBRUMsMkNBQTJDO0FBUTVDLE1BQU0waUc7SUFDSixDQUFDeHBGLEdBQUcsQ0FBQztJQUNMLENBQUMydUIsTUFBTSxDQUFNO0lBQ2IsQ0FBQzg2RCxXQUFXLENBQUM7SUFDYixDQUFDNXBGLEtBQUssQ0FBQztJQUNQLENBQUM3QyxHQUFHLENBQU07SUFDVixDQUFDMHNGLElBQUksQ0FBd0I7SUFDN0IsQ0FBQzNwRixLQUFLLENBQUM7SUFDUCxDQUFDRCxLQUFLLENBQUM7SUFDUCxDQUFDNzNDLEdBQUcsQ0FBQztJQUNMLENBQUMwaEksUUFBUSxDQUFDO0lBQ1YsQ0FBQ0MsV0FBVyxDQUFDO0lBQ2IsQ0FBQ3ZHLFNBQVMsQ0FBQztJQUNYLENBQUNILE1BQU0sQ0FBTTtJQUNiLE9BQU8sQ0FBQzJHLFFBQVEsR0FBRyxFQUFFO0lBQ3JCLE9BQU8sQ0FBQ0MsUUFBUSxHQUFHLEVBQUU7SUFDckIsT0FBTyxDQUFDQyxHQUFHLEdBQUdQLGlCQUFpQixDQUFDSyxRQUFRLEdBQUdMLGlCQUFpQixDQUFDTSxRQUFRLENBQUM7SUFDdEVwcUksWUFBWSxFQUNWdUQsQ0FBQyxFQUNEME0sQ0FBQyxFQUNGLEVBQUVxd0MsR0FBRyxFQUFFNHBGLFdBQVcsRUFBRXZHLFNBQVMsRUFBRXhqRixLQUFLLEVBQUU0cEYsY0FBYyxDQUFDLENBQUU7YUFsQnhELENBQUM5NkQsTUFBTSxHQUFHLEVBQUU7YUFHWixDQUFDM3hCLEdBQUcsR0FBRyxFQUFFO2FBQ1QsQ0FBQzBzRixJQUFJLEdBQUcsSUFBSW54SCxhQUFhO2FBT3pCLENBQUMycUgsTUFBTSxHQUFHLEVBQUU7UUFRVixJQUFJLENBQUMsQ0FBQ2xqRixHQUFHLEdBQUdBO1FBQ1osSUFBSSxDQUFDLENBQUNxakYsU0FBUyxHQUFHQSxZQUFZdUc7UUFDOUIsSUFBSSxDQUFDLENBQUMvcEYsS0FBSyxHQUFHQTtRQUNkLElBQUksQ0FBQyxDQUFDNnBGLElBQUksQ0FBQzdrSSxHQUFHLENBQUM7WUFBQytKO1lBQUtBO1lBQUtBO1lBQUtBO1lBQUszTDtZQUFHME07U0FBRSxFQUFFO1FBQzNDLElBQUksQ0FBQyxDQUFDODVILFdBQVcsR0FBR0E7UUFDcEIsSUFBSSxDQUFDLENBQUNFLFFBQVEsR0FBR0gsaUJBQWlCLENBQUNLLFFBQVEsR0FBR0Q7UUFDOUMsSUFBSSxDQUFDLENBQUMzaEksR0FBRyxHQUFHdWhJLGlCQUFpQixDQUFDTyxHQUFHLEdBQUdIO1FBQ3BDLElBQUksQ0FBQyxDQUFDQSxXQUFXLEdBQUdBO1FBQ3BCLElBQUksQ0FBQyxDQUFDMUcsTUFBTSxDQUFDMzdILElBQUksQ0FBQ3RFLEdBQUcwTTtJQUN2QjtJQUNBNjVDLFVBQVU7UUFDUixPQUFPMHdCLE1BQU0sSUFBSSxDQUFDLENBQUN3dkQsSUFBSSxDQUFDLEVBQUU7SUFDNUI7SUFDQSxDQUFDTSxhQUFhO1FBQ1osTUFBTUMsVUFBVSxJQUFJLENBQUMsQ0FBQ1AsSUFBSSxDQUFDMW9HLFFBQVEsQ0FBQyxHQUFHO1FBQ3ZDLE1BQU1rcEcsYUFBYSxJQUFJLENBQUMsQ0FBQ1IsSUFBSSxDQUFDMW9HLFFBQVEsQ0FBQyxJQUFJO1FBQzNDLE1BQU0sQ0FBQy85QixHQUFHME0sR0FBRzhoQyxPQUFPQyxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUNzTyxHQUFHO1FBQ3ZDLE9BQU87WUFBRSxLQUFJLENBQUMsQ0FBQ0QsS0FBSyxHQUFHLENBQUNrcUYsT0FBTyxDQUFDLEVBQUUsR0FBR0MsVUFBVSxDQUFDLEVBQUUsSUFBSSxJQUFJam5JLENBQUFBLElBQUt3dUM7WUFBUSxLQUFJLENBQUMsQ0FBQ3FPLEtBQUssR0FBRyxDQUFDbXFGLE9BQU8sQ0FBQyxFQUFFLEdBQUdDLFVBQVUsQ0FBQyxFQUFFLElBQUksSUFBSXY2SCxDQUFBQSxJQUFLK2hDO1lBQVMsS0FBSSxDQUFDLENBQUNxTyxLQUFLLEdBQUcsQ0FBQ21xRixVQUFVLENBQUMsRUFBRSxHQUFHRCxPQUFPLENBQUMsRUFBRSxJQUFJLElBQUlobkksQ0FBQUEsSUFBS3d1QztZQUFRLEtBQUksQ0FBQyxDQUFDcU8sS0FBSyxHQUFHLENBQUNvcUYsVUFBVSxDQUFDLEVBQUUsR0FBR0QsT0FBTyxDQUFDLEVBQUUsSUFBSSxJQUFJdDZILENBQUFBLElBQUsraEM7U0FBTztJQUNuUTtJQUNBdi9CLElBQUksRUFDRmxQLENBQUMsRUFDRDBNLENBQUMsRUFDRixFQUFFO1FBQ0QsSUFBSSxDQUFDLENBQUNvd0MsS0FBSyxHQUFHOThDO1FBQ2QsSUFBSSxDQUFDLENBQUM2OEMsS0FBSyxHQUFHbndDO1FBQ2QsTUFBTSxDQUFDdytDLFFBQVFDLFFBQVEreUMsWUFBWUMsWUFBWSxHQUFHLElBQUksQ0FBQyxDQUFDcGhELEdBQUc7UUFDM0QsSUFBSSxDQUFDeFosSUFBSUMsSUFBSUUsSUFBSUUsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDNmlHLElBQUksQ0FBQzFvRyxRQUFRLENBQUMsR0FBRztRQUM5QyxNQUFNbXBHLFFBQVFsbkksSUFBSTBqQztRQUNsQixNQUFNeWpHLFFBQVF6NkgsSUFBSWszQjtRQUNsQixNQUFNblosSUFBSTVxQixLQUFLcStELEtBQUssQ0FBQ2dwRSxPQUFPQztRQUM1QixJQUFJMThHLElBQUksSUFBSSxDQUFDLENBQUN6bEIsR0FBRyxFQUFFO1lBQ2pCLE9BQU87UUFDVDtRQUNBLE1BQU1vaUksUUFBUTM4RyxJQUFJLElBQUksQ0FBQyxDQUFDaThHLFFBQVE7UUFDaEMsTUFBTWx5RyxJQUFJNHlHLFFBQVEzOEc7UUFDbEIsTUFBTXdnRCxTQUFTejJDLElBQUkweUc7UUFDbkIsTUFBTWg4RCxTQUFTMTJDLElBQUkyeUc7UUFDbkIsSUFBSTlqRyxLQUFLRTtRQUNULElBQUlELEtBQUtFO1FBQ1RELEtBQUtHO1FBQ0xGLEtBQUtJO1FBQ0xGLE1BQU11bkM7UUFDTnJuQyxNQUFNc25DO1FBQ04sSUFBSSxDQUFDLENBQUMrMEQsTUFBTSxFQUFFMzdILEtBQUt0RSxHQUFHME07UUFDdEIsTUFBTTI2SCxLQUFLLENBQUNuOEQsU0FBU2s4RDtRQUNyQixNQUFNRSxLQUFLcjhELFNBQVNtOEQ7UUFDcEIsTUFBTUcsTUFBTUYsS0FBSyxJQUFJLENBQUMsQ0FBQ2pILFNBQVM7UUFDaEMsTUFBTW9ILE1BQU1GLEtBQUssSUFBSSxDQUFDLENBQUNsSCxTQUFTO1FBQ2hDLElBQUksQ0FBQyxDQUFDcUcsSUFBSSxDQUFDN2tJLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzZrSSxJQUFJLENBQUMxb0csUUFBUSxDQUFDLEdBQUcsSUFBSTtRQUMxQyxJQUFJLENBQUMsQ0FBQzBvRyxJQUFJLENBQUM3a0ksR0FBRyxDQUFDO1lBQUM4aEMsS0FBSzZqRztZQUFLM2pHLEtBQUs0akc7U0FBSSxFQUFFO1FBQ3JDLElBQUksQ0FBQyxDQUFDZixJQUFJLENBQUM3a0ksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDNmtJLElBQUksQ0FBQzFvRyxRQUFRLENBQUMsSUFBSSxLQUFLO1FBQzVDLElBQUksQ0FBQyxDQUFDMG9HLElBQUksQ0FBQzdrSSxHQUFHLENBQUM7WUFBQzhoQyxLQUFLNmpHO1lBQUszakcsS0FBSzRqRztTQUFJLEVBQUU7UUFDckMsSUFBSXZ3RCxNQUFNLElBQUksQ0FBQyxDQUFDd3ZELElBQUksQ0FBQyxFQUFFLEdBQUc7WUFDeEIsSUFBSSxJQUFJLENBQUMsQ0FBQzFzRixHQUFHLENBQUMxZ0QsTUFBTSxLQUFLLEdBQUc7Z0JBQzFCLElBQUksQ0FBQyxDQUFDb3RJLElBQUksQ0FBQzdrSSxHQUFHLENBQUM7b0JBQUMyaEMsS0FBS2drRztvQkFBSy9qRyxLQUFLZ2tHO2lCQUFJLEVBQUU7Z0JBQ3JDLElBQUksQ0FBQyxDQUFDenRGLEdBQUcsQ0FBQ3oxQyxJQUFJLENBQUNxSCxLQUFLQSxLQUFLQSxLQUFLQSxLQUFLLENBQUM0M0IsS0FBS2drRyxNQUFNcjhFLE1BQUssSUFBS2d6QyxZQUFZLENBQUMxNkQsS0FBS2drRyxNQUFNcjhFLE1BQUssSUFBS2d6QztnQkFDM0YsSUFBSSxDQUFDLENBQUNzb0MsSUFBSSxDQUFDN2tJLEdBQUcsQ0FBQztvQkFBQzJoQyxLQUFLZ2tHO29CQUFLL2pHLEtBQUtna0c7aUJBQUksRUFBRTtnQkFDckMsSUFBSSxDQUFDLENBQUM5N0QsTUFBTSxDQUFDcG5FLElBQUksQ0FBQ3FILEtBQUtBLEtBQUtBLEtBQUtBLEtBQUssQ0FBQzQzQixLQUFLZ2tHLE1BQU1yOEUsTUFBSyxJQUFLZ3pDLFlBQVksQ0FBQzE2RCxLQUFLZ2tHLE1BQU1yOEUsTUFBSyxJQUFLZ3pDO1lBQ2hHO1lBQ0EsSUFBSSxDQUFDLENBQUNzb0MsSUFBSSxDQUFDN2tJLEdBQUcsQ0FBQztnQkFBQ3loQztnQkFBSUM7Z0JBQUlDO2dCQUFJQztnQkFBSUU7Z0JBQUlFO2FBQUcsRUFBRTtZQUN6QyxPQUFPLENBQUMsSUFBSSxDQUFDMmlCLE9BQU87UUFDdEI7UUFDQSxJQUFJLENBQUMsQ0FBQ2tnRixJQUFJLENBQUM3a0ksR0FBRyxDQUFDO1lBQUN5aEM7WUFBSUM7WUFBSUM7WUFBSUM7WUFBSUU7WUFBSUU7U0FBRyxFQUFFO1FBQ3pDLE1BQU15Z0MsUUFBUXhrRSxLQUFLK0wsR0FBRyxDQUFDL0wsS0FBS200RyxLQUFLLENBQUMxMEUsS0FBS0UsSUFBSUgsS0FBS0UsTUFBTTFqQyxLQUFLbTRHLEtBQUssQ0FBQzlzQyxRQUFRRDtRQUN6RSxJQUFJNUcsUUFBUXhrRSxLQUFLMDBCLEVBQUUsR0FBRyxHQUFHO1lBQ3ZCLENBQUNnUCxJQUFJQyxJQUFJRSxJQUFJRSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM2aUcsSUFBSSxDQUFDMW9HLFFBQVEsQ0FBQyxHQUFHO1lBQzFDLElBQUksQ0FBQyxDQUFDZ2MsR0FBRyxDQUFDejFDLElBQUksQ0FBQ3FILEtBQUtBLEtBQUtBLEtBQUtBLEtBQUssQ0FBQyxDQUFDNDNCLEtBQUtHLEVBQUMsSUFBSyxJQUFJd25CLE1BQUssSUFBS2d6QyxZQUFZLENBQUMsQ0FBQzE2RCxLQUFLSSxFQUFDLElBQUssSUFBSXVuQixNQUFLLElBQUtnekM7WUFDckcsQ0FBQzU2RCxJQUFJQyxJQUFJSCxJQUFJQyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUNtakcsSUFBSSxDQUFDMW9HLFFBQVEsQ0FBQyxJQUFJO1lBQzNDLElBQUksQ0FBQyxDQUFDMnRDLE1BQU0sQ0FBQ3BuRSxJQUFJLENBQUNxSCxLQUFLQSxLQUFLQSxLQUFLQSxLQUFLLENBQUMsQ0FBQzAzQixLQUFLRSxFQUFDLElBQUssSUFBSTJuQixNQUFLLElBQUtnekMsWUFBWSxDQUFDLENBQUM1NkQsS0FBS0UsRUFBQyxJQUFLLElBQUkybkIsTUFBSyxJQUFLZ3pDO1lBQ3hHLE9BQU87UUFDVDtRQUNBLENBQUM5NkQsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUUsSUFBSUUsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDNmlHLElBQUksQ0FBQzFvRyxRQUFRLENBQUMsR0FBRztRQUNsRCxJQUFJLENBQUMsQ0FBQ2djLEdBQUcsQ0FBQ3oxQyxJQUFJLENBQUMsQ0FBQyxDQUFDKytCLEtBQUssSUFBSUUsRUFBQyxJQUFLLElBQUkybkIsTUFBSyxJQUFLZ3pDLFlBQVksQ0FBQyxDQUFDNTZELEtBQUssSUFBSUUsRUFBQyxJQUFLLElBQUkybkIsTUFBSyxJQUFLZ3pDLGFBQWEsQ0FBQyxDQUFDLElBQUk1NkQsS0FBS0csRUFBQyxJQUFLLElBQUl3bkIsTUFBSyxJQUFLZ3pDLFlBQVksQ0FBQyxDQUFDLElBQUkxNkQsS0FBS0ksRUFBQyxJQUFLLElBQUl1bkIsTUFBSyxJQUFLZ3pDLGFBQWEsQ0FBQyxDQUFDNTZELEtBQUtHLEVBQUMsSUFBSyxJQUFJd25CLE1BQUssSUFBS2d6QyxZQUFZLENBQUMsQ0FBQzE2RCxLQUFLSSxFQUFDLElBQUssSUFBSXVuQixNQUFLLElBQUtnekM7UUFDL1AsQ0FBQ3o2RCxJQUFJRSxJQUFJTCxJQUFJQyxJQUFJSCxJQUFJQyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUNtakcsSUFBSSxDQUFDMW9HLFFBQVEsQ0FBQyxJQUFJO1FBQ25ELElBQUksQ0FBQyxDQUFDMnRDLE1BQU0sQ0FBQ3BuRSxJQUFJLENBQUMsQ0FBQyxDQUFDKytCLEtBQUssSUFBSUUsRUFBQyxJQUFLLElBQUkybkIsTUFBSyxJQUFLZ3pDLFlBQVksQ0FBQyxDQUFDNTZELEtBQUssSUFBSUUsRUFBQyxJQUFLLElBQUkybkIsTUFBSyxJQUFLZ3pDLGFBQWEsQ0FBQyxDQUFDLElBQUk1NkQsS0FBS0csRUFBQyxJQUFLLElBQUl3bkIsTUFBSyxJQUFLZ3pDLFlBQVksQ0FBQyxDQUFDLElBQUkxNkQsS0FBS0ksRUFBQyxJQUFLLElBQUl1bkIsTUFBSyxJQUFLZ3pDLGFBQWEsQ0FBQyxDQUFDNTZELEtBQUtHLEVBQUMsSUFBSyxJQUFJd25CLE1BQUssSUFBS2d6QyxZQUFZLENBQUMsQ0FBQzE2RCxLQUFLSSxFQUFDLElBQUssSUFBSXVuQixNQUFLLElBQUtnekM7UUFDbFEsT0FBTztJQUNUO0lBQ0E0bkMsWUFBWTtRQUNWLElBQUksSUFBSSxDQUFDeC9FLE9BQU8sSUFBSTtZQUNsQixPQUFPO1FBQ1Q7UUFDQSxNQUFNeE0sTUFBTSxJQUFJLENBQUMsQ0FBQ0EsR0FBRztRQUNyQixNQUFNMnhCLFNBQVMsSUFBSSxDQUFDLENBQUNBLE1BQU07UUFDM0IsSUFBSXVMLE1BQU0sSUFBSSxDQUFDLENBQUN3dkQsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQ2xnRixPQUFPLElBQUk7WUFDM0MsT0FBTyxJQUFJLENBQUMsQ0FBQ2toRixrQkFBa0I7UUFDakM7UUFDQSxNQUFNMXBJLFNBQVMsRUFBRTtRQUNqQkEsT0FBT3VHLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRXkxQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRUEsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2xDLElBQUssSUFBSS83QyxJQUFJLEdBQUdBLElBQUkrN0MsSUFBSTFnRCxNQUFNLEVBQUUyRSxLQUFLLEVBQUc7WUFDdEMsSUFBSWk1RSxNQUFNbDlCLEdBQUcsQ0FBQy83QyxFQUFFLEdBQUc7Z0JBQ2pCRCxPQUFPdUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFeTFDLEdBQUcsQ0FBQy83QyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUrN0MsR0FBRyxDQUFDLzdDLElBQUksRUFBRSxDQUFDLENBQUM7WUFDNUMsT0FBTztnQkFDTEQsT0FBT3VHLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRXkxQyxHQUFHLENBQUMvN0MsRUFBRSxDQUFDLENBQUMsRUFBRSs3QyxHQUFHLENBQUMvN0MsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFKzdDLEdBQUcsQ0FBQy83QyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUrN0MsR0FBRyxDQUFDLzdDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSs3QyxHQUFHLENBQUMvN0MsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFKzdDLEdBQUcsQ0FBQy83QyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQ2hHO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQzBwSSxZQUFZLENBQUMzcEk7UUFDbkIsSUFBSyxJQUFJQyxJQUFJMHRFLE9BQU9yeUUsTUFBTSxHQUFHLEdBQUcyRSxLQUFLLEdBQUdBLEtBQUssRUFBRztZQUM5QyxJQUFJaTVFLE1BQU12TCxNQUFNLENBQUMxdEUsRUFBRSxHQUFHO2dCQUNwQkQsT0FBT3VHLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRW9uRSxNQUFNLENBQUMxdEUsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFMHRFLE1BQU0sQ0FBQzF0RSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQ2xELE9BQU87Z0JBQ0xELE9BQU91RyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUVvbkUsTUFBTSxDQUFDMXRFLEVBQUUsQ0FBQyxDQUFDLEVBQUUwdEUsTUFBTSxDQUFDMXRFLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRTB0RSxNQUFNLENBQUMxdEUsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFMHRFLE1BQU0sQ0FBQzF0RSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUwdEUsTUFBTSxDQUFDMXRFLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRTB0RSxNQUFNLENBQUMxdEUsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUNsSDtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUMycEksY0FBYyxDQUFDNXBJO1FBQ3JCLE9BQU9BLE9BQU9qQyxJQUFJLENBQUM7SUFDckI7SUFDQSxDQUFDMnJJLGtCQUFrQjtRQUNqQixNQUFNLENBQUN6bkksR0FBRzBNLEdBQUc4aEMsT0FBT0MsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDc08sR0FBRztRQUN2QyxNQUFNLENBQUM2cUYsVUFBVUMsVUFBVUMsYUFBYUMsWUFBWSxHQUFHLElBQUksQ0FBQyxDQUFDaEIsYUFBYTtRQUMxRSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUNOLElBQUksQ0FBQyxFQUFFLEdBQUd6bUksQ0FBQUEsSUFBS3d1QyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDaTRGLElBQUksQ0FBQyxFQUFFLEdBQUcvNUgsQ0FBQUEsSUFBSytoQyxPQUFPLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDZzRGLElBQUksQ0FBQyxFQUFFLEdBQUd6bUksQ0FBQUEsSUFBS3d1QyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDaTRGLElBQUksQ0FBQyxFQUFFLEdBQUcvNUgsQ0FBQUEsSUFBSytoQyxPQUFPLEVBQUUsRUFBRW01RixTQUFTLENBQUMsRUFBRUMsU0FBUyxFQUFFLEVBQUVDLFlBQVksQ0FBQyxFQUFFQyxZQUFZLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDdEIsSUFBSSxDQUFDLEdBQUcsR0FBR3ptSSxDQUFBQSxJQUFLd3VDLE1BQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUNpNEYsSUFBSSxDQUFDLEdBQUcsR0FBRy81SCxDQUFBQSxJQUFLK2hDLE9BQU8sRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUNnNEYsSUFBSSxDQUFDLEdBQUcsR0FBR3ptSSxDQUFBQSxJQUFLd3VDLE1BQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUNpNEYsSUFBSSxDQUFDLEdBQUcsR0FBRy81SCxDQUFBQSxJQUFLK2hDLE9BQU8sRUFBRSxDQUFDO0lBQ3hVO0lBQ0EsQ0FBQ2s1RixjQUFjLENBQUM1cEksTUFBTTtRQUNwQixNQUFNMnRFLFNBQVMsSUFBSSxDQUFDLENBQUNBLE1BQU07UUFDM0IzdEUsT0FBT3VHLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRW9uRSxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRUEsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7SUFDNUM7SUFDQSxDQUFDZzhELFlBQVksQ0FBQzNwSSxNQUFNO1FBQ2xCLE1BQU0sQ0FBQ2lDLEdBQUcwTSxHQUFHOGhDLE9BQU9DLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQ3NPLEdBQUc7UUFDdkMsTUFBTWlxRixVQUFVLElBQUksQ0FBQyxDQUFDUCxJQUFJLENBQUMxb0csUUFBUSxDQUFDLEdBQUc7UUFDdkMsTUFBTWtwRyxhQUFhLElBQUksQ0FBQyxDQUFDUixJQUFJLENBQUMxb0csUUFBUSxDQUFDLElBQUk7UUFDM0MsTUFBTSxDQUFDNnBHLFVBQVVDLFVBQVVDLGFBQWFDLFlBQVksR0FBRyxJQUFJLENBQUMsQ0FBQ2hCLGFBQWE7UUFDMUVocEksT0FBT3VHLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDMGlJLE9BQU8sQ0FBQyxFQUFFLEdBQUdobkksQ0FBQUEsSUFBS3d1QyxNQUFNLENBQUMsRUFBRSxDQUFDdzRGLE9BQU8sQ0FBQyxFQUFFLEdBQUd0NkgsQ0FBQUEsSUFBSytoQyxPQUFPLEVBQUUsRUFBRW01RixTQUFTLENBQUMsRUFBRUMsU0FBUyxFQUFFLEVBQUVDLFlBQVksQ0FBQyxFQUFFQyxZQUFZLEVBQUUsRUFBRSxDQUFDZCxVQUFVLENBQUMsRUFBRSxHQUFHam5JLENBQUFBLElBQUt3dUMsTUFBTSxDQUFDLEVBQUUsQ0FBQ3k0RixVQUFVLENBQUMsRUFBRSxHQUFHdjZILENBQUFBLElBQUsraEMsT0FBTyxDQUFDO0lBQ2pNO0lBQ0F1NUYsbUJBQW1CQyxPQUFPLEVBQUVoSSxNQUFNLEVBQUVsakYsR0FBRyxFQUFFNHBGLFdBQVcsRUFBRUgsV0FBVyxFQUFFNXBGLEtBQUssRUFBRTtRQUN4RSxPQUFPLElBQUlzckYsZ0JBQWdCRCxTQUFTaEksUUFBUWxqRixLQUFLNHBGLGFBQWFILGFBQWE1cEY7SUFDN0U7SUFDQXVyRixjQUFjO1FBQ1osTUFBTXB1RixNQUFNLElBQUksQ0FBQyxDQUFDQSxHQUFHO1FBQ3JCLE1BQU0yeEIsU0FBUyxJQUFJLENBQUMsQ0FBQ0EsTUFBTTtRQUMzQixNQUFNKzZELE9BQU8sSUFBSSxDQUFDLENBQUNBLElBQUk7UUFDdkIsTUFBTSxDQUFDdjdFLFFBQVFDLFFBQVEreUMsWUFBWUMsWUFBWSxHQUFHLElBQUksQ0FBQyxDQUFDcGhELEdBQUc7UUFDM0QsTUFBTWtqRixTQUFTLElBQUkzcUgsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDMnFILE1BQU0sRUFBRTVtSSxVQUFVLEtBQUs7UUFDOUQsSUFBSyxJQUFJMkUsSUFBSSxHQUFHaW5DLEtBQUtnN0YsT0FBTzVtSSxNQUFNLEdBQUcsR0FBRzJFLElBQUlpbkMsSUFBSWpuQyxLQUFLLEVBQUc7WUFDdERpaUksTUFBTSxDQUFDamlJLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDaWlJLE1BQU0sQ0FBQ2ppSSxFQUFFLEdBQUdrdEQsTUFBSyxJQUFLZ3pDO1lBQ3pDK2hDLE1BQU0sQ0FBQ2ppSSxJQUFJLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDaWlJLE1BQU0sQ0FBQ2ppSSxJQUFJLEVBQUUsR0FBR210RCxNQUFLLElBQUtnekM7UUFDbkQ7UUFDQThoQyxNQUFNLENBQUNBLE9BQU81bUksTUFBTSxHQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDeWpELEtBQUssR0FBR29PLE1BQUssSUFBS2d6QztRQUNyRCtoQyxNQUFNLENBQUNBLE9BQU81bUksTUFBTSxHQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDd2pELEtBQUssR0FBR3NPLE1BQUssSUFBS2d6QztRQUNyRCxJQUFJbG5CLE1BQU13dkQsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQ2xnRixPQUFPLElBQUk7WUFDckMsT0FBTyxJQUFJLENBQUMsQ0FBQzZoRixtQkFBbUIsQ0FBQ25JO1FBQ25DO1FBQ0EsTUFBTWdJLFVBQVUsSUFBSTN5SCxhQUFhLElBQUksQ0FBQyxDQUFDeWtDLEdBQUcsQ0FBQzFnRCxNQUFNLEdBQUcsS0FBSyxJQUFJLENBQUMsQ0FBQ3F5RSxNQUFNLENBQUNyeUUsTUFBTTtRQUM1RSxJQUFJZ3ZJLElBQUl0dUYsSUFBSTFnRCxNQUFNO1FBQ2xCLElBQUssSUFBSTJFLElBQUksR0FBR0EsSUFBSXFxSSxHQUFHcnFJLEtBQUssRUFBRztZQUM3QixJQUFJaTVFLE1BQU1sOUIsR0FBRyxDQUFDLzdDLEVBQUUsR0FBRztnQkFDakJpcUksT0FBTyxDQUFDanFJLEVBQUUsR0FBR2lxSSxPQUFPLENBQUNqcUksSUFBSSxFQUFFLEdBQUcyTjtnQkFDOUI7WUFDRjtZQUNBczhILE9BQU8sQ0FBQ2pxSSxFQUFFLEdBQUcrN0MsR0FBRyxDQUFDLzdDLEVBQUU7WUFDbkJpcUksT0FBTyxDQUFDanFJLElBQUksRUFBRSxHQUFHKzdDLEdBQUcsQ0FBQy83QyxJQUFJLEVBQUU7UUFDN0I7UUFDQXFxSSxJQUFJLElBQUksQ0FBQyxDQUFDQyxhQUFhLENBQUNMLFNBQVNJO1FBQ2pDLElBQUssSUFBSXJxSSxJQUFJMHRFLE9BQU9yeUUsTUFBTSxHQUFHLEdBQUcyRSxLQUFLLEdBQUdBLEtBQUssRUFBRztZQUM5QyxJQUFLLElBQUlzUCxJQUFJLEdBQUdBLElBQUksR0FBR0EsS0FBSyxFQUFHO2dCQUM3QixJQUFJMnBFLE1BQU12TCxNQUFNLENBQUMxdEUsSUFBSXNQLEVBQUUsR0FBRztvQkFDeEIyNkgsT0FBTyxDQUFDSSxFQUFFLEdBQUdKLE9BQU8sQ0FBQ0ksSUFBSSxFQUFFLEdBQUcxOEg7b0JBQzlCMDhILEtBQUs7b0JBQ0w7Z0JBQ0Y7Z0JBQ0FKLE9BQU8sQ0FBQ0ksRUFBRSxHQUFHMzhELE1BQU0sQ0FBQzF0RSxJQUFJc1AsRUFBRTtnQkFDMUIyNkgsT0FBTyxDQUFDSSxJQUFJLEVBQUUsR0FBRzM4RCxNQUFNLENBQUMxdEUsSUFBSXNQLElBQUksRUFBRTtnQkFDbEMrNkgsS0FBSztZQUNQO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQ0UsZUFBZSxDQUFDTixTQUFTSTtRQUMvQixPQUFPLElBQUksQ0FBQ0wsa0JBQWtCLENBQUNDLFNBQVNoSSxRQUFRLElBQUksQ0FBQyxDQUFDbGpGLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQzRwRixXQUFXLEVBQUUsSUFBSSxDQUFDLENBQUNILFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQzVwRixLQUFLO0lBQzlHO0lBQ0EsQ0FBQ3dyRixtQkFBbUIsQ0FBQ25JLE1BQU07UUFDekIsTUFBTXdHLE9BQU8sSUFBSSxDQUFDLENBQUNBLElBQUk7UUFDdkIsTUFBTSxDQUFDdjdFLFFBQVFDLFFBQVEreUMsWUFBWUMsWUFBWSxHQUFHLElBQUksQ0FBQyxDQUFDcGhELEdBQUc7UUFDM0QsTUFBTSxDQUFDNnFGLFVBQVVDLFVBQVVDLGFBQWFDLFlBQVksR0FBRyxJQUFJLENBQUMsQ0FBQ2hCLGFBQWE7UUFDMUUsTUFBTWtCLFVBQVUsSUFBSTN5SCxhQUFhO1FBQ2pDMnlILFFBQVFybUksR0FBRyxDQUFDO1lBQUMrSjtZQUFLQTtZQUFLQTtZQUFLQTtZQUFNODZILENBQUFBLElBQUksQ0FBQyxFQUFFLEdBQUd2N0UsTUFBSyxJQUFLZ3pDO1lBQWF1b0MsQ0FBQUEsSUFBSSxDQUFDLEVBQUUsR0FBR3Q3RSxNQUFLLElBQUtnekM7WUFBYXh5RjtZQUFLQTtZQUFLQTtZQUFLQTtZQUFNODZILENBQUFBLElBQUksQ0FBQyxFQUFFLEdBQUd2N0UsTUFBSyxJQUFLZ3pDO1lBQWF1b0MsQ0FBQUEsSUFBSSxDQUFDLEVBQUUsR0FBR3Q3RSxNQUFLLElBQUtnekM7WUFBYXh5RjtZQUFLQTtZQUFLQTtZQUFLQTtZQUFLaThIO1lBQVVDO1lBQVVsOEg7WUFBS0E7WUFBS0E7WUFBS0E7WUFBS204SDtZQUFhQztZQUFhcDhIO1lBQUtBO1lBQUtBO1lBQUtBO1lBQU04NkgsQ0FBQUEsSUFBSSxDQUFDLEdBQUcsR0FBR3Y3RSxNQUFLLElBQUtnekM7WUFBYXVvQyxDQUFBQSxJQUFJLENBQUMsR0FBRyxHQUFHdDdFLE1BQUssSUFBS2d6QztZQUFheHlGO1lBQUtBO1lBQUtBO1lBQUtBO1lBQU04NkgsQ0FBQUEsSUFBSSxDQUFDLEdBQUcsR0FBR3Y3RSxNQUFLLElBQUtnekM7WUFBYXVvQyxDQUFBQSxJQUFJLENBQUMsR0FBRyxHQUFHdDdFLE1BQUssSUFBS2d6QztTQUFZLEVBQUU7UUFDcGMsT0FBTyxJQUFJLENBQUM2cEMsa0JBQWtCLENBQUNDLFNBQVNoSSxRQUFRLElBQUksQ0FBQyxDQUFDbGpGLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQzRwRixXQUFXLEVBQUUsSUFBSSxDQUFDLENBQUNILFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQzVwRixLQUFLO0lBQzlHO0lBQ0EsQ0FBQzJyRixlQUFlLENBQUNOLE9BQU8sRUFBRTFuRyxHQUFHO1FBQzNCLE1BQU1tckMsU0FBUyxJQUFJLENBQUMsQ0FBQ0EsTUFBTTtRQUMzQnU4RCxRQUFRcm1JLEdBQUcsQ0FBQztZQUFDK0o7WUFBS0E7WUFBS0E7WUFBS0E7WUFBSysvRCxNQUFNLENBQUMsRUFBRTtZQUFFQSxNQUFNLENBQUMsRUFBRTtTQUFDLEVBQUVuckM7UUFDeEQsT0FBT0EsT0FBTztJQUNoQjtJQUNBLENBQUMrbkcsYUFBYSxDQUFDTCxPQUFPLEVBQUUxbkcsR0FBRztRQUN6QixNQUFNeW1HLFVBQVUsSUFBSSxDQUFDLENBQUNQLElBQUksQ0FBQzFvRyxRQUFRLENBQUMsR0FBRztRQUN2QyxNQUFNa3BHLGFBQWEsSUFBSSxDQUFDLENBQUNSLElBQUksQ0FBQzFvRyxRQUFRLENBQUMsSUFBSTtRQUMzQyxNQUFNLENBQUNtdEIsUUFBUUMsUUFBUSt5QyxZQUFZQyxZQUFZLEdBQUcsSUFBSSxDQUFDLENBQUNwaEQsR0FBRztRQUMzRCxNQUFNLENBQUM2cUYsVUFBVUMsVUFBVUMsYUFBYUMsWUFBWSxHQUFHLElBQUksQ0FBQyxDQUFDaEIsYUFBYTtRQUMxRWtCLFFBQVFybUksR0FBRyxDQUFDO1lBQUMrSjtZQUFLQTtZQUFLQTtZQUFLQTtZQUFNcTdILENBQUFBLE9BQU8sQ0FBQyxFQUFFLEdBQUc5N0UsTUFBSyxJQUFLZ3pDO1lBQWE4b0MsQ0FBQUEsT0FBTyxDQUFDLEVBQUUsR0FBRzc3RSxNQUFLLElBQUtnekM7WUFBYXh5RjtZQUFLQTtZQUFLQTtZQUFLQTtZQUFLaThIO1lBQVVDO1lBQVVsOEg7WUFBS0E7WUFBS0E7WUFBS0E7WUFBS204SDtZQUFhQztZQUFhcDhIO1lBQUtBO1lBQUtBO1lBQUtBO1lBQU1zN0gsQ0FBQUEsVUFBVSxDQUFDLEVBQUUsR0FBRy83RSxNQUFLLElBQUtnekM7WUFBYStvQyxDQUFBQSxVQUFVLENBQUMsRUFBRSxHQUFHOTdFLE1BQUssSUFBS2d6QztTQUFZLEVBQUU1OUQ7UUFDcFMsT0FBT0EsT0FBTztJQUNoQjtBQUNGO0FBQ0EsTUFBTTJuRyx3QkFBd0JwQztJQUM1QixDQUFDL29GLEdBQUcsQ0FBQztJQUNMLENBQUN5NUIsSUFBSSxDQUF1QjtJQUM1QixDQUFDZ3dELFdBQVcsQ0FBQztJQUNiLENBQUM1cEYsS0FBSyxDQUFDO0lBQ1AsQ0FBQ3FqRixNQUFNLENBQUM7SUFDUixDQUFDMEcsV0FBVyxDQUFDO0lBQ2IsQ0FBQ3NCLE9BQU8sQ0FBQztJQUNUeHJJLFlBQVl3ckksT0FBTyxFQUFFaEksTUFBTSxFQUFFbGpGLEdBQUcsRUFBRTRwRixXQUFXLEVBQUVILFdBQVcsRUFBRTVwRixLQUFLLENBQUU7UUFDakUsS0FBSzthQVBQLENBQUM0NUIsSUFBSSxHQUFHLElBQUlsaEUsYUFBYTtRQVF2QixJQUFJLENBQUMsQ0FBQzJ5SCxPQUFPLEdBQUdBO1FBQ2hCLElBQUksQ0FBQyxDQUFDaEksTUFBTSxHQUFHQTtRQUNmLElBQUksQ0FBQyxDQUFDbGpGLEdBQUcsR0FBR0E7UUFDWixJQUFJLENBQUMsQ0FBQzRwRixXQUFXLEdBQUdBO1FBQ3BCLElBQUksQ0FBQyxDQUFDSCxXQUFXLEdBQUdBO1FBQ3BCLElBQUksQ0FBQyxDQUFDNXBGLEtBQUssR0FBR0E7UUFDZCxJQUFJLENBQUM0ckYsVUFBVSxHQUFHO1lBQUM3OEg7WUFBS0E7U0FBSTtRQUM1QixJQUFJLENBQUM4OEgsU0FBUyxHQUFHO1lBQUM5OEg7WUFBS0E7U0FBSTtRQUMzQixJQUFJLENBQUMsQ0FBQys4SCxhQUFhLENBQUM5ckY7UUFDcEIsTUFBTSxDQUFDNThDLEdBQUcwTSxHQUFHOGhDLE9BQU9DLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQytuQyxJQUFJO1FBQ3hDLElBQUssSUFBSXg0RSxJQUFJLEdBQUdpbkMsS0FBS2dqRyxRQUFRNXVJLE1BQU0sRUFBRTJFLElBQUlpbkMsSUFBSWpuQyxLQUFLLEVBQUc7WUFDbkRpcUksT0FBTyxDQUFDanFJLEVBQUUsR0FBRyxDQUFDaXFJLE9BQU8sQ0FBQ2pxSSxFQUFFLEdBQUdnQyxDQUFBQSxJQUFLd3VDO1lBQ2hDeTVGLE9BQU8sQ0FBQ2pxSSxJQUFJLEVBQUUsR0FBRyxDQUFDaXFJLE9BQU8sQ0FBQ2pxSSxJQUFJLEVBQUUsR0FBRzBPLENBQUFBLElBQUsraEM7UUFDMUM7UUFDQSxJQUFLLElBQUl6d0MsSUFBSSxHQUFHaW5DLEtBQUtnN0YsT0FBTzVtSSxNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsS0FBSyxFQUFHO1lBQ2xEaWlJLE1BQU0sQ0FBQ2ppSSxFQUFFLEdBQUcsQ0FBQ2lpSSxNQUFNLENBQUNqaUksRUFBRSxHQUFHZ0MsQ0FBQUEsSUFBS3d1QztZQUM5Qnl4RixNQUFNLENBQUNqaUksSUFBSSxFQUFFLEdBQUcsQ0FBQ2lpSSxNQUFNLENBQUNqaUksSUFBSSxFQUFFLEdBQUcwTyxDQUFBQSxJQUFLK2hDO1FBQ3hDO0lBQ0Y7SUFDQXMzRixZQUFZO1FBQ1YsTUFBTWhvSSxTQUFTO1lBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUNrcUksT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUNBLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUFDO1FBQzNELElBQUssSUFBSWpxSSxJQUFJLEdBQUdpbkMsS0FBSyxJQUFJLENBQUMsQ0FBQ2dqRyxPQUFPLENBQUM1dUksTUFBTSxFQUFFMkUsSUFBSWluQyxJQUFJam5DLEtBQUssRUFBRztZQUN6RCxJQUFJaTVFLE1BQU0sSUFBSSxDQUFDLENBQUNneEQsT0FBTyxDQUFDanFJLEVBQUUsR0FBRztnQkFDM0JELE9BQU91RyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMyakksT0FBTyxDQUFDanFJLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQ2lxSSxPQUFPLENBQUNqcUksSUFBSSxFQUFFLENBQUMsQ0FBQztnQkFDOUQ7WUFDRjtZQUNBRCxPQUFPdUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDMmpJLE9BQU8sQ0FBQ2pxSSxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDaXFJLE9BQU8sQ0FBQ2pxSSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUNpcUksT0FBTyxDQUFDanFJLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQ2lxSSxPQUFPLENBQUNqcUksSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDaXFJLE9BQU8sQ0FBQ2pxSSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUNpcUksT0FBTyxDQUFDanFJLElBQUksRUFBRSxDQUFDLENBQUM7UUFDNUo7UUFDQUQsT0FBT3VHLElBQUksQ0FBQztRQUNaLE9BQU92RyxPQUFPakMsSUFBSSxDQUFDO0lBQ3JCO0lBQ0FzbEQsVUFBVSxDQUFDOG5CLEtBQUtDLEtBQUtDLEtBQUtILElBQUksRUFBRXI3QixRQUFRLEVBQUU7UUFDeEMsTUFBTVksUUFBUTQ2QixNQUFNRjtRQUNwQixNQUFNejZCLFNBQVN3NkIsTUFBTUU7UUFDckIsSUFBSTgrRDtRQUNKLElBQUloSTtRQUNKLE9BQVFyeUY7WUFDTixLQUFLO2dCQUNIcTZGLFVBQVVuQyxRQUFRRyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUNnQyxPQUFPLEVBQUUvK0QsS0FBS0QsS0FBS3o2QixPQUFPLENBQUNDO2dCQUM1RHd4RixTQUFTNkYsUUFBUUcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDaEcsTUFBTSxFQUFFLzJELEtBQUtELEtBQUt6NkIsT0FBTyxDQUFDQztnQkFDMUQ7WUFDRixLQUFLO2dCQUNIdzVGLFVBQVVuQyxRQUFRSSxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMrQixPQUFPLEVBQUUvK0QsS0FBS0MsS0FBSzM2QixPQUFPQztnQkFDbEV3eEYsU0FBUzZGLFFBQVFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQ2pHLE1BQU0sRUFBRS8yRCxLQUFLQyxLQUFLMzZCLE9BQU9DO2dCQUNoRTtZQUNGLEtBQUs7Z0JBQ0h3NUYsVUFBVW5DLFFBQVFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQ2dDLE9BQU8sRUFBRTcrRCxLQUFLRCxLQUFLLENBQUMzNkIsT0FBT0M7Z0JBQzVEd3hGLFNBQVM2RixRQUFRRyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUNoRyxNQUFNLEVBQUU3MkQsS0FBS0QsS0FBSyxDQUFDMzZCLE9BQU9DO2dCQUMxRDtZQUNGLEtBQUs7Z0JBQ0h3NUYsVUFBVW5DLFFBQVFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQytCLE9BQU8sRUFBRTcrRCxLQUFLSCxLQUFLLENBQUN6NkIsT0FBTyxDQUFDQztnQkFDcEV3eEYsU0FBUzZGLFFBQVFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQ2pHLE1BQU0sRUFBRTcyRCxLQUFLSCxLQUFLLENBQUN6NkIsT0FBTyxDQUFDQztnQkFDbEU7UUFDSjtRQUNBLE9BQU87WUFDTHc1RixTQUFTNzhILE1BQU1xVyxJQUFJLENBQUN3bUg7WUFDcEJoSSxRQUFRO2dCQUFDNzBILE1BQU1xVyxJQUFJLENBQUN3K0c7YUFBUTtRQUM5QjtJQUNGO0lBQ0EsQ0FBQ3lJLGFBQWEsQ0FBQzlyRixLQUFLO1FBQ2xCLE1BQU1xckYsVUFBVSxJQUFJLENBQUMsQ0FBQ0EsT0FBTztRQUM3QixJQUFJbnJGLFFBQVFtckYsT0FBTyxDQUFDLEVBQUU7UUFDdEIsSUFBSXByRixRQUFRb3JGLE9BQU8sQ0FBQyxFQUFFO1FBQ3RCLE1BQU1qb0csU0FBUztZQUFDOGM7WUFBT0Q7WUFBT0M7WUFBT0Q7U0FBTTtRQUMzQyxJQUFJOHJGLGNBQWM3ckY7UUFDbEIsSUFBSThyRixjQUFjL3JGO1FBQ2xCLElBQUlnc0YsYUFBYS9yRjtRQUNqQixJQUFJZ3NGLGFBQWFqc0Y7UUFDakIsTUFBTWtzRixjQUFjbnNGLFFBQVEvOEMsS0FBSzRQLEdBQUcsR0FBRzVQLEtBQUttRixHQUFHO1FBQy9DLE1BQU1na0ksYUFBYSxJQUFJMXpILGFBQWE7UUFDcEMsSUFBSyxJQUFJdFgsSUFBSSxHQUFHaW5DLEtBQUtnakcsUUFBUTV1SSxNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsS0FBSyxFQUFHO1lBQ25ELE1BQU1nQyxJQUFJaW9JLE9BQU8sQ0FBQ2pxSSxJQUFJLEVBQUUsRUFDdEIwTyxJQUFJdTdILE9BQU8sQ0FBQ2pxSSxJQUFJLEVBQUU7WUFDcEIsSUFBSWk1RSxNQUFNZ3hELE9BQU8sQ0FBQ2pxSSxFQUFFLEdBQUc7Z0JBQ3JCeWhDLEtBQUswRCxnQkFBZ0IsQ0FBQ25qQyxHQUFHME0sR0FBR3N6QjtnQkFDNUIsSUFBSTRvRyxjQUFjbDhILEdBQUc7b0JBQ25CaThILGNBQWMzb0k7b0JBQ2Q0b0ksY0FBY2w4SDtnQkFDaEIsT0FBTyxJQUFJazhILGdCQUFnQmw4SCxHQUFHO29CQUM1Qmk4SCxjQUFjSSxZQUFZSixhQUFhM29JO2dCQUN6QztnQkFDQSxJQUFJOG9JLGFBQWFwOEgsR0FBRztvQkFDbEJtOEgsYUFBYTdvSTtvQkFDYjhvSSxhQUFhcDhIO2dCQUNmLE9BQU8sSUFBSW84SCxlQUFlcDhILEdBQUc7b0JBQzNCbThILGFBQWFFLFlBQVlGLFlBQVk3b0k7Z0JBQ3ZDO1lBQ0YsT0FBTztnQkFDTGdwSSxVQUFVLENBQUMsRUFBRSxHQUFHQSxVQUFVLENBQUMsRUFBRSxHQUFHdjlIO2dCQUNoQ3U5SCxVQUFVLENBQUMsRUFBRSxHQUFHQSxVQUFVLENBQUMsRUFBRSxHQUFHLENBQUN2OUg7Z0JBQ2pDZzBCLEtBQUs0RSxpQkFBaUIsQ0FBQ3lZLE9BQU9ELFVBQVVvckYsUUFBUXJzSSxLQUFLLENBQUNvQyxHQUFHQSxJQUFJLElBQUlnckk7Z0JBQ2pFdnBHLEtBQUsyRCxlQUFlLENBQUM0bEcsVUFBVSxDQUFDLEVBQUUsRUFBRUEsVUFBVSxDQUFDLEVBQUUsRUFBRUEsVUFBVSxDQUFDLEVBQUUsRUFBRUEsVUFBVSxDQUFDLEVBQUUsRUFBRWhwRztnQkFDakYsSUFBSTRvRyxjQUFjSSxVQUFVLENBQUMsRUFBRSxFQUFFO29CQUMvQkwsY0FBY0ssVUFBVSxDQUFDLEVBQUU7b0JBQzNCSixjQUFjSSxVQUFVLENBQUMsRUFBRTtnQkFDN0IsT0FBTyxJQUFJSixnQkFBZ0JJLFVBQVUsQ0FBQyxFQUFFLEVBQUU7b0JBQ3hDTCxjQUFjSSxZQUFZSixhQUFhSyxVQUFVLENBQUMsRUFBRTtnQkFDdEQ7Z0JBQ0EsSUFBSUYsYUFBYUUsVUFBVSxDQUFDLEVBQUUsRUFBRTtvQkFDOUJILGFBQWFHLFVBQVUsQ0FBQyxFQUFFO29CQUMxQkYsYUFBYUUsVUFBVSxDQUFDLEVBQUU7Z0JBQzVCLE9BQU8sSUFBSUYsZUFBZUUsVUFBVSxDQUFDLEVBQUUsRUFBRTtvQkFDdkNILGFBQWFFLFlBQVlGLFlBQVlHLFVBQVUsQ0FBQyxFQUFFO2dCQUNwRDtZQUNGO1lBQ0Fsc0YsUUFBUTk4QztZQUNSNjhDLFFBQVFud0M7UUFDVjtRQUNBLE1BQU04cEUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsSUFBSTtRQUN2QkEsSUFBSSxDQUFDLEVBQUUsR0FBR3gyQyxNQUFNLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDd21HLFdBQVc7UUFDdkNod0QsSUFBSSxDQUFDLEVBQUUsR0FBR3gyQyxNQUFNLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDd21HLFdBQVc7UUFDdkNod0QsSUFBSSxDQUFDLEVBQUUsR0FBR3gyQyxNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRSxHQUFHLElBQUksSUFBSSxDQUFDLENBQUN3bUcsV0FBVztRQUN2RGh3RCxJQUFJLENBQUMsRUFBRSxHQUFHeDJDLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQ3dtRyxXQUFXO1FBQ3ZELElBQUksQ0FBQ2dDLFVBQVUsR0FBRztZQUFDRztZQUFhQztTQUFZO1FBQzVDLElBQUksQ0FBQ0gsU0FBUyxHQUFHO1lBQUNJO1lBQVlDO1NBQVc7SUFDM0M7SUFDQSxJQUFJL3JGLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxDQUFDeTVCLElBQUk7SUFDbkI7SUFDQXl5RCxZQUFZemlFLEtBQUssRUFBRXpwQixHQUFHLEVBQUU0cEYsV0FBVyxFQUFFdkcsU0FBUyxFQUFFeGpGLEtBQUssRUFBRTRwRixjQUFjLENBQUMsRUFBRTtRQUN0RSxPQUFPLElBQUlELGlCQUFpQi8vRCxPQUFPenBCLEtBQUs0cEYsYUFBYXZHLFdBQVd4akYsT0FBTzRwRjtJQUN6RTtJQUNBMEMsY0FBYzlJLFNBQVMsRUFBRW9HLFdBQVcsRUFBRTtRQUNwQyxNQUFNLENBQUN4bUksR0FBRzBNLEdBQUc4aEMsT0FBT0MsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDK25DLElBQUk7UUFDeEMsTUFBTSxDQUFDdHJCLFFBQVFDLFFBQVEreUMsWUFBWUMsWUFBWSxHQUFHLElBQUksQ0FBQyxDQUFDcGhELEdBQUc7UUFDM0QsTUFBTWpKLEtBQUt0RixRQUFRMHZEO1FBQ25CLE1BQU1ucUQsS0FBS3RGLFNBQVMwdkQ7UUFDcEIsTUFBTXpvQyxLQUFLMTFELElBQUlrK0YsYUFBYWh6QztRQUM1QixNQUFNeUssS0FBS2pwRCxJQUFJeXhGLGNBQWNoekM7UUFDN0IsTUFBTWcrRSxXQUFXLElBQUksQ0FBQ0YsV0FBVyxDQUFDO1lBQ2hDanBJLEdBQUcsSUFBSSxDQUFDLENBQUNpZ0ksTUFBTSxDQUFDLEVBQUUsR0FBR25zRixLQUFLNGhCO1lBQzFCaHBELEdBQUcsSUFBSSxDQUFDLENBQUN1ekgsTUFBTSxDQUFDLEVBQUUsR0FBR2xzRixLQUFLNGhCO1FBQzVCLEdBQUcsSUFBSSxDQUFDLENBQUM1WSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM0cEYsV0FBVyxFQUFFdkcsV0FBVyxJQUFJLENBQUMsQ0FBQ3hqRixLQUFLLEVBQUU0cEYsZUFBZSxJQUFJLENBQUMsQ0FBQ0EsV0FBVztRQUN6RixJQUFLLElBQUl4b0ksSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQyxDQUFDaWlJLE1BQU0sQ0FBQzVtSSxNQUFNLEVBQUUyRSxLQUFLLEVBQUc7WUFDL0NtckksU0FBU2o2SCxHQUFHLENBQUM7Z0JBQ1hsUCxHQUFHLElBQUksQ0FBQyxDQUFDaWdJLE1BQU0sQ0FBQ2ppSSxFQUFFLEdBQUc4MUMsS0FBSzRoQjtnQkFDMUJocEQsR0FBRyxJQUFJLENBQUMsQ0FBQ3V6SCxNQUFNLENBQUNqaUksSUFBSSxFQUFFLEdBQUcrMUMsS0FBSzRoQjtZQUNoQztRQUNGO1FBQ0EsT0FBT3d6RSxTQUFTaEIsV0FBVztJQUM3QjtBQUNGO0VBRUMsNENBQTRDO0FBZ0I3QyxNQUFNaUI7SUFDSixDQUFDcnNGLEdBQUcsQ0FBQztJQUNMLENBQUN5ckYsVUFBVSxDQUFDO0lBQ1osQ0FBQ0MsU0FBUyxDQUFDO0lBQ1gsQ0FBQ1ksYUFBYSxDQUFNO0lBQ3BCLENBQUNDLFNBQVMsQ0FBTTtJQUNoQjdzSSxZQUFZa2dELEtBQUssRUFBRW0xRSxjQUFjLENBQUMsRUFBRTBVLGNBQWMsQ0FBQyxFQUFFNXBGLFFBQVEsSUFBSSxDQUFFO2FBRm5FLENBQUN5c0YsYUFBYSxHQUFHLEVBQUU7YUFDbkIsQ0FBQ0MsU0FBUyxHQUFHLEVBQUU7UUFFYixNQUFNdHBHLFNBQVM7WUFBQ3YwQjtZQUFVQTtZQUFVLENBQUNBO1lBQVUsQ0FBQ0E7U0FBUztRQUN6RCxNQUFNODlILG1CQUFtQjtRQUN6QixNQUFNQyxVQUFVLE1BQU0sQ0FBQ0Q7UUFDdkIsS0FBSyxNQUFNLEVBQ1R2cEksQ0FBQyxFQUNEME0sQ0FBQyxFQUNEOGhDLEtBQUssRUFDTEMsTUFBTSxFQUNQLElBQUlrTyxNQUFPO1lBQ1YsTUFBTXBaLEtBQUsxakMsS0FBS0MsS0FBSyxDQUFDLENBQUNFLElBQUk4eEgsV0FBVSxJQUFLMFgsV0FBV0E7WUFDckQsTUFBTTlsRyxLQUFLN2pDLEtBQUtELElBQUksQ0FBQyxDQUFDSSxJQUFJd3VDLFFBQVFzakYsV0FBVSxJQUFLMFgsV0FBV0E7WUFDNUQsTUFBTWhtRyxLQUFLM2pDLEtBQUtDLEtBQUssQ0FBQyxDQUFDNE0sSUFBSW9sSCxXQUFVLElBQUswWCxXQUFXQTtZQUNyRCxNQUFNNWxHLEtBQUsvakMsS0FBS0QsSUFBSSxDQUFDLENBQUM4TSxJQUFJK2hDLFNBQVNxakYsV0FBVSxJQUFLMFgsV0FBV0E7WUFDN0QsTUFBTTFsRSxPQUFPO2dCQUFDdmdDO2dCQUFJQztnQkFBSUk7Z0JBQUk7YUFBSztZQUMvQixNQUFNK25DLFFBQVE7Z0JBQUNqb0M7Z0JBQUlGO2dCQUFJSTtnQkFBSTthQUFNO1lBQ2pDLElBQUksQ0FBQyxDQUFDeWxHLGFBQWEsQ0FBQy9rSSxJQUFJLENBQUN3L0QsTUFBTTZIO1lBQy9CbHNDLEtBQUsyRCxlQUFlLENBQUNHLElBQUlDLElBQUlFLElBQUlFLElBQUk1RDtRQUN2QztRQUNBLE1BQU1zdkQsWUFBWXR2RCxNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRSxHQUFHLElBQUl3bUc7UUFDOUMsTUFBTWozQyxhQUFhdnZELE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLEdBQUcsSUFBSXdtRztRQUMvQyxNQUFNaUQsY0FBY3pwRyxNQUFNLENBQUMsRUFBRSxHQUFHd21HO1FBQ2hDLE1BQU1rRCxjQUFjMXBHLE1BQU0sQ0FBQyxFQUFFLEdBQUd3bUc7UUFDaEMsSUFBSW1DLGNBQWMvckYsUUFBUSxDQUFDbnhDLFdBQVdBO1FBQ3RDLElBQUltOUgsY0FBY245SDtRQUNsQixNQUFNaytILFdBQVcsSUFBSSxDQUFDLENBQUNOLGFBQWEsQ0FBQ2huSCxFQUFFLENBQUN1NkIsUUFBUSxDQUFDLElBQUksQ0FBQztRQUN0RCxNQUFNNnJGLFlBQVk7WUFBQ2tCLFFBQVEsQ0FBQyxFQUFFO1lBQUVBLFFBQVEsQ0FBQyxFQUFFO1NBQUM7UUFDNUMsS0FBSyxNQUFNQyxRQUFRLElBQUksQ0FBQyxDQUFDUCxhQUFhLENBQUU7WUFDdEMsTUFBTSxDQUFDcnBJLEdBQUd3akMsSUFBSUksSUFBSWtnQyxLQUFLLEdBQUc4bEU7WUFDMUIsSUFBSSxDQUFDOWxFLFFBQVFsbkIsT0FBTztnQkFDbEIsSUFBSXBaLEtBQUtvbEcsYUFBYTtvQkFDcEJBLGNBQWNwbEc7b0JBQ2RtbEcsY0FBYzNvSTtnQkFDaEIsT0FBTyxJQUFJd2pDLE9BQU9vbEcsYUFBYTtvQkFDN0JELGNBQWM5b0ksS0FBSzRQLEdBQUcsQ0FBQ2s1SCxhQUFhM29JO2dCQUN0QztZQUNGLE9BQU8sSUFBSThqRSxRQUFRLENBQUNsbkIsT0FBTztnQkFDekIsSUFBSXBaLEtBQUtvbEcsYUFBYTtvQkFDcEJBLGNBQWNwbEc7b0JBQ2RtbEcsY0FBYzNvSTtnQkFDaEIsT0FBTyxJQUFJd2pDLE9BQU9vbEcsYUFBYTtvQkFDN0JELGNBQWM5b0ksS0FBS21GLEdBQUcsQ0FBQzJqSSxhQUFhM29JO2dCQUN0QztZQUNGO1lBQ0E0cEksSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDNXBJLElBQUl5cEksV0FBVSxJQUFLbjZDO1lBQzlCczZDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQ3BtRyxLQUFLa21HLFdBQVUsSUFBS242QztZQUMvQnE2QyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUNobUcsS0FBSzhsRyxXQUFVLElBQUtuNkM7UUFDakM7UUFDQSxJQUFJLENBQUMsQ0FBQ3h5QyxHQUFHLEdBQUcsSUFBSXpuQyxhQUFhO1lBQUNtMEg7WUFBYUM7WUFBYXA2QztZQUFXQztTQUFXO1FBQzlFLElBQUksQ0FBQyxDQUFDaTVDLFVBQVUsR0FBRztZQUFDRztZQUFhQztTQUFZO1FBQzdDLElBQUksQ0FBQyxDQUFDSCxTQUFTLEdBQUdBO0lBQ3BCO0lBQ0FOLGNBQWM7UUFDWixJQUFJLENBQUMsQ0FBQ2tCLGFBQWEsQ0FBQ3pwSCxJQUFJLENBQUMsQ0FBQ2xELEdBQUdDLElBQU1ELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLElBQUlELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLElBQUlELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO1FBQzVFLE1BQU1rdEgsdUJBQXVCLEVBQUU7UUFDL0IsS0FBSyxNQUFNRCxRQUFRLElBQUksQ0FBQyxDQUFDUCxhQUFhLENBQUU7WUFDdEMsSUFBSU8sSUFBSSxDQUFDLEVBQUUsRUFBRTtnQkFDWEMscUJBQXFCdmxJLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQ3dsSSxTQUFTLENBQUNGO2dCQUM3QyxJQUFJLENBQUMsQ0FBQy8xRCxNQUFNLENBQUMrMUQ7WUFDZixPQUFPO2dCQUNMLElBQUksQ0FBQyxDQUFDbjdILE1BQU0sQ0FBQ203SDtnQkFDYkMscUJBQXFCdmxJLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQ3dsSSxTQUFTLENBQUNGO1lBQy9DO1FBQ0Y7UUFDQSxPQUFPLElBQUksQ0FBQyxDQUFDekIsV0FBVyxDQUFDMEI7SUFDM0I7SUFDQSxDQUFDMUIsV0FBVyxDQUFDMEIsb0JBQW9CO1FBQy9CLE1BQU1FLFFBQVEsRUFBRTtRQUNoQixNQUFNQyxXQUFXLElBQUkzNEg7UUFDckIsS0FBSyxNQUFNdTRILFFBQVFDLHFCQUFzQjtZQUN2QyxNQUFNLENBQUM3cEksR0FBR3dqQyxJQUFJSSxHQUFHLEdBQUdnbUc7WUFDcEJHLE1BQU16bEksSUFBSSxDQUFDO2dCQUFDdEU7Z0JBQUd3akM7Z0JBQUlvbUc7YUFBSyxFQUFFO2dCQUFDNXBJO2dCQUFHNGpDO2dCQUFJZ21HO2FBQUs7UUFDekM7UUFDQUcsTUFBTW5xSCxJQUFJLENBQUMsQ0FBQ2xELEdBQUdDLElBQU1ELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLElBQUlELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFO1FBQy9DLElBQUssSUFBSTNlLElBQUksR0FBR2luQyxLQUFLOGtHLE1BQU0xd0ksTUFBTSxFQUFFMkUsSUFBSWluQyxJQUFJam5DLEtBQUssRUFBRztZQUNqRCxNQUFNaXNJLFFBQVFGLEtBQUssQ0FBQy9ySSxFQUFFLENBQUMsRUFBRTtZQUN6QixNQUFNa3NJLFFBQVFILEtBQUssQ0FBQy9ySSxJQUFJLEVBQUUsQ0FBQyxFQUFFO1lBQzdCaXNJLE1BQU0zbEksSUFBSSxDQUFDNGxJO1lBQ1hBLE1BQU01bEksSUFBSSxDQUFDMmxJO1lBQ1hELFNBQVM5NkgsR0FBRyxDQUFDKzZIO1lBQ2JELFNBQVM5NkgsR0FBRyxDQUFDZzdIO1FBQ2Y7UUFDQSxNQUFNQyxXQUFXLEVBQUU7UUFDbkIsSUFBSWxDO1FBQ0osTUFBTytCLFNBQVMzN0gsSUFBSSxHQUFHLEVBQUc7WUFDeEIsTUFBTXU3SCxPQUFPSSxTQUFTN3BILE1BQU0sR0FBRzloQixJQUFJLEdBQUcvRCxLQUFLO1lBQzNDLElBQUksQ0FBQzBGLEdBQUd3akMsSUFBSUksSUFBSXFtRyxPQUFPQyxNQUFNLEdBQUdOO1lBQ2hDSSxTQUFTbnZGLE1BQU0sQ0FBQyt1RjtZQUNoQixJQUFJZixhQUFhN29JO1lBQ2pCLElBQUk4b0ksYUFBYXRsRztZQUNqQnlrRyxVQUFVO2dCQUFDam9JO2dCQUFHNGpDO2FBQUc7WUFDakJ1bUcsU0FBUzdsSSxJQUFJLENBQUMyakk7WUFDZCxNQUFPLEtBQU07Z0JBQ1gsSUFBSXA1SDtnQkFDSixJQUFJbTdILFNBQVNub0ksR0FBRyxDQUFDb29JLFFBQVE7b0JBQ3ZCcDdILElBQUlvN0g7Z0JBQ04sT0FBTyxJQUFJRCxTQUFTbm9JLEdBQUcsQ0FBQ3FvSSxRQUFRO29CQUM5QnI3SCxJQUFJcTdIO2dCQUNOLE9BQU87b0JBQ0w7Z0JBQ0Y7Z0JBQ0FGLFNBQVNudkYsTUFBTSxDQUFDaHNDO2dCQUNoQixDQUFDN08sR0FBR3dqQyxJQUFJSSxJQUFJcW1HLE9BQU9DLE1BQU0sR0FBR3I3SDtnQkFDNUIsSUFBSWc2SCxlQUFlN29JLEdBQUc7b0JBQ3BCaW9JLFFBQVEzakksSUFBSSxDQUFDdWtJLFlBQVlDLFlBQVk5b0ksR0FBRzhvSSxlQUFldGxHLEtBQUtBLEtBQUtJO29CQUNqRWlsRyxhQUFhN29JO2dCQUNmO2dCQUNBOG9JLGFBQWFBLGVBQWV0bEcsS0FBS0ksS0FBS0o7WUFDeEM7WUFDQXlrRyxRQUFRM2pJLElBQUksQ0FBQ3VrSSxZQUFZQztRQUMzQjtRQUNBLE9BQU8sSUFBSXNCLGlCQUFpQkQsVUFBVSxJQUFJLENBQUMsQ0FBQ3B0RixHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUN5ckYsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDQyxTQUFTO0lBQ3BGO0lBQ0EsQ0FBQzRCLFlBQVksQ0FBQzM5SCxDQUFDO1FBQ2IsTUFBTXNZLFFBQVEsSUFBSSxDQUFDLENBQUNza0gsU0FBUztRQUM3QixJQUFJcGtILFFBQVE7UUFDWixJQUFJckMsTUFBTW1DLE1BQU0zckIsTUFBTSxHQUFHO1FBQ3pCLE1BQU82ckIsU0FBU3JDLElBQUs7WUFDbkIsTUFBTXluSCxTQUFTcGxILFFBQVFyQyxPQUFPO1lBQzlCLE1BQU0yZ0IsS0FBS3hlLEtBQUssQ0FBQ3NsSCxPQUFPLENBQUMsRUFBRTtZQUMzQixJQUFJOW1HLE9BQU85MkIsR0FBRztnQkFDWixPQUFPNDlIO1lBQ1Q7WUFDQSxJQUFJOW1HLEtBQUs5MkIsR0FBRztnQkFDVndZLFFBQVFvbEgsU0FBUztZQUNuQixPQUFPO2dCQUNMem5ILE1BQU15bkgsU0FBUztZQUNqQjtRQUNGO1FBQ0EsT0FBT3puSCxNQUFNO0lBQ2Y7SUFDQSxDQUFDZ3hELE1BQU0sQ0FBQyxHQUFHcndDLElBQUlJLEdBQUc7UUFDaEIsTUFBTWg3QixRQUFRLElBQUksQ0FBQyxDQUFDeWhJLFlBQVksQ0FBQzdtRztRQUNqQyxJQUFJLENBQUMsQ0FBQzhsRyxTQUFTLENBQUMzb0YsTUFBTSxDQUFDLzNDLE9BQU8sR0FBRztZQUFDNDZCO1lBQUlJO1NBQUc7SUFDM0M7SUFDQSxDQUFDbjFCLE1BQU0sQ0FBQyxHQUFHKzBCLElBQUlJLEdBQUc7UUFDaEIsTUFBTWg3QixRQUFRLElBQUksQ0FBQyxDQUFDeWhJLFlBQVksQ0FBQzdtRztRQUNqQyxJQUFLLElBQUl4bEMsSUFBSTRLLE9BQU81SyxJQUFJLElBQUksQ0FBQyxDQUFDc3JJLFNBQVMsQ0FBQ2p3SSxNQUFNLEVBQUUyRSxJQUFLO1lBQ25ELE1BQU0sQ0FBQ2tuQixPQUFPckMsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDeW1ILFNBQVMsQ0FBQ3RySSxFQUFFO1lBQ3ZDLElBQUlrbkIsVUFBVXNlLElBQUk7Z0JBQ2hCO1lBQ0Y7WUFDQSxJQUFJdGUsVUFBVXNlLE1BQU0zZ0IsUUFBUStnQixJQUFJO2dCQUM5QixJQUFJLENBQUMsQ0FBQzBsRyxTQUFTLENBQUMzb0YsTUFBTSxDQUFDM2lELEdBQUc7Z0JBQzFCO1lBQ0Y7UUFDRjtRQUNBLElBQUssSUFBSUEsSUFBSTRLLFFBQVEsR0FBRzVLLEtBQUssR0FBR0EsSUFBSztZQUNuQyxNQUFNLENBQUNrbkIsT0FBT3JDLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQ3ltSCxTQUFTLENBQUN0ckksRUFBRTtZQUN2QyxJQUFJa25CLFVBQVVzZSxJQUFJO2dCQUNoQjtZQUNGO1lBQ0EsSUFBSXRlLFVBQVVzZSxNQUFNM2dCLFFBQVErZ0IsSUFBSTtnQkFDOUIsSUFBSSxDQUFDLENBQUMwbEcsU0FBUyxDQUFDM29GLE1BQU0sQ0FBQzNpRCxHQUFHO2dCQUMxQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLENBQUM4ckksU0FBUyxDQUFDRixJQUFJO1FBQ2IsTUFBTSxDQUFDNXBJLEdBQUd3akMsSUFBSUksR0FBRyxHQUFHZ21HO1FBQ3BCLE1BQU12aUIsVUFBVTtZQUFDO2dCQUFDcm5IO2dCQUFHd2pDO2dCQUFJSTthQUFHO1NBQUM7UUFDN0IsTUFBTWg3QixRQUFRLElBQUksQ0FBQyxDQUFDeWhJLFlBQVksQ0FBQ3ptRztRQUNqQyxJQUFLLElBQUk1bEMsSUFBSSxHQUFHQSxJQUFJNEssT0FBTzVLLElBQUs7WUFDOUIsTUFBTSxDQUFDa25CLE9BQU9yQyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUN5bUgsU0FBUyxDQUFDdHJJLEVBQUU7WUFDdkMsSUFBSyxJQUFJc1AsSUFBSSxHQUFHOGhGLEtBQUtpNEIsUUFBUWh1SCxNQUFNLEVBQUVpVSxJQUFJOGhGLElBQUk5aEYsSUFBSztnQkFDaEQsTUFBTSxHQUFHdTJCLElBQUkwbUcsR0FBRyxHQUFHbGpCLE9BQU8sQ0FBQy81RyxFQUFFO2dCQUM3QixJQUFJdVYsT0FBT2doQixNQUFNMG1HLE1BQU1ybEgsT0FBTztvQkFDNUI7Z0JBQ0Y7Z0JBQ0EsSUFBSTJlLE1BQU0zZSxPQUFPO29CQUNmLElBQUlxbEgsS0FBSzFuSCxLQUFLO3dCQUNad2tHLE9BQU8sQ0FBQy81RyxFQUFFLENBQUMsRUFBRSxHQUFHdVY7b0JBQ2xCLE9BQU87d0JBQ0wsSUFBSXVzRSxPQUFPLEdBQUc7NEJBQ1osT0FBTyxFQUFFO3dCQUNYO3dCQUNBaTRCLFFBQVExbUUsTUFBTSxDQUFDcnpDLEdBQUc7d0JBQ2xCQTt3QkFDQThoRjtvQkFDRjtvQkFDQTtnQkFDRjtnQkFDQWk0QixPQUFPLENBQUMvNUcsRUFBRSxDQUFDLEVBQUUsR0FBRzRYO2dCQUNoQixJQUFJcWxILEtBQUsxbkgsS0FBSztvQkFDWndrRyxRQUFRL2lILElBQUksQ0FBQzt3QkFBQ3RFO3dCQUFHNmlCO3dCQUFLMG5IO3FCQUFHO2dCQUMzQjtZQUNGO1FBQ0Y7UUFDQSxPQUFPbGpCO0lBQ1Q7QUFDRjtBQUNBLE1BQU0raUIseUJBQXlCdEU7SUFDN0IsQ0FBQy9vRixHQUFHLENBQUM7SUFDTCxDQUFDb3RGLFFBQVEsQ0FBQztJQUNWMXRJLFlBQVkwdEksUUFBUSxFQUFFcHRGLEdBQUcsRUFBRXlyRixVQUFVLEVBQUVDLFNBQVMsQ0FBRTtRQUNoRCxLQUFLO1FBQ0wsSUFBSSxDQUFDLENBQUMwQixRQUFRLEdBQUdBO1FBQ2pCLElBQUksQ0FBQyxDQUFDcHRGLEdBQUcsR0FBR0E7UUFDWixJQUFJLENBQUN5ckYsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7SUFDbkI7SUFDQTFDLFlBQVk7UUFDVixNQUFNaG9JLFNBQVMsRUFBRTtRQUNqQixLQUFLLE1BQU15c0ksV0FBVyxJQUFJLENBQUMsQ0FBQ0wsUUFBUSxDQUFFO1lBQ3BDLElBQUksQ0FBQ00sT0FBT0MsTUFBTSxHQUFHRjtZQUNyQnpzSSxPQUFPdUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFbW1JLE1BQU0sQ0FBQyxFQUFFQyxNQUFNLENBQUM7WUFDaEMsSUFBSyxJQUFJMXNJLElBQUksR0FBR0EsSUFBSXdzSSxRQUFRbnhJLE1BQU0sRUFBRTJFLEtBQUssRUFBRztnQkFDMUMsTUFBTWdDLElBQUl3cUksT0FBTyxDQUFDeHNJLEVBQUU7Z0JBQ3BCLE1BQU0wTyxJQUFJODlILE9BQU8sQ0FBQ3hzSSxJQUFJLEVBQUU7Z0JBQ3hCLElBQUlnQyxNQUFNeXFJLE9BQU87b0JBQ2Yxc0ksT0FBT3VHLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRW9JLEVBQUUsQ0FBQztvQkFDbkJnK0gsUUFBUWgrSDtnQkFDVixPQUFPLElBQUlBLE1BQU1nK0gsT0FBTztvQkFDdEIzc0ksT0FBT3VHLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRXRFLEVBQUUsQ0FBQztvQkFDbkJ5cUksUUFBUXpxSTtnQkFDVjtZQUNGO1lBQ0FqQyxPQUFPdUcsSUFBSSxDQUFDO1FBQ2Q7UUFDQSxPQUFPdkcsT0FBT2pDLElBQUksQ0FBQztJQUNyQjtJQUNBc2xELFVBQVUsQ0FBQzhuQixLQUFLQyxLQUFLQyxLQUFLSCxJQUFJLEVBQUUrOEQsU0FBUyxFQUFFO1FBQ3pDLE1BQU1tRSxXQUFXLEVBQUU7UUFDbkIsTUFBTTM3RixRQUFRNDZCLE1BQU1GO1FBQ3BCLE1BQU16NkIsU0FBU3c2QixNQUFNRTtRQUNyQixLQUFLLE1BQU04K0QsV0FBVyxJQUFJLENBQUMsQ0FBQ2tDLFFBQVEsQ0FBRTtZQUNwQyxNQUFNbEssU0FBUyxJQUFJNzBILE1BQU02OEgsUUFBUTV1SSxNQUFNO1lBQ3ZDLElBQUssSUFBSTJFLElBQUksR0FBR0EsSUFBSWlxSSxRQUFRNXVJLE1BQU0sRUFBRTJFLEtBQUssRUFBRztnQkFDMUNpaUksTUFBTSxDQUFDamlJLEVBQUUsR0FBR2tyRSxNQUFNKytELE9BQU8sQ0FBQ2pxSSxFQUFFLEdBQUd3d0M7Z0JBQy9CeXhGLE1BQU0sQ0FBQ2ppSSxJQUFJLEVBQUUsR0FBR2lyRSxNQUFNZy9ELE9BQU8sQ0FBQ2pxSSxJQUFJLEVBQUUsR0FBR3l3QztZQUN6QztZQUNBMDdGLFNBQVM3bEksSUFBSSxDQUFDMjdIO1FBQ2hCO1FBQ0EsT0FBT2tLO0lBQ1Q7SUFDQSxJQUFJcHRGLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxDQUFDQSxHQUFHO0lBQ2xCO0lBQ0EsSUFBSTR0Rix5QkFBeUI7UUFDM0IsT0FBTztZQUFDO1NBQW1CO0lBQzdCO0FBQ0Y7QUFDQSxNQUFNQyw4QkFBOEJyRTtJQUNsQ3lCLG1CQUFtQkMsT0FBTyxFQUFFaEksTUFBTSxFQUFFbGpGLEdBQUcsRUFBRTRwRixXQUFXLEVBQUVILFdBQVcsRUFBRTVwRixLQUFLLEVBQUU7UUFDeEUsT0FBTyxJQUFJaXVGLHFCQUFxQjVDLFNBQVNoSSxRQUFRbGpGLEtBQUs0cEYsYUFBYUgsYUFBYTVwRjtJQUNsRjtBQUNGO0FBQ0EsTUFBTWl1Riw2QkFBNkIzQztJQUNqQ2UsWUFBWXppRSxLQUFLLEVBQUV6cEIsR0FBRyxFQUFFNHBGLFdBQVcsRUFBRXZHLFNBQVMsRUFBRXhqRixLQUFLLEVBQUU0cEYsY0FBYyxDQUFDLEVBQUU7UUFDdEUsT0FBTyxJQUFJb0Usc0JBQXNCcGtFLE9BQU96cEIsS0FBSzRwRixhQUFhdkcsV0FBV3hqRixPQUFPNHBGO0lBQzlFO0FBQ0Y7RUFFQyxvQ0FBb0M7QUFlckMsTUFBTXNFLHdCQUF3QnpzRTtJQUM1QixDQUFDMVMsVUFBVSxDQUFRO0lBQ25CLENBQUNZLFlBQVksQ0FBSztJQUNsQixDQUFDNVAsS0FBSyxDQUFDO0lBQ1AsQ0FBQ291RixVQUFVLENBQVE7SUFDbkIsQ0FBQ3R5RixXQUFXLENBQVE7SUFDcEIsQ0FBQ3V5RixhQUFhLENBQVE7SUFDdEIsQ0FBQ3grRSxTQUFTLENBQVE7SUFDbEIsQ0FBQ0MsV0FBVyxDQUFLO0lBQ2pCLENBQUN3K0UsWUFBWSxDQUFRO0lBQ3JCLENBQUNDLGlCQUFpQixDQUFRO0lBQzFCLENBQUNsOUgsRUFBRSxDQUFRO0lBQ1gsQ0FBQ205SCxlQUFlLENBQVM7SUFDekIsQ0FBQzNDLFVBQVUsQ0FBUTtJQUNuQixDQUFDQyxTQUFTLENBQVE7SUFDbEIsQ0FBQzJDLFNBQVMsQ0FBUTtJQUNsQixDQUFDdmxILElBQUksQ0FBTTtJQUNYLENBQUN1NkcsU0FBUyxDQUFDO0lBQ1gsQ0FBQ2owRSxnQkFBZ0IsQ0FBTTs7YUFDaEJ5MkUsZ0JBQWdCOzs7YUFDaEJ5SSxrQkFBa0I7OzthQUNsQkMsb0JBQW9COzs7YUFDcEJwcUUsUUFBUTs7O2FBQ1IzUCxjQUFjbGtDLHFCQUFxQkcsU0FBUzs7O2FBQzVDKzlHLG1CQUFtQixDQUFDOzs7YUFDcEJDLGlCQUFpQjs7O2FBQ2pCQyx1QkFBdUI7O0lBQzlCLFdBQVd4bUYsbUJBQW1CO1FBQzVCLE1BQU1uckQsUUFBUWd4SSxnQkFBZ0JudUksU0FBUztRQUN2QyxPQUFPa2dDLE9BQU8sSUFBSSxFQUFFLG9CQUFvQixJQUFJbWtCLGdCQUFnQjtZQUFDO2dCQUFDO29CQUFDO29CQUFhO2lCQUFnQjtnQkFBRWxuRCxNQUFNNHhJLFVBQVU7Z0JBQUU7b0JBQzlHcG9JLE1BQU07d0JBQUM7cUJBQUU7Z0JBQ1g7YUFBRTtZQUFFO2dCQUFDO29CQUFDO29CQUFjO2lCQUFpQjtnQkFBRXhKLE1BQU00eEksVUFBVTtnQkFBRTtvQkFDdkRwb0ksTUFBTTt3QkFBQztxQkFBRTtnQkFDWDthQUFFO1lBQUU7Z0JBQUM7b0JBQUM7b0JBQVc7aUJBQWM7Z0JBQUV4SixNQUFNNHhJLFVBQVU7Z0JBQUU7b0JBQ2pEcG9JLE1BQU07d0JBQUM7cUJBQUU7Z0JBQ1g7YUFBRTtZQUFFO2dCQUFDO29CQUFDO29CQUFhO2lCQUFnQjtnQkFBRXhKLE1BQU00eEksVUFBVTtnQkFBRTtvQkFDckRwb0ksTUFBTTt3QkFBQztxQkFBRTtnQkFDWDthQUFFO1NBQUM7SUFDTDtJQUNBN0csWUFBWTZXLE1BQU0sQ0FBRTtRQUNsQixLQUFLLENBQUM7WUFDSixHQUFHQSxNQUFNO1lBQ1RuWCxNQUFNO1FBQ1I7YUExQ0YsQ0FBQ3d2RCxVQUFVLEdBQUc7YUFDZCxDQUFDWSxZQUFZLEdBQUc7YUFFaEIsQ0FBQ3crRSxVQUFVLEdBQUc7YUFDZCxDQUFDdHlGLFdBQVcsR0FBRzthQUNmLENBQUN1eUYsYUFBYSxHQUFHO2FBQ2pCLENBQUN4K0UsU0FBUyxHQUFHO2FBQ2IsQ0FBQ0MsV0FBVyxHQUFHO2FBQ2YsQ0FBQ3crRSxZQUFZLEdBQUc7YUFDaEIsQ0FBQ0MsaUJBQWlCLEdBQUc7YUFDckIsQ0FBQ2w5SCxFQUFFLEdBQUc7YUFDTixDQUFDbTlILGVBQWUsR0FBRzthQUNuQixDQUFDM0MsVUFBVSxHQUFHO2FBQ2QsQ0FBQ0MsU0FBUyxHQUFHO2FBQ2IsQ0FBQzJDLFNBQVMsR0FBRzthQUNiLENBQUN2bEgsSUFBSSxHQUFHO2FBRVIsQ0FBQ3NtQyxnQkFBZ0IsR0FBRztRQTBCbEIsSUFBSSxDQUFDOVosS0FBSyxHQUFHLytCLE9BQU8rK0IsS0FBSyxJQUFJeTRGLGdCQUFnQmxJLGFBQWE7UUFDMUQsSUFBSSxDQUFDLENBQUN4QyxTQUFTLEdBQUc5c0gsT0FBTzhzSCxTQUFTLElBQUkwSyxnQkFBZ0JRLGlCQUFpQjtRQUN2RSxJQUFJLENBQUM5MUYsT0FBTyxHQUFHbGlDLE9BQU9raUMsT0FBTyxJQUFJczFGLGdCQUFnQk8sZUFBZTtRQUNoRSxJQUFJLENBQUMsQ0FBQzF1RixLQUFLLEdBQUdycEMsT0FBT3FwQyxLQUFLLElBQUk7UUFDOUIsSUFBSSxDQUFDLENBQUN3UCxnQkFBZ0IsR0FBRzc0QyxPQUFPNjRDLGdCQUFnQixJQUFJO1FBQ3BELElBQUksQ0FBQyxDQUFDdG1DLElBQUksR0FBR3ZTLE9BQU91UyxJQUFJLElBQUk7UUFDNUIsSUFBSSxDQUFDdThDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNvSCxhQUFhLEdBQUc7UUFDckIsSUFBSWwyRCxPQUFPcTRILFdBQVcsR0FBRyxDQUFDLEdBQUc7WUFDM0IsSUFBSSxDQUFDLENBQUNSLGVBQWUsR0FBRztZQUN4QixJQUFJLENBQUMsQ0FBQ1Msa0JBQWtCLENBQUN0NEg7WUFDekIsSUFBSSxDQUFDLENBQUN1NEgsY0FBYztRQUN0QixPQUFPLElBQUksSUFBSSxDQUFDLENBQUNsdkYsS0FBSyxFQUFFO1lBQ3RCLElBQUksQ0FBQyxDQUFDZ1AsVUFBVSxHQUFHcjRDLE9BQU9xNEMsVUFBVTtZQUNwQyxJQUFJLENBQUMsQ0FBQ1ksWUFBWSxHQUFHajVDLE9BQU9pNUMsWUFBWTtZQUN4QyxJQUFJLENBQUMsQ0FBQ0MsU0FBUyxHQUFHbDVDLE9BQU9rNUMsU0FBUztZQUNsQyxJQUFJLENBQUMsQ0FBQ0MsV0FBVyxHQUFHbjVDLE9BQU9tNUMsV0FBVztZQUN0QyxJQUFJLENBQUMsQ0FBQ3EvRSxjQUFjO1lBQ3BCLElBQUksQ0FBQyxDQUFDRCxjQUFjO1lBQ3BCLElBQUksQ0FBQy8vRCxNQUFNLENBQUMsSUFBSSxDQUFDbCtCLFFBQVE7UUFDM0I7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDOGpCLG1CQUFtQixFQUFFO1lBQzdCLElBQUksQ0FBQ2xZLFVBQVUsQ0FBQytULFNBQVMsQ0FBQztRQUM1QjtJQUNGO0lBQ0EsSUFBSW1nQix1QkFBdUI7UUFDekIsT0FBTztZQUNMbmIsUUFBUTtZQUNSdndELE1BQU0sSUFBSSxDQUFDLENBQUNtcEksZUFBZSxHQUFHLG1CQUFtQjtZQUNqRDk0RixPQUFPLElBQUksQ0FBQ21ILFVBQVUsQ0FBQ3FQLGtCQUFrQixDQUFDLElBQUksQ0FBQ3hXLEtBQUs7WUFDcEQrdEYsV0FBVyxJQUFJLENBQUMsQ0FBQ0EsU0FBUztZQUMxQmowRSxrQkFBa0IsSUFBSSxDQUFDLENBQUNBLGdCQUFnQjtRQUMxQztJQUNGO0lBQ0EsSUFBSXdoQixxQkFBcUI7UUFDdkIsT0FBTztZQUNMM3JFLE1BQU07WUFDTnF3QyxPQUFPLElBQUksQ0FBQ21ILFVBQVUsQ0FBQ3FQLGtCQUFrQixDQUFDLElBQUksQ0FBQ3hXLEtBQUs7UUFDdEQ7SUFDRjtJQUNBLE9BQU9xK0IsMEJBQTBCOW1FLElBQUksRUFBRTtRQUNyQyxPQUFPO1lBQ0xtaUksZ0JBQWdCbmlJLEtBQUt0TyxHQUFHLENBQUMsU0FBUytTLElBQUk7UUFDeEM7SUFDRjtJQUNBLENBQUN5OUgsY0FBYztRQUNiLE1BQU0zQyxXQUFXLElBQUlDLGtCQUFrQixJQUFJLENBQUMsQ0FBQ3pzRixLQUFLLEVBQUU7UUFDcEQsSUFBSSxDQUFDLENBQUN1dUYsaUJBQWlCLEdBQUcvQixTQUFTaEIsV0FBVztRQUM5QyxDQUFDLElBQUksQ0FBQ25vSSxDQUFDLEVBQUUsSUFBSSxDQUFDME0sQ0FBQyxFQUFFLElBQUksQ0FBQzhoQyxLQUFLLEVBQUUsSUFBSSxDQUFDQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQ3k4RixpQkFBaUIsQ0FBQ251RixHQUFHO1FBQ3ZFLE1BQU1pdkYscUJBQXFCLElBQUk1QyxrQkFBa0IsSUFBSSxDQUFDLENBQUN6c0YsS0FBSyxFQUFFLFFBQVEsT0FBTyxJQUFJLENBQUNuRCxVQUFVLENBQUNLLFNBQVMsS0FBSztRQUMzRyxJQUFJLENBQUMsQ0FBQ214RixhQUFhLEdBQUdnQixtQkFBbUI3RCxXQUFXO1FBQ3BELE1BQU0sRUFDSkssVUFBVSxFQUNYLEdBQUcsSUFBSSxDQUFDLENBQUMwQyxpQkFBaUI7UUFDM0IsSUFBSSxDQUFDLENBQUMxQyxVQUFVLEdBQUc7WUFBRUEsQ0FBQUEsVUFBVSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUN4b0ksQ0FBQyxJQUFJLElBQUksQ0FBQ3d1QyxLQUFLO1lBQUdnNkYsQ0FBQUEsVUFBVSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUM5N0gsQ0FBQyxJQUFJLElBQUksQ0FBQytoQyxNQUFNO1NBQUM7UUFDbEcsTUFBTSxFQUNKZzZGLFNBQVMsRUFDVixHQUFHLElBQUksQ0FBQyxDQUFDdUMsYUFBYTtRQUN2QixJQUFJLENBQUMsQ0FBQ3ZDLFNBQVMsR0FBRztZQUFFQSxDQUFBQSxTQUFTLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ3pvSSxDQUFDLElBQUksSUFBSSxDQUFDd3VDLEtBQUs7WUFBR2k2RixDQUFBQSxTQUFTLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQy83SCxDQUFDLElBQUksSUFBSSxDQUFDK2hDLE1BQU07U0FBQztJQUNqRztJQUNBLENBQUNtOUYsa0JBQWtCLENBQUMsRUFDbEJWLGlCQUFpQixFQUNqQlMsV0FBVyxFQUNYWixVQUFVLEVBQ1g7UUFDQyxJQUFJLENBQUMsQ0FBQ0csaUJBQWlCLEdBQUdBO1FBQzFCLE1BQU1lLGlCQUFpQjtRQUN2QixJQUFJLENBQUMsQ0FBQ2pCLGFBQWEsR0FBR0Usa0JBQWtCaEMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDOUksU0FBUyxHQUFHLElBQUk2TCxnQkFBZ0I7UUFDNUYsSUFBSU4sZUFBZSxHQUFHO1lBQ3BCLElBQUksQ0FBQyxDQUFDMzlILEVBQUUsR0FBRzI5SDtZQUNYLElBQUksQ0FBQyxDQUFDWixVQUFVLEdBQUdBO1lBQ25CLElBQUksQ0FBQ3AvRixNQUFNLENBQUN1Z0csU0FBUyxDQUFDQyxZQUFZLENBQUNSLGFBQWE7Z0JBQzlDbjFELE1BQU0wMEQsa0JBQWtCbnVGLEdBQUc7Z0JBQzNCNDRCLE1BQU07b0JBQ0psckQsR0FBR3lnSCxrQkFBa0JuRixTQUFTO2dCQUNoQztZQUNGO1lBQ0EsSUFBSSxDQUFDLENBQUNxRixTQUFTLEdBQUcsSUFBSSxDQUFDei9GLE1BQU0sQ0FBQ3VnRyxTQUFTLENBQUNFLFdBQVcsQ0FBQztnQkFDbERDLFdBQVc7b0JBQ1RDLGtCQUFrQjtvQkFDbEJDLE1BQU07Z0JBQ1I7Z0JBQ0EvMUQsTUFBTSxJQUFJLENBQUMsQ0FBQ3cwRCxhQUFhLENBQUNqdUYsR0FBRztnQkFDN0I0NEIsTUFBTTtvQkFDSmxyRCxHQUFHLElBQUksQ0FBQyxDQUFDdWdILGFBQWEsQ0FBQ2pGLFNBQVM7Z0JBQ2xDO1lBQ0YsR0FBRztRQUNMLE9BQU8sSUFBSSxJQUFJLENBQUNwNkYsTUFBTSxFQUFFO1lBQ3RCLE1BQU0wNEIsUUFBUSxJQUFJLENBQUMxNEIsTUFBTSxDQUFDSCxRQUFRLENBQUNvQyxRQUFRO1lBQzNDLElBQUksQ0FBQ2pDLE1BQU0sQ0FBQ3VnRyxTQUFTLENBQUNNLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDeCtILEVBQUUsRUFBRTtnQkFDL0N3b0UsTUFBTXMwRCxnQkFBZ0IsQ0FBQzJCLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQ3ZCLGlCQUFpQixDQUFDbnVGLEdBQUcsRUFBRSxDQUFDc25CLFFBQVEsSUFBSSxDQUFDejJCLFFBQVEsR0FBRyxHQUFFLElBQUs7Z0JBQy9GK25DLE1BQU07b0JBQ0psckQsR0FBR3lnSCxrQkFBa0JuRixTQUFTO2dCQUNoQztZQUNGO1lBQ0EsSUFBSSxDQUFDcDZGLE1BQU0sQ0FBQ3VnRyxTQUFTLENBQUNNLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDcEIsU0FBUyxFQUFFO2dCQUN0RDUwRCxNQUFNczBELGdCQUFnQixDQUFDMkIsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDekIsYUFBYSxDQUFDanVGLEdBQUcsRUFBRXNuQjtnQkFDM0RzUixNQUFNO29CQUNKbHJELEdBQUcsSUFBSSxDQUFDLENBQUN1Z0gsYUFBYSxDQUFDakYsU0FBUztnQkFDbEM7WUFDRjtRQUNGO1FBQ0EsTUFBTSxDQUFDL2xJLEdBQUcwTSxHQUFHOGhDLE9BQU9DLE9BQU8sR0FBR3k4RixrQkFBa0JudUYsR0FBRztRQUNuRCxPQUFRLElBQUksQ0FBQ25QLFFBQVE7WUFDbkIsS0FBSztnQkFDSCxJQUFJLENBQUM1dEMsQ0FBQyxHQUFHQTtnQkFDVCxJQUFJLENBQUMwTSxDQUFDLEdBQUdBO2dCQUNULElBQUksQ0FBQzhoQyxLQUFLLEdBQUdBO2dCQUNiLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtnQkFDZDtZQUNGLEtBQUs7Z0JBQ0g7b0JBQ0UsTUFBTSxDQUFDRyxXQUFXQyxXQUFXLEdBQUcsSUFBSSxDQUFDc3NCLGdCQUFnQjtvQkFDckQsSUFBSSxDQUFDbjdELENBQUMsR0FBRzBNO29CQUNULElBQUksQ0FBQ0EsQ0FBQyxHQUFHLElBQUkxTTtvQkFDYixJQUFJLENBQUN3dUMsS0FBSyxHQUFHQSxRQUFRSyxhQUFhRDtvQkFDbEMsSUFBSSxDQUFDSCxNQUFNLEdBQUdBLFNBQVNHLFlBQVlDO29CQUNuQztnQkFDRjtZQUNGLEtBQUs7Z0JBQ0gsSUFBSSxDQUFDN3VDLENBQUMsR0FBRyxJQUFJQTtnQkFDYixJQUFJLENBQUMwTSxDQUFDLEdBQUcsSUFBSUE7Z0JBQ2IsSUFBSSxDQUFDOGhDLEtBQUssR0FBR0E7Z0JBQ2IsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO2dCQUNkO1lBQ0YsS0FBSztnQkFDSDtvQkFDRSxNQUFNLENBQUNHLFdBQVdDLFdBQVcsR0FBRyxJQUFJLENBQUNzc0IsZ0JBQWdCO29CQUNyRCxJQUFJLENBQUNuN0QsQ0FBQyxHQUFHLElBQUkwTTtvQkFDYixJQUFJLENBQUNBLENBQUMsR0FBRzFNO29CQUNULElBQUksQ0FBQ3d1QyxLQUFLLEdBQUdBLFFBQVFLLGFBQWFEO29CQUNsQyxJQUFJLENBQUNILE1BQU0sR0FBR0EsU0FBU0csWUFBWUM7b0JBQ25DO2dCQUNGO1FBQ0o7UUFDQSxNQUFNLEVBQ0oyNUYsVUFBVSxFQUNYLEdBQUcwQztRQUNKLElBQUksQ0FBQyxDQUFDMUMsVUFBVSxHQUFHO1lBQUVBLENBQUFBLFVBQVUsQ0FBQyxFQUFFLEdBQUd4b0ksQ0FBQUEsSUFBS3d1QztZQUFRZzZGLENBQUFBLFVBQVUsQ0FBQyxFQUFFLEdBQUc5N0gsQ0FBQUEsSUFBSytoQztTQUFPO1FBQzlFLE1BQU0sRUFDSmc2RixTQUFTLEVBQ1YsR0FBRyxJQUFJLENBQUMsQ0FBQ3VDLGFBQWE7UUFDdkIsSUFBSSxDQUFDLENBQUN2QyxTQUFTLEdBQUc7WUFBRUEsQ0FBQUEsU0FBUyxDQUFDLEVBQUUsR0FBR3pvSSxDQUFBQSxJQUFLd3VDO1lBQVFpNkYsQ0FBQUEsU0FBUyxDQUFDLEVBQUUsR0FBRy83SCxDQUFBQSxJQUFLK2hDO1NBQU87SUFDN0U7SUFDQSxPQUFPeXBCLFdBQVdDLElBQUksRUFBRTliLFNBQVMsRUFBRTtRQUNqQ2dpQixpQkFBaUJuRyxVQUFVLENBQUNDLE1BQU05YjtRQUNsQ3l1RixnQkFBZ0JsSSxhQUFhLEtBQUt2bUYsVUFBVW1ILGVBQWUsRUFBRXJqQyxTQUFTOWhCLE9BQU8vRCxTQUFTO0lBQ3hGO0lBQ0EsT0FBT2s0RCxvQkFBb0J4d0QsSUFBSSxFQUFFMUgsS0FBSyxFQUFFO1FBQ3RDLE9BQVEwSDtZQUNOLEtBQUs4ckIsMkJBQTJCUyxlQUFlO2dCQUM3Q3U4RyxnQkFBZ0JsSSxhQUFhLEdBQUd0b0k7Z0JBQ2hDO1lBQ0YsS0FBS3d6QiwyQkFBMkJVLG1CQUFtQjtnQkFDakRzOEcsZ0JBQWdCUSxpQkFBaUIsR0FBR2h4STtnQkFDcEM7UUFDSjtJQUNGO0lBQ0FzNkQsZ0JBQWdCNTBELENBQUMsRUFBRTBNLENBQUMsRUFBRSxDQUFDO0lBQ3ZCLElBQUlrdEMsa0JBQWtCO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLENBQUM2dUYsU0FBUztJQUN4QjtJQUNBLElBQUkxdUUsd0JBQXdCO1FBQzFCLE9BQU8sSUFBSSxDQUFDLENBQUN5dUUsVUFBVTtJQUN6QjtJQUNBdGhGLGFBQWFsbEQsSUFBSSxFQUFFMUgsS0FBSyxFQUFFO1FBQ3hCLE9BQVEwSDtZQUNOLEtBQUs4ckIsMkJBQTJCUyxlQUFlO2dCQUM3QyxJQUFJLENBQUMsQ0FBQzY4RixXQUFXLENBQUM5d0g7Z0JBQ2xCO1lBQ0YsS0FBS3d6QiwyQkFBMkJVLG1CQUFtQjtnQkFDakQsSUFBSSxDQUFDLENBQUNrK0csZUFBZSxDQUFDcHlJO2dCQUN0QjtRQUNKO0lBQ0Y7SUFDQSxXQUFXNjFELDRCQUE0QjtRQUNyQyxPQUFPO1lBQUM7Z0JBQUNyaUMsMkJBQTJCUyxlQUFlO2dCQUFFdThHLGdCQUFnQmxJLGFBQWE7YUFBQztZQUFFO2dCQUFDOTBHLDJCQUEyQlUsbUJBQW1CO2dCQUFFczhHLGdCQUFnQlEsaUJBQWlCO2FBQUM7U0FBQztJQUMzSztJQUNBLElBQUkxM0UscUJBQXFCO1FBQ3ZCLE9BQU87WUFBQztnQkFBQzlsQywyQkFBMkJTLGVBQWU7Z0JBQUUsSUFBSSxDQUFDOGpCLEtBQUssSUFBSXk0RixnQkFBZ0JsSSxhQUFhO2FBQUM7WUFBRTtnQkFBQzkwRywyQkFBMkJVLG1CQUFtQjtnQkFBRSxJQUFJLENBQUMsQ0FBQzR4RyxTQUFTLElBQUkwSyxnQkFBZ0JRLGlCQUFpQjthQUFDO1lBQUU7Z0JBQUN4OUcsMkJBQTJCVyxjQUFjO2dCQUFFLElBQUksQ0FBQyxDQUFDMDhHLGVBQWU7YUFBQztTQUFDO0lBQ2hSO0lBQ0FoeEUsaUJBQWlCO1FBQ2YsSUFBSSxDQUFDeHVCLE1BQU0sRUFBRXVnRyxVQUFVTSxpQkFBaUIsSUFBSSxDQUFDLENBQUN4K0gsRUFBRSxFQUFFO1lBQ2hEa1csTUFBTTtnQkFDSndTLE1BQU0sSUFBSSxDQUFDMmIsS0FBSztnQkFDaEIsZ0JBQWdCLElBQUksQ0FBQ21ELE9BQU87WUFDOUI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDaUQsV0FBVyxFQUFFMnlFLFlBQVksSUFBSSxDQUFDLzRFLEtBQUs7UUFDekMsS0FBSyxDQUFDOG5CO0lBQ1I7SUFDQSxDQUFDaXhELFdBQVcsQ0FBQy80RSxLQUFLO1FBQ2hCLE1BQU1zNkYscUJBQXFCLENBQUN0SixLQUFLdUo7WUFDL0IsSUFBSSxDQUFDdjZGLEtBQUssR0FBR2d4RjtZQUNiLElBQUksQ0FBQzd0RixPQUFPLEdBQUdvM0Y7WUFDZixJQUFJLENBQUN6eUUsY0FBYztRQUNyQjtRQUNBLE1BQU1tcEUsYUFBYSxJQUFJLENBQUNqeEYsS0FBSztRQUM3QixNQUFNdzZGLGVBQWUsSUFBSSxDQUFDcjNGLE9BQU87UUFDakMsSUFBSSxDQUFDb2EsV0FBVyxDQUFDO1lBQ2Z2UCxLQUFLc3NGLG1CQUFtQnZ0SSxJQUFJLENBQUMsSUFBSSxFQUFFaXpDLE9BQU95NEYsZ0JBQWdCTyxlQUFlO1lBQ3pFL3FGLE1BQU1xc0YsbUJBQW1CdnRJLElBQUksQ0FBQyxJQUFJLEVBQUVra0ksWUFBWXVKO1lBQ2hEdHNGLE1BQU0sSUFBSSxDQUFDL0csVUFBVSxDQUFDdWEsUUFBUSxDQUFDMzBELElBQUksQ0FBQyxJQUFJLENBQUNvNkMsVUFBVSxFQUFFLElBQUk7WUFDekRnSCxVQUFVO1lBQ1Z4K0MsTUFBTThyQiwyQkFBMkJTLGVBQWU7WUFDaERreUIscUJBQXFCO1lBQ3JCQyxVQUFVO1FBQ1o7UUFDQSxJQUFJLENBQUM0WCxnQkFBZ0IsQ0FBQztZQUNwQi9GLFFBQVE7WUFDUmxnQixPQUFPLElBQUksQ0FBQ21ILFVBQVUsQ0FBQ3FQLGtCQUFrQixDQUFDeFc7UUFDNUMsR0FBRztJQUNMO0lBQ0EsQ0FBQ3E2RixlQUFlLENBQUN0TSxTQUFTO1FBQ3hCLE1BQU0wTSxpQkFBaUIsSUFBSSxDQUFDLENBQUMxTSxTQUFTO1FBQ3RDLE1BQU0yTSxlQUFlQyxDQUFBQTtZQUNuQixJQUFJLENBQUMsQ0FBQzVNLFNBQVMsR0FBRzRNO1lBQ2xCLElBQUksQ0FBQyxDQUFDQyxlQUFlLENBQUNEO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDcDlFLFdBQVcsQ0FBQztZQUNmdlAsS0FBSzBzRixhQUFhM3RJLElBQUksQ0FBQyxJQUFJLEVBQUVnaEk7WUFDN0I5L0UsTUFBTXlzRixhQUFhM3RJLElBQUksQ0FBQyxJQUFJLEVBQUUwdEk7WUFDOUJ2c0YsTUFBTSxJQUFJLENBQUMvRyxVQUFVLENBQUN1YSxRQUFRLENBQUMzMEQsSUFBSSxDQUFDLElBQUksQ0FBQ282QyxVQUFVLEVBQUUsSUFBSTtZQUN6RGdILFVBQVU7WUFDVngrQyxNQUFNOHJCLDJCQUEyQk8sYUFBYTtZQUM5Q295QixxQkFBcUI7WUFDckJDLFVBQVU7UUFDWjtRQUNBLElBQUksQ0FBQzRYLGdCQUFnQixDQUFDO1lBQ3BCL0YsUUFBUTtZQUNSNnRFO1FBQ0YsR0FBRztJQUNMO0lBQ0EsSUFBSTc0RCxpQkFBaUI7UUFDbkIsSUFBSSxJQUFJLENBQUMvdEIsVUFBVSxDQUFDZ0ssZUFBZSxFQUFFO1lBQ25DLE1BQU0vSyxjQUFjLElBQUksQ0FBQyxDQUFDQSxXQUFXLEdBQUcsSUFBSTR3RSxZQUFZO2dCQUN0RDN3RSxRQUFRLElBQUk7WUFDZDtZQUNBLE9BQU87Z0JBQUM7b0JBQUM7b0JBQWVEO2lCQUFZO2FBQUM7UUFDdkM7UUFDQSxPQUFPLEtBQUssQ0FBQzh1QjtJQUNmO0lBQ0E2RixpQkFBaUI7UUFDZixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDN2hDLEdBQUcsQ0FBQytKLFNBQVMsQ0FBQytWLE1BQU0sQ0FBQyxZQUFZO0lBQ3hDO0lBQ0FnaUIsZ0JBQWdCO1FBQ2QsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQzloQyxHQUFHLENBQUMrSixTQUFTLENBQUMrVixNQUFNLENBQUMsWUFBWTtJQUN4QztJQUNBa1gsb0JBQW9CO1FBQ2xCLE9BQU8sS0FBSyxDQUFDQSxrQkFBa0IsSUFBSSxDQUFDLENBQUMycUUsV0FBVztJQUNsRDtJQUNBcnBFLHFCQUFxQjtRQUNuQixPQUFPO1lBQUM7WUFBRztTQUFFO0lBQ2Y7SUFDQW1ILFFBQVF0VixFQUFFLEVBQUVDLEVBQUUsRUFBRTtRQUNkLE9BQU8sS0FBSyxDQUFDcVYsUUFBUXRWLElBQUlDLElBQUksSUFBSSxDQUFDLENBQUN1M0UsV0FBVztJQUNoRDtJQUNBN2hFLFVBQVVyZ0IsS0FBSyxFQUFFO1FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQzBHLG1CQUFtQixFQUFFO1lBQzdCLElBQUksQ0FBQy9sQixNQUFNLENBQUN3aEcsaUJBQWlCLENBQUMsSUFBSTtRQUNwQztRQUNBLElBQUluaUYsT0FBTztZQUNULElBQUksQ0FBQ3pmLEdBQUcsQ0FBQ3lmLEtBQUs7UUFDaEI7SUFDRjtJQUNBdjhDLFNBQVM7UUFDUCxJQUFJLENBQUMsQ0FBQzIrSCxjQUFjO1FBQ3BCLElBQUksQ0FBQzkwRSxnQkFBZ0IsQ0FBQztZQUNwQi9GLFFBQVE7UUFDVjtRQUNBLEtBQUssQ0FBQzlqRDtJQUNSO0lBQ0FvbkQsVUFBVTtRQUNSLElBQUksQ0FBQyxJQUFJLENBQUNscUIsTUFBTSxFQUFFO1lBQ2hCO1FBQ0Y7UUFDQSxLQUFLLENBQUNrcUI7UUFDTixJQUFJLElBQUksQ0FBQ3RxQixHQUFHLEtBQUssTUFBTTtZQUNyQjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNzZ0csY0FBYztRQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDNXFFLGVBQWUsRUFBRTtZQUN6QixJQUFJLENBQUN0MUIsTUFBTSxDQUFDejhCLEdBQUcsQ0FBQyxJQUFJO1FBQ3RCO0lBQ0Y7SUFDQXd6RCxVQUFVLzJCLE1BQU0sRUFBRTtRQUNoQixJQUFJMGhHLGlCQUFpQjtRQUNyQixJQUFJLElBQUksQ0FBQzFoRyxNQUFNLElBQUksQ0FBQ0EsUUFBUTtZQUMxQixJQUFJLENBQUMsQ0FBQ3loRyxjQUFjO1FBQ3RCLE9BQU8sSUFBSXpoRyxRQUFRO1lBQ2pCLElBQUksQ0FBQyxDQUFDa2dHLGNBQWMsQ0FBQ2xnRztZQUNyQjBoRyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMxaEcsTUFBTSxJQUFJLElBQUksQ0FBQ0osR0FBRyxFQUFFK0osVUFBVTZQLFNBQVM7UUFDaEU7UUFDQSxLQUFLLENBQUN1ZCxVQUFVLzJCO1FBQ2hCLElBQUksQ0FBQzRPLElBQUksQ0FBQyxJQUFJLENBQUNpbUIsVUFBVTtRQUN6QixJQUFJNnNFLGdCQUFnQjtZQUNsQixJQUFJLENBQUNuNUUsTUFBTTtRQUNiO0lBQ0Y7SUFDQSxDQUFDKzRFLGVBQWUsQ0FBQzdNLFNBQVM7UUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDK0ssZUFBZSxFQUFFO1lBQzFCO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQ1Msa0JBQWtCLENBQUM7WUFDdkJWLG1CQUFtQixJQUFJLENBQUMsQ0FBQ0EsaUJBQWlCLENBQUNoQyxhQUFhLENBQUM5SSxZQUFZO1FBQ3ZFO1FBQ0EsSUFBSSxDQUFDNzlELGlCQUFpQjtRQUN0QixJQUFJLENBQUNrQyxPQUFPLENBQUMsSUFBSSxDQUFDajJCLEtBQUssRUFBRSxJQUFJLENBQUNDLE1BQU07SUFDdEM7SUFDQSxDQUFDMitGLGNBQWM7UUFDYixJQUFJLElBQUksQ0FBQyxDQUFDcC9ILEVBQUUsS0FBSyxRQUFRLENBQUMsSUFBSSxDQUFDMjlCLE1BQU0sRUFBRTtZQUNyQztRQUNGO1FBQ0EsSUFBSSxDQUFDQSxNQUFNLENBQUN1Z0csU0FBUyxDQUFDejlILE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQ1QsRUFBRTtRQUNyQyxJQUFJLENBQUMsQ0FBQ0EsRUFBRSxHQUFHO1FBQ1gsSUFBSSxDQUFDMjlCLE1BQU0sQ0FBQ3VnRyxTQUFTLENBQUN6OUgsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDMjhILFNBQVM7UUFDNUMsSUFBSSxDQUFDLENBQUNBLFNBQVMsR0FBRztJQUNwQjtJQUNBLENBQUNTLGNBQWMsQ0FBQ2xnRyxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUNsQyxJQUFJLElBQUksQ0FBQyxDQUFDMzlCLEVBQUUsS0FBSyxNQUFNO1lBQ3JCO1FBQ0Y7UUFDQyxHQUNDQSxJQUFJLElBQUksQ0FBQyxDQUFDQSxFQUFFLEVBQ1orOEgsWUFBWSxJQUFJLENBQUMsQ0FBQ0EsVUFBVSxFQUM3QixHQUFHcC9GLE9BQU91Z0csU0FBUyxDQUFDb0IsSUFBSSxDQUFDO1lBQ3hCOTJELE1BQU0sSUFBSSxDQUFDLENBQUMwMEQsaUJBQWlCLENBQUNudUYsR0FBRztZQUNqQzc0QixNQUFNO2dCQUNKdXBCLFNBQVM7Z0JBQ1QvVyxNQUFNLElBQUksQ0FBQzJiLEtBQUs7Z0JBQ2hCLGdCQUFnQixJQUFJLENBQUNtRCxPQUFPO1lBQzlCO1lBQ0E2MkYsV0FBVztnQkFDVGx6RixXQUFXO2dCQUNYb3pGLE1BQU0sSUFBSSxDQUFDLENBQUNwQixlQUFlO1lBQzdCO1lBQ0F4MUQsTUFBTTtnQkFDSmxyRCxHQUFHLElBQUksQ0FBQyxDQUFDeWdILGlCQUFpQixDQUFDbkYsU0FBUztZQUN0QztRQUNGLEdBQUcsT0FBTyxLQUFJO1FBQ2QsSUFBSSxDQUFDLENBQUNxRixTQUFTLEdBQUd6L0YsT0FBT3VnRyxTQUFTLENBQUNFLFdBQVcsQ0FBQztZQUM3Q0MsV0FBVztnQkFDVEMsa0JBQWtCO2dCQUNsQkMsTUFBTSxJQUFJLENBQUMsQ0FBQ3BCLGVBQWU7WUFDN0I7WUFDQTMwRCxNQUFNLElBQUksQ0FBQyxDQUFDdzBELGFBQWEsQ0FBQ2p1RixHQUFHO1lBQzdCNDRCLE1BQU07Z0JBQ0psckQsR0FBRyxJQUFJLENBQUMsQ0FBQ3VnSCxhQUFhLENBQUNqRixTQUFTO1lBQ2xDO1FBQ0YsR0FBRyxJQUFJLENBQUMsQ0FBQ29GLGVBQWU7UUFDeEIsSUFBSSxJQUFJLENBQUMsQ0FBQ0YsWUFBWSxFQUFFO1lBQ3RCLElBQUksQ0FBQyxDQUFDQSxZQUFZLENBQUNsa0ksS0FBSyxDQUFDOHNILFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQ2tYLFVBQVU7UUFDdEQ7SUFDRjtJQUNBLE9BQU8sQ0FBQzBCLFVBQVUsQ0FBQyxDQUFDenNJLEdBQUcwTSxHQUFHOGhDLE9BQU9DLE9BQU8sRUFBRTQxQixLQUFLO1FBQzdDLE9BQVFBO1lBQ04sS0FBSztnQkFDSCxPQUFPO29CQUFDLElBQUkzM0QsSUFBSStoQztvQkFBUXp1QztvQkFBR3l1QztvQkFBUUQ7aUJBQU07WUFDM0MsS0FBSztnQkFDSCxPQUFPO29CQUFDLElBQUl4dUMsSUFBSXd1QztvQkFBTyxJQUFJOWhDLElBQUkraEM7b0JBQVFEO29CQUFPQztpQkFBTztZQUN2RCxLQUFLO2dCQUNILE9BQU87b0JBQUMvaEM7b0JBQUcsSUFBSTFNLElBQUl3dUM7b0JBQU9DO29CQUFRRDtpQkFBTTtRQUM1QztRQUNBLE9BQU87WUFBQ3h1QztZQUFHME07WUFBRzhoQztZQUFPQztTQUFPO0lBQzlCO0lBQ0FxOUIsT0FBT3pILEtBQUssRUFBRTtRQUNaLE1BQU0sRUFDSjZuRSxTQUFTLEVBQ1YsR0FBRyxJQUFJLENBQUN2Z0csTUFBTTtRQUNmLElBQUlvUjtRQUNKLElBQUksSUFBSSxDQUFDLENBQUNvdUYsZUFBZSxFQUFFO1lBQ3pCOW1FLFFBQVEsQ0FBQ0EsUUFBUSxJQUFJLENBQUN6MkIsUUFBUSxHQUFHLEdBQUUsSUFBSztZQUN4Q21QLE1BQU0rdEYsZ0JBQWdCLENBQUMyQixVQUFVLENBQUMsSUFBSSxDQUFDLENBQUN2QixpQkFBaUIsQ0FBQ251RixHQUFHLEVBQUVzbkI7UUFDakUsT0FBTztZQUNMdG5CLE1BQU0rdEYsZ0JBQWdCLENBQUMyQixVQUFVLENBQUM7Z0JBQUMsSUFBSSxDQUFDenNJLENBQUM7Z0JBQUUsSUFBSSxDQUFDME0sQ0FBQztnQkFBRSxJQUFJLENBQUM4aEMsS0FBSztnQkFBRSxJQUFJLENBQUNDLE1BQU07YUFBQyxFQUFFNDFCO1FBQy9FO1FBQ0E2bkUsVUFBVU0sZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUN4K0gsRUFBRSxFQUFFO1lBQ25Dd29FLE1BQU16NUI7WUFDTjc0QixNQUFNO2dCQUNKLHNCQUFzQm1nRDtZQUN4QjtRQUNGO1FBQ0E2bkUsVUFBVU0sZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUNwQixTQUFTLEVBQUU7WUFDMUM1MEQsTUFBTXMwRCxnQkFBZ0IsQ0FBQzJCLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQ3pCLGFBQWEsQ0FBQ2p1RixHQUFHLEVBQUVzbkI7WUFDM0RuZ0QsTUFBTTtnQkFDSixzQkFBc0JtZ0Q7WUFDeEI7UUFDRjtJQUNGO0lBQ0FyNUIsU0FBUztRQUNQLElBQUksSUFBSSxDQUFDTyxHQUFHLEVBQUU7WUFDWixPQUFPLElBQUksQ0FBQ0EsR0FBRztRQUNqQjtRQUNBLE1BQU1BLE1BQU0sS0FBSyxDQUFDUDtRQUNsQixJQUFJLElBQUksQ0FBQyxDQUFDbmxCLElBQUksRUFBRTtZQUNkMGxCLElBQUl2QixZQUFZLENBQUMsY0FBYyxJQUFJLENBQUMsQ0FBQ25rQixJQUFJO1lBQ3pDMGxCLElBQUl2QixZQUFZLENBQUMsUUFBUTtRQUMzQjtRQUNBLElBQUksSUFBSSxDQUFDLENBQUNtaEcsZUFBZSxFQUFFO1lBQ3pCNS9GLElBQUkrSixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1FBQ3BCLE9BQU87WUFDTCxJQUFJLENBQUNxOEIsR0FBRyxDQUFDL0MsZ0JBQWdCLENBQUMsV0FBVyxJQUFJLENBQUMsQ0FBQzZsQixPQUFPLENBQUNqdkQsSUFBSSxDQUFDLElBQUksR0FBRztnQkFDN0RncEMsUUFBUSxJQUFJLENBQUNvUixVQUFVLENBQUNDLE9BQU87WUFDakM7UUFDRjtRQUNBLE1BQU13eEYsZUFBZSxJQUFJLENBQUMsQ0FBQ0EsWUFBWSxHQUFHN2pJLFNBQVMySSxhQUFhLENBQUM7UUFDakV3N0IsSUFBSXA0QixNQUFNLENBQUM4M0g7UUFDWEEsYUFBYWpoRyxZQUFZLENBQUMsZUFBZTtRQUN6Q2loRyxhQUFhOXpGLFNBQVMsR0FBRztRQUN6Qjh6RixhQUFhbGtJLEtBQUssQ0FBQzhzSCxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUNrWCxVQUFVO1FBQzlDLElBQUksQ0FBQ3RtRSxPQUFPLENBQUMsSUFBSSxDQUFDajJCLEtBQUssRUFBRSxJQUFJLENBQUNDLE1BQU07UUFDcEMyTyxXQUFXLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQzZ0RixZQUFZLEVBQUU7WUFBQztZQUFlO1NBQWU7UUFDcEUsSUFBSSxDQUFDNTlELGFBQWE7UUFDbEIsT0FBTzloQztJQUNUO0lBQ0FnaUcsY0FBYztRQUNaLElBQUksQ0FBQyxJQUFJLENBQUN2akYsVUFBVSxFQUFFO1lBQ3BCLElBQUksQ0FBQ3JlLE1BQU0sRUFBRXVnRyxVQUFVTSxpQkFBaUIsSUFBSSxDQUFDLENBQUNwQixTQUFTLEVBQUU7Z0JBQ3ZEaUIsV0FBVztvQkFDVG1CLFNBQVM7Z0JBQ1g7WUFDRjtRQUNGO0lBQ0Y7SUFDQUMsZUFBZTtRQUNiLElBQUksQ0FBQyxJQUFJLENBQUN6akYsVUFBVSxFQUFFO1lBQ3BCLElBQUksQ0FBQ3JlLE1BQU0sRUFBRXVnRyxVQUFVTSxpQkFBaUIsSUFBSSxDQUFDLENBQUNwQixTQUFTLEVBQUU7Z0JBQ3ZEaUIsV0FBVztvQkFDVG1CLFNBQVM7Z0JBQ1g7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxDQUFDbi9FLE9BQU8sQ0FBQ3hrQixLQUFLO1FBQ1ppaEcsZ0JBQWdCN2xGLGdCQUFnQixDQUFDbGtELElBQUksQ0FBQyxJQUFJLEVBQUU4b0M7SUFDOUM7SUFDQTZoRyxXQUFXN3hGLFNBQVMsRUFBRTtRQUNwQixJQUFJLENBQUNsTyxNQUFNLENBQUN3bUIsUUFBUSxDQUFDLElBQUk7UUFDekIsT0FBUXRZO1lBQ04sS0FBSztZQUNMLEtBQUs7Z0JBQ0gsSUFBSSxDQUFDLENBQUM2ekYsUUFBUSxDQUFDO2dCQUNmO1lBQ0YsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsSUFBSSxDQUFDLENBQUNBLFFBQVEsQ0FBQztnQkFDZjtRQUNKO0lBQ0Y7SUFDQSxDQUFDQSxRQUFRLENBQUN4b0gsS0FBSztRQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ3ltQyxVQUFVLEVBQUU7WUFDckI7UUFDRjtRQUNBLE1BQU1TLFlBQVl2N0MsT0FBT3c3QyxZQUFZO1FBQ3JDLElBQUlubkMsT0FBTztZQUNUa25DLFVBQVU4eUUsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDdnpFLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQ1ksWUFBWTtRQUM1RCxPQUFPO1lBQ0xILFVBQVU4eUUsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDMXlFLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQ0MsV0FBVztRQUMxRDtJQUNGO0lBQ0F5SCxTQUFTO1FBQ1AsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ2szRSxTQUFTLEVBQUU7WUFDcEI7UUFDRjtRQUNBLElBQUksQ0FBQ3ovRixNQUFNLEVBQUV1Z0csVUFBVU0saUJBQWlCLElBQUksQ0FBQyxDQUFDcEIsU0FBUyxFQUFFO1lBQ3ZEaUIsV0FBVztnQkFDVG1CLFNBQVM7Z0JBQ1RsakcsVUFBVTtZQUNaO1FBQ0Y7SUFDRjtJQUNBNm5CLFdBQVc7UUFDVCxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDaTVFLFNBQVMsRUFBRTtZQUNwQjtRQUNGO1FBQ0EsSUFBSSxDQUFDei9GLE1BQU0sRUFBRXVnRyxVQUFVTSxpQkFBaUIsSUFBSSxDQUFDLENBQUNwQixTQUFTLEVBQUU7WUFDdkRpQixXQUFXO2dCQUNUL2hHLFVBQVU7WUFDWjtRQUNGO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDNmdHLGVBQWUsRUFBRTtZQUMxQixJQUFJLENBQUMsQ0FBQ3VDLFFBQVEsQ0FBQztRQUNqQjtJQUNGO0lBQ0EsSUFBSXhwRSxtQkFBbUI7UUFDckIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDaW5FLGVBQWU7SUFDL0I7SUFDQTV3RixLQUFLa1ksVUFBVSxJQUFJLENBQUMrTixVQUFVLEVBQUU7UUFDOUIsS0FBSyxDQUFDam1CLEtBQUtrWTtRQUNYLElBQUksSUFBSSxDQUFDOW1CLE1BQU0sRUFBRTtZQUNmLElBQUksQ0FBQ0EsTUFBTSxDQUFDdWdHLFNBQVMsQ0FBQ00sZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUN4K0gsRUFBRSxFQUFFO2dCQUMvQ3ErSCxXQUFXO29CQUNUbmdHLFFBQVEsQ0FBQ3VtQjtnQkFDWDtZQUNGO1lBQ0EsSUFBSSxDQUFDOW1CLE1BQU0sQ0FBQ3VnRyxTQUFTLENBQUNNLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDcEIsU0FBUyxFQUFFO2dCQUN0RGlCLFdBQVc7b0JBQ1RuZ0csUUFBUSxDQUFDdW1CO2dCQUNYO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsQ0FBQ3k2RSxXQUFXO1FBQ1YsT0FBTyxJQUFJLENBQUMsQ0FBQy9CLGVBQWUsR0FBRyxJQUFJLENBQUN2OUYsUUFBUSxHQUFHO0lBQ2pEO0lBQ0EsQ0FBQysvRixjQUFjO1FBQ2IsSUFBSSxJQUFJLENBQUMsQ0FBQ3hDLGVBQWUsRUFBRTtZQUN6QixPQUFPO1FBQ1Q7UUFDQSxNQUFNLENBQUN2OEYsV0FBV0MsV0FBVyxHQUFHLElBQUksQ0FBQ2t5QixjQUFjO1FBQ25ELE1BQU0sQ0FBQ2p5QixPQUFPQyxNQUFNLEdBQUcsSUFBSSxDQUFDaXlCLGVBQWU7UUFDM0MsTUFBTXJrQixRQUFRLElBQUksQ0FBQyxDQUFDQSxLQUFLO1FBQ3pCLE1BQU1xMEUsYUFBYSxJQUFJMTdHLGFBQWFxbkMsTUFBTXRqRCxNQUFNLEdBQUc7UUFDbkQsSUFBSTJFLElBQUk7UUFDUixLQUFLLE1BQU0sRUFDVGdDLENBQUMsRUFDRDBNLENBQUMsRUFDRDhoQyxLQUFLLEVBQ0xDLE1BQU0sRUFDUCxJQUFJa08sTUFBTztZQUNWLE1BQU03SSxLQUFLOXpDLElBQUk0dUMsWUFBWUU7WUFDM0IsTUFBTWlGLEtBQUssQ0FBQyxJQUFJcm5DLENBQUFBLElBQUttaUMsYUFBYUU7WUFDbENpaUYsVUFBVSxDQUFDaHpILEVBQUUsR0FBR2d6SCxVQUFVLENBQUNoekgsSUFBSSxFQUFFLEdBQUc4MUM7WUFDcENrOUUsVUFBVSxDQUFDaHpILElBQUksRUFBRSxHQUFHZ3pILFVBQVUsQ0FBQ2h6SCxJQUFJLEVBQUUsR0FBRysxQztZQUN4Q2k5RSxVQUFVLENBQUNoekgsSUFBSSxFQUFFLEdBQUdnekgsVUFBVSxDQUFDaHpILElBQUksRUFBRSxHQUFHODFDLEtBQUt0RixRQUFRSTtZQUNyRG9pRixVQUFVLENBQUNoekgsSUFBSSxFQUFFLEdBQUdnekgsVUFBVSxDQUFDaHpILElBQUksRUFBRSxHQUFHKzFDLEtBQUt0RixTQUFTSTtZQUN0RDd3QyxLQUFLO1FBQ1A7UUFDQSxPQUFPZ3pIO0lBQ1Q7SUFDQSxDQUFDNGMsaUJBQWlCLENBQUN6c0csSUFBSTtRQUNyQixPQUFPLElBQUksQ0FBQyxDQUFDK3BHLGlCQUFpQixDQUFDOXBGLFNBQVMsQ0FBQ2pnQixNQUFNLElBQUksQ0FBQyxDQUFDK3JHLFdBQVc7SUFDbEU7SUFDQSxPQUFPVyxrQkFBa0JsaUcsTUFBTSxFQUFFaVIsS0FBSyxFQUFFLEVBQ3RDL2lELFFBQVFteUQsU0FBUyxFQUNqQmhzRCxDQUFDLEVBQ0QwTSxDQUFDLEVBQ0YsRUFBRTtRQUNELE1BQU0sRUFDSjFNLEdBQUdrckQsTUFBTSxFQUNUeCtDLEdBQUd5K0MsTUFBTSxFQUNUM2MsT0FBT2dvQixXQUFXLEVBQ2xCL25CLFFBQVFnb0IsWUFBWSxFQUNyQixHQUFHekssVUFBVVoscUJBQXFCO1FBQ25DLE1BQU1sakIsS0FBSyxJQUFJQztRQUNmLE1BQU1DLFNBQVN1RCxPQUFPa2MsY0FBYyxDQUFDM2Y7UUFDckMsTUFBTXE5QixvQkFBb0IxMkQsQ0FBQUE7WUFDeEJxNUIsR0FBR0ksS0FBSztZQUNSLElBQUksQ0FBQyxDQUFDd2xHLFlBQVksQ0FBQ25pRyxRQUFROThCO1FBQzdCO1FBQ0FnQyxPQUFPMjNCLGdCQUFnQixDQUFDLFFBQVErOEIsbUJBQW1CO1lBQ2pEbjlCO1FBQ0Y7UUFDQXYzQixPQUFPMjNCLGdCQUFnQixDQUFDLGFBQWErOEIsbUJBQW1CO1lBQ3REbjlCO1FBQ0Y7UUFDQXYzQixPQUFPMjNCLGdCQUFnQixDQUFDLGVBQWV5SSxXQUFXO1lBQ2hEbUosU0FBUztZQUNUK2hCLFNBQVM7WUFDVC96QjtRQUNGO1FBQ0F2M0IsT0FBTzIzQixnQkFBZ0IsQ0FBQyxlQUFldUksZUFBZTtZQUNwRDNJO1FBQ0Y7UUFDQTRqQixVQUFVeGpCLGdCQUFnQixDQUFDLGVBQWUsSUFBSSxDQUFDLENBQUN1bEcsYUFBYSxDQUFDM3VJLElBQUksQ0FBQyxJQUFJLEVBQUV1c0MsU0FBUztZQUNoRnZEO1FBQ0Y7UUFDQSxJQUFJLENBQUNvakcsY0FBYyxHQUFHLElBQUlaLHNCQUFzQjtZQUM5QzVxSTtZQUNBME07UUFDRixHQUFHO1lBQUN3K0M7WUFBUUM7WUFBUXFMO1lBQWFDO1NBQWEsRUFBRTlxQixPQUFPZ0MsS0FBSyxFQUFFLElBQUksQ0FBQzI5RixpQkFBaUIsR0FBRyxHQUFHMXVGLE9BQU87UUFDaEcsR0FDQzV1QyxJQUFJLElBQUksQ0FBQ3U5SCxnQkFBZ0IsRUFDekJSLFlBQVksSUFBSSxDQUFDVSxvQkFBb0IsRUFDdEMsR0FBRzkvRixPQUFPdWdHLFNBQVMsQ0FBQ29CLElBQUksQ0FBQztZQUN4QjkyRCxNQUFNO2dCQUFDO2dCQUFHO2dCQUFHO2dCQUFHO2FBQUU7WUFDbEJ0eUQsTUFBTTtnQkFDSnVwQixTQUFTO2dCQUNUL1csTUFBTSxJQUFJLENBQUNrc0csYUFBYTtnQkFDeEIsZ0JBQWdCLElBQUksQ0FBQ3lJLGVBQWU7WUFDdEM7WUFDQWdCLFdBQVc7Z0JBQ1RsekYsV0FBVztnQkFDWG96RixNQUFNO1lBQ1I7WUFDQTUyRCxNQUFNO2dCQUNKbHJELEdBQUcsSUFBSSxDQUFDK2dILGNBQWMsQ0FBQ3pGLFNBQVM7WUFDbEM7UUFDRixHQUFHLE1BQU0sS0FBSTtJQUNmO0lBQ0EsT0FBTyxDQUFDZ0ksYUFBYSxDQUFDcGlHLE1BQU0sRUFBRTlCLEtBQUs7UUFDakMsSUFBSSxJQUFJLENBQUMyaEcsY0FBYyxDQUFDdDhILEdBQUcsQ0FBQzI2QixRQUFRO1lBQ2xDOEIsT0FBT3VnRyxTQUFTLENBQUNNLGdCQUFnQixDQUFDLElBQUksQ0FBQ2pCLGdCQUFnQixFQUFFO2dCQUN2RDUxRCxNQUFNO29CQUNKbHJELEdBQUcsSUFBSSxDQUFDK2dILGNBQWMsQ0FBQ3pGLFNBQVM7Z0JBQ2xDO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBTyxDQUFDK0gsWUFBWSxDQUFDbmlHLE1BQU0sRUFBRTlCLEtBQUs7UUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQzJoRyxjQUFjLENBQUNqbEYsT0FBTyxJQUFJO1lBQ2xDNWEsT0FBT29oQixxQkFBcUIsQ0FBQ2xqQixPQUFPLE9BQU87Z0JBQ3pDOGhHLGFBQWEsSUFBSSxDQUFDSixnQkFBZ0I7Z0JBQ2xDTCxtQkFBbUIsSUFBSSxDQUFDTSxjQUFjLENBQUNyRCxXQUFXO2dCQUNsRDRDLFlBQVksSUFBSSxDQUFDVSxvQkFBb0I7Z0JBQ3JDdC9FLGtCQUFrQjtZQUNwQjtRQUNGLE9BQU87WUFDTHhnQixPQUFPdWdHLFNBQVMsQ0FBQ3o5SCxNQUFNLENBQUMsSUFBSSxDQUFDODhILGdCQUFnQjtRQUMvQztRQUNBLElBQUksQ0FBQ0EsZ0JBQWdCLEdBQUcsQ0FBQztRQUN6QixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLG9CQUFvQixHQUFHO0lBQzlCO0lBQ0EsYUFBYWg4RSxZQUFZN2xELElBQUksRUFBRStoQyxNQUFNLEVBQUUwUSxTQUFTLEVBQUU7UUFDaEQsSUFBSWl2RCxjQUFjO1FBQ2xCLElBQUkxaEcsZ0JBQWdCcWxILDRCQUE0QjtZQUM5QyxNQUFNLEVBQ0pybEgsTUFBTSxFQUNKb25ILFVBQVUsRUFDVjd2RixJQUFJLEVBQ0p5TSxRQUFRLEVBQ1I1L0IsRUFBRSxFQUNGcWtDLEtBQUssRUFDTG1ELE9BQU8sRUFDUHNjLFFBQVEsRUFDUjhILFFBQVEsRUFDUjdILFdBQVcsRUFDWDZPLFlBQVksRUFDWkMsZ0JBQWdCLEVBQ2pCLEVBQ0RsMUIsUUFBUSxFQUNOdkUsTUFBTSxFQUNKa2pCLFVBQVUsRUFDWCxFQUNGLEVBQ0YsR0FBRzFnRDtZQUNKMGhHLGNBQWMxaEcsT0FBTztnQkFDbkJxaUUsZ0JBQWdCNStDLHFCQUFxQkcsU0FBUztnQkFDOUM2a0IsT0FBT2puQyxNQUFNcVcsSUFBSSxDQUFDNHdCO2dCQUNsQm1EO2dCQUNBdzdFO2dCQUNBcjBFLE9BQU87Z0JBQ1A2TSxXQUFXYyxhQUFhO2dCQUN4Qm5wQixNQUFNQSxLQUFLdmxDLEtBQUssQ0FBQztnQkFDakJneUM7Z0JBQ0E4akIscUJBQXFCMWpEO2dCQUNyQkE7Z0JBQ0E0akQsU0FBUztnQkFDVEU7Z0JBQ0E4SDtnQkFDQS9nQixTQUFTa1osYUFBYTl6QixPQUFPO2dCQUM3QjJpQztnQkFDQUM7WUFDRjtRQUNGLE9BQU8sSUFBSWozRCxnQkFBZ0JtbEgsc0JBQXNCO1lBQy9DLE1BQU0sRUFDSm5sSCxNQUFNLEVBQ0pxbkgsUUFBUSxFQUNSOXZGLElBQUksRUFDSnlNLFFBQVEsRUFDUjUvQixFQUFFLEVBQ0Zxa0MsS0FBSyxFQUNMdy9FLGFBQWEsRUFDWHdRLFVBQVVqQyxTQUFTLEVBQ3BCLEVBQ0R0dUUsUUFBUSxFQUNSOEgsUUFBUSxFQUNSN0gsV0FBVyxFQUNYNk8sWUFBWSxFQUNaQyxnQkFBZ0IsRUFDakIsRUFDRGwxQixRQUFRLEVBQ052RSxNQUFNLEVBQ0prakIsVUFBVSxFQUNYLEVBQ0YsRUFDRixHQUFHMWdEO1lBQ0owaEcsY0FBYzFoRyxPQUFPO2dCQUNuQnFpRSxnQkFBZ0I1K0MscUJBQXFCRyxTQUFTO2dCQUM5QzZrQixPQUFPam5DLE1BQU1xVyxJQUFJLENBQUM0d0I7Z0JBQ2xCK3RGO2dCQUNBblA7Z0JBQ0F0MEUsT0FBTztnQkFDUDZNLFdBQVdjLGFBQWE7Z0JBQ3hCbnBCLE1BQU1BLEtBQUt2bEMsS0FBSyxDQUFDO2dCQUNqQmd5QztnQkFDQThqQixxQkFBcUIxakQ7Z0JBQ3JCQTtnQkFDQTRqRCxTQUFTO2dCQUNURTtnQkFDQThIO2dCQUNBL2dCLFNBQVNrWixhQUFhOXpCLE9BQU87Z0JBQzdCMmlDO2dCQUNBQztZQUNGO1FBQ0Y7UUFDQSxNQUFNLEVBQ0p4dUIsS0FBSyxFQUNMMitFLFVBQVUsRUFDVkMsUUFBUSxFQUNSejdFLE9BQU8sRUFDUixHQUFHNXJDO1FBQ0osTUFBTTh1QyxTQUFTLE1BQU0sS0FBSyxDQUFDK1csWUFBWTdsRCxNQUFNK2hDLFFBQVEwUTtRQUNyRDNELE9BQU9yRyxLQUFLLEdBQUc1UyxLQUFLQyxZQUFZLElBQUkyUztRQUNwQ3FHLE9BQU9sRCxPQUFPLEdBQUdBLFdBQVc7UUFDNUIsSUFBSXk3RSxVQUFVO1lBQ1p2NEUsT0FBTyxDQUFDMG5GLFNBQVMsR0FBR3gySCxLQUFLdzJILFNBQVM7UUFDcEM7UUFDQTFuRixPQUFPNm5CLFlBQVksR0FBRytxQztRQUN0QixJQUFJMWhHLEtBQUtpdkMsT0FBTyxFQUFFO1lBQ2hCSCxPQUFPK3ZCLGNBQWMsQ0FBQzcrRDtRQUN4QjtRQUNBLE1BQU0sQ0FBQ2dsQyxXQUFXQyxXQUFXLEdBQUc2SixPQUFPcW9CLGNBQWM7UUFDckQsTUFBTSxDQUFDanlCLE9BQU9DLE1BQU0sR0FBRzJKLE9BQU9zb0IsZUFBZTtRQUM3QyxJQUFJZ3dELFlBQVk7WUFDZCxNQUFNcjBFLFFBQVFqRSxPQUFPLENBQUNpRSxLQUFLLEdBQUcsRUFBRTtZQUNoQyxJQUFLLElBQUkzK0MsSUFBSSxHQUFHQSxJQUFJZ3pILFdBQVczM0gsTUFBTSxFQUFFMkUsS0FBSyxFQUFHO2dCQUM3QzIrQyxNQUFNcjRDLElBQUksQ0FBQztvQkFDVHRFLEdBQUcsQ0FBQ2d4SCxVQUFVLENBQUNoekgsRUFBRSxHQUFHOHdDLEtBQUksSUFBS0Y7b0JBQzdCbGlDLEdBQUcsSUFBSSxDQUFDc2tILFVBQVUsQ0FBQ2h6SCxJQUFJLEVBQUUsR0FBRyt3QyxLQUFJLElBQUtGO29CQUNyQ0wsT0FBTyxDQUFDd2lGLFVBQVUsQ0FBQ2h6SCxJQUFJLEVBQUUsR0FBR2d6SCxVQUFVLENBQUNoekgsRUFBRSxJQUFJNHdDO29CQUM3Q0gsUUFBUSxDQUFDdWlGLFVBQVUsQ0FBQ2h6SCxJQUFJLEVBQUUsR0FBR2d6SCxVQUFVLENBQUNoekgsSUFBSSxFQUFFLElBQUk2d0M7Z0JBQ3BEO1lBQ0Y7WUFDQTZKLE9BQU8sQ0FBQ296RixjQUFjO1lBQ3RCcHpGLE9BQU8sQ0FBQ216RixjQUFjO1lBQ3RCbnpGLE9BQU9vekIsTUFBTSxDQUFDcHpCLE9BQU85SyxRQUFRO1FBQy9CLE9BQU8sSUFBSXFqRixVQUFVO1lBQ25CdjRFLE9BQU8sQ0FBQ3l5RixlQUFlLEdBQUc7WUFDMUIsTUFBTWxMLFNBQVNoUCxRQUFRLENBQUMsRUFBRTtZQUMxQixNQUFNenFELFFBQVE7Z0JBQ1p4bUUsR0FBR2lnSSxNQUFNLENBQUMsRUFBRSxHQUFHbnhGO2dCQUNmcGlDLEdBQUdtaUMsYUFBY294RixDQUFBQSxNQUFNLENBQUMsRUFBRSxHQUFHbHhGLEtBQUk7WUFDbkM7WUFDQSxNQUFNbzZGLFdBQVcsSUFBSXlCLHNCQUFzQnBrRSxPQUFPO2dCQUFDO2dCQUFHO2dCQUFHNTNCO2dCQUFXQzthQUFXLEVBQUUsR0FBRzZKLE9BQU8sQ0FBQzBuRixTQUFTLEdBQUcsR0FBRyxNQUFNO1lBQ2pILElBQUssSUFBSXBpSSxJQUFJLEdBQUdpbkMsS0FBS2c3RixPQUFPNW1JLE1BQU0sRUFBRTJFLElBQUlpbkMsSUFBSWpuQyxLQUFLLEVBQUc7Z0JBQ2xEd29FLE1BQU14bUUsQ0FBQyxHQUFHaWdJLE1BQU0sQ0FBQ2ppSSxFQUFFLEdBQUc4d0M7Z0JBQ3RCMDNCLE1BQU05NUQsQ0FBQyxHQUFHbWlDLGFBQWNveEYsQ0FBQUEsTUFBTSxDQUFDamlJLElBQUksRUFBRSxHQUFHK3dDLEtBQUk7Z0JBQzVDbzZGLFNBQVNqNkgsR0FBRyxDQUFDczNEO1lBQ2Y7WUFDQSxNQUFNLEVBQ0p4NEQsRUFBRSxFQUNGKzhILFVBQVUsRUFDWCxHQUFHcC9GLE9BQU91Z0csU0FBUyxDQUFDb0IsSUFBSSxDQUFDO2dCQUN4QjkyRCxNQUFNO29CQUFDO29CQUFHO29CQUFHO29CQUFHO2lCQUFFO2dCQUNsQnR5RCxNQUFNO29CQUNKdXBCLFNBQVM7b0JBQ1QvVyxNQUFNZ2lCLE9BQU9yRyxLQUFLO29CQUNsQixnQkFBZ0JxRyxPQUFPMnlGLGVBQWU7Z0JBQ3hDO2dCQUNBZ0IsV0FBVztvQkFDVGx6RixXQUFXO29CQUNYb3pGLE1BQU07Z0JBQ1I7Z0JBQ0E1MkQsTUFBTTtvQkFDSmxyRCxHQUFHMCtHLFNBQVNwRCxTQUFTO2dCQUN2QjtZQUNGLEdBQUcsTUFBTTtZQUNUcnRGLE9BQU8sQ0FBQ2t6RixrQkFBa0IsQ0FBQztnQkFDekJWLG1CQUFtQi9CLFNBQVNoQixXQUFXO2dCQUN2Q3dELGFBQWEzOUg7Z0JBQ2IrOEg7WUFDRjtZQUNBcnlGLE9BQU8sQ0FBQ216RixjQUFjO1lBQ3RCbnpGLE9BQU9vekIsTUFBTSxDQUFDcHpCLE9BQU80cEIsY0FBYztRQUNyQztRQUNBLE9BQU81cEI7SUFDVDtJQUNBMEksVUFBVTBYLGVBQWUsS0FBSyxFQUFFO1FBQzlCLElBQUksSUFBSSxDQUFDdlMsT0FBTyxNQUFNdVMsY0FBYztZQUNsQyxPQUFPO1FBQ1Q7UUFDQSxJQUFJLElBQUksQ0FBQ2xILE9BQU8sRUFBRTtZQUNoQixPQUFPLElBQUksQ0FBQ29hLGdCQUFnQjtRQUM5QjtRQUNBLE1BQU0zNUIsUUFBUWdzQixpQkFBaUJ3QixhQUFhLENBQUMvZCxPQUFPLENBQUMsSUFBSSxDQUFDdEksVUFBVSxDQUFDbVAsY0FBYyxDQUFDLElBQUksQ0FBQ3RXLEtBQUs7UUFDOUYsTUFBTStjLGFBQWEsS0FBSyxDQUFDaE8sVUFBVTBYO1FBQ25DcDlELE9BQU9rdkMsTUFBTSxDQUFDd2tCLFlBQVk7WUFDeEIvYztZQUNBbUQsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckI0cUYsV0FBVyxJQUFJLENBQUMsQ0FBQ0EsU0FBUztZQUMxQnBQLFlBQVksSUFBSSxDQUFDLENBQUMyYyxjQUFjO1lBQ2hDeEQsVUFBVSxJQUFJLENBQUMsQ0FBQ3lELGlCQUFpQixDQUFDeCtFLFdBQVdqdUIsSUFBSTtRQUNuRDtRQUNBLElBQUksQ0FBQzZaLFVBQVUsQ0FBQ29VO1FBQ2hCLElBQUksSUFBSSxDQUFDc0MsbUJBQW1CLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ20wRSxpQkFBaUIsQ0FBQ3oyRSxhQUFhO1lBQ3BFLE9BQU87UUFDVDtRQUNBQSxXQUFXcGhELEVBQUUsR0FBRyxJQUFJLENBQUMwakQsbUJBQW1CO1FBQ3hDLE9BQU90QztJQUNUO0lBQ0EsQ0FBQ3kyRSxpQkFBaUIsQ0FBQ3oyRSxVQUFVO1FBQzNCLE1BQU0sRUFDSi9jLEtBQUssRUFDTixHQUFHLElBQUksQ0FBQ2t1QixZQUFZO1FBQ3JCLE9BQU8sSUFBSSxDQUFDb0ksZ0JBQWdCLElBQUl2WixXQUFXL2MsS0FBSyxDQUFDcGpDLElBQUksQ0FBQyxDQUFDcUssR0FBR3RiLElBQU1zYixNQUFNKzRCLEtBQUssQ0FBQ3IwQyxFQUFFO0lBQ2hGO0lBQ0E4NEQsd0JBQXdCakYsVUFBVSxFQUFFO1FBQ2xDLElBQUksSUFBSSxDQUFDRCxPQUFPLEVBQUU7WUFDaEJDLFdBQVd4WCxJQUFJO1lBQ2YsT0FBTztRQUNUO1FBQ0F3WCxXQUFXa2MsWUFBWSxDQUFDO1lBQ3RCNXNDLE1BQU0sSUFBSSxDQUFDaXFDLFVBQVU7WUFDckIvQixPQUFPLElBQUksQ0FBQ3h3QixPQUFPO1FBQ3JCO1FBQ0EsT0FBTztJQUNUO0lBQ0EsT0FBT3VaLDBCQUEwQjtRQUMvQixPQUFPO0lBQ1Q7QUFDRjtFQUVDLCtCQUErQjtBQVloQyxNQUFNNDdFO0lBQ0osQ0FBQ0MsYUFBYSxDQUF1QjtJQUNyQ0MsZUFBZS94SSxJQUFJLEVBQUU3QixLQUFLLEVBQUU7UUFDMUIsSUFBSSxDQUFDNkIsS0FBSyxHQUFHN0I7UUFDYixJQUFJLENBQUM2ekksaUJBQWlCLENBQUNoeUksTUFBTTdCO0lBQy9CO0lBQ0FreUksaUJBQWlCcDFDLFVBQVUsRUFBRTtRQUMzQixJQUFJLENBQUNBLFlBQVk7WUFDZjtRQUNGO1FBQ0EsS0FBSyxNQUFNLENBQUNqN0YsTUFBTTdCLE1BQU0sSUFBSW9CLE9BQU84WCxPQUFPLENBQUM0akYsWUFBYTtZQUN0RCxJQUFJLENBQUNqN0YsS0FBS2tnQyxVQUFVLENBQUMsTUFBTTtnQkFDekIsSUFBSSxDQUFDNnhHLGNBQWMsQ0FBQy94SSxNQUFNN0I7WUFDNUI7UUFDRjtJQUNGO0lBQ0E2ekksa0JBQWtCaHlJLElBQUksRUFBRTdCLEtBQUssRUFBRTtRQUM3QixJQUFJLENBQUMsQ0FBQzJ6SSxhQUFhLENBQUM5eEksS0FBSyxHQUFHN0I7SUFDOUI7SUFDQTh6SSxrQkFBa0I7UUFDaEIsTUFBTWxxSCxPQUFPLElBQUksQ0FBQyxDQUFDK3BILGFBQWE7UUFDaEMsSUFBSSxDQUFDLENBQUNBLGFBQWEsR0FBR3Z5SSxPQUFPK0wsTUFBTSxDQUFDO1FBQ3BDLE9BQU87WUFDTHljO1FBQ0Y7SUFDRjtJQUNBNjNELFFBQVE7UUFDTixJQUFJLENBQUMsQ0FBQ2t5RCxhQUFhLEdBQUd2eUksT0FBTytMLE1BQU0sQ0FBQztJQUN0QztJQUNBNG1JLFVBQVVqeUksVUFBVSxJQUFJLEVBQUU7UUFDeEIsSUFBSSxDQUFDb3dJLGdCQUFnQixDQUFDcHdJO0lBQ3hCO0lBQ0F3RyxRQUFRO1FBQ05pNUIsWUFBWTtJQUNkOzthQWpDQSxDQUFDb3lHLGFBQWEsR0FBR3Z5SSxPQUFPK0wsTUFBTSxDQUFDOztBQWtDakM7QUFDQSxNQUFNNm1JLHNCQUFzQmp3RTtJQUMxQixDQUFDa3dFLFlBQVksQ0FBUTtJQUNyQixDQUFDQyxlQUFlLENBQUM7O2FBR1ZDLGlCQUFpQixDQUFDOzs7YUFDbEJDLGlCQUFpQjs7SUFDeEIsT0FBTyxDQUFDQyxXQUFXLEdBQUcsS0FBSztJQUMzQixPQUFPLENBQUNDLGdCQUFnQixHQUFHLEtBQUs7SUFDaEMsT0FBTyxDQUFDQyxxQkFBcUIsR0FBRyxLQUFLO0lBQ3JDLE9BQU8sQ0FBQ0MsZ0JBQWdCLEdBQUduakksSUFBSTtJQUMvQixPQUFPLENBQUNvakksa0JBQWtCLEdBQUcsS0FBSztJQUNsQyxPQUFPLENBQUNDLGlCQUFpQixHQUFHLEtBQUs7SUFDakMsT0FBTyxDQUFDQyxvQkFBb0IsR0FBR3RqSSxJQUFJOzthQUM1QnVqSSxnQkFBZ0I7O0lBQ3ZCenlJLFlBQVk2VyxNQUFNLENBQUU7UUFDbEIsS0FBSyxDQUFDQTthQWZSLENBQUNpN0gsWUFBWSxHQUFHO2FBRWhCeEwsZUFBZTthQUNmb00sVUFBVTtRQWFSLElBQUksQ0FBQyxDQUFDWCxlQUFlLEdBQUdsN0gsT0FBT2s3SCxlQUFlLElBQUk7UUFDbEQsSUFBSSxDQUFDWSxZQUFZLENBQUM5N0g7SUFDcEI7SUFDQTZtRCxpQkFBaUI7UUFDZixJQUFJLENBQUM0b0UsWUFBWSxFQUFFOTJGLE9BQU8sSUFBSSxDQUFDb0csS0FBSztRQUNwQyxLQUFLLENBQUM4bkI7SUFDUjtJQUNBaTFFLGFBQWE5N0gsTUFBTSxFQUFFO1FBQ25CLElBQUlBLE9BQU9pN0gsWUFBWSxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxDQUFDYyxrQkFBa0IsQ0FBQy83SDtZQUN6QixJQUFJLENBQUMsQ0FBQ3U0SCxjQUFjO1FBQ3RCO0lBQ0Y7SUFDQSxDQUFDd0Qsa0JBQWtCLENBQUMsRUFDbEJkLFlBQVksRUFDWmUsTUFBTSxFQUNOQyxjQUFjLEVBQ2Y7UUFDQyxJQUFJLENBQUMsQ0FBQ2hCLFlBQVksR0FBR0E7UUFDckIsSUFBSSxDQUFDaUIsZUFBZSxLQUFLRDtRQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDNzlFLG1CQUFtQixFQUFFO1lBQzdCLElBQUksQ0FBQ2xZLFVBQVUsQ0FBQytULFNBQVMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUM3UyxVQUFVLENBQUMsWUFBWSxDQUFDO1FBQ3pFO1FBQ0EsSUFBSTQwRixVQUFVLEdBQUc7WUFDZixJQUFJLENBQUNILE9BQU8sR0FBR0c7WUFDZixJQUFJLENBQUMzakcsTUFBTSxDQUFDdWdHLFNBQVMsQ0FBQ0MsWUFBWSxDQUFDbUQsUUFBUWYsYUFBYWtCLGlCQUFpQjtRQUMzRSxPQUFPO1lBQ0wsSUFBSSxDQUFDTixPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUNPLGFBQWEsQ0FBQ25CLGNBQWMsSUFBSSxDQUFDNWlHLE1BQU07UUFDOUQ7UUFDQSxJQUFJLENBQUMsQ0FBQ2drRyxVQUFVLENBQUNwQixhQUFheHhGLEdBQUc7SUFDbkM7SUFDQSxDQUFDMnlGLGFBQWEsQ0FBQ25CLFlBQVksRUFBRTVpRyxNQUFNO1FBQ2pDLE1BQU0sRUFDSjM5QixFQUFFLEVBQ0gsR0FBRzI5QixPQUFPdWdHLFNBQVMsQ0FBQ29CLElBQUksQ0FBQ2dCLGNBQWNzQixtQkFBbUIsQ0FBQyxJQUFJLENBQUNKLGVBQWUsQ0FBQ3BCLGVBQWUsSUFBSUcsYUFBYXNCLG9CQUFvQixHQUFHLE9BQU87UUFDL0ksT0FBTzdoSTtJQUNUO0lBQ0EsT0FBTzRoSSxvQkFBb0JudkcsRUFBRSxFQUFFZ0csRUFBRSxFQUFFO1FBQ2pDLE1BQU1xcEcsU0FBUyxJQUFJeitILElBQUkzVixPQUFPbUYsSUFBSSxDQUFDNC9CO1FBQ25DLEtBQUssTUFBTSxDQUFDaDhCLEtBQUtuSyxNQUFNLElBQUlvQixPQUFPOFgsT0FBTyxDQUFDaXpCLElBQUs7WUFDN0MsSUFBSXFwRyxPQUFPanVJLEdBQUcsQ0FBQzRDLE1BQU07Z0JBQ25CL0ksT0FBT2t2QyxNQUFNLENBQUNuSyxFQUFFLENBQUNoOEIsSUFBSSxFQUFFbks7WUFDekIsT0FBTztnQkFDTG1tQyxFQUFFLENBQUNoOEIsSUFBSSxHQUFHbks7WUFDWjtRQUNGO1FBQ0EsT0FBT21tQztJQUNUO0lBQ0EsT0FBT3N2Ryx5QkFBeUJDLFFBQVEsRUFBRTtRQUN4Q24wRyxZQUFZO0lBQ2Q7SUFDQSxXQUFXbzBHLFdBQVc7UUFDcEJwMEcsWUFBWTtJQUNkO0lBQ0EsV0FBV3NsQyxXQUFXO1FBQ3BCLE9BQU87SUFDVDtJQUNBLFdBQVcrdUUsMEJBQTBCO1FBQ25DLE9BQU87SUFDVDtJQUNBLE9BQU8xOUUsb0JBQW9CeHdELElBQUksRUFBRTFILEtBQUssRUFBRTtRQUN0QyxNQUFNNjFJLGVBQWUsSUFBSSxDQUFDRixRQUFRLENBQUMzMEksR0FBRyxDQUFDMEc7UUFDdkMsSUFBSW11SSxjQUFjO1lBQ2hCLElBQUksQ0FBQ0Msc0JBQXNCLENBQUNsQyxjQUFjLENBQUNpQyxjQUFjNzFJO1FBQzNEO1FBQ0EsSUFBSSxJQUFJLENBQUNvMEksY0FBYyxFQUFFO1lBQ3ZCSixjQUFjLENBQUNLLFdBQVcsQ0FBQ1QsY0FBYyxDQUFDaUMsY0FBYzcxSTtZQUN4RCxJQUFJLENBQUNvMEksY0FBYyxDQUFDeEMsU0FBUyxDQUFDTSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNpQyxjQUFjLEVBQUUsSUFBSSxDQUFDMkIsc0JBQXNCLENBQUNoQyxlQUFlO1FBQ2pIO0lBQ0Y7SUFDQWxuRixhQUFhbGxELElBQUksRUFBRTFILEtBQUssRUFBRTtRQUN4QixNQUFNNjFJLGVBQWUsSUFBSSxDQUFDMXpJLFdBQVcsQ0FBQ3d6SSxRQUFRLENBQUMzMEksR0FBRyxDQUFDMEc7UUFDbkQsSUFBSW11SSxjQUFjO1lBQ2hCLElBQUksQ0FBQ0UsZUFBZSxDQUFDcnVJLE1BQU1tdUksY0FBYzcxSTtRQUMzQztJQUNGO0lBQ0EsV0FBVzYxRCw0QkFBNEI7UUFDckMsTUFBTWluQyxhQUFhLEVBQUU7UUFDckIsTUFBTWg3RixVQUFVLElBQUksQ0FBQ2cwSSxzQkFBc0I7UUFDM0MsS0FBSyxNQUFNLENBQUNwdUksTUFBTTdGLEtBQUssSUFBSSxJQUFJLENBQUM4ekksUUFBUSxDQUFFO1lBQ3hDNzRDLFdBQVc5eUYsSUFBSSxDQUFDO2dCQUFDdEM7Z0JBQU01RixPQUFPLENBQUNELEtBQUs7YUFBQztRQUN2QztRQUNBLE9BQU9pN0Y7SUFDVDtJQUNBLElBQUl4akMscUJBQXFCO1FBQ3ZCLE1BQU13akMsYUFBYSxFQUFFO1FBQ3JCLE1BQU0sRUFDSm80QyxlQUFlLEVBQ2hCLEdBQUcsSUFBSTtRQUNSLEtBQUssTUFBTSxDQUFDeHRJLE1BQU03RixLQUFLLElBQUksSUFBSSxDQUFDTSxXQUFXLENBQUN3ekksUUFBUSxDQUFFO1lBQ3BENzRDLFdBQVc5eUYsSUFBSSxDQUFDO2dCQUFDdEM7Z0JBQU13dEksZUFBZSxDQUFDcnpJLEtBQUs7YUFBQztRQUMvQztRQUNBLE9BQU9pN0Y7SUFDVDtJQUNBaTVDLGdCQUFnQnJ1SSxJQUFJLEVBQUU3RixJQUFJLEVBQUU3QixLQUFLLEVBQUU7UUFDakMsTUFBTThCLFVBQVUsSUFBSSxDQUFDb3pJLGVBQWU7UUFDcEMsTUFBTWMsYUFBYWwwSSxPQUFPLENBQUNELEtBQUs7UUFDaEMsTUFBTUcsU0FBUzJVLENBQUFBO1lBQ2I3VSxRQUFROHhJLGNBQWMsQ0FBQy94SSxNQUFNOFU7WUFDN0IsTUFBTXVsRSxPQUFPLElBQUksQ0FBQyxDQUFDKzNELFlBQVksQ0FBQ0wsY0FBYyxDQUFDL3hJLE1BQU04VTtZQUNyRCxJQUFJdWxFLE1BQU07Z0JBQ1IsSUFBSSxDQUFDLENBQUNtNUQsVUFBVSxDQUFDbjVEO1lBQ25CO1lBQ0EsSUFBSSxDQUFDN3FDLE1BQU0sRUFBRXVnRyxVQUFVTSxpQkFBaUIsSUFBSSxDQUFDMkMsT0FBTyxFQUFFL3lJLFFBQVFneUksZUFBZTtZQUM3RSxJQUFJcHNJLFNBQVMsSUFBSSxDQUFDMHBILFNBQVMsRUFBRTtnQkFDM0IsSUFBSSxDQUFDdnhELGNBQWM7WUFDckI7UUFDRjtRQUNBLElBQUksQ0FBQ3ZLLFdBQVcsQ0FBQztZQUNmdlAsS0FBSy9qRCxPQUFPOEMsSUFBSSxDQUFDLElBQUksRUFBRTlFO1lBQ3ZCZ21ELE1BQU1oa0QsT0FBTzhDLElBQUksQ0FBQyxJQUFJLEVBQUVreEk7WUFDeEIvdkYsTUFBTSxJQUFJLENBQUMvRyxVQUFVLENBQUN1YSxRQUFRLENBQUMzMEQsSUFBSSxDQUFDLElBQUksQ0FBQ282QyxVQUFVLEVBQUUsSUFBSTtZQUN6RGdILFVBQVU7WUFDVngrQztZQUNBeStDLHFCQUFxQjtZQUNyQkMsVUFBVTtRQUNaO0lBQ0Y7SUFDQTJtQixjQUFjO1FBQ1osSUFBSSxDQUFDMTdCLE1BQU0sRUFBRXVnRyxVQUFVTSxpQkFBaUIsSUFBSSxDQUFDMkMsT0FBTyxFQUFFYixjQUFjc0IsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUNyQixZQUFZLENBQUNnQyw0QkFBNEIsQ0FBQyxJQUFJLENBQUMsQ0FBQ0Msa0JBQWtCLEtBQUs7WUFDbktoNkQsTUFBTSxJQUFJLENBQUMsQ0FBQ2k2RCxTQUFTO1FBQ3ZCO0lBQ0Y7SUFDQWhyRSxhQUFhO1FBQ1gsSUFBSSxDQUFDOTVCLE1BQU0sRUFBRXVnRyxVQUFVTSxpQkFBaUIsSUFBSSxDQUFDMkMsT0FBTyxFQUFFYixjQUFjc0IsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUNyQixZQUFZLENBQUNtQywyQkFBMkIsQ0FBQyxJQUFJLENBQUMsQ0FBQ0Ysa0JBQWtCLEtBQUs7WUFDbEtoNkQsTUFBTSxJQUFJLENBQUMsQ0FBQ2k2RCxTQUFTO1FBQ3ZCO0lBQ0Y7SUFDQWx0RSxlQUFlb3RFLEVBQUUsRUFBRUMsRUFBRSxFQUFFO1FBQ3JCLElBQUksQ0FBQ2psRyxNQUFNLEVBQUV1Z0csVUFBVU0saUJBQWlCLElBQUksQ0FBQzJDLE9BQU8sRUFBRTtZQUNwRDM0RCxNQUFNLElBQUksQ0FBQyxDQUFDaTZELFNBQVM7UUFDdkI7SUFDRjtJQUNBcHRFLGdCQUFnQjtRQUNkLElBQUksQ0FBQzEzQixNQUFNLEVBQUV1Z0csVUFBVU0saUJBQWlCLElBQUksQ0FBQzJDLE9BQU8sRUFBRWIsY0FBY3NCLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDckIsWUFBWSxDQUFDc0MsOEJBQThCLENBQUMsSUFBSSxDQUFDLENBQUNMLGtCQUFrQixJQUFJLElBQUksQ0FBQ3IxRSxnQkFBZ0IsR0FBRztZQUM1THFiLE1BQU0sSUFBSSxDQUFDLENBQUNpNkQsU0FBUztRQUN2QjtJQUNGO0lBQ0E1bEUsbUJBQW1CO1FBQ2pCLElBQUksQ0FBQ2wvQixNQUFNLEVBQUV1Z0csVUFBVU0saUJBQWlCLElBQUksQ0FBQzJDLE9BQU8sRUFBRTtZQUNwRDlDLFdBQVc7Z0JBQ1R5RSxRQUFRO1lBQ1Y7UUFDRjtJQUNGO0lBQ0FybUUsa0JBQWtCO1FBQ2hCLElBQUksQ0FBQzkrQixNQUFNLEVBQUV1Z0csVUFBVU0saUJBQWlCLElBQUksQ0FBQzJDLE9BQU8sRUFBRTtZQUNwRDlDLFdBQVc7Z0JBQ1R5RSxRQUFRO1lBQ1Y7UUFDRjtJQUNGO0lBQ0F2OEUsU0FBUztRQUNQLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNnWCxlQUFlO1FBQ3BCLElBQUksQ0FBQzZCLGNBQWM7SUFDckI7SUFDQUEsaUJBQWlCO1FBQ2YsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQzdoQyxHQUFHLENBQUMrSixTQUFTLENBQUMrVixNQUFNLENBQUMsWUFBWTtJQUN4QztJQUNBZ2lCLGdCQUFnQjtRQUNkLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUM5aEMsR0FBRyxDQUFDK0osU0FBUyxDQUFDK1YsTUFBTSxDQUFDLFlBQVk7SUFDeEM7SUFDQXdZLHFCQUFxQjtRQUNuQixPQUFPO1lBQUM7WUFBRztTQUFFO0lBQ2Y7SUFDQSxJQUFJN25ELGNBQWM7UUFDaEIsT0FBTztJQUNUO0lBQ0FxdkQsVUFBVXJnQixLQUFLLEVBQUU7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDMEcsbUJBQW1CLEVBQUU7WUFDN0IsSUFBSSxDQUFDL2xCLE1BQU0sQ0FBQ3doRyxpQkFBaUIsQ0FBQyxJQUFJO1FBQ3BDO1FBQ0EsSUFBSSxDQUFDL3FFLFlBQVksR0FBRztRQUNwQixJQUFJLElBQUksQ0FBQyxDQUFDb3NFLGVBQWUsRUFBRTtZQUN6QixJQUFJLENBQUMsQ0FBQ0EsZUFBZSxHQUFHO1lBQ3hCLElBQUksQ0FBQ2o2RSxNQUFNO1lBQ1gsSUFBSSxDQUFDNW9CLE1BQU0sQ0FBQ3NtQixXQUFXLENBQUMsSUFBSTtZQUM1QixJQUFJakgsU0FBUyxJQUFJLENBQUN5Z0IsVUFBVSxFQUFFO2dCQUM1QixJQUFJLENBQUNsZ0MsR0FBRyxDQUFDeWYsS0FBSztZQUNoQjtRQUNGO0lBQ0Y7SUFDQXY4QyxTQUFTO1FBQ1AsSUFBSSxDQUFDLENBQUMyK0gsY0FBYztRQUNwQixLQUFLLENBQUMzK0g7SUFDUjtJQUNBb25ELFVBQVU7UUFDUixJQUFJLENBQUMsSUFBSSxDQUFDbHFCLE1BQU0sRUFBRTtZQUNoQjtRQUNGO1FBQ0EsS0FBSyxDQUFDa3FCO1FBQ04sSUFBSSxJQUFJLENBQUN0cUIsR0FBRyxLQUFLLE1BQU07WUFDckI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDc2dHLGNBQWM7UUFDcEIsSUFBSSxDQUFDLENBQUM4RCxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUNwQixZQUFZLENBQUN4eEYsR0FBRztRQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDa2tCLGVBQWUsRUFBRTtZQUN6QixJQUFJLENBQUN0MUIsTUFBTSxDQUFDejhCLEdBQUcsQ0FBQyxJQUFJO1FBQ3RCO0lBQ0Y7SUFDQXd6RCxVQUFVLzJCLE1BQU0sRUFBRTtRQUNoQixJQUFJMGhHLGlCQUFpQjtRQUNyQixJQUFJLElBQUksQ0FBQzFoRyxNQUFNLElBQUksQ0FBQ0EsUUFBUTtZQUMxQixJQUFJLENBQUM2TixVQUFVLENBQUMrUixtQkFBbUIsQ0FBQyxJQUFJO1lBQ3hDLElBQUksQ0FBQyxDQUFDNmhGLGNBQWM7UUFDdEIsT0FBTyxJQUFJemhHLFFBQVE7WUFDakIsSUFBSSxDQUFDNk4sVUFBVSxDQUFDOFIsZ0JBQWdCLENBQUMsSUFBSTtZQUNyQyxJQUFJLENBQUMsQ0FBQ3VnRixjQUFjLENBQUNsZ0c7WUFDckIwaEcsaUJBQWlCLENBQUMsSUFBSSxDQUFDMWhHLE1BQU0sSUFBSSxJQUFJLENBQUNKLEdBQUcsRUFBRStKLFVBQVU2UCxTQUFTO1FBQ2hFO1FBQ0EsS0FBSyxDQUFDdWQsVUFBVS8yQjtRQUNoQixJQUFJMGhHLGdCQUFnQjtZQUNsQixJQUFJLENBQUNuNUUsTUFBTTtRQUNiO0lBQ0Y7SUFDQSxDQUFDazVFLGNBQWM7UUFDYixJQUFJLElBQUksQ0FBQytCLE9BQU8sS0FBSyxRQUFRLENBQUMsSUFBSSxDQUFDeGpHLE1BQU0sRUFBRTtZQUN6QztRQUNGO1FBQ0EsSUFBSSxDQUFDQSxNQUFNLENBQUN1Z0csU0FBUyxDQUFDejlILE1BQU0sQ0FBQyxJQUFJLENBQUMwZ0ksT0FBTztRQUN6QyxJQUFJLENBQUNBLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0ssZUFBZSxDQUFDenpELEtBQUs7SUFDNUI7SUFDQSxDQUFDOHZELGNBQWMsQ0FBQ2xnRyxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUNsQyxJQUFJLElBQUksQ0FBQ3dqRyxPQUFPLEtBQUssUUFBUSxJQUFJLENBQUN4akcsTUFBTSxLQUFLQSxRQUFRO1lBQ25EO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQ3dqRyxPQUFPLEtBQUssTUFBTTtZQUN6QixJQUFJLENBQUN4akcsTUFBTSxDQUFDdWdHLFNBQVMsQ0FBQzZFLFlBQVksQ0FBQyxJQUFJLENBQUM1QixPQUFPLEVBQUV4akcsT0FBT3VnRyxTQUFTO1lBQ2pFO1FBQ0Y7UUFDQSxJQUFJLENBQUNzRCxlQUFlLENBQUNuQixTQUFTO1FBQzlCLElBQUksQ0FBQ2MsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDTyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUNuQixZQUFZLEVBQUU1aUc7SUFDekQ7SUFDQSxDQUFDcWxHLG9CQUFvQixDQUFDLENBQUNoeEksR0FBRzBNLEdBQUc4aEMsT0FBT0MsT0FBTztRQUN6QyxNQUFNLEVBQ0owc0Isa0JBQWtCLENBQUM4MUUsSUFBSUMsR0FBRyxFQUMxQnRqRyxRQUFRLEVBQ1QsR0FBRyxJQUFJO1FBQ1IsT0FBUUE7WUFDTixLQUFLO2dCQUNILE9BQU87b0JBQUNsaEM7b0JBQUcsSUFBSTFNO29CQUFHd3VDLFFBQVMwaUcsQ0FBQUEsS0FBS0QsRUFBQztvQkFBSXhpRyxTQUFVd2lHLENBQUFBLEtBQUtDLEVBQUM7aUJBQUc7WUFDMUQsS0FBSztnQkFDSCxPQUFPO29CQUFDLElBQUlseEk7b0JBQUcsSUFBSTBNO29CQUFHOGhDO29CQUFPQztpQkFBTztZQUN0QyxLQUFLO2dCQUNILE9BQU87b0JBQUMsSUFBSS9oQztvQkFBRzFNO29CQUFHd3VDLFFBQVMwaUcsQ0FBQUEsS0FBS0QsRUFBQztvQkFBSXhpRyxTQUFVd2lHLENBQUFBLEtBQUtDLEVBQUM7aUJBQUc7WUFDMUQ7Z0JBQ0UsT0FBTztvQkFBQ2x4STtvQkFBRzBNO29CQUFHOGhDO29CQUFPQztpQkFBTztRQUNoQztJQUNGO0lBQ0EsQ0FBQytoRyxrQkFBa0I7UUFDakIsTUFBTSxFQUNKeHdJLENBQUMsRUFDRDBNLENBQUMsRUFDRDhoQyxLQUFLLEVBQ0xDLE1BQU0sRUFDTjBzQixrQkFBa0IsQ0FBQzgxRSxJQUFJQyxHQUFHLEVBQzFCdGpHLFFBQVEsRUFDVCxHQUFHLElBQUk7UUFDUixPQUFRQTtZQUNOLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQyxJQUFJbGhDO29CQUFHMU07b0JBQUd3dUMsUUFBU3lpRyxDQUFBQSxLQUFLQyxFQUFDO29CQUFJemlHLFNBQVV5aUcsQ0FBQUEsS0FBS0QsRUFBQztpQkFBRztZQUMxRCxLQUFLO2dCQUNILE9BQU87b0JBQUMsSUFBSWp4STtvQkFBRyxJQUFJME07b0JBQUc4aEM7b0JBQU9DO2lCQUFPO1lBQ3RDLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQy9oQztvQkFBRyxJQUFJMU07b0JBQUd3dUMsUUFBU3lpRyxDQUFBQSxLQUFLQyxFQUFDO29CQUFJemlHLFNBQVV5aUcsQ0FBQUEsS0FBS0QsRUFBQztpQkFBRztZQUMxRDtnQkFDRSxPQUFPO29CQUFDanhJO29CQUFHME07b0JBQUc4aEM7b0JBQU9DO2lCQUFPO1FBQ2hDO0lBQ0Y7SUFDQSxDQUFDa2hHLFVBQVUsQ0FBQ241RCxJQUFJO1FBQ2QsQ0FBQyxJQUFJLENBQUN4MkUsQ0FBQyxFQUFFLElBQUksQ0FBQzBNLENBQUMsRUFBRSxJQUFJLENBQUM4aEMsS0FBSyxFQUFFLElBQUksQ0FBQ0MsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUN1aUcsb0JBQW9CLENBQUN4NkQ7UUFDdkUsSUFBSSxJQUFJLENBQUNqckMsR0FBRyxFQUFFO1lBQ1osSUFBSSxDQUFDZzNCLGlCQUFpQjtZQUN0QixJQUFJLENBQUNrQyxPQUFPO1FBQ2Q7UUFDQSxJQUFJLENBQUNnQixVQUFVO0lBQ2pCO0lBQ0EsQ0FBQ2dyRSxTQUFTO1FBQ1IsTUFBTSxFQUNKendJLENBQUMsRUFDRDBNLENBQUMsRUFDRDhoQyxLQUFLLEVBQ0xDLE1BQU0sRUFDTmIsUUFBUSxFQUNSMDBCLGNBQWMsRUFDZG5ILGtCQUFrQixDQUFDODFFLElBQUlDLEdBQUcsRUFDM0IsR0FBRyxJQUFJO1FBQ1IsT0FBUSxDQUFDdGpHLFdBQVcsSUFBSTAwQixjQUFhLElBQUs7WUFDeEMsS0FBSztnQkFDSCxPQUFPO29CQUFDLElBQUk1MUQsSUFBSStoQztvQkFBUXp1QztvQkFBR3l1QztvQkFBUUQ7aUJBQU07WUFDM0MsS0FBSztnQkFDSCxPQUFPO29CQUFDLElBQUl4dUMsSUFBSXd1QztvQkFBTyxJQUFJOWhDLElBQUkraEM7b0JBQVFEO29CQUFPQztpQkFBTztZQUN2RCxLQUFLO2dCQUNILE9BQU87b0JBQUMvaEM7b0JBQUcsSUFBSTFNLElBQUl3dUM7b0JBQU9DO29CQUFRRDtpQkFBTTtZQUMxQyxLQUFLO2dCQUNILE9BQU87b0JBQUN4dUM7b0JBQUcwTSxJQUFJOGhDLFFBQVN5aUcsQ0FBQUEsS0FBS0MsRUFBQztvQkFBSXppRyxTQUFVeWlHLENBQUFBLEtBQUtELEVBQUM7b0JBQUl6aUcsUUFBU3lpRyxDQUFBQSxLQUFLQyxFQUFDO2lCQUFHO1lBQzFFLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQyxJQUFJeGtJO29CQUFHMU07b0JBQUd3dUMsUUFBU3lpRyxDQUFBQSxLQUFLQyxFQUFDO29CQUFJemlHLFNBQVV5aUcsQ0FBQUEsS0FBS0QsRUFBQztpQkFBRztZQUMxRCxLQUFLO2dCQUNILE9BQU87b0JBQUMsSUFBSWp4SSxJQUFJeXVDLFNBQVV5aUcsQ0FBQUEsS0FBS0QsRUFBQztvQkFBSSxJQUFJdmtJO29CQUFHK2hDLFNBQVV5aUcsQ0FBQUEsS0FBS0QsRUFBQztvQkFBSXppRyxRQUFTeWlHLENBQUFBLEtBQUtDLEVBQUM7aUJBQUc7WUFDbkYsS0FBSztnQkFDSCxPQUFPO29CQUFDeGtJLElBQUk4aEMsUUFBU3lpRyxDQUFBQSxLQUFLQyxFQUFDO29CQUFJLElBQUlseEksSUFBSXl1QyxTQUFVeWlHLENBQUFBLEtBQUtELEVBQUM7b0JBQUl6aUcsUUFBU3lpRyxDQUFBQSxLQUFLQyxFQUFDO29CQUFJemlHLFNBQVV5aUcsQ0FBQUEsS0FBS0QsRUFBQztpQkFBRztZQUNuRyxLQUFLO2dCQUNILE9BQU87b0JBQUNqeEksSUFBSXd1QztvQkFBTzloQyxJQUFJK2hDO29CQUFRRDtvQkFBT0M7aUJBQU87WUFDL0MsS0FBSztnQkFDSCxPQUFPO29CQUFDLElBQUkvaEM7b0JBQUcxTSxJQUFJd3VDO29CQUFPQztvQkFBUUQ7aUJBQU07WUFDMUMsS0FBSztnQkFDSCxPQUFPO29CQUFDLElBQUl4dUM7b0JBQUcsSUFBSTBNO29CQUFHOGhDO29CQUFPQztpQkFBTztZQUN0QyxLQUFLO2dCQUNILE9BQU87b0JBQUMvaEMsSUFBSStoQztvQkFBUSxJQUFJenVDO29CQUFHeXVDO29CQUFRRDtpQkFBTTtZQUMzQyxLQUFLO2dCQUNILE9BQU87b0JBQUN4dUMsSUFBSXl1QyxTQUFVeWlHLENBQUFBLEtBQUtELEVBQUM7b0JBQUl2a0k7b0JBQUcraEMsU0FBVXlpRyxDQUFBQSxLQUFLRCxFQUFDO29CQUFJemlHLFFBQVN5aUcsQ0FBQUEsS0FBS0MsRUFBQztpQkFBRztZQUMzRSxLQUFLO2dCQUNILE9BQU87b0JBQUMsSUFBSXhrSSxJQUFJOGhDLFFBQVN5aUcsQ0FBQUEsS0FBS0MsRUFBQztvQkFBSWx4SSxJQUFJeXVDLFNBQVV5aUcsQ0FBQUEsS0FBS0QsRUFBQztvQkFBSXppRyxRQUFTeWlHLENBQUFBLEtBQUtDLEVBQUM7b0JBQUl6aUcsU0FBVXlpRyxDQUFBQSxLQUFLRCxFQUFDO2lCQUFHO1lBQ25HLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQyxJQUFJanhJO29CQUFHLElBQUkwTSxJQUFJOGhDLFFBQVN5aUcsQ0FBQUEsS0FBS0MsRUFBQztvQkFBSXppRyxTQUFVeWlHLENBQUFBLEtBQUtELEVBQUM7b0JBQUl6aUcsUUFBU3lpRyxDQUFBQSxLQUFLQyxFQUFDO2lCQUFHO1lBQ2xGLEtBQUs7Z0JBQ0gsT0FBTztvQkFBQ3hrSTtvQkFBRyxJQUFJMU07b0JBQUd3dUMsUUFBU3lpRyxDQUFBQSxLQUFLQyxFQUFDO29CQUFJemlHLFNBQVV5aUcsQ0FBQUEsS0FBS0QsRUFBQztpQkFBRztZQUMxRDtnQkFDRSxPQUFPO29CQUFDanhJO29CQUFHME07b0JBQUc4aEM7b0JBQU9DO2lCQUFPO1FBQ2hDO0lBQ0Y7SUFDQXE5QixTQUFTO1FBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQ25nQyxNQUFNLEVBQUU7WUFDaEI7UUFDRjtRQUNBLElBQUksQ0FBQ0EsTUFBTSxDQUFDdWdHLFNBQVMsQ0FBQ00sZ0JBQWdCLENBQUMsSUFBSSxDQUFDMkMsT0FBTyxFQUFFYixjQUFjc0IsbUJBQW1CLENBQUM7WUFDckZwNUQsTUFBTSxJQUFJLENBQUMsQ0FBQ2k2RCxTQUFTO1FBQ3ZCLEdBQUcsSUFBSSxDQUFDLENBQUNsQyxZQUFZLENBQUM0QyxjQUFjLENBQUMsQ0FBQyxJQUFJLENBQUM3dUUsY0FBYyxHQUFHLElBQUksQ0FBQzEwQixRQUFRLEdBQUcsR0FBRSxJQUFLO0lBQ3JGO0lBQ0FrWixrQkFBa0I7UUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQ25iLE1BQU0sRUFBRTtZQUNoQjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNna0csVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDcEIsWUFBWSxDQUFDNkMsc0JBQXNCLENBQUMsSUFBSSxDQUFDajJFLGdCQUFnQixFQUFFLElBQUksQ0FBQ3h2QixNQUFNLENBQUNnQyxLQUFLO0lBQ3JHO0lBQ0EsT0FBTzBqRyw2QkFBNkIsQ0FBQztJQUNyQ3JtRyxTQUFTO1FBQ1AsSUFBSSxJQUFJLENBQUNPLEdBQUcsRUFBRTtZQUNaLE9BQU8sSUFBSSxDQUFDQSxHQUFHO1FBQ2pCO1FBQ0EsSUFBSTQzQixPQUFPQztRQUNYLElBQUksSUFBSSxDQUFDaEQsT0FBTyxFQUFFO1lBQ2hCK0MsUUFBUSxJQUFJLENBQUNuakUsQ0FBQztZQUNkb2pFLFFBQVEsSUFBSSxDQUFDMTJELENBQUM7UUFDaEI7UUFDQSxNQUFNNitCLE1BQU0sS0FBSyxDQUFDUDtRQUNsQk8sSUFBSStKLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7UUFDbEIsTUFBTW9pSSxVQUFVbHFJLFNBQVMySSxhQUFhLENBQUM7UUFDdkN3N0IsSUFBSXA0QixNQUFNLENBQUNtK0g7UUFDWEEsUUFBUXRuRyxZQUFZLENBQUMsZUFBZTtRQUNwQ3NuRyxRQUFRbjZGLFNBQVMsR0FBRztRQUNwQixJQUFJLENBQUNzdEIsT0FBTztRQUNaLElBQUksQ0FBQ2pyQixVQUFVLENBQUM4UixnQkFBZ0IsQ0FBQyxJQUFJO1FBQ3JDLElBQUksQ0FBQzhoQixjQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDaE4sT0FBTyxFQUFFO1lBQ2hCLElBQUksQ0FBQzhDLGVBQWUsQ0FBQ0MsT0FBT0M7UUFDOUI7UUFDQSxPQUFPNzNCO0lBQ1Q7SUFDQSxPQUFPZ21HLHFCQUFxQlosRUFBRSxFQUFFQyxFQUFFLEVBQUVZLFlBQVksRUFBRUMsYUFBYSxFQUFFekwsU0FBUyxFQUFFO1FBQzFFbnFHLFlBQVk7SUFDZDtJQUNBLE9BQU82MUcsYUFBYS9sRyxNQUFNLEVBQUUwUSxTQUFTLEVBQUVzMUYsTUFBTSxFQUFFOW5HLEtBQUssRUFBRTtRQUNwRCxNQUFNLEVBQ0pod0MsTUFBTSxFQUNOZzBDLFNBQVM3dEMsQ0FBQyxFQUNWOHRDLFNBQVNwaEMsQ0FBQyxFQUNWaytELFNBQVMsRUFDVHBPLFdBQVcsRUFDWixHQUFHM3lCO1FBQ0osSUFBSXlrRyxjQUFjLENBQUNTLGtCQUFrQixJQUFJVCxjQUFjLENBQUNTLGtCQUFrQixLQUFLdnlFLGFBQWE7WUFDMUY7UUFDRjtRQUNBLE1BQU0sRUFDSmh4QixVQUFVLEVBQ1JvQyxRQUFRLEVBQ1QsRUFDRixHQUFHakM7UUFDSixNQUFNLEVBQ0o2QyxPQUFPZ29CLFdBQVcsRUFDbEIvbkIsUUFBUWdvQixZQUFZLEVBQ3JCLEdBQUc1OEQsT0FBT3V4RCxxQkFBcUI7UUFDaEMsTUFBTWxqQixLQUFLb21HLGNBQWMsQ0FBQ00sZ0JBQWdCLEdBQUcsSUFBSXptRztRQUNqRCxNQUFNQyxTQUFTdUQsT0FBT2tjLGNBQWMsQ0FBQzNmO1FBQ3JDb21HLGNBQWMsQ0FBQ1EsZ0JBQWdCLEtBQUtsa0U7UUFDcEMwakUsY0FBYyxDQUFDUyxrQkFBa0IsS0FBS3Z5RTtRQUN0QzNyRCxPQUFPMjNCLGdCQUFnQixDQUFDLGFBQWEzNUIsQ0FBQUE7WUFDbkMsSUFBSXkvSCxjQUFjLENBQUNRLGdCQUFnQixLQUFLamdJLEVBQUUrN0QsU0FBUyxFQUFFO2dCQUNuRCxJQUFJLENBQUNnbkUsUUFBUSxDQUFDL2lJO1lBQ2hCLE9BQU87Z0JBQ0x5L0gsY0FBYyxDQUFDVSxpQkFBaUIsRUFBRW4wRixPQUFPaHNDLEVBQUUrN0QsU0FBUztZQUN0RDtRQUNGLEdBQUc7WUFDRHhpQztRQUNGO1FBQ0F2M0IsT0FBTzIzQixnQkFBZ0IsQ0FBQyxpQkFBaUIzNUIsQ0FBQUE7WUFDdkMsSUFBSXkvSCxjQUFjLENBQUNRLGdCQUFnQixLQUFLamdJLEVBQUUrN0QsU0FBUyxFQUFFO2dCQUNuRCxJQUFJLENBQUM4akUsY0FBYyxDQUFDcDZFLGlCQUFpQjtZQUN2QyxPQUFPO2dCQUNMZzZFLGNBQWMsQ0FBQ1UsaUJBQWlCLEVBQUVuMEYsT0FBT2hzQyxFQUFFKzdELFNBQVM7WUFDdEQ7UUFDRixHQUFHO1lBQ0R4aUM7UUFDRjtRQUNBdjNCLE9BQU8yM0IsZ0JBQWdCLENBQUMsZUFBZTM1QixDQUFBQTtZQUNyQyxJQUFJeS9ILGNBQWMsQ0FBQ1Msa0JBQWtCLEtBQUtsZ0ksRUFBRTJ0RCxXQUFXLEVBQUU7Z0JBQ3ZEO1lBQ0Y7WUFDQzh4RSxDQUFBQSxjQUFjLENBQUNVLGlCQUFpQixLQUFLLElBQUkzOUgsS0FBSSxFQUFHbkMsR0FBRyxDQUFDTCxFQUFFKzdELFNBQVM7WUFDaEUsSUFBSTBqRSxjQUFjLENBQUNLLFdBQVcsQ0FBQ2tELGFBQWEsSUFBSTtnQkFDOUN2RCxjQUFjLENBQUNLLFdBQVcsQ0FBQ21ELGlCQUFpQjtnQkFDNUMsSUFBSXhELGNBQWMsQ0FBQ0ssV0FBVyxDQUFDcG9GLE9BQU8sSUFBSTtvQkFDeEMsSUFBSSxDQUFDbW9GLGNBQWMsQ0FBQ3A2RSxpQkFBaUIsQ0FBQztnQkFDeEMsT0FBTztvQkFDTCxJQUFJLENBQUNzOUUsUUFBUSxDQUFDO2dCQUNoQjtZQUNGO1FBQ0YsR0FBRztZQUNEeDNGLFNBQVM7WUFDVCtoQixTQUFTO1lBQ1QvekI7UUFDRjtRQUNBdjNCLE9BQU8yM0IsZ0JBQWdCLENBQUMsZUFBZXVJLGVBQWU7WUFDcEQzSTtRQUNGO1FBQ0F2dUMsT0FBTzJ1QyxnQkFBZ0IsQ0FBQyxlQUFlLElBQUksQ0FBQ3VwRyxTQUFTLENBQUMzeUksSUFBSSxDQUFDLElBQUksR0FBRztZQUNoRWdwQztRQUNGO1FBQ0F2dUMsT0FBTzJ1QyxnQkFBZ0IsQ0FBQyxhQUFhMzVCLENBQUFBO1lBQ25DLElBQUlBLEVBQUVtakksU0FBUyxLQUFLMUQsY0FBYyxDQUFDVyxvQkFBb0IsRUFBRTtnQkFDdkRoK0YsVUFBVXBpQztZQUNaO1FBQ0YsR0FBRztZQUNEdTVCO1FBQ0Y7UUFDQXVELE9BQU9raUIsYUFBYTtRQUNwQnhSLFVBQVVnSyxjQUFjLEVBQUVoTTtRQUMxQixJQUFJaTBGLGNBQWMsQ0FBQ0ssV0FBVyxFQUFFO1lBQzlCaGpHLE9BQU91Z0csU0FBUyxDQUFDTSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNpQyxjQUFjLEVBQUVILGNBQWMsQ0FBQ0ssV0FBVyxDQUFDc0QsUUFBUSxDQUFDanlJLEdBQUcwTSxHQUFHOHBELGFBQWFDLGNBQWM3b0I7WUFDNUg7UUFDRjtRQUNBeU8sVUFBVTJYLDRCQUE0QixDQUFDLElBQUk7UUFDM0NzNkUsY0FBYyxDQUFDSyxXQUFXLEdBQUcsSUFBSSxDQUFDNEMsb0JBQW9CLENBQUN2eEksR0FBRzBNLEdBQUc4cEQsYUFBYUMsY0FBYzdvQjtRQUN4RjBnRyxjQUFjLENBQUNPLHFCQUFxQixHQUFHLElBQUksQ0FBQ2tCLHdCQUF3QjtRQUNwRSxJQUFJLENBQUNyQixjQUFjLEdBQUcvaUc7UUFDckIsR0FDQzM5QixJQUFJLElBQUksQ0FBQ3lnSSxjQUFjLEVBQ3hCLEdBQUc5aUcsT0FBT3VnRyxTQUFTLENBQUNvQixJQUFJLENBQUMsSUFBSSxDQUFDc0MsbUJBQW1CLENBQUN0QixjQUFjLENBQUNPLHFCQUFxQixDQUFDVCxlQUFlLElBQUlFLGNBQWMsQ0FBQ0ssV0FBVyxDQUFDa0Isb0JBQW9CLEdBQUcsTUFBTSxNQUFLO0lBQzFLO0lBQ0EsT0FBT2tDLFVBQVVsb0csS0FBSyxFQUFFO1FBQ3RCeWtHLGNBQWMsQ0FBQ1csb0JBQW9CLEdBQUcsQ0FBQztRQUN2QyxJQUFJLENBQUNYLGNBQWMsQ0FBQ0ssV0FBVyxFQUFFO1lBQy9CO1FBQ0Y7UUFDQSxNQUFNLEVBQ0o5Z0csT0FBTyxFQUNQQyxPQUFPLEVBQ1A4OEIsU0FBUyxFQUNWLEdBQUcvZ0M7UUFDSixJQUFJeWtHLGNBQWMsQ0FBQ1EsZ0JBQWdCLEtBQUtsa0UsV0FBVztZQUNqRDtRQUNGO1FBQ0EsSUFBSTBqRSxjQUFjLENBQUNVLGlCQUFpQixFQUFFM2dJLFFBQVEsR0FBRztZQUMvQyxJQUFJLENBQUN1akksUUFBUSxDQUFDL25HO1lBQ2Q7UUFDRjtRQUNBLElBQUksQ0FBQzZrRyxjQUFjLENBQUN4QyxTQUFTLENBQUNNLGdCQUFnQixDQUFDLElBQUksQ0FBQ2lDLGNBQWMsRUFBRUgsY0FBYyxDQUFDSyxXQUFXLENBQUN6L0gsR0FBRyxDQUFDMitCLFNBQVNDO1FBQzVHd2dHLGNBQWMsQ0FBQ1csb0JBQW9CLEdBQUdwbEcsTUFBTW1vRyxTQUFTO1FBQ3JEL2dHLFVBQVVwSDtJQUNaO0lBQ0EsT0FBT3FvRyxTQUFTdjdILEdBQUcsRUFBRTtRQUNuQixJQUFJQSxLQUFLO1lBQ1AsSUFBSSxDQUFDODNILGNBQWMsR0FBRyxDQUFDO1lBQ3ZCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1lBQ3RCSixjQUFjLENBQUNLLFdBQVcsR0FBRztZQUM3QkwsY0FBYyxDQUFDTyxxQkFBcUIsR0FBRztZQUN2Q1AsY0FBYyxDQUFDUyxrQkFBa0IsR0FBRztZQUNwQ1QsY0FBYyxDQUFDVyxvQkFBb0IsR0FBR3RqSTtRQUN4QztRQUNBLElBQUkyaUksY0FBYyxDQUFDTSxnQkFBZ0IsRUFBRTtZQUNuQ04sY0FBYyxDQUFDTSxnQkFBZ0IsQ0FBQ3RtRyxLQUFLO1lBQ3JDZ21HLGNBQWMsQ0FBQ00sZ0JBQWdCLEdBQUc7WUFDbENOLGNBQWMsQ0FBQ1EsZ0JBQWdCLEdBQUduakk7WUFDbEMyaUksY0FBYyxDQUFDVSxpQkFBaUIsR0FBRztRQUNyQztJQUNGO0lBQ0EsT0FBTzRDLFNBQVMvbkcsS0FBSyxFQUFFO1FBQ3JCLE1BQU04QixTQUFTLElBQUksQ0FBQytpRyxjQUFjO1FBQ2xDLElBQUksQ0FBQy9pRyxRQUFRO1lBQ1g7UUFDRjtRQUNBQSxPQUFPa2lCLGFBQWEsQ0FBQztRQUNyQixJQUFJLENBQUNxa0YsUUFBUSxDQUFDO1FBQ2QsSUFBSXJvRyxPQUFPaHdDLFdBQVc4eEMsT0FBT0osR0FBRyxFQUFFO1lBQ2hDSSxPQUFPdWdHLFNBQVMsQ0FBQ00sZ0JBQWdCLENBQUMsSUFBSSxDQUFDaUMsY0FBYyxFQUFFSCxjQUFjLENBQUNLLFdBQVcsQ0FBQzlySCxHQUFHLENBQUNnbkIsTUFBTWdFLE9BQU8sRUFBRWhFLE1BQU1pRSxPQUFPO1FBQ3BIO1FBQ0EsSUFBSSxJQUFJLENBQUNvaUcsdUJBQXVCLEVBQUU7WUFDaEMsTUFBTTVDLE9BQU9nQixjQUFjLENBQUNLLFdBQVc7WUFDdkMsTUFBTVcsU0FBUyxJQUFJLENBQUNiLGNBQWM7WUFDbEMsTUFBTTBELGNBQWM3RSxLQUFLOEUsY0FBYztZQUN2Q3ptRyxPQUFPaWtCLFdBQVcsQ0FBQztnQkFDakJ2UCxLQUFLO29CQUNIMVUsT0FBT3VnRyxTQUFTLENBQUNNLGdCQUFnQixDQUFDOEMsUUFBUWhDLEtBQUsrRSxjQUFjLENBQUNGO2dCQUNoRTtnQkFDQTd4RixNQUFNO29CQUNKM1UsT0FBT3VnRyxTQUFTLENBQUNNLGdCQUFnQixDQUFDOEMsUUFBUWhDLEtBQUt3RSxpQkFBaUI7Z0JBQ2xFO2dCQUNBdHhGLFVBQVU7Z0JBQ1Z4K0MsTUFBTThyQiwyQkFBMkJhLFNBQVM7WUFDNUM7WUFDQTtRQUNGO1FBQ0EsSUFBSSxDQUFDa2dFLFVBQVUsQ0FBQztJQUNsQjtJQUNBLE9BQU9BLFdBQVd5akQsU0FBUyxFQUFFO1FBQzNCLE1BQU0zbUcsU0FBUyxJQUFJLENBQUMraUcsY0FBYztRQUNsQyxJQUFJLENBQUMvaUcsUUFBUTtZQUNYLE9BQU87UUFDVDtRQUNBQSxPQUFPa2lCLGFBQWEsQ0FBQztRQUNyQmxpQixPQUFPeW9CLGNBQWMsQ0FBQ3RtQywyQkFBMkJhLFNBQVM7UUFDMUQsSUFBSSxDQUFDMi9HLGNBQWMsQ0FBQ0ssV0FBVyxDQUFDcG9GLE9BQU8sSUFBSTtZQUN6QyxNQUFNLEVBQ0p3YSxnQkFBZ0IsQ0FBQ255QixXQUFXQyxXQUFXLEVBQ3ZDbEIsS0FBSyxFQUNOLEdBQUdoQztZQUNKLE1BQU0rTSxTQUFTL00sT0FBT29oQixxQkFBcUIsQ0FBQztnQkFDMUNsZixTQUFTO2dCQUNUQyxTQUFTO1lBQ1gsR0FBRyxPQUFPO2dCQUNSd2hHLFFBQVEsSUFBSSxDQUFDYixjQUFjO2dCQUMzQkYsY0FBY0QsY0FBYyxDQUFDSyxXQUFXLENBQUN4RyxXQUFXLENBQUN2NUYsWUFBWWpCLE9BQU9rQixhQUFhbEIsT0FBT0EsT0FBTyxJQUFJLENBQUN1aEcsYUFBYTtnQkFDckhLLGdCQUFnQmpCLGNBQWMsQ0FBQ08scUJBQXFCO2dCQUNwREwsaUJBQWlCLENBQUM4RDtZQUNwQjtZQUNBLElBQUksQ0FBQ0osUUFBUSxDQUFDO1lBQ2QsT0FBT3g1RjtRQUNUO1FBQ0EvTSxPQUFPdWdHLFNBQVMsQ0FBQ3o5SCxNQUFNLENBQUMsSUFBSSxDQUFDZ2dJLGNBQWM7UUFDM0MsSUFBSSxDQUFDeUQsUUFBUSxDQUFDO1FBQ2QsT0FBTztJQUNUO0lBQ0FLLHFCQUFxQkMsS0FBSyxFQUFFLENBQUM7SUFDN0IsT0FBT0MsZ0JBQWdCQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRU4sS0FBSyxFQUFFO1FBQ2xGMzJHLFlBQVk7SUFDZDtJQUNBLGFBQWE0ekIsWUFBWTdsRCxJQUFJLEVBQUUraEMsTUFBTSxFQUFFMFEsU0FBUyxFQUFFO1FBQ2hELE1BQU0sRUFDSjNOLFNBQVMsRUFDUEUsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLEtBQUssRUFDTEMsS0FBSyxFQUNOLEVBQ0YsR0FBR3BELE9BQU9ILFFBQVE7UUFDbkIsTUFBTStpRyxlQUFlLElBQUksQ0FBQ2tFLGVBQWUsQ0FBQzNqRyxPQUFPQyxPQUFPSCxXQUFXQyxZQUFZLElBQUksQ0FBQ3FnRyxhQUFhLEVBQUV0bEk7UUFDbkcsTUFBTTh1QyxTQUFTLE1BQU0sS0FBSyxDQUFDK1csWUFBWTdsRCxNQUFNK2hDLFFBQVEwUTtRQUNyRDNELE9BQU82NUYsb0JBQW9CLENBQUMzb0k7UUFDNUI4dUMsT0FBTyxDQUFDMjJGLGtCQUFrQixDQUFDO1lBQ3pCZDtRQUNGO1FBQ0E3MUYsT0FBTyxDQUFDbXpGLGNBQWM7UUFDdEJuekYsT0FBT29PLGVBQWU7UUFDdEJwTyxPQUFPb3pCLE1BQU07UUFDYixPQUFPcHpCO0lBQ1Q7SUFDQXE2RixjQUFjajZFLFlBQVksRUFBRTtRQUMxQixNQUFNLENBQUNocUIsT0FBT0MsTUFBTSxHQUFHLElBQUksQ0FBQ2l5QixlQUFlO1FBQzNDLE1BQU0sQ0FBQ3B5QixXQUFXQyxXQUFXLEdBQUcsSUFBSSxDQUFDa3lCLGNBQWM7UUFDbkQsT0FBTyxJQUFJLENBQUMsQ0FBQ3d0RSxZQUFZLENBQUNudEYsU0FBUyxDQUFDO1lBQUN0UztZQUFPQztZQUFPSDtZQUFXQztTQUFXLEVBQUVpcUI7SUFDN0U7SUFDQWhDLHdCQUF3QmpGLFVBQVUsRUFBRTtRQUNsQ0EsV0FBV2tjLFlBQVksQ0FBQztZQUN0QjVzQyxNQUFNLElBQUksQ0FBQ2lxQyxVQUFVO1FBQ3ZCO1FBQ0EsT0FBTztJQUNUO0lBQ0EsT0FBT2haLDBCQUEwQjtRQUMvQixPQUFPO0lBQ1Q7QUFDRjtFQUVDLDBDQUEwQztBQVUzQyxNQUFNNGdGO0lBQ0osQ0FBQ3ZNLElBQUksQ0FBdUI7SUFDNUIsQ0FBQ2p2RixJQUFJLENBQUM7SUFDTixDQUFDRCxLQUFLLENBQUM7SUFDUCxDQUFDM0osUUFBUSxDQUFDO0lBQ1YsQ0FBQ3d5RixTQUFTLENBQUM7SUFDWCxDQUFDSCxNQUFNLENBQUM7SUFDUixDQUFDZ1QsV0FBVyxDQUFNO0lBQ2xCLENBQUNDLFNBQVMsQ0FBSztJQUNmLENBQUMvSSxRQUFRLENBQXdCO0lBQ2pDLENBQUMzekUsV0FBVyxDQUFDO0lBQ2IsQ0FBQ0MsWUFBWSxDQUFDO0lBQ2RoNkQsWUFBWXVELENBQUMsRUFBRTBNLENBQUMsRUFBRThwRCxXQUFXLEVBQUVDLFlBQVksRUFBRTdvQixRQUFRLEVBQUV3eUYsU0FBUyxDQUFFO2FBWGxFLENBQUNxRyxJQUFJLEdBQUcsSUFBSWx4SCxhQUFhO2FBTXpCLENBQUMwOUgsV0FBVyxHQUFHO2FBQ2YsQ0FBQ0MsU0FBUyxHQUFHO2FBQ2IsQ0FBQy9JLFFBQVEsR0FBRyxJQUFJZ0o7UUFJZCxJQUFJLENBQUMsQ0FBQzM4RSxXQUFXLEdBQUdBO1FBQ3BCLElBQUksQ0FBQyxDQUFDQyxZQUFZLEdBQUdBO1FBQ3JCLElBQUksQ0FBQyxDQUFDN29CLFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUN3eUYsU0FBUyxHQUFHQTtRQUNsQixDQUFDcGdJLEdBQUcwTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMwbUksY0FBYyxDQUFDcHpJLEdBQUcwTTtRQUNqQyxNQUFNOHFDLE9BQU8sSUFBSSxDQUFDLENBQUNBLElBQUksR0FBRztZQUFDN3JDO1lBQUtBO1lBQUtBO1lBQUtBO1lBQUszTDtZQUFHME07U0FBRTtRQUNwRCxJQUFJLENBQUMsQ0FBQ3V6SCxNQUFNLEdBQUc7WUFBQ2pnSTtZQUFHME07U0FBRTtRQUNyQixJQUFJLENBQUMsQ0FBQzZxQyxLQUFLLEdBQUc7WUFBQztnQkFDYkM7Z0JBQ0F5b0YsUUFBUSxJQUFJLENBQUMsQ0FBQ0EsTUFBTTtZQUN0QjtTQUFFO1FBQ0YsSUFBSSxDQUFDLENBQUN3RyxJQUFJLENBQUM3a0ksR0FBRyxDQUFDNDFDLE1BQU07SUFDdkI7SUFDQTAyRixlQUFlL3hJLElBQUksRUFBRTdCLEtBQUssRUFBRTtRQUMxQixJQUFJNkIsU0FBUyxnQkFBZ0I7WUFDM0IsSUFBSSxDQUFDLENBQUNpa0ksU0FBUyxHQUFHOWxJO1FBQ3BCO0lBQ0Y7SUFDQSxDQUFDODRJLGNBQWMsQ0FBQ3B6SSxDQUFDLEVBQUUwTSxDQUFDO1FBQ2xCLE9BQU9vNUgsUUFBUTNVLGVBQWUsQ0FBQ254SCxHQUFHME0sR0FBRyxJQUFJLENBQUMsQ0FBQzhwRCxXQUFXLEVBQUUsSUFBSSxDQUFDLENBQUNDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQzdvQixRQUFRO0lBQzVGO0lBQ0EyWSxVQUFVO1FBQ1IsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDaFAsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDQSxLQUFLLENBQUNsK0MsTUFBTSxLQUFLO0lBQ2hEO0lBQ0F3NEksZ0JBQWdCO1FBQ2QsT0FBTyxJQUFJLENBQUMsQ0FBQzVSLE1BQU0sQ0FBQzVtSSxNQUFNLElBQUk7SUFDaEM7SUFDQTZWLElBQUlsUCxDQUFDLEVBQUUwTSxDQUFDLEVBQUU7UUFDUixDQUFDMU0sR0FBRzBNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQzBtSSxjQUFjLENBQUNwekksR0FBRzBNO1FBQ2pDLE1BQU0sQ0FBQzYyQixJQUFJQyxJQUFJRSxJQUFJRSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM2aUcsSUFBSSxDQUFDMW9HLFFBQVEsQ0FBQyxHQUFHO1FBQ2hELE1BQU1tcEcsUUFBUWxuSSxJQUFJMGpDO1FBQ2xCLE1BQU15akcsUUFBUXo2SCxJQUFJazNCO1FBQ2xCLE1BQU1uWixJQUFJNXFCLEtBQUtxK0QsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDMUgsV0FBVyxHQUFHMHdFLE9BQU8sSUFBSSxDQUFDLENBQUN6d0UsWUFBWSxHQUFHMHdFO1FBQ3JFLElBQUkxOEcsS0FBSyxHQUFHO1lBQ1YsT0FBTztRQUNUO1FBQ0EsSUFBSSxDQUFDLENBQUN3MUcsTUFBTSxDQUFDMzdILElBQUksQ0FBQ3RFLEdBQUcwTTtRQUNyQixJQUFJdXFFLE1BQU0xekMsS0FBSztZQUNiLElBQUksQ0FBQyxDQUFDa2pHLElBQUksQ0FBQzdrSSxHQUFHLENBQUM7Z0JBQUM4aEM7Z0JBQUlFO2dCQUFJNWpDO2dCQUFHME07YUFBRSxFQUFFO1lBQy9CLElBQUksQ0FBQyxDQUFDOHFDLElBQUksQ0FBQ2x6QyxJQUFJLENBQUNxSCxLQUFLQSxLQUFLQSxLQUFLQSxLQUFLM0wsR0FBRzBNO1lBQ3ZDLE9BQU87Z0JBQ0xpcEUsTUFBTTtvQkFDSmxyRCxHQUFHLElBQUksQ0FBQ3M3RyxTQUFTO2dCQUNuQjtZQUNGO1FBQ0Y7UUFDQSxJQUFJOXVELE1BQU0sSUFBSSxDQUFDLENBQUN3dkQsSUFBSSxDQUFDLEVBQUUsR0FBRztZQUN4QixJQUFJLENBQUMsQ0FBQ2p2RixJQUFJLENBQUNtSixNQUFNLENBQUMsR0FBRztRQUN2QjtRQUNBLElBQUksQ0FBQyxDQUFDOGxGLElBQUksQ0FBQzdrSSxHQUFHLENBQUM7WUFBQzJoQztZQUFJQztZQUFJRTtZQUFJRTtZQUFJNWpDO1lBQUcwTTtTQUFFLEVBQUU7UUFDdkMsSUFBSSxDQUFDLENBQUM4cUMsSUFBSSxDQUFDbHpDLElBQUksSUFBSXdoSSxRQUFRUSxrQkFBa0IsQ0FBQy9pRyxJQUFJQyxJQUFJRSxJQUFJRSxJQUFJNWpDLEdBQUcwTTtRQUNqRSxPQUFPO1lBQ0xpcEUsTUFBTTtnQkFDSmxyRCxHQUFHLElBQUksQ0FBQ3M3RyxTQUFTO1lBQ25CO1FBQ0Y7SUFDRjtJQUNBbGpILElBQUk3aUIsQ0FBQyxFQUFFME0sQ0FBQyxFQUFFO1FBQ1IsTUFBTTh1SCxTQUFTLElBQUksQ0FBQ3RzSCxHQUFHLENBQUNsUCxHQUFHME07UUFDM0IsSUFBSTh1SCxRQUFRO1lBQ1YsT0FBT0E7UUFDVDtRQUNBLElBQUksSUFBSSxDQUFDLENBQUN5RSxNQUFNLENBQUM1bUksTUFBTSxLQUFLLEdBQUc7WUFDN0IsT0FBTztnQkFDTHM4RSxNQUFNO29CQUNKbHJELEdBQUcsSUFBSSxDQUFDczdHLFNBQVM7Z0JBQ25CO1lBQ0Y7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBa00sU0FBU2p5SSxDQUFDLEVBQUUwTSxDQUFDLEVBQUU4cEQsV0FBVyxFQUFFQyxZQUFZLEVBQUU3b0IsUUFBUSxFQUFFO1FBQ2xELElBQUksQ0FBQyxDQUFDNG9CLFdBQVcsR0FBR0E7UUFDcEIsSUFBSSxDQUFDLENBQUNDLFlBQVksR0FBR0E7UUFDckIsSUFBSSxDQUFDLENBQUM3b0IsUUFBUSxHQUFHQTtRQUNqQixDQUFDNXRDLEdBQUcwTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMwbUksY0FBYyxDQUFDcHpJLEdBQUcwTTtRQUNqQyxNQUFNOHFDLE9BQU8sSUFBSSxDQUFDLENBQUNBLElBQUksR0FBRztZQUFDN3JDO1lBQUtBO1lBQUtBO1lBQUtBO1lBQUszTDtZQUFHME07U0FBRTtRQUNwRCxJQUFJLENBQUMsQ0FBQ3V6SCxNQUFNLEdBQUc7WUFBQ2pnSTtZQUFHME07U0FBRTtRQUNyQixNQUFNKzVILE9BQU8sSUFBSSxDQUFDLENBQUNsdkYsS0FBSyxDQUFDbDFCLEVBQUUsQ0FBQyxDQUFDO1FBQzdCLElBQUlva0gsTUFBTTtZQUNSQSxLQUFLanZGLElBQUksR0FBRyxJQUFJbGlDLGFBQWFteEgsS0FBS2p2RixJQUFJO1lBQ3RDaXZGLEtBQUt4RyxNQUFNLEdBQUcsSUFBSTNxSCxhQUFhbXhILEtBQUt4RyxNQUFNO1FBQzVDO1FBQ0EsSUFBSSxDQUFDLENBQUMxb0YsS0FBSyxDQUFDanpDLElBQUksQ0FBQztZQUNma3pDO1lBQ0F5b0YsUUFBUSxJQUFJLENBQUMsQ0FBQ0EsTUFBTTtRQUN0QjtRQUNBLElBQUksQ0FBQyxDQUFDd0csSUFBSSxDQUFDN2tJLEdBQUcsQ0FBQzQxQyxNQUFNO1FBQ3JCLElBQUksQ0FBQyxDQUFDMDdGLFNBQVMsR0FBRztRQUNsQixJQUFJLENBQUNuTixTQUFTO1FBQ2QsT0FBTztJQUNUO0lBQ0FxTSxpQkFBaUI7UUFDZixPQUFPLElBQUksQ0FBQyxDQUFDNzZGLEtBQUssQ0FBQ2wxQixFQUFFLENBQUMsQ0FBQztJQUN6QjtJQUNBZ3dILGVBQWU3b0csT0FBTyxFQUFFO1FBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQytOLEtBQUssRUFBRTtZQUNoQixPQUFPLElBQUksQ0FBQyxDQUFDNHlGLFFBQVEsQ0FBQ2tJLGNBQWMsQ0FBQzdvRztRQUN2QztRQUNBLElBQUksQ0FBQyxDQUFDK04sS0FBSyxDQUFDanpDLElBQUksQ0FBQ2tsQztRQUNqQixJQUFJLENBQUMsQ0FBQ2dPLElBQUksR0FBR2hPLFFBQVFnTyxJQUFJO1FBQ3pCLElBQUksQ0FBQyxDQUFDeW9GLE1BQU0sR0FBR3oyRixRQUFReTJGLE1BQU07UUFDN0IsSUFBSSxDQUFDLENBQUNpVCxTQUFTLEdBQUc7UUFDbEIsT0FBTztZQUNMdjlELE1BQU07Z0JBQ0psckQsR0FBRyxJQUFJLENBQUNzN0csU0FBUztZQUNuQjtRQUNGO0lBQ0Y7SUFDQStMLG9CQUFvQjtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUN2NkYsS0FBSyxFQUFFO1lBQ2hCLE9BQU8sSUFBSSxDQUFDLENBQUM0eUYsUUFBUSxDQUFDMkgsaUJBQWlCO1FBQ3pDO1FBQ0EsSUFBSSxDQUFDLENBQUN2NkYsS0FBSyxDQUFDM0wsR0FBRztRQUNmLElBQUksQ0FBQyxDQUFDcW5HLFdBQVcsR0FBRztRQUNwQixJQUFLLElBQUlqMUksSUFBSSxHQUFHaW5DLEtBQUssSUFBSSxDQUFDLENBQUNzUyxLQUFLLENBQUNsK0MsTUFBTSxFQUFFMkUsSUFBSWluQyxJQUFJam5DLElBQUs7WUFDcEQsTUFBTSxFQUNKdzVDLElBQUksRUFDSnlvRixNQUFNLEVBQ1AsR0FBRyxJQUFJLENBQUMsQ0FBQzFvRixLQUFLLENBQUN2NUMsRUFBRTtZQUNsQixJQUFJLENBQUMsQ0FBQ3c1QyxJQUFJLEdBQUdBO1lBQ2IsSUFBSSxDQUFDLENBQUN5b0YsTUFBTSxHQUFHQTtZQUNmLElBQUksQ0FBQyxDQUFDaVQsU0FBUyxHQUFHO1lBQ2xCLElBQUksQ0FBQ25OLFNBQVM7UUFDaEI7UUFDQSxPQUFPO1lBQ0xwd0QsTUFBTTtnQkFDSmxyRCxHQUFHLElBQUksQ0FBQyxDQUFDd29ILFdBQVc7WUFDdEI7UUFDRjtJQUNGO0lBQ0FsTixZQUFZO1FBQ1YsTUFBTXNOLFNBQVN2TixRQUFRTSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM1dUYsSUFBSSxDQUFDLEVBQUU7UUFDN0MsTUFBTTg3RixTQUFTeE4sUUFBUU0sUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDNXVGLElBQUksQ0FBQyxFQUFFO1FBQzdDLElBQUksSUFBSSxDQUFDLENBQUN5b0YsTUFBTSxDQUFDNW1JLE1BQU0sS0FBSyxHQUFHO1lBQzdCLElBQUksQ0FBQyxDQUFDNDVJLFdBQVcsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUNBLFdBQVcsQ0FBQyxHQUFHLEVBQUVJLE9BQU8sQ0FBQyxFQUFFQyxPQUFPLEVBQUUsQ0FBQztZQUNsRSxPQUFPLElBQUksQ0FBQyxDQUFDTCxXQUFXO1FBQzFCO1FBQ0EsSUFBSSxJQUFJLENBQUMsQ0FBQ2hULE1BQU0sQ0FBQzVtSSxNQUFNLElBQUksR0FBRztZQUM1QixNQUFNMkUsSUFBSSxJQUFJLENBQUMsQ0FBQ2kxSSxXQUFXLENBQUNwakcsV0FBVyxDQUFDO1lBQ3hDLElBQUksQ0FBQyxDQUFDb2pHLFdBQVcsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUNBLFdBQVcsQ0FBQ3IzSSxLQUFLLENBQUMsR0FBR29DLEdBQUcsR0FBRyxFQUFFcTFJLE9BQU8sQ0FBQyxFQUFFQyxPQUFPLENBQUM7WUFDNUUsSUFBSSxDQUFDLENBQUNKLFNBQVMsR0FBRztRQUNwQjtRQUNBLElBQUksSUFBSSxDQUFDLENBQUNqVCxNQUFNLENBQUM1bUksTUFBTSxLQUFLLEdBQUc7WUFDN0IsTUFBTWs2SSxVQUFVek4sUUFBUU0sUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDNXVGLElBQUksQ0FBQyxHQUFHO1lBQy9DLE1BQU1nOEYsVUFBVTFOLFFBQVFNLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQzV1RixJQUFJLENBQUMsR0FBRztZQUMvQyxJQUFJLENBQUMsQ0FBQ3k3RixXQUFXLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDQSxXQUFXLENBQUMsR0FBRyxFQUFFTSxRQUFRLENBQUMsRUFBRUMsUUFBUSxDQUFDO1lBQ2xFLElBQUksQ0FBQyxDQUFDTixTQUFTLEdBQUc7WUFDbEIsT0FBTyxJQUFJLENBQUMsQ0FBQ0QsV0FBVztRQUMxQjtRQUNBLE1BQU1sMUksU0FBUyxFQUFFO1FBQ2pCLElBQUksSUFBSSxDQUFDLENBQUNtMUksU0FBUyxLQUFLLEdBQUc7WUFDekJuMUksT0FBT3VHLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSt1SSxPQUFPLENBQUMsRUFBRUMsT0FBTyxDQUFDO1lBQ25DLElBQUksQ0FBQyxDQUFDSixTQUFTLEdBQUc7UUFDcEI7UUFDQSxJQUFLLElBQUlsMUksSUFBSSxJQUFJLENBQUMsQ0FBQ2sxSSxTQUFTLEVBQUVqdUcsS0FBSyxJQUFJLENBQUMsQ0FBQ3VTLElBQUksQ0FBQ24rQyxNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsS0FBSyxFQUFHO1lBQ3BFLE1BQU0sQ0FBQ3kxSSxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLNXpJLEdBQUcwTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUM4cUMsSUFBSSxDQUFDNTdDLEtBQUssQ0FBQ29DLEdBQUdBLElBQUksR0FBR2tHLEdBQUcsQ0FBQzRoSSxRQUFRTSxRQUFRO1lBQ2xGcm9JLE9BQU91RyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUVtdkksSUFBSSxDQUFDLEVBQUVDLElBQUksQ0FBQyxFQUFFQyxJQUFJLENBQUMsRUFBRUMsSUFBSSxDQUFDLEVBQUU1ekksRUFBRSxDQUFDLEVBQUUwTSxFQUFFLENBQUM7UUFDdEQ7UUFDQSxJQUFJLENBQUMsQ0FBQ3VtSSxXQUFXLElBQUlsMUksT0FBT2pDLElBQUksQ0FBQztRQUNqQyxJQUFJLENBQUMsQ0FBQ28zSSxTQUFTLEdBQUcsSUFBSSxDQUFDLENBQUMxN0YsSUFBSSxDQUFDbitDLE1BQU07UUFDbkMsT0FBTyxJQUFJLENBQUMsQ0FBQzQ1SSxXQUFXO0lBQzFCO0lBQ0E5SyxZQUFZM3hFLFdBQVcsRUFBRUMsWUFBWSxFQUFFOW9CLEtBQUssRUFBRTY0RixXQUFXLEVBQUU7UUFDekQsTUFBTUMsT0FBTyxJQUFJLENBQUMsQ0FBQ2x2RixLQUFLLENBQUNsMUIsRUFBRSxDQUFDLENBQUM7UUFDN0Jva0gsS0FBS2p2RixJQUFJLEdBQUcsSUFBSWxpQyxhQUFhbXhILEtBQUtqdkYsSUFBSTtRQUN0Q2l2RixLQUFLeEcsTUFBTSxHQUFHLElBQUkzcUgsYUFBYW14SCxLQUFLeEcsTUFBTTtRQUMxQyxJQUFJLENBQUMsQ0FBQ2tLLFFBQVEsQ0FBQy9nQixLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM3eEUsS0FBSyxFQUFFaWYsYUFBYUMsY0FBYzlvQixPQUFPLElBQUksQ0FBQyxDQUFDQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUN3eUYsU0FBUyxFQUFFb0c7UUFDckcsSUFBSSxDQUFDLENBQUNDLElBQUksR0FBRztRQUNiLElBQUksQ0FBQyxDQUFDanZGLElBQUksR0FBRztRQUNiLElBQUksQ0FBQyxDQUFDRCxLQUFLLEdBQUc7UUFDZCxJQUFJLENBQUMsQ0FBQzA3RixXQUFXLEdBQUc7UUFDcEIsT0FBTyxJQUFJLENBQUMsQ0FBQzlJLFFBQVE7SUFDdkI7SUFDQSxJQUFJMEYsdUJBQXVCO1FBQ3pCLE9BQU87WUFDTDNySCxNQUFNO2dCQUNKdXBCLFNBQVM7WUFDWDtZQUNBNCtGLFdBQVc7Z0JBQ1RpQixNQUFNO1lBQ1I7WUFDQTkyRCxNQUFNO2dCQUFDO2dCQUFHO2dCQUFHO2dCQUFHO2FBQUU7UUFDcEI7SUFDRjtBQUNGO0FBQ0EsTUFBTTI4RCx1QkFBdUJyTjtJQUMzQixDQUFDdHZELElBQUksQ0FBQztJQUNOLENBQUNxOUQsZUFBZSxDQUFLO0lBQ3JCLENBQUNyTixXQUFXLENBQUM7SUFDYixDQUFDanZGLEtBQUssQ0FBQztJQUNQLENBQUNpZixXQUFXLENBQUM7SUFDYixDQUFDQyxZQUFZLENBQUM7SUFDZCxDQUFDK04sV0FBVyxDQUFDO0lBQ2IsQ0FBQzUyQixRQUFRLENBQUM7SUFDVixDQUFDd3lGLFNBQVMsQ0FBQztJQUNYaFgsTUFBTTd4RSxLQUFLLEVBQUVpZixXQUFXLEVBQUVDLFlBQVksRUFBRStOLFdBQVcsRUFBRTUyQixRQUFRLEVBQUV3eUYsU0FBUyxFQUFFb0csV0FBVyxFQUFFO1FBQ3JGLElBQUksQ0FBQyxDQUFDaHdFLFdBQVcsR0FBR0E7UUFDcEIsSUFBSSxDQUFDLENBQUNDLFlBQVksR0FBR0E7UUFDckIsSUFBSSxDQUFDLENBQUMrTixXQUFXLEdBQUdBO1FBQ3BCLElBQUksQ0FBQyxDQUFDNTJCLFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUN3eUYsU0FBUyxHQUFHQTtRQUNsQixJQUFJLENBQUMsQ0FBQ29HLFdBQVcsR0FBR0EsZUFBZTtRQUNuQyxJQUFJLENBQUMsQ0FBQ2p2RixLQUFLLEdBQUdBO1FBQ2QsSUFBSSxDQUFDLENBQUN1OEYsV0FBVztJQUNuQjtJQUNBLElBQUkxVCxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsU0FBUztJQUN4QjtJQUNBaVMsZUFBZTdvRyxPQUFPLEVBQUU7UUFDdEIsSUFBSSxDQUFDLENBQUMrTixLQUFLLENBQUNqekMsSUFBSSxDQUFDa2xDO1FBQ2pCLE9BQU87WUFDTG1zQyxNQUFNO2dCQUNKbHJELEdBQUcsSUFBSSxDQUFDczdHLFNBQVM7WUFDbkI7UUFDRjtJQUNGO0lBQ0ErTCxvQkFBb0I7UUFDbEIsSUFBSSxDQUFDLENBQUN2NkYsS0FBSyxDQUFDM0wsR0FBRztRQUNmLE9BQU87WUFDTCtwQyxNQUFNO2dCQUNKbHJELEdBQUcsSUFBSSxDQUFDczdHLFNBQVM7WUFDbkI7UUFDRjtJQUNGO0lBQ0FBLFlBQVk7UUFDVixNQUFNaG9JLFNBQVMsRUFBRTtRQUNqQixLQUFLLE1BQU0sRUFDVHk1QyxJQUFJLEVBQ0wsSUFBSSxJQUFJLENBQUMsQ0FBQ0QsS0FBSyxDQUFFO1lBQ2hCeDVDLE9BQU91RyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUV3aEksUUFBUU0sUUFBUSxDQUFDNXVGLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFc3VGLFFBQVFNLFFBQVEsQ0FBQzV1RixJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDeEUsSUFBSUEsS0FBS24rQyxNQUFNLEtBQUssR0FBRztnQkFDckIwRSxPQUFPdUcsSUFBSSxDQUFDO2dCQUNaO1lBQ0Y7WUFDQSxJQUFJa3pDLEtBQUtuK0MsTUFBTSxLQUFLLE1BQU00OUUsTUFBTXovQixJQUFJLENBQUMsRUFBRSxHQUFHO2dCQUN4Q3o1QyxPQUFPdUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFd2hJLFFBQVFNLFFBQVEsQ0FBQzV1RixJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRXN1RixRQUFRTSxRQUFRLENBQUM1dUYsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUMxRTtZQUNGO1lBQ0EsSUFBSyxJQUFJeDVDLElBQUksR0FBR2luQyxLQUFLdVMsS0FBS24rQyxNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsS0FBSyxFQUFHO2dCQUNoRCxNQUFNLENBQUN5MUksS0FBS0MsS0FBS0MsS0FBS0MsS0FBSzV6SSxHQUFHME0sRUFBRSxHQUFHOHFDLEtBQUt6WixRQUFRLENBQUMvL0IsR0FBR0EsSUFBSSxHQUFHa0csR0FBRyxDQUFDNGhJLFFBQVFNLFFBQVE7Z0JBQy9Fcm9JLE9BQU91RyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUVtdkksSUFBSSxDQUFDLEVBQUVDLElBQUksQ0FBQyxFQUFFQyxJQUFJLENBQUMsRUFBRUMsSUFBSSxDQUFDLEVBQUU1ekksRUFBRSxDQUFDLEVBQUUwTSxFQUFFLENBQUM7WUFDdEQ7UUFDRjtRQUNBLE9BQU8zTyxPQUFPakMsSUFBSSxDQUFDO0lBQ3JCO0lBQ0FzbEQsVUFBVSxDQUFDdFMsT0FBT0MsT0FBT0gsV0FBV0MsV0FBVyxFQUFFaXFCLFlBQVksRUFBRTtRQUM3RCxNQUFNaTdFLGtCQUFrQixFQUFFO1FBQzFCLE1BQU1DLG1CQUFtQixFQUFFO1FBQzNCLE1BQU0sQ0FBQ2gwSSxHQUFHME0sR0FBRzhoQyxPQUFPQyxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUN3bEcsbUJBQW1CO1FBQ3ZELElBQUl2K0UsSUFBSUMsSUFBSTdoQixJQUFJQyxJQUFJeFEsSUFBSUMsSUFBSUUsSUFBSUUsSUFBSXN3RztRQUNwQyxPQUFRLElBQUksQ0FBQyxDQUFDdG1HLFFBQVE7WUFDcEIsS0FBSztnQkFDSHNtRyxZQUFZcE8sUUFBUUcsUUFBUTtnQkFDNUJ2d0UsS0FBSzVtQjtnQkFDTDZtQixLQUFLNW1CLFFBQVFGO2dCQUNiaUYsS0FBS2xGO2dCQUNMbUYsS0FBSyxDQUFDbEY7Z0JBQ050TCxLQUFLdUwsUUFBUTl1QyxJQUFJNHVDO2dCQUNqQnBMLEtBQUt1TCxRQUFRLENBQUMsSUFBSXJpQyxJQUFJK2hDLE1BQUssSUFBS0k7Z0JBQ2hDbkwsS0FBS29MLFFBQVEsQ0FBQzl1QyxJQUFJd3VDLEtBQUksSUFBS0k7Z0JBQzNCaEwsS0FBS21MLFFBQVEsQ0FBQyxJQUFJcmlDLENBQUFBLElBQUttaUM7Z0JBQ3ZCO1lBQ0YsS0FBSztnQkFDSHFsRyxZQUFZcE8sUUFBUUksZUFBZTtnQkFDbkN4d0UsS0FBSzVtQjtnQkFDTDZtQixLQUFLNW1CO2dCQUNMK0UsS0FBS2xGO2dCQUNMbUYsS0FBS2xGO2dCQUNMdEwsS0FBS3VMLFFBQVFwaUMsSUFBSWtpQztnQkFDakJwTCxLQUFLdUwsUUFBUS91QyxJQUFJNnVDO2dCQUNqQm5MLEtBQUtvTCxRQUFRLENBQUNwaUMsSUFBSStoQyxNQUFLLElBQUtHO2dCQUM1QmhMLEtBQUttTCxRQUFRLENBQUMvdUMsSUFBSXd1QyxLQUFJLElBQUtLO2dCQUMzQjtZQUNGLEtBQUs7Z0JBQ0hxbEcsWUFBWXBPLFFBQVFHLFFBQVE7Z0JBQzVCdndFLEtBQUs1bUIsUUFBUUY7Z0JBQ2IrbUIsS0FBSzVtQjtnQkFDTCtFLEtBQUssQ0FBQ2xGO2dCQUNObUYsS0FBS2xGO2dCQUNMdEwsS0FBS3VMLFFBQVEsQ0FBQyxJQUFJOXVDLElBQUl3dUMsS0FBSSxJQUFLSTtnQkFDL0JwTCxLQUFLdUwsUUFBUXJpQyxJQUFJbWlDO2dCQUNqQm5MLEtBQUtvTCxRQUFRLENBQUMsSUFBSTl1QyxDQUFBQSxJQUFLNHVDO2dCQUN2QmhMLEtBQUttTCxRQUFRLENBQUNyaUMsSUFBSStoQyxNQUFLLElBQUtJO2dCQUM1QjtZQUNGLEtBQUs7Z0JBQ0hxbEcsWUFBWXBPLFFBQVFJLGVBQWU7Z0JBQ25DeHdFLEtBQUs1bUIsUUFBUUY7Z0JBQ2IrbUIsS0FBSzVtQixRQUFRRjtnQkFDYmlGLEtBQUssQ0FBQ2xGO2dCQUNObUYsS0FBSyxDQUFDbEY7Z0JBQ050TCxLQUFLdUwsUUFBUSxDQUFDLElBQUlwaUMsSUFBSStoQyxNQUFLLElBQUtHO2dCQUNoQ3BMLEtBQUt1TCxRQUFRLENBQUMsSUFBSS91QyxJQUFJd3VDLEtBQUksSUFBS0s7Z0JBQy9CbkwsS0FBS29MLFFBQVEsQ0FBQyxJQUFJcGlDLENBQUFBLElBQUtraUM7Z0JBQ3ZCaEwsS0FBS21MLFFBQVEsQ0FBQyxJQUFJL3VDLENBQUFBLElBQUs2dUM7Z0JBQ3ZCO1FBQ0o7UUFDQSxLQUFLLE1BQU0sRUFDVDJJLElBQUksRUFDSnlvRixNQUFNLEVBQ1AsSUFBSSxJQUFJLENBQUMsQ0FBQzFvRixLQUFLLENBQUU7WUFDaEJ3OEYsZ0JBQWdCenZJLElBQUksQ0FBQzR2SSxVQUFVMThGLE1BQU1rZSxJQUFJQyxJQUFJN2hCLElBQUlDLElBQUkra0IsZUFBZSxJQUFJMXRELE1BQU1vc0MsS0FBS24rQyxNQUFNLElBQUk7WUFDN0YyNkksaUJBQWlCMXZJLElBQUksQ0FBQzR2SSxVQUFValUsUUFBUXZxRSxJQUFJQyxJQUFJN2hCLElBQUlDLElBQUkra0IsZUFBZSxJQUFJMXRELE1BQU02MEgsT0FBTzVtSSxNQUFNLElBQUk7UUFDcEc7UUFDQSxPQUFPO1lBQ0xrK0MsT0FBT3c4RjtZQUNQOVQsUUFBUStUO1lBQ1I3eUcsTUFBTTtnQkFBQ29DO2dCQUFJQztnQkFBSUU7Z0JBQUlFO2FBQUc7UUFDeEI7SUFDRjtJQUNBLE9BQU82ckIsWUFBWTNnQixLQUFLLEVBQUVDLEtBQUssRUFBRUgsU0FBUyxFQUFFQyxVQUFVLEVBQUUyM0YsV0FBVyxFQUFFLEVBQ25FaG5DLE9BQU8sRUFDTGpvRCxLQUFLLEVBQ0wwb0YsTUFBTSxFQUNQLEVBQ0RyeUYsUUFBUSxFQUNSd3lGLFNBQVMsRUFDVixFQUFFO1FBQ0QsTUFBTStULFdBQVcsRUFBRTtRQUNuQixJQUFJeitFLElBQUlDLElBQUk3aEIsSUFBSUMsSUFBSW1nRztRQUNwQixPQUFRdG1HO1lBQ04sS0FBSztnQkFDSHNtRyxZQUFZcE8sUUFBUUcsUUFBUTtnQkFDNUJ2d0UsS0FBSyxDQUFDNW1CLFFBQVFGO2dCQUNkK21CLEtBQUs1bUIsUUFBUUYsYUFBYTtnQkFDMUJpRixLQUFLLElBQUlsRjtnQkFDVG1GLEtBQUssQ0FBQyxJQUFJbEY7Z0JBQ1Y7WUFDRixLQUFLO2dCQUNIcWxHLFlBQVlwTyxRQUFRSSxlQUFlO2dCQUNuQ3h3RSxLQUFLLENBQUMzbUIsUUFBUUY7Z0JBQ2Q4bUIsS0FBSyxDQUFDN21CLFFBQVFGO2dCQUNka0YsS0FBSyxJQUFJakY7Z0JBQ1RrRixLQUFLLElBQUluRjtnQkFDVDtZQUNGLEtBQUs7Z0JBQ0hzbEcsWUFBWXBPLFFBQVFHLFFBQVE7Z0JBQzVCdndFLEtBQUs1bUIsUUFBUUYsWUFBWTtnQkFDekIrbUIsS0FBSyxDQUFDNW1CLFFBQVFGO2dCQUNkaUYsS0FBSyxDQUFDLElBQUlsRjtnQkFDVm1GLEtBQUssSUFBSWxGO2dCQUNUO1lBQ0YsS0FBSztnQkFDSHFsRyxZQUFZcE8sUUFBUUksZUFBZTtnQkFDbkN4d0UsS0FBSzNtQixRQUFRRixhQUFhO2dCQUMxQjhtQixLQUFLN21CLFFBQVFGLFlBQVk7Z0JBQ3pCa0YsS0FBSyxDQUFDLElBQUlqRjtnQkFDVmtGLEtBQUssQ0FBQyxJQUFJbkY7Z0JBQ1Y7UUFDSjtRQUNBLElBQUksQ0FBQzJJLE9BQU87WUFDVkEsUUFBUSxFQUFFO1lBQ1YsS0FBSyxNQUFNaXZCLFNBQVN5NUQsT0FBUTtnQkFDMUIsTUFBTTV2SCxNQUFNbTJELE1BQU1udEUsTUFBTTtnQkFDeEIsSUFBSWdYLFFBQVEsR0FBRztvQkFDYmtuQyxNQUFNanpDLElBQUksQ0FBQyxJQUFJZ1IsYUFBYTt3QkFBQzNKO3dCQUFLQTt3QkFBS0E7d0JBQUtBO3dCQUFLNjZELEtBQUssQ0FBQyxFQUFFO3dCQUFFQSxLQUFLLENBQUMsRUFBRTtxQkFBQztvQkFDcEU7Z0JBQ0Y7Z0JBQ0EsSUFBSW4yRCxRQUFRLEdBQUc7b0JBQ2JrbkMsTUFBTWp6QyxJQUFJLENBQUMsSUFBSWdSLGFBQWE7d0JBQUMzSjt3QkFBS0E7d0JBQUtBO3dCQUFLQTt3QkFBSzY2RCxLQUFLLENBQUMsRUFBRTt3QkFBRUEsS0FBSyxDQUFDLEVBQUU7d0JBQUU3NkQ7d0JBQUtBO3dCQUFLQTt3QkFBS0E7d0JBQUs2NkQsS0FBSyxDQUFDLEVBQUU7d0JBQUVBLEtBQUssQ0FBQyxFQUFFO3FCQUFDO29CQUM1RztnQkFDRjtnQkFDQSxNQUFNaHZCLE9BQU8sSUFBSWxpQyxhQUFhLElBQUtqRixDQUFBQSxNQUFNO2dCQUN6Q2tuQyxNQUFNanpDLElBQUksQ0FBQ2t6QztnQkFDWCxJQUFJLENBQUNqVSxJQUFJQyxJQUFJRSxJQUFJRSxHQUFHLEdBQUc0aUMsTUFBTXpvQyxRQUFRLENBQUMsR0FBRztnQkFDekN5WixLQUFLNTFDLEdBQUcsQ0FBQztvQkFBQytKO29CQUFLQTtvQkFBS0E7b0JBQUtBO29CQUFLNDNCO29CQUFJQztpQkFBRyxFQUFFO2dCQUN2QyxJQUFLLElBQUl4bEMsSUFBSSxHQUFHQSxJQUFJcVMsS0FBS3JTLEtBQUssRUFBRztvQkFDL0IsTUFBTWdDLElBQUl3bUUsS0FBSyxDQUFDeG9FLEVBQUU7b0JBQ2xCLE1BQU0wTyxJQUFJODVELEtBQUssQ0FBQ3hvRSxJQUFJLEVBQUU7b0JBQ3RCdzVDLEtBQUs1MUMsR0FBRyxDQUFDa2tJLFFBQVFRLGtCQUFrQixDQUFDL2lHLElBQUlDLElBQUlFLElBQUlFLElBQUk1akMsR0FBRzBNLElBQUksQ0FBQzFPLElBQUksS0FBSztvQkFDckUsQ0FBQ3VsQyxJQUFJQyxJQUFJRSxJQUFJRSxHQUFHLEdBQUc7d0JBQUNGO3dCQUFJRTt3QkFBSTVqQzt3QkFBRzBNO3FCQUFFO2dCQUNuQztZQUNGO1FBQ0Y7UUFDQSxJQUFLLElBQUkxTyxJQUFJLEdBQUdpbkMsS0FBS3NTLE1BQU1sK0MsTUFBTSxFQUFFMkUsSUFBSWluQyxJQUFJam5DLElBQUs7WUFDOUNtMkksU0FBUzd2SSxJQUFJLENBQUM7Z0JBQ1prekMsTUFBTTA4RixVQUFVMzhGLEtBQUssQ0FBQ3Y1QyxFQUFFLENBQUNrRyxHQUFHLENBQUNsRSxDQUFBQSxJQUFLQSxLQUFLMkwsTUFBTStwRCxJQUFJQyxJQUFJN2hCLElBQUlDO2dCQUN6RGtzRixRQUFRaVUsVUFBVWpVLE1BQU0sQ0FBQ2ppSSxFQUFFLENBQUNrRyxHQUFHLENBQUNsRSxDQUFBQSxJQUFLQSxLQUFLMkwsTUFBTStwRCxJQUFJQyxJQUFJN2hCLElBQUlDO1lBQzlEO1FBQ0Y7UUFDQSxNQUFNbzJGLFdBQVcsSUFBSSxJQUFJLENBQUN4dEksU0FBUyxDQUFDRixXQUFXO1FBQy9DMHRJLFNBQVMvZ0IsS0FBSyxDQUFDK3FCLFVBQVV2bEcsV0FBV0MsWUFBWSxHQUFHakIsVUFBVXd5RixXQUFXb0c7UUFDeEUsT0FBTzJEO0lBQ1Q7SUFDQSxDQUFDaUssbUJBQW1CLENBQUNoVSxZQUFZLElBQUksQ0FBQyxDQUFDQSxTQUFTO1FBQzlDLE1BQU1pVSxTQUFTLElBQUksQ0FBQyxDQUFDN04sV0FBVyxHQUFHcEcsWUFBWSxJQUFJLElBQUksQ0FBQyxDQUFDNTdELFdBQVc7UUFDcEUsT0FBTyxJQUFJLENBQUMsQ0FBQzUyQixRQUFRLEdBQUcsUUFBUSxJQUFJO1lBQUN5bUcsU0FBUyxJQUFJLENBQUMsQ0FBQzc5RSxXQUFXO1lBQUU2OUUsU0FBUyxJQUFJLENBQUMsQ0FBQzU5RSxZQUFZO1NBQUMsR0FBRztZQUFDNDlFLFNBQVMsSUFBSSxDQUFDLENBQUM1OUUsWUFBWTtZQUFFNDlFLFNBQVMsSUFBSSxDQUFDLENBQUM3OUUsV0FBVztTQUFDO0lBQzNKO0lBQ0EsQ0FBQ3k5RSxtQkFBbUI7UUFDbEIsTUFBTSxDQUFDajBJLEdBQUcwTSxHQUFHOGhDLE9BQU9DLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQytuQyxJQUFJO1FBQ3hDLE1BQU0sQ0FBQzg5RCxTQUFTQyxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUNILG1CQUFtQixDQUFDO1FBQ3JELE9BQU87WUFBQ3AwSSxJQUFJczBJO1lBQVM1bkksSUFBSTZuSTtZQUFTL2xHLFFBQVEsSUFBSThsRztZQUFTN2xHLFNBQVMsSUFBSThsRztTQUFRO0lBQzlFO0lBQ0EsQ0FBQ1QsV0FBVztRQUNWLE1BQU10OUQsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsSUFBSSxHQUFHLElBQUlsaEUsYUFBYTtZQUFDN0o7WUFBVUE7WUFBVSxDQUFDQTtZQUFVLENBQUNBO1NBQVM7UUFDckYsS0FBSyxNQUFNLEVBQ1QrckMsSUFBSSxFQUNMLElBQUksSUFBSSxDQUFDLENBQUNELEtBQUssQ0FBRTtZQUNoQixJQUFJQyxLQUFLbitDLE1BQU0sSUFBSSxJQUFJO2dCQUNyQixJQUFLLElBQUkyRSxJQUFJLEdBQUdpbkMsS0FBS3VTLEtBQUtuK0MsTUFBTSxFQUFFMkUsSUFBSWluQyxJQUFJam5DLEtBQUssRUFBRztvQkFDaER5aEMsS0FBSzBELGdCQUFnQixDQUFDcVUsSUFBSSxDQUFDeDVDLEVBQUUsRUFBRXc1QyxJQUFJLENBQUN4NUMsSUFBSSxFQUFFLEVBQUV3NEU7Z0JBQzlDO2dCQUNBO1lBQ0Y7WUFDQSxJQUFJMTVCLFFBQVF0RixJQUFJLENBQUMsRUFBRSxFQUNqQnFGLFFBQVFyRixJQUFJLENBQUMsRUFBRTtZQUNqQixJQUFLLElBQUl4NUMsSUFBSSxHQUFHaW5DLEtBQUt1UyxLQUFLbitDLE1BQU0sRUFBRTJFLElBQUlpbkMsSUFBSWpuQyxLQUFLLEVBQUc7Z0JBQ2hELE1BQU0sQ0FBQ3kxSSxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLNXpJLEdBQUcwTSxFQUFFLEdBQUc4cUMsS0FBS3paLFFBQVEsQ0FBQy8vQixHQUFHQSxJQUFJO2dCQUN4RHloQyxLQUFLNEUsaUJBQWlCLENBQUN5WSxPQUFPRCxPQUFPNDJGLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUs1ekksR0FBRzBNLEdBQUc4cEU7Z0JBQy9EMTVCLFFBQVE5OEM7Z0JBQ1I2OEMsUUFBUW53QztZQUNWO1FBQ0Y7UUFDQSxNQUFNLENBQUM0bkksU0FBU0MsUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDSCxtQkFBbUI7UUFDcEQ1OUQsSUFBSSxDQUFDLEVBQUUsR0FBR2h2QyxVQUFVZ3ZDLElBQUksQ0FBQyxFQUFFLEdBQUc4OUQsU0FBUyxHQUFHO1FBQzFDOTlELElBQUksQ0FBQyxFQUFFLEdBQUdodkMsVUFBVWd2QyxJQUFJLENBQUMsRUFBRSxHQUFHKzlELFNBQVMsR0FBRztRQUMxQy85RCxJQUFJLENBQUMsRUFBRSxHQUFHaHZDLFVBQVVndkMsSUFBSSxDQUFDLEVBQUUsR0FBRzg5RCxTQUFTLEdBQUc7UUFDMUM5OUQsSUFBSSxDQUFDLEVBQUUsR0FBR2h2QyxVQUFVZ3ZDLElBQUksQ0FBQyxFQUFFLEdBQUcrOUQsU0FBUyxHQUFHO1FBQzFDLzlELElBQUksQ0FBQyxFQUFFLElBQUlBLElBQUksQ0FBQyxFQUFFO1FBQ2xCQSxJQUFJLENBQUMsRUFBRSxJQUFJQSxJQUFJLENBQUMsRUFBRTtJQUNwQjtJQUNBLElBQUl6NUIsTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDLENBQUN5NUIsSUFBSTtJQUNuQjtJQUNBMDNELGVBQWUveEksSUFBSSxFQUFFN0IsS0FBSyxFQUFFO1FBQzFCLElBQUk2QixTQUFTLGdCQUFnQjtZQUMzQixPQUFPLElBQUksQ0FBQyxDQUFDdXdJLGVBQWUsQ0FBQ3B5STtRQUMvQjtRQUNBLE9BQU87SUFDVDtJQUNBLENBQUNveUksZUFBZSxDQUFDdE0sU0FBUztRQUN4QixNQUFNLENBQUNvVSxZQUFZQyxXQUFXLEdBQUcsSUFBSSxDQUFDLENBQUNMLG1CQUFtQjtRQUMxRCxJQUFJLENBQUMsQ0FBQ2hVLFNBQVMsR0FBR0E7UUFDbEIsTUFBTSxDQUFDc1UsWUFBWUMsV0FBVyxHQUFHLElBQUksQ0FBQyxDQUFDUCxtQkFBbUI7UUFDMUQsTUFBTSxDQUFDUSxhQUFhQyxZQUFZLEdBQUc7WUFBQ0gsYUFBYUY7WUFBWUcsYUFBYUY7U0FBVztRQUNyRixNQUFNaitELE9BQU8sSUFBSSxDQUFDLENBQUNBLElBQUk7UUFDdkJBLElBQUksQ0FBQyxFQUFFLElBQUlvK0Q7UUFDWHArRCxJQUFJLENBQUMsRUFBRSxJQUFJcStEO1FBQ1hyK0QsSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJbytEO1FBQ2ZwK0QsSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJcStEO1FBQ2YsT0FBT3IrRDtJQUNUO0lBQ0E0NkQsdUJBQXVCLENBQUM1aUcsT0FBT0MsT0FBTyxFQUFFZCxLQUFLLEVBQUU7UUFDN0MsTUFBTSxDQUFDNm1HLFlBQVlDLFdBQVcsR0FBRyxJQUFJLENBQUMsQ0FBQ0wsbUJBQW1CO1FBQzFELElBQUksQ0FBQyxDQUFDNTlFLFdBQVcsR0FBR2hvQjtRQUNwQixJQUFJLENBQUMsQ0FBQ2lvQixZQUFZLEdBQUdob0I7UUFDckIsSUFBSSxDQUFDLENBQUMrMUIsV0FBVyxHQUFHNzJCO1FBQ3BCLE1BQU0sQ0FBQyttRyxZQUFZQyxXQUFXLEdBQUcsSUFBSSxDQUFDLENBQUNQLG1CQUFtQjtRQUMxRCxNQUFNUSxjQUFjRixhQUFhRjtRQUNqQyxNQUFNSyxjQUFjRixhQUFhRjtRQUNqQyxNQUFNaitELE9BQU8sSUFBSSxDQUFDLENBQUNBLElBQUk7UUFDdkJBLElBQUksQ0FBQyxFQUFFLElBQUlvK0Q7UUFDWHArRCxJQUFJLENBQUMsRUFBRSxJQUFJcStEO1FBQ1hyK0QsSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJbytEO1FBQ2ZwK0QsSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJcStEO1FBQ2YsT0FBT3IrRDtJQUNUO0lBQ0EyNkQsZUFBZXZqRyxRQUFRLEVBQUU7UUFDdkIsSUFBSSxDQUFDLENBQUNpbUcsZUFBZSxHQUFHam1HO1FBQ3hCLE9BQU87WUFDTCtuQyxNQUFNO2dCQUNKMy9DLFdBQVcsSUFBSSxDQUFDOCtHLGlCQUFpQjtZQUNuQztRQUNGO0lBQ0Y7SUFDQSxJQUFJcm5HLFVBQVU7UUFDWixPQUFPLElBQUksQ0FBQyxDQUFDK29DLElBQUksQ0FBQ3R5RSxHQUFHLENBQUM0aEksUUFBUU0sUUFBUSxFQUFFdHFJLElBQUksQ0FBQztJQUMvQztJQUNBLElBQUkyekksb0JBQW9CO1FBQ3RCLE1BQU0sQ0FBQ3p2SSxHQUFHME0sRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDOHBFLElBQUk7UUFDekIsT0FBTztZQUNMdHlELE1BQU07Z0JBQ0p1cEIsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDdkI7WUFDQWtvQyxNQUFNO2dCQUNKLG9CQUFvQixDQUFDLEVBQUVtd0QsUUFBUU0sUUFBUSxDQUFDcG1JLEdBQUcsQ0FBQyxFQUFFOGxJLFFBQVFNLFFBQVEsQ0FBQzE1SCxHQUFHLENBQUM7WUFDckU7UUFDRjtJQUNGO0lBQ0EsSUFBSW9vSSxvQkFBb0I7UUFDdEIsTUFBTSxLQUFJdG1HLE9BQU9DLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQytuQyxJQUFJO1FBQ3JDLElBQUk5NUQsSUFBSSxHQUNOQyxJQUFJLEdBQ0pyRCxJQUFJLEdBQ0ptUixJQUFJLEdBQ0o1YixJQUFJLEdBQ0pyTCxJQUFJO1FBQ04sT0FBUSxJQUFJLENBQUMsQ0FBQ3F3SSxlQUFlO1lBQzNCLEtBQUs7Z0JBQ0hsM0gsSUFBSTh4QixTQUFTRDtnQkFDYmwxQixJQUFJLENBQUNrMUIsUUFBUUM7Z0JBQ2I1L0IsSUFBSTIvQjtnQkFDSjtZQUNGLEtBQUs7Z0JBQ0g5eEIsSUFBSSxDQUFDO2dCQUNMK04sSUFBSSxDQUFDO2dCQUNMNWIsSUFBSTIvQjtnQkFDSmhyQyxJQUFJaXJDO2dCQUNKO1lBQ0YsS0FBSztnQkFDSDl4QixJQUFJLENBQUM4eEIsU0FBU0Q7Z0JBQ2RsMUIsSUFBSWsxQixRQUFRQztnQkFDWmpyQyxJQUFJaXJDO2dCQUNKO1lBQ0Y7Z0JBQ0UsT0FBTztRQUNYO1FBQ0EsT0FBTyxDQUFDLE9BQU8sRUFBRS94QixFQUFFLENBQUMsRUFBRUMsRUFBRSxDQUFDLEVBQUVyRCxFQUFFLENBQUMsRUFBRW1SLEVBQUUsQ0FBQyxFQUFFcTdHLFFBQVFNLFFBQVEsQ0FBQ3YzSCxHQUFHLENBQUMsRUFBRWkzSCxRQUFRTSxRQUFRLENBQUM1aUksR0FBRyxDQUFDLENBQUM7SUFDcEY7SUFDQStzSSw2QkFBNkIsQ0FBQ3I3RSxNQUFNQyxNQUFNdVEsVUFBVUMsVUFBVSxFQUFFO1FBQzlELE1BQU0sQ0FBQzJ1RSxTQUFTQyxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUNILG1CQUFtQjtRQUNwRCxNQUFNLENBQUNwMEksR0FBRzBNLEdBQUc4aEMsT0FBT0MsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDK25DLElBQUk7UUFDeEMsSUFBSTMyRSxLQUFLK0wsR0FBRyxDQUFDNGlDLFFBQVE4bEcsWUFBWXhPLFFBQVEvdUYsU0FBUyxJQUFJbDNDLEtBQUsrTCxHQUFHLENBQUM2aUMsU0FBUzhsRyxZQUFZek8sUUFBUS91RixTQUFTLEVBQUU7WUFDckcsTUFBTTJlLEtBQUtSLE9BQU93USxXQUFXLElBQUsxbEUsQ0FBQUEsSUFBSXd1QyxRQUFRO1lBQzlDLE1BQU1tbkIsS0FBS1IsT0FBT3dRLFlBQVksSUFBS2o1RCxDQUFBQSxJQUFJK2hDLFNBQVM7WUFDaEQsT0FBTztnQkFDTGtuQyxNQUFNO29CQUNKLG9CQUFvQixDQUFDLEVBQUVtd0QsUUFBUU0sUUFBUSxDQUFDbHhFLE1BQU0sQ0FBQyxFQUFFNHdFLFFBQVFNLFFBQVEsQ0FBQ2p4RSxNQUFNLENBQUM7b0JBQ3pFbi9CLFdBQVcsQ0FBQyxFQUFFLElBQUksQ0FBQzgrRyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUVwL0UsR0FBRyxDQUFDLEVBQUVDLEdBQUcsQ0FBQyxDQUFDO2dCQUMvRDtZQUNGO1FBQ0Y7UUFDQSxNQUFNby9FLE1BQU0sQ0FBQ3J2RSxXQUFXLElBQUk0dUUsT0FBTSxJQUFNOWxHLENBQUFBLFFBQVEsSUFBSThsRyxPQUFNO1FBQzFELE1BQU1VLE1BQU0sQ0FBQ3J2RSxZQUFZLElBQUk0dUUsT0FBTSxJQUFNOWxHLENBQUFBLFNBQVMsSUFBSThsRyxPQUFNO1FBQzVELE1BQU1VLE1BQU16bUcsUUFBUWszQjtRQUNwQixNQUFNd3ZFLE1BQU16bUcsU0FBU2szQjtRQUNyQixPQUFPO1lBQ0xnUSxNQUFNO2dCQUNKLG9CQUFvQixDQUFDLEVBQUVtd0QsUUFBUU0sUUFBUSxDQUFDcG1JLEdBQUcsQ0FBQyxFQUFFOGxJLFFBQVFNLFFBQVEsQ0FBQzE1SCxHQUFHLENBQUM7Z0JBQ25Fc3BCLFdBQVcsQ0FBQyxFQUFFLElBQUksQ0FBQzgrRyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUVHLElBQUksQ0FBQyxFQUFFQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFcFAsUUFBUU0sUUFBUSxDQUFDa08sU0FBUyxDQUFDLEVBQUV4TyxRQUFRTSxRQUFRLENBQUNtTyxTQUFTLFFBQVEsRUFBRVEsSUFBSSxDQUFDLEVBQUVDLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUVsUCxRQUFRTSxRQUFRLENBQUMsQ0FBQ2tPLFNBQVMsQ0FBQyxFQUFFeE8sUUFBUU0sUUFBUSxDQUFDLENBQUNtTyxTQUFTLENBQUMsQ0FBQztZQUN4TztRQUNGO0lBQ0Y7SUFDQTdELDRCQUE0QixDQUFDeDdFLE1BQU1DLE1BQU11USxVQUFVQyxVQUFVLEVBQUU7UUFDN0QsTUFBTSxDQUFDMnVFLFNBQVNDLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQ0gsbUJBQW1CO1FBQ3BELE1BQU01OUQsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsSUFBSTtRQUN2QixNQUFNLENBQUN4MkUsR0FBRzBNLEdBQUc4aEMsT0FBT0MsT0FBTyxHQUFHK25DO1FBQzlCQSxJQUFJLENBQUMsRUFBRSxHQUFHdGhCO1FBQ1ZzaEIsSUFBSSxDQUFDLEVBQUUsR0FBR3JoQjtRQUNWcWhCLElBQUksQ0FBQyxFQUFFLEdBQUc5UTtRQUNWOFEsSUFBSSxDQUFDLEVBQUUsR0FBRzdRO1FBQ1YsSUFBSTlsRSxLQUFLK0wsR0FBRyxDQUFDNGlDLFFBQVE4bEcsWUFBWXhPLFFBQVEvdUYsU0FBUyxJQUFJbDNDLEtBQUsrTCxHQUFHLENBQUM2aUMsU0FBUzhsRyxZQUFZek8sUUFBUS91RixTQUFTLEVBQUU7WUFDckcsTUFBTTJlLEtBQUtSLE9BQU93USxXQUFXLElBQUsxbEUsQ0FBQUEsSUFBSXd1QyxRQUFRO1lBQzlDLE1BQU1tbkIsS0FBS1IsT0FBT3dRLFlBQVksSUFBS2o1RCxDQUFBQSxJQUFJK2hDLFNBQVM7WUFDaEQsS0FBSyxNQUFNLEVBQ1QrSSxJQUFJLEVBQ0p5b0YsTUFBTSxFQUNQLElBQUksSUFBSSxDQUFDLENBQUMxb0YsS0FBSyxDQUFFO2dCQUNoQnV1RixRQUFRSyxVQUFVLENBQUMzdUYsTUFBTWtlLElBQUlDLElBQUluZTtnQkFDakNzdUYsUUFBUUssVUFBVSxDQUFDbEcsUUFBUXZxRSxJQUFJQyxJQUFJc3FFO1lBQ3JDO1lBQ0EsT0FBTztnQkFDTC83RyxNQUFNO29CQUNKdXBCLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUN2QjtnQkFDQWtvQyxNQUFNO29CQUNKLG9CQUFvQixDQUFDLEVBQUVtd0QsUUFBUU0sUUFBUSxDQUFDbHhFLE1BQU0sQ0FBQyxFQUFFNHdFLFFBQVFNLFFBQVEsQ0FBQ2p4RSxNQUFNLENBQUM7b0JBQ3pFbi9CLFdBQVcsSUFBSSxDQUFDOCtHLGlCQUFpQixJQUFJO29CQUNyQ3JxSCxHQUFHLElBQUksQ0FBQ3M3RyxTQUFTO2dCQUNuQjtZQUNGO1FBQ0Y7UUFDQSxNQUFNZ1AsTUFBTSxDQUFDcnZFLFdBQVcsSUFBSTR1RSxPQUFNLElBQU05bEcsQ0FBQUEsUUFBUSxJQUFJOGxHLE9BQU07UUFDMUQsTUFBTVUsTUFBTSxDQUFDcnZFLFlBQVksSUFBSTR1RSxPQUFNLElBQU05bEcsQ0FBQUEsU0FBUyxJQUFJOGxHLE9BQU07UUFDNUQsTUFBTTcrRSxLQUFLLENBQUNxL0UsTUFBTy8wSSxDQUFBQSxJQUFJczBJLE9BQU0sSUFBS3AvRSxPQUFPby9FO1FBQ3pDLE1BQU0zK0UsS0FBSyxDQUFDcS9FLE1BQU90b0ksQ0FBQUEsSUFBSTZuSSxPQUFNLElBQUtwL0UsT0FBT28vRTtRQUN6QyxJQUFJUSxRQUFRLEtBQUtDLFFBQVEsS0FBS3QvRSxPQUFPLEtBQUtDLE9BQU8sR0FBRztZQUNsRCxLQUFLLE1BQU0sRUFDVG5lLElBQUksRUFDSnlvRixNQUFNLEVBQ1AsSUFBSSxJQUFJLENBQUMsQ0FBQzFvRixLQUFLLENBQUU7Z0JBQ2hCdXVGLFFBQVFHLFFBQVEsQ0FBQ3p1RixNQUFNa2UsSUFBSUMsSUFBSW8vRSxLQUFLQyxLQUFLeDlGO2dCQUN6Q3N1RixRQUFRRyxRQUFRLENBQUNoRyxRQUFRdnFFLElBQUlDLElBQUlvL0UsS0FBS0MsS0FBSy9VO1lBQzdDO1FBQ0Y7UUFDQSxPQUFPO1lBQ0wvN0csTUFBTTtnQkFDSnVwQixTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUN2QjtZQUNBa29DLE1BQU07Z0JBQ0osb0JBQW9CLENBQUMsRUFBRW13RCxRQUFRTSxRQUFRLENBQUNseEUsTUFBTSxDQUFDLEVBQUU0d0UsUUFBUU0sUUFBUSxDQUFDanhFLE1BQU0sQ0FBQztnQkFDekVuL0IsV0FBVyxJQUFJLENBQUM4K0csaUJBQWlCLElBQUk7Z0JBQ3JDcnFILEdBQUcsSUFBSSxDQUFDczdHLFNBQVM7WUFDbkI7UUFDRjtJQUNGO0lBQ0E4SywrQkFBK0IsQ0FBQzM3RSxNQUFNQyxLQUFLLEVBQUVnRyxnQkFBZ0IsRUFBRTtRQUM3RCxNQUFNLENBQUNnNkUsZ0JBQWdCQyxnQkFBZ0IsR0FBR2o2RTtRQUMxQyxNQUFNcWIsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsSUFBSTtRQUN2QixNQUFNOWdCLEtBQUtSLE9BQU9zaEIsSUFBSSxDQUFDLEVBQUU7UUFDekIsTUFBTTdnQixLQUFLUixPQUFPcWhCLElBQUksQ0FBQyxFQUFFO1FBQ3pCLElBQUksSUFBSSxDQUFDLENBQUNoZ0IsV0FBVyxLQUFLMitFLGtCQUFrQixJQUFJLENBQUMsQ0FBQzErRSxZQUFZLEtBQUsyK0UsaUJBQWlCO1lBQ2xGLEtBQUssTUFBTSxFQUNUNTlGLElBQUksRUFDSnlvRixNQUFNLEVBQ1AsSUFBSSxJQUFJLENBQUMsQ0FBQzFvRixLQUFLLENBQUU7Z0JBQ2hCdXVGLFFBQVFLLFVBQVUsQ0FBQzN1RixNQUFNa2UsSUFBSUMsSUFBSW5lO2dCQUNqQ3N1RixRQUFRSyxVQUFVLENBQUNsRyxRQUFRdnFFLElBQUlDLElBQUlzcUU7WUFDckM7UUFDRixPQUFPO1lBQ0wsTUFBTW5zRixLQUFLLElBQUksQ0FBQyxDQUFDMGlCLFdBQVcsR0FBRzIrRTtZQUMvQixNQUFNcGhHLEtBQUssSUFBSSxDQUFDLENBQUMwaUIsWUFBWSxHQUFHMitFO1lBQ2hDLElBQUksQ0FBQyxDQUFDNStFLFdBQVcsR0FBRzIrRTtZQUNwQixJQUFJLENBQUMsQ0FBQzErRSxZQUFZLEdBQUcyK0U7WUFDckIsS0FBSyxNQUFNLEVBQ1Q1OUYsSUFBSSxFQUNKeW9GLE1BQU0sRUFDUCxJQUFJLElBQUksQ0FBQyxDQUFDMW9GLEtBQUssQ0FBRTtnQkFDaEJ1dUYsUUFBUUcsUUFBUSxDQUFDenVGLE1BQU1rZSxJQUFJQyxJQUFJN2hCLElBQUlDLElBQUl5RDtnQkFDdkNzdUYsUUFBUUcsUUFBUSxDQUFDaEcsUUFBUXZxRSxJQUFJQyxJQUFJN2hCLElBQUlDLElBQUlrc0Y7WUFDM0M7WUFDQXpwRCxJQUFJLENBQUMsRUFBRSxJQUFJMWlDO1lBQ1gwaUMsSUFBSSxDQUFDLEVBQUUsSUFBSXppQztRQUNiO1FBQ0F5aUMsSUFBSSxDQUFDLEVBQUUsR0FBR3RoQjtRQUNWc2hCLElBQUksQ0FBQyxFQUFFLEdBQUdyaEI7UUFDVixPQUFPO1lBQ0xqeEMsTUFBTTtnQkFDSnVwQixTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUN2QjtZQUNBa29DLE1BQU07Z0JBQ0psckQsR0FBRyxJQUFJLENBQUNzN0csU0FBUztnQkFDakIsb0JBQW9CLENBQUMsRUFBRUQsUUFBUU0sUUFBUSxDQUFDbHhFLE1BQU0sQ0FBQyxFQUFFNHdFLFFBQVFNLFFBQVEsQ0FBQ2p4RSxNQUFNLENBQUM7WUFDM0U7UUFDRjtJQUNGO0lBQ0EsSUFBSTA2RSx1QkFBdUI7UUFDekIsTUFBTXI1RCxPQUFPLElBQUksQ0FBQyxDQUFDQSxJQUFJO1FBQ3ZCLE9BQU87WUFDTHR5RCxNQUFNO2dCQUNKdXBCLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3ZCO1lBQ0E0K0YsV0FBVztnQkFDVGlCLE1BQU07WUFDUjtZQUNBMzNELE1BQU07Z0JBQ0psckQsR0FBRyxJQUFJLENBQUNzN0csU0FBUztnQkFDakIsb0JBQW9CLENBQUMsRUFBRUQsUUFBUU0sUUFBUSxDQUFDNXZELElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFc3ZELFFBQVFNLFFBQVEsQ0FBQzV2RCxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7Z0JBQy9FeGdELFdBQVcsSUFBSSxDQUFDOCtHLGlCQUFpQixJQUFJO1lBQ3ZDO1lBQ0F0K0Q7UUFDRjtJQUNGOzs7YUF0Y0EsQ0FBQ3E5RCxlQUFlLEdBQUc7O0FBdWNyQjtFQUVDLDhCQUE4QjtBQVMvQixNQUFNd0IsMEJBQTBCckg7SUFDOUJ2eEksWUFBWTY0SSxnQkFBZ0IsQ0FBRTtRQUM1QixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxlQUFlLEdBQUdEO1FBQ3ZCLEtBQUssQ0FBQzlJLGlCQUFpQjtZQUNyQjkxRyxNQUFNO1lBQ05GLFFBQVE2bkMsaUJBQWlCK0MsaUJBQWlCO1lBQzFDLGtCQUFrQjtZQUNsQixnQkFBZ0I7WUFDaEIsa0JBQWtCO1lBQ2xCLG1CQUFtQjtZQUNuQixxQkFBcUI7UUFDdkI7SUFDRjtJQUNBK3NFLGtCQUFrQmh5SSxJQUFJLEVBQUU3QixLQUFLLEVBQUU7UUFDN0IsSUFBSTZCLFNBQVMsZ0JBQWdCO1lBQzNCN0IsVUFBVSxJQUFJLENBQUMsZUFBZTtZQUM5QkEsU0FBUyxJQUFJLENBQUNpN0ksZUFBZSxDQUFDaHVGLFNBQVM7UUFDekM7UUFDQSxLQUFLLENBQUM0bUYsa0JBQWtCaHlJLE1BQU03QjtJQUNoQztJQUNBc0ksUUFBUTtRQUNOLE1BQU1BLFFBQVEsSUFBSXl5SSxrQkFBa0IsSUFBSSxDQUFDRSxlQUFlO1FBQ3hEM3lJLE1BQU15ckksU0FBUyxDQUFDLElBQUk7UUFDcEIsT0FBT3pySTtJQUNUO0FBQ0Y7QUFDQSxNQUFNNHlJLGtCQUFrQmxIOzthQUNmcHRFLFFBQVE7OzthQUNSM1AsY0FBY2xrQyxxQkFBcUJLLEdBQUc7OzthQUN0QzBpSCx5QkFBeUI7O0lBQ2hDM3pJLFlBQVk2VyxNQUFNLENBQUU7UUFDbEIsS0FBSyxDQUFDO1lBQ0osR0FBR0EsTUFBTTtZQUNUblgsTUFBTTtRQUNSO1FBQ0EsSUFBSSxDQUFDc2tFLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQytJLGFBQWEsR0FBRztJQUN2QjtJQUNBLE9BQU90UixXQUFXQyxJQUFJLEVBQUU5YixTQUFTLEVBQUU7UUFDakNnaUIsaUJBQWlCbkcsVUFBVSxDQUFDQyxNQUFNOWI7UUFDbEMsSUFBSSxDQUFDK3pGLHNCQUFzQixHQUFHLElBQUlpRixrQkFBa0JoNUYsVUFBVWlMLGNBQWM7SUFDOUU7SUFDQSxPQUFPeW9GLHlCQUF5QjN6SSxPQUFPLEVBQUU7UUFDdkMsTUFBTXdHLFFBQVEsSUFBSSxDQUFDd3RJLHNCQUFzQixDQUFDeHRJLEtBQUs7UUFDL0NBLE1BQU00cEksZ0JBQWdCLENBQUNwd0k7UUFDdkIsT0FBT3dHO0lBQ1Q7SUFDQSxXQUFXc3RJLDBCQUEwQjtRQUNuQyxPQUFPO0lBQ1Q7SUFDQSxXQUFXRCxXQUFXO1FBQ3BCLE9BQU9wekcsT0FBTyxJQUFJLEVBQUUsWUFBWSxJQUFJMEosSUFBSTtZQUFDO2dCQUFDelksMkJBQTJCTyxhQUFhO2dCQUFFO2FBQWU7WUFBRTtnQkFBQ1AsMkJBQTJCTSxTQUFTO2dCQUFFO2FBQVM7WUFBRTtnQkFBQ04sMkJBQTJCUSxXQUFXO2dCQUFFO2FBQWlCO1NBQUM7SUFDcE47SUFDQSxPQUFPaWpILHFCQUFxQnZ4SSxDQUFDLEVBQUUwTSxDQUFDLEVBQUU4cEQsV0FBVyxFQUFFQyxZQUFZLEVBQUU3b0IsUUFBUSxFQUFFO1FBQ3JFLE9BQU8sSUFBSW9sRyxnQkFBZ0JoekksR0FBRzBNLEdBQUc4cEQsYUFBYUMsY0FBYzdvQixVQUFVLElBQUksQ0FBQ3dpRyxzQkFBc0IsQ0FBQyxlQUFlO0lBQ25IO0lBQ0EsT0FBT3FDLGdCQUFnQjNqRyxLQUFLLEVBQUVDLEtBQUssRUFBRUgsU0FBUyxFQUFFQyxVQUFVLEVBQUUyM0YsV0FBVyxFQUFFNThILElBQUksRUFBRTtRQUM3RSxPQUFPdXBJLGVBQWUxakYsV0FBVyxDQUFDM2dCLE9BQU9DLE9BQU9ILFdBQVdDLFlBQVkyM0YsYUFBYTU4SDtJQUN0RjtJQUNBLGFBQWE2bEQsWUFBWTdsRCxJQUFJLEVBQUUraEMsTUFBTSxFQUFFMFEsU0FBUyxFQUFFO1FBQ2hELElBQUlpdkQsY0FBYztRQUNsQixJQUFJMWhHLGdCQUFnQm1sSCxzQkFBc0I7WUFDeEMsTUFBTSxFQUNKbmxILE1BQU0sRUFDSnFuSCxRQUFRLEVBQ1I5dkYsSUFBSSxFQUNKeU0sUUFBUSxFQUNSNS9CLEVBQUUsRUFDRnFrQyxLQUFLLEVBQ0xtRCxPQUFPLEVBQ1BxOEUsYUFBYSxFQUNYd1EsVUFBVWpDLFNBQVMsRUFDcEIsRUFDRHR1RSxRQUFRLEVBQ1I4SCxRQUFRLEVBQ1I3SCxXQUFXLEVBQ1g2TyxZQUFZLEVBQ1pDLGdCQUFnQixFQUNqQixFQUNEbDFCLFFBQVEsRUFDTnZFLE1BQU0sRUFDSmtqQixVQUFVLEVBQ1gsRUFDRixFQUNGLEdBQUcxZ0Q7WUFDSjBoRyxjQUFjMWhHLE9BQU87Z0JBQ25CcWlFLGdCQUFnQjUrQyxxQkFBcUJLLEdBQUc7Z0JBQ3hDMmtCLE9BQU9qbkMsTUFBTXFXLElBQUksQ0FBQzR3QjtnQkFDbEIrdEY7Z0JBQ0E1cUY7Z0JBQ0FncUQsT0FBTztvQkFDTHlnQyxRQUFRaFA7Z0JBQ1Y7Z0JBQ0F0MEUsT0FBTztnQkFDUDZNLFdBQVdjLGFBQWE7Z0JBQ3hCbnBCLE1BQU1BLEtBQUt2bEMsS0FBSyxDQUFDO2dCQUNqQmd5QztnQkFDQThqQixxQkFBcUIxakQ7Z0JBQ3JCQTtnQkFDQTRqRCxTQUFTO2dCQUNURTtnQkFDQThIO2dCQUNBL2dCLFNBQVNrWixhQUFhOXpCLE9BQU87Z0JBQzdCMmlDO2dCQUNBQztZQUNGO1FBQ0Y7UUFDQSxNQUFNbm9CLFNBQVMsTUFBTSxLQUFLLENBQUMrVyxZQUFZN2xELE1BQU0raEMsUUFBUTBRO1FBQ3JEM0QsT0FBTzZuQixZQUFZLEdBQUcrcUM7UUFDdEIsSUFBSTFoRyxLQUFLaXZDLE9BQU8sRUFBRTtZQUNoQkgsT0FBTyt2QixjQUFjLENBQUM3K0Q7UUFDeEI7UUFDQSxPQUFPOHVDO0lBQ1Q7SUFDQSxJQUFJNnVCLGlCQUFpQjtRQUNuQixJQUFJLENBQUN3N0QsWUFBWSxLQUFLLElBQUl0WCxpQkFBaUIsSUFBSTtRQUMvQyxPQUFPO1lBQUM7Z0JBQUM7Z0JBQWUsSUFBSSxDQUFDc1gsWUFBWTthQUFDO1NBQUM7SUFDN0M7SUFDQSxJQUFJclgsWUFBWTtRQUNkLE9BQU81OUYsMkJBQTJCTSxTQUFTO0lBQzdDO0lBQ0EsSUFBSWlrQixRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUNtOUYsZUFBZSxDQUFDaDVHLE1BQU07SUFDcEM7SUFDQSxJQUFJZ2YsVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDZzZGLGVBQWUsQ0FBQyxpQkFBaUI7SUFDL0M7SUFDQTFvRixrQkFBa0I7UUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQ25iLE1BQU0sRUFBRTtZQUNoQjtRQUNGO1FBQ0EsS0FBSyxDQUFDbWI7UUFDTixNQUFNLEVBQ0pxb0YsT0FBTyxFQUNQSyxlQUFlLEVBQ2Y3akcsTUFBTSxFQUNQLEdBQUcsSUFBSTtRQUNSNmpHLGdCQUFnQnJCLGlCQUFpQixDQUFDO1FBQ2xDeGlHLE9BQU91Z0csU0FBUyxDQUFDTSxnQkFBZ0IsQ0FBQzJDLFNBQVNLLGdCQUFnQnBCLGVBQWU7SUFDNUU7SUFDQSxPQUFPaUQsNkJBQTZCO1FBQ2xDLE1BQU0xbEcsU0FBUyxJQUFJLENBQUMraUcsY0FBYztRQUNsQyxJQUFJLENBQUMvaUcsUUFBUTtZQUNYO1FBQ0Y7UUFDQSxLQUFLLENBQUMwbEc7UUFDTixJQUFJLENBQUNqQixzQkFBc0IsQ0FBQ2pDLGlCQUFpQixDQUFDO1FBQzlDeGlHLE9BQU91Z0csU0FBUyxDQUFDTSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNpQyxjQUFjLEVBQUUsSUFBSSxDQUFDMkIsc0JBQXNCLENBQUNoQyxlQUFlO0lBQ3BHO0lBQ0FtRSxxQkFBcUIsRUFDbkJsZ0csS0FBSyxFQUNMK3RGLFNBQVMsRUFDVDVxRixPQUFPLEVBQ1IsRUFBRTtRQUNELElBQUksQ0FBQ2c2RixlQUFlLEdBQUdnRyxVQUFVekYsd0JBQXdCLENBQUM7WUFDeER2NUcsUUFBUWlKLEtBQUtDLFlBQVksSUFBSTJTO1lBQzdCLGdCQUFnQit0RjtZQUNoQixrQkFBa0I1cUY7UUFDcEI7SUFDRjtJQUNBNEwsVUFBVTBYLGVBQWUsS0FBSyxFQUFFO1FBQzlCLElBQUksSUFBSSxDQUFDdlMsT0FBTyxJQUFJO1lBQ2xCLE9BQU87UUFDVDtRQUNBLElBQUksSUFBSSxDQUFDcUwsT0FBTyxFQUFFO1lBQ2hCLE9BQU8sSUFBSSxDQUFDb2EsZ0JBQWdCO1FBQzlCO1FBQ0EsTUFBTSxFQUNKejBCLEtBQUssRUFDTDBvRixNQUFNLEVBQ1AsR0FBRyxJQUFJLENBQUM4UyxhQUFhLENBQUNqNkU7UUFDdkIsTUFBTSxFQUNKMDJFLGlCQUFpQixFQUNmaDVHLE1BQU0sRUFDTixrQkFBa0JnZixPQUFPLEVBQ3pCLGdCQUFnQjRxRixTQUFTLEVBQzFCLEVBQ0YsR0FBRyxJQUFJO1FBQ1IsTUFBTWh4RSxhQUFhMXpELE9BQU9rdkMsTUFBTSxDQUFDLEtBQUssQ0FBQ3dXLFVBQVUwWCxlQUFlO1lBQzlEem1CLE9BQU9nc0IsaUJBQWlCd0IsYUFBYSxDQUFDL2QsT0FBTyxDQUFDdHJCO1lBQzlDZ2Y7WUFDQTRxRjtZQUNBNWdDLE9BQU87Z0JBQ0xqb0Q7Z0JBQ0Ewb0Y7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDamxGLFVBQVUsQ0FBQ29VO1FBQ2hCLElBQUkwSixjQUFjO1lBQ2hCMUosV0FBVytjLE1BQU0sR0FBRztZQUNwQixPQUFPL2M7UUFDVDtRQUNBLElBQUksSUFBSSxDQUFDc0MsbUJBQW1CLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ20wRSxpQkFBaUIsQ0FBQ3oyRSxhQUFhO1lBQ3BFLE9BQU87UUFDVDtRQUNBQSxXQUFXcGhELEVBQUUsR0FBRyxJQUFJLENBQUMwakQsbUJBQW1CO1FBQ3hDLE9BQU90QztJQUNUO0lBQ0EsQ0FBQ3kyRSxpQkFBaUIsQ0FBQ3oyRSxVQUFVO1FBQzNCLE1BQU0sRUFDSi9jLEtBQUssRUFDTCt0RixTQUFTLEVBQ1Q1cUYsT0FBTyxFQUNQZ1UsU0FBUyxFQUNWLEdBQUcsSUFBSSxDQUFDK1csWUFBWTtRQUNyQixPQUFPLElBQUksQ0FBQ29JLGdCQUFnQixJQUFJLElBQUksQ0FBQzNFLGFBQWEsSUFBSSxJQUFJLENBQUNDLGVBQWUsSUFBSTdVLFdBQVcvYyxLQUFLLENBQUNwakMsSUFBSSxDQUFDLENBQUNxSyxHQUFHdGIsSUFBTXNiLE1BQU0rNEIsS0FBSyxDQUFDcjBDLEVBQUUsS0FBS294RCxXQUFXZ3hFLFNBQVMsS0FBS0EsYUFBYWh4RSxXQUFXNVosT0FBTyxLQUFLQSxXQUFXNFosV0FBVzVGLFNBQVMsS0FBS0E7SUFDcE87SUFDQXNOLHdCQUF3QmpGLFVBQVUsRUFBRTtRQUNsQyxJQUFJLElBQUksQ0FBQ0QsT0FBTyxFQUFFO1lBQ2hCQyxXQUFXeFgsSUFBSTtZQUNmLE9BQU87UUFDVDtRQUNBLE1BQU0sRUFDSjRsRixNQUFNLEVBQ045K0YsSUFBSSxFQUNMLEdBQUcsSUFBSSxDQUFDNHhHLGFBQWEsQ0FBQztRQUN2QmxoRixXQUFXa2MsWUFBWSxDQUFDO1lBQ3RCNXNDO1lBQ0FpL0YsV0FBVyxJQUFJLENBQUNvUCxlQUFlLENBQUMsZUFBZTtZQUMvQ3ZQO1lBQ0E1MkQsT0FBTyxJQUFJLENBQUN4d0IsT0FBTztRQUNyQjtRQUNBLE9BQU87SUFDVDtBQUNGO0VBRUMsMENBQTBDO0FBRTNDLE1BQU00OEYsMkJBQTJCdEM7SUFDL0JwTixZQUFZO1FBQ1YsSUFBSXB3RCxPQUFPLEtBQUssQ0FBQ293RDtRQUNqQixJQUFJLENBQUNwd0QsS0FBS2x0QixRQUFRLENBQUMsTUFBTTtZQUN2Qmt0QixRQUFRO1FBQ1Y7UUFDQSxPQUFPQTtJQUNUO0FBQ0Y7RUFFQyxnREFBZ0Q7QUFnQmpELE1BQU0rL0QscUJBQXFCO0FBQzNCLE1BQU1DLDJCQUEyQjtBQUNqQyxNQUFNQztJQUNKLE9BQU8sQ0FBQ0MsVUFBVSxHQUFHO1FBQ25CemhHLFFBQVE7UUFDUjBoRyxjQUFjO1FBQ2RDLFFBQVE7UUFDUkMsWUFBWTtJQUNkLEVBQUU7SUFDRixPQUFPLENBQUNDLGlCQUFpQixDQUFDQyxFQUFFLEVBQUVDLEVBQUUsRUFBRW40SSxDQUFDLEVBQUVzUCxDQUFDO1FBQ3BDdFAsS0FBS2s0STtRQUNMNW9JLEtBQUs2b0k7UUFDTCxJQUFJbjRJLE1BQU0sR0FBRztZQUNYLE9BQU9zUCxJQUFJLElBQUksSUFBSTtRQUNyQjtRQUNBLElBQUl0UCxNQUFNLEdBQUc7WUFDWCxPQUFPc1AsSUFBSTtRQUNiO1FBQ0EsT0FBTyxJQUFJQTtJQUNiO0lBQ0EsT0FBTyxDQUFDOG9JLGlCQUFpQixHQUFHLElBQUloaEksV0FBVztRQUFDO1FBQUc7UUFBRyxDQUFDO1FBQUc7UUFBRyxDQUFDO1FBQUc7UUFBRyxDQUFDO1FBQUcsQ0FBQztRQUFHO1FBQUcsQ0FBQztRQUFHO1FBQUcsQ0FBQztRQUFHO1FBQUc7UUFBRztRQUFHO0tBQUUsRUFBRTtJQUNuRyxPQUFPLENBQUNpaEksZ0JBQWdCLENBQUN4dkcsR0FBRyxFQUFFMkgsS0FBSyxFQUFFMG5HLEVBQUUsRUFBRUMsRUFBRSxFQUFFbjRJLENBQUMsRUFBRXNQLENBQUMsRUFBRXFtRSxNQUFNO1FBQ3ZELE1BQU0zbEUsS0FBSyxJQUFJLENBQUMsQ0FBQ2lvSSxpQkFBaUIsQ0FBQ0MsSUFBSUMsSUFBSW40SSxHQUFHc1A7UUFDOUMsSUFBSyxJQUFJb0csSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7WUFDMUIsTUFBTTRpSSxLQUFLLENBQUMsQ0FBQzVpSSxJQUFJMUYsS0FBSzJsRSxTQUFTLEVBQUMsSUFBSztZQUNyQyxNQUFNNGlFLFNBQVMsSUFBSSxDQUFDLENBQUNILGlCQUFpQixDQUFDLElBQUlFLEdBQUc7WUFDOUMsTUFBTUUsU0FBUyxJQUFJLENBQUMsQ0FBQ0osaUJBQWlCLENBQUMsSUFBSUUsS0FBSyxFQUFFO1lBQ2xELElBQUl6dkcsR0FBRyxDQUFDLENBQUNxdkcsS0FBS0ssTUFBSyxJQUFLL25HLFFBQVMybkcsQ0FBQUEsS0FBS0ssTUFBSyxFQUFHLEtBQUssR0FBRztnQkFDcEQsT0FBT0Y7WUFDVDtRQUNGO1FBQ0EsT0FBTyxDQUFDO0lBQ1Y7SUFDQSxPQUFPLENBQUNHLHVCQUF1QixDQUFDNXZHLEdBQUcsRUFBRTJILEtBQUssRUFBRTBuRyxFQUFFLEVBQUVDLEVBQUUsRUFBRW40SSxDQUFDLEVBQUVzUCxDQUFDLEVBQUVxbUUsTUFBTTtRQUM5RCxNQUFNM2xFLEtBQUssSUFBSSxDQUFDLENBQUNpb0ksaUJBQWlCLENBQUNDLElBQUlDLElBQUluNEksR0FBR3NQO1FBQzlDLElBQUssSUFBSW9HLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1lBQzFCLE1BQU00aUksS0FBSyxDQUFDNWlJLElBQUkxRixLQUFLMmxFLFNBQVMsRUFBQyxJQUFLO1lBQ3BDLE1BQU00aUUsU0FBUyxJQUFJLENBQUMsQ0FBQ0gsaUJBQWlCLENBQUMsSUFBSUUsR0FBRztZQUM5QyxNQUFNRSxTQUFTLElBQUksQ0FBQyxDQUFDSixpQkFBaUIsQ0FBQyxJQUFJRSxLQUFLLEVBQUU7WUFDbEQsSUFBSXp2RyxHQUFHLENBQUMsQ0FBQ3F2RyxLQUFLSyxNQUFLLElBQUsvbkcsUUFBUzJuRyxDQUFBQSxLQUFLSyxNQUFLLEVBQUcsS0FBSyxHQUFHO2dCQUNwRCxPQUFPRjtZQUNUO1FBQ0Y7UUFDQSxPQUFPLENBQUM7SUFDVjtJQUNBLE9BQU8sQ0FBQ0ksWUFBWSxDQUFDN3ZHLEdBQUcsRUFBRTJILEtBQUssRUFBRUMsTUFBTSxFQUFFa29HLFNBQVM7UUFDaEQsTUFBTXRPLElBQUl4aEcsSUFBSXh0QyxNQUFNO1FBQ3BCLE1BQU02MkQsUUFBUSxJQUFJOTZDLFdBQVdpekg7UUFDN0IsSUFBSyxJQUFJcnFJLElBQUksR0FBR0EsSUFBSXFxSSxHQUFHcnFJLElBQUs7WUFDMUJreUQsS0FBSyxDQUFDbHlELEVBQUUsR0FBRzZvQyxHQUFHLENBQUM3b0MsRUFBRSxJQUFJMjRJLFlBQVksSUFBSTtRQUN2QztRQUNBLElBQUssSUFBSTM0SSxJQUFJLEdBQUdBLElBQUl5d0MsU0FBUyxHQUFHendDLElBQUs7WUFDbkNreUQsS0FBSyxDQUFDbHlELElBQUl3d0MsTUFBTSxHQUFHMGhCLEtBQUssQ0FBQ2x5RCxJQUFJd3dDLFFBQVFBLFFBQVEsRUFBRSxHQUFHO1FBQ3BEO1FBQ0EsSUFBSyxJQUFJeHdDLElBQUksR0FBR0EsSUFBSXd3QyxPQUFPeHdDLElBQUs7WUFDOUJreUQsS0FBSyxDQUFDbHlELEVBQUUsR0FBR2t5RCxLQUFLLENBQUMxaEIsUUFBUUMsU0FBUyxJQUFJendDLEVBQUUsR0FBRztRQUM3QztRQUNBLElBQUk0NEksTUFBTTtRQUNWLElBQUlDO1FBQ0osTUFBTUMsV0FBVyxFQUFFO1FBQ25CLElBQUssSUFBSTk0SSxJQUFJLEdBQUdBLElBQUl5d0MsU0FBUyxHQUFHendDLElBQUs7WUFDbkM2NEksT0FBTztZQUNQLElBQUssSUFBSXZwSSxJQUFJLEdBQUdBLElBQUlraEMsUUFBUSxHQUFHbGhDLElBQUs7Z0JBQ2xDLE1BQU15cEksS0FBSy80SSxJQUFJd3dDLFFBQVFsaEM7Z0JBQ3ZCLE1BQU0wcEksTUFBTTltRixLQUFLLENBQUM2bUYsR0FBRztnQkFDckIsSUFBSUMsUUFBUSxHQUFHO29CQUNiO2dCQUNGO2dCQUNBLElBQUlDLEtBQUtqNUk7Z0JBQ1QsSUFBSWs1SSxLQUFLNXBJO2dCQUNULElBQUkwcEksUUFBUSxLQUFLOW1GLEtBQUssQ0FBQzZtRixLQUFLLEVBQUUsS0FBSyxHQUFHO29CQUNwQ0gsT0FBTztvQkFDUE0sTUFBTTtnQkFDUixPQUFPLElBQUlGLE9BQU8sS0FBSzltRixLQUFLLENBQUM2bUYsS0FBSyxFQUFFLEtBQUssR0FBRztvQkFDMUNILE9BQU87b0JBQ1BNLE1BQU07b0JBQ04sSUFBSUYsTUFBTSxHQUFHO3dCQUNYSCxPQUFPRztvQkFDVDtnQkFDRixPQUFPO29CQUNMLElBQUlBLFFBQVEsR0FBRzt3QkFDYkgsT0FBT2gzSSxLQUFLK0wsR0FBRyxDQUFDb3JJO29CQUNsQjtvQkFDQTtnQkFDRjtnQkFDQSxNQUFNL1csU0FBUztvQkFBQzN5SDtvQkFBR3RQO2lCQUFFO2dCQUNyQixNQUFNbTVJLFNBQVNELE9BQU81cEksSUFBSTtnQkFDMUIsTUFBTThwSSxVQUFVO29CQUNkRDtvQkFDQWxYO29CQUNBanlILElBQUk0b0k7b0JBQ0pqckcsUUFBUTtnQkFDVjtnQkFDQW1yRyxTQUFTeHlJLElBQUksQ0FBQzh5STtnQkFDZCxJQUFJQztnQkFDSixLQUFLLE1BQU0vOUgsS0FBS3c5SCxTQUFVO29CQUN4QixJQUFJeDlILEVBQUV0TCxFQUFFLEtBQUs2b0ksTUFBTTt3QkFDakJRLFdBQVcvOUg7d0JBQ1g7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDKzlILFVBQVU7b0JBQ2JELFFBQVF6ckcsTUFBTSxHQUFHd3JHLFNBQVNOLE9BQU87Z0JBQ25DLE9BQU8sSUFBSVEsU0FBU0YsTUFBTSxFQUFFO29CQUMxQkMsUUFBUXpyRyxNQUFNLEdBQUd3ckcsU0FBU0UsU0FBUzFyRyxNQUFNLEdBQUdrckc7Z0JBQzlDLE9BQU87b0JBQ0xPLFFBQVF6ckcsTUFBTSxHQUFHd3JHLFNBQVNOLE9BQU9RLFNBQVMxckcsTUFBTTtnQkFDbEQ7Z0JBQ0EsTUFBTWo0QixJQUFJLElBQUksQ0FBQyxDQUFDMmlJLGdCQUFnQixDQUFDbm1GLE9BQU8xaEIsT0FBT3h3QyxHQUFHc1AsR0FBRzJwSSxJQUFJQyxJQUFJO2dCQUM3RCxJQUFJeGpJLE1BQU0sQ0FBQyxHQUFHO29CQUNadzhDLEtBQUssQ0FBQzZtRixHQUFHLEdBQUcsQ0FBQ0g7b0JBQ2IsSUFBSTFtRixLQUFLLENBQUM2bUYsR0FBRyxLQUFLLEdBQUc7d0JBQ25CRixPQUFPaDNJLEtBQUsrTCxHQUFHLENBQUNza0QsS0FBSyxDQUFDNm1GLEdBQUc7b0JBQzNCO29CQUNBO2dCQUNGO2dCQUNBLElBQUlSLFNBQVMsSUFBSSxDQUFDLENBQUNILGlCQUFpQixDQUFDLElBQUkxaUksRUFBRTtnQkFDM0MsSUFBSThpSSxTQUFTLElBQUksQ0FBQyxDQUFDSixpQkFBaUIsQ0FBQyxJQUFJMWlJLElBQUksRUFBRTtnQkFDL0MsTUFBTTRqSSxLQUFLdDVJLElBQUl1NEk7Z0JBQ2YsTUFBTWdCLEtBQUtqcUksSUFBSWtwSTtnQkFDZlMsS0FBS0s7Z0JBQ0xKLEtBQUtLO2dCQUNMLElBQUlDLEtBQUt4NUk7Z0JBQ1QsSUFBSXk1SSxLQUFLbnFJO2dCQUNULE1BQU8sS0FBTTtvQkFDWCxNQUFNZ3BJLEtBQUssSUFBSSxDQUFDLENBQUNHLHVCQUF1QixDQUFDdm1GLE9BQU8xaEIsT0FBT2dwRyxJQUFJQyxJQUFJUixJQUFJQyxJQUFJO29CQUN2RVgsU0FBUyxJQUFJLENBQUMsQ0FBQ0gsaUJBQWlCLENBQUMsSUFBSUUsR0FBRztvQkFDeENFLFNBQVMsSUFBSSxDQUFDLENBQUNKLGlCQUFpQixDQUFDLElBQUlFLEtBQUssRUFBRTtvQkFDNUMsTUFBTW9CLEtBQUtGLEtBQUtqQjtvQkFDaEIsTUFBTW9CLEtBQUtGLEtBQUtqQjtvQkFDaEJ2VyxPQUFPMzdILElBQUksQ0FBQ3F6SSxJQUFJRDtvQkFDaEIsTUFBTUUsTUFBTUosS0FBS2hwRyxRQUFRaXBHO29CQUN6QixJQUFJdm5GLEtBQUssQ0FBQzBuRixNQUFNLEVBQUUsS0FBSyxHQUFHO3dCQUN4QjFuRixLQUFLLENBQUMwbkYsSUFBSSxHQUFHLENBQUNoQjtvQkFDaEIsT0FBTyxJQUFJMW1GLEtBQUssQ0FBQzBuRixJQUFJLEtBQUssR0FBRzt3QkFDM0IxbkYsS0FBSyxDQUFDMG5GLElBQUksR0FBR2hCO29CQUNmO29CQUNBLElBQUljLE9BQU8xNUksS0FBSzI1SSxPQUFPcnFJLEtBQUtrcUksT0FBT0YsTUFBTUcsT0FBT0YsSUFBSTt3QkFDbEQsSUFBSXJuRixLQUFLLENBQUM2bUYsR0FBRyxLQUFLLEdBQUc7NEJBQ25CRixPQUFPaDNJLEtBQUsrTCxHQUFHLENBQUNza0QsS0FBSyxDQUFDNm1GLEdBQUc7d0JBQzNCO3dCQUNBO29CQUNGLE9BQU87d0JBQ0xFLEtBQUtPO3dCQUNMTixLQUFLTzt3QkFDTEQsS0FBS0U7d0JBQ0xELEtBQUtFO29CQUNQO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBLE9BQU9iO0lBQ1Q7SUFDQSxPQUFPLENBQUNlLG9CQUFvQixDQUFDNVgsTUFBTSxFQUFFLzZHLEtBQUssRUFBRXJDLEdBQUcsRUFBRXVlLE1BQU07UUFDckQsSUFBSXZlLE1BQU1xQyxTQUFTLEdBQUc7WUFDcEIsSUFBSyxJQUFJbG5CLElBQUlrbkIsT0FBT2xuQixJQUFJNmtCLE1BQU0sR0FBRzdrQixLQUFLLEVBQUc7Z0JBQ3ZDb2pDLE9BQU85OEIsSUFBSSxDQUFDMjdILE1BQU0sQ0FBQ2ppSSxFQUFFLEVBQUVpaUksTUFBTSxDQUFDamlJLElBQUksRUFBRTtZQUN0QztZQUNBO1FBQ0Y7UUFDQSxNQUFNODVJLEtBQUs3WCxNQUFNLENBQUMvNkcsTUFBTTtRQUN4QixNQUFNNnlILEtBQUs5WCxNQUFNLENBQUMvNkcsUUFBUSxFQUFFO1FBQzVCLE1BQU04eUgsTUFBTS9YLE1BQU0sQ0FBQ3A5RyxNQUFNLEVBQUUsR0FBR2kxSDtRQUM5QixNQUFNRyxNQUFNaFksTUFBTSxDQUFDcDlHLE1BQU0sRUFBRSxHQUFHazFIO1FBQzlCLE1BQU1HLE9BQU9yNEksS0FBS3ErRCxLQUFLLENBQUM4NUUsS0FBS0M7UUFDN0IsTUFBTUUsT0FBT0gsTUFBTUU7UUFDbkIsTUFBTUUsT0FBT0gsTUFBTUM7UUFDbkIsTUFBTUcsS0FBS0YsT0FBT0osS0FBS0ssT0FBT047UUFDOUIsTUFBTXQrSCxJQUFJeStILE1BQU1EO1FBQ2hCLE1BQU1NLE9BQU8sSUFBSUo7UUFDakIsTUFBTUssTUFBTTE0SSxLQUFLMjRJLElBQUksQ0FBQ2gvSDtRQUN0QixNQUFNaS9ILFNBQVM1NEksS0FBSzA0RyxHQUFHLENBQUNnZ0M7UUFDeEIsTUFBTUcsU0FBUzc0SSxLQUFLeTRHLEdBQUcsQ0FBQ2lnQztRQUN4QixNQUFNSSxPQUFPTCxPQUFRejRJLENBQUFBLEtBQUsrTCxHQUFHLENBQUM2c0ksVUFBVTU0SSxLQUFLK0wsR0FBRyxDQUFDOHNJLE9BQU07UUFDdkQsTUFBTUUsT0FBT04sT0FBUSxLQUFJSyxPQUFPQSxRQUFRO1FBQ3hDLE1BQU1FLGFBQWFoNUksS0FBSzRQLEdBQUcsQ0FBQzVQLEtBQUsyNEksSUFBSSxDQUFDMzRJLEtBQUsrTCxHQUFHLENBQUM4c0ksU0FBU0QsVUFBVUcsT0FBTy80SSxLQUFLMjRJLElBQUksQ0FBQzM0SSxLQUFLK0wsR0FBRyxDQUFDOHNJLFNBQVNELFVBQVVHO1FBQy9HLElBQUlFLE9BQU87UUFDWCxJQUFJbHdJLFFBQVFzYztRQUNaLElBQUssSUFBSWxuQixJQUFJa25CLFFBQVEsR0FBR2xuQixJQUFJNmtCLE1BQU0sR0FBRzdrQixLQUFLLEVBQUc7WUFDM0MsTUFBTXlzQixJQUFJNXFCLEtBQUsrTCxHQUFHLENBQUN5c0ksS0FBS0YsT0FBT2xZLE1BQU0sQ0FBQ2ppSSxJQUFJLEVBQUUsR0FBR282SSxPQUFPblksTUFBTSxDQUFDamlJLEVBQUU7WUFDL0QsSUFBSXlzQixJQUFJcXVILE1BQU07Z0JBQ1psd0ksUUFBUTVLO2dCQUNSODZJLE9BQU9ydUg7WUFDVDtRQUNGO1FBQ0EsSUFBSXF1SCxPQUFPLENBQUNaLE9BQU9XLFVBQVMsS0FBTSxHQUFHO1lBQ25DLElBQUksQ0FBQyxDQUFDaEIsb0JBQW9CLENBQUM1WCxRQUFRLzZHLE9BQU90YyxRQUFRLEdBQUd3NEI7WUFDckQsSUFBSSxDQUFDLENBQUN5Mkcsb0JBQW9CLENBQUM1WCxRQUFRcjNILE9BQU9pYSxLQUFLdWU7UUFDakQsT0FBTztZQUNMQSxPQUFPOThCLElBQUksQ0FBQ3d6SSxJQUFJQztRQUNsQjtJQUNGO0lBQ0EsT0FBTyxDQUFDZ0IsY0FBYyxDQUFDOVksTUFBTTtRQUMzQixNQUFNNytGLFNBQVMsRUFBRTtRQUNqQixNQUFNL3dCLE1BQU00dkgsT0FBTzVtSSxNQUFNO1FBQ3pCLElBQUksQ0FBQyxDQUFDdytJLG9CQUFvQixDQUFDNVgsUUFBUSxHQUFHNXZILEtBQUsrd0I7UUFDM0NBLE9BQU85OEIsSUFBSSxDQUFDMjdILE1BQU0sQ0FBQzV2SCxNQUFNLEVBQUUsRUFBRTR2SCxNQUFNLENBQUM1dkgsTUFBTSxFQUFFO1FBQzVDLE9BQU8rd0IsT0FBTy9uQyxNQUFNLElBQUksSUFBSSxPQUFPK25DO0lBQ3JDO0lBQ0EsT0FBTyxDQUFDNDNHLGVBQWUsQ0FBQ255RyxHQUFHLEVBQUUySCxLQUFLLEVBQUVDLE1BQU0sRUFBRXdxRyxNQUFNLEVBQUVsRCxNQUFNLEVBQUVDLFVBQVU7UUFDcEUsTUFBTWtELFNBQVMsSUFBSTVqSSxhQUFhMGdJLGNBQWM7UUFDOUMsTUFBTW1ELFVBQVUsQ0FBQyxJQUFJRixVQUFVO1FBQy9CLE1BQU1HLFdBQVdwRCxjQUFjO1FBQy9CLElBQUssSUFBSWg0SSxJQUFJLEdBQUdBLElBQUlnNEksWUFBWWg0SSxJQUFLO1lBQ25DLE1BQU1nQyxJQUFJLENBQUNoQyxJQUFJbzdJLFFBQU8sS0FBTTtZQUM1QixJQUFLLElBQUk5ckksSUFBSSxHQUFHQSxJQUFJMG9JLFlBQVkxb0ksSUFBSztnQkFDbkM0ckksTUFBTSxDQUFDbDdJLElBQUlnNEksYUFBYTFvSSxFQUFFLEdBQUd6TixLQUFLdzVJLEdBQUcsQ0FBQyxDQUFDcjVJLElBQUksQ0FBQ3NOLElBQUk4ckksUUFBTyxLQUFNLEtBQUtEO1lBQ3BFO1FBQ0Y7UUFDQSxNQUFNRyxjQUFjLElBQUloa0ksYUFBYTtRQUNyQyxNQUFNaWtJLFVBQVUsQ0FBQyxJQUFJeEQsVUFBVTtRQUMvQixJQUFLLElBQUkvM0ksSUFBSSxHQUFHQSxJQUFJLEtBQUtBLElBQUs7WUFDNUJzN0ksV0FBVyxDQUFDdDdJLEVBQUUsR0FBRzZCLEtBQUt3NUksR0FBRyxDQUFDcjdJLEtBQUssSUFBSXU3STtRQUNyQztRQUNBLE1BQU1sUixJQUFJeGhHLElBQUl4dEMsTUFBTTtRQUNwQixNQUFNbWdKLE1BQU0sSUFBSTU3SSxXQUFXeXFJO1FBQzNCLE1BQU1vUixZQUFZLElBQUlwa0ksWUFBWTtRQUNsQyxJQUFLLElBQUlyWCxJQUFJLEdBQUdBLElBQUl5d0MsUUFBUXp3QyxJQUFLO1lBQy9CLElBQUssSUFBSXNQLElBQUksR0FBR0EsSUFBSWtoQyxPQUFPbGhDLElBQUs7Z0JBQzlCLE1BQU15cEksS0FBSy80SSxJQUFJd3dDLFFBQVFsaEM7Z0JBQ3ZCLE1BQU0rMEQsU0FBU3g3QixHQUFHLENBQUNrd0csR0FBRztnQkFDdEIsSUFBSTVwSSxNQUFNO2dCQUNWLElBQUl1c0ksT0FBTztnQkFDWCxJQUFLLElBQUlobUksSUFBSSxHQUFHQSxJQUFJc2lJLFlBQVl0aUksSUFBSztvQkFDbkMsTUFBTWhILElBQUkxTyxJQUFJMFYsSUFBSTBsSTtvQkFDbEIsSUFBSTFzSSxJQUFJLEtBQUtBLEtBQUsraEMsUUFBUTt3QkFDeEI7b0JBQ0Y7b0JBQ0EsSUFBSyxJQUFJb0gsSUFBSSxHQUFHQSxJQUFJbWdHLFlBQVluZ0csSUFBSzt3QkFDbkMsTUFBTTcxQyxJQUFJc04sSUFBSXVvQyxJQUFJdWpHO3dCQUNsQixJQUFJcDVJLElBQUksS0FBS0EsS0FBS3d1QyxPQUFPOzRCQUN2Qjt3QkFDRjt3QkFDQSxNQUFNbXJHLFlBQVk5eUcsR0FBRyxDQUFDbjZCLElBQUk4aEMsUUFBUXh1QyxFQUFFO3dCQUNwQyxNQUFNd3pDLElBQUkwbEcsTUFBTSxDQUFDeGxJLElBQUlzaUksYUFBYW5nRyxFQUFFLEdBQUd5akcsV0FBVyxDQUFDejVJLEtBQUsrTCxHQUFHLENBQUMrdEksWUFBWXQzRSxRQUFRO3dCQUNoRmwxRCxPQUFPd3NJLFlBQVlubUc7d0JBQ25Ca21HLFFBQVFsbUc7b0JBQ1Y7Z0JBQ0Y7Z0JBQ0EsTUFBTXdqRyxNQUFNd0MsR0FBRyxDQUFDekMsR0FBRyxHQUFHbDNJLEtBQUs2MUMsS0FBSyxDQUFDdm9DLE1BQU11c0k7Z0JBQ3ZDRCxTQUFTLENBQUN6QyxJQUFJO1lBQ2hCO1FBQ0Y7UUFDQSxPQUFPO1lBQUN3QztZQUFLQztTQUFVO0lBQ3pCO0lBQ0EsT0FBTyxDQUFDRyxZQUFZLENBQUMveUcsR0FBRztRQUN0QixNQUFNNHlHLFlBQVksSUFBSXBrSSxZQUFZO1FBQ2xDLEtBQUssTUFBTXVxQixLQUFLaUgsSUFBSztZQUNuQjR5RyxTQUFTLENBQUM3NUcsRUFBRTtRQUNkO1FBQ0EsT0FBTzY1RztJQUNUO0lBQ0EsT0FBTyxDQUFDSSxPQUFPLENBQUNoekcsR0FBRztRQUNqQixNQUFNd2hHLElBQUl4aEcsSUFBSXh0QyxNQUFNO1FBQ3BCLE1BQU1tZ0osTUFBTSxJQUFJbGxJLGtCQUFrQit6SCxLQUFLO1FBQ3ZDLElBQUk1NEgsTUFBTSxDQUFDaEU7UUFDWCxJQUFJekcsTUFBTXlHO1FBQ1YsSUFBSyxJQUFJek4sSUFBSSxHQUFHaW5DLEtBQUt1MEcsSUFBSW5nSixNQUFNLEVBQUUyRSxJQUFJaW5DLElBQUlqbkMsSUFBSztZQUM1QyxNQUFNZzVJLE1BQU13QyxHQUFHLENBQUN4N0ksRUFBRSxHQUFHNm9DLEdBQUcsQ0FBQzdvQyxLQUFLLEVBQUU7WUFDaEN5UixNQUFNNVAsS0FBSzRQLEdBQUcsQ0FBQ0EsS0FBS3VuSTtZQUNwQmh5SSxNQUFNbkYsS0FBS21GLEdBQUcsQ0FBQ0EsS0FBS2d5STtRQUN0QjtRQUNBLE1BQU12OUIsUUFBUSxNQUFPaHFHLENBQUFBLE1BQU16SyxHQUFFO1FBQzdCLElBQUssSUFBSWhILElBQUksR0FBR2luQyxLQUFLdTBHLElBQUluZ0osTUFBTSxFQUFFMkUsSUFBSWluQyxJQUFJam5DLElBQUs7WUFDNUN3N0ksR0FBRyxDQUFDeDdJLEVBQUUsR0FBRyxDQUFDdzdJLEdBQUcsQ0FBQ3g3SSxFQUFFLEdBQUdnSCxHQUFFLElBQUt5MEc7UUFDNUI7UUFDQSxPQUFPKy9CO0lBQ1Q7SUFDQSxPQUFPLENBQUNNLGNBQWMsQ0FBQ0wsU0FBUztRQUM5QixJQUFJejdJO1FBQ0osSUFBSSs3SSxJQUFJLENBQUN0dUk7UUFDVCxJQUFJdXVJLElBQUksQ0FBQ3Z1STtRQUNULE1BQU16RyxNQUFNeTBJLFVBQVV6YyxTQUFTLENBQUN2cEgsQ0FBQUEsSUFBS0EsTUFBTTtRQUMzQyxJQUFJOHNCLE1BQU12N0I7UUFDVixJQUFJaTFJLE9BQU9qMUk7UUFDWCxJQUFLaEgsSUFBSWdILEtBQUtoSCxJQUFJLEtBQUtBLElBQUs7WUFDMUIsTUFBTXlWLElBQUlnbUksU0FBUyxDQUFDejdJLEVBQUU7WUFDdEIsSUFBSXlWLElBQUlzbUksR0FBRztnQkFDVCxJQUFJLzdJLElBQUl1aUMsTUFBTXk1RyxHQUFHO29CQUNmQSxJQUFJaDhJLElBQUl1aUM7b0JBQ1IwNUcsT0FBT2o4SSxJQUFJO2dCQUNiO2dCQUNBKzdJLElBQUl0bUk7Z0JBQ0o4c0IsTUFBTXZpQztZQUNSO1FBQ0Y7UUFDQSxJQUFLQSxJQUFJaThJLE9BQU8sR0FBR2o4SSxLQUFLLEdBQUdBLElBQUs7WUFDOUIsSUFBSXk3SSxTQUFTLENBQUN6N0ksRUFBRSxHQUFHeTdJLFNBQVMsQ0FBQ3o3SSxJQUFJLEVBQUUsRUFBRTtnQkFDbkM7WUFDRjtRQUNGO1FBQ0EsT0FBT0E7SUFDVDtJQUNBLE9BQU8sQ0FBQ2s4SSxhQUFhLENBQUM5NkgsTUFBTTtRQUMxQixNQUFNKzZILGlCQUFpQi82SDtRQUN2QixNQUFNLEVBQ0pvdkIsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBR3J2QjtRQUNKLE1BQU0sRUFDSmcxQixNQUFNLEVBQ1AsR0FBRyxJQUFJLENBQUMsQ0FBQ3loRyxVQUFVO1FBQ3BCLElBQUlud0UsV0FBV2wzQjtRQUNmLElBQUltM0IsWUFBWWwzQjtRQUNoQixJQUFJRCxRQUFRNEYsVUFBVTNGLFNBQVMyRixRQUFRO1lBQ3JDLElBQUlnbUcsWUFBWTVyRztZQUNoQixJQUFJNnJHLGFBQWE1ckc7WUFDakIsSUFBSXFzRCxRQUFRajdGLEtBQUt5NkksSUFBSSxDQUFDejZJLEtBQUs0UCxHQUFHLENBQUMrK0IsT0FBT0MsVUFBVTJGO1lBQ2hELE1BQU1tbUcsU0FBUzE2SSxLQUFLQyxLQUFLLENBQUNnN0Y7WUFDMUJBLFFBQVFBLFVBQVV5L0MsU0FBU0EsU0FBUyxJQUFJQTtZQUN4QyxJQUFLLElBQUl2OEksSUFBSSxHQUFHQSxJQUFJODhGLE9BQU85OEYsSUFBSztnQkFDOUIwbkUsV0FBVzdsRSxLQUFLRCxJQUFJLENBQUN3NkksWUFBWTtnQkFDakN6MEUsWUFBWTlsRSxLQUFLRCxJQUFJLENBQUN5NkksYUFBYTtnQkFDbkMsTUFBTTM2RixZQUFZLElBQUkvZ0IsZ0JBQWdCK21DLFVBQVVDO2dCQUNoRCxNQUFNM3lCLE1BQU0wTSxVQUFVOUIsVUFBVSxDQUFDO2dCQUNqQzVLLElBQUlpTCxTQUFTLENBQUM3K0IsUUFBUSxHQUFHLEdBQUdnN0gsV0FBV0MsWUFBWSxHQUFHLEdBQUczMEUsVUFBVUM7Z0JBQ25FeTBFLFlBQVkxMEU7Z0JBQ1oyMEUsYUFBYTEwRTtnQkFDYixJQUFJdm1ELFdBQVcrNkgsZ0JBQWdCO29CQUM3Qi82SCxPQUFPNVksS0FBSztnQkFDZDtnQkFDQTRZLFNBQVNzZ0MsVUFBVUMscUJBQXFCO1lBQzFDO1lBQ0EsTUFBTTg1RCxRQUFRNTVHLEtBQUttRixHQUFHLENBQUNvdkMsU0FBU3N4QixVQUFVdHhCLFNBQVN1eEI7WUFDbkRELFdBQVc3bEUsS0FBSzYxQyxLQUFLLENBQUNnd0IsV0FBVyt6QztZQUNqQzl6QyxZQUFZOWxFLEtBQUs2MUMsS0FBSyxDQUFDaXdCLFlBQVk4ekM7UUFDckM7UUFDQSxNQUFNLzVELFlBQVksSUFBSS9nQixnQkFBZ0IrbUMsVUFBVUM7UUFDaEQsTUFBTTN5QixNQUFNME0sVUFBVTlCLFVBQVUsQ0FBQyxNQUFNO1lBQ3JDQyxvQkFBb0I7UUFDdEI7UUFDQTdLLElBQUlxMkMsU0FBUyxHQUFHO1FBQ2hCcjJDLElBQUlrbkQsUUFBUSxDQUFDLEdBQUcsR0FBR3gwQixVQUFVQztRQUM3QjN5QixJQUFJanJDLE1BQU0sR0FBRztRQUNiaXJDLElBQUlpTCxTQUFTLENBQUM3K0IsUUFBUSxHQUFHLEdBQUdBLE9BQU9vdkIsS0FBSyxFQUFFcHZCLE9BQU9xdkIsTUFBTSxFQUFFLEdBQUcsR0FBR2kzQixVQUFVQztRQUN6RSxNQUFNNjBFLFlBQVl4bkcsSUFBSWtMLFlBQVksQ0FBQyxHQUFHLEdBQUd3bkIsVUFBVUMsV0FBVy83RCxJQUFJO1FBQ2xFLE1BQU02d0ksV0FBVyxJQUFJLENBQUMsQ0FBQ1osT0FBTyxDQUFDVztRQUMvQixPQUFPO1lBQUNDO1lBQVUvMEU7WUFBVUM7U0FBVTtJQUN4QztJQUNBLE9BQU8rMEUsd0JBQXdCNzBILElBQUksRUFBRSxFQUNuQzJ1RCxVQUFVLEVBQ1ZtbUUsU0FBUyxFQUNUeGxFLFVBQVUsRUFDWCxFQUFFdm1DLFNBQVMsRUFBRUMsVUFBVSxFQUFFakIsUUFBUSxFQUFFNDRGLFdBQVcsRUFBRTtRQUMvQyxJQUFJN29GLFNBQVMsSUFBSWhmLGdCQUFnQixHQUFHO1FBQ3BDLElBQUlxVSxNQUFNMkssT0FBT0MsVUFBVSxDQUFDLE1BQU07WUFDaENzN0QsT0FBTztRQUNUO1FBQ0EsTUFBTTFrQixXQUFXO1FBQ2pCLE1BQU05aEIsT0FBTzEvQixJQUFJMC9CLElBQUksR0FBRyxDQUFDLEVBQUVpb0UsVUFBVSxDQUFDLEVBQUV4bEUsV0FBVyxDQUFDLEVBQUVxZixTQUFTLEdBQUcsRUFBRWhnQixXQUFXLENBQUM7UUFDaEYsTUFBTSxFQUNKK1EscUJBQXFCLEVBQ3JCQyxzQkFBc0IsRUFDdEJDLHVCQUF1QixFQUN2QkMsd0JBQXdCLEVBQ3hCNnpCLHFCQUFxQixFQUNyQkMsc0JBQXNCLEVBQ3RCaHJFLEtBQUssRUFDTixHQUFHd0UsSUFBSTB0RCxXQUFXLENBQUM3NkU7UUFDcEIsTUFBTSswSCxRQUFRO1FBQ2QsTUFBTTczRCxjQUFjbGpGLEtBQUtELElBQUksQ0FBQ0MsS0FBSzRQLEdBQUcsQ0FBQzVQLEtBQUsrTCxHQUFHLENBQUMyNUUseUJBQXlCMWxGLEtBQUsrTCxHQUFHLENBQUM0NUUsMkJBQTJCLEdBQUdoM0MsU0FBU29zRztRQUN6SCxNQUFNNTNELGVBQWVuakYsS0FBS0QsSUFBSSxDQUFDQyxLQUFLNFAsR0FBRyxDQUFDNVAsS0FBSytMLEdBQUcsQ0FBQzY1RSwyQkFBMkI1bEYsS0FBSytMLEdBQUcsQ0FBQzg1RSw2QkFBNkI4TyxVQUFVMzBGLEtBQUsrTCxHQUFHLENBQUMydEcseUJBQXlCMTVHLEtBQUsrTCxHQUFHLENBQUM0dEcsMkJBQTJCaGxCLFlBQVlvbUQ7UUFDOU1qOUYsU0FBUyxJQUFJaGYsZ0JBQWdCb2tELGFBQWFDO1FBQzFDaHdDLE1BQU0ySyxPQUFPQyxVQUFVLENBQUMsTUFBTTtZQUM1QnM3RCxPQUFPO1lBQ1ByN0Qsb0JBQW9CO1FBQ3RCO1FBQ0E3SyxJQUFJMC9CLElBQUksR0FBR0E7UUFDWDEvQixJQUFJanJDLE1BQU0sR0FBRztRQUNiaXJDLElBQUlxMkMsU0FBUyxHQUFHO1FBQ2hCcjJDLElBQUlrbkQsUUFBUSxDQUFDLEdBQUcsR0FBR25YLGFBQWFDO1FBQ2hDaHdDLElBQUlxMkMsU0FBUyxHQUFHO1FBQ2hCcjJDLElBQUlraEMsUUFBUSxDQUFDcnVELE1BQU1rOUQsY0FBZTYzRCxDQUFBQSxRQUFRLEtBQUssR0FBRzUzRCxlQUFnQixLQUFJNDNELEtBQUksSUFBSztRQUMvRSxNQUFNSCxXQUFXLElBQUksQ0FBQyxDQUFDWixPQUFPLENBQUM3bUcsSUFBSWtMLFlBQVksQ0FBQyxHQUFHLEdBQUc2a0MsYUFBYUMsY0FBY3A1RSxJQUFJO1FBQ3JGLE1BQU02dkksWUFBWSxJQUFJLENBQUMsQ0FBQ0csWUFBWSxDQUFDYTtRQUNyQyxNQUFNOUQsWUFBWSxJQUFJLENBQUMsQ0FBQ21ELGNBQWMsQ0FBQ0w7UUFDdkMsTUFBTW9CLGNBQWMsSUFBSSxDQUFDLENBQUNuRSxZQUFZLENBQUMrRCxVQUFVMTNELGFBQWFDLGNBQWMyekQ7UUFDNUUsT0FBTyxJQUFJLENBQUNtRSxpQkFBaUIsQ0FBQztZQUM1QnZqRyxPQUFPO2dCQUNMd2pHLFFBQVFGO2dCQUNScnNHLE9BQU91MEM7Z0JBQ1B0MEMsUUFBUXUwQztZQUNWO1lBQ0FwMEM7WUFDQUM7WUFDQWpCO1lBQ0E0NEY7WUFDQXdVLFlBQVk7WUFDWkMsYUFBYTtRQUNmO0lBQ0Y7SUFDQSxPQUFPcnFJLFFBQVF3TyxNQUFNLEVBQUV3dkIsU0FBUyxFQUFFQyxVQUFVLEVBQUVqQixRQUFRLEVBQUU0NEYsV0FBVyxFQUFFO1FBQ25FLE1BQU0sQ0FBQ2lVLFVBQVVqc0csT0FBT0MsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDeXJHLGFBQWEsQ0FBQzk2SDtRQUN0RCxNQUFNLENBQUNyaEIsUUFBUTA3SSxVQUFVLEdBQUcsSUFBSSxDQUFDLENBQUNULGVBQWUsQ0FBQ3lCLFVBQVVqc0csT0FBT0MsUUFBUTV1QyxLQUFLcStELEtBQUssQ0FBQzF2QixPQUFPQyxVQUFVLElBQUksQ0FBQyxDQUFDb25HLFVBQVUsQ0FBQ0MsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDRCxVQUFVLENBQUNFLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQ0YsVUFBVSxDQUFDRyxVQUFVO1FBQzFMLE1BQU1XLFlBQVksSUFBSSxDQUFDLENBQUNtRCxjQUFjLENBQUNMO1FBQ3ZDLE1BQU1vQixjQUFjLElBQUksQ0FBQyxDQUFDbkUsWUFBWSxDQUFDMzRJLFFBQVF5d0MsT0FBT0MsUUFBUWtvRztRQUM5RCxPQUFPLElBQUksQ0FBQ21FLGlCQUFpQixDQUFDO1lBQzVCdmpHLE9BQU87Z0JBQ0x3akcsUUFBUUY7Z0JBQ1Jyc0c7Z0JBQ0FDO1lBQ0Y7WUFDQUc7WUFDQUM7WUFDQWpCO1lBQ0E0NEY7WUFDQXdVLFlBQVk7WUFDWkMsYUFBYTtRQUNmO0lBQ0Y7SUFDQSxPQUFPSCxrQkFBa0IsRUFDdkJ2akcsS0FBSyxFQUNMM0ksU0FBUyxFQUNUQyxVQUFVLEVBQ1ZqQixRQUFRLEVBQ1I0NEYsV0FBVyxFQUNYd1UsVUFBVSxFQUNWQyxXQUFXLEVBQ1osRUFBRTtRQUNELElBQUlydEcsV0FBVyxRQUFRLEdBQUc7WUFDeEIsQ0FBQ2dCLFdBQVdDLFdBQVcsR0FBRztnQkFBQ0E7Z0JBQVlEO2FBQVU7UUFDbkQ7UUFDQSxNQUFNLEVBQ0ptc0csTUFBTSxFQUNOdnNHLEtBQUssRUFDTEMsTUFBTSxFQUNQLEdBQUc4STtRQUNKLE1BQU02b0YsWUFBWTdvRixNQUFNNm9GLFNBQVMsSUFBSTtRQUNyQyxNQUFNOGEsaUJBQWlCLEVBQUU7UUFDekIsTUFBTXpoQyxRQUFRNTVHLEtBQUttRixHQUFHLENBQUM0cEMsWUFBWUosT0FBT0ssYUFBYUo7UUFDdkQsTUFBTTBzRyxTQUFTMWhDLFFBQVE3cUU7UUFDdkIsTUFBTXdzRyxTQUFTM2hDLFFBQVE1cUU7UUFDdkIsTUFBTXdzRyxZQUFZLEVBQUU7UUFDcEIsS0FBSyxNQUFNLEVBQ1RwYixNQUFNLEVBQ1AsSUFBSThhLE9BQVE7WUFDWCxNQUFNTyxnQkFBZ0JOLGFBQWEsSUFBSSxDQUFDLENBQUNqQyxjQUFjLENBQUM5WSxVQUFVQTtZQUNsRSxJQUFJLENBQUNxYixlQUFlO2dCQUNsQjtZQUNGO1lBQ0FELFVBQVUvMkksSUFBSSxDQUFDZzNJO1lBQ2YsTUFBTWpySSxNQUFNaXJJLGNBQWNqaUosTUFBTTtZQUNoQyxNQUFNa2lKLFlBQVksSUFBSWptSSxhQUFhakY7WUFDbkMsTUFBTW1uQyxPQUFPLElBQUlsaUMsYUFBYSxJQUFLakYsQ0FBQUEsUUFBUSxJQUFJLElBQUlBLE1BQU07WUFDekQ2cUksZUFBZTUySSxJQUFJLENBQUM7Z0JBQ2xCa3pDO2dCQUNBeW9GLFFBQVFzYjtZQUNWO1lBQ0EsSUFBSWxySSxRQUFRLEdBQUc7Z0JBQ2JrckksU0FBUyxDQUFDLEVBQUUsR0FBR0QsYUFBYSxDQUFDLEVBQUUsR0FBR0g7Z0JBQ2xDSSxTQUFTLENBQUMsRUFBRSxHQUFHRCxhQUFhLENBQUMsRUFBRSxHQUFHRjtnQkFDbEM1akcsS0FBSzUxQyxHQUFHLENBQUM7b0JBQUMrSjtvQkFBS0E7b0JBQUtBO29CQUFLQTtvQkFBSzR2SSxTQUFTLENBQUMsRUFBRTtvQkFBRUEsU0FBUyxDQUFDLEVBQUU7aUJBQUMsRUFBRTtnQkFDM0Q7WUFDRjtZQUNBLElBQUksQ0FBQ2g0RyxJQUFJQyxJQUFJRSxJQUFJRSxHQUFHLEdBQUcwM0c7WUFDdkIvM0csTUFBTTQzRztZQUNOMzNHLE1BQU00M0c7WUFDTjEzRyxNQUFNeTNHO1lBQ052M0csTUFBTXczRztZQUNORyxVQUFVMzVJLEdBQUcsQ0FBQztnQkFBQzJoQztnQkFBSUM7Z0JBQUlFO2dCQUFJRTthQUFHLEVBQUU7WUFDaEM0VCxLQUFLNTFDLEdBQUcsQ0FBQztnQkFBQytKO2dCQUFLQTtnQkFBS0E7Z0JBQUtBO2dCQUFLNDNCO2dCQUFJQzthQUFHLEVBQUU7WUFDdkMsSUFBSyxJQUFJeGxDLElBQUksR0FBR0EsSUFBSXFTLEtBQUtyUyxLQUFLLEVBQUc7Z0JBQy9CLE1BQU1nQyxJQUFJdTdJLFNBQVMsQ0FBQ3Y5SSxFQUFFLEdBQUdzOUksYUFBYSxDQUFDdDlJLEVBQUUsR0FBR205STtnQkFDNUMsTUFBTXp1SSxJQUFJNnVJLFNBQVMsQ0FBQ3Y5SSxJQUFJLEVBQUUsR0FBR3M5SSxhQUFhLENBQUN0OUksSUFBSSxFQUFFLEdBQUdvOUk7Z0JBQ3BENWpHLEtBQUs1MUMsR0FBRyxDQUFDa2tJLFFBQVFRLGtCQUFrQixDQUFDL2lHLElBQUlDLElBQUlFLElBQUlFLElBQUk1akMsR0FBRzBNLElBQUksQ0FBQzFPLElBQUksS0FBSztnQkFDckUsQ0FBQ3VsQyxJQUFJQyxJQUFJRSxJQUFJRSxHQUFHLEdBQUc7b0JBQUNGO29CQUFJRTtvQkFBSTVqQztvQkFBRzBNO2lCQUFFO1lBQ25DO1FBQ0Y7UUFDQSxJQUFJd3VJLGVBQWU3aEosTUFBTSxLQUFLLEdBQUc7WUFDL0IsT0FBTztRQUNUO1FBQ0EsTUFBTTR1SSxVQUFVZ1QsY0FBYyxJQUFJeEYsdUJBQXVCLElBQUl0QztRQUM3RGxMLFFBQVE3ZSxLQUFLLENBQUM4eEIsZ0JBQWdCdHNHLFdBQVdDLFlBQVksR0FBR2pCLFVBQVVxdEcsY0FBYyxJQUFJN2EsV0FBV29HO1FBQy9GLE9BQU87WUFDTHlCO1lBQ0FvVDtZQUNBSjtZQUNBN2E7WUFDQTV4RjtZQUNBQztRQUNGO0lBQ0Y7SUFDQSxhQUFhK3NHLGtCQUFrQixFQUM3QnJSLFFBQVEsRUFDUjhRLFdBQVcsRUFDWDdhLFNBQVMsRUFDVDV4RixLQUFLLEVBQ0xDLE1BQU0sRUFDUCxFQUFFO1FBQ0QsSUFBSWd0RyxVQUFVaHdJO1FBQ2QsSUFBSWl3SSxVQUFVLENBQUNqd0k7UUFDZixJQUFJa3dJLGlCQUFpQjtRQUNyQixLQUFLLE1BQU0xYixVQUFVa0ssU0FBVTtZQUM3QndSLGtCQUFrQjFiLE9BQU81bUksTUFBTTtZQUMvQixJQUFLLElBQUkyRSxJQUFJLEdBQUdpbkMsS0FBS2c3RixPQUFPNW1JLE1BQU0sRUFBRTJFLElBQUlpbkMsSUFBSWpuQyxJQUFLO2dCQUMvQyxNQUFNNDlJLEtBQUszYixNQUFNLENBQUNqaUksRUFBRSxHQUFHaWlJLE1BQU0sQ0FBQ2ppSSxJQUFJLEVBQUU7Z0JBQ3BDeTlJLFVBQVU1N0ksS0FBS21GLEdBQUcsQ0FBQ3kySSxTQUFTRztnQkFDNUJGLFVBQVU3N0ksS0FBSzRQLEdBQUcsQ0FBQ2lzSSxTQUFTRTtZQUM5QjtRQUNGO1FBQ0EsSUFBSUM7UUFDSixJQUFJSixXQUFXLENBQUMsT0FBT0MsV0FBVyxLQUFLO1lBQ3JDRyxhQUFhem5JO1FBQ2YsT0FBTyxJQUFJcW5JLFdBQVcsQ0FBQyxTQUFTQyxXQUFXLE9BQU87WUFDaERHLGFBQWEzbUk7UUFDZixPQUFPO1lBQ0wybUksYUFBYXptSTtRQUNmO1FBQ0EsTUFBTS9FLE1BQU04NUgsU0FBUzl3SSxNQUFNO1FBQzNCLE1BQU15aUosZUFBZXBHLHFCQUFxQkMsMkJBQTJCdGxJO1FBQ3JFLE1BQU11dUgsU0FBUyxJQUFJdnBILFlBQVl5bUk7UUFDL0IsSUFBSW5vRSxTQUFTO1FBQ2JpckQsTUFBTSxDQUFDanJELFNBQVMsR0FBR21vRSxlQUFlem1JLFlBQVkwbUksaUJBQWlCLEdBQUcsQ0FBQ0osaUJBQWlCLElBQUl0ckksR0FBRSxJQUFLd3JJLFdBQVdFLGlCQUFpQjtRQUMzSG5kLE1BQU0sQ0FBQ2pyRCxTQUFTLEdBQUc7UUFDbkJpckQsTUFBTSxDQUFDanJELFNBQVMsR0FBR25sQztRQUNuQm93RixNQUFNLENBQUNqckQsU0FBUyxHQUFHbGxDO1FBQ25CbXdGLE1BQU0sQ0FBQ2pyRCxTQUFTLEdBQUdzbkUsY0FBYyxJQUFJO1FBQ3JDcmMsTUFBTSxDQUFDanJELFNBQVMsR0FBRzl6RSxLQUFLNFAsR0FBRyxDQUFDLEdBQUc1UCxLQUFLQyxLQUFLLENBQUNzZ0ksYUFBYTtRQUN2RHhCLE1BQU0sQ0FBQ2pyRCxTQUFTLEdBQUd0akU7UUFDbkJ1dUgsTUFBTSxDQUFDanJELFNBQVMsR0FBR2tvRSxXQUFXRSxpQkFBaUI7UUFDL0MsS0FBSyxNQUFNOWIsVUFBVWtLLFNBQVU7WUFDN0J2TCxNQUFNLENBQUNqckQsU0FBUyxHQUFHc3NELE9BQU81bUksTUFBTSxHQUFHO1lBQ25DdWxJLE1BQU0sQ0FBQ2pyRCxTQUFTLEdBQUdzc0QsTUFBTSxDQUFDLEVBQUU7WUFDNUJyQixNQUFNLENBQUNqckQsU0FBUyxHQUFHc3NELE1BQU0sQ0FBQyxFQUFFO1FBQzlCO1FBQ0EsTUFBTTEwQyxLQUFLLElBQUl5d0Qsa0JBQWtCO1FBQ2pDLE1BQU1DLFNBQVMxd0QsR0FBRzd1RixRQUFRLENBQUN3L0ksU0FBUztRQUNwQyxNQUFNRCxPQUFPN2dFLEtBQUs7UUFDbEI2Z0UsT0FBTzExSSxLQUFLLENBQUNxNEg7UUFDYixNQUFNdWQsYUFBYU4sV0FBV2wvSSxTQUFTLENBQUNGLFdBQVc7UUFDbkQsS0FBSyxNQUFNd2pJLFVBQVVrSyxTQUFVO1lBQzdCLE1BQU1pUyxRQUFRLElBQUlELFdBQVdsYyxPQUFPNW1JLE1BQU0sR0FBRztZQUM3QyxJQUFLLElBQUkyRSxJQUFJLEdBQUdpbkMsS0FBS2c3RixPQUFPNW1JLE1BQU0sRUFBRTJFLElBQUlpbkMsSUFBSWpuQyxJQUFLO2dCQUMvQ28rSSxLQUFLLENBQUNwK0ksSUFBSSxFQUFFLEdBQUdpaUksTUFBTSxDQUFDamlJLEVBQUUsR0FBR2lpSSxNQUFNLENBQUNqaUksSUFBSSxFQUFFO1lBQzFDO1lBQ0FpK0ksT0FBTzExSSxLQUFLLENBQUM2MUk7UUFDZjtRQUNBSCxPQUFPejFJLEtBQUs7UUFDWixNQUFNcWdDLE1BQU0sTUFBTSxJQUFJdzFHLFNBQVM5d0QsR0FBRyt3RCxRQUFRLEVBQUVsZ0ksV0FBVztRQUN2RCxNQUFNOVcsUUFBUSxJQUFJMUgsV0FBV2lwQztRQUM3QixPQUFPZSxhQUFhdGlDO0lBQ3RCO0lBQ0EsYUFBYWkzSSxvQkFBb0JDLGFBQWEsRUFBRTtRQUM5QyxJQUFJO1lBQ0YsTUFBTWwzSSxRQUFRd2lDLGVBQWUwMEc7WUFDN0IsTUFBTSxFQUNKRixRQUFRLEVBQ1I1L0ksUUFBUSxFQUNULEdBQUcsSUFBSSsvSSxvQkFBb0I7WUFDNUIsTUFBTVIsU0FBU3YvSSxTQUFTdy9JLFNBQVM7WUFDakMsTUFBTUQsT0FBTzdnRSxLQUFLO1lBQ2xCNmdFLE9BQU8xMUksS0FBSyxDQUFDakIsT0FBTzA0QyxJQUFJLENBQUM7Z0JBQ3ZCLE1BQU1pK0YsT0FBTzdnRSxLQUFLO2dCQUNsQixNQUFNNmdFLE9BQU96MUksS0FBSztZQUNwQixHQUFHODFFLEtBQUssQ0FBQyxLQUFPO1lBQ2hCLElBQUkxeUUsT0FBTztZQUNYLElBQUkrcEUsU0FBUztZQUNiLFdBQVcsTUFBTTNzRCxTQUFTczFILFNBQVU7Z0JBQ2xDMXlJLFNBQVMsSUFBSWhNLFdBQVcsSUFBSXlYLFlBQVkyUixNQUFNanBCLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFO2dCQUM5RDZMLEtBQUtoSSxHQUFHLENBQUNvbEIsT0FBTzJzRDtnQkFDaEJBLFVBQVUzc0QsTUFBTTN0QixNQUFNO1lBQ3hCO1lBQ0EsTUFBTXVsSSxTQUFTLElBQUl2cEgsWUFBWXpMLEtBQUs3TCxNQUFNLEVBQUUsR0FBRzZMLEtBQUt2USxNQUFNLElBQUk7WUFDOUQsTUFBTXFYLFVBQVVrdUgsTUFBTSxDQUFDLEVBQUU7WUFDekIsSUFBSWx1SCxZQUFZLEdBQUc7Z0JBQ2pCLE1BQU0sSUFBSThHLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRTlHLFFBQVEsQ0FBQztZQUMvQztZQUNBLE1BQU04OUIsUUFBUW93RixNQUFNLENBQUMsRUFBRTtZQUN2QixNQUFNbndGLFNBQVNtd0YsTUFBTSxDQUFDLEVBQUU7WUFDeEIsTUFBTXFjLGNBQWNyYyxNQUFNLENBQUMsRUFBRSxLQUFLO1lBQ2xDLE1BQU13QixZQUFZeEIsTUFBTSxDQUFDLEVBQUU7WUFDM0IsTUFBTThkLG1CQUFtQjlkLE1BQU0sQ0FBQyxFQUFFO1lBQ2xDLE1BQU1pZCxhQUFhamQsTUFBTSxDQUFDLEVBQUU7WUFDNUIsTUFBTXVMLFdBQVcsRUFBRTtZQUNuQixNQUFNd1MsY0FBYyxDQUFDakgscUJBQXFCQywyQkFBMkIrRyxnQkFBZSxJQUFLcm5JLFlBQVkwbUksaUJBQWlCO1lBQ3RILElBQUlLO1lBQ0osT0FBUVA7Z0JBQ04sS0FBS3puSSxVQUFVMm5JLGlCQUFpQjtvQkFDOUJLLFFBQVEsSUFBSWhvSSxVQUFVeEssS0FBSzdMLE1BQU0sRUFBRTQrSTtvQkFDbkM7Z0JBQ0YsS0FBS3puSSxXQUFXNm1JLGlCQUFpQjtvQkFDL0JLLFFBQVEsSUFBSWxuSSxXQUFXdEwsS0FBSzdMLE1BQU0sRUFBRTQrSTtvQkFDcEM7Z0JBQ0YsS0FBS3ZuSSxXQUFXMm1JLGlCQUFpQjtvQkFDL0JLLFFBQVEsSUFBSWhuSSxXQUFXeEwsS0FBSzdMLE1BQU0sRUFBRTQrSTtvQkFDcEM7WUFDSjtZQUNBaHBFLFNBQVM7WUFDVCxJQUFLLElBQUkzMUUsSUFBSSxHQUFHQSxJQUFJMCtJLGtCQUFrQjErSSxJQUFLO2dCQUN6QyxNQUFNcVMsTUFBTXV1SCxNQUFNLENBQUMrVywyQkFBMkIzM0ksSUFBSTAzSSxtQkFBbUI7Z0JBQ3JFLE1BQU16VixTQUFTLElBQUkzcUgsYUFBYWpGLE1BQU07Z0JBQ3RDODVILFNBQVM3bEksSUFBSSxDQUFDMjdIO2dCQUNkLElBQUssSUFBSTN5SCxJQUFJLEdBQUdBLElBQUlxb0ksMkJBQTJCLEdBQUdyb0ksSUFBSztvQkFDckQyeUgsTUFBTSxDQUFDM3lILEVBQUUsR0FBR3N4SCxNQUFNLENBQUMrVywyQkFBMkIzM0ksSUFBSTAzSSxxQkFBcUJwb0ksSUFBSSxFQUFFO2dCQUMvRTtnQkFDQSxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSStDLEtBQUsvQyxJQUFLO29CQUM1QjJ5SCxNQUFNLENBQUMzeUgsSUFBSSxFQUFFLEdBQUcyeUgsTUFBTSxDQUFDM3lILEVBQUUsR0FBRzh1SSxLQUFLLENBQUN6b0UsU0FBUztnQkFDN0M7WUFDRjtZQUNBLE9BQU87Z0JBQ0xzbkU7Z0JBQ0E3YTtnQkFDQStKO2dCQUNBMzdGO2dCQUNBQztZQUNGO1FBQ0YsRUFBRSxPQUFPNS9CLEdBQUc7WUFDVitzQixLQUFLLENBQUMscUJBQXFCLEVBQUUvc0IsRUFBRSxDQUFDO1lBQ2hDLE9BQU87UUFDVDtJQUNGO0FBQ0Y7RUFFQyxvQ0FBb0M7QUFVckMsTUFBTSt0SSx5QkFBeUI1TztJQUM3QnZ4SSxhQUFjO1FBQ1osS0FBSztRQUNMLEtBQUssQ0FBQyt2SSxpQkFBaUI7WUFDckI5MUcsTUFBTTJuQyxpQkFBaUIrQyxpQkFBaUI7WUFDeEMsZ0JBQWdCO1FBQ2xCO0lBQ0Y7SUFDQXgrRCxRQUFRO1FBQ04sTUFBTUEsUUFBUSxJQUFJZzZJO1FBQ2xCaDZJLE1BQU15ckksU0FBUyxDQUFDLElBQUk7UUFDcEIsT0FBT3pySTtJQUNUO0FBQ0Y7QUFDQSxNQUFNaTZJLDhCQUE4QnhIO0lBQ2xDNTRJLFlBQVk2NEksZ0JBQWdCLENBQUU7UUFDNUIsS0FBSyxDQUFDQTtRQUNOLEtBQUssQ0FBQzlJLGlCQUFpQjtZQUNyQmgyRyxRQUFRNm5DLGlCQUFpQitDLGlCQUFpQjtZQUMxQyxnQkFBZ0I7UUFDbEI7SUFDRjtJQUNBeCtELFFBQVE7UUFDTixNQUFNQSxRQUFRLElBQUlpNkksc0JBQXNCLElBQUksQ0FBQ3RILGVBQWU7UUFDNUQzeUksTUFBTXlySSxTQUFTLENBQUMsSUFBSTtRQUNwQixPQUFPenJJO0lBQ1Q7QUFDRjtBQUNBLE1BQU1rNkksd0JBQXdCeE87SUFDNUIsQ0FBQ3lPLFdBQVcsQ0FBUztJQUNyQixDQUFDOWdHLFdBQVcsQ0FBUTtJQUNwQixDQUFDdWdHLGFBQWEsQ0FBUTtJQUN0QixDQUFDUSxhQUFhLENBQVE7O2FBQ2Y5N0UsUUFBUTs7O2FBQ1IzUCxjQUFjbGtDLHFCQUFxQk8sU0FBUzs7O2FBQzVDd2lILHlCQUF5Qjs7SUFDaEMzekksWUFBWTZXLE1BQU0sQ0FBRTtRQUNsQixLQUFLLENBQUM7WUFDSixHQUFHQSxNQUFNO1lBQ1RrN0gsaUJBQWlCO1lBQ2pCcnlJLE1BQU07UUFDUjthQVpGLENBQUM0Z0osV0FBVyxHQUFHO2FBQ2YsQ0FBQzlnRyxXQUFXLEdBQUc7YUFDZixDQUFDdWdHLGFBQWEsR0FBRzthQUNqQixDQUFDUSxhQUFhLEdBQUc7UUFVZixJQUFJLENBQUN2OEUsb0JBQW9CLEdBQUc7UUFDNUIsSUFBSSxDQUFDLENBQUMrN0UsYUFBYSxHQUFHbHBJLE9BQU9rcEksYUFBYSxJQUFJO1FBQzlDLElBQUksQ0FBQyxDQUFDdmdHLFdBQVcsR0FBRztRQUNwQixJQUFJLENBQUN1dEIsYUFBYSxHQUFHO0lBQ3ZCO0lBQ0EsT0FBT3RSLFdBQVdDLElBQUksRUFBRTliLFNBQVMsRUFBRTtRQUNqQ2dpQixpQkFBaUJuRyxVQUFVLENBQUNDLE1BQU05YjtRQUNsQyxJQUFJLENBQUMrekYsc0JBQXNCLEdBQUcsSUFBSXdNO1FBQ2xDLElBQUksQ0FBQ0ssNkJBQTZCLEdBQUcsSUFBSUosc0JBQXNCeGdHLFVBQVVpTCxjQUFjO0lBQ3pGO0lBQ0EsT0FBT3lvRix5QkFBeUIzekksT0FBTyxFQUFFO1FBQ3ZDLE1BQU13RyxRQUFRLElBQUksQ0FBQ3d0SSxzQkFBc0IsQ0FBQ3h0SSxLQUFLO1FBQy9DQSxNQUFNNHBJLGdCQUFnQixDQUFDcHdJO1FBQ3ZCLE9BQU93RztJQUNUO0lBQ0EsV0FBV3N0SSwwQkFBMEI7UUFDbkMsT0FBTztJQUNUO0lBQ0EsV0FBV0QsV0FBVztRQUNwQixPQUFPcHpHLE9BQU8sSUFBSSxFQUFFLFlBQVksSUFBSTBKO0lBQ3RDO0lBQ0EsV0FBVzQ2QixXQUFXO1FBQ3BCLE9BQU87SUFDVDtJQUNBLElBQUl3TSxxQkFBcUI7UUFDdkIsT0FBTztZQUNMM3JFLE1BQU07WUFDTms3SSxnQkFBZ0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDamhHLFdBQVc7UUFDckM7SUFDRjtJQUNBLE9BQU95MEIsMEJBQTBCOW1FLElBQUksRUFBRTtRQUNyQyxNQUFNdXpJLHNCQUFzQnZ6SSxLQUFLdE8sR0FBRyxDQUFDO1FBQ3JDLE9BQU87WUFDTGd0RSxZQUFZNjBFLG9CQUFvQjdoSixHQUFHLENBQUMsU0FBUztZQUM3QzhoSixjQUFjRCxvQkFBb0I3aEosR0FBRyxDQUFDLFVBQVU7UUFDbEQ7SUFDRjtJQUNBLElBQUkwZ0IsY0FBYztRQUNoQixPQUFPO0lBQ1Q7SUFDQThxQyxrQkFBa0I7UUFDaEIsSUFBSSxJQUFJLENBQUNxb0YsT0FBTyxLQUFLLE1BQU07WUFDekI7UUFDRjtRQUNBLEtBQUssQ0FBQ3JvRjtJQUNSO0lBQ0E5YixTQUFTO1FBQ1AsSUFBSSxJQUFJLENBQUNPLEdBQUcsRUFBRTtZQUNaLE9BQU8sSUFBSSxDQUFDQSxHQUFHO1FBQ2pCO1FBQ0EsSUFBSTQzQixPQUFPQztRQUNYLE1BQU0sRUFDSmhELE9BQU8sRUFDUixHQUFHLElBQUk7UUFDUixJQUFJQSxTQUFTO1lBQ1gsSUFBSSxDQUFDQSxPQUFPLEdBQUc7WUFDZitDLFFBQVEsSUFBSSxDQUFDbmpFLENBQUM7WUFDZG9qRSxRQUFRLElBQUksQ0FBQzEyRCxDQUFDO1FBQ2hCO1FBQ0EsS0FBSyxDQUFDcytCO1FBQ04sSUFBSSxJQUFJLENBQUNta0csT0FBTyxLQUFLLE1BQU07WUFDekIsSUFBSSxJQUFJLENBQUMsQ0FBQ3FOLGFBQWEsRUFBRTtnQkFDdkIsTUFBTSxFQUNKamxHLEtBQUssRUFDTHlqRyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWGgvRixXQUFXLEVBQ1hvaEcsSUFBSSxFQUNKQyxZQUFZLEVBQ2IsR0FBRyxJQUFJLENBQUMsQ0FBQ2QsYUFBYTtnQkFDdkIsTUFBTSxFQUNKOXRHLFNBQVMsRUFDUEUsU0FBUyxFQUNUQyxVQUFVLEVBQ1gsRUFDRGpCLFFBQVEsRUFDVCxHQUFHLElBQUksQ0FBQ2pDLE1BQU0sQ0FBQ0gsUUFBUTtnQkFDeEIsTUFBTXk4RixVQUFVMk4sbUJBQW1Ca0YsaUJBQWlCLENBQUM7b0JBQ25EdmpHO29CQUNBM0k7b0JBQ0FDO29CQUNBakI7b0JBQ0E0NEYsYUFBYXNXLGdCQUFnQjVOLGFBQWE7b0JBQzFDOEw7b0JBQ0FDO2dCQUNGO2dCQUNBLElBQUksQ0FBQ3NDLFlBQVksQ0FBQ3RWLFNBQVNxVixjQUFjcmhHLGFBQWFvaEc7WUFDeEQsT0FBTztnQkFDTCxJQUFJLENBQUM5eEcsR0FBRyxDQUFDdkIsWUFBWSxDQUFDLGtCQUFrQjNtQixLQUFLb3FDLFNBQVMsQ0FBQztvQkFDckR4UixhQUFhO2dCQUNmO2dCQUNBLElBQUksQ0FBQzFRLEdBQUcsQ0FBQ1csTUFBTSxHQUFHO2dCQUNsQixJQUFJLENBQUNzTixVQUFVLENBQUNrUixZQUFZLENBQUMsSUFBSTtZQUNuQztRQUNGLE9BQU87WUFDTCxJQUFJLENBQUNuZixHQUFHLENBQUN2QixZQUFZLENBQUMsa0JBQWtCM21CLEtBQUtvcUMsU0FBUyxDQUFDO2dCQUNyRHhSLGFBQWEsSUFBSSxDQUFDLENBQUNBLFdBQVcsSUFBSTtZQUNwQztRQUNGO1FBQ0EsSUFBSW1rQixTQUFTO1lBQ1gsSUFBSSxDQUFDQSxPQUFPLEdBQUc7WUFDZixJQUFJLENBQUM4QyxlQUFlLENBQUNDLE9BQU9DO1FBQzlCO1FBQ0EsT0FBTyxJQUFJLENBQUM3M0IsR0FBRztJQUNqQjtJQUNBaXlHLFFBQVFILElBQUksRUFBRTtRQUNaLElBQUksQ0FBQyxDQUFDTCxhQUFhLEdBQUdLO1FBQ3RCLElBQUksQ0FBQzcxRSxjQUFjO0lBQ3JCO0lBQ0E5Z0MsVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDLENBQUNzMkcsYUFBYTtJQUM1QjtJQUNBLElBQUkvZ0csY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQyxDQUFDQSxXQUFXO0lBQzFCO0lBQ0EsSUFBSUEsWUFBWUEsV0FBVyxFQUFFO1FBQzNCLElBQUksQ0FBQyxDQUFDQSxXQUFXLEdBQUdBO1FBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMxUSxHQUFHLEVBQUU7WUFDYjtRQUNGO1FBQ0EsSUFBSSxDQUFDQSxHQUFHLENBQUN2QixZQUFZLENBQUMsa0JBQWtCM21CLEtBQUtvcUMsU0FBUyxDQUFDO1lBQ3JEeFI7UUFDRjtRQUNBLEtBQUssQ0FBQ3VyQixpQkFBaUJ4cEIsSUFBSSxDQUFDeEYsQ0FBQUE7WUFDMUJBLFNBQVN3RCwwQkFBMEJDO1FBQ3JDO0lBQ0Y7SUFDQXdoRyxzQkFBc0I7UUFDcEIsTUFBTSxFQUNKcEMsU0FBUyxFQUNUSixXQUFXLEVBQ1g3YSxTQUFTLEVBQ1Q1eEYsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBRyxJQUFJLENBQUMsQ0FBQyt0RyxhQUFhO1FBQ3ZCLE1BQU1wb0csU0FBU3YwQyxLQUFLNFAsR0FBRyxDQUFDKytCLE9BQU9DO1FBQy9CLE1BQU1pdkcsY0FBYzlILG1CQUFtQmtGLGlCQUFpQixDQUFDO1lBQ3ZEdmpHLE9BQU87Z0JBQ0x3akcsUUFBUU0sVUFBVW4zSSxHQUFHLENBQUMrN0gsQ0FBQUEsU0FBVzt3QkFDL0JBO29CQUNGO2dCQUNBRztnQkFDQTV4RjtnQkFDQUM7WUFDRjtZQUNBRyxXQUFXd0Y7WUFDWHZGLFlBQVl1RjtZQUNaeEcsVUFBVTtZQUNWNDRGLGFBQWE7WUFDYndVLFlBQVk7WUFDWkM7UUFDRjtRQUNBLE9BQU87WUFDTEE7WUFDQWhULFNBQVN5VixZQUFZelYsT0FBTztRQUM5QjtJQUNGO0lBQ0EsSUFBSTFnRSxpQkFBaUI7UUFDbkIsSUFBSSxJQUFJLENBQUMvdEIsVUFBVSxDQUFDK0IsZ0JBQWdCLEVBQUU7WUFDcEMsT0FBTztnQkFBQztvQkFBQztvQkFBaUIsSUFBSSxDQUFDL0IsVUFBVSxDQUFDK0IsZ0JBQWdCO2lCQUFDO2FBQUM7UUFDOUQ7UUFDQSxPQUFPLEtBQUssQ0FBQ2dzQjtJQUNmO0lBQ0FnMkUsYUFBYTN6SSxJQUFJLEVBQUUwekksWUFBWSxFQUFFcmhHLFdBQVcsRUFBRW9oRyxJQUFJLEVBQUU7UUFDbEQsTUFBTSxFQUNKcjlJLEdBQUcrMEQsTUFBTSxFQUNUcm9ELEdBQUdzb0QsTUFBTSxFQUNWLEdBQUcsSUFBSTtRQUNSLE1BQU0sRUFDSml6RSxPQUFPLEVBQ1IsR0FBRyxJQUFJLENBQUMsQ0FBQ3VVLGFBQWEsR0FBRzV5STtRQUMxQixJQUFJLENBQUMsQ0FBQ216SSxXQUFXLEdBQUc5VSxtQkFBbUJ3TjtRQUN2QyxJQUFJLENBQUN4NUYsV0FBVyxHQUFHQTtRQUNuQixJQUFJc3pGO1FBQ0osSUFBSSxJQUFJLENBQUMsQ0FBQ3dOLFdBQVcsRUFBRTtZQUNyQnhOLGlCQUFpQnVOLGdCQUFnQi9NLHdCQUF3QjtRQUMzRCxPQUFPO1lBQ0xSLGlCQUFpQnVOLGdCQUFnQkcsNkJBQTZCLENBQUNyNkksS0FBSztZQUNwRTJzSSxlQUFlL0MsZ0JBQWdCLENBQUM7Z0JBQzlCLGdCQUFnQnZFLFFBQVE3SCxTQUFTO1lBQ25DO1FBQ0Y7UUFDQSxJQUFJLENBQUNnUCxZQUFZLENBQUM7WUFDaEJiLGNBQWN0RztZQUNkc0g7UUFDRjtRQUNBLE1BQU0sR0FBRzFnRyxXQUFXLEdBQUcsSUFBSSxDQUFDa3lCLGNBQWM7UUFDMUMsSUFBSTRFLFlBQVkyM0UsZUFBZXp1RztRQUMvQjgyQixZQUFZQSxhQUFhLElBQUksTUFBTUE7UUFDbkMsSUFBSSxDQUFDbjNCLEtBQUssSUFBSW0zQixZQUFZLElBQUksQ0FBQ2wzQixNQUFNO1FBQ3JDLElBQUksSUFBSSxDQUFDRCxLQUFLLElBQUksR0FBRztZQUNuQm0zQixhQUFhLE1BQU0sSUFBSSxDQUFDbjNCLEtBQUs7WUFDN0IsSUFBSSxDQUFDQSxLQUFLLEdBQUc7UUFDZjtRQUNBLElBQUksQ0FBQ0MsTUFBTSxHQUFHazNCO1FBQ2QsSUFBSSxDQUFDbEIsT0FBTztRQUNaLElBQUksQ0FBQ3prRSxDQUFDLEdBQUcrMEQ7UUFDVCxJQUFJLENBQUNyb0QsQ0FBQyxHQUFHc29EO1FBQ1QsSUFBSSxDQUFDcU4sTUFBTTtRQUNYLElBQUksQ0FBQ29ELFVBQVU7UUFDZixJQUFJLENBQUMzZSxlQUFlO1FBQ3BCLElBQUksQ0FBQ2dsQixNQUFNO1FBQ1gsSUFBSSxDQUFDdHlCLFVBQVUsQ0FBQzhULHNCQUFzQixDQUFDLElBQUk7UUFDM0MsSUFBSSxDQUFDa3dGLE9BQU8sQ0FBQ0g7UUFDYixJQUFJLENBQUMva0YsZ0JBQWdCLENBQUM7WUFDcEIvRixRQUFRO1lBQ1Izb0QsTUFBTTtnQkFDSit6SSxjQUFjLENBQUMsQ0FBQ047Z0JBQ2hCSCxnQkFBZ0IsQ0FBQyxDQUFDamhHO1lBQ3BCO1FBQ0Y7UUFDQSxJQUFJLENBQUMxUSxHQUFHLENBQUNXLE1BQU0sR0FBRztJQUNwQjtJQUNBMHhHLGFBQWF4K0gsTUFBTSxFQUFFO1FBQ25CLE1BQU0sRUFDSnN2QixTQUFTLEVBQ1BFLFNBQVMsRUFDVEMsVUFBVSxFQUNYLEVBQ0RqQixRQUFRLEVBQ1QsR0FBRyxJQUFJLENBQUNqQyxNQUFNLENBQUNILFFBQVE7UUFDeEIsT0FBT29xRyxtQkFBbUJobEksT0FBTyxDQUFDd08sUUFBUXd2QixXQUFXQyxZQUFZakIsVUFBVWt2RyxnQkFBZ0I1TixhQUFhO0lBQzFHO0lBQ0EyTyxZQUFZaDRILElBQUksRUFBRWk0SCxRQUFRLEVBQUU7UUFDMUIsTUFBTSxFQUNKcHZHLFNBQVMsRUFDUEUsU0FBUyxFQUNUQyxVQUFVLEVBQ1gsRUFDRGpCLFFBQVEsRUFDVCxHQUFHLElBQUksQ0FBQ2pDLE1BQU0sQ0FBQ0gsUUFBUTtRQUN4QixPQUFPb3FHLG1CQUFtQjhFLHVCQUF1QixDQUFDNzBILE1BQU1pNEgsVUFBVWx2RyxXQUFXQyxZQUFZakIsVUFBVWt2RyxnQkFBZ0I1TixhQUFhO0lBQ2xJO0lBQ0E2TyxrQkFBa0JoRCxNQUFNLEVBQUU7UUFDeEIsTUFBTSxFQUNKcnNHLFNBQVMsRUFDUEUsU0FBUyxFQUNUQyxVQUFVLEVBQ1gsRUFDRGpCLFFBQVEsRUFDVCxHQUFHLElBQUksQ0FBQ2pDLE1BQU0sQ0FBQ0gsUUFBUTtRQUN4QixPQUFPb3FHLG1CQUFtQmtGLGlCQUFpQixDQUFDO1lBQzFDdmpHLE9BQU93akc7WUFDUG5zRztZQUNBQztZQUNBakI7WUFDQTQ0RixhQUFhc1csZ0JBQWdCNU4sYUFBYTtZQUMxQzhMLFlBQVk7WUFDWkMsYUFBYTtRQUNmO0lBQ0Y7SUFDQTFJLHFCQUFxQixFQUNuQjBJLFdBQVcsRUFDWDdhLFNBQVMsRUFDVixFQUFFO1FBQ0QsSUFBSTZhLGFBQWE7WUFDZixJQUFJLENBQUN6TCxlQUFlLEdBQUdzTixnQkFBZ0IvTSx3QkFBd0I7UUFDakUsT0FBTztZQUNMLElBQUksQ0FBQ1AsZUFBZSxHQUFHc04sZ0JBQWdCRyw2QkFBNkIsQ0FBQ3I2SSxLQUFLO1lBQzFFLElBQUksQ0FBQzRzSSxlQUFlLENBQUNoRCxnQkFBZ0IsQ0FBQztnQkFDcEMsZ0JBQWdCcE07WUFDbEI7UUFDRjtJQUNGO0lBQ0FoL0UsVUFBVTBYLGVBQWUsS0FBSyxFQUFFO1FBQzlCLElBQUksSUFBSSxDQUFDdlMsT0FBTyxJQUFJO1lBQ2xCLE9BQU87UUFDVDtRQUNBLE1BQU0sRUFDSmhQLEtBQUssRUFDTDBvRixNQUFNLEVBQ1AsR0FBRyxJQUFJLENBQUM4UyxhQUFhLENBQUNqNkU7UUFDdkIsTUFBTSxFQUNKMDJFLGlCQUFpQixFQUNmLGdCQUFnQnBQLFNBQVMsRUFDMUIsRUFDRixHQUFHLElBQUk7UUFDUixNQUFNaHhFLGFBQWExekQsT0FBT2t2QyxNQUFNLENBQUMsS0FBSyxDQUFDd1csVUFBVTBYLGVBQWU7WUFDOURrbEYsYUFBYTtZQUNiL0MsYUFBYSxJQUFJLENBQUMsQ0FBQzhCLFdBQVc7WUFDOUIxcUcsT0FBTztnQkFBQztnQkFBRztnQkFBRzthQUFFO1lBQ2hCK3RGLFdBQVcsSUFBSSxDQUFDLENBQUMyYyxXQUFXLEdBQUcsSUFBSTNjO1FBQ3JDO1FBQ0EsSUFBSSxDQUFDcGxGLFVBQVUsQ0FBQ29VO1FBQ2hCLElBQUkwSixjQUFjO1lBQ2hCMUosV0FBV293QyxLQUFLLEdBQUc7Z0JBQ2pCam9EO2dCQUNBMG9GO1lBQ0Y7WUFDQTd3RSxXQUFXaXVGLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQ0wsYUFBYTtZQUNyQzV0RixXQUFXK2MsTUFBTSxHQUFHO1FBQ3RCLE9BQU87WUFDTC9jLFdBQVc3WCxLQUFLLEdBQUdBO1FBQ3JCO1FBQ0EsSUFBSSxJQUFJLENBQUMsQ0FBQzBFLFdBQVcsRUFBRTtZQUNyQm1ULFdBQVdrUCxpQkFBaUIsR0FBRztnQkFDN0J0OEQsTUFBTTtnQkFDTmk4SSxLQUFLLElBQUksQ0FBQyxDQUFDaGlHLFdBQVc7WUFDeEI7UUFDRjtRQUNBLE9BQU9tVDtJQUNUO0lBQ0EsT0FBT3FqRixnQkFBZ0IzakcsS0FBSyxFQUFFQyxLQUFLLEVBQUVILFNBQVMsRUFBRUMsVUFBVSxFQUFFMjNGLFdBQVcsRUFBRTU4SCxJQUFJLEVBQUU7UUFDN0UsSUFBSUEsS0FBS3F4SSxXQUFXLEVBQUU7WUFDcEIsT0FBT3hGLG1CQUFtQmhtRixXQUFXLENBQUMzZ0IsT0FBT0MsT0FBT0gsV0FBV0MsWUFBWTIzRixhQUFhNThIO1FBQzFGO1FBQ0EsT0FBT3VwSSxlQUFlMWpGLFdBQVcsQ0FBQzNnQixPQUFPQyxPQUFPSCxXQUFXQyxZQUFZMjNGLGFBQWE1OEg7SUFDdEY7SUFDQSxhQUFhNmxELFlBQVk3bEQsSUFBSSxFQUFFK2hDLE1BQU0sRUFBRTBRLFNBQVMsRUFBRTtRQUNoRCxNQUFNM0QsU0FBUyxNQUFNLEtBQUssQ0FBQytXLFlBQVk3bEQsTUFBTStoQyxRQUFRMFE7UUFDckQzRCxPQUFPLENBQUNxa0csV0FBVyxHQUFHbnpJLEtBQUtxeEksV0FBVztRQUN0Q3ZpRyxPQUFPdUQsV0FBVyxHQUFHcnlDLEtBQUswMEQsaUJBQWlCLEVBQUUyL0UsT0FBTztRQUNwRHZsRyxPQUFPLENBQUNza0csYUFBYSxHQUFHcHpJLEtBQUt5ekksSUFBSTtRQUNqQyxPQUFPM2tHO0lBQ1Q7QUFDRjtFQUVDLGdDQUFnQztBQVFqQyxNQUFNd2xHLG9CQUFvQjcvRTtJQUN4QixDQUFDai9DLE1BQU0sQ0FBUTtJQUNmLENBQUMrK0gsUUFBUSxDQUFRO0lBQ2pCLENBQUNDLGFBQWEsQ0FBUTtJQUN0QixDQUFDQyxTQUFTLENBQVE7SUFDbEIsQ0FBQ0MsVUFBVSxDQUFRO0lBQ25CLENBQUNDLGNBQWMsQ0FBTTtJQUNyQixDQUFDNWdHLE1BQU0sQ0FBUTtJQUNmLENBQUM2Z0csYUFBYSxDQUFTO0lBQ3ZCLENBQUNDLGVBQWUsQ0FBUTtJQUN4QixDQUFDcGdHLEtBQUssQ0FBUztJQUNmLENBQUNxZ0csdUJBQXVCLENBQVM7O2FBQzFCeDlFLFFBQVE7OzthQUNSM1AsY0FBY2xrQyxxQkFBcUJJLEtBQUs7O0lBQy9DaHhCLFlBQVk2VyxNQUFNLENBQUU7UUFDbEIsS0FBSyxDQUFDO1lBQ0osR0FBR0EsTUFBTTtZQUNUblgsTUFBTTtRQUNSO2FBakJGLENBQUNpakIsTUFBTSxHQUFHO2FBQ1YsQ0FBQysrSCxRQUFRLEdBQUc7YUFDWixDQUFDQyxhQUFhLEdBQUc7YUFDakIsQ0FBQ0MsU0FBUyxHQUFHO2FBQ2IsQ0FBQ0MsVUFBVSxHQUFHO2FBQ2QsQ0FBQ0MsY0FBYyxHQUFHO2FBQ2xCLENBQUM1Z0csTUFBTSxHQUFHO2FBQ1YsQ0FBQzZnRyxhQUFhLEdBQUc7YUFDakIsQ0FBQ0MsZUFBZSxHQUFHO2FBQ25CLENBQUNwZ0csS0FBSyxHQUFHO2FBQ1QsQ0FBQ3FnRyx1QkFBdUIsR0FBRztRQVF6QixJQUFJLENBQUMsQ0FBQ0wsU0FBUyxHQUFHL3FJLE9BQU8rcUksU0FBUztRQUNsQyxJQUFJLENBQUMsQ0FBQ0MsVUFBVSxHQUFHaHJJLE9BQU9nckksVUFBVTtRQUNwQyxJQUFJLENBQUM5MEUsYUFBYSxHQUFHO0lBQ3ZCO0lBQ0EsT0FBT3RSLFdBQVdDLElBQUksRUFBRTliLFNBQVMsRUFBRTtRQUNqQ2dpQixpQkFBaUJuRyxVQUFVLENBQUNDLE1BQU05YjtJQUNwQztJQUNBLE9BQU80Uyx5QkFBeUJrVCxJQUFJLEVBQUU7UUFDcEMsT0FBT250Qix3QkFBd0JsbUMsUUFBUSxDQUFDcXpEO0lBQzFDO0lBQ0EsT0FBT3hULE1BQU12K0MsSUFBSSxFQUFFdTdCLE1BQU0sRUFBRTtRQUN6QkEsT0FBT2d6RyxXQUFXLENBQUM7WUFDakJwK0gsTUFBTThNLHFCQUFxQkksS0FBSztRQUNsQyxHQUFHO1lBQ0Q2d0gsWUFBWWx1SSxLQUFLd3VJLFNBQVM7UUFDNUI7SUFDRjtJQUNBdDNFLGdCQUFnQjtRQUNkLElBQUksSUFBSSxDQUFDOXRCLFVBQVUsQ0FBQ3NPLGlCQUFpQixFQUFFO1lBQ3JDLElBQUksQ0FBQ3ZjLEdBQUcsQ0FBQ1csTUFBTSxHQUFHO1FBQ3BCO1FBQ0EsS0FBSyxDQUFDbzdCO0lBQ1I7SUFDQSxJQUFJcUcscUJBQXFCO1FBQ3ZCLE9BQU87WUFDTDNyRSxNQUFNO1lBQ05zbUUsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDSixXQUFXLEVBQUV0dkI7UUFDbEM7SUFDRjtJQUNBLE9BQU84M0IsMEJBQTBCOW1FLElBQUksRUFBRTtRQUNyQyxNQUFNaTFJLGtCQUFrQmoxSSxLQUFLdE8sR0FBRyxDQUFDO1FBQ2pDLE9BQU87WUFDTGd0RSxZQUFZdTJFLGdCQUFnQnZqSixHQUFHLENBQUMsU0FBUztZQUN6QzhoSixjQUFjeUIsZ0JBQWdCdmpKLEdBQUcsQ0FBQyxVQUFVO1FBQzlDO0lBQ0Y7SUFDQSxDQUFDd2pKLGdCQUFnQixDQUFDbDFJLElBQUksRUFBRW0xSSxTQUFTLEtBQUs7UUFDcEMsSUFBSSxDQUFDbjFJLE1BQU07WUFDVCxJQUFJLENBQUM2RSxNQUFNO1lBQ1g7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDMlEsTUFBTSxHQUFHeFYsS0FBS3dWLE1BQU07UUFDMUIsSUFBSSxDQUFDMi9ILFFBQVE7WUFDWCxJQUFJLENBQUMsQ0FBQ1osUUFBUSxHQUFHdjBJLEtBQUtvRSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxDQUFDcXdDLEtBQUssR0FBR3owQyxLQUFLeTBDLEtBQUs7UUFDMUI7UUFDQSxJQUFJejBDLEtBQUsyMEMsSUFBSSxFQUFFO1lBQ2IsSUFBSSxDQUFDLENBQUNnZ0csY0FBYyxHQUFHMzBJLEtBQUsyMEMsSUFBSSxDQUFDcGlELElBQUk7UUFDdkM7UUFDQSxJQUFJLENBQUMsQ0FBQzhrRixZQUFZO0lBQ3BCO0lBQ0EsQ0FBQys5RCxhQUFhO1FBQ1osSUFBSSxDQUFDLENBQUNaLGFBQWEsR0FBRztRQUN0QixJQUFJLENBQUM1a0csVUFBVSxDQUFDbVosYUFBYSxDQUFDO1FBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ2hWLE1BQU0sRUFBRTtZQUNqQjtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUNuRSxVQUFVLENBQUN1Tyw0QkFBNEIsSUFBSSxJQUFJLENBQUN2TyxVQUFVLENBQUNzTyxpQkFBaUIsSUFBSSxJQUFJLENBQUMsQ0FBQzFvQyxNQUFNLEVBQUU7WUFDckcsSUFBSSxDQUFDb29ELGNBQWMsR0FBR3hwQixJQUFJLENBQUM7Z0JBQ3pCLElBQUksQ0FBQ3FpQixZQUFZLENBQUNobUIsSUFBSTtnQkFDdEIsSUFBSSxDQUFDYixVQUFVLENBQUN5UCxXQUFXLENBQUMsSUFBSSxFQUFFO1lBQ3BDO1lBQ0E7UUFDRjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUN6UCxVQUFVLENBQUN1Tyw0QkFBNEIsSUFBSSxJQUFJLENBQUN2TyxVQUFVLENBQUNzTyxpQkFBaUIsSUFBSSxJQUFJLENBQUMsQ0FBQzFvQyxNQUFNLEVBQUU7WUFDdEcsSUFBSSxDQUFDazVDLGdCQUFnQixDQUFDO2dCQUNwQi9GLFFBQVE7Z0JBQ1Izb0QsTUFBTTtvQkFDSnExSSxnQkFBZ0I7b0JBQ2hCQyxlQUFlO2dCQUNqQjtZQUNGO1lBQ0EsSUFBSTtnQkFDRixJQUFJLENBQUNDLGNBQWM7WUFDckIsRUFBRSxPQUFNLENBQUM7UUFDWDtRQUNBLElBQUksQ0FBQzV6RyxHQUFHLENBQUN5ZixLQUFLO0lBQ2hCO0lBQ0EsTUFBTW0wRixlQUFlaHJFLFlBQVksSUFBSSxFQUFFaXJFLG9CQUFvQixJQUFJLEVBQUU7UUFDL0QsSUFBSSxJQUFJLENBQUM3MkUsY0FBYyxJQUFJO1lBQ3pCLE9BQU87UUFDVDtRQUNBLE1BQU0sRUFDSnBrQixTQUFTLEVBQ1YsR0FBRyxJQUFJLENBQUMzSyxVQUFVO1FBQ25CLElBQUksQ0FBQzJLLFdBQVc7WUFDZCxNQUFNLElBQUkzc0MsTUFBTTtRQUNsQjtRQUNBLElBQUksQ0FBRSxNQUFNMnNDLFVBQVVrN0YsWUFBWSxDQUFDLFlBQWE7WUFDOUMsTUFBTSxJQUFJN25JLE1BQU07UUFDbEI7UUFDQSxNQUFNLEVBQ0o1TixJQUFJLEVBQ0o0a0MsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBRzBsQyxhQUFhLElBQUksQ0FBQ21yRSxVQUFVLENBQUMsTUFBTSxNQUFNLE1BQU1uckUsU0FBUztRQUM1RCxNQUFNem5DLFdBQVcsTUFBTXlYLFVBQVVvN0YsS0FBSyxDQUFDO1lBQ3JDcGpKLE1BQU07WUFDTjZ3QyxTQUFTO2dCQUNQcGpDO2dCQUNBNGtDO2dCQUNBQztnQkFDQSt3RyxVQUFVNTFJLEtBQUt2USxNQUFNLEdBQUltMUMsQ0FBQUEsUUFBUUMsTUFBSztZQUN4QztRQUNGO1FBQ0EsSUFBSSxDQUFDL0IsVUFBVTtZQUNiLE1BQU0sSUFBSWwxQixNQUFNO1FBQ2xCO1FBQ0EsSUFBSWsxQixTQUFTdnlDLEtBQUssRUFBRTtZQUNsQixNQUFNLElBQUlxZCxNQUFNO1FBQ2xCO1FBQ0EsSUFBSWsxQixTQUFTc3NCLE1BQU0sRUFBRTtZQUNuQixPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUN0c0IsU0FBU3RMLE1BQU0sRUFBRTtZQUNwQixNQUFNLElBQUk1cEIsTUFBTTtRQUNsQjtRQUNBLE1BQU1vaEMsVUFBVWxNLFNBQVN0TCxNQUFNO1FBQy9CLE1BQU0sSUFBSSxDQUFDZ25DLGlCQUFpQixDQUFDeHZCO1FBQzdCLElBQUl3bUcscUJBQXFCLENBQUMsSUFBSSxDQUFDNzJFLGNBQWMsSUFBSTtZQUMvQyxJQUFJLENBQUNMLFdBQVcsR0FBRztnQkFDakIrMUUsS0FBS3JsRztnQkFDTG1nQixZQUFZO1lBQ2Q7UUFDRjtRQUNBLE9BQU9uZ0I7SUFDVDtJQUNBLENBQUM2bUcsU0FBUztRQUNSLElBQUksSUFBSSxDQUFDLENBQUN0QixRQUFRLEVBQUU7WUFDbEIsSUFBSSxDQUFDM2tHLFVBQVUsQ0FBQ21aLGFBQWEsQ0FBQztZQUM5QixJQUFJLENBQUNuWixVQUFVLENBQUM0YyxZQUFZLENBQUM1VyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMyK0YsUUFBUSxFQUFFbmdHLElBQUksQ0FBQ3AwQyxDQUFBQSxPQUFRLElBQUksQ0FBQyxDQUFDazFJLGdCQUFnQixDQUFDbDFJLE1BQU0sT0FBT3V0RyxPQUFPLENBQUMsSUFBTSxJQUFJLENBQUMsQ0FBQzZuQyxhQUFhO1lBQ3pJO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDWCxTQUFTLEVBQUU7WUFDbkIsTUFBTXJoSSxNQUFNLElBQUksQ0FBQyxDQUFDcWhJLFNBQVM7WUFDM0IsSUFBSSxDQUFDLENBQUNBLFNBQVMsR0FBRztZQUNsQixJQUFJLENBQUM3a0csVUFBVSxDQUFDbVosYUFBYSxDQUFDO1lBQzlCLElBQUksQ0FBQyxDQUFDeXJGLGFBQWEsR0FBRyxJQUFJLENBQUM1a0csVUFBVSxDQUFDNGMsWUFBWSxDQUFDL1csVUFBVSxDQUFDcmlDLEtBQUtnaEMsSUFBSSxDQUFDcDBDLENBQUFBLE9BQVEsSUFBSSxDQUFDLENBQUNrMUksZ0JBQWdCLENBQUNsMUksT0FBT3V0RyxPQUFPLENBQUMsSUFBTSxJQUFJLENBQUMsQ0FBQzZuQyxhQUFhO1lBQy9JO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDVixVQUFVLEVBQUU7WUFDcEIsTUFBTS8vRixPQUFPLElBQUksQ0FBQyxDQUFDKy9GLFVBQVU7WUFDN0IsSUFBSSxDQUFDLENBQUNBLFVBQVUsR0FBRztZQUNuQixJQUFJLENBQUM5a0csVUFBVSxDQUFDbVosYUFBYSxDQUFDO1lBQzlCLElBQUksQ0FBQyxDQUFDeXJGLGFBQWEsR0FBRyxJQUFJLENBQUM1a0csVUFBVSxDQUFDNGMsWUFBWSxDQUFDalgsV0FBVyxDQUFDWixNQUFNUCxJQUFJLENBQUNwMEMsQ0FBQUEsT0FBUSxJQUFJLENBQUMsQ0FBQ2sxSSxnQkFBZ0IsQ0FBQ2wxSSxPQUFPdXRHLE9BQU8sQ0FBQyxJQUFNLElBQUksQ0FBQyxDQUFDNm5DLGFBQWE7WUFDako7UUFDRjtRQUNBLE1BQU05MUksUUFBUTlCLFNBQVMySSxhQUFhLENBQUM7UUFDckM3RyxNQUFNbEgsSUFBSSxHQUFHO1FBQ2JrSCxNQUFNdzJJLE1BQU0sR0FBRzFxRyx3QkFBd0JsNUMsSUFBSSxDQUFDO1FBQzVDLE1BQU1zc0MsU0FBUyxJQUFJLENBQUNvUixVQUFVLENBQUNDLE9BQU87UUFDdEMsSUFBSSxDQUFDLENBQUMya0csYUFBYSxHQUFHLElBQUlsN0ksUUFBUVEsQ0FBQUE7WUFDaEN3RixNQUFNcy9CLGdCQUFnQixDQUFDLFVBQVU7Z0JBQy9CLElBQUksQ0FBQ3QvQixNQUFNeTJJLEtBQUssSUFBSXoySSxNQUFNeTJJLEtBQUssQ0FBQ3RtSixNQUFNLEtBQUssR0FBRztvQkFDNUMsSUFBSSxDQUFDb1YsTUFBTTtnQkFDYixPQUFPO29CQUNMLElBQUksQ0FBQytxQyxVQUFVLENBQUNtWixhQUFhLENBQUM7b0JBQzlCLE1BQU0vb0QsT0FBTyxNQUFNLElBQUksQ0FBQzR2QyxVQUFVLENBQUM0YyxZQUFZLENBQUNqWCxXQUFXLENBQUNqMkMsTUFBTXkySSxLQUFLLENBQUMsRUFBRTtvQkFDMUUsSUFBSSxDQUFDcm5GLGdCQUFnQixDQUFDO3dCQUNwQi9GLFFBQVE7d0JBQ1Izb0QsTUFBTTs0QkFDSnExSSxnQkFBZ0IsSUFBSSxDQUFDemxHLFVBQVUsQ0FBQ3NPLGlCQUFpQjt3QkFDbkQ7b0JBQ0Y7b0JBQ0EsSUFBSSxDQUFDLENBQUNnM0YsZ0JBQWdCLENBQUNsMUk7Z0JBQ3pCO2dCQUNBbEc7WUFDRixHQUFHO2dCQUNEMGtDO1lBQ0Y7WUFDQWwvQixNQUFNcy9CLGdCQUFnQixDQUFDLFVBQVU7Z0JBQy9CLElBQUksQ0FBQy81QixNQUFNO2dCQUNYL0s7WUFDRixHQUFHO2dCQUNEMGtDO1lBQ0Y7UUFDRixHQUFHK3VFLE9BQU8sQ0FBQyxJQUFNLElBQUksQ0FBQyxDQUFDNm5DLGFBQWE7UUFDcEM5MUksTUFBTTAySSxLQUFLO0lBQ2I7SUFDQW54SSxTQUFTO1FBQ1AsSUFBSSxJQUFJLENBQUMsQ0FBQzB2SSxRQUFRLEVBQUU7WUFDbEIsSUFBSSxDQUFDLENBQUMvK0gsTUFBTSxHQUFHO1lBQ2YsSUFBSSxDQUFDbzZCLFVBQVUsQ0FBQzRjLFlBQVksQ0FBQ3ZXLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQ3MrRixRQUFRO1lBQ3BELElBQUksQ0FBQyxDQUFDeGdHLE1BQU0sRUFBRWx2QztZQUNkLElBQUksQ0FBQyxDQUFDa3ZDLE1BQU0sR0FBRztZQUNmLElBQUksSUFBSSxDQUFDLENBQUM4Z0csZUFBZSxFQUFFO2dCQUN6QjcyRixhQUFhLElBQUksQ0FBQyxDQUFDNjJGLGVBQWU7Z0JBQ2xDLElBQUksQ0FBQyxDQUFDQSxlQUFlLEdBQUc7WUFDMUI7UUFDRjtRQUNBLEtBQUssQ0FBQ2h3STtJQUNSO0lBQ0FvbkQsVUFBVTtRQUNSLElBQUksQ0FBQyxJQUFJLENBQUNscUIsTUFBTSxFQUFFO1lBQ2hCLElBQUksSUFBSSxDQUFDLENBQUN3eUcsUUFBUSxFQUFFO2dCQUNsQixJQUFJLENBQUMsQ0FBQ3NCLFNBQVM7WUFDakI7WUFDQTtRQUNGO1FBQ0EsS0FBSyxDQUFDNXBGO1FBQ04sSUFBSSxJQUFJLENBQUN0cUIsR0FBRyxLQUFLLE1BQU07WUFDckI7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDLENBQUM0eUcsUUFBUSxJQUFJLElBQUksQ0FBQyxDQUFDeGdHLE1BQU0sS0FBSyxNQUFNO1lBQzNDLElBQUksQ0FBQyxDQUFDOGhHLFNBQVM7UUFDakI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDeCtFLGVBQWUsRUFBRTtZQUN6QixJQUFJLENBQUN0MUIsTUFBTSxDQUFDejhCLEdBQUcsQ0FBQyxJQUFJO1FBQ3RCO0lBQ0Y7SUFDQW04RCxVQUFVcmdCLEtBQUssRUFBRTtRQUNmLElBQUksQ0FBQ29YLFlBQVksR0FBRztRQUNwQixJQUFJcFgsT0FBTztZQUNULElBQUksQ0FBQ3pmLEdBQUcsQ0FBQ3lmLEtBQUs7UUFDaEI7SUFDRjtJQUNBekUsVUFBVTtRQUNSLE9BQU8sQ0FBRSxLQUFJLENBQUMsQ0FBQzYzRixhQUFhLElBQUksSUFBSSxDQUFDLENBQUNoL0gsTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDaS9ILFNBQVMsSUFBSSxJQUFJLENBQUMsQ0FBQ0MsVUFBVSxJQUFJLElBQUksQ0FBQyxDQUFDSCxRQUFRLElBQUksSUFBSSxDQUFDLENBQUNLLGFBQWE7SUFDOUg7SUFDQSxJQUFJajNFLGlCQUFpQjtRQUNuQixPQUFPO1lBQUM7Z0JBQUM7Z0JBQVcsSUFBSSxDQUFDVSxhQUFhO2FBQUc7U0FBQztJQUM1QztJQUNBLElBQUlqc0QsY0FBYztRQUNoQixPQUFPO0lBQ1Q7SUFDQWd2QixTQUFTO1FBQ1AsSUFBSSxJQUFJLENBQUNPLEdBQUcsRUFBRTtZQUNaLE9BQU8sSUFBSSxDQUFDQSxHQUFHO1FBQ2pCO1FBQ0EsSUFBSTQzQixPQUFPQztRQUNYLElBQUksSUFBSSxDQUFDaEQsT0FBTyxFQUFFO1lBQ2hCK0MsUUFBUSxJQUFJLENBQUNuakUsQ0FBQztZQUNkb2pFLFFBQVEsSUFBSSxDQUFDMTJELENBQUM7UUFDaEI7UUFDQSxLQUFLLENBQUNzK0I7UUFDTixJQUFJLENBQUNPLEdBQUcsQ0FBQ1csTUFBTSxHQUFHO1FBQ2xCLElBQUksQ0FBQys3QixhQUFhO1FBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ3UyRSxhQUFhLEVBQUU7WUFDeEIsSUFBSSxJQUFJLENBQUMsQ0FBQ3AvSCxNQUFNLEVBQUU7Z0JBQ2hCLElBQUksQ0FBQyxDQUFDNmhFLFlBQVk7WUFDcEIsT0FBTztnQkFDTCxJQUFJLENBQUMsQ0FBQ3crRCxTQUFTO1lBQ2pCO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQ3IvRSxPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDOEMsZUFBZSxDQUFDQyxPQUFPQztRQUM5QjtRQUNBLElBQUksQ0FBQzVwQixVQUFVLENBQUM4UixnQkFBZ0IsQ0FBQyxJQUFJO1FBQ3JDLE9BQU8sSUFBSSxDQUFDL2YsR0FBRztJQUNqQjtJQUNBMnJCLFVBQVV4RixtQkFBbUIsRUFBRS9ULE1BQU0sRUFBRTtRQUNyQyxNQUFNLEVBQ0ozdkMsSUFBSW13SSxRQUFRLEVBQ1ovK0gsTUFBTSxFQUNQLEdBQUcsSUFBSSxDQUFDbzZCLFVBQVUsQ0FBQzRjLFlBQVksQ0FBQzNXLGFBQWEsQ0FBQ2lTLHFCQUFxQi9UO1FBQ3BFQSxPQUFPbHZDLE1BQU07UUFDYixJQUFJMHZJLFlBQVksSUFBSSxDQUFDM2tHLFVBQVUsQ0FBQzRjLFlBQVksQ0FBQ3BXLFNBQVMsQ0FBQ20rRixXQUFXO1lBQ2hFLElBQUksQ0FBQyxDQUFDQSxRQUFRLEdBQUdBO1lBQ2pCLElBQUkvK0gsUUFBUTtnQkFDVixJQUFJLENBQUMsQ0FBQ0EsTUFBTSxHQUFHQTtZQUNqQjtZQUNBLElBQUksQ0FBQyxDQUFDby9ILGFBQWEsR0FBRztZQUN0QixJQUFJLENBQUMsQ0FBQ3Y5RCxZQUFZO1FBQ3BCO0lBQ0Y7SUFDQXhiLGFBQWE7UUFDWCxJQUFJLENBQUMzZSxlQUFlO0lBQ3RCO0lBQ0FBLGtCQUFrQjtRQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDbmIsTUFBTSxFQUFFO1lBQ2hCO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDOHlHLGVBQWUsS0FBSyxNQUFNO1lBQ2xDNzJGLGFBQWEsSUFBSSxDQUFDLENBQUM2MkYsZUFBZTtRQUNwQztRQUNBLE1BQU05cEYsZUFBZTtRQUNyQixJQUFJLENBQUMsQ0FBQzhwRixlQUFlLEdBQUdyckYsV0FBVztZQUNqQyxJQUFJLENBQUMsQ0FBQ3FyRixlQUFlLEdBQUc7WUFDeEIsSUFBSSxDQUFDLENBQUNvQixVQUFVO1FBQ2xCLEdBQUdsckY7SUFDTDtJQUNBLENBQUNzc0IsWUFBWTtRQUNYLE1BQU0sRUFDSjExQyxHQUFHLEVBQ0osR0FBRyxJQUFJO1FBQ1IsSUFBSSxFQUNGaUQsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBRyxJQUFJLENBQUMsQ0FBQ3J2QixNQUFNO1FBQ2hCLE1BQU0sQ0FBQ3d2QixXQUFXQyxXQUFXLEdBQUcsSUFBSSxDQUFDa3lCLGNBQWM7UUFDbkQsTUFBTSsrRSxZQUFZO1FBQ2xCLElBQUksSUFBSSxDQUFDdHhHLEtBQUssRUFBRTtZQUNkQSxRQUFRLElBQUksQ0FBQ0EsS0FBSyxHQUFHSTtZQUNyQkgsU0FBUyxJQUFJLENBQUNBLE1BQU0sR0FBR0k7UUFDekIsT0FBTyxJQUFJTCxRQUFRc3hHLFlBQVlseEcsYUFBYUgsU0FBU3F4RyxZQUFZanhHLFlBQVk7WUFDM0UsTUFBTXE3QixTQUFTcnFFLEtBQUttRixHQUFHLENBQUM4NkksWUFBWWx4RyxZQUFZSixPQUFPc3hHLFlBQVlqeEcsYUFBYUo7WUFDaEZELFNBQVMwN0I7WUFDVHo3QixVQUFVeTdCO1FBQ1o7UUFDQSxJQUFJLENBQUMxd0IsVUFBVSxDQUFDbVosYUFBYSxDQUFDO1FBQzlCLE1BQU1oVixTQUFTLElBQUksQ0FBQyxDQUFDQSxNQUFNLEdBQUd2MkMsU0FBUzJJLGFBQWEsQ0FBQztRQUNyRDR0QyxPQUFPM1QsWUFBWSxDQUFDLFFBQVE7UUFDNUIsSUFBSSxDQUFDNjlCLFlBQVksQ0FBQ2xxQjtRQUNsQixJQUFJLENBQUNuUCxLQUFLLEdBQUdBLFFBQVFJO1FBQ3JCLElBQUksQ0FBQ0gsTUFBTSxHQUFHQSxTQUFTSTtRQUN2QixJQUFJLENBQUM0MUIsT0FBTztRQUNaLElBQUksSUFBSSxDQUFDbkUsZUFBZSxFQUFFSSxZQUFZO1lBQ3BDLElBQUksQ0FBQzJCLE1BQU07UUFDYixPQUFPO1lBQ0wsSUFBSSxDQUFDRSxpQkFBaUI7UUFDeEI7UUFDQSxJQUFJLENBQUNqQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQzltQixVQUFVLENBQUN1Tyw0QkFBNEIsSUFBSSxDQUFDLElBQUksQ0FBQ3ZPLFVBQVUsQ0FBQ3NPLGlCQUFpQixJQUFJLElBQUksQ0FBQzRKLG1CQUFtQixFQUFFO1lBQ25Ibm1CLElBQUlXLE1BQU0sR0FBRztRQUNmO1FBQ0EsSUFBSSxDQUFDLENBQUMyekcsVUFBVTtRQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNuQix1QkFBdUIsRUFBRTtZQUNsQyxJQUFJLENBQUMveUcsTUFBTSxDQUFDd2hHLGlCQUFpQixDQUFDLElBQUk7WUFDbEMsSUFBSSxDQUFDLENBQUN1Uix1QkFBdUIsR0FBRztRQUNsQztRQUNBLElBQUksQ0FBQ3BtRixnQkFBZ0IsQ0FBQztZQUNwQi9GLFFBQVE7UUFDVjtRQUNBLElBQUksSUFBSSxDQUFDLENBQUNnc0YsY0FBYyxFQUFFO1lBQ3hCLElBQUksQ0FBQ2h6RyxHQUFHLENBQUN2QixZQUFZLENBQUMsb0JBQW9CLElBQUksQ0FBQyxDQUFDdTBHLGNBQWM7UUFDaEU7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDN3NGLG1CQUFtQixFQUFFO1lBQzdCLElBQUksQ0FBQ2xZLFVBQVUsQ0FBQytULFNBQVMsQ0FBQztRQUM1QjtJQUNGO0lBQ0EreEYsV0FBV1MsZ0JBQWdCLEVBQUVDLG1CQUFtQixFQUFFdHpELGtCQUFrQixLQUFLLEVBQUU7UUFDekUsSUFBSSxDQUFDcXpELGtCQUFrQjtZQUNyQkEsbUJBQW1CO1FBQ3JCO1FBQ0EsTUFBTSxFQUNKdnhHLE9BQU95eEcsV0FBVyxFQUNsQnh4RyxRQUFReXhHLFlBQVksRUFDckIsR0FBRyxJQUFJLENBQUMsQ0FBQzlnSSxNQUFNO1FBQ2hCLE1BQU0rZ0ksY0FBYyxJQUFJdnNHO1FBQ3hCLElBQUl4MEIsU0FBUyxJQUFJLENBQUMsQ0FBQ0EsTUFBTTtRQUN6QixJQUFJb3ZCLFFBQVF5eEcsYUFDVnh4RyxTQUFTeXhHO1FBQ1gsSUFBSXZpRyxTQUFTO1FBQ2IsSUFBSXFpRyxxQkFBcUI7WUFDdkIsSUFBSUMsY0FBY0QsdUJBQXVCRSxlQUFlRixxQkFBcUI7Z0JBQzNFLE1BQU12bUMsUUFBUTU1RyxLQUFLbUYsR0FBRyxDQUFDZzdJLHNCQUFzQkMsYUFBYUQsc0JBQXNCRTtnQkFDaEYxeEcsUUFBUTN1QyxLQUFLQyxLQUFLLENBQUNtZ0osY0FBY3htQztnQkFDakNockUsU0FBUzV1QyxLQUFLQyxLQUFLLENBQUNvZ0osZUFBZXptQztZQUNyQztZQUNBOTdELFNBQVN2MkMsU0FBUzJJLGFBQWEsQ0FBQztZQUNoQyxNQUFNcXdJLGNBQWN6aUcsT0FBT25QLEtBQUssR0FBRzN1QyxLQUFLRCxJQUFJLENBQUM0dUMsUUFBUTJ4RyxZQUFZcnNHLEVBQUU7WUFDbkUsTUFBTXVzRyxlQUFlMWlHLE9BQU9sUCxNQUFNLEdBQUc1dUMsS0FBS0QsSUFBSSxDQUFDNnVDLFNBQVMweEcsWUFBWXBzRyxFQUFFO1lBQ3RFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ3NLLEtBQUssRUFBRTtnQkFDaEJqL0IsU0FBUyxJQUFJLENBQUMsQ0FBQ2toSSxXQUFXLENBQUNGLGFBQWFDO1lBQzFDO1lBQ0EsTUFBTXJ0RyxNQUFNMkssT0FBT0MsVUFBVSxDQUFDO1lBQzlCNUssSUFBSWpyQyxNQUFNLEdBQUcsSUFBSSxDQUFDeXhDLFVBQVUsQ0FBQ3dPLFNBQVM7WUFDdEMsSUFBSXZTLFFBQVEsU0FDVnFnQyxRQUFRO1lBQ1YsSUFBSSxJQUFJLENBQUN0OEIsVUFBVSxDQUFDd08sU0FBUyxLQUFLLFFBQVE7Z0JBQ3hDOHRCLFFBQVE7WUFDVixPQUFPLElBQUk3Z0MsWUFBWUMsVUFBVSxFQUFFO2dCQUNqQ08sUUFBUTtnQkFDUnFnQyxRQUFRO1lBQ1Y7WUFDQSxNQUFNeXFFLFNBQVM7WUFDZixNQUFNQyxjQUFjRCxTQUFTSixZQUFZcnNHLEVBQUU7WUFDM0MsTUFBTTJzRyxlQUFlRixTQUFTSixZQUFZcHNHLEVBQUU7WUFDNUMsTUFBTTQwQyxVQUFVLElBQUlocUQsZ0JBQWdCNmhILGNBQWMsR0FBR0MsZUFBZTtZQUNwRSxNQUFNQyxhQUFhLzNELFFBQVEvcUMsVUFBVSxDQUFDO1lBQ3RDOGlHLFdBQVdyM0QsU0FBUyxHQUFHNXpDO1lBQ3ZCaXJHLFdBQVd4bUQsUUFBUSxDQUFDLEdBQUcsR0FBR3NtRCxjQUFjLEdBQUdDLGVBQWU7WUFDMURDLFdBQVdyM0QsU0FBUyxHQUFHdlQ7WUFDdkI0cUUsV0FBV3htRCxRQUFRLENBQUMsR0FBRyxHQUFHc21ELGFBQWFDO1lBQ3ZDQyxXQUFXeG1ELFFBQVEsQ0FBQ3NtRCxhQUFhQyxjQUFjRCxhQUFhQztZQUM1RHp0RyxJQUFJcTJDLFNBQVMsR0FBR3IyQyxJQUFJczJDLGFBQWEsQ0FBQ1gsU0FBUztZQUMzQzMxQyxJQUFJa25ELFFBQVEsQ0FBQyxHQUFHLEdBQUdrbUQsYUFBYUM7WUFDaENydEcsSUFBSWlMLFNBQVMsQ0FBQzcrQixRQUFRLEdBQUcsR0FBR0EsT0FBT292QixLQUFLLEVBQUVwdkIsT0FBT3F2QixNQUFNLEVBQUUsR0FBRyxHQUFHMnhHLGFBQWFDO1FBQzlFO1FBQ0EsSUFBSWxzRSxZQUFZO1FBQ2hCLElBQUl1WSxpQkFBaUI7WUFDbkIsSUFBSWkwRCxXQUFXQztZQUNmLElBQUlULFlBQVlsc0csU0FBUyxJQUFJNzBCLE9BQU9vdkIsS0FBSyxHQUFHdXhHLG9CQUFvQjNnSSxPQUFPcXZCLE1BQU0sR0FBR3N4RyxrQkFBa0I7Z0JBQ2hHWSxZQUFZdmhJLE9BQU9vdkIsS0FBSztnQkFDeEJveUcsYUFBYXhoSSxPQUFPcXZCLE1BQU07WUFDNUIsT0FBTztnQkFDTHJ2QixTQUFTLElBQUksQ0FBQyxDQUFDQSxNQUFNO2dCQUNyQixJQUFJNmdJLGNBQWNGLG9CQUFvQkcsZUFBZUgsa0JBQWtCO29CQUNyRSxNQUFNdG1DLFFBQVE1NUcsS0FBS21GLEdBQUcsQ0FBQys2SSxtQkFBbUJFLGFBQWFGLG1CQUFtQkc7b0JBQzFFUyxZQUFZOWdKLEtBQUtDLEtBQUssQ0FBQ21nSixjQUFjeG1DO29CQUNyQ21uQyxhQUFhL2dKLEtBQUtDLEtBQUssQ0FBQ29nSixlQUFlem1DO29CQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNwN0QsS0FBSyxFQUFFO3dCQUNoQmovQixTQUFTLElBQUksQ0FBQyxDQUFDa2hJLFdBQVcsQ0FBQ0ssV0FBV0M7b0JBQ3hDO2dCQUNGO1lBQ0Y7WUFDQSxNQUFNbGhHLFlBQVksSUFBSS9nQixnQkFBZ0JnaUgsV0FBV0M7WUFDakQsTUFBTUMsZUFBZW5oRyxVQUFVOUIsVUFBVSxDQUFDLE1BQU07Z0JBQzlDQyxvQkFBb0I7WUFDdEI7WUFDQWdqRyxhQUFhNWlHLFNBQVMsQ0FBQzcrQixRQUFRLEdBQUcsR0FBR0EsT0FBT292QixLQUFLLEVBQUVwdkIsT0FBT3F2QixNQUFNLEVBQUUsR0FBRyxHQUFHa3lHLFdBQVdDO1lBQ25GenNFLFlBQVk7Z0JBQ1YzbEMsT0FBT215RztnQkFDUGx5RyxRQUFRbXlHO2dCQUNSaDNJLE1BQU1pM0ksYUFBYTNpRyxZQUFZLENBQUMsR0FBRyxHQUFHeWlHLFdBQVdDLFlBQVloM0ksSUFBSTtZQUNuRTtRQUNGO1FBQ0EsT0FBTztZQUNMK3pDO1lBQ0FuUDtZQUNBQztZQUNBMGxDO1FBQ0Y7SUFDRjtJQUNBLENBQUNtc0UsV0FBVyxDQUFDOXhHLEtBQUssRUFBRUMsTUFBTTtRQUN4QixNQUFNLEVBQ0pELE9BQU95eEcsV0FBVyxFQUNsQnh4RyxRQUFReXhHLFlBQVksRUFDckIsR0FBRyxJQUFJLENBQUMsQ0FBQzlnSSxNQUFNO1FBQ2hCLElBQUlzbUQsV0FBV3U2RTtRQUNmLElBQUl0NkUsWUFBWXU2RTtRQUNoQixJQUFJOWdJLFNBQVMsSUFBSSxDQUFDLENBQUNBLE1BQU07UUFDekIsTUFBT3NtRCxXQUFXLElBQUlsM0IsU0FBU20zQixZQUFZLElBQUlsM0IsT0FBUTtZQUNyRCxNQUFNMnJHLFlBQVkxMEU7WUFDbEIsTUFBTTIwRSxhQUFhMTBFO1lBQ25CLElBQUlELFdBQVcsSUFBSWwzQixPQUFPO2dCQUN4QmszQixXQUFXQSxZQUFZLFFBQVE3bEUsS0FBS0MsS0FBSyxDQUFDNGxFLFdBQVcsS0FBSyxJQUFJN2xFLEtBQUtELElBQUksQ0FBQzhsRSxXQUFXO1lBQ3JGO1lBQ0EsSUFBSUMsWUFBWSxJQUFJbDNCLFFBQVE7Z0JBQzFCazNCLFlBQVlBLGFBQWEsUUFBUTlsRSxLQUFLQyxLQUFLLENBQUM2bEUsWUFBWSxLQUFLLElBQUk5bEUsS0FBS0QsSUFBSSxDQUFDK2xFLFlBQVk7WUFDekY7WUFDQSxNQUFNam1CLFlBQVksSUFBSS9nQixnQkFBZ0IrbUMsVUFBVUM7WUFDaEQsTUFBTTN5QixNQUFNME0sVUFBVTlCLFVBQVUsQ0FBQztZQUNqQzVLLElBQUlpTCxTQUFTLENBQUM3K0IsUUFBUSxHQUFHLEdBQUdnN0gsV0FBV0MsWUFBWSxHQUFHLEdBQUczMEUsVUFBVUM7WUFDbkV2bUQsU0FBU3NnQyxVQUFVQyxxQkFBcUI7UUFDMUM7UUFDQSxPQUFPdmdDO0lBQ1Q7SUFDQSxDQUFDeWdJLFVBQVU7UUFDVCxNQUFNLENBQUNycEYsYUFBYUMsYUFBYSxHQUFHLElBQUksQ0FBQzBFLGdCQUFnQjtRQUN6RCxNQUFNLEVBQ0ozc0IsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBRyxJQUFJO1FBQ1IsTUFBTTB4RyxjQUFjLElBQUl2c0c7UUFDeEIsTUFBTXdzRyxjQUFjdmdKLEtBQUtELElBQUksQ0FBQzR1QyxRQUFRZ29CLGNBQWMycEYsWUFBWXJzRyxFQUFFO1FBQ2xFLE1BQU11c0csZUFBZXhnSixLQUFLRCxJQUFJLENBQUM2dUMsU0FBU2dvQixlQUFlMHBGLFlBQVlwc0csRUFBRTtRQUNyRSxNQUFNNEosU0FBUyxJQUFJLENBQUMsQ0FBQ0EsTUFBTTtRQUMzQixJQUFJLENBQUNBLFVBQVVBLE9BQU9uUCxLQUFLLEtBQUs0eEcsZUFBZXppRyxPQUFPbFAsTUFBTSxLQUFLNHhHLGNBQWM7WUFDN0U7UUFDRjtRQUNBMWlHLE9BQU9uUCxLQUFLLEdBQUc0eEc7UUFDZnppRyxPQUFPbFAsTUFBTSxHQUFHNHhHO1FBQ2hCLE1BQU1qaEksU0FBUyxJQUFJLENBQUMsQ0FBQ2kvQixLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUNqL0IsTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDa2hJLFdBQVcsQ0FBQ0YsYUFBYUM7UUFDM0UsTUFBTXJ0RyxNQUFNMkssT0FBT0MsVUFBVSxDQUFDO1FBQzlCNUssSUFBSWpyQyxNQUFNLEdBQUcsSUFBSSxDQUFDeXhDLFVBQVUsQ0FBQ3dPLFNBQVM7UUFDdENoVixJQUFJaUwsU0FBUyxDQUFDNytCLFFBQVEsR0FBRyxHQUFHQSxPQUFPb3ZCLEtBQUssRUFBRXB2QixPQUFPcXZCLE1BQU0sRUFBRSxHQUFHLEdBQUcyeEcsYUFBYUM7SUFDOUU7SUFDQSxDQUFDUyxlQUFlLENBQUNDLEtBQUs7UUFDcEIsSUFBSUEsT0FBTztZQUNULElBQUksSUFBSSxDQUFDLENBQUMxaUcsS0FBSyxFQUFFO2dCQUNmLE1BQU1yaEMsTUFBTSxJQUFJLENBQUN3OEIsVUFBVSxDQUFDNGMsWUFBWSxDQUFDeFcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDdStGLFFBQVE7Z0JBQ2pFLElBQUluaEksS0FBSztvQkFDUCxPQUFPQTtnQkFDVDtZQUNGO1lBQ0EsTUFBTTJnQyxTQUFTdjJDLFNBQVMySSxhQUFhLENBQUM7WUFDckMsR0FDQ3krQixPQUFPbVAsT0FBT25QLEtBQUssRUFDbkJDLFFBQVFrUCxPQUFPbFAsTUFBTSxFQUN0QixHQUFHLElBQUksQ0FBQyxDQUFDcnZCLE1BQU07WUFDaEIsTUFBTTR6QixNQUFNMkssT0FBT0MsVUFBVSxDQUFDO1lBQzlCNUssSUFBSWlMLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQzcrQixNQUFNLEVBQUUsR0FBRztZQUMvQixPQUFPdStCLE9BQU9xakcsU0FBUztRQUN6QjtRQUNBLElBQUksSUFBSSxDQUFDLENBQUMzaUcsS0FBSyxFQUFFO1lBQ2YsTUFBTSxDQUFDelAsV0FBV0MsV0FBVyxHQUFHLElBQUksQ0FBQ2t5QixjQUFjO1lBQ25ELE1BQU12eUIsUUFBUTN1QyxLQUFLNjFDLEtBQUssQ0FBQyxJQUFJLENBQUNsSCxLQUFLLEdBQUdJLFlBQVl4QyxjQUFjRSxnQkFBZ0I7WUFDaEYsTUFBTW1DLFNBQVM1dUMsS0FBSzYxQyxLQUFLLENBQUMsSUFBSSxDQUFDakgsTUFBTSxHQUFHSSxhQUFhekMsY0FBY0UsZ0JBQWdCO1lBQ25GLE1BQU1vVCxZQUFZLElBQUkvZ0IsZ0JBQWdCNlAsT0FBT0M7WUFDN0MsTUFBTXVFLE1BQU0wTSxVQUFVOUIsVUFBVSxDQUFDO1lBQ2pDNUssSUFBSWlMLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQzcrQixNQUFNLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDQSxNQUFNLENBQUNvdkIsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDcHZCLE1BQU0sQ0FBQ3F2QixNQUFNLEVBQUUsR0FBRyxHQUFHRCxPQUFPQztZQUN4RixPQUFPaVIsVUFBVUMscUJBQXFCO1FBQ3hDO1FBQ0EsT0FBT2o5QyxnQkFBZ0IsSUFBSSxDQUFDLENBQUMwYyxNQUFNO0lBQ3JDO0lBQ0EsYUFBYXF3QyxZQUFZN2xELElBQUksRUFBRStoQyxNQUFNLEVBQUUwUSxTQUFTLEVBQUU7UUFDaEQsSUFBSWl2RCxjQUFjO1FBQ2xCLElBQUlrekMsZ0JBQWdCO1FBQ3BCLElBQUk1MEksZ0JBQWdCeWxILHdCQUF3QjtZQUMxQyxNQUFNLEVBQ0p6bEgsTUFBTSxFQUNKdTNCLElBQUksRUFDSnlNLFFBQVEsRUFDUjUvQixFQUFFLEVBQ0ZpekksWUFBWSxFQUNabnZGLFFBQVEsRUFDUjhILFFBQVEsRUFDUjdILFdBQVcsRUFDWDZPLFlBQVksRUFDWkMsZ0JBQWdCLEVBQ2pCLEVBQ0R6cEIsU0FBUyxFQUNUekwsUUFBUSxFQUNOdkUsTUFBTSxFQUNKa2pCLFVBQVUsRUFDWCxFQUNGLEVBQ0QzTSxNQUFNLEVBQ1AsR0FBRy96QztZQUNKLElBQUl1MEksVUFBVS8rSDtZQUNkLElBQUl1K0IsUUFBUTtnQkFDVixPQUFPL3pDLEtBQUsrekMsTUFBTTtnQkFDakIsR0FDQzN2QyxJQUFJbXdJLFFBQVEsRUFDWi8rSCxNQUFNLEVBQ1AsR0FBR2k5QixVQUFVK1osWUFBWSxDQUFDM1csYUFBYSxDQUFDckksVUFBVXBwQyxFQUFFLEVBQUUydkMsT0FBTTtnQkFDN0RBLE9BQU9sdkMsTUFBTTtZQUNmLE9BQU87Z0JBQ0wrdkksZ0JBQWdCO2dCQUNoQjUwSSxLQUFLcTRILFlBQVksR0FBRztZQUN0QjtZQUNBLE1BQU1ycEYsVUFBVSxDQUFDLE1BQU1qTixPQUFPdTFHLFdBQVcsQ0FBQzlmLGlCQUFpQixDQUFDLENBQUMsRUFBRXI2RixpQkFBaUIsRUFBRS80QixHQUFHLENBQUMsSUFBSTFTLElBQUksaUJBQWlCO1lBQy9HZ3dHLGNBQWMxaEcsT0FBTztnQkFDbkJxaUUsZ0JBQWdCNStDLHFCQUFxQkksS0FBSztnQkFDMUMwd0g7Z0JBQ0EvK0g7Z0JBQ0FvcUMsV0FBV2MsYUFBYTtnQkFDeEJucEIsTUFBTUEsS0FBS3ZsQyxLQUFLLENBQUM7Z0JBQ2pCZ3lDO2dCQUNBOGpCLHFCQUFxQjFqRDtnQkFDckJBO2dCQUNBNGpELFNBQVM7Z0JBQ1QwTSxtQkFBbUI7b0JBQ2pCdkYsWUFBWTtvQkFDWm5nQjtnQkFDRjtnQkFDQXlGLE9BQU87Z0JBQ1A0aUc7Z0JBQ0FudkY7Z0JBQ0E4SDtnQkFDQS9nQixTQUFTa1osYUFBYTl6QixPQUFPO2dCQUM3QjJpQztnQkFDQUM7WUFDRjtRQUNGO1FBQ0EsTUFBTW5vQixTQUFTLE1BQU0sS0FBSyxDQUFDK1csWUFBWTdsRCxNQUFNK2hDLFFBQVEwUTtRQUNyRCxNQUFNLEVBQ0psYixJQUFJLEVBQ0ovaEIsTUFBTSxFQUNOaS9ILFNBQVMsRUFDVEYsUUFBUSxFQUNSOS9GLEtBQUssRUFDTGlnQixpQkFBaUIsRUFDbEIsR0FBRzEwRDtRQUNKLElBQUk0MEksZUFBZTtZQUNqQm5pRyxVQUFVOGEsZ0JBQWdCLENBQUN2dEQsS0FBS29FLEVBQUUsRUFBRTBxQztZQUNwQ0EsT0FBTyxDQUFDOGxHLGFBQWEsR0FBRztRQUMxQixPQUFPLElBQUlMLFlBQVk5aEcsVUFBVStaLFlBQVksQ0FBQ3BXLFNBQVMsQ0FBQ20rRixXQUFXO1lBQ2pFemxHLE9BQU8sQ0FBQ3lsRyxRQUFRLEdBQUdBO1lBQ25CLElBQUkvK0gsUUFBUTtnQkFDVnM1QixPQUFPLENBQUN0NUIsTUFBTSxHQUFHQTtZQUNuQjtRQUNGLE9BQU87WUFDTHM1QixPQUFPLENBQUMybEcsU0FBUyxHQUFHQTtRQUN0QjtRQUNBM2xHLE9BQU8sQ0FBQzJGLEtBQUssR0FBR0E7UUFDaEIsTUFBTSxDQUFDbVksYUFBYUMsYUFBYSxHQUFHL2QsT0FBT3FvQixjQUFjO1FBQ3pEcm9CLE9BQU9sSyxLQUFLLEdBQUcsQ0FBQ3JOLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLElBQUlxMUI7UUFDckM5ZCxPQUFPakssTUFBTSxHQUFHLENBQUN0TixJQUFJLENBQUMsRUFBRSxHQUFHQSxJQUFJLENBQUMsRUFBRSxJQUFJczFCO1FBQ3RDLElBQUk2SCxtQkFBbUI7WUFDckI1bEIsT0FBT3d2QixXQUFXLEdBQUc1SjtRQUN2QjtRQUNBNWxCLE9BQU82bkIsWUFBWSxHQUFHK3FDO1FBQ3RCLElBQUkxaEcsS0FBS2l2QyxPQUFPLEVBQUU7WUFDaEJILE9BQU8rdkIsY0FBYyxDQUFDNytEO1FBQ3hCO1FBQ0E4dUMsT0FBTyxDQUFDZ21HLHVCQUF1QixHQUFHLENBQUMsQ0FBQ3B6QztRQUNwQyxPQUFPNXlEO0lBQ1Q7SUFDQTBJLFVBQVUwWCxlQUFlLEtBQUssRUFBRTkwQyxVQUFVLElBQUksRUFBRTtRQUM5QyxJQUFJLElBQUksQ0FBQ3VpQyxPQUFPLElBQUk7WUFDbEIsT0FBTztRQUNUO1FBQ0EsSUFBSSxJQUFJLENBQUNxTCxPQUFPLEVBQUU7WUFDaEIsT0FBTyxJQUFJLENBQUNvYSxnQkFBZ0I7UUFDOUI7UUFDQSxNQUFNNWMsYUFBYTF6RCxPQUFPa3ZDLE1BQU0sQ0FBQyxLQUFLLENBQUN3VyxVQUFVMFgsZUFBZTtZQUM5RHFsRixVQUFVLElBQUksQ0FBQyxDQUFDQSxRQUFRO1lBQ3hCOS9GLE9BQU8sSUFBSSxDQUFDLENBQUNBLEtBQUs7UUFDcEI7UUFDQSxJQUFJLENBQUNyRCxVQUFVLENBQUNvVTtRQUNoQixJQUFJMEosY0FBYztZQUNoQjFKLFdBQVdpdkYsU0FBUyxHQUFHLElBQUksQ0FBQyxDQUFDeUMsZUFBZSxDQUFDO1lBQzdDMXhGLFdBQVdrUCxpQkFBaUIsR0FBRyxJQUFJLENBQUMrSixnQkFBZ0IsQ0FBQztZQUNyRGpaLFdBQVcrYyxNQUFNLEdBQUc7WUFDcEIsT0FBTy9jO1FBQ1Q7UUFDQSxNQUFNLEVBQ0oySixVQUFVLEVBQ1ZuZ0IsT0FBTyxFQUNSLEdBQUcsSUFBSSxDQUFDeXZCLGdCQUFnQixDQUFDO1FBQzFCLElBQUksQ0FBQ3RQLGNBQWNuZ0IsU0FBUztZQUMxQndXLFdBQVdrUCxpQkFBaUIsR0FBRztnQkFDN0J0OEQsTUFBTTtnQkFDTmk4SSxLQUFLcmxHO1lBQ1A7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDOFksbUJBQW1CLEVBQUU7WUFDNUIsTUFBTXl2RixVQUFVLElBQUksQ0FBQyxDQUFDdGIsaUJBQWlCLENBQUN6MkU7WUFDeEMsSUFBSSt4RixRQUFRQyxNQUFNLEVBQUU7Z0JBQ2xCLE9BQU87WUFDVDtZQUNBLElBQUlELFFBQVFFLGFBQWEsRUFBRTtnQkFDekIsT0FBT2p5RixXQUFXa1AsaUJBQWlCO1lBQ3JDLE9BQU87Z0JBQ0xsUCxXQUFXa1AsaUJBQWlCLENBQUMyaUYsWUFBWSxHQUFHLElBQUksQ0FBQzFnRixZQUFZLENBQUMwZ0YsWUFBWSxJQUFJLENBQUM7WUFDakY7WUFDQTd4RixXQUFXcGhELEVBQUUsR0FBRyxJQUFJLENBQUMwakQsbUJBQW1CO1lBQ3hDLE9BQU90QyxXQUFXK3VGLFFBQVE7WUFDMUIsT0FBTy91RjtRQUNUO1FBQ0EsSUFBSXByQyxZQUFZLE1BQU07WUFDcEIsT0FBT29yQztRQUNUO1FBQ0FwckMsUUFBUXM5SCxNQUFNLEtBQUssSUFBSS82RztRQUN2QixNQUFNZzdHLE9BQU8sSUFBSSxDQUFDLENBQUNsakcsS0FBSyxHQUFHLENBQUMrUSxXQUFXanVCLElBQUksQ0FBQyxFQUFFLEdBQUdpdUIsV0FBV2p1QixJQUFJLENBQUMsRUFBRSxJQUFLaXVCLENBQUFBLFdBQVdqdUIsSUFBSSxDQUFDLEVBQUUsR0FBR2l1QixXQUFXanVCLElBQUksQ0FBQyxFQUFFLElBQUk7UUFDbkgsSUFBSSxDQUFDbmQsUUFBUXM5SCxNQUFNLENBQUN6L0ksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDczhJLFFBQVEsR0FBRztZQUN2Q242SCxRQUFRczlILE1BQU0sQ0FBQzEvSSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUN1OEksUUFBUSxFQUFFO2dCQUNqQ29EO2dCQUNBbnlGO1lBQ0Y7WUFDQUEsV0FBV2h3QyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMwaEksZUFBZSxDQUFDO1FBQzVDLE9BQU8sSUFBSSxJQUFJLENBQUMsQ0FBQ3ppRyxLQUFLLEVBQUU7WUFDdEIsTUFBTW1qRyxXQUFXeDlILFFBQVFzOUgsTUFBTSxDQUFDaG1KLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzZpSixRQUFRO1lBQ2xELElBQUlvRCxPQUFPQyxTQUFTRCxJQUFJLEVBQUU7Z0JBQ3hCQyxTQUFTRCxJQUFJLEdBQUdBO2dCQUNoQkMsU0FBU3B5RixVQUFVLENBQUNod0MsTUFBTSxDQUFDNVksS0FBSztnQkFDaENnN0ksU0FBU3B5RixVQUFVLENBQUNod0MsTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDMGhJLGVBQWUsQ0FBQztZQUNyRDtRQUNGO1FBQ0EsT0FBTzF4RjtJQUNUO0lBQ0EsQ0FBQ3kyRSxpQkFBaUIsQ0FBQ3oyRSxVQUFVO1FBQzNCLE1BQU0sRUFDSjVGLFNBQVMsRUFDVDhVLG1CQUFtQixFQUNqQjFsQixPQUFPLEVBQ1IsRUFDRixHQUFHLElBQUksQ0FBQzJuQixZQUFZO1FBQ3JCLE1BQU1raEYsa0JBQWtCcnlGLFdBQVc1RixTQUFTLEtBQUtBO1FBQ2pELE1BQU02M0YsZ0JBQWdCLENBQUNqeUYsV0FBV2tQLGlCQUFpQixFQUFFMi9FLE9BQU8sRUFBQyxNQUFPcmxHO1FBQ3BFLE9BQU87WUFDTHdvRyxRQUFRLENBQUMsSUFBSSxDQUFDejRFLGdCQUFnQixJQUFJLENBQUMsSUFBSSxDQUFDM0UsYUFBYSxJQUFJLENBQUMsSUFBSSxDQUFDQyxlQUFlLElBQUl3OUUsbUJBQW1CSjtZQUNyR0E7UUFDRjtJQUNGO0lBQ0F2cUYsd0JBQXdCakYsVUFBVSxFQUFFO1FBQ2xDLElBQUksSUFBSSxDQUFDRCxPQUFPLEVBQUU7WUFDaEJDLFdBQVd4WCxJQUFJO1lBQ2YsT0FBTztRQUNUO1FBQ0F3WCxXQUFXa2MsWUFBWSxDQUFDO1lBQ3RCNXNDLE1BQU0sSUFBSSxDQUFDaXFDLFVBQVU7WUFDckIvQixPQUFPLElBQUksQ0FBQ3h3QixPQUFPO1FBQ3JCO1FBQ0EsT0FBTztJQUNUO0FBQ0Y7RUFFQyxrREFBa0Q7QUFnQm5ELE1BQU02b0c7SUFDSixDQUFDaGhCLG9CQUFvQixDQUFDO0lBQ3RCLENBQUNpaEIsVUFBVSxDQUFTO0lBQ3BCLENBQUM5ekUsZUFBZSxDQUFRO0lBQ3hCLENBQUMrekUsT0FBTyxDQUFRO0lBQ2hCLENBQUNDLG9CQUFvQixDQUFRO0lBQzdCLENBQUMxeUYsT0FBTyxDQUFhO0lBQ3JCLENBQUMyeUYsY0FBYyxDQUFTO0lBQ3hCLENBQUNDLFdBQVcsQ0FBUztJQUNyQixDQUFDQyxVQUFVLENBQVM7SUFDcEIsQ0FBQ0MsU0FBUyxDQUFRO0lBQ2xCLENBQUNDLGNBQWMsQ0FBUTtJQUN2QixDQUFDbDJGLFNBQVMsQ0FBUTtJQUNsQixDQUFDbTJGLGVBQWUsQ0FBUTtJQUN4QixDQUFDQyxtQkFBbUIsQ0FBUTtJQUM1QixDQUFDQyx3QkFBd0IsQ0FBTTtJQUMvQixDQUFDaG1HLFNBQVMsQ0FBQzs7YUFDSmltRyxlQUFlOztJQUN0QixPQUFPLENBQUN0L0YsV0FBVyxHQUFHLElBQUl6YyxJQUFJO1FBQUNnOEY7UUFBZ0JpVDtRQUFXMEk7UUFBYXBUO1FBQWlCZ1M7S0FBZ0IsQ0FBQzU0SSxHQUFHLENBQUNsQyxDQUFBQSxPQUFRO1lBQUNBLEtBQUt1dkQsV0FBVztZQUFFdnZEO1NBQUssR0FBRztJQUNoSnZGLFlBQVksRUFDVjQvQyxTQUFTLEVBQ1RtTixTQUFTLEVBQ1RqZSxHQUFHLEVBQ0hxMUYsZUFBZSxFQUNmRixvQkFBb0IsRUFDcEI3eUQsZUFBZSxFQUNmcStELFNBQVMsRUFDVGxnRixTQUFTLEVBQ1R4Z0IsUUFBUSxFQUNSMnNCLElBQUksRUFDTCxDQUFFO2FBNUJILENBQUN3cEYsVUFBVSxHQUFHO2FBQ2QsQ0FBQzl6RSxlQUFlLEdBQUc7YUFDbkIsQ0FBQyt6RSxPQUFPLEdBQUc7YUFDWCxDQUFDQyxvQkFBb0IsR0FBRzthQUN4QixDQUFDMXlGLE9BQU8sR0FBRyxJQUFJNW9CO2FBQ2YsQ0FBQ3U3RyxjQUFjLEdBQUc7YUFDbEIsQ0FBQ0MsV0FBVyxHQUFHO2FBQ2YsQ0FBQ0MsVUFBVSxHQUFHO2FBQ2QsQ0FBQ0MsU0FBUyxHQUFHO2FBQ2IsQ0FBQ0MsY0FBYyxHQUFHO2FBQ2xCLENBQUNsMkYsU0FBUyxHQUFHO2FBQ2IsQ0FBQ20yRixlQUFlLEdBQUc7YUFDbkIsQ0FBQ0MsbUJBQW1CLEdBQUc7YUFDdkIsQ0FBQ0Msd0JBQXdCLEdBQUcsQ0FBQztRQWdCM0IsTUFBTXIvRixjQUFjO2VBQUkwK0Ysc0JBQXNCLENBQUMxK0YsV0FBVyxDQUFDN2lDLE1BQU07U0FBRztRQUNwRSxJQUFJLENBQUN1aEksc0JBQXNCWSxZQUFZLEVBQUU7WUFDdkNaLHNCQUFzQlksWUFBWSxHQUFHO1lBQ3JDLEtBQUssTUFBTTVuRyxjQUFjc0ksWUFBYTtnQkFDcEN0SSxXQUFXd2QsVUFBVSxDQUFDQyxNQUFNOWI7WUFDOUI7UUFDRjtRQUNBQSxVQUFVNFQsbUJBQW1CLENBQUNqTjtRQUM5QixJQUFJLENBQUMsQ0FBQzNHLFNBQVMsR0FBR0E7UUFDbEIsSUFBSSxDQUFDbU4sU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNqZSxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDLENBQUNtMUYsb0JBQW9CLEdBQUdBO1FBQzdCLElBQUksQ0FBQyxDQUFDN3lELGVBQWUsR0FBR0E7UUFDeEIsSUFBSSxDQUFDcmlDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDLENBQUN3Z0IsU0FBUyxHQUFHQTtRQUNsQixJQUFJLENBQUNrZ0YsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNnVixXQUFXLEdBQUd0Z0I7UUFDbkIsSUFBSSxDQUFDLENBQUN2a0YsU0FBUyxDQUFDaVUsUUFBUSxDQUFDLElBQUk7SUFDL0I7SUFDQSxJQUFJL0osVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDLENBQUM0SSxPQUFPLENBQUM5Z0QsSUFBSSxLQUFLO0lBQ2hDO0lBQ0EsSUFBSWswSSxjQUFjO1FBQ2hCLE9BQU8sSUFBSSxDQUFDaDhGLE9BQU8sSUFBSSxJQUFJLENBQUMsQ0FBQ2xLLFNBQVMsQ0FBQzZaLE9BQU8sT0FBTzdvQyxxQkFBcUJDLElBQUk7SUFDaEY7SUFDQWdsQyxjQUFjbDJELE9BQU8sRUFBRTtRQUNyQixJQUFJLENBQUMsQ0FBQ2lnRCxTQUFTLENBQUNpVyxhQUFhLENBQUNsMkQ7SUFDaEM7SUFDQXMwRCxXQUFXbndDLE9BQU8sSUFBSSxDQUFDLENBQUM4N0IsU0FBUyxDQUFDNlosT0FBTyxFQUFFLEVBQUU7UUFDM0MsSUFBSSxDQUFDLENBQUMraUQsT0FBTztRQUNiLE9BQVExNEY7WUFDTixLQUFLOE0scUJBQXFCQyxJQUFJO2dCQUM1QixJQUFJLENBQUNpZSxHQUFHLENBQUMrSixTQUFTLENBQUMrVixNQUFNLENBQUMsY0FBYztnQkFDeEMsSUFBSSxDQUFDbTNGLG9CQUFvQjtnQkFDekIsSUFBSSxDQUFDeDlFLG1CQUFtQixDQUFDO2dCQUN6QixJQUFJLENBQUN5OUUsa0NBQWtDLENBQUM7Z0JBQ3hDLElBQUksQ0FBQzV2RixZQUFZO2dCQUNqQjtZQUNGLEtBQUt4bEMscUJBQXFCSyxHQUFHO2dCQUMzQixJQUFJLENBQUM4MEgsb0JBQW9CO2dCQUN6QixJQUFJLENBQUN4OUUsbUJBQW1CLENBQUM7Z0JBQ3pCLElBQUksQ0FBQ2xTLFdBQVc7Z0JBQ2hCO1lBQ0YsS0FBS3psQyxxQkFBcUJHLFNBQVM7Z0JBQ2pDLElBQUksQ0FBQ2sxSCxtQkFBbUI7Z0JBQ3hCLElBQUksQ0FBQzE5RSxtQkFBbUIsQ0FBQztnQkFDekIsSUFBSSxDQUFDblMsWUFBWTtnQkFDakI7WUFDRjtnQkFDRSxJQUFJLENBQUMydkYsb0JBQW9CO2dCQUN6QixJQUFJLENBQUN4OUUsbUJBQW1CLENBQUM7Z0JBQ3pCLElBQUksQ0FBQ2xTLFdBQVc7UUFDcEI7UUFDQSxJQUFJLENBQUMydkYsa0NBQWtDLENBQUM7UUFDeEMsTUFBTSxFQUNKbnRHLFNBQVMsRUFDVixHQUFHLElBQUksQ0FBQy9KLEdBQUc7UUFDWitKLFVBQVUrVixNQUFNLENBQUMsY0FBYztRQUMvQixJQUFJOXFDLFNBQVM4TSxxQkFBcUJNLEtBQUssRUFBRTtZQUN2QzJuQixVQUFVK1YsTUFBTSxDQUFDLGtCQUFrQjtRQUNyQyxPQUFPO1lBQ0wvVixVQUFVK1YsTUFBTSxDQUFDLGtCQUFrQjtZQUNuQyxLQUFLLE1BQU0zUSxjQUFjZ25HLHNCQUFzQixDQUFDMStGLFdBQVcsQ0FBQzdpQyxNQUFNLEdBQUk7Z0JBQ3BFbTFCLFVBQVUrVixNQUFNLENBQUMsQ0FBQyxFQUFFM1EsV0FBV3dtQixLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUzZ0QsU0FBU202QixXQUFXNlcsV0FBVztZQUNoRjtRQUNGO1FBQ0EsSUFBSSxDQUFDaG1CLEdBQUcsQ0FBQ1csTUFBTSxHQUFHO0lBQ3BCO0lBQ0FnZ0IsYUFBYUYsU0FBUyxFQUFFO1FBQ3RCLE9BQU9BLGNBQWMsSUFBSSxDQUFDLENBQUNBLFNBQVMsRUFBRXpnQjtJQUN4QztJQUNBeWtCLGdCQUFnQjFKLFNBQVMsRUFBRTtRQUN6QixJQUFJLENBQUMsQ0FBQ2pLLFNBQVMsQ0FBQzJULGVBQWUsQ0FBQzFKO0lBQ2xDO0lBQ0FzSixZQUFZdDhDLE1BQU0sRUFBRTtRQUNsQixJQUFJLENBQUMsQ0FBQytvQyxTQUFTLENBQUN1VCxXQUFXLENBQUN0OEM7SUFDOUI7SUFDQThnRCxlQUFlcHlELElBQUksRUFBRTtRQUNuQixJQUFJLENBQUMsQ0FBQ3E2QyxTQUFTLENBQUMrWCxjQUFjLENBQUNweUQ7SUFDakM7SUFDQTZyRCxjQUFjb0wsVUFBVSxLQUFLLEVBQUU7UUFDN0IsSUFBSSxDQUFDMXRCLEdBQUcsQ0FBQytKLFNBQVMsQ0FBQytWLE1BQU0sQ0FBQyxXQUFXLENBQUM0TjtJQUN4QztJQUNBK0wsb0JBQW9CL0wsVUFBVSxLQUFLLEVBQUU7UUFDbkMsSUFBSSxDQUFDMXRCLEdBQUcsQ0FBQytKLFNBQVMsQ0FBQytWLE1BQU0sQ0FBQyxZQUFZLENBQUM0TjtJQUN6QztJQUNBd3BGLG1DQUFtQ3hwRixVQUFVLEtBQUssRUFBRTtRQUNsRCxJQUFJLENBQUMsQ0FBQzRVLGVBQWUsRUFBRXRpQyxJQUFJK0osVUFBVStWLE9BQU8sWUFBWSxDQUFDNE47SUFDM0Q7SUFDQSxJQUFJLENBQUMwcEYsa0JBQWtCO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLENBQUN4ekYsT0FBTyxDQUFDOWdELElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDOGdELE9BQU8sQ0FBQ2h2QyxNQUFNLEtBQUssSUFBSSxDQUFDLENBQUNrOEIsU0FBUyxDQUFDMlcsVUFBVSxDQUFDLElBQUksQ0FBQ3hKLFNBQVM7SUFDdEc7SUFDQSxNQUFNK0csU0FBUztRQUNiLElBQUksQ0FBQyxDQUFDeXhGLFVBQVUsR0FBRztRQUNuQixJQUFJLENBQUN6MkcsR0FBRyxDQUFDcVAsUUFBUSxHQUFHO1FBQ3BCLElBQUksQ0FBQ29xQixtQkFBbUIsQ0FBQztRQUN6QixJQUFJLENBQUN6NUIsR0FBRyxDQUFDK0osU0FBUyxDQUFDK1YsTUFBTSxDQUFDLGNBQWM7UUFDeEMsSUFBSSxDQUFDLENBQUMrMkYsbUJBQW1CLEVBQUU5NUc7UUFDM0IsSUFBSSxDQUFDLENBQUM4NUcsbUJBQW1CLEdBQUc7UUFDNUIsTUFBTVEsdUJBQXVCLElBQUl2eEk7UUFDakMsS0FBSyxNQUFNcW5DLFVBQVUsSUFBSSxDQUFDLENBQUNpcUcsa0JBQWtCLENBQUU7WUFDN0NqcUcsT0FBTzIwQixhQUFhO1lBQ3BCMzBCLE9BQU82QixJQUFJLENBQUM7WUFDWixJQUFJN0IsT0FBT2daLG1CQUFtQixFQUFFO2dCQUM5QixJQUFJLENBQUMsQ0FBQ3JWLFNBQVMsQ0FBQ29YLCtCQUErQixDQUFDL2E7Z0JBQ2hEa3FHLHFCQUFxQjF6SSxHQUFHLENBQUN3cEMsT0FBT2daLG1CQUFtQjtZQUNyRDtRQUNGO1FBQ0EsTUFBTW1jLGtCQUFrQixJQUFJLENBQUMsQ0FBQ0EsZUFBZTtRQUM3QyxJQUFJQSxpQkFBaUI7WUFDbkIsS0FBSyxNQUFNc3ZELFlBQVl0dkQsZ0JBQWdCcTBELHNCQUFzQixHQUFJO2dCQUMvRC9FLFNBQVM5aUYsSUFBSTtnQkFDYixJQUFJLElBQUksQ0FBQyxDQUFDZ0MsU0FBUyxDQUFDa1gsMEJBQTBCLENBQUM0cEUsU0FBU3Z6SCxJQUFJLENBQUNvRSxFQUFFLEdBQUc7b0JBQ2hFO2dCQUNGO2dCQUNBLElBQUk0MEkscUJBQXFCL2dKLEdBQUcsQ0FBQ3M3SCxTQUFTdnpILElBQUksQ0FBQ29FLEVBQUUsR0FBRztvQkFDOUM7Z0JBQ0Y7Z0JBQ0EsTUFBTTBxQyxTQUFTLE1BQU0sSUFBSSxDQUFDK1csV0FBVyxDQUFDMHRFO2dCQUN0QyxJQUFJLENBQUN6a0YsUUFBUTtvQkFDWDtnQkFDRjtnQkFDQSxJQUFJLENBQUNnYixZQUFZLENBQUNoYjtnQkFDbEJBLE9BQU8yMEIsYUFBYTtZQUN0QjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUMyMEUsVUFBVSxHQUFHO1FBQ25CLElBQUksQ0FBQyxDQUFDM2xHLFNBQVMsQ0FBQ3FLLFNBQVMsQ0FBQ21FLFFBQVEsQ0FBQyxtQkFBbUI7WUFDcEQvdEQsUUFBUSxJQUFJO1lBQ1p3dEQsWUFBWSxJQUFJLENBQUNkLFNBQVMsR0FBRztRQUMvQjtJQUNGO0lBQ0FnSCxVQUFVO1FBQ1IsSUFBSSxDQUFDLENBQUN1eEYsV0FBVyxHQUFHO1FBQ3BCLElBQUksQ0FBQ3gyRyxHQUFHLENBQUNxUCxRQUFRLEdBQUcsQ0FBQztRQUNyQixJQUFJLENBQUNvcUIsbUJBQW1CLENBQUM7UUFDekIsSUFBSSxDQUFDejVCLEdBQUcsQ0FBQytKLFNBQVMsQ0FBQytWLE1BQU0sQ0FBQyxjQUFjO1FBQ3hDLElBQUksSUFBSSxDQUFDLENBQUNXLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDbzJGLG1CQUFtQixFQUFFO1lBQ2pELElBQUksQ0FBQyxDQUFDQSxtQkFBbUIsR0FBRyxJQUFJajZHO1lBQ2hDLE1BQU1DLFNBQVMsSUFBSSxDQUFDLENBQUNpVSxTQUFTLENBQUN3TCxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUN1NkYsbUJBQW1CO1lBQ3ZFLElBQUksQ0FBQyxDQUFDcDJGLFNBQVMsQ0FBQ3pnQixHQUFHLENBQUMvQyxnQkFBZ0IsQ0FBQyxlQUFlMzVCLENBQUFBO2dCQUNsRCxNQUFNZzBJLHNCQUFzQjtnQkFDNUIsTUFBTSxFQUNKbjRFLE9BQU8sRUFDUEMsT0FBTyxFQUNQcW5FLFNBQVMsRUFDVixHQUFHbmpJO2dCQUNKLE1BQU13ekksMkJBQTJCLElBQUksQ0FBQyxDQUFDQSx3QkFBd0I7Z0JBQy9ELElBQUlyUSxZQUFZcVEsMkJBQTJCUSxxQkFBcUI7b0JBQzlELElBQUksQ0FBQyxDQUFDUix3QkFBd0IsR0FBR3JRO29CQUNqQztnQkFDRjtnQkFDQSxJQUFJLENBQUMsQ0FBQ3FRLHdCQUF3QixHQUFHLENBQUM7Z0JBQ2xDLE1BQU0sRUFDSi9zRyxTQUFTLEVBQ1YsR0FBRyxJQUFJLENBQUMvSixHQUFHO2dCQUNaK0osVUFBVStWLE1BQU0sQ0FBQyxlQUFlO2dCQUNoQyxNQUFNL2pDLFdBQVdsZ0IsU0FBUzA3SSxpQkFBaUIsQ0FBQ3A0RSxTQUFTQztnQkFDckRyMUIsVUFBVStWLE1BQU0sQ0FBQyxlQUFlO2dCQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDOWYsR0FBRyxDQUFDNFosUUFBUSxDQUFDNzlCLFFBQVEsQ0FBQyxFQUFFLEdBQUc7b0JBQ25DO2dCQUNGO2dCQUNBLElBQUl0WjtnQkFDSixNQUFNeVgsUUFBUSxJQUFJOHJCLE9BQU8sQ0FBQyxDQUFDLEVBQUVua0IsdUJBQXVCLE9BQU8sQ0FBQztnQkFDNUQsS0FBSyxNQUFNb2MsV0FBV2xpQixTQUFVO29CQUM5QixJQUFJN0IsTUFBTXRtQixJQUFJLENBQUNxcUMsUUFBUXg3QixFQUFFLEdBQUc7d0JBQzFCQSxLQUFLdzdCLFFBQVF4N0IsRUFBRTt3QkFDZjtvQkFDRjtnQkFDRjtnQkFDQSxJQUFJLENBQUNBLElBQUk7b0JBQ1A7Z0JBQ0Y7Z0JBQ0EsTUFBTTBxQyxTQUFTLElBQUksQ0FBQyxDQUFDeVcsT0FBTyxDQUFDN3pELEdBQUcsQ0FBQzBTO2dCQUNqQyxJQUFJMHFDLFFBQVFnWix3QkFBd0IsTUFBTTtvQkFDeEM3aUQsRUFBRXFpQyxlQUFlO29CQUNqQnJpQyxFQUFFbWlDLGNBQWM7b0JBQ2hCMEgsT0FBTzYwQixRQUFRLENBQUMxK0Q7Z0JBQ2xCO1lBQ0YsR0FBRztnQkFDRHU1QjtnQkFDQWdTLFNBQVM7WUFDWDtRQUNGO1FBQ0EsTUFBTXl6QixrQkFBa0IsSUFBSSxDQUFDLENBQUNBLGVBQWU7UUFDN0MsSUFBSUEsaUJBQWlCO1lBQ25CLE1BQU1rMUUscUJBQXFCLElBQUl4OEc7WUFDL0IsTUFBTXk4RyxtQkFBbUIsSUFBSXo4RztZQUM3QixLQUFLLE1BQU1tUyxVQUFVLElBQUksQ0FBQyxDQUFDaXFHLGtCQUFrQixDQUFFO2dCQUM3Q2pxRyxPQUFPMDBCLGNBQWM7Z0JBQ3JCLElBQUksQ0FBQzEwQixPQUFPZ1osbUJBQW1CLEVBQUU7b0JBQy9CaFosT0FBT2sxQiwyQkFBMkIsQ0FBQ0M7b0JBQ25DO2dCQUNGO2dCQUNBLElBQUluMUIsT0FBTzBJLFNBQVMsT0FBTyxNQUFNO29CQUMvQjJoRyxtQkFBbUJuaEosR0FBRyxDQUFDODJDLE9BQU9nWixtQkFBbUIsRUFBRWhaO29CQUNuRDtnQkFDRixPQUFPO29CQUNMc3FHLGlCQUFpQnBoSixHQUFHLENBQUM4MkMsT0FBT2daLG1CQUFtQixFQUFFaFo7Z0JBQ25EO2dCQUNBLElBQUksQ0FBQ3lwRixxQkFBcUIsQ0FBQ3pwRixPQUFPZ1osbUJBQW1CLEdBQUduWDtnQkFDeEQ3QixPQUFPanFDLE1BQU07WUFDZjtZQUNBLE1BQU13MEksWUFBWXAxRSxnQkFBZ0JxMEQsc0JBQXNCO1lBQ3hELEtBQUssTUFBTS9FLFlBQVk4bEIsVUFBVztnQkFDaEMsTUFBTSxFQUNKajFJLEVBQUUsRUFDSCxHQUFHbXZILFNBQVN2ekgsSUFBSTtnQkFDakIsSUFBSSxJQUFJLENBQUMsQ0FBQ3l5QyxTQUFTLENBQUNrWCwwQkFBMEIsQ0FBQ3ZsRCxLQUFLO29CQUNsRG12SCxTQUFTcHZELFlBQVksQ0FBQzt3QkFDcEJuYyxTQUFTO29CQUNYO29CQUNBO2dCQUNGO2dCQUNBLElBQUlsWixTQUFTc3FHLGlCQUFpQjFuSixHQUFHLENBQUMwUztnQkFDbEMsSUFBSTBxQyxRQUFRO29CQUNWQSxPQUFPczFCLHNCQUFzQixDQUFDbXZEO29CQUM5QnprRixPQUFPNkIsSUFBSSxDQUFDO29CQUNaNGlGLFNBQVM1aUYsSUFBSTtvQkFDYjtnQkFDRjtnQkFDQTdCLFNBQVNxcUcsbUJBQW1Cem5KLEdBQUcsQ0FBQzBTO2dCQUNoQyxJQUFJMHFDLFFBQVE7b0JBQ1YsSUFBSSxDQUFDLENBQUMyRCxTQUFTLENBQUNpWCw0QkFBNEIsQ0FBQzVhO29CQUM3QyxJQUFJQSxPQUFPb2UsdUJBQXVCLENBQUNxbUUsV0FBVzt3QkFDNUN6a0YsT0FBTzZCLElBQUksQ0FBQztvQkFDZDtnQkFDRjtnQkFDQTRpRixTQUFTNWlGLElBQUk7WUFDZjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUMwK0QsT0FBTztRQUNiLElBQUksSUFBSSxDQUFDMXlELE9BQU8sRUFBRTtZQUNoQixJQUFJLENBQUNoYixHQUFHLENBQUNXLE1BQU0sR0FBRztRQUNwQjtRQUNBLE1BQU0sRUFDSm9KLFNBQVMsRUFDVixHQUFHLElBQUksQ0FBQy9KLEdBQUc7UUFDWixLQUFLLE1BQU1tUCxjQUFjZ25HLHNCQUFzQixDQUFDMStGLFdBQVcsQ0FBQzdpQyxNQUFNLEdBQUk7WUFDcEVtMUIsVUFBVTdtQyxNQUFNLENBQUMsQ0FBQyxFQUFFaXNDLFdBQVd3bUIsS0FBSyxDQUFDLE9BQU8sQ0FBQztRQUMvQztRQUNBLElBQUksQ0FBQ3NoRixvQkFBb0I7UUFDekIsSUFBSSxDQUFDQyxrQ0FBa0MsQ0FBQztRQUN4QyxJQUFJLENBQUMsQ0FBQ1YsV0FBVyxHQUFHO0lBQ3RCO0lBQ0E1ZixzQkFBc0JuMEgsRUFBRSxFQUFFO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLENBQUM2L0QsZUFBZSxFQUFFczBELHNCQUFzQm4wSCxPQUFPO0lBQzdEO0lBQ0EybEQsZ0JBQWdCamIsTUFBTSxFQUFFO1FBQ3RCLE1BQU13cUcsZ0JBQWdCLElBQUksQ0FBQyxDQUFDN21HLFNBQVMsQ0FBQzBaLFNBQVM7UUFDL0MsSUFBSW10RixrQkFBa0J4cUcsUUFBUTtZQUM1QjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUMyRCxTQUFTLENBQUNzWCxlQUFlLENBQUNqYjtJQUNsQztJQUNBZ3FHLHNCQUFzQjtRQUNwQixJQUFJLENBQUNuM0csR0FBRyxDQUFDcVAsUUFBUSxHQUFHLENBQUM7UUFDckIsSUFBSSxJQUFJLENBQUMsQ0FBQ29SLFNBQVMsRUFBRXpnQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM0MkcsZUFBZSxFQUFFO1lBQ2xELElBQUksQ0FBQyxDQUFDQSxlQUFlLEdBQUcsSUFBSWg2RztZQUM1QixNQUFNQyxTQUFTLElBQUksQ0FBQyxDQUFDaVUsU0FBUyxDQUFDd0wsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDczZGLGVBQWU7WUFDbkUsSUFBSSxDQUFDLENBQUNuMkYsU0FBUyxDQUFDemdCLEdBQUcsQ0FBQy9DLGdCQUFnQixDQUFDLGVBQWUsSUFBSSxDQUFDLENBQUMyNkcsb0JBQW9CLENBQUMvakosSUFBSSxDQUFDLElBQUksR0FBRztnQkFDekZncEM7WUFDRjtZQUNBLElBQUksQ0FBQyxDQUFDNGpCLFNBQVMsQ0FBQ3pnQixHQUFHLENBQUMrSixTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1FBQ3BDO0lBQ0Y7SUFDQXN6SSx1QkFBdUI7UUFDckIsSUFBSSxDQUFDajNHLEdBQUcsQ0FBQ3FQLFFBQVEsR0FBRztRQUNwQixJQUFJLElBQUksQ0FBQyxDQUFDb1IsU0FBUyxFQUFFemdCLE9BQU8sSUFBSSxDQUFDLENBQUM0MkcsZUFBZSxFQUFFO1lBQ2pELElBQUksQ0FBQyxDQUFDQSxlQUFlLENBQUM3NUcsS0FBSztZQUMzQixJQUFJLENBQUMsQ0FBQzY1RyxlQUFlLEdBQUc7WUFDeEIsSUFBSSxDQUFDLENBQUNuMkYsU0FBUyxDQUFDemdCLEdBQUcsQ0FBQytKLFNBQVMsQ0FBQzdtQyxNQUFNLENBQUM7UUFDdkM7SUFDRjtJQUNBLENBQUMwMEksb0JBQW9CLENBQUN0NUcsS0FBSztRQUN6QixJQUFJLENBQUMsQ0FBQ3dTLFNBQVMsQ0FBQzJKLFdBQVc7UUFDM0IsTUFBTSxFQUNKbnNELE1BQU0sRUFDUCxHQUFHZ3dDO1FBQ0osSUFBSWh3QyxXQUFXLElBQUksQ0FBQyxDQUFDbXlELFNBQVMsQ0FBQ3pnQixHQUFHLElBQUksQ0FBQzF4QyxPQUFPdXdDLFlBQVksQ0FBQyxZQUFZLFNBQVN2d0MsT0FBT3k3QyxTQUFTLENBQUM2UCxRQUFRLENBQUMsZUFBYyxLQUFNLElBQUksQ0FBQyxDQUFDNkcsU0FBUyxDQUFDemdCLEdBQUcsQ0FBQzRaLFFBQVEsQ0FBQ3RyRCxTQUFTO1lBQ2xLLE1BQU0sRUFDSm9sQyxLQUFLLEVBQ04sR0FBR1IsaUJBQWlCSyxRQUFRO1lBQzdCLElBQUkrSyxNQUFNOFEsTUFBTSxLQUFLLEtBQUs5USxNQUFNeVgsT0FBTyxJQUFJcmlCLE9BQU87Z0JBQ2hEO1lBQ0Y7WUFDQSxJQUFJLENBQUMsQ0FBQ29kLFNBQVMsQ0FBQzJRLGNBQWMsQ0FBQyxhQUFhLE1BQU07WUFDbEQsSUFBSSxDQUFDLENBQUNoQixTQUFTLENBQUN6Z0IsR0FBRyxDQUFDK0osU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztZQUNsQyxJQUFJLENBQUMyK0MsYUFBYTtZQUNsQmk5RSxnQkFBZ0IrQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUN4eEYsU0FBUyxDQUFDeEMsU0FBUyxLQUFLLE9BQU87Z0JBQzNFaGdELFFBQVEsSUFBSSxDQUFDLENBQUNteUQsU0FBUyxDQUFDemdCLEdBQUc7Z0JBQzNCdnJDLEdBQUc2cEMsTUFBTTdwQyxDQUFDO2dCQUNWME0sR0FBR205QixNQUFNbjlCLENBQUM7WUFDWjtZQUNBLElBQUksQ0FBQyxDQUFDcy9DLFNBQVMsQ0FBQ3pnQixHQUFHLENBQUMvQyxnQkFBZ0IsQ0FBQyxhQUFhO2dCQUNoRCxJQUFJLENBQUMsQ0FBQ3dqQixTQUFTLENBQUN6Z0IsR0FBRyxDQUFDK0osU0FBUyxDQUFDN21DLE1BQU0sQ0FBQztnQkFDckMsSUFBSSxDQUFDby9DLGFBQWEsQ0FBQztZQUNyQixHQUFHO2dCQUNEakQsTUFBTTtnQkFDTnhpQixRQUFRLElBQUksQ0FBQyxDQUFDaVUsU0FBUyxDQUFDNUMsT0FBTztZQUNqQztZQUNBNVAsTUFBTW1ILGNBQWM7UUFDdEI7SUFDRjtJQUNBOGhCLGNBQWM7UUFDWixJQUFJLElBQUksQ0FBQyxDQUFDOHVGLE9BQU8sRUFBRTtZQUNqQjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNBLE9BQU8sR0FBRyxJQUFJejVHO1FBQ3BCLE1BQU1DLFNBQVMsSUFBSSxDQUFDLENBQUNpVSxTQUFTLENBQUN3TCxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMrNUYsT0FBTztRQUMzRCxJQUFJLENBQUNyMkcsR0FBRyxDQUFDL0MsZ0JBQWdCLENBQUMsZUFBZSxJQUFJLENBQUM2aEMsV0FBVyxDQUFDanJFLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDcEVncEM7UUFDRjtRQUNBLE1BQU0wbEIsWUFBWSxJQUFJLENBQUNBLFNBQVMsQ0FBQzF1RCxJQUFJLENBQUMsSUFBSTtRQUMxQyxJQUFJLENBQUNtc0MsR0FBRyxDQUFDL0MsZ0JBQWdCLENBQUMsYUFBYXNsQixXQUFXO1lBQ2hEMWxCO1FBQ0Y7UUFDQSxJQUFJLENBQUNtRCxHQUFHLENBQUMvQyxnQkFBZ0IsQ0FBQyxpQkFBaUJzbEIsV0FBVztZQUNwRDFsQjtRQUNGO0lBQ0Y7SUFDQXlxQixlQUFlO1FBQ2IsSUFBSSxDQUFDLENBQUMrdUYsT0FBTyxFQUFFdDVHO1FBQ2YsSUFBSSxDQUFDLENBQUNzNUcsT0FBTyxHQUFHO0lBQ2xCO0lBQ0F3QixPQUFPMXFHLE1BQU0sRUFBRTtRQUNiLElBQUksQ0FBQyxDQUFDeVcsT0FBTyxDQUFDdnRELEdBQUcsQ0FBQzgyQyxPQUFPMXFDLEVBQUUsRUFBRTBxQztRQUM3QixNQUFNLEVBQ0pnWixtQkFBbUIsRUFDcEIsR0FBR2haO1FBQ0osSUFBSWdaLHVCQUF1QixJQUFJLENBQUMsQ0FBQ3JWLFNBQVMsQ0FBQ2tYLDBCQUEwQixDQUFDN0Isc0JBQXNCO1lBQzFGLElBQUksQ0FBQyxDQUFDclYsU0FBUyxDQUFDbVgsOEJBQThCLENBQUM5YTtRQUNqRDtJQUNGO0lBQ0EvbUMsT0FBTyttQyxNQUFNLEVBQUU7UUFDYixJQUFJLENBQUMsQ0FBQ3lXLE9BQU8sQ0FBQ3RVLE1BQU0sQ0FBQ25DLE9BQU8xcUMsRUFBRTtRQUM5QixJQUFJLENBQUMsQ0FBQzB5SCxvQkFBb0IsRUFBRTJpQix5QkFBeUIzcUcsT0FBTyswQixVQUFVO1FBQ3RFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ3MwRSxXQUFXLElBQUlycEcsT0FBT2daLG1CQUFtQixFQUFFO1lBQ3BELElBQUksQ0FBQyxDQUFDclYsU0FBUyxDQUFDZ1gsMkJBQTJCLENBQUMzYTtRQUM5QztJQUNGO0lBQ0FqcUMsT0FBT2lxQyxNQUFNLEVBQUU7UUFDYixJQUFJLENBQUMvbUMsTUFBTSxDQUFDK21DO1FBQ1osSUFBSSxDQUFDLENBQUMyRCxTQUFTLENBQUM4VyxZQUFZLENBQUN6YTtRQUM3QkEsT0FBT25OLEdBQUcsQ0FBQzk4QixNQUFNO1FBQ2pCaXFDLE9BQU91b0IsZUFBZSxHQUFHO0lBQzNCO0lBQ0FuTCxhQUFhcGQsTUFBTSxFQUFFO1FBQ25CLElBQUlBLE9BQU8vTSxNQUFNLEtBQUssSUFBSSxFQUFFO1lBQzFCO1FBQ0Y7UUFDQSxJQUFJK00sT0FBTy9NLE1BQU0sSUFBSStNLE9BQU9nWixtQkFBbUIsRUFBRTtZQUMvQyxJQUFJLENBQUMsQ0FBQ3JWLFNBQVMsQ0FBQ2dYLDJCQUEyQixDQUFDM2EsT0FBT2daLG1CQUFtQjtZQUN0RTJNLGlCQUFpQmdELHVCQUF1QixDQUFDM29CO1lBQ3pDQSxPQUFPZ1osbUJBQW1CLEdBQUc7UUFDL0I7UUFDQSxJQUFJLENBQUMweEYsTUFBTSxDQUFDMXFHO1FBQ1pBLE9BQU8vTSxNQUFNLEVBQUVoNkIsT0FBTyttQztRQUN0QkEsT0FBT2dxQixTQUFTLENBQUMsSUFBSTtRQUNyQixJQUFJaHFCLE9BQU9uTixHQUFHLElBQUltTixPQUFPdW9CLGVBQWUsRUFBRTtZQUN4Q3ZvQixPQUFPbk4sR0FBRyxDQUFDOThCLE1BQU07WUFDakIsSUFBSSxDQUFDODhCLEdBQUcsQ0FBQ3A0QixNQUFNLENBQUN1bEMsT0FBT25OLEdBQUc7UUFDNUI7SUFDRjtJQUNBcjhCLElBQUl3cEMsTUFBTSxFQUFFO1FBQ1YsSUFBSUEsT0FBTy9NLE1BQU0sS0FBSyxJQUFJLElBQUkrTSxPQUFPdW9CLGVBQWUsRUFBRTtZQUNwRDtRQUNGO1FBQ0EsSUFBSSxDQUFDbkwsWUFBWSxDQUFDcGQ7UUFDbEIsSUFBSSxDQUFDLENBQUMyRCxTQUFTLENBQUM2VyxTQUFTLENBQUN4YTtRQUMxQixJQUFJLENBQUMwcUcsTUFBTSxDQUFDMXFHO1FBQ1osSUFBSSxDQUFDQSxPQUFPdW9CLGVBQWUsRUFBRTtZQUMzQixNQUFNMTFCLE1BQU1tTixPQUFPMU4sTUFBTTtZQUN6QixJQUFJLENBQUNPLEdBQUcsQ0FBQ3A0QixNQUFNLENBQUNvNEI7WUFDaEJtTixPQUFPdW9CLGVBQWUsR0FBRztRQUMzQjtRQUNBdm9CLE9BQU82cEIsaUJBQWlCO1FBQ3hCN3BCLE9BQU8yeUIsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMyMkUsVUFBVTtRQUNsQyxJQUFJLENBQUMsQ0FBQzNsRyxTQUFTLENBQUNpUixzQkFBc0IsQ0FBQzVVO1FBQ3ZDQSxPQUFPNGYsZ0JBQWdCLENBQUM1ZixPQUFPZzFCLG9CQUFvQjtJQUNyRDtJQUNBM0MsZ0JBQWdCcnlCLE1BQU0sRUFBRTtRQUN0QixJQUFJLENBQUNBLE9BQU91b0IsZUFBZSxFQUFFO1lBQzNCO1FBQ0Y7UUFDQSxNQUFNLEVBQ0o3YixhQUFhLEVBQ2QsR0FBR2grQztRQUNKLElBQUlzeEMsT0FBT25OLEdBQUcsQ0FBQzRaLFFBQVEsQ0FBQ0Msa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUN5OEYsb0JBQW9CLEVBQUU7WUFDckVucEcsT0FBT3VCLG1CQUFtQixHQUFHO1lBQzdCLElBQUksQ0FBQyxDQUFDNG5HLG9CQUFvQixHQUFHenVGLFdBQVc7Z0JBQ3RDLElBQUksQ0FBQyxDQUFDeXVGLG9CQUFvQixHQUFHO2dCQUM3QixJQUFJLENBQUNucEcsT0FBT25OLEdBQUcsQ0FBQzRaLFFBQVEsQ0FBQy85QyxTQUFTZytDLGFBQWEsR0FBRztvQkFDaEQxTSxPQUFPbk4sR0FBRyxDQUFDL0MsZ0JBQWdCLENBQUMsV0FBVzt3QkFDckNrUSxPQUFPdUIsbUJBQW1CLEdBQUc7b0JBQy9CLEdBQUc7d0JBQ0QyUSxNQUFNO3dCQUNOeGlCLFFBQVEsSUFBSSxDQUFDLENBQUNpVSxTQUFTLENBQUM1QyxPQUFPO29CQUNqQztvQkFDQTJMLGNBQWM0RixLQUFLO2dCQUNyQixPQUFPO29CQUNMdFMsT0FBT3VCLG1CQUFtQixHQUFHO2dCQUMvQjtZQUNGLEdBQUc7UUFDTDtRQUNBdkIsT0FBT2lvQixtQkFBbUIsR0FBRyxJQUFJLENBQUMsQ0FBQysvRCxvQkFBb0IsRUFBRVcsaUJBQWlCLElBQUksQ0FBQzkxRixHQUFHLEVBQUVtTixPQUFPbk4sR0FBRyxFQUFFbU4sT0FBTyswQixVQUFVLEVBQUU7SUFDckg7SUFDQS9aLGFBQWFoYixNQUFNLEVBQUU7UUFDbkIsSUFBSUEsT0FBTzh5QixnQkFBZ0IsSUFBSTtZQUM3Qjl5QixPQUFPL00sTUFBTSxLQUFLLElBQUk7WUFDdEIrTSxPQUFPbWQsT0FBTztZQUNkbmQsT0FBTzZCLElBQUk7UUFDYixPQUFPO1lBQ0wsSUFBSSxDQUFDcnJDLEdBQUcsQ0FBQ3dwQztRQUNYO0lBQ0Y7SUFDQXkwRixrQkFBa0J6MEYsTUFBTSxFQUFFO1FBQ3hCLE1BQU0ySCxNQUFNLElBQU0zSCxPQUFPYyxVQUFVLENBQUNxYyxPQUFPLENBQUNuZDtRQUM1QyxNQUFNNEgsT0FBTztZQUNYNUgsT0FBT2pxQyxNQUFNO1FBQ2Y7UUFDQSxJQUFJLENBQUNtaEQsV0FBVyxDQUFDO1lBQ2Z2UDtZQUNBQztZQUNBRSxVQUFVO1FBQ1o7SUFDRjtJQUNBaUosZUFBZXQxQyxHQUFHLEVBQUU7UUFDbEIsS0FBSyxNQUFNdWtDLFVBQVUsSUFBSSxDQUFDLENBQUN5VyxPQUFPLENBQUNodkMsTUFBTSxHQUFJO1lBQzNDLElBQUl1NEIsT0FBT3ZrQyxHQUFHLEtBQUtBLEtBQUs7Z0JBQ3RCLE9BQU91a0M7WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBQ0E4b0IsWUFBWTtRQUNWLE9BQU8sSUFBSSxDQUFDLENBQUNubEIsU0FBUyxDQUFDK1QsS0FBSztJQUM5QjtJQUNBLElBQUksQ0FBQ2t6RixpQkFBaUI7UUFDcEIsT0FBTzVCLHNCQUFzQixDQUFDMStGLFdBQVcsQ0FBQzFuRCxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMrZ0QsU0FBUyxDQUFDNlosT0FBTztJQUN2RTtJQUNBck8sZUFBZTNmLEVBQUUsRUFBRTtRQUNqQixPQUFPLElBQUksQ0FBQyxDQUFDbVUsU0FBUyxDQUFDd0wsY0FBYyxDQUFDM2Y7SUFDeEM7SUFDQSxDQUFDcTdHLGVBQWUsQ0FBQ2p3SSxNQUFNO1FBQ3JCLE1BQU1vbkMsYUFBYSxJQUFJLENBQUMsQ0FBQzRvRyxpQkFBaUI7UUFDMUMsT0FBTzVvRyxhQUFhLElBQUlBLFdBQVcvOUMsU0FBUyxDQUFDRixXQUFXLENBQUM2VyxVQUFVO0lBQ3JFO0lBQ0E4K0MsMEJBQTBCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLENBQUNreEYsaUJBQWlCLEVBQUVseEY7SUFDbEM7SUFDQSxNQUFNdXNGLFlBQVl2aUosT0FBTyxFQUFFa1gsTUFBTSxFQUFFO1FBQ2pDLElBQUksQ0FBQ2cvQyxhQUFhLENBQUNsMkQ7UUFDbkIsTUFBTSxJQUFJLENBQUMsQ0FBQ2lnRCxTQUFTLENBQUNxVSxVQUFVLENBQUN0MEQsUUFBUW1rQixJQUFJO1FBQzdDLE1BQU0sRUFDSnN0QixPQUFPLEVBQ1BDLE9BQU8sRUFDUixHQUFHLElBQUksQ0FBQyxDQUFDMDFHLGNBQWM7UUFDeEIsTUFBTXgxSSxLQUFLLElBQUksQ0FBQ3d6RCxTQUFTO1FBQ3pCLE1BQU05b0IsU0FBUyxJQUFJLENBQUMsQ0FBQzZxRyxlQUFlLENBQUM7WUFDbkM1M0csUUFBUSxJQUFJO1lBQ1ozOUI7WUFDQWhPLEdBQUc2dEM7WUFDSG5oQyxHQUFHb2hDO1lBQ0h1TyxXQUFXLElBQUksQ0FBQyxDQUFDQSxTQUFTO1lBQzFCcWtCLFlBQVk7WUFDWixHQUFHcHRELE1BQU07UUFDWDtRQUNBLElBQUlvbEMsUUFBUTtZQUNWLElBQUksQ0FBQ3hwQyxHQUFHLENBQUN3cEM7UUFDWDtJQUNGO0lBQ0EsTUFBTStXLFlBQVk3bEQsSUFBSSxFQUFFO1FBQ3RCLE9BQU8sTUFBTzgzSSxzQkFBc0IsQ0FBQzErRixXQUFXLENBQUMxbkQsR0FBRyxDQUFDc08sS0FBS3FpRSxjQUFjLElBQUlyaUUsS0FBS3dySCxvQkFBb0IsR0FBRzNsRSxZQUFZN2xELE1BQU0sSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDeXlDLFNBQVMsS0FBTTtJQUN2SjtJQUNBMFEsc0JBQXNCbGpCLEtBQUssRUFBRTYyQixVQUFVLEVBQUU5MkQsT0FBTyxDQUFDLENBQUMsRUFBRTtRQUNsRCxNQUFNb0UsS0FBSyxJQUFJLENBQUN3ekQsU0FBUztRQUN6QixNQUFNOW9CLFNBQVMsSUFBSSxDQUFDLENBQUM2cUcsZUFBZSxDQUFDO1lBQ25DNTNHLFFBQVEsSUFBSTtZQUNaMzlCO1lBQ0FoTyxHQUFHNnBDLE1BQU1nRSxPQUFPO1lBQ2hCbmhDLEdBQUdtOUIsTUFBTWlFLE9BQU87WUFDaEJ1TyxXQUFXLElBQUksQ0FBQyxDQUFDQSxTQUFTO1lBQzFCcWtCO1lBQ0EsR0FBRzkyRCxJQUFJO1FBQ1Q7UUFDQSxJQUFJOHVDLFFBQVE7WUFDVixJQUFJLENBQUN4cEMsR0FBRyxDQUFDd3BDO1FBQ1g7UUFDQSxPQUFPQTtJQUNUO0lBQ0EsSUFBSTJoQixxQkFBcUI7UUFDdkIsT0FBTyxJQUFJLENBQUM5dUIsR0FBRyxDQUFDNmYscUJBQXFCO0lBQ3ZDO0lBQ0EsQ0FBQ280RixjQUFjO1FBQ2IsTUFBTSxFQUNKeGpKLENBQUMsRUFDRDBNLENBQUMsRUFDRDhoQyxLQUFLLEVBQ0xDLE1BQU0sRUFDUCxHQUFHLElBQUksQ0FBQzRyQixrQkFBa0I7UUFDM0IsTUFBTXc1QixNQUFNaDBGLEtBQUs0UCxHQUFHLENBQUMsR0FBR3pQO1FBQ3hCLE1BQU0rekYsTUFBTWwwRixLQUFLNFAsR0FBRyxDQUFDLEdBQUcvQztRQUN4QixNQUFNdW5GLE1BQU1wMEYsS0FBS21GLEdBQUcsQ0FBQzZMLE9BQU9nN0QsVUFBVSxFQUFFN3JFLElBQUl3dUM7UUFDNUMsTUFBTTJsRCxNQUFNdDBGLEtBQUttRixHQUFHLENBQUM2TCxPQUFPKzZELFdBQVcsRUFBRWwvRCxJQUFJK2hDO1FBQzdDLE1BQU1ULFVBQVUsQ0FBQzZsRCxNQUFNSSxHQUFFLElBQUssSUFBSWowRjtRQUNsQyxNQUFNaXVDLFVBQVUsQ0FBQzhsRCxNQUFNSSxHQUFFLElBQUssSUFBSXpuRjtRQUNsQyxNQUFNLENBQUNtaEMsU0FBU0MsUUFBUSxHQUFHLElBQUksQ0FBQ3RDLFFBQVEsQ0FBQ29DLFFBQVEsR0FBRyxRQUFRLElBQUk7WUFBQ0k7WUFBU0M7U0FBUSxHQUFHO1lBQUNBO1lBQVNEO1NBQVE7UUFDdkcsT0FBTztZQUNMSDtZQUNBQztRQUNGO0lBQ0Y7SUFDQXVrQixhQUFhem9ELE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFDdEIsSUFBSSxDQUFDbWpELHFCQUFxQixDQUFDLElBQUksQ0FBQyxDQUFDeTJGLGNBQWMsSUFBSSxNQUFNNTVJO0lBQzNEO0lBQ0Fxb0QsWUFBWXZaLE1BQU0sRUFBRTtRQUNsQixJQUFJLENBQUMsQ0FBQzJELFNBQVMsQ0FBQzRWLFdBQVcsQ0FBQ3ZaO0lBQzlCO0lBQ0F1YixlQUFldmIsTUFBTSxFQUFFO1FBQ3JCLElBQUksQ0FBQyxDQUFDMkQsU0FBUyxDQUFDNFgsY0FBYyxDQUFDdmI7SUFDakM7SUFDQXlaLFNBQVN6WixNQUFNLEVBQUU7UUFDZixJQUFJLENBQUMsQ0FBQzJELFNBQVMsQ0FBQzhWLFFBQVEsQ0FBQ3paO0lBQzNCO0lBQ0FvVixVQUFVamtCLEtBQUssRUFBRTtRQUNmLE1BQU0sRUFDSjVLLEtBQUssRUFDTixHQUFHUixpQkFBaUJLLFFBQVE7UUFDN0IsSUFBSStLLE1BQU04USxNQUFNLEtBQUssS0FBSzlRLE1BQU15WCxPQUFPLElBQUlyaUIsT0FBTztZQUNoRDtRQUNGO1FBQ0EsSUFBSTRLLE1BQU1od0MsTUFBTSxLQUFLLElBQUksQ0FBQzB4QyxHQUFHLEVBQUU7WUFDN0I7UUFDRjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ3UyRyxjQUFjLEVBQUU7WUFDekI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDQSxjQUFjLEdBQUc7UUFDdkIsSUFBSSxJQUFJLENBQUMsQ0FBQ3dCLGlCQUFpQixFQUFFbmlGLFlBQVksSUFBSSxDQUFDLENBQUNtaUYsaUJBQWlCLENBQUNwVCx1QkFBdUIsRUFBRTtZQUN4RjtRQUNGO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDeVIsVUFBVSxFQUFFO1lBQ3JCLElBQUksQ0FBQyxDQUFDQSxVQUFVLEdBQUc7WUFDbkI7UUFDRjtRQUNBLE1BQU04QixjQUFjLElBQUksQ0FBQyxDQUFDcG5HLFNBQVMsQ0FBQzZaLE9BQU87UUFDM0MsSUFBSXV0RixnQkFBZ0JwMkgscUJBQXFCSSxLQUFLLElBQUlnMkgsZ0JBQWdCcDJILHFCQUFxQk8sU0FBUyxFQUFFO1lBQ2hHLElBQUksQ0FBQyxDQUFDeXVCLFNBQVMsQ0FBQzJKLFdBQVc7WUFDM0I7UUFDRjtRQUNBLElBQUksQ0FBQytHLHFCQUFxQixDQUFDbGpCLE9BQU87SUFDcEM7SUFDQXdnQyxZQUFZeGdDLEtBQUssRUFBRTtRQUNqQixJQUFJLElBQUksQ0FBQyxDQUFDd1MsU0FBUyxDQUFDNlosT0FBTyxPQUFPN29DLHFCQUFxQkcsU0FBUyxFQUFFO1lBQ2hFLElBQUksQ0FBQ2sxSCxtQkFBbUI7UUFDMUI7UUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDWixjQUFjLEVBQUU7WUFDeEIsSUFBSSxDQUFDLENBQUNBLGNBQWMsR0FBRztZQUN2QjtRQUNGO1FBQ0EsTUFBTSxFQUNKN2lILEtBQUssRUFDTixHQUFHUixpQkFBaUJLLFFBQVE7UUFDN0IsSUFBSStLLE1BQU04USxNQUFNLEtBQUssS0FBSzlRLE1BQU15WCxPQUFPLElBQUlyaUIsT0FBTztZQUNoRDtRQUNGO1FBQ0EsSUFBSTRLLE1BQU1od0MsTUFBTSxLQUFLLElBQUksQ0FBQzB4QyxHQUFHLEVBQUU7WUFDN0I7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDdTJHLGNBQWMsR0FBRztRQUN2QixJQUFJLElBQUksQ0FBQyxDQUFDd0IsaUJBQWlCLEVBQUVuaUYsVUFBVTtZQUNyQyxJQUFJLENBQUN1aUYsbUJBQW1CLENBQUM3NUc7WUFDekI7UUFDRjtRQUNBLE1BQU02TyxTQUFTLElBQUksQ0FBQyxDQUFDMkQsU0FBUyxDQUFDMFosU0FBUztRQUN4QyxJQUFJLENBQUMsQ0FBQzRyRixVQUFVLEdBQUcsQ0FBQ2pwRyxVQUFVQSxPQUFPNk4sT0FBTztJQUM5QztJQUNBbTlGLG9CQUFvQjc1RyxLQUFLLEVBQUU7UUFDekIsSUFBSSxDQUFDMEIsR0FBRyxDQUFDeWYsS0FBSyxDQUFDO1lBQ2JtaUIsZUFBZTtRQUNqQjtRQUNBLElBQUksSUFBSSxDQUFDLENBQUM4MEUsU0FBUyxFQUFFO1lBQ25CLElBQUksQ0FBQyxDQUFDcUIsaUJBQWlCLENBQUM1UixZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDcjFGLFNBQVMsRUFBRSxPQUFPeFM7WUFDbkU7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDd1MsU0FBUyxDQUFDeU0sd0JBQXdCLENBQUMsSUFBSTtRQUM3QyxJQUFJLENBQUMsQ0FBQ201RixTQUFTLEdBQUcsSUFBSTk1RztRQUN0QixNQUFNQyxTQUFTLElBQUksQ0FBQyxDQUFDaVUsU0FBUyxDQUFDd0wsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDbzZGLFNBQVM7UUFDN0QsSUFBSSxDQUFDMTJHLEdBQUcsQ0FBQy9DLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxFQUNqQ3M2QixhQUFhLEVBQ2Q7WUFDQyxJQUFJQSxpQkFBaUIsQ0FBQyxJQUFJLENBQUN2M0IsR0FBRyxDQUFDNFosUUFBUSxDQUFDMmQsZ0JBQWdCO2dCQUN0RCxJQUFJLENBQUMsQ0FBQ28vRSxjQUFjLEdBQUc7Z0JBQ3ZCLElBQUksQ0FBQzEyRixjQUFjO1lBQ3JCO1FBQ0YsR0FBRztZQUNEcGpCO1FBQ0Y7UUFDQSxJQUFJLENBQUMsQ0FBQ2s3RyxpQkFBaUIsQ0FBQzVSLFlBQVksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUNyMUYsU0FBUyxFQUFFLE9BQU94UztJQUNyRTtJQUNBODVHLE1BQU1sNUYsRUFBRSxFQUFFO1FBQ1IsSUFBSUEsSUFBSTtZQUNOLE1BQU0sRUFDSnJGLGFBQWEsRUFDZCxHQUFHaCtDO1lBQ0osSUFBSSxJQUFJLENBQUNta0MsR0FBRyxDQUFDNFosUUFBUSxDQUFDQyxnQkFBZ0I7Z0JBQ3BDLElBQUksQ0FBQyxDQUFDODhGLGNBQWMsR0FBRzk4RjtZQUN6QjtZQUNBO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDODhGLGNBQWMsRUFBRTtZQUN4Qjl1RixXQUFXO2dCQUNULElBQUksQ0FBQyxDQUFDOHVGLGNBQWMsRUFBRWwzRjtnQkFDdEIsSUFBSSxDQUFDLENBQUNrM0YsY0FBYyxHQUFHO1lBQ3pCLEdBQUc7UUFDTDtJQUNGO0lBQ0E1dEYsa0JBQWtCZytFLFlBQVksS0FBSyxFQUFFO1FBQ25DLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzJQLFNBQVMsRUFBRTtZQUNwQixPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUMsQ0FBQzVsRyxTQUFTLENBQUN5TSx3QkFBd0IsQ0FBQztRQUN6QyxJQUFJLENBQUMsQ0FBQ201RixTQUFTLENBQUMzNUcsS0FBSztRQUNyQixJQUFJLENBQUMsQ0FBQzI1RyxTQUFTLEdBQUc7UUFDbEIsSUFBSSxDQUFDLENBQUNDLGNBQWMsR0FBRztRQUN2QixPQUFPLElBQUksQ0FBQyxDQUFDb0IsaUJBQWlCLENBQUN6MEQsVUFBVSxDQUFDeWpEO0lBQzVDO0lBQ0E1dUUsY0FBY2hyQixNQUFNLEVBQUUxNEMsQ0FBQyxFQUFFME0sQ0FBQyxFQUFFO1FBQzFCLE1BQU1pN0MsUUFBUSxJQUFJLENBQUMsQ0FBQ3RMLFNBQVMsQ0FBQzRPLFVBQVUsQ0FBQ2pyRCxHQUFHME07UUFDNUMsSUFBSWk3QyxVQUFVLFFBQVFBLFVBQVUsSUFBSSxFQUFFO1lBQ3BDLE9BQU87UUFDVDtRQUNBQSxNQUFNbU8sWUFBWSxDQUFDcGQ7UUFDbkIsT0FBTztJQUNUO0lBQ0E4UyxpQkFBaUI7UUFDZixJQUFJLElBQUksQ0FBQyxDQUFDeTJGLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUMzdEYsaUJBQWlCO1lBQ3RCLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUNBeE4sa0JBQWtCO1FBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ203RixTQUFTLEVBQUU7WUFDcEI7UUFDRjtRQUNBLElBQUksQ0FBQyxDQUFDcUIsaUJBQWlCLENBQUNqUywwQkFBMEIsQ0FBQyxJQUFJO0lBQ3pEO0lBQ0FsMUYsVUFBVTtRQUNSLElBQUksQ0FBQ3FQLGNBQWM7UUFDbkIsSUFBSSxJQUFJLENBQUMsQ0FBQ25QLFNBQVMsQ0FBQzBaLFNBQVMsSUFBSXBxQixXQUFXLElBQUksRUFBRTtZQUNoRCxJQUFJLENBQUMsQ0FBQzBRLFNBQVMsQ0FBQ21QLGNBQWM7WUFDOUIsSUFBSSxDQUFDLENBQUNuUCxTQUFTLENBQUNzWCxlQUFlLENBQUM7UUFDbEM7UUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDa3VGLG9CQUFvQixFQUFFO1lBQzlCajZGLGFBQWEsSUFBSSxDQUFDLENBQUNpNkYsb0JBQW9CO1lBQ3ZDLElBQUksQ0FBQyxDQUFDQSxvQkFBb0IsR0FBRztRQUMvQjtRQUNBLEtBQUssTUFBTW5wRyxVQUFVLElBQUksQ0FBQyxDQUFDeVcsT0FBTyxDQUFDaHZDLE1BQU0sR0FBSTtZQUMzQyxJQUFJLENBQUMsQ0FBQ3VnSCxvQkFBb0IsRUFBRTJpQix5QkFBeUIzcUcsT0FBTyswQixVQUFVO1lBQ3RFLzBCLE9BQU9ncUIsU0FBUyxDQUFDO1lBQ2pCaHFCLE9BQU91b0IsZUFBZSxHQUFHO1lBQ3pCdm9CLE9BQU9uTixHQUFHLENBQUM5OEIsTUFBTTtRQUNuQjtRQUNBLElBQUksQ0FBQzg4QixHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUMsQ0FBQzRqQixPQUFPLENBQUN0dUMsS0FBSztRQUNuQixJQUFJLENBQUMsQ0FBQ3c3QixTQUFTLENBQUNvVSxXQUFXLENBQUMsSUFBSTtJQUNsQztJQUNBLENBQUN3b0QsT0FBTztRQUNOLEtBQUssTUFBTXZnRSxVQUFVLElBQUksQ0FBQyxDQUFDeVcsT0FBTyxDQUFDaHZDLE1BQU0sR0FBSTtZQUMzQyxJQUFJdTRCLE9BQU82TixPQUFPLElBQUk7Z0JBQ3BCN04sT0FBT2pxQyxNQUFNO1lBQ2Y7UUFDRjtJQUNGO0lBQ0F1OEIsT0FBTyxFQUNMUSxRQUFRLEVBQ1QsRUFBRTtRQUNELElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtRQUNoQjRILG1CQUFtQixJQUFJLENBQUM3SCxHQUFHLEVBQUVDO1FBQzdCLEtBQUssTUFBTWtOLFVBQVUsSUFBSSxDQUFDLENBQUMyRCxTQUFTLENBQUMyVyxVQUFVLENBQUMsSUFBSSxDQUFDeEosU0FBUyxFQUFHO1lBQy9ELElBQUksQ0FBQ3Q2QyxHQUFHLENBQUN3cEM7WUFDVEEsT0FBT21kLE9BQU87UUFDaEI7UUFDQSxJQUFJLENBQUNuRixVQUFVO0lBQ2pCO0lBQ0F6a0IsT0FBTyxFQUNMVCxRQUFRLEVBQ1QsRUFBRTtRQUNELElBQUksQ0FBQyxDQUFDNlEsU0FBUyxDQUFDbVAsY0FBYztRQUM5QixJQUFJLENBQUMsQ0FBQ3l0RCxPQUFPO1FBQ2IsTUFBTTJxQyxjQUFjLElBQUksQ0FBQ3A0RyxRQUFRLENBQUNvQyxRQUFRO1FBQzFDLE1BQU1BLFdBQVdwQyxTQUFTb0MsUUFBUTtRQUNsQyxJQUFJLENBQUNwQyxRQUFRLEdBQUdBO1FBQ2hCNEgsbUJBQW1CLElBQUksQ0FBQzdILEdBQUcsRUFBRTtZQUMzQnFDO1FBQ0Y7UUFDQSxJQUFJZzJHLGdCQUFnQmgyRyxVQUFVO1lBQzVCLEtBQUssTUFBTThLLFVBQVUsSUFBSSxDQUFDLENBQUN5VyxPQUFPLENBQUNodkMsTUFBTSxHQUFJO2dCQUMzQ3U0QixPQUFPb3pCLE1BQU0sQ0FBQ2wrQjtZQUNoQjtRQUNGO0lBQ0Y7SUFDQSxJQUFJbXpCLGlCQUFpQjtRQUNuQixNQUFNLEVBQ0pueUIsU0FBUyxFQUNUQyxVQUFVLEVBQ1gsR0FBRyxJQUFJLENBQUNyRCxRQUFRLENBQUNrRCxPQUFPO1FBQ3pCLE9BQU87WUFBQ0U7WUFBV0M7U0FBVztJQUNoQztJQUNBLElBQUlsQixRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsQ0FBQzBPLFNBQVMsQ0FBQ2lMLGNBQWMsQ0FBQ0MsU0FBUztJQUNqRDtBQUNGO0VBRUMsOEJBQThCO0FBRy9CLE1BQU1zOEY7SUFDSixDQUFDbDRHLE1BQU0sQ0FBUTtJQUNmLENBQUNtNEcsT0FBTyxDQUFhO0lBQ3JCLENBQUNDLFFBQVEsQ0FBYTtJQUN0QixPQUFPLENBQUMvMUksRUFBRSxHQUFHLEVBQUU7SUFDZnZSLFlBQVksRUFDVitzRCxTQUFTLEVBQ1YsQ0FBRTthQU5ILENBQUM3ZCxNQUFNLEdBQUc7YUFDVixDQUFDbTRHLE9BQU8sR0FBRyxJQUFJdjlHO2FBQ2YsQ0FBQ3c5RyxRQUFRLEdBQUcsSUFBSXg5RztRQUtkLElBQUksQ0FBQ2lqQixTQUFTLEdBQUdBO0lBQ25CO0lBQ0FrWixVQUFVLzJCLE1BQU0sRUFBRTtRQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNBLE1BQU0sRUFBRTtZQUNqQixJQUFJLENBQUMsQ0FBQ0EsTUFBTSxHQUFHQTtZQUNmO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDQSxNQUFNLEtBQUtBLFFBQVE7WUFDM0IsSUFBSSxJQUFJLENBQUMsQ0FBQ200RyxPQUFPLENBQUN6MUksSUFBSSxHQUFHLEdBQUc7Z0JBQzFCLEtBQUssTUFBTTZWLFFBQVEsSUFBSSxDQUFDLENBQUM0L0gsT0FBTyxDQUFDM2pJLE1BQU0sR0FBSTtvQkFDekMrRCxLQUFLelYsTUFBTTtvQkFDWGs5QixPQUFPeDRCLE1BQU0sQ0FBQytRO2dCQUNoQjtZQUNGO1lBQ0EsSUFBSSxDQUFDLENBQUN5bkIsTUFBTSxHQUFHQTtRQUNqQjtJQUNGO0lBQ0EsV0FBV3E0RyxjQUFjO1FBQ3ZCLE9BQU9ubkgsT0FBTyxJQUFJLEVBQUUsZUFBZSxJQUFJeXdGO0lBQ3pDO0lBQ0EsT0FBTyxDQUFDMjJCLE1BQU0sQ0FBQ3o2RyxPQUFPLEVBQUUsQ0FBQ3hwQyxHQUFHME0sR0FBRzhoQyxPQUFPQyxPQUFPO1FBQzNDLE1BQU0sRUFDSjFuQyxLQUFLLEVBQ04sR0FBR3lpQztRQUNKemlDLE1BQU1nekMsR0FBRyxHQUFHLENBQUMsRUFBRSxNQUFNcnRDLEVBQUUsQ0FBQyxDQUFDO1FBQ3pCM0YsTUFBTSs4RCxJQUFJLEdBQUcsQ0FBQyxFQUFFLE1BQU05akUsRUFBRSxDQUFDLENBQUM7UUFDMUIrRyxNQUFNeW5DLEtBQUssR0FBRyxDQUFDLEVBQUUsTUFBTUEsTUFBTSxDQUFDLENBQUM7UUFDL0J6bkMsTUFBTTBuQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLE1BQU1BLE9BQU8sQ0FBQyxDQUFDO0lBQ25DO0lBQ0EsQ0FBQ3kxRyxTQUFTO1FBQ1IsTUFBTXhtRyxNQUFNbW1HLFVBQVVHLFdBQVcsQ0FBQ3Y4SSxNQUFNLENBQUMsR0FBRyxHQUFHO1FBQy9DLElBQUksQ0FBQyxDQUFDa2tDLE1BQU0sQ0FBQ3g0QixNQUFNLENBQUN1cUM7UUFDcEJBLElBQUkxVCxZQUFZLENBQUMsZUFBZTtRQUNoQyxPQUFPMFQ7SUFDVDtJQUNBLENBQUN5bUcsY0FBYyxDQUFDeG1FLElBQUksRUFBRXltRSxNQUFNO1FBQzFCLE1BQU12d0IsV0FBV2d3QixVQUFVRyxXQUFXLENBQUNqMEksYUFBYSxDQUFDO1FBQ3JENHRFLEtBQUt4cUUsTUFBTSxDQUFDMGdIO1FBQ1osTUFBTWtYLGFBQWEsQ0FBQyxLQUFLLEVBQUVxWixPQUFPLENBQUM7UUFDbkN2d0IsU0FBUzdwRixZQUFZLENBQUMsTUFBTStnRztRQUM1QmxYLFNBQVM3cEYsWUFBWSxDQUFDLGlCQUFpQjtRQUN2QyxNQUFNcTZHLGNBQWNSLFVBQVVHLFdBQVcsQ0FBQ2owSSxhQUFhLENBQUM7UUFDeEQ4akgsU0FBUzFnSCxNQUFNLENBQUNreEk7UUFDaEJBLFlBQVlyNkcsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUVvNkcsT0FBTyxDQUFDO1FBQzdDQyxZQUFZL3VHLFNBQVMsQ0FBQ3BtQyxHQUFHLENBQUM7UUFDMUIsT0FBTzY3SDtJQUNUO0lBQ0EsQ0FBQ3lCLGdCQUFnQixDQUFDaGpHLE9BQU8sRUFBRTR0RCxVQUFVO1FBQ25DLEtBQUssTUFBTSxDQUFDM3lGLEtBQUtuSyxNQUFNLElBQUlvQixPQUFPOFgsT0FBTyxDQUFDNGpGLFlBQWE7WUFDckQsSUFBSTk4RixVQUFVLE1BQU07Z0JBQ2xCa3ZDLFFBQVFVLGVBQWUsQ0FBQ3psQztZQUMxQixPQUFPO2dCQUNMK2tDLFFBQVFRLFlBQVksQ0FBQ3ZsQyxLQUFLbks7WUFDNUI7UUFDRjtJQUNGO0lBQ0FnekksS0FBS2wyQyxVQUFVLEVBQUVrdEQsa0JBQWtCLEtBQUssRUFBRUMsVUFBVSxLQUFLLEVBQUU7UUFDekQsTUFBTXYySSxLQUFLNjFJLFVBQVUsQ0FBQzcxSSxFQUFFO1FBQ3hCLE1BQU1rVyxPQUFPLElBQUksQ0FBQyxDQUFDZ2dJLFNBQVM7UUFDNUIsTUFBTXZtRSxPQUFPa21FLFVBQVVHLFdBQVcsQ0FBQ2owSSxhQUFhLENBQUM7UUFDakRtVSxLQUFLL1EsTUFBTSxDQUFDd3FFO1FBQ1osTUFBTWhJLE9BQU9rdUUsVUFBVUcsV0FBVyxDQUFDajBJLGFBQWEsQ0FBQztRQUNqRDR0RSxLQUFLeHFFLE1BQU0sQ0FBQ3dpRTtRQUNaLE1BQU15dUUsU0FBUyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUM1NkYsU0FBUyxDQUFDLENBQUMsRUFBRXg3QyxHQUFHLENBQUM7UUFDOUMybkUsS0FBSzNyQyxZQUFZLENBQUMsTUFBTW82RztRQUN4Qnp1RSxLQUFLM3JDLFlBQVksQ0FBQyxpQkFBaUI7UUFDbkMsSUFBSXM2RyxpQkFBaUI7WUFDbkIsSUFBSSxDQUFDLENBQUNQLFFBQVEsQ0FBQ25pSixHQUFHLENBQUNvTSxJQUFJMm5FO1FBQ3pCO1FBQ0EsTUFBTW8xRCxhQUFhd1osVUFBVSxJQUFJLENBQUMsQ0FBQ0osY0FBYyxDQUFDeG1FLE1BQU15bUUsVUFBVTtRQUNsRSxNQUFNSSxNQUFNWCxVQUFVRyxXQUFXLENBQUNqMEksYUFBYSxDQUFDO1FBQ2hEbVUsS0FBSy9RLE1BQU0sQ0FBQ3F4STtRQUNaQSxJQUFJeDZHLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFbzZHLE9BQU8sQ0FBQztRQUNyQyxJQUFJLENBQUM1WCxnQkFBZ0IsQ0FBQ3RvSCxNQUFNa3pFO1FBQzVCLElBQUksQ0FBQyxDQUFDMHNELE9BQU8sQ0FBQ2xpSixHQUFHLENBQUNvTSxJQUFJa1c7UUFDdEIsT0FBTztZQUNMbFc7WUFDQSs4SCxZQUFZLENBQUMsS0FBSyxFQUFFQSxXQUFXLENBQUMsQ0FBQztRQUNuQztJQUNGO0lBQ0FxQixZQUFZaDFDLFVBQVUsRUFBRXF0RCwyQkFBMkIsRUFBRTtRQUNuRCxNQUFNejJJLEtBQUs2MUksVUFBVSxDQUFDNzFJLEVBQUU7UUFDeEIsTUFBTWtXLE9BQU8sSUFBSSxDQUFDLENBQUNnZ0ksU0FBUztRQUM1QixNQUFNdm1FLE9BQU9rbUUsVUFBVUcsV0FBVyxDQUFDajBJLGFBQWEsQ0FBQztRQUNqRG1VLEtBQUsvUSxNQUFNLENBQUN3cUU7UUFDWixNQUFNaEksT0FBT2t1RSxVQUFVRyxXQUFXLENBQUNqMEksYUFBYSxDQUFDO1FBQ2pENHRFLEtBQUt4cUUsTUFBTSxDQUFDd2lFO1FBQ1osTUFBTXl1RSxTQUFTLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQzU2RixTQUFTLENBQUMsQ0FBQyxFQUFFeDdDLEdBQUcsQ0FBQztRQUM5QzJuRSxLQUFLM3JDLFlBQVksQ0FBQyxNQUFNbzZHO1FBQ3hCenVFLEtBQUszckMsWUFBWSxDQUFDLGlCQUFpQjtRQUNuQyxJQUFJMDZHO1FBQ0osSUFBSUQsNkJBQTZCO1lBQy9CLE1BQU0xdEQsT0FBTzhzRCxVQUFVRyxXQUFXLENBQUNqMEksYUFBYSxDQUFDO1lBQ2pENHRFLEtBQUt4cUUsTUFBTSxDQUFDNGpGO1lBQ1oydEQsU0FBUyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUNsN0YsU0FBUyxDQUFDLENBQUMsRUFBRXg3QyxHQUFHLENBQUM7WUFDeEMrb0YsS0FBSy9zRCxZQUFZLENBQUMsTUFBTTA2RztZQUN4QjN0RCxLQUFLL3NELFlBQVksQ0FBQyxhQUFhO1lBQy9CLE1BQU03SSxPQUFPMGlILFVBQVVHLFdBQVcsQ0FBQ2owSSxhQUFhLENBQUM7WUFDakRnbkYsS0FBSzVqRixNQUFNLENBQUNndUI7WUFDWkEsS0FBSzZJLFlBQVksQ0FBQyxTQUFTO1lBQzNCN0ksS0FBSzZJLFlBQVksQ0FBQyxVQUFVO1lBQzVCN0ksS0FBSzZJLFlBQVksQ0FBQyxRQUFRO1lBQzFCLE1BQU13NkcsTUFBTVgsVUFBVUcsV0FBVyxDQUFDajBJLGFBQWEsQ0FBQztZQUNoRGduRixLQUFLNWpGLE1BQU0sQ0FBQ3F4STtZQUNaQSxJQUFJeDZHLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFbzZHLE9BQU8sQ0FBQztZQUNyQ0ksSUFBSXg2RyxZQUFZLENBQUMsVUFBVTtZQUMzQnc2RyxJQUFJeDZHLFlBQVksQ0FBQyxRQUFRO1lBQ3pCdzZHLElBQUl4NkcsWUFBWSxDQUFDLGFBQWE7WUFDOUJ3NkcsSUFBSWx2RyxTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1FBQ3BCO1FBQ0EsTUFBTXkxSSxPQUFPZCxVQUFVRyxXQUFXLENBQUNqMEksYUFBYSxDQUFDO1FBQ2pEbVUsS0FBSy9RLE1BQU0sQ0FBQ3d4STtRQUNaQSxLQUFLMzZHLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFbzZHLE9BQU8sQ0FBQztRQUN0QyxJQUFJTSxRQUFRO1lBQ1ZDLEtBQUszNkcsWUFBWSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUwNkcsT0FBTyxDQUFDLENBQUM7UUFDN0M7UUFDQSxNQUFNRSxPQUFPRCxLQUFLRSxTQUFTO1FBQzNCM2dJLEtBQUsvUSxNQUFNLENBQUN5eEk7UUFDWkQsS0FBS3J2RyxTQUFTLENBQUNwbUMsR0FBRyxDQUFDO1FBQ25CMDFJLEtBQUt0dkcsU0FBUyxDQUFDcG1DLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUNzOUgsZ0JBQWdCLENBQUN0b0gsTUFBTWt6RTtRQUM1QixJQUFJLENBQUMsQ0FBQzBzRCxPQUFPLENBQUNsaUosR0FBRyxDQUFDb00sSUFBSWtXO1FBQ3RCLE9BQU9sVztJQUNUO0lBQ0FtK0gsYUFBYW4rSCxFQUFFLEVBQUVvcEYsVUFBVSxFQUFFO1FBQzNCLElBQUksQ0FBQyxDQUFDMnNELFFBQVEsQ0FBQ2xwRyxNQUFNLENBQUM3c0M7UUFDdEIsSUFBSSxDQUFDdytILGdCQUFnQixDQUFDeCtILElBQUlvcEY7SUFDNUI7SUFDQW8xQyxpQkFBaUJzWSxXQUFXLEVBQUUxdEQsVUFBVSxFQUFFO1FBQ3hDLElBQUksQ0FBQ0EsWUFBWTtZQUNmO1FBQ0Y7UUFDQSxNQUFNLEVBQ0psekUsSUFBSSxFQUNKc3lELElBQUksRUFDSjYxRCxTQUFTLEVBQ1QxMkQsSUFBSSxFQUNMLEdBQUd5aEI7UUFDSixNQUFNNXRELFVBQVUsT0FBT3M3RyxnQkFBZ0IsV0FBVyxJQUFJLENBQUMsQ0FBQ2hCLE9BQU8sQ0FBQ3hvSixHQUFHLENBQUN3cEosZUFBZUE7UUFDbkYsSUFBSSxDQUFDdDdHLFNBQVM7WUFDWjtRQUNGO1FBQ0EsSUFBSXRsQixNQUFNO1lBQ1IsSUFBSSxDQUFDLENBQUNzb0gsZ0JBQWdCLENBQUNoakcsU0FBU3RsQjtRQUNsQztRQUNBLElBQUlzeUQsTUFBTTtZQUNScXRFLFVBQVUsQ0FBQ0ksTUFBTSxDQUFDejZHLFNBQVNndEM7UUFDN0I7UUFDQSxJQUFJNjFELFdBQVc7WUFDYixNQUFNLEVBQ0ovMkYsU0FBUyxFQUNWLEdBQUc5TDtZQUNKLEtBQUssTUFBTSxDQUFDMk4sV0FBVzc4QyxNQUFNLElBQUlvQixPQUFPOFgsT0FBTyxDQUFDNjRILFdBQVk7Z0JBQzFELzJGLFVBQVUrVixNQUFNLENBQUNsVSxXQUFXNzhDO1lBQzlCO1FBQ0Y7UUFDQSxJQUFJcTdFLE1BQU07WUFDUixNQUFNZ0ksT0FBT24wQyxRQUFRaU8sVUFBVTtZQUMvQixNQUFNc3RHLGNBQWNwbkUsS0FBS2xtQyxVQUFVO1lBQ25DLElBQUksQ0FBQyxDQUFDKzBGLGdCQUFnQixDQUFDdVksYUFBYXB2RTtRQUN0QztJQUNGO0lBQ0FvN0QsYUFBYS9pSSxFQUFFLEVBQUUyNUMsS0FBSyxFQUFFO1FBQ3RCLElBQUlBLFVBQVUsSUFBSSxFQUFFO1lBQ2xCO1FBQ0Y7UUFDQSxNQUFNempDLE9BQU8sSUFBSSxDQUFDLENBQUM0L0gsT0FBTyxDQUFDeG9KLEdBQUcsQ0FBQzBTO1FBQy9CLElBQUksQ0FBQ2tXLE1BQU07WUFDVDtRQUNGO1FBQ0F5akMsTUFBTSxDQUFDaGMsTUFBTSxDQUFDeDRCLE1BQU0sQ0FBQytRO1FBQ3JCLElBQUksQ0FBQyxDQUFDNC9ILE9BQU8sQ0FBQ2pwRyxNQUFNLENBQUM3c0M7UUFDckIyNUMsTUFBTSxDQUFDbThGLE9BQU8sQ0FBQ2xpSixHQUFHLENBQUNvTSxJQUFJa1c7SUFDekI7SUFDQXpWLE9BQU9ULEVBQUUsRUFBRTtRQUNULElBQUksQ0FBQyxDQUFDKzFJLFFBQVEsQ0FBQ2xwRyxNQUFNLENBQUM3c0M7UUFDdEIsSUFBSSxJQUFJLENBQUMsQ0FBQzI5QixNQUFNLEtBQUssTUFBTTtZQUN6QjtRQUNGO1FBQ0EsSUFBSSxDQUFDLENBQUNtNEcsT0FBTyxDQUFDeG9KLEdBQUcsQ0FBQzBTLElBQUlTLE1BQU07UUFDNUIsSUFBSSxDQUFDLENBQUNxMUksT0FBTyxDQUFDanBHLE1BQU0sQ0FBQzdzQztJQUN2QjtJQUNBbXVDLFVBQVU7UUFDUixJQUFJLENBQUMsQ0FBQ3hRLE1BQU0sR0FBRztRQUNmLEtBQUssTUFBTXpuQixRQUFRLElBQUksQ0FBQyxDQUFDNC9ILE9BQU8sQ0FBQzNqSSxNQUFNLEdBQUk7WUFDekMrRCxLQUFLelYsTUFBTTtRQUNiO1FBQ0EsSUFBSSxDQUFDLENBQUNxMUksT0FBTyxDQUFDampJLEtBQUs7UUFDbkIsSUFBSSxDQUFDLENBQUNrakksUUFBUSxDQUFDbGpJLEtBQUs7SUFDdEI7QUFDRjtFQUVDLGVBQWU7QUFpQmhCO0lBQ0VyakIsV0FBV3duSixrQkFBa0IsR0FBRztRQUM5QjViLG1CQUFtQkE7SUFDckI7QUFDRixDQUNBNXJJLFdBQVd5bkosUUFBUSxHQUFHO0lBQ3BCdm5ILGdCQUFnQkE7SUFDaEJna0gsdUJBQXVCQTtJQUN2QjV6SCw0QkFBNEJBO0lBQzVCVCxzQkFBc0JBO0lBQ3RCNDBCLDJCQUEyQkE7SUFDM0J3K0UsaUJBQWlCQTtJQUNqQjF6RyxnQkFBZ0JBO0lBQ2hCb0QsZ0JBQWdCQTtJQUNoQm9sQixjQUFjQTtJQUNkNnpFLE9BQU9BO0lBQ1BDLGFBQWFBO0lBQ2JudEYsd0JBQXdCQTtJQUN4QmtaLGNBQWNBO0lBQ2RrNEUsZUFBZUE7SUFDZnUyQixXQUFXQTtJQUNYbHpELGFBQWFseUQ7SUFDYjhOLFdBQVdBO0lBQ1hnSyxtQkFBbUJBO0lBQ25Cb2pFLGFBQWFBO0lBQ2IvcEUsb0JBQW9CQTtJQUNwQkUsdUJBQXVCQTtJQUN2QnNDLFFBQVFBO0lBQ1IxTCxTQUFTQTtJQUNUd0wsb0JBQW9CQTtJQUNwQnUyRCxxQkFBcUJBO0lBQ3JCN1ksV0FBVzcvRDtJQUNYc04scUJBQXFCQTtJQUNyQmtTLGNBQWNBO0lBQ2RHLFdBQVdBO0lBQ1g0bkMscUJBQXFCQTtJQUNyQjl2QyxXQUFXQTtJQUNYdUosZUFBZUE7SUFDZnpLLGtCQUFrQkE7SUFDbEJsUixLQUFLQTtJQUNMd2UsYUFBYUE7SUFDYjNZLG1CQUFtQkE7SUFDbkIrK0UsdUJBQXVCQTtJQUN2QjNvRSxlQUFlQTtJQUNmNm9FLFdBQVdBO0lBQ1h0ckYsZ0JBQWdCQTtJQUNoQndkLGVBQWVBO0lBQ2ZpRCw2QkFBNkJBO0lBQzdCNEgsZ0JBQWdCQTtJQUNoQjNaLG1CQUFtQkE7SUFDbkI4VixvQkFBb0JBO0lBQ3BCdlcsUUFBUUE7SUFDUis0RyxvQkFBb0JBO0lBQ3BCM2tHLFdBQVdBO0lBQ1grRCx5QkFBeUJBO0lBQ3pCa2hFLFdBQVdBO0lBQ1gzNkMsY0FBY0E7SUFDZDcrQixlQUFlQTtJQUNmK0MsTUFBTUE7SUFDTnpLLGdCQUFnQkE7SUFDaEJ0a0IsU0FBU0E7SUFDVDQ0QixVQUFVQTtBQUNaO0FBRXc2QixDQUV4NkIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktY2FyZWVyLWFzc2lzdGFudC8uL25vZGVfbW9kdWxlcy9wZGYtcGFyc2Uvbm9kZV9tb2R1bGVzL3BkZmpzLWRpc3QvbGVnYWN5L2J1aWxkL3BkZi5tanM/YWQ0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNzdGFydCBUaGUgZm9sbG93aW5nIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZVxuICogSmF2YVNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZVxuICpcbiAqIENvcHlyaWdodCAyMDI0IE1vemlsbGEgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAbGljZW5kIFRoZSBhYm92ZSBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFTY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqL1xuXG4vKipcbiAqIHBkZmpzVmVyc2lvbiA9IDUuNC4yOTZcbiAqIHBkZmpzQnVpbGQgPSBmNTZkYzg2MDFcbiAqL1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyAzNDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkwMSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUoaXQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMwNik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIHRyeVRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODIzKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oODUxKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50LCB1c2luZ0l0ZXJhdG9yKSB7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZ2V0SXRlcmF0b3JNZXRob2QoYXJndW1lbnQpIDogdXNpbmdJdGVyYXRvcjtcbiAgaWYgKGFDYWxsYWJsZShpdGVyYXRvck1ldGhvZCkpIHJldHVybiBhbk9iamVjdChjYWxsKGl0ZXJhdG9yTWV0aG9kLCBhcmd1bWVudCkpO1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTE2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2NTIpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMwNik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzY3KTtcbnZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTM5KTtcbnZhciBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTQ5KTtcblxudmFyIGZpbmRXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IoJ2ZpbmQnLCBUeXBlRXJyb3IpO1xuXG4vLyBgSXRlcmF0b3IucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pdGVyYXRvci5wcm90b3R5cGUuZmluZFxuJCh7IHRhcmdldDogJ0l0ZXJhdG9yJywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogZmluZFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIH0sIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUpIHtcbiAgICBhbk9iamVjdCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgYUNhbGxhYmxlKHByZWRpY2F0ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UodGhpcywgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChmaW5kV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IpIHJldHVybiBjYWxsKGZpbmRXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciwgdGhpcywgcHJlZGljYXRlKTtcblxuICAgIHZhciByZWNvcmQgPSBnZXRJdGVyYXRvckRpcmVjdCh0aGlzKTtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgcmV0dXJuIGl0ZXJhdGUocmVjb3JkLCBmdW5jdGlvbiAodmFsdWUsIHN0b3ApIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGNvdW50ZXIrKykpIHJldHVybiBzdG9wKHZhbHVlKTtcbiAgICB9LCB7IElTX1JFQ09SRDogdHJ1ZSwgSU5URVJSVVBURUQ6IHRydWUgfSkucmVzdWx0O1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjgzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzkpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MDEpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5Nyk7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MjQpO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gKF9fd2VicGFja19yZXF1aXJlX18oMzUwKS5DT05GSUdVUkFCTEUpO1xudmFyIGluc3BlY3RTb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MDYpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExODEpO1xuXG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyICRTdHJpbmcgPSBTdHJpbmc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG52YXIgam9pbiA9IHVuY3VycnlUaGlzKFtdLmpvaW4pO1xuXG52YXIgQ09ORklHVVJBQkxFX0xFTkdUSCA9IERFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdsZW5ndGgnLCB7IHZhbHVlOiA4IH0pLmxlbmd0aCAhPT0gODtcbn0pO1xuXG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbnZhciBtYWtlQnVpbHRJbiA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChzdHJpbmdTbGljZSgkU3RyaW5nKG5hbWUpLCAwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIHJlcGxhY2UoJFN0cmluZyhuYW1lKSwgL15TeW1ib2xcXCgoW14pXSopXFwpLiokLywgJyQxJykgKyAnXSc7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nZXR0ZXIpIG5hbWUgPSAnZ2V0ICcgKyBuYW1lO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9ICdzZXQgJyArIG5hbWU7XG4gIGlmICghaGFzT3duKHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSkge1xuICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkodmFsdWUsICduYW1lJywgeyB2YWx1ZTogbmFtZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIGVsc2UgdmFsdWUubmFtZSA9IG5hbWU7XG4gIH1cbiAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgJ2FyaXR5JykgJiYgdmFsdWUubGVuZ3RoICE9PSBvcHRpb25zLmFyaXR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkodmFsdWUsICdwcm90b3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAvLyBpbiBWOCB+IENocm9tZSA1MywgcHJvdG90eXBlcyBvZiBzb21lIG1ldGhvZHMsIGxpa2UgYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgLCBhcmUgbm9uLXdyaXRhYmxlXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gIGlmICghaGFzT3duKHN0YXRlLCAnc291cmNlJykpIHtcbiAgICBzdGF0ZS5zb3VyY2UgPSBqb2luKFRFTVBMQVRFLCB0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0ZW5kLW5hdGl2ZSAtLSByZXF1aXJlZFxuRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gbWFrZUJ1aWx0SW4oZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IGluc3BlY3RTb3VyY2UodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzUwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mjk3KTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyB8fCAoREVTQ1JJUFRPUlMgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM5Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzc1MSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQyMTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDU2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcbnZhciBhblVpbnQ4QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNTQpO1xudmFyIG5vdERldGFjaGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTY5KTtcblxudmFyIG51bWJlclRvU3RyaW5nID0gdW5jdXJyeVRoaXMoMS4xLnRvU3RyaW5nKTtcblxudmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWxUaGlzLlVpbnQ4QXJyYXk7XG5cbnZhciBJTkNPUlJFQ1RfQkVIQVZJT1JfT1JfRE9FU05UX0VYSVNUUyA9ICFVaW50OEFycmF5IHx8ICFVaW50OEFycmF5LnByb3RvdHlwZS50b0hleCB8fCAhKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdGFyZ2V0ID0gbmV3IFVpbnQ4QXJyYXkoWzI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1XSk7XG4gICAgcmV0dXJuIHRhcmdldC50b0hleCgpID09PSAnZmZmZmZmZmZmZmZmZmZmZic7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vLyBgVWludDhBcnJheS5wcm90b3R5cGUudG9IZXhgIG1ldGhvZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXlidWZmZXItYmFzZTY0XG5pZiAoVWludDhBcnJheSkgJCh7IHRhcmdldDogJ1VpbnQ4QXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfQkVIQVZJT1JfT1JfRE9FU05UX0VYSVNUUyB9LCB7XG4gIHRvSGV4OiBmdW5jdGlvbiB0b0hleCgpIHtcbiAgICBhblVpbnQ4QXJyYXkodGhpcyk7XG4gICAgbm90RGV0YWNoZWQodGhpcy5idWZmZXIpO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhleCA9IG51bWJlclRvU3RyaW5nKHRoaXNbaV0sIDE2KTtcbiAgICAgIHJlc3VsdCArPSBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTA3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTY1KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVjb3JkLCBmbiwgSVRFUkFUT1JfSU5TVEVBRF9PRl9SRUNPUkQpIHtcbiAgdmFyIGl0ZXJhdG9yID0gSVRFUkFUT1JfSU5TVEVBRF9PRl9SRUNPUkQgPyByZWNvcmQgOiByZWNvcmQuaXRlcmF0b3I7XG4gIHZhciBuZXh0ID0gcmVjb3JkLm5leHQ7XG4gIHZhciBzdGVwLCByZXN1bHQ7XG4gIHdoaWxlICghKHN0ZXAgPSBjYWxsKG5leHQsIGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgIHJlc3VsdCA9IGZuKHN0ZXAudmFsdWUpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTMxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMwNik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzY3KTtcbnZhciBnZXRJdGVyYXRvckZsYXR0ZW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NjQ2KTtcbnZhciBjcmVhdGVJdGVyYXRvclByb3h5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NDYyKTtcbnZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTM5KTtcbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mzk1KTtcbnZhciBpdGVyYXRvckhlbHBlclRocm93c09uSW52YWxpZEl0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODQpO1xudmFyIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NDkpO1xuXG52YXIgRkxBVF9NQVBfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SID0gIUlTX1BVUkVcbiAgJiYgIWl0ZXJhdG9ySGVscGVyVGhyb3dzT25JbnZhbGlkSXRlcmF0b3IoJ2ZsYXRNYXAnLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xudmFyIGZsYXRNYXBXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9ICFJU19QVVJFICYmICFGTEFUX01BUF9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1JcbiAgJiYgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcignZmxhdE1hcCcsIFR5cGVFcnJvcik7XG5cbnZhciBGT1JDRUQgPSBJU19QVVJFIHx8IEZMQVRfTUFQX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiB8fCBmbGF0TWFwV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3I7XG5cbnZhciBJdGVyYXRvclByb3h5ID0gY3JlYXRlSXRlcmF0b3JQcm94eShmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3I7XG4gIHZhciBtYXBwZXIgPSB0aGlzLm1hcHBlcjtcbiAgdmFyIHJlc3VsdCwgaW5uZXI7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoaW5uZXIgPSB0aGlzLmlubmVyKSB0cnkge1xuICAgICAgcmVzdWx0ID0gYW5PYmplY3QoY2FsbChpbm5lci5uZXh0LCBpbm5lci5pdGVyYXRvcikpO1xuICAgICAgaWYgKCFyZXN1bHQuZG9uZSkgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgIHRoaXMuaW5uZXIgPSBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTsgfVxuXG4gICAgcmVzdWx0ID0gYW5PYmplY3QoY2FsbCh0aGlzLm5leHQsIGl0ZXJhdG9yKSk7XG5cbiAgICBpZiAodGhpcy5kb25lID0gISFyZXN1bHQuZG9uZSkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaW5uZXIgPSBnZXRJdGVyYXRvckZsYXR0ZW5hYmxlKG1hcHBlcihyZXN1bHQudmFsdWUsIHRoaXMuY291bnRlcisrKSwgZmFsc2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTsgfVxuICB9XG59KTtcblxuLy8gYEl0ZXJhdG9yLnByb3RvdHlwZS5mbGF0TWFwYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXRlcmF0b3IucHJvdG90eXBlLmZsYXRtYXBcbiQoeyB0YXJnZXQ6ICdJdGVyYXRvcicsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIGZsYXRNYXA6IGZ1bmN0aW9uIGZsYXRNYXAobWFwcGVyKSB7XG4gICAgYW5PYmplY3QodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGFDYWxsYWJsZShtYXBwZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKHRoaXMsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoZmxhdE1hcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKSByZXR1cm4gY2FsbChmbGF0TWFwV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IsIHRoaXMsIG1hcHBlcik7XG5cbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yUHJveHkoZ2V0SXRlcmF0b3JEaXJlY3QodGhpcyksIHtcbiAgICAgIG1hcHBlcjogbWFwcGVyLFxuICAgICAgaW5uZXI6IG51bGxcbiAgICB9KTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDYxNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjU1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTU1KTtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChjbGFzc29mKGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG4gIHJldHVybiAkU3RyaW5nKGFyZ3VtZW50KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY3OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaXNQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTYyNSk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUHJvdG90eXBlKSB7XG4gIGlmIChpc1Byb3RvdHlwZU9mKFByb3RvdHlwZSwgaXQpKSByZXR1cm4gaXQ7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjg0OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG4vLyBTaG91bGQgdGhyb3cgYW4gZXJyb3Igb24gaW52YWxpZCBpdGVyYXRvclxuLy8gaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy8zMzY4MzkxMTVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGFyZ3VtZW50KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1pdGVyYXRvciAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICB2YXIgbWV0aG9kID0gdHlwZW9mIEl0ZXJhdG9yID09ICdmdW5jdGlvbicgJiYgSXRlcmF0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdO1xuICBpZiAobWV0aG9kKSB0cnkge1xuICAgIG1ldGhvZC5jYWxsKHsgbmV4dDogbnVsbCB9LCBhcmd1bWVudCkubmV4dCgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NDE6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuLy8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tbWF0aC10cnVuYyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gdHJ1bmMoeCkge1xuICB2YXIgbiA9ICt4O1xuICByZXR1cm4gKG4gPiAwID8gZmxvb3IgOiBjZWlsKShuKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc1Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzc1MSk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkwMSk7XG52YXIgaXNQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTYyNSk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwNDApO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSgkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mKCRTeW1ib2wucHJvdG90eXBlLCAkT2JqZWN0KGl0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NTUpO1xudmFyIGdldE1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTk2Nik7XG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxMTcpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNjI2OSk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MjI3KTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGl0KSkgcmV0dXJuIGdldE1ldGhvZChpdCwgSVRFUkFUT1IpXG4gICAgfHwgZ2V0TWV0aG9kKGl0LCAnQEBpdGVyYXRvcicpXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk0NDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGFscGhhYmV0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmFscGhhYmV0O1xuICBpZiAoYWxwaGFiZXQgPT09IHVuZGVmaW5lZCB8fCBhbHBoYWJldCA9PT0gJ2Jhc2U2NCcgfHwgYWxwaGFiZXQgPT09ICdiYXNlNjR1cmwnKSByZXR1cm4gYWxwaGFiZXQgfHwgJ2Jhc2U2NCc7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yKCdJbmNvcnJlY3QgYGFscGhhYmV0YCBvcHRpb24nKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDEwNzI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgyOCk7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3MjcpO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1rZXlzIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTEwMzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSwgdmFsdWU6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCB2YWx1ZTogZXJyb3IgfTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTEwODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oNjk1NSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBrbGFzcyA9IGNsYXNzb2YoaXQpO1xuICByZXR1cm4ga2xhc3MgPT09ICdCaWdJbnQ2NEFycmF5JyB8fCBrbGFzcyA9PT0gJ0JpZ1VpbnQ2NEFycmF5Jztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDExNDg6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG52YXIgaXRlcmF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjY1Mik7XG52YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzA2KTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODU1MSk7XG52YXIgZ2V0SXRlcmF0b3JEaXJlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NjcpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MzkpO1xudmFyIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NDkpO1xuXG52YXIgZXZlcnlXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IoJ2V2ZXJ5JywgVHlwZUVycm9yKTtcblxuLy8gYEl0ZXJhdG9yLnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yLnByb3RvdHlwZS5ldmVyeVxuJCh7IHRhcmdldDogJ0l0ZXJhdG9yJywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogZXZlcnlXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciB9LCB7XG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShwcmVkaWNhdGUpIHtcbiAgICBhbk9iamVjdCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgYUNhbGxhYmxlKHByZWRpY2F0ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UodGhpcywgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChldmVyeVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKSByZXR1cm4gY2FsbChldmVyeVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yLCB0aGlzLCBwcmVkaWNhdGUpO1xuXG4gICAgdmFyIHJlY29yZCA9IGdldEl0ZXJhdG9yRGlyZWN0KHRoaXMpO1xuICAgIHZhciBjb3VudGVyID0gMDtcbiAgICByZXR1cm4gIWl0ZXJhdGUocmVjb3JkLCBmdW5jdGlvbiAodmFsdWUsIHN0b3ApIHtcbiAgICAgIGlmICghcHJlZGljYXRlKHZhbHVlLCBjb3VudGVyKyspKSByZXR1cm4gc3RvcCgpO1xuICAgIH0sIHsgSVNfUkVDT1JEOiB0cnVlLCBJTlRFUlJVUFRFRDogdHJ1ZSB9KS5zdG9wcGVkO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTE4MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NjIyKTtcbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNjY5OSk7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mjk3KTtcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2MjkpO1xudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oNjExOSk7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDIxKTtcblxudmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWxUaGlzLlR5cGVFcnJvcjtcbnZhciBXZWFrTWFwID0gZ2xvYmFsVGhpcy5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtYXNzaWduIC0tIHByb3RvdHlwZSBtZXRob2RzIHByb3RlY3Rpb24gKi9cbiAgc3RvcmUuZ2V0ID0gc3RvcmUuZ2V0O1xuICBzdG9yZS5oYXMgPSBzdG9yZS5oYXM7XG4gIHN0b3JlLnNldCA9IHN0b3JlLnNldDtcbiAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWFzc2lnbiAtLSBwcm90b3R5cGUgbWV0aG9kcyBwcm90ZWN0aW9uICovXG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoc3RvcmUuaGFzKGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgc3RvcmUuc2V0KGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gc3RvcmUuZ2V0KGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHN0b3JlLmhhcyhpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24oaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24oaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMjkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB0cnVuYyA9IF9fd2VicGFja19yZXF1aXJlX18oNzQxKTtcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgbnVtYmVyID0gK2FyZ3VtZW50O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSAwID8gMCA6IHRydW5jKG51bWJlcik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMzg1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTM5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcnMsIGtpbmQsIHZhbHVlKSB7XG4gIGZvciAodmFyIGkgPSBpdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChpdGVyc1tpXSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBpdGVyYXRvckNsb3NlKGl0ZXJzW2ldLml0ZXJhdG9yLCBraW5kLCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGtpbmQgPSAndGhyb3cnO1xuICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICB9XG4gIH1cbiAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNTQ4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oOTAzOSk7XG52YXIgVjggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MTkpO1xudmFyIEVOVklST05NRU5UID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjE1KTtcblxudmFyIHN0cnVjdHVyZWRDbG9uZSA9IGdsb2JhbFRoaXMuc3RydWN0dXJlZENsb25lO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICEhc3RydWN0dXJlZENsb25lICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHByZXZlbnQgVjggQXJyYXlCdWZmZXJEZXRhY2hpbmcgcHJvdGVjdG9yIGNlbGwgaW52YWxpZGF0aW9uIGFuZCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG4gIGlmICgoRU5WSVJPTk1FTlQgPT09ICdERU5PJyAmJiBWOCA+IDkyKSB8fCAoRU5WSVJPTk1FTlQgPT09ICdOT0RFJyAmJiBWOCA+IDk0KSB8fCAoRU5WSVJPTk1FTlQgPT09ICdCUk9XU0VSJyAmJiBWOCA+IDk3KSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDgpO1xuICB2YXIgY2xvbmUgPSBzdHJ1Y3R1cmVkQ2xvbmUoYnVmZmVyLCB7IHRyYW5zZmVyOiBbYnVmZmVyXSB9KTtcbiAgcmV0dXJuIGJ1ZmZlci5ieXRlTGVuZ3RoICE9PSAwIHx8IGNsb25lLmJ5dGVMZW5ndGggIT09IDg7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTU0OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDY2MzIpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNjI1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5jdXJyeVRoaXMoe30uaXNQcm90b3R5cGVPZik7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE2ODk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgYXBwbHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3NDUpO1xudmFyIHNsaWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjgwKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjA0Myk7XG52YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzA2KTtcbnZhciBwZXJmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTAzKTtcblxudmFyIFByb21pc2UgPSBnbG9iYWxUaGlzLlByb21pc2U7XG5cbnZhciBBQ0NFUFRfQVJHVU1FTlRTID0gZmFsc2U7XG4vLyBBdm9pZGluZyB0aGUgdXNlIG9mIHBvbHlmaWxscyBvZiB0aGUgcHJldmlvdXMgaXRlcmF0aW9uIG9mIHRoaXMgcHJvcG9zYWxcbi8vIHRoYXQgZG9lcyBub3QgYWNjZXB0IGFyZ3VtZW50cyBvZiB0aGUgY2FsbGJhY2tcbnZhciBGT1JDRUQgPSAhUHJvbWlzZSB8fCAhUHJvbWlzZVsndHJ5J10gfHwgcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gIFByb21pc2VbJ3RyeSddKGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgIEFDQ0VQVF9BUkdVTUVOVFMgPSBhcmd1bWVudCA9PT0gODtcbiAgfSwgOCk7XG59KS5lcnJvciB8fCAhQUNDRVBUX0FSR1VNRU5UUztcblxuLy8gYFByb21pc2UudHJ5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS50cnlcbiQoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAndHJ5JzogZnVuY3Rpb24gKGNhbGxiYWNrZm4gLyogLCAuLi5hcmdzICovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKHRoaXMpO1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcHBseShhQ2FsbGFibGUoY2FsbGJhY2tmbiksIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gICAgKHJlc3VsdC5lcnJvciA/IHByb21pc2VDYXBhYmlsaXR5LnJlamVjdCA6IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmUpKHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNjk4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIHVuaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjA0KTtcbnZhciBzZXRNZXRob2RHZXRLZXlzQmVmb3JlQ2xvbmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oOTgzNSk7XG52YXIgc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkxNik7XG5cbnZhciBGT1JDRUQgPSAhc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSgndW5pb24nKSB8fCAhc2V0TWV0aG9kR2V0S2V5c0JlZm9yZUNsb25pbmcoJ3VuaW9uJyk7XG5cbi8vIGBTZXQucHJvdG90eXBlLnVuaW9uYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS51bmlvblxuJCh7IHRhcmdldDogJ1NldCcsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIHVuaW9uOiB1bmlvblxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE3MDE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG52YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzA2KTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODU1MSk7XG52YXIgZ2V0SXRlcmF0b3JEaXJlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NjcpO1xudmFyIGNyZWF0ZUl0ZXJhdG9yUHJveHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0NjIpO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzMTkpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MzkpO1xudmFyIGl0ZXJhdG9ySGVscGVyVGhyb3dzT25JbnZhbGlkSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NCk7XG52YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDU0OSk7XG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oNjM5NSk7XG5cbnZhciBNQVBfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SID0gIUlTX1BVUkUgJiYgIWl0ZXJhdG9ySGVscGVyVGhyb3dzT25JbnZhbGlkSXRlcmF0b3IoJ21hcCcsIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG52YXIgbWFwV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSAhSVNfUFVSRSAmJiAhTUFQX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUlxuICAmJiBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKCdtYXAnLCBUeXBlRXJyb3IpO1xuXG52YXIgRk9SQ0VEID0gSVNfUFVSRSB8fCBNQVBfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SIHx8IG1hcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yO1xuXG52YXIgSXRlcmF0b3JQcm94eSA9IGNyZWF0ZUl0ZXJhdG9yUHJveHkoZnVuY3Rpb24gKCkge1xuICB2YXIgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yO1xuICB2YXIgcmVzdWx0ID0gYW5PYmplY3QoY2FsbCh0aGlzLm5leHQsIGl0ZXJhdG9yKSk7XG4gIHZhciBkb25lID0gdGhpcy5kb25lID0gISFyZXN1bHQuZG9uZTtcbiAgaWYgKCFkb25lKSByZXR1cm4gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgdGhpcy5tYXBwZXIsIFtyZXN1bHQudmFsdWUsIHRoaXMuY291bnRlcisrXSwgdHJ1ZSk7XG59KTtcblxuLy8gYEl0ZXJhdG9yLnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pdGVyYXRvci5wcm90b3R5cGUubWFwXG4kKHsgdGFyZ2V0OiAnSXRlcmF0b3InLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBwZXIpIHtcbiAgICBhbk9iamVjdCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgYUNhbGxhYmxlKG1hcHBlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UodGhpcywgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChtYXBXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcikgcmV0dXJuIGNhbGwobWFwV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IsIHRoaXMsIG1hcHBlcik7XG5cbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yUHJveHkoZ2V0SXRlcmF0b3JEaXJlY3QodGhpcyksIHtcbiAgICAgIG1hcHBlcjogbWFwcGVyXG4gICAgfSk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNzY3OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG4vLyBgR2V0SXRlcmF0b3JEaXJlY3Qob2JqKWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldGl0ZXJhdG9yZGlyZWN0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICBpdGVyYXRvcjogb2JqLFxuICAgIG5leHQ6IG9iai5uZXh0LFxuICAgIGRvbmU6IGZhbHNlXG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxODI4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mjk3KTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzOTcpO1xudmFyIGluZGV4T2YgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg5NjE3KS5pbmRleE9mKTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjEpO1xuXG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duKGhpZGRlbktleXMsIGtleSkgJiYgaGFzT3duKE8sIGtleSkgJiYgcHVzaChyZXN1bHQsIGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXNPd24oTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcHVzaChyZXN1bHQsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIxMDY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIG1ha2VCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygyODMpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTEzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gIGlmIChkZXNjcmlwdG9yLmdldCkgbWFrZUJ1aWx0SW4oZGVzY3JpcHRvci5nZXQsIG5hbWUsIHsgZ2V0dGVyOiB0cnVlIH0pO1xuICBpZiAoZGVzY3JpcHRvci5zZXQpIG1ha2VCdWlsdEluKGRlc2NyaXB0b3Iuc2V0LCBuYW1lLCB7IHNldHRlcjogdHJ1ZSB9KTtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5LmYodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIxNDA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oODIyNyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjE5NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xuXG52YXIgdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdHJpbmdTbGljZSh0b1N0cmluZyhpdCksIDgsIC0xKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIyMTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMzAzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG5cbnZhciBVaW50OEFycmF5ID0gZ2xvYmFsVGhpcy5VaW50OEFycmF5O1xudmFyIFN5bnRheEVycm9yID0gZ2xvYmFsVGhpcy5TeW50YXhFcnJvcjtcbnZhciBwYXJzZUludCA9IGdsb2JhbFRoaXMucGFyc2VJbnQ7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgTk9UX0hFWCA9IC9bXlxcZGEtZl0vaTtcbnZhciBleGVjID0gdW5jdXJyeVRoaXMoTk9UX0hFWC5leGVjKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyaW5nLCBpbnRvKSB7XG4gIHZhciBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyaW5nTGVuZ3RoICUgMiAhPT0gMCkgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdTdHJpbmcgc2hvdWxkIGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGNoYXJhY3RlcnMnKTtcbiAgdmFyIG1heExlbmd0aCA9IGludG8gPyBtaW4oaW50by5sZW5ndGgsIHN0cmluZ0xlbmd0aCAvIDIpIDogc3RyaW5nTGVuZ3RoIC8gMjtcbiAgdmFyIGJ5dGVzID0gaW50byB8fCBuZXcgVWludDhBcnJheShtYXhMZW5ndGgpO1xuICB2YXIgcmVhZCA9IDA7XG4gIHZhciB3cml0dGVuID0gMDtcbiAgd2hpbGUgKHdyaXR0ZW4gPCBtYXhMZW5ndGgpIHtcbiAgICB2YXIgaGV4aXRzID0gc3RyaW5nU2xpY2Uoc3RyaW5nLCByZWFkLCByZWFkICs9IDIpO1xuICAgIGlmIChleGVjKE5PVF9IRVgsIGhleGl0cykpIHRocm93IG5ldyBTeW50YXhFcnJvcignU3RyaW5nIHNob3VsZCBvbmx5IGNvbnRhaW4gaGV4IGNoYXJhY3RlcnMnKTtcbiAgICBieXRlc1t3cml0dGVuKytdID0gcGFyc2VJbnQoaGV4aXRzLCAxNik7XG4gIH1cbiAgcmV0dXJuIHsgYnl0ZXM6IGJ5dGVzLCByZWFkOiByZWFkIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMzYwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MDEpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NzI3KTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjEpO1xudmFyIGh0bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5Nyk7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDU1KTtcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxMTkpO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtYXNzaWdubWVudCAtLSBhdm9pZCBtZW1vcnkgbGVha1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsO1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJ1xuICAgID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudFxuICAgICAgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgLy8gb2xkIElFXG4gICAgICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpXG4gICAgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtY3JlYXRlIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXNNb2R1bGUuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjQ3NTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBpc1N1cGVyc2V0T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1MjcpO1xudmFyIHNldE1ldGhvZEFjY2VwdFNldExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MTYpO1xuXG52YXIgSU5DT1JSRUNUID0gIXNldE1ldGhvZEFjY2VwdFNldExpa2UoJ2lzU3VwZXJzZXRPZicsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuICFyZXN1bHQ7XG59KTtcblxuLy8gYFNldC5wcm90b3R5cGUuaXNTdXBlcnNldE9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5pc3N1cGVyc2V0b2ZcbiQoeyB0YXJnZXQ6ICdTZXQnLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1QgfSwge1xuICBpc1N1cGVyc2V0T2Y6IGlzU3VwZXJzZXRPZlxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI0ODk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG52YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzA2KTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODU1MSk7XG52YXIgZ2V0SXRlcmF0b3JEaXJlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NjcpO1xudmFyIGNyZWF0ZUl0ZXJhdG9yUHJveHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0NjIpO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzMTkpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzOTUpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MzkpO1xudmFyIGl0ZXJhdG9ySGVscGVyVGhyb3dzT25JbnZhbGlkSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NCk7XG52YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDU0OSk7XG5cbnZhciBGSUxURVJfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SID0gIUlTX1BVUkUgJiYgIWl0ZXJhdG9ySGVscGVyVGhyb3dzT25JbnZhbGlkSXRlcmF0b3IoJ2ZpbHRlcicsIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG52YXIgZmlsdGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSAhSVNfUFVSRSAmJiAhRklMVEVSX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUlxuICAmJiBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKCdmaWx0ZXInLCBUeXBlRXJyb3IpO1xuXG52YXIgRk9SQ0VEID0gSVNfUFVSRSB8fCBGSUxURVJfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SIHx8IGZpbHRlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yO1xuXG52YXIgSXRlcmF0b3JQcm94eSA9IGNyZWF0ZUl0ZXJhdG9yUHJveHkoZnVuY3Rpb24gKCkge1xuICB2YXIgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yO1xuICB2YXIgcHJlZGljYXRlID0gdGhpcy5wcmVkaWNhdGU7XG4gIHZhciBuZXh0ID0gdGhpcy5uZXh0O1xuICB2YXIgcmVzdWx0LCBkb25lLCB2YWx1ZTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICByZXN1bHQgPSBhbk9iamVjdChjYWxsKG5leHQsIGl0ZXJhdG9yKSk7XG4gICAgZG9uZSA9IHRoaXMuZG9uZSA9ICEhcmVzdWx0LmRvbmU7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICBpZiAoY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgcHJlZGljYXRlLCBbdmFsdWUsIHRoaXMuY291bnRlcisrXSwgdHJ1ZSkpIHJldHVybiB2YWx1ZTtcbiAgfVxufSk7XG5cbi8vIGBJdGVyYXRvci5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXRlcmF0b3IucHJvdG90eXBlLmZpbHRlclxuJCh7IHRhcmdldDogJ0l0ZXJhdG9yJywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgYW5PYmplY3QodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGFDYWxsYWJsZShwcmVkaWNhdGUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKHRoaXMsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoZmlsdGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IpIHJldHVybiBjYWxsKGZpbHRlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yLCB0aGlzLCBwcmVkaWNhdGUpO1xuXG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvclByb3h5KGdldEl0ZXJhdG9yRGlyZWN0KHRoaXMpLCB7XG4gICAgICBwcmVkaWNhdGU6IHByZWRpY2F0ZVxuICAgIH0pO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjUyOTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuLy8gYENyZWF0ZUl0ZXJSZXN1bHRPYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVpdGVycmVzdWx0b2JqZWN0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IGRvbmUgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI2MDM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCwgJGRlZmF1bHQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID09PSB1bmRlZmluZWQgPyBhcmd1bWVudHMubGVuZ3RoIDwgMiA/ICcnIDogJGRlZmF1bHQgOiB0b1N0cmluZyhhcmd1bWVudCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNjUyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDgwKTtcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTY1KTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODU1MSk7XG52YXIgdHJ5VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MjMpO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIwOSk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxOTgpO1xudmFyIGlzUHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2MjUpO1xudmFyIGdldEl0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1MSk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTUzOSk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuICB0aGlzLnN0b3BwZWQgPSBzdG9wcGVkO1xuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG5cbnZhciBSZXN1bHRQcm90b3R5cGUgPSBSZXN1bHQucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XG4gIHZhciBBU19FTlRSSUVTID0gISEob3B0aW9ucyAmJiBvcHRpb25zLkFTX0VOVFJJRVMpO1xuICB2YXIgSVNfUkVDT1JEID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklTX1JFQ09SRCk7XG4gIHZhciBJU19JVEVSQVRPUiA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19JVEVSQVRPUik7XG4gIHZhciBJTlRFUlJVUFRFRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JTlRFUlJVUFRFRCk7XG4gIHZhciBmbiA9IGJpbmQodW5ib3VuZEZ1bmN0aW9uLCB0aGF0KTtcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcblxuICB2YXIgc3RvcCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICBpZiAoaXRlcmF0b3IpIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICdub3JtYWwnKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QodmFsdWUpO1xuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgfSByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZSwgc3RvcCkgOiBmbih2YWx1ZSk7XG4gIH07XG5cbiAgaWYgKElTX1JFQ09SRCkge1xuICAgIGl0ZXJhdG9yID0gaXRlcmFibGUuaXRlcmF0b3I7XG4gIH0gZWxzZSBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICBpZiAoIWl0ZXJGbikgdGhyb3cgbmV3ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKGl0ZXJhYmxlKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEZuKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgaXNQcm90b3R5cGVPZihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbiAgICB9XG4gICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihpdGVyYWJsZSwgaXRlckZuKTtcbiAgfVxuXG4gIG5leHQgPSBJU19SRUNPUkQgPyBpdGVyYWJsZS5uZXh0IDogaXRlcmF0b3IubmV4dDtcbiAgd2hpbGUgKCEoc3RlcCA9IGNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGNhbGxGbihzdGVwLnZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgaXNQcm90b3R5cGVPZihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjc3Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzU3KTtcbnZhciBnZXRNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NjYpO1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyNzApO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oODIyNyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIGlmICghaXNPYmplY3QoaW5wdXQpIHx8IGlzU3ltYm9sKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kKGlucHV0LCBUT19QUklNSVRJVkUpO1xuICB2YXIgcmVzdWx0O1xuICBpZiAoZXhvdGljVG9QcmltKSB7XG4gICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICByZXN1bHQgPSBjYWxsKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QocmVzdWx0KSB8fCBpc1N5bWJvbChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjc4Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mjk3KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODk4MSk7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTE5KTtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyMTEpO1xuXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUgPSAkT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/ICRPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXNPd24ob2JqZWN0LCBJRV9QUk9UTykpIHJldHVybiBvYmplY3RbSUVfUFJPVE9dO1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmIChpc0NhbGxhYmxlKGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjc5Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzkpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MDEpO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09PSBQT0xZRklMTCA/IHRydWVcbiAgICA6IHZhbHVlID09PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogaXNDYWxsYWJsZShkZXRlY3Rpb24pID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI4MDQ6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbnZhciBjb21tb25BbHBoYWJldCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSc7XG52YXIgYmFzZTY0QWxwaGFiZXQgPSBjb21tb25BbHBoYWJldCArICcrLyc7XG52YXIgYmFzZTY0VXJsQWxwaGFiZXQgPSBjb21tb25BbHBoYWJldCArICctXyc7XG5cbnZhciBpbnZlcnNlID0gZnVuY3Rpb24gKGNoYXJhY3RlcnMpIHtcbiAgLy8gVE9ETzogdXNlIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpbiBgY29yZS1qc0A0YFxuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBpbmRleCA9IDA7XG4gIGZvciAoOyBpbmRleCA8IDY0OyBpbmRleCsrKSByZXN1bHRbY2hhcmFjdGVycy5jaGFyQXQoaW5kZXgpXSA9IGluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGkyYzogYmFzZTY0QWxwaGFiZXQsXG4gIGMyaTogaW52ZXJzZShiYXNlNjRBbHBoYWJldCksXG4gIGkyY1VybDogYmFzZTY0VXJsQWxwaGFiZXQsXG4gIGMyaVVybDogaW52ZXJzZShiYXNlNjRVcmxBbHBoYWJldClcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI4MTI6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXNzZWQsIHJlcXVpcmVkKSB7XG4gIGlmIChwYXNzZWQgPCByZXF1aXJlZCkgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIHJldHVybiBwYXNzZWQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyODM5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcblxudmFyIG5hdmlnYXRvciA9IGdsb2JhbFRoaXMubmF2aWdhdG9yO1xudmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVzZXJBZ2VudCA/IFN0cmluZyh1c2VyQWdlbnQpIDogJyc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI5Njc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gLS0gc2FmZSAqL1xudmFyIHVuY3VycnlUaGlzQWNjZXNzb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3MDYpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzc1MCk7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNTA2KTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LXNldHByb3RvdHlwZW9mIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgc2V0dGVyID0gdW5jdXJyeVRoaXNBY2Nlc3NvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJywgJ3NldCcpO1xuICAgIHNldHRlcih0ZXN0LCBbXSk7XG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgcmVxdWlyZU9iamVjdENvZXJjaWJsZShPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmICghaXNPYmplY3QoTykpIHJldHVybiBPO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyKE8sIHByb3RvKTtcbiAgICBlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMDY4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuLy8gYmFzZWQgb24gU2hld2NodWsncyBhbGdvcml0aG0gZm9yIGV4YWN0bHkgZmxvYXRpbmcgcG9pbnQgYWRkaXRpb25cbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1tYXRoLXN1bS9ibG9iLzM1MTNkNTgzMjNhMWFlMjU1NjBlODcwMGFhNTI5NDUwMGM2YzkyODcvcG9seWZpbGwvcG9seWZpbGwubWpzXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xudmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2NTIpO1xuXG52YXIgJFJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG52YXIgJEluZmluaXR5ID0gSW5maW5pdHk7XG52YXIgJE5hTiA9IE5hTjtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG5cbnZhciBQT1dfMl8xMDIzID0gcG93KDIsIDEwMjMpO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBwb3coMiwgNTMpIC0gMTsgLy8gMiAqKiA1MyAtIDEgPT09IDkwMDcxOTkyNTQ3NDA5OTJcbnZhciBNQVhfRE9VQkxFID0gTnVtYmVyLk1BWF9WQUxVRTsgLy8gMiAqKiAxMDI0IC0gMiAqKiAoMTAyMyAtIDUyKSA9PT0gMS43OTc2OTMxMzQ4NjIzMTU3MDgxNWUrMzA4XG52YXIgTUFYX1VMUCA9IHBvdygyLCA5NzEpOyAvLyAyICoqICgxMDIzIC0gNTIpID09PSAxLjk5NTg0MDMwOTUzNDcxOTgxMTY2ZSsyOTJcblxudmFyIE5PVF9BX05VTUJFUiA9IHt9O1xudmFyIE1JTlVTX0lORklOSVRZID0ge307XG52YXIgUExVU19JTkZJTklUWSA9IHt9O1xudmFyIE1JTlVTX1pFUk8gPSB7fTtcbnZhciBGSU5JVEUgPSB7fTtcblxuLy8gcHJlcmVxdWlzaXRlOiBhYnMoeCkgPj0gYWJzKHkpXG52YXIgdHdvc3VtID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdmFyIGhpID0geCArIHk7XG4gIHZhciBsbyA9IHkgLSAoaGkgLSB4KTtcbiAgcmV0dXJuIHsgaGk6IGhpLCBsbzogbG8gfTtcbn07XG5cbi8vIGBNYXRoLnN1bVByZWNpc2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtbWF0aC1zdW1cbiQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSB9LCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50cyAtLSBva1xuICBzdW1QcmVjaXNlOiBmdW5jdGlvbiBzdW1QcmVjaXNlKGl0ZW1zKSB7XG4gICAgdmFyIG51bWJlcnMgPSBbXTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBzdGF0ZSA9IE1JTlVTX1pFUk87XG5cbiAgICBpdGVyYXRlKGl0ZW1zLCBmdW5jdGlvbiAobikge1xuICAgICAgaWYgKCsrY291bnQgPj0gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgbmV3ICRSYW5nZUVycm9yKCdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnKTtcbiAgICAgIGlmICh0eXBlb2YgbiAhPSAnbnVtYmVyJykgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1ZhbHVlIGlzIG5vdCBhIG51bWJlcicpO1xuICAgICAgaWYgKHN0YXRlICE9PSBOT1RfQV9OVU1CRVIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICAgICAgaWYgKG4gIT09IG4pIHN0YXRlID0gTk9UX0FfTlVNQkVSO1xuICAgICAgICBlbHNlIGlmIChuID09PSAkSW5maW5pdHkpIHN0YXRlID0gc3RhdGUgPT09IE1JTlVTX0lORklOSVRZID8gTk9UX0FfTlVNQkVSIDogUExVU19JTkZJTklUWTtcbiAgICAgICAgZWxzZSBpZiAobiA9PT0gLSRJbmZpbml0eSkgc3RhdGUgPSBzdGF0ZSA9PT0gUExVU19JTkZJTklUWSA/IE5PVF9BX05VTUJFUiA6IE1JTlVTX0lORklOSVRZO1xuICAgICAgICBlbHNlIGlmICgobiAhPT0gMCB8fCAoMSAvIG4pID09PSAkSW5maW5pdHkpICYmIChzdGF0ZSA9PT0gTUlOVVNfWkVSTyB8fCBzdGF0ZSA9PT0gRklOSVRFKSkge1xuICAgICAgICAgIHN0YXRlID0gRklOSVRFO1xuICAgICAgICAgIHB1c2gobnVtYmVycywgbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgTk9UX0FfTlVNQkVSOiByZXR1cm4gJE5hTjtcbiAgICAgIGNhc2UgTUlOVVNfSU5GSU5JVFk6IHJldHVybiAtJEluZmluaXR5O1xuICAgICAgY2FzZSBQTFVTX0lORklOSVRZOiByZXR1cm4gJEluZmluaXR5O1xuICAgICAgY2FzZSBNSU5VU19aRVJPOiByZXR1cm4gLTA7XG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWxzID0gW107XG4gICAgdmFyIG92ZXJmbG93ID0gMDsgLy8gY29uY2VwdHVhbGx5IDIgKiogMTAyNCB0aW1lcyB0aGlzIHZhbHVlOyB0aGUgZmluYWwgcGFydGlhbCBpcyBiaWFzZWQgYnkgdGhpcyBhbW91bnRcbiAgICB2YXIgeCwgeSwgc3VtLCBoaSwgbG8sIHRtcDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgeCA9IG51bWJlcnNbaV07XG4gICAgICB2YXIgYWN0dWFsbHlVc2VkUGFydGlhbHMgPSAwO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0aWFscy5sZW5ndGg7IGorKykge1xuICAgICAgICB5ID0gcGFydGlhbHNbal07XG4gICAgICAgIGlmIChhYnMoeCkgPCBhYnMoeSkpIHtcbiAgICAgICAgICB0bXAgPSB4O1xuICAgICAgICAgIHggPSB5O1xuICAgICAgICAgIHkgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgc3VtID0gdHdvc3VtKHgsIHkpO1xuICAgICAgICBoaSA9IHN1bS5oaTtcbiAgICAgICAgbG8gPSBzdW0ubG87XG4gICAgICAgIGlmIChhYnMoaGkpID09PSAkSW5maW5pdHkpIHtcbiAgICAgICAgICB2YXIgc2lnbiA9IGhpID09PSAkSW5maW5pdHkgPyAxIDogLTE7XG4gICAgICAgICAgb3ZlcmZsb3cgKz0gc2lnbjtcblxuICAgICAgICAgIHggPSAoeCAtIChzaWduICogUE9XXzJfMTAyMykpIC0gKHNpZ24gKiBQT1dfMl8xMDIzKTtcbiAgICAgICAgICBpZiAoYWJzKHgpIDwgYWJzKHkpKSB7XG4gICAgICAgICAgICB0bXAgPSB4O1xuICAgICAgICAgICAgeCA9IHk7XG4gICAgICAgICAgICB5ID0gdG1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdW0gPSB0d29zdW0oeCwgeSk7XG4gICAgICAgICAgaGkgPSBzdW0uaGk7XG4gICAgICAgICAgbG8gPSBzdW0ubG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvICE9PSAwKSBwYXJ0aWFsc1thY3R1YWxseVVzZWRQYXJ0aWFscysrXSA9IGxvO1xuICAgICAgICB4ID0gaGk7XG4gICAgICB9XG4gICAgICBwYXJ0aWFscy5sZW5ndGggPSBhY3R1YWxseVVzZWRQYXJ0aWFscztcbiAgICAgIGlmICh4ICE9PSAwKSBwdXNoKHBhcnRpYWxzLCB4KTtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHRoZSBleGFjdCBzdW0gb2YgcGFydGlhbHMsIHN0b3BwaW5nIG9uY2Ugd2UgbG9zZSBwcmVjaXNpb25cbiAgICB2YXIgbiA9IHBhcnRpYWxzLmxlbmd0aCAtIDE7XG4gICAgaGkgPSAwO1xuICAgIGxvID0gMDtcblxuICAgIGlmIChvdmVyZmxvdyAhPT0gMCkge1xuICAgICAgdmFyIG5leHQgPSBuID49IDAgPyBwYXJ0aWFsc1tuXSA6IDA7XG4gICAgICBuLS07XG4gICAgICBpZiAoYWJzKG92ZXJmbG93KSA+IDEgfHwgKG92ZXJmbG93ID4gMCAmJiBuZXh0ID4gMCkgfHwgKG92ZXJmbG93IDwgMCAmJiBuZXh0IDwgMCkpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJmbG93ID4gMCA/ICRJbmZpbml0eSA6IC0kSW5maW5pdHk7XG4gICAgICB9XG4gICAgICAvLyBoZXJlIHdlIGFjdHVhbGx5IGhhdmUgdG8gZG8gdGhlIGFyaXRobWV0aWNcbiAgICAgIC8vIGRyb3AgYSBmYWN0b3Igb2YgMiBzbyB3ZSBjYW4gZG8gaXQgd2l0aG91dCBvdmVyZmxvd1xuICAgICAgLy8gYXNzZXJ0KGFicyhvdmVyZmxvdykgPT09IDEpXG4gICAgICBzdW0gPSB0d29zdW0ob3ZlcmZsb3cgKiBQT1dfMl8xMDIzLCBuZXh0IC8gMik7XG4gICAgICBoaSA9IHN1bS5oaTtcbiAgICAgIGxvID0gc3VtLmxvO1xuICAgICAgbG8gKj0gMjtcbiAgICAgIGlmIChhYnMoMiAqIGhpKSA9PT0gJEluZmluaXR5KSB7XG4gICAgICAgIC8vIHJvdW5kaW5nIHRvIHRoZSBtYXhpbXVtIHZhbHVlXG4gICAgICAgIGlmIChoaSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gKGhpID09PSBQT1dfMl8xMDIzICYmIGxvID09PSAtKE1BWF9VTFAgLyAyKSAmJiBuID49IDAgJiYgcGFydGlhbHNbbl0gPCAwKSA/IE1BWF9ET1VCTEUgOiAkSW5maW5pdHk7XG4gICAgICAgIH0gcmV0dXJuIChoaSA9PT0gLVBPV18yXzEwMjMgJiYgbG8gPT09IChNQVhfVUxQIC8gMikgJiYgbiA+PSAwICYmIHBhcnRpYWxzW25dID4gMCkgPyAtTUFYX0RPVUJMRSA6IC0kSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsbyAhPT0gMCkge1xuICAgICAgICBwYXJ0aWFsc1srK25dID0gbG87XG4gICAgICAgIGxvID0gMDtcbiAgICAgIH1cblxuICAgICAgaGkgKj0gMjtcbiAgICB9XG5cbiAgICB3aGlsZSAobiA+PSAwKSB7XG4gICAgICBzdW0gPSB0d29zdW0oaGksIHBhcnRpYWxzW24tLV0pO1xuICAgICAgaGkgPSBzdW0uaGk7XG4gICAgICBsbyA9IHN1bS5sbztcbiAgICAgIGlmIChsbyAhPT0gMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKG4gPj0gMCAmJiAoKGxvIDwgMCAmJiBwYXJ0aWFsc1tuXSA8IDApIHx8IChsbyA+IDAgJiYgcGFydGlhbHNbbl0gPiAwKSkpIHtcbiAgICAgIHkgPSBsbyAqIDI7XG4gICAgICB4ID0gaGkgKyB5O1xuICAgICAgaWYgKHkgPT09IHggLSBoaSkgaGkgPSB4O1xuICAgIH1cblxuICAgIHJldHVybiBoaTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMxNjc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MDEpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5NjcpO1xuXG4vLyBtYWtlcyBzdWJjbGFzc2luZyB3b3JrIGNvcnJlY3QgZm9yIHdyYXBwZWQgYnVpbHQtaW5zXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkdGhpcywgZHVtbXksIFdyYXBwZXIpIHtcbiAgdmFyIE5ld1RhcmdldCwgTmV3VGFyZ2V0UHJvdG90eXBlO1xuICBpZiAoXG4gICAgLy8gaXQgY2FuIHdvcmsgb25seSB3aXRoIG5hdGl2ZSBgc2V0UHJvdG90eXBlT2ZgXG4gICAgc2V0UHJvdG90eXBlT2YgJiZcbiAgICAvLyB3ZSBoYXZlbid0IGNvbXBsZXRlbHkgY29ycmVjdCBwcmUtRVM2IHdheSBmb3IgZ2V0dGluZyBgbmV3LnRhcmdldGAsIHNvIHVzZSB0aGlzXG4gICAgaXNDYWxsYWJsZShOZXdUYXJnZXQgPSBkdW1teS5jb25zdHJ1Y3RvcikgJiZcbiAgICBOZXdUYXJnZXQgIT09IFdyYXBwZXIgJiZcbiAgICBpc09iamVjdChOZXdUYXJnZXRQcm90b3R5cGUgPSBOZXdUYXJnZXQucHJvdG90eXBlKSAmJlxuICAgIE5ld1RhcmdldFByb3RvdHlwZSAhPT0gV3JhcHBlci5wcm90b3R5cGVcbiAgKSBzZXRQcm90b3R5cGVPZigkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcbiAgcmV0dXJuICR0aGlzO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzIzODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUiA9IF9fd2VicGFja19yZXF1aXJlX18oNzgxMSk7XG52YXIgYXJyYXlCdWZmZXJCeXRlTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mzk0KTtcblxudmFyIERhdGFWaWV3ID0gZ2xvYmFsVGhpcy5EYXRhVmlldztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTykge1xuICBpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVIgfHwgYXJyYXlCdWZmZXJCeXRlTGVuZ3RoKE8pICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldyAtLSB0aHJvd2VyXG4gICAgbmV3IERhdGFWaWV3KE8pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzM5Mjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xuXG52YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xudmFyIHRvU3RyaW5nID0gdW5jdXJyeVRoaXMoMS4xLnRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyAoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgdG9TdHJpbmcoKytpZCArIHBvc3RmaXgsIDM2KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0NDA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwODApO1xudmFyIFNldEhlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDIpO1xudmFyIGNsb25lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mjg2KTtcbnZhciBzaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTcwKTtcbnZhciBnZXRTZXRSZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3ODkpO1xudmFyIGl0ZXJhdGVTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0NjkpO1xudmFyIGl0ZXJhdGVTaW1wbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwNyk7XG5cbnZhciBoYXMgPSBTZXRIZWxwZXJzLmhhcztcbnZhciByZW1vdmUgPSBTZXRIZWxwZXJzLnJlbW92ZTtcblxuLy8gYFNldC5wcm90b3R5cGUuZGlmZmVyZW5jZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZGlmZmVyZW5jZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaWZmZXJlbmNlKG90aGVyKSB7XG4gIHZhciBPID0gYVNldCh0aGlzKTtcbiAgdmFyIG90aGVyUmVjID0gZ2V0U2V0UmVjb3JkKG90aGVyKTtcbiAgdmFyIHJlc3VsdCA9IGNsb25lKE8pO1xuICBpZiAoc2l6ZShPKSA8PSBvdGhlclJlYy5zaXplKSBpdGVyYXRlU2V0KE8sIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKG90aGVyUmVjLmluY2x1ZGVzKGUpKSByZW1vdmUocmVzdWx0LCBlKTtcbiAgfSk7XG4gIGVsc2UgaXRlcmF0ZVNpbXBsZShvdGhlclJlYy5nZXRJdGVyYXRvcigpLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChoYXMocmVzdWx0LCBlKSkgcmVtb3ZlKHJlc3VsdCwgZSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzQ2Mzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnQgPT0gJ3N0cmluZycpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0FyZ3VtZW50IGlzIG5vdCBhIHN0cmluZycpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzUwNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaXNQb3NzaWJsZVByb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkyNSk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc1Bvc3NpYmxlUHJvdG90eXBlKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArICRTdHJpbmcoYXJndW1lbnQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzU3OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTY1KTtcbnZhciBpdGVyYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjUyKTtcbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMDYpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTc2Nyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTUzOSk7XG52YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDU0OSk7XG5cbnZhciBzb21lV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKCdzb21lJywgVHlwZUVycm9yKTtcblxuLy8gYEl0ZXJhdG9yLnByb3RvdHlwZS5zb21lYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXRlcmF0b3IucHJvdG90eXBlLnNvbWVcbiQoeyB0YXJnZXQ6ICdJdGVyYXRvcicsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IHNvbWVXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciB9LCB7XG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUocHJlZGljYXRlKSB7XG4gICAgYW5PYmplY3QodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGFDYWxsYWJsZShwcmVkaWNhdGUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKHRoaXMsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoc29tZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKSByZXR1cm4gY2FsbChzb21lV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IsIHRoaXMsIHByZWRpY2F0ZSk7XG5cbiAgICB2YXIgcmVjb3JkID0gZ2V0SXRlcmF0b3JEaXJlY3QodGhpcyk7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHJldHVybiBpdGVyYXRlKHJlY29yZCwgZnVuY3Rpb24gKHZhbHVlLCBzdG9wKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBjb3VudGVyKyspKSByZXR1cm4gc3RvcCgpO1xuICAgIH0sIHsgSVNfUkVDT1JEOiB0cnVlLCBJTlRFUlJVUFRFRDogdHJ1ZSB9KS5zdG9wcGVkO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzY1MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgYVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oNzA4MCk7XG52YXIgU2V0SGVscGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQwMik7XG52YXIgY2xvbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyODYpO1xudmFyIGdldFNldFJlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzc4OSk7XG52YXIgaXRlcmF0ZVNpbXBsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA3KTtcblxudmFyIGFkZCA9IFNldEhlbHBlcnMuYWRkO1xudmFyIGhhcyA9IFNldEhlbHBlcnMuaGFzO1xudmFyIHJlbW92ZSA9IFNldEhlbHBlcnMucmVtb3ZlO1xuXG4vLyBgU2V0LnByb3RvdHlwZS5zeW1tZXRyaWNEaWZmZXJlbmNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5zeW1tZXRyaWNkaWZmZXJlbmNlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN5bW1ldHJpY0RpZmZlcmVuY2Uob3RoZXIpIHtcbiAgdmFyIE8gPSBhU2V0KHRoaXMpO1xuICB2YXIga2V5c0l0ZXIgPSBnZXRTZXRSZWNvcmQob3RoZXIpLmdldEl0ZXJhdG9yKCk7XG4gIHZhciByZXN1bHQgPSBjbG9uZShPKTtcbiAgaXRlcmF0ZVNpbXBsZShrZXlzSXRlciwgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoaGFzKE8sIGUpKSByZW1vdmUocmVzdWx0LCBlKTtcbiAgICBlbHNlIGFkZChyZXN1bHQsIGUpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM3MDY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcbnZhciBzdG9yZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzYyOSk7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMoRnVuY3Rpb24udG9TdHJpbmcpO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUoc3RvcmUuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZS5pbnNwZWN0U291cmNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNzE3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM3MjQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPT0gNztcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNzg5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMDYpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTY1KTtcbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjkxKTtcbnZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTc2Nyk7XG5cbnZhciBJTlZBTElEX1NJWkUgPSAnSW52YWxpZCBzaXplJztcbnZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbnZhciBtYXggPSBNYXRoLm1heDtcblxudmFyIFNldFJlY29yZCA9IGZ1bmN0aW9uIChzZXQsIGludFNpemUpIHtcbiAgdGhpcy5zZXQgPSBzZXQ7XG4gIHRoaXMuc2l6ZSA9IG1heChpbnRTaXplLCAwKTtcbiAgdGhpcy5oYXMgPSBhQ2FsbGFibGUoc2V0Lmhhcyk7XG4gIHRoaXMua2V5cyA9IGFDYWxsYWJsZShzZXQua2V5cyk7XG59O1xuXG5TZXRSZWNvcmQucHJvdG90eXBlID0ge1xuICBnZXRJdGVyYXRvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRJdGVyYXRvckRpcmVjdChhbk9iamVjdChjYWxsKHRoaXMua2V5cywgdGhpcy5zZXQpKSk7XG4gIH0sXG4gIGluY2x1ZGVzOiBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gY2FsbCh0aGlzLmhhcywgdGhpcy5zZXQsIGl0KTtcbiAgfVxufTtcblxuLy8gYEdldFNldFJlY29yZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvcHJvcG9zYWwtc2V0LW1ldGhvZHMvI3NlYy1nZXRzZXRyZWNvcmRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICBhbk9iamVjdChvYmopO1xuICB2YXIgbnVtU2l6ZSA9ICtvYmouc2l6ZTtcbiAgLy8gTk9URTogSWYgc2l6ZSBpcyB1bmRlZmluZWQsIHRoZW4gbnVtU2l6ZSB3aWxsIGJlIE5hTlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICBpZiAobnVtU2l6ZSAhPT0gbnVtU2l6ZSkgdGhyb3cgbmV3ICRUeXBlRXJyb3IoSU5WQUxJRF9TSVpFKTtcbiAgdmFyIGludFNpemUgPSB0b0ludGVnZXJPckluZmluaXR5KG51bVNpemUpO1xuICBpZiAoaW50U2l6ZSA8IDApIHRocm93IG5ldyAkUmFuZ2VFcnJvcihJTlZBTElEX1NJWkUpO1xuICByZXR1cm4gbmV3IFNldFJlY29yZChvYmosIGludFNpemUpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzgzODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgYVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oNzA4MCk7XG52YXIgc2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTE3MCk7XG52YXIgaXRlcmF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oODQ2OSk7XG52YXIgZ2V0U2V0UmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzg5KTtcblxuLy8gYFNldC5wcm90b3R5cGUuaXNTdWJzZXRPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuaXNzdWJzZXRvZlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N1YnNldE9mKG90aGVyKSB7XG4gIHZhciBPID0gYVNldCh0aGlzKTtcbiAgdmFyIG90aGVyUmVjID0gZ2V0U2V0UmVjb3JkKG90aGVyKTtcbiAgaWYgKHNpemUoTykgPiBvdGhlclJlYy5zaXplKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpdGVyYXRlKE8sIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCFvdGhlclJlYy5pbmNsdWRlcyhlKSkgcmV0dXJuIGZhbHNlO1xuICB9LCB0cnVlKSAhPT0gZmFsc2U7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzODUzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGlzRGlzam9pbnRGcm9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDQ5KTtcbnZhciBzZXRNZXRob2RBY2NlcHRTZXRMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTE2KTtcblxudmFyIElOQ09SUkVDVCA9ICFzZXRNZXRob2RBY2NlcHRTZXRMaWtlKCdpc0Rpc2pvaW50RnJvbScsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuICFyZXN1bHQ7XG59KTtcblxuLy8gYFNldC5wcm90b3R5cGUuaXNEaXNqb2ludEZyb21gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmlzZGlzam9pbnRmcm9tXG4kKHsgdGFyZ2V0OiAnU2V0JywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUIH0sIHtcbiAgaXNEaXNqb2ludEZyb206IGlzRGlzam9pbnRGcm9tXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzkyNTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGFyZ3VtZW50KSB8fCBhcmd1bWVudCA9PT0gbnVsbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM5NzI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChhcmd1bWVudCA9PT0gdW5kZWZpbmVkIHx8IGlzT2JqZWN0KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcigkU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQwNTU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDExNDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODk4MSk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxOTgpO1xudmFyIHNldEFycmF5TGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTI3KTtcbnZhciBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MzcpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcblxudmFyIElOQ09SUkVDVF9UT19MRU5HVEggPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbXS5wdXNoLmNhbGwoeyBsZW5ndGg6IDB4MTAwMDAwMDAwIH0sIDEpICE9PSA0Mjk0OTY3Mjk3O1xufSk7XG5cbi8vIFY4IDw9IDEyMSBhbmQgU2FmYXJpIDw9IDE1LjQ7IEZGIDwgMjMgdGhyb3dzIEludGVybmFsRXJyb3Jcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEyNjgxXG52YXIgcHJvcGVyRXJyb3JPbk5vbldyaXRhYmxlTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShbXSwgJ2xlbmd0aCcsIHsgd3JpdGFibGU6IGZhbHNlIH0pLnB1c2goKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3I7XG4gIH1cbn07XG5cbnZhciBGT1JDRUQgPSBJTkNPUlJFQ1RfVE9fTEVOR1RIIHx8ICFwcm9wZXJFcnJvck9uTm9uV3JpdGFibGVMZW5ndGgoKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5wdXNoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnB1c2hcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBhcml0eTogMSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBwdXNoOiBmdW5jdGlvbiBwdXNoKGl0ZW0pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlcihsZW4gKyBhcmdDb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdDb3VudDsgaSsrKSB7XG4gICAgICBPW2xlbl0gPSBhcmd1bWVudHNbaV07XG4gICAgICBsZW4rKztcbiAgICB9XG4gICAgc2V0QXJyYXlMZW5ndGgoTywgbGVuKTtcbiAgICByZXR1cm4gbGVuO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDExNzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuLy8gd2UgY2FuJ3QgdXNlIGp1c3QgYGl0ID09IG51bGxgIHNpbmNlIG9mIGBkb2N1bWVudC5hbGxgIHNwZWNpYWwgY2FzZVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1Jc0hUTUxEREEtaW50ZXJuYWwtc2xvdC1hZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gbnVsbCB8fCBpdCA9PT0gdW5kZWZpbmVkO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDE0OTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxudmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgaWYgKGl0ID09PSBpdCkgcmV0dXJuIGl0O1xuICB0aHJvdyBuZXcgJFJhbmdlRXJyb3IoJ05hTiBpcyBub3QgYWxsb3dlZCcpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDE1NDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oNjk1NSk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBQZXJmb3JtID8gUmVxdWlyZUludGVybmFsU2xvdChhcmd1bWVudCwgW1tUeXBlZEFycmF5TmFtZV1dKVxuLy8gSWYgYXJndW1lbnQuW1tUeXBlZEFycmF5TmFtZV1dIGlzIG5vdCBcIlVpbnQ4QXJyYXlcIiwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZihhcmd1bWVudCkgPT09ICdVaW50OEFycmF5JykgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcignQXJndW1lbnQgaXMgbm90IGFuIFVpbnQ4QXJyYXknKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQyMDQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwODApO1xudmFyIGFkZCA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDIpLmFkZCk7XG52YXIgY2xvbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyODYpO1xudmFyIGdldFNldFJlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzc4OSk7XG52YXIgaXRlcmF0ZVNpbXBsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA3KTtcblxuLy8gYFNldC5wcm90b3R5cGUudW5pb25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLnVuaW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuaW9uKG90aGVyKSB7XG4gIHZhciBPID0gYVNldCh0aGlzKTtcbiAgdmFyIGtleXNJdGVyID0gZ2V0U2V0UmVjb3JkKG90aGVyKS5nZXRJdGVyYXRvcigpO1xuICB2YXIgcmVzdWx0ID0gY2xvbmUoTyk7XG4gIGl0ZXJhdGVTaW1wbGUoa2V5c0l0ZXIsIGZ1bmN0aW9uIChpdCkge1xuICAgIGFkZChyZXN1bHQsIGl0KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MjA5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyMjcpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNjI2OSk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MjE1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbi8qIGdsb2JhbCBCdW4sIERlbm8gLS0gZGV0ZWN0aW9uICovXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgdXNlckFnZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyODM5KTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTk1KTtcblxudmFyIHVzZXJBZ2VudFN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiB1c2VyQWdlbnQuc2xpY2UoMCwgc3RyaW5nLmxlbmd0aCkgPT09IHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHVzZXJBZ2VudFN0YXJ0c1dpdGgoJ0J1bi8nKSkgcmV0dXJuICdCVU4nO1xuICBpZiAodXNlckFnZW50U3RhcnRzV2l0aCgnQ2xvdWRmbGFyZS1Xb3JrZXJzJykpIHJldHVybiAnQ0xPVURGTEFSRSc7XG4gIGlmICh1c2VyQWdlbnRTdGFydHNXaXRoKCdEZW5vLycpKSByZXR1cm4gJ0RFTk8nO1xuICBpZiAodXNlckFnZW50U3RhcnRzV2l0aCgnTm9kZS5qcy8nKSkgcmV0dXJuICdOT0RFJztcbiAgaWYgKGdsb2JhbFRoaXMuQnVuICYmIHR5cGVvZiBCdW4udmVyc2lvbiA9PSAnc3RyaW5nJykgcmV0dXJuICdCVU4nO1xuICBpZiAoZ2xvYmFsVGhpcy5EZW5vICYmIHR5cGVvZiBEZW5vLnZlcnNpb24gPT0gJ29iamVjdCcpIHJldHVybiAnREVOTyc7XG4gIGlmIChjbGFzc29mKGdsb2JhbFRoaXMucHJvY2VzcykgPT09ICdwcm9jZXNzJykgcmV0dXJuICdOT0RFJztcbiAgaWYgKGdsb2JhbFRoaXMud2luZG93ICYmIGdsb2JhbFRoaXMuZG9jdW1lbnQpIHJldHVybiAnQlJPV1NFUic7XG4gIHJldHVybiAnUkVTVCc7XG59KSgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MjI2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIGFTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NjMpO1xudmFyIGFuVWludDhBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNDE1NCk7XG52YXIgbm90RGV0YWNoZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxNjkpO1xudmFyICRmcm9tSGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzAzKTtcblxuLy8gYFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldEZyb21IZXhgIG1ldGhvZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXlidWZmZXItYmFzZTY0XG5pZiAoZ2xvYmFsVGhpcy5VaW50OEFycmF5KSAkKHsgdGFyZ2V0OiAnVWludDhBcnJheScsIHByb3RvOiB0cnVlIH0sIHtcbiAgc2V0RnJvbUhleDogZnVuY3Rpb24gc2V0RnJvbUhleChzdHJpbmcpIHtcbiAgICBhblVpbnQ4QXJyYXkodGhpcyk7XG4gICAgYVN0cmluZyhzdHJpbmcpO1xuICAgIG5vdERldGFjaGVkKHRoaXMuYnVmZmVyKTtcbiAgICB2YXIgcmVhZCA9ICRmcm9tSGV4KHN0cmluZywgdGhpcykucmVhZDtcbiAgICByZXR1cm4geyByZWFkOiByZWFkLCB3cml0dGVuOiByZWFkIC8gMiB9O1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDIzNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDMwNjgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MjcwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTY1KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0KHZhbCA9IGNhbGwoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlKGZuID0gaW5wdXQudmFsdWVPZikgJiYgIWlzT2JqZWN0KHZhbCA9IGNhbGwoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQzNzY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOTUpO1xuXG4vLyBgSXNBcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1pc2FycmF5IC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZ3VtZW50KSB7XG4gIHJldHVybiBjbGFzc29mKGFyZ3VtZW50KSA9PT0gJ0FycmF5Jztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ0MDI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXNldCAtLSBzYWZlXG52YXIgU2V0UHJvdG90eXBlID0gU2V0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1zZXQgLS0gc2FmZVxuICBTZXQ6IFNldCxcbiAgYWRkOiB1bmN1cnJ5VGhpcyhTZXRQcm90b3R5cGUuYWRkKSxcbiAgaGFzOiB1bmN1cnJ5VGhpcyhTZXRQcm90b3R5cGUuaGFzKSxcbiAgcmVtb3ZlOiB1bmN1cnJ5VGhpcyhTZXRQcm90b3R5cGVbJ2RlbGV0ZSddKSxcbiAgcHJvdG86IFNldFByb3RvdHlwZVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDQ0OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgYVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oNzA4MCk7XG52YXIgaGFzID0gKF9fd2VicGFja19yZXF1aXJlX18oNDQwMikuaGFzKTtcbnZhciBzaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTcwKTtcbnZhciBnZXRTZXRSZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3ODkpO1xudmFyIGl0ZXJhdGVTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0NjkpO1xudmFyIGl0ZXJhdGVTaW1wbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwNyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTUzOSk7XG5cbi8vIGBTZXQucHJvdG90eXBlLmlzRGlzam9pbnRGcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5pc2Rpc2pvaW50ZnJvbVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Rpc2pvaW50RnJvbShvdGhlcikge1xuICB2YXIgTyA9IGFTZXQodGhpcyk7XG4gIHZhciBvdGhlclJlYyA9IGdldFNldFJlY29yZChvdGhlcik7XG4gIGlmIChzaXplKE8pIDw9IG90aGVyUmVjLnNpemUpIHJldHVybiBpdGVyYXRlU2V0KE8sIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKG90aGVyUmVjLmluY2x1ZGVzKGUpKSByZXR1cm4gZmFsc2U7XG4gIH0sIHRydWUpICE9PSBmYWxzZTtcbiAgdmFyIGl0ZXJhdG9yID0gb3RoZXJSZWMuZ2V0SXRlcmF0b3IoKTtcbiAgcmV0dXJuIGl0ZXJhdGVTaW1wbGUoaXRlcmF0b3IsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGhhcyhPLCBlKSkgcmV0dXJuIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICdub3JtYWwnLCBmYWxzZSk7XG4gIH0pICE9PSBmYWxzZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ0ODM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIGdldEJ1aWx0SW5Ob2RlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NDI5KTtcbnZhciBQUk9QRVJfU1RSVUNUVVJFRF9DTE9ORV9UUkFOU0ZFUiA9IF9fd2VicGFja19yZXF1aXJlX18oMTU0OCk7XG5cbnZhciBzdHJ1Y3R1cmVkQ2xvbmUgPSBnbG9iYWxUaGlzLnN0cnVjdHVyZWRDbG9uZTtcbnZhciAkQXJyYXlCdWZmZXIgPSBnbG9iYWxUaGlzLkFycmF5QnVmZmVyO1xudmFyICRNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbFRoaXMuTWVzc2FnZUNoYW5uZWw7XG52YXIgZGV0YWNoID0gZmFsc2U7XG52YXIgV29ya2VyVGhyZWFkcywgY2hhbm5lbCwgYnVmZmVyLCAkZGV0YWNoO1xuXG5pZiAoUFJPUEVSX1NUUlVDVFVSRURfQ0xPTkVfVFJBTlNGRVIpIHtcbiAgZGV0YWNoID0gZnVuY3Rpb24gKHRyYW5zZmVyYWJsZSkge1xuICAgIHN0cnVjdHVyZWRDbG9uZSh0cmFuc2ZlcmFibGUsIHsgdHJhbnNmZXI6IFt0cmFuc2ZlcmFibGVdIH0pO1xuICB9O1xufSBlbHNlIGlmICgkQXJyYXlCdWZmZXIpIHRyeSB7XG4gIGlmICghJE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgV29ya2VyVGhyZWFkcyA9IGdldEJ1aWx0SW5Ob2RlTW9kdWxlKCd3b3JrZXJfdGhyZWFkcycpO1xuICAgIGlmIChXb3JrZXJUaHJlYWRzKSAkTWVzc2FnZUNoYW5uZWwgPSBXb3JrZXJUaHJlYWRzLk1lc3NhZ2VDaGFubmVsO1xuICB9XG5cbiAgaWYgKCRNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgJE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgYnVmZmVyID0gbmV3ICRBcnJheUJ1ZmZlcigyKTtcblxuICAgICRkZXRhY2ggPSBmdW5jdGlvbiAodHJhbnNmZXJhYmxlKSB7XG4gICAgICBjaGFubmVsLnBvcnQxLnBvc3RNZXNzYWdlKG51bGwsIFt0cmFuc2ZlcmFibGVdKTtcbiAgICB9O1xuXG4gICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID09PSAyKSB7XG4gICAgICAkZGV0YWNoKGJ1ZmZlcik7XG4gICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIGRldGFjaCA9ICRkZXRhY2g7XG4gICAgfVxuICB9XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZGV0YWNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NDk1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIFY4X1ZFUlNJT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MTkpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcblxudmFyICRTdHJpbmcgPSBnbG9iYWxUaGlzLlN0cmluZztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3Rpbmdcbm1vZHVsZS5leHBvcnRzID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woJ3N5bWJvbCBkZXRlY3Rpb24nKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICAvLyBuYjogRG8gbm90IGNhbGwgYFN0cmluZ2AgZGlyZWN0bHkgdG8gYXZvaWQgdGhpcyBiZWluZyBvcHRpbWl6ZWQgb3V0IHRvIGBzeW1ib2wrJydgIHdoaWNoIHdpbGwsXG4gIC8vIG9mIGNvdXJzZSwgZmFpbC5cbiAgcmV0dXJuICEkU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OICYmIFY4X1ZFUlNJT04gPCA0MTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NTI3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNDM3Nik7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIFNhZmFyaSA8IDEzIGRvZXMgbm90IHRocm93IGFuIGVycm9yIGluIHRoaXMgY2FzZVxudmFyIFNJTEVOVF9PTl9OT05fV1JJVEFCTEVfTEVOR1RIX1NFVCA9IERFU0NSSVBUT1JTICYmICFmdW5jdGlvbiAoKSB7XG4gIC8vIG1ha2VzIG5vIHNlbnNlIHdpdGhvdXQgcHJvcGVyIHN0cmljdCBtb2RlIHN1cHBvcnRcbiAgaWYgKHRoaXMgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFtdLCAnbGVuZ3RoJywgeyB3cml0YWJsZTogZmFsc2UgfSkubGVuZ3RoID0gMTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3I7XG4gIH1cbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTSUxFTlRfT05fTk9OX1dSSVRBQkxFX0xFTkdUSF9TRVQgPyBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gIGlmIChpc0FycmF5KE8pICYmICFnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgJ2xlbmd0aCcpLndyaXRhYmxlKSB7XG4gICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Nhbm5vdCBzZXQgcmVhZCBvbmx5IC5sZW5ndGgnKTtcbiAgfSByZXR1cm4gTy5sZW5ndGggPSBsZW5ndGg7XG59IDogZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICByZXR1cm4gTy5sZW5ndGggPSBsZW5ndGg7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NTQ5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvZWNtYTI2Mi9wdWxsLzM0Njdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBFeHBlY3RlZEVycm9yKSB7XG4gIHZhciBJdGVyYXRvciA9IGdsb2JhbFRoaXMuSXRlcmF0b3I7XG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yICYmIEl0ZXJhdG9yLnByb3RvdHlwZTtcbiAgdmFyIG1ldGhvZCA9IEl0ZXJhdG9yUHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlW01FVEhPRF9OQU1FXTtcblxuICB2YXIgQ0xPU0VEID0gZmFsc2U7XG5cbiAgaWYgKG1ldGhvZCkgdHJ5IHtcbiAgICBtZXRob2QuY2FsbCh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHRydWUgfTsgfSxcbiAgICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7IENMT1NFRCA9IHRydWU7IH1cbiAgICB9LCAtMSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MTE5NVxuICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXhwZWN0ZWRFcnJvcikpIENMT1NFRCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCFDTE9TRUQpIHJldHVybiBtZXRob2Q7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NTc2OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5tb2R1bGUuZXhwb3J0cyA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpIHx8XG4gIGNoZWNrKHR5cGVvZiB0aGlzID09ICdvYmplY3QnICYmIHRoaXMpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NjAzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NDApO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcbnZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNjU1KTtcbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgxMik7XG5cbnZhciAkVVJMU2VhcmNoUGFyYW1zID0gVVJMU2VhcmNoUGFyYW1zO1xudmFyIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSA9ICRVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlO1xudmFyIGFwcGVuZCA9IHVuY3VycnlUaGlzKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5hcHBlbmQpO1xudmFyICRkZWxldGUgPSB1bmN1cnJ5VGhpcyhVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGVbJ2RlbGV0ZSddKTtcbnZhciBmb3JFYWNoID0gdW5jdXJyeVRoaXMoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLmZvckVhY2gpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcbnZhciBwYXJhbXMgPSBuZXcgJFVSTFNlYXJjaFBhcmFtcygnYT0xJmE9MiZiPTMnKTtcblxucGFyYW1zWydkZWxldGUnXSgnYScsIDEpO1xuLy8gYHVuZGVmaW5lZGAgY2FzZSBpcyBhIENocm9taXVtIDExNyBidWdcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTE0MjIyXG5wYXJhbXNbJ2RlbGV0ZSddKCdiJywgdW5kZWZpbmVkKTtcblxuaWYgKHBhcmFtcyArICcnICE9PSAnYT0yJykge1xuICBkZWZpbmVCdWlsdEluKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgJ2RlbGV0ZScsIGZ1bmN0aW9uIChuYW1lIC8qICwgdmFsdWUgKi8pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgJHZhbHVlID0gbGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAobGVuZ3RoICYmICR2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJGRlbGV0ZSh0aGlzLCBuYW1lKTtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIGZvckVhY2godGhpcywgZnVuY3Rpb24gKHYsIGspIHsgLy8gYWxzbyB2YWxpZGF0ZXMgYHRoaXNgXG4gICAgICBwdXNoKGVudHJpZXMsIHsga2V5OiBrLCB2YWx1ZTogdiB9KTtcbiAgICB9KTtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChsZW5ndGgsIDEpO1xuICAgIHZhciBrZXkgPSB0b1N0cmluZyhuYW1lKTtcbiAgICB2YXIgdmFsdWUgPSB0b1N0cmluZygkdmFsdWUpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGRpbmRleCA9IDA7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgdmFyIGVudHJpZXNMZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICB2YXIgZW50cnk7XG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllc0xlbmd0aCkge1xuICAgICAgZW50cnkgPSBlbnRyaWVzW2luZGV4KytdO1xuICAgICAgaWYgKGZvdW5kIHx8IGVudHJ5LmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgJGRlbGV0ZSh0aGlzLCBlbnRyeS5rZXkpO1xuICAgICAgfSBlbHNlIGRpbmRleCsrO1xuICAgIH1cbiAgICB3aGlsZSAoZGluZGV4IDwgZW50cmllc0xlbmd0aCkge1xuICAgICAgZW50cnkgPSBlbnRyaWVzW2RpbmRleCsrXTtcbiAgICAgIGlmICghKGVudHJ5LmtleSA9PT0ga2V5ICYmIGVudHJ5LnZhbHVlID09PSB2YWx1ZSkpIGFwcGVuZCh0aGlzLCBlbnRyeS5rZXksIGVudHJ5LnZhbHVlKTtcbiAgICB9XG4gIH0sIHsgZW51bWVyYWJsZTogdHJ1ZSwgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NjI4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDQzKTtcblxuLy8gYFByb21pc2Uud2l0aFJlc29sdmVyc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2Uud2l0aFJlc29sdmVyc1xuJCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlIH0sIHtcbiAgd2l0aFJlc29sdmVyczogZnVuY3Rpb24gd2l0aFJlc29sdmVycygpIHtcbiAgICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKHRoaXMpO1xuICAgIHJldHVybiB7XG4gICAgICBwcm9taXNlOiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlLFxuICAgICAgcmVzb2x2ZTogcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZSxcbiAgICAgIHJlamVjdDogcHJvbWlzZUNhcGFiaWxpdHkucmVqZWN0XG4gICAgfTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ2NDQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIE5BVElWRV9BUlJBWV9CVUZGRVIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4MTEpO1xudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzI0KTtcbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5Nyk7XG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oNjk1NSk7XG52YXIgdHJ5VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MjMpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNjY5OSk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNjg0MCk7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTA2KTtcbnZhciBpc1Byb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjI1KTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMjc4Nyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5NjcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oODIyNyk7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzkyKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTgxKTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBJbnQ4QXJyYXkgPSBnbG9iYWxUaGlzLkludDhBcnJheTtcbnZhciBJbnQ4QXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXkgJiYgSW50OEFycmF5LnByb3RvdHlwZTtcbnZhciBVaW50OENsYW1wZWRBcnJheSA9IGdsb2JhbFRoaXMuVWludDhDbGFtcGVkQXJyYXk7XG52YXIgVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUgPSBVaW50OENsYW1wZWRBcnJheSAmJiBVaW50OENsYW1wZWRBcnJheS5wcm90b3R5cGU7XG52YXIgVHlwZWRBcnJheSA9IEludDhBcnJheSAmJiBnZXRQcm90b3R5cGVPZihJbnQ4QXJyYXkpO1xudmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXlQcm90b3R5cGUgJiYgZ2V0UHJvdG90eXBlT2YoSW50OEFycmF5UHJvdG90eXBlKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbFRoaXMuVHlwZUVycm9yO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciBUWVBFRF9BUlJBWV9UQUcgPSB1aWQoJ1RZUEVEX0FSUkFZX1RBRycpO1xudmFyIFRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SID0gJ1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcic7XG4vLyBGaXhpbmcgbmF0aXZlIHR5cGVkIGFycmF5cyBpbiBPcGVyYSBQcmVzdG8gY3Jhc2hlcyB0aGUgYnJvd3Nlciwgc2VlICM1OTVcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTID0gTkFUSVZFX0FSUkFZX0JVRkZFUiAmJiAhIXNldFByb3RvdHlwZU9mICYmIGNsYXNzb2YoZ2xvYmFsVGhpcy5vcGVyYSkgIT09ICdPcGVyYSc7XG52YXIgVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEID0gZmFsc2U7XG52YXIgTkFNRSwgQ29uc3RydWN0b3IsIFByb3RvdHlwZTtcblxudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0ID0ge1xuICBJbnQ4QXJyYXk6IDEsXG4gIFVpbnQ4QXJyYXk6IDEsXG4gIFVpbnQ4Q2xhbXBlZEFycmF5OiAxLFxuICBJbnQxNkFycmF5OiAyLFxuICBVaW50MTZBcnJheTogMixcbiAgSW50MzJBcnJheTogNCxcbiAgVWludDMyQXJyYXk6IDQsXG4gIEZsb2F0MzJBcnJheTogNCxcbiAgRmxvYXQ2NEFycmF5OiA4XG59O1xuXG52YXIgQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0ID0ge1xuICBCaWdJbnQ2NEFycmF5OiA4LFxuICBCaWdVaW50NjRBcnJheTogOFxufTtcblxudmFyIGlzVmlldyA9IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGZhbHNlO1xuICB2YXIga2xhc3MgPSBjbGFzc29mKGl0KTtcbiAgcmV0dXJuIGtsYXNzID09PSAnRGF0YVZpZXcnXG4gICAgfHwgaGFzT3duKFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcylcbiAgICB8fCBoYXNPd24oQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcyk7XG59O1xuXG52YXIgZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGl0KTtcbiAgaWYgKCFpc09iamVjdChwcm90bykpIHJldHVybjtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZShwcm90byk7XG4gIHJldHVybiAoc3RhdGUgJiYgaGFzT3duKHN0YXRlLCBUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUikpID8gc3RhdGVbVFlQRURfQVJSQVlfQ09OU1RSVUNUT1JdIDogZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yKHByb3RvKTtcbn07XG5cbnZhciBpc1R5cGVkQXJyYXkgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBmYWxzZTtcbiAgdmFyIGtsYXNzID0gY2xhc3NvZihpdCk7XG4gIHJldHVybiBoYXNPd24oVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKVxuICAgIHx8IGhhc093bihCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKTtcbn07XG5cbnZhciBhVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNUeXBlZEFycmF5KGl0KSkgcmV0dXJuIGl0O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUYXJnZXQgaXMgbm90IGEgdHlwZWQgYXJyYXknKTtcbn07XG5cbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKEMpIHtcbiAgaWYgKGlzQ2FsbGFibGUoQykgJiYgKCFzZXRQcm90b3R5cGVPZiB8fCBpc1Byb3RvdHlwZU9mKFR5cGVkQXJyYXksIEMpKSkgcmV0dXJuIEM7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IodHJ5VG9TdHJpbmcoQykgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yJyk7XG59O1xuXG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IGZ1bmN0aW9uIChLRVksIHByb3BlcnR5LCBmb3JjZWQsIG9wdGlvbnMpIHtcbiAgaWYgKCFERVNDUklQVE9SUykgcmV0dXJuO1xuICBpZiAoZm9yY2VkKSBmb3IgKHZhciBBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWxUaGlzW0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIGhhc093bihUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlLCBLRVkpKSB0cnkge1xuICAgICAgZGVsZXRlIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gb2xkIFdlYktpdCBidWcgLSBzb21lIG1ldGhvZHMgYXJlIG5vbi1jb25maWd1cmFibGVcbiAgICAgIHRyeSB7XG4gICAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXSA9IHByb3BlcnR5O1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7IC8qIGVtcHR5ICovIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFUeXBlZEFycmF5UHJvdG90eXBlW0tFWV0gfHwgZm9yY2VkKSB7XG4gICAgZGVmaW5lQnVpbHRJbihUeXBlZEFycmF5UHJvdG90eXBlLCBLRVksIGZvcmNlZCA/IHByb3BlcnR5XG4gICAgICA6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgJiYgSW50OEFycmF5UHJvdG90eXBlW0tFWV0gfHwgcHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCA9IGZ1bmN0aW9uIChLRVksIHByb3BlcnR5LCBmb3JjZWQpIHtcbiAgdmFyIEFSUkFZLCBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gIGlmICghREVTQ1JJUFRPUlMpIHJldHVybjtcbiAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgaWYgKGZvcmNlZCkgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsVGhpc1tBUlJBWV07XG4gICAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIGhhc093bihUeXBlZEFycmF5Q29uc3RydWN0b3IsIEtFWSkpIHRyeSB7XG4gICAgICAgIGRlbGV0ZSBUeXBlZEFycmF5Q29uc3RydWN0b3JbS0VZXTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICB9XG4gICAgaWYgKCFUeXBlZEFycmF5W0tFWV0gfHwgZm9yY2VkKSB7XG4gICAgICAvLyBWOCB+IENocm9tZSA0OS01MCBgJVR5cGVkQXJyYXklYCBtZXRob2RzIGFyZSBub24td3JpdGFibGUgbm9uLWNvbmZpZ3VyYWJsZVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlZmluZUJ1aWx0SW4oVHlwZWRBcnJheSwgS0VZLCBmb3JjZWQgPyBwcm9wZXJ0eSA6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgJiYgVHlwZWRBcnJheVtLRVldIHx8IHByb3BlcnR5KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICB9IGVsc2UgcmV0dXJuO1xuICB9XG4gIGZvciAoQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWxUaGlzW0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmICghVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV0gfHwgZm9yY2VkKSkge1xuICAgICAgZGVmaW5lQnVpbHRJbihUeXBlZEFycmF5Q29uc3RydWN0b3IsIEtFWSwgcHJvcGVydHkpO1xuICAgIH1cbiAgfVxufTtcblxuZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gIENvbnN0cnVjdG9yID0gZ2xvYmFsVGhpc1tOQU1FXTtcbiAgUHJvdG90eXBlID0gQ29uc3RydWN0b3IgJiYgQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICBpZiAoUHJvdG90eXBlKSBlbmZvcmNlSW50ZXJuYWxTdGF0ZShQcm90b3R5cGUpW1RZUEVEX0FSUkFZX0NPTlNUUlVDVE9SXSA9IENvbnN0cnVjdG9yO1xuICBlbHNlIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBmYWxzZTtcbn1cblxuZm9yIChOQU1FIGluIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICBDb25zdHJ1Y3RvciA9IGdsb2JhbFRoaXNbTkFNRV07XG4gIFByb3RvdHlwZSA9IENvbnN0cnVjdG9yICYmIENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgaWYgKFByb3RvdHlwZSkgZW5mb3JjZUludGVybmFsU3RhdGUoUHJvdG90eXBlKVtUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUl0gPSBDb25zdHJ1Y3Rvcjtcbn1cblxuLy8gV2ViS2l0IGJ1ZyAtIHR5cGVkIGFycmF5cyBjb25zdHJ1Y3RvcnMgcHJvdG90eXBlIGlzIE9iamVjdC5wcm90b3R5cGVcbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB8fCAhaXNDYWxsYWJsZShUeXBlZEFycmF5KSB8fCBUeXBlZEFycmF5ID09PSBGdW5jdGlvbi5wcm90b3R5cGUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdyAtLSBzYWZlXG4gIFR5cGVkQXJyYXkgPSBmdW5jdGlvbiBUeXBlZEFycmF5KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG4gIH07XG4gIGlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBpZiAoZ2xvYmFsVGhpc1tOQU1FXSkgc2V0UHJvdG90eXBlT2YoZ2xvYmFsVGhpc1tOQU1FXSwgVHlwZWRBcnJheSk7XG4gIH1cbn1cblxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIHx8ICFUeXBlZEFycmF5UHJvdG90eXBlIHx8IFR5cGVkQXJyYXlQcm90b3R5cGUgPT09IE9iamVjdFByb3RvdHlwZSkge1xuICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheS5wcm90b3R5cGU7XG4gIGlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBpZiAoZ2xvYmFsVGhpc1tOQU1FXSkgc2V0UHJvdG90eXBlT2YoZ2xvYmFsVGhpc1tOQU1FXS5wcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUpO1xuICB9XG59XG5cbi8vIFdlYktpdCBidWcgLSBvbmUgbW9yZSBvYmplY3QgaW4gVWludDhDbGFtcGVkQXJyYXkgcHJvdG90eXBlIGNoYWluXG5pZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBnZXRQcm90b3R5cGVPZihVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSkgIT09IFR5cGVkQXJyYXlQcm90b3R5cGUpIHtcbiAgc2V0UHJvdG90eXBlT2YoVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUpO1xufVxuXG5pZiAoREVTQ1JJUFRPUlMgJiYgIWhhc093bihUeXBlZEFycmF5UHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkge1xuICBUWVBFRF9BUlJBWV9UQUdfUkVRVUlSRUQgPSB0cnVlO1xuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVHlwZWRBcnJheVByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh0aGlzKSA/IHRoaXNbVFlQRURfQVJSQVlfVEFHXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIGlmIChnbG9iYWxUaGlzW05BTUVdKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGdsb2JhbFRoaXNbTkFNRV0sIFRZUEVEX0FSUkFZX1RBRywgTkFNRSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1M6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MsXG4gIFRZUEVEX0FSUkFZX1RBRzogVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEICYmIFRZUEVEX0FSUkFZX1RBRyxcbiAgYVR5cGVkQXJyYXk6IGFUeXBlZEFycmF5LFxuICBhVHlwZWRBcnJheUNvbnN0cnVjdG9yOiBhVHlwZWRBcnJheUNvbnN0cnVjdG9yLFxuICBleHBvcnRUeXBlZEFycmF5TWV0aG9kOiBleHBvcnRUeXBlZEFycmF5TWV0aG9kLFxuICBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kOiBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kLFxuICBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3I6IGdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvcixcbiAgaXNWaWV3OiBpc1ZpZXcsXG4gIGlzVHlwZWRBcnJheTogaXNUeXBlZEFycmF5LFxuICBUeXBlZEFycmF5OiBUeXBlZEFycmF5LFxuICBUeXBlZEFycmF5UHJvdG90eXBlOiBUeXBlZEFycmF5UHJvdG90eXBlXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NjU5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MTMpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjk4MCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtrZXldID0gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0OTAxOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLUlzSFRNTEREQS1pbnRlcm5hbC1zbG90XG52YXIgZG9jdW1lbnRBbGwgPSB0eXBlb2YgZG9jdW1lbnQgPT0gJ29iamVjdCcgJiYgZG9jdW1lbnQuYWxsO1xuXG4vLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLXR5cGVvZi11bmRlZmluZWQgLS0gcmVxdWlyZWQgZm9yIHRlc3Rpbmdcbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIGRvY3VtZW50QWxsID09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50QWxsICE9PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50ID09PSBkb2N1bWVudEFsbDtcbn0gOiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDkxMzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MjQpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTE3KTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IF9fd2VicGFja19yZXF1aXJlX18oODY4Nik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIHRvUHJvcGVydHlLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NjkpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFTlVNRVJBQkxFID0gJ2VudW1lcmFibGUnO1xudmFyIENPTkZJR1VSQUJMRSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEVdIDogY3VycmVudFtDT05GSUdVUkFCTEVdLFxuICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfSByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xufSA6ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ5MTY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3NTEpO1xuXG52YXIgY3JlYXRlU2V0TGlrZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiB7XG4gICAgc2l6ZTogc2l6ZSxcbiAgICBoYXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxudmFyIGNyZWF0ZVNldExpa2VXaXRoSW5maW5pdHlTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIHtcbiAgICBzaXplOiBzaXplLFxuICAgIGhhczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2UnKTtcbiAgICB9XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICB2YXIgU2V0ID0gZ2V0QnVpbHRJbignU2V0Jyk7XG4gIHRyeSB7XG4gICAgbmV3IFNldCgpW25hbWVdKGNyZWF0ZVNldExpa2UoMCkpO1xuICAgIHRyeSB7XG4gICAgICAvLyBsYXRlIHNwZWMgY2hhbmdlLCBlYXJseSBXZWJLaXQgfiBTYWZhcmkgMTcgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgcGFzcyBpdFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc2V0LW1ldGhvZHMvcHVsbC84OFxuICAgICAgLy8gYWxzbyBjb3ZlcmVkIGVuZ2luZXMgd2l0aFxuICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI3MjY3OVxuICAgICAgbmV3IFNldCgpW25hbWVdKGNyZWF0ZVNldExpa2UoLTEpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiB0cnVlO1xuICAgICAgLy8gZWFybHkgVjggaW1wbGVtZW50YXRpb24gYnVnXG4gICAgICAvLyBodHRwczovL2lzc3Vlcy5jaHJvbWl1bS5vcmcvaXNzdWVzLzM1MTMzMjYzNFxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IFNldCgpW25hbWVdKGNyZWF0ZVNldExpa2VXaXRoSW5maW5pdHlTaXplKC1JbmZpbml0eSkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB2YXIgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBzZXQuYWRkKDEpO1xuICAgICAgICBzZXQuYWRkKDIpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soc2V0W25hbWVdKGNyZWF0ZVNldExpa2VXaXRoSW5maW5pdHlTaXplKEluZmluaXR5KSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ5NzI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzY3KTtcbnZhciBub3RBTmFOID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTQ5KTtcbnZhciB0b1Bvc2l0aXZlSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTU5MCk7XG52YXIgY3JlYXRlSXRlcmF0b3JQcm94eSA9IF9fd2VicGFja19yZXF1aXJlX18oOTQ2Mik7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTUzOSk7XG52YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDU0OSk7XG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oNjM5NSk7XG5cbnZhciB0YWtlV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSAhSVNfUFVSRSAmJiBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKCd0YWtlJywgUmFuZ2VFcnJvcik7XG5cbnZhciBJdGVyYXRvclByb3h5ID0gY3JlYXRlSXRlcmF0b3JQcm94eShmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3I7XG4gIGlmICghdGhpcy5yZW1haW5pbmctLSkge1xuICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgcmV0dXJuIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICdub3JtYWwnLCB1bmRlZmluZWQpO1xuICB9XG4gIHZhciByZXN1bHQgPSBhbk9iamVjdChjYWxsKHRoaXMubmV4dCwgaXRlcmF0b3IpKTtcbiAgdmFyIGRvbmUgPSB0aGlzLmRvbmUgPSAhIXJlc3VsdC5kb25lO1xuICBpZiAoIWRvbmUpIHJldHVybiByZXN1bHQudmFsdWU7XG59KTtcblxuLy8gYEl0ZXJhdG9yLnByb3RvdHlwZS50YWtlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXRlcmF0b3IucHJvdG90eXBlLnRha2VcbiQoeyB0YXJnZXQ6ICdJdGVyYXRvcicsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IElTX1BVUkUgfHwgdGFrZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIH0sIHtcbiAgdGFrZTogZnVuY3Rpb24gdGFrZShsaW1pdCkge1xuICAgIGFuT2JqZWN0KHRoaXMpO1xuICAgIHZhciByZW1haW5pbmc7XG4gICAgdHJ5IHtcbiAgICAgIHJlbWFpbmluZyA9IHRvUG9zaXRpdmVJbnRlZ2VyKG5vdEFOYU4oK2xpbWl0KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UodGhpcywgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmICh0YWtlV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IpIHJldHVybiBjYWxsKHRha2VXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciwgdGhpcywgcmVtYWluaW5nKTtcblxuICAgIHJldHVybiBuZXcgSXRlcmF0b3JQcm94eShnZXRJdGVyYXRvckRpcmVjdCh0aGlzKSwge1xuICAgICAgcmVtYWluaW5nOiByZW1haW5pbmdcbiAgICB9KTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ5Nzk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzc1MSk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTgwKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MTMpLmYpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5Nyk7XG52YXIgYW5JbnN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjc5KTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzE2Nyk7XG52YXIgbm9ybWFsaXplU3RyaW5nQXJndW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MDMpO1xudmFyIERPTUV4Y2VwdGlvbkNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTAwMik7XG52YXIgY2xlYXJFcnJvclN0YWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTc0KTtcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oNjM5NSk7XG5cbnZhciBET01fRVhDRVBUSU9OID0gJ0RPTUV4Y2VwdGlvbic7XG52YXIgRXJyb3IgPSBnZXRCdWlsdEluKCdFcnJvcicpO1xudmFyIE5hdGl2ZURPTUV4Y2VwdGlvbiA9IGdldEJ1aWx0SW4oRE9NX0VYQ0VQVElPTik7XG5cbnZhciAkRE9NRXhjZXB0aW9uID0gZnVuY3Rpb24gRE9NRXhjZXB0aW9uKCkge1xuICBhbkluc3RhbmNlKHRoaXMsIERPTUV4Y2VwdGlvblByb3RvdHlwZSk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWVzc2FnZSA9IG5vcm1hbGl6ZVN0cmluZ0FyZ3VtZW50KGFyZ3VtZW50c0xlbmd0aCA8IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pO1xuICB2YXIgbmFtZSA9IG5vcm1hbGl6ZVN0cmluZ0FyZ3VtZW50KGFyZ3VtZW50c0xlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0sICdFcnJvcicpO1xuICB2YXIgdGhhdCA9IG5ldyBOYXRpdmVET01FeGNlcHRpb24obWVzc2FnZSwgbmFtZSk7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyb3IubmFtZSA9IERPTV9FWENFUFRJT047XG4gIGRlZmluZVByb3BlcnR5KHRoYXQsICdzdGFjaycsIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCBjbGVhckVycm9yU3RhY2soZXJyb3Iuc3RhY2ssIDEpKSk7XG4gIGluaGVyaXRJZlJlcXVpcmVkKHRoYXQsIHRoaXMsICRET01FeGNlcHRpb24pO1xuICByZXR1cm4gdGhhdDtcbn07XG5cbnZhciBET01FeGNlcHRpb25Qcm90b3R5cGUgPSAkRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IE5hdGl2ZURPTUV4Y2VwdGlvbi5wcm90b3R5cGU7XG5cbnZhciBFUlJPUl9IQVNfU1RBQ0sgPSAnc3RhY2snIGluIG5ldyBFcnJvcihET01fRVhDRVBUSU9OKTtcbnZhciBET01fRVhDRVBUSU9OX0hBU19TVEFDSyA9ICdzdGFjaycgaW4gbmV3IE5hdGl2ZURPTUV4Y2VwdGlvbigxLCAyKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGRlc2NyaXB0b3IgPSBOYXRpdmVET01FeGNlcHRpb24gJiYgREVTQ1JJUFRPUlMgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWxUaGlzLCBET01fRVhDRVBUSU9OKTtcblxuLy8gQnVuIH4gMC4xLjEgRE9NRXhjZXB0aW9uIGhhdmUgaW5jb3JyZWN0IGRlc2NyaXB0b3IgYW5kIHdlIGNhbid0IHJlZGVmaW5lIGl0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vSmFycmVkLVN1bW5lci9idW4vaXNzdWVzLzM5OVxudmFyIEJVR0dZX0RFU0NSSVBUT1IgPSAhIWRlc2NyaXB0b3IgJiYgIShkZXNjcmlwdG9yLndyaXRhYmxlICYmIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlKTtcblxudmFyIEZPUkNFRF9DT05TVFJVQ1RPUiA9IEVSUk9SX0hBU19TVEFDSyAmJiAhQlVHR1lfREVTQ1JJUFRPUiAmJiAhRE9NX0VYQ0VQVElPTl9IQVNfU1RBQ0s7XG5cbi8vIGBET01FeGNlcHRpb25gIGNvbnN0cnVjdG9yIHBhdGNoIGZvciBgLnN0YWNrYCB3aGVyZSBpdCdzIHJlcXVpcmVkXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLURPTUV4Y2VwdGlvbi1zcGVjaWFsbmVzc1xuJCh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGZvcmNlZDogSVNfUFVSRSB8fCBGT1JDRURfQ09OU1RSVUNUT1IgfSwgeyAvLyBUT0RPOiBmaXggZXhwb3J0IGxvZ2ljXG4gIERPTUV4Y2VwdGlvbjogRk9SQ0VEX0NPTlNUUlVDVE9SID8gJERPTUV4Y2VwdGlvbiA6IE5hdGl2ZURPTUV4Y2VwdGlvblxufSk7XG5cbnZhciBQb2x5ZmlsbGVkRE9NRXhjZXB0aW9uID0gZ2V0QnVpbHRJbihET01fRVhDRVBUSU9OKTtcbnZhciBQb2x5ZmlsbGVkRE9NRXhjZXB0aW9uUHJvdG90eXBlID0gUG9seWZpbGxlZERPTUV4Y2VwdGlvbi5wcm90b3R5cGU7XG5cbmlmIChQb2x5ZmlsbGVkRE9NRXhjZXB0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yICE9PSBQb2x5ZmlsbGVkRE9NRXhjZXB0aW9uKSB7XG4gIGlmICghSVNfUFVSRSkge1xuICAgIGRlZmluZVByb3BlcnR5KFBvbHlmaWxsZWRET01FeGNlcHRpb25Qcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCBQb2x5ZmlsbGVkRE9NRXhjZXB0aW9uKSk7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gRE9NRXhjZXB0aW9uQ29uc3RhbnRzKSBpZiAoaGFzT3duKERPTUV4Y2VwdGlvbkNvbnN0YW50cywga2V5KSkge1xuICAgIHZhciBjb25zdGFudCA9IERPTUV4Y2VwdGlvbkNvbnN0YW50c1trZXldO1xuICAgIHZhciBjb25zdGFudE5hbWUgPSBjb25zdGFudC5zO1xuICAgIGlmICghaGFzT3duKFBvbHlmaWxsZWRET01FeGNlcHRpb24sIGNvbnN0YW50TmFtZSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KFBvbHlmaWxsZWRET01FeGNlcHRpb24sIGNvbnN0YW50TmFtZSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDYsIGNvbnN0YW50LmMpKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTAwMjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEluZGV4U2l6ZUVycm9yOiB7IHM6ICdJTkRFWF9TSVpFX0VSUicsIGM6IDEsIG06IDEgfSxcbiAgRE9NU3RyaW5nU2l6ZUVycm9yOiB7IHM6ICdET01TVFJJTkdfU0laRV9FUlInLCBjOiAyLCBtOiAwIH0sXG4gIEhpZXJhcmNoeVJlcXVlc3RFcnJvcjogeyBzOiAnSElFUkFSQ0hZX1JFUVVFU1RfRVJSJywgYzogMywgbTogMSB9LFxuICBXcm9uZ0RvY3VtZW50RXJyb3I6IHsgczogJ1dST05HX0RPQ1VNRU5UX0VSUicsIGM6IDQsIG06IDEgfSxcbiAgSW52YWxpZENoYXJhY3RlckVycm9yOiB7IHM6ICdJTlZBTElEX0NIQVJBQ1RFUl9FUlInLCBjOiA1LCBtOiAxIH0sXG4gIE5vRGF0YUFsbG93ZWRFcnJvcjogeyBzOiAnTk9fREFUQV9BTExPV0VEX0VSUicsIGM6IDYsIG06IDAgfSxcbiAgTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3I6IHsgczogJ05PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUicsIGM6IDcsIG06IDEgfSxcbiAgTm90Rm91bmRFcnJvcjogeyBzOiAnTk9UX0ZPVU5EX0VSUicsIGM6IDgsIG06IDEgfSxcbiAgTm90U3VwcG9ydGVkRXJyb3I6IHsgczogJ05PVF9TVVBQT1JURURfRVJSJywgYzogOSwgbTogMSB9LFxuICBJblVzZUF0dHJpYnV0ZUVycm9yOiB7IHM6ICdJTlVTRV9BVFRSSUJVVEVfRVJSJywgYzogMTAsIG06IDEgfSxcbiAgSW52YWxpZFN0YXRlRXJyb3I6IHsgczogJ0lOVkFMSURfU1RBVEVfRVJSJywgYzogMTEsIG06IDEgfSxcbiAgU3ludGF4RXJyb3I6IHsgczogJ1NZTlRBWF9FUlInLCBjOiAxMiwgbTogMSB9LFxuICBJbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3I6IHsgczogJ0lOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUicsIGM6IDEzLCBtOiAxIH0sXG4gIE5hbWVzcGFjZUVycm9yOiB7IHM6ICdOQU1FU1BBQ0VfRVJSJywgYzogMTQsIG06IDEgfSxcbiAgSW52YWxpZEFjY2Vzc0Vycm9yOiB7IHM6ICdJTlZBTElEX0FDQ0VTU19FUlInLCBjOiAxNSwgbTogMSB9LFxuICBWYWxpZGF0aW9uRXJyb3I6IHsgczogJ1ZBTElEQVRJT05fRVJSJywgYzogMTYsIG06IDAgfSxcbiAgVHlwZU1pc21hdGNoRXJyb3I6IHsgczogJ1RZUEVfTUlTTUFUQ0hfRVJSJywgYzogMTcsIG06IDEgfSxcbiAgU2VjdXJpdHlFcnJvcjogeyBzOiAnU0VDVVJJVFlfRVJSJywgYzogMTgsIG06IDEgfSxcbiAgTmV0d29ya0Vycm9yOiB7IHM6ICdORVRXT1JLX0VSUicsIGM6IDE5LCBtOiAxIH0sXG4gIEFib3J0RXJyb3I6IHsgczogJ0FCT1JUX0VSUicsIGM6IDIwLCBtOiAxIH0sXG4gIFVSTE1pc21hdGNoRXJyb3I6IHsgczogJ1VSTF9NSVNNQVRDSF9FUlInLCBjOiAyMSwgbTogMSB9LFxuICBRdW90YUV4Y2VlZGVkRXJyb3I6IHsgczogJ1FVT1RBX0VYQ0VFREVEX0VSUicsIGM6IDIyLCBtOiAxIH0sXG4gIFRpbWVvdXRFcnJvcjogeyBzOiAnVElNRU9VVF9FUlInLCBjOiAyMywgbTogMSB9LFxuICBJbnZhbGlkTm9kZVR5cGVFcnJvcjogeyBzOiAnSU5WQUxJRF9OT0RFX1RZUEVfRVJSJywgYzogMjQsIG06IDEgfSxcbiAgRGF0YUNsb25lRXJyb3I6IHsgczogJ0RBVEFfQ0xPTkVfRVJSJywgYzogMjUsIG06IDEgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTAyNDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBzeW1tZXRyaWNEaWZmZXJlbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNjUwKTtcbnZhciBzZXRNZXRob2RHZXRLZXlzQmVmb3JlQ2xvbmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oOTgzNSk7XG52YXIgc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkxNik7XG5cbnZhciBGT1JDRUQgPSAhc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSgnc3ltbWV0cmljRGlmZmVyZW5jZScpIHx8ICFzZXRNZXRob2RHZXRLZXlzQmVmb3JlQ2xvbmluZygnc3ltbWV0cmljRGlmZmVyZW5jZScpO1xuXG4vLyBgU2V0LnByb3RvdHlwZS5zeW1tZXRyaWNEaWZmZXJlbmNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5zeW1tZXRyaWNkaWZmZXJlbmNlXG4kKHsgdGFyZ2V0OiAnU2V0JywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgc3ltbWV0cmljRGlmZmVyZW5jZTogc3ltbWV0cmljRGlmZmVyZW5jZVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUwMzE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3NTEpO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDgwKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MTcpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcblxudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQoa2V5cywgZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTE2OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaXNEZXRhY2hlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIzOCk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNEZXRhY2hlZChpdCkpIHRocm93IG5ldyAkVHlwZUVycm9yKCdBcnJheUJ1ZmZlciBpcyBkZXRhY2hlZCcpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MTcwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpc0FjY2Vzc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzA2KTtcbnZhciBTZXRIZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDAyKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmN1cnJ5VGhpc0FjY2Vzc29yKFNldEhlbHBlcnMucHJvdG8sICdzaXplJywgJ2dldCcpIHx8IGZ1bmN0aW9uIChzZXQpIHtcbiAgcmV0dXJuIHNldC5zaXplO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTIxMzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciBhcnJheUZyb21Db25zdHJ1Y3RvckFuZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzNzApO1xudmFyICRmcm9tQmFzZTY0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTQzKTtcblxudmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWxUaGlzLlVpbnQ4QXJyYXk7XG5cbnZhciBJTkNPUlJFQ1RfQkVIQVZJT1JfT1JfRE9FU05UX0VYSVNUUyA9ICFVaW50OEFycmF5IHx8ICFVaW50OEFycmF5LmZyb21CYXNlNjQgfHwgIWZ1bmN0aW9uICgpIHtcbiAgLy8gV2Via2l0IG5vdCB0aHJvdyBhbiBlcnJvciBvbiBvZGQgbGVuZ3RoIHN0cmluZ1xuICB0cnkge1xuICAgIFVpbnQ4QXJyYXkuZnJvbUJhc2U2NCgnYScpO1xuICAgIHJldHVybjtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB0cnkge1xuICAgIFVpbnQ4QXJyYXkuZnJvbUJhc2U2NCgnJywgbnVsbCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0oKTtcblxuLy8gYFVpbnQ4QXJyYXkuZnJvbUJhc2U2NGAgbWV0aG9kXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hcnJheWJ1ZmZlci1iYXNlNjRcbmlmIChVaW50OEFycmF5KSAkKHsgdGFyZ2V0OiAnVWludDhBcnJheScsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0JFSEFWSU9SX09SX0RPRVNOVF9FWElTVFMgfSwge1xuICBmcm9tQmFzZTY0OiBmdW5jdGlvbiBmcm9tQmFzZTY0KHN0cmluZyAvKiAsIG9wdGlvbnMgKi8pIHtcbiAgICB2YXIgcmVzdWx0ID0gJGZyb21CYXNlNjQoc3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbnVsbCwgMHgxRkZGRkZGRkZGRkZGRik7XG4gICAgcmV0dXJuIGFycmF5RnJvbUNvbnN0cnVjdG9yQW5kTGlzdChVaW50OEFycmF5LCByZXN1bHQuYnl0ZXMpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTM3MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxOTgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgbGlzdCwgJGxlbmd0aCkge1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyAkbGVuZ3RoIDogbGVuZ3RoT2ZBcnJheUxpa2UobGlzdCk7XG4gIHZhciByZXN1bHQgPSBuZXcgQ29uc3RydWN0b3IobGVuZ3RoKTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUzOTc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDU1KTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NzUwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTYxMDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMTI5MSk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU2MjM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxuX193ZWJwYWNrX3JlcXVpcmVfXyg0NTYpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NjM2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG52YXIgdW5jdXJyeVRoaXNBY2Nlc3NvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjcwNik7XG52YXIgdG9JbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oNzY5Nik7XG52YXIgbm90RGV0YWNoZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxNjkpO1xudmFyIGFycmF5QnVmZmVyQnl0ZUxlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNzM5NCk7XG52YXIgZGV0YWNoVHJhbnNmZXJhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDgzKTtcbnZhciBQUk9QRVJfU1RSVUNUVVJFRF9DTE9ORV9UUkFOU0ZFUiA9IF9fd2VicGFja19yZXF1aXJlX18oMTU0OCk7XG5cbnZhciBzdHJ1Y3R1cmVkQ2xvbmUgPSBnbG9iYWxUaGlzLnN0cnVjdHVyZWRDbG9uZTtcbnZhciBBcnJheUJ1ZmZlciA9IGdsb2JhbFRoaXMuQXJyYXlCdWZmZXI7XG52YXIgRGF0YVZpZXcgPSBnbG9iYWxUaGlzLkRhdGFWaWV3O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIEFycmF5QnVmZmVyUHJvdG90eXBlID0gQXJyYXlCdWZmZXIucHJvdG90eXBlO1xudmFyIERhdGFWaWV3UHJvdG90eXBlID0gRGF0YVZpZXcucHJvdG90eXBlO1xudmFyIHNsaWNlID0gdW5jdXJyeVRoaXMoQXJyYXlCdWZmZXJQcm90b3R5cGUuc2xpY2UpO1xudmFyIGlzUmVzaXphYmxlID0gdW5jdXJyeVRoaXNBY2Nlc3NvcihBcnJheUJ1ZmZlclByb3RvdHlwZSwgJ3Jlc2l6YWJsZScsICdnZXQnKTtcbnZhciBtYXhCeXRlTGVuZ3RoID0gdW5jdXJyeVRoaXNBY2Nlc3NvcihBcnJheUJ1ZmZlclByb3RvdHlwZSwgJ21heEJ5dGVMZW5ndGgnLCAnZ2V0Jyk7XG52YXIgZ2V0SW50OCA9IHVuY3VycnlUaGlzKERhdGFWaWV3UHJvdG90eXBlLmdldEludDgpO1xudmFyIHNldEludDggPSB1bmN1cnJ5VGhpcyhEYXRhVmlld1Byb3RvdHlwZS5zZXRJbnQ4KTtcblxubW9kdWxlLmV4cG9ydHMgPSAoUFJPUEVSX1NUUlVDVFVSRURfQ0xPTkVfVFJBTlNGRVIgfHwgZGV0YWNoVHJhbnNmZXJhYmxlKSAmJiBmdW5jdGlvbiAoYXJyYXlCdWZmZXIsIG5ld0xlbmd0aCwgcHJlc2VydmVSZXNpemFiaWxpdHkpIHtcbiAgdmFyIGJ5dGVMZW5ndGggPSBhcnJheUJ1ZmZlckJ5dGVMZW5ndGgoYXJyYXlCdWZmZXIpO1xuICB2YXIgbmV3Qnl0ZUxlbmd0aCA9IG5ld0xlbmd0aCA9PT0gdW5kZWZpbmVkID8gYnl0ZUxlbmd0aCA6IHRvSW5kZXgobmV3TGVuZ3RoKTtcbiAgdmFyIGZpeGVkTGVuZ3RoID0gIWlzUmVzaXphYmxlIHx8ICFpc1Jlc2l6YWJsZShhcnJheUJ1ZmZlcik7XG4gIHZhciBuZXdCdWZmZXI7XG4gIG5vdERldGFjaGVkKGFycmF5QnVmZmVyKTtcbiAgaWYgKFBST1BFUl9TVFJVQ1RVUkVEX0NMT05FX1RSQU5TRkVSKSB7XG4gICAgYXJyYXlCdWZmZXIgPSBzdHJ1Y3R1cmVkQ2xvbmUoYXJyYXlCdWZmZXIsIHsgdHJhbnNmZXI6IFthcnJheUJ1ZmZlcl0gfSk7XG4gICAgaWYgKGJ5dGVMZW5ndGggPT09IG5ld0J5dGVMZW5ndGggJiYgKHByZXNlcnZlUmVzaXphYmlsaXR5IHx8IGZpeGVkTGVuZ3RoKSkgcmV0dXJuIGFycmF5QnVmZmVyO1xuICB9XG4gIGlmIChieXRlTGVuZ3RoID49IG5ld0J5dGVMZW5ndGggJiYgKCFwcmVzZXJ2ZVJlc2l6YWJpbGl0eSB8fCBmaXhlZExlbmd0aCkpIHtcbiAgICBuZXdCdWZmZXIgPSBzbGljZShhcnJheUJ1ZmZlciwgMCwgbmV3Qnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9wdGlvbnMgPSBwcmVzZXJ2ZVJlc2l6YWJpbGl0eSAmJiAhZml4ZWRMZW5ndGggJiYgbWF4Qnl0ZUxlbmd0aCA/IHsgbWF4Qnl0ZUxlbmd0aDogbWF4Qnl0ZUxlbmd0aChhcnJheUJ1ZmZlcikgfSA6IHVuZGVmaW5lZDtcbiAgICBuZXdCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobmV3Qnl0ZUxlbmd0aCwgb3B0aW9ucyk7XG4gICAgdmFyIGEgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgIHZhciBiID0gbmV3IERhdGFWaWV3KG5ld0J1ZmZlcik7XG4gICAgdmFyIGNvcHlMZW5ndGggPSBtaW4obmV3Qnl0ZUxlbmd0aCwgYnl0ZUxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3B5TGVuZ3RoOyBpKyspIHNldEludDgoYiwgaSwgZ2V0SW50OChhLCBpKSk7XG4gIH1cbiAgaWYgKCFQUk9QRVJfU1RSVUNUVVJFRF9DTE9ORV9UUkFOU0ZFUikgZGV0YWNoVHJhbnNmZXJhYmxlKGFycmF5QnVmZmVyKTtcbiAgcmV0dXJuIG5ld0J1ZmZlcjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU3NDU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjI5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlIHx8IHt9KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU3ODE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzc1MSk7XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4MTIpO1xudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTUpO1xudmFyIFVTRV9OQVRJVkVfVVJMID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDE2KTtcblxudmFyIFVSTCA9IGdldEJ1aWx0SW4oJ1VSTCcpO1xuXG4vLyBgVVJMLnBhcnNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1jYW5wYXJzZVxuJCh7IHRhcmdldDogJ1VSTCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIVVTRV9OQVRJVkVfVVJMIH0sIHtcbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHVybCkge1xuICAgIHZhciBsZW5ndGggPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgdXJsU3RyaW5nID0gdG9TdHJpbmcodXJsKTtcbiAgICB2YXIgYmFzZSA9IGxlbmd0aCA8IDIgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0b1N0cmluZyhhcmd1bWVudHNbMV0pO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IFVSTCh1cmxTdHJpbmcsIGJhc2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1ODU0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjc3Nyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgVG9CaWdJbnRgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2JpZ2ludFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIHByaW0gPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ251bWJlcicpO1xuICBpZiAodHlwZW9mIHByaW0gPT0gJ251bWJlcicpIHRocm93IG5ldyAkVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBudW1iZXIgdG8gYmlnaW50XCIpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYmlnaW50IC0tIHNhZmVcbiAgcmV0dXJuIEJpZ0ludChwcmltKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU4NzY6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgaXNTdWJzZXRPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMzgzOCk7XG52YXIgc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkxNik7XG5cbnZhciBJTkNPUlJFQ1QgPSAhc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSgnaXNTdWJzZXRPZicsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG4vLyBgU2V0LnByb3RvdHlwZS5pc1N1YnNldE9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5pc3N1YnNldG9mXG4kKHsgdGFyZ2V0OiAnU2V0JywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUIH0sIHtcbiAgaXNTdWJzZXRPZjogaXNTdWJzZXRPZlxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU5MTc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzI0KTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oOTAzOSk7XG52YXIgY3JlYXRlRWxlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDA1NSk7XG5cbi8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPT0gNztcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1OTY2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMDYpO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTE3KTtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoViwgUCkge1xuICB2YXIgZnVuYyA9IFZbUF07XG4gIHJldHVybiBpc051bGxPclVuZGVmaW5lZChmdW5jKSA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZShmdW5jKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDYwNDM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMwNik7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IG5ldyAkVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhQ2FsbGFibGUocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUNhbGxhYmxlKHJlamVjdCk7XG59O1xuXG4vLyBgTmV3UHJvbWlzZUNhcGFiaWxpdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1uZXdwcm9taXNlY2FwYWJpbGl0eVxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MDgwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNzQ3Nik7XG52YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzA2KTtcbnZhciBOQVRJVkVfQklORCA9IF9fd2VicGFja19yZXF1aXJlX18oNjE2KTtcblxudmFyIGJpbmQgPSB1bmN1cnJ5VGhpcyh1bmN1cnJ5VGhpcy5iaW5kKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCkge1xuICBhQ2FsbGFibGUoZm4pO1xuICByZXR1cm4gdGhhdCA9PT0gdW5kZWZpbmVkID8gZm4gOiBOQVRJVkVfQklORCA/IGJpbmQoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDYxMTk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTc0NSk7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzkyKTtcblxudmFyIGtleXMgPSBzaGFyZWQoJ2tleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDYxOTM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIEVOVklST05NRU5UID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjE1KTtcblxubW9kdWxlLmV4cG9ydHMgPSBFTlZJUk9OTUVOVCA9PT0gJ05PREUnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MTk4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oODAxNCk7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjI2OTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjI3OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZGVmaW5lQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNjg0MCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIGRlZmluZUJ1aWx0SW4odGFyZ2V0LCBrZXksIHNyY1trZXldLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDYzMTk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTM5KTtcblxuLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgRU5UUklFUykge1xuICB0cnkge1xuICAgIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2Mzk1OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NTE4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg3MzQ3KS5mKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2OTkpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NDApO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NDMzKTtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NzQwKTtcbnZhciBpc0ZvcmNlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjc5Nik7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAgICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMuZG9udENhbGxHZXRTZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxUaGlzO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbFRoaXNbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxUaGlzW1RBUkdFVF0gJiYgZ2xvYmFsVGhpc1tUQVJHRVRdLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmluZUJ1aWx0SW4odGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjU3Mzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTA2KTtcbnZhciBpc0RldGFjaGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjM4KTtcblxudmFyIEFycmF5QnVmZmVyUHJvdG90eXBlID0gQXJyYXlCdWZmZXIucHJvdG90eXBlO1xuXG4vLyBgQXJyYXlCdWZmZXIucHJvdG90eXBlLmRldGFjaGVkYCBnZXR0ZXJcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LWFycmF5YnVmZmVyLnByb3RvdHlwZS5kZXRhY2hlZFxuaWYgKERFU0NSSVBUT1JTICYmICEoJ2RldGFjaGVkJyBpbiBBcnJheUJ1ZmZlclByb3RvdHlwZSkpIHtcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKEFycmF5QnVmZmVyUHJvdG90eXBlLCAnZGV0YWNoZWQnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZGV0YWNoZWQoKSB7XG4gICAgICByZXR1cm4gaXNEZXRhY2hlZCh0aGlzKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NjMyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyICRmcm9tQmFzZTY0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTQzKTtcbnZhciBhblVpbnQ4QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNTQpO1xuXG52YXIgVWludDhBcnJheSA9IGdsb2JhbFRoaXMuVWludDhBcnJheTtcblxudmFyIElOQ09SUkVDVF9CRUhBVklPUl9PUl9ET0VTTlRfRVhJU1RTID0gIVVpbnQ4QXJyYXkgfHwgIVVpbnQ4QXJyYXkucHJvdG90eXBlLnNldEZyb21CYXNlNjQgfHwgIWZ1bmN0aW9uICgpIHtcbiAgdmFyIHRhcmdldCA9IG5ldyBVaW50OEFycmF5KFsyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NV0pO1xuICB0cnkge1xuICAgIHRhcmdldC5zZXRGcm9tQmFzZTY0KCcnLCBudWxsKTtcbiAgICByZXR1cm47XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgLy8gV2Via2l0IG5vdCB0aHJvdyBhbiBlcnJvciBvbiBvZGQgbGVuZ3RoIHN0cmluZ1xuICB0cnkge1xuICAgIHRhcmdldC5zZXRGcm9tQmFzZTY0KCdhJyk7XG4gICAgcmV0dXJuO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHRyeSB7XG4gICAgdGFyZ2V0LnNldEZyb21CYXNlNjQoJ01qWXlaZz09PScpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0YXJnZXRbMF0gPT09IDUwICYmIHRhcmdldFsxXSA9PT0gNTQgJiYgdGFyZ2V0WzJdID09PSA1MCAmJiB0YXJnZXRbM10gPT09IDI1NSAmJiB0YXJnZXRbNF0gPT09IDI1NTtcbiAgfVxufSgpO1xuXG4vLyBgVWludDhBcnJheS5wcm90b3R5cGUuc2V0RnJvbUJhc2U2NGAgbWV0aG9kXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hcnJheWJ1ZmZlci1iYXNlNjRcbmlmIChVaW50OEFycmF5KSAkKHsgdGFyZ2V0OiAnVWludDhBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVF9CRUhBVklPUl9PUl9ET0VTTlRfRVhJU1RTIH0sIHtcbiAgc2V0RnJvbUJhc2U2NDogZnVuY3Rpb24gc2V0RnJvbUJhc2U2NChzdHJpbmcgLyogLCBvcHRpb25zICovKSB7XG4gICAgYW5VaW50OEFycmF5KHRoaXMpO1xuXG4gICAgdmFyIHJlc3VsdCA9ICRmcm9tQmFzZTY0KHN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoaXMsIHRoaXMubGVuZ3RoKTtcblxuICAgIHJldHVybiB7IHJlYWQ6IHJlc3VsdC5yZWFkLCB3cml0dGVuOiByZXN1bHQud3JpdHRlbiB9O1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjY5OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MjQpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTEzKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5ODApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjcwNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMwNik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCBtZXRob2QpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gICAgcmV0dXJuIHVuY3VycnlUaGlzKGFDYWxsYWJsZShPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwga2V5KVttZXRob2RdKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY4MDE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzI0KTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IF9fd2VicGFja19yZXF1aXJlX18oODY4Nik7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MTMpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzOTcpO1xudmFyIG9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNzIpO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTICYmICFWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIgcHJvcHMgPSB0b0luZGV4ZWRPYmplY3QoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgcHJvcHNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjgyMzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjgzNzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID4gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgJFR5cGVFcnJvcignTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY4NDA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MDEpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTEzKTtcbnZhciBtYWtlQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjgzKTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oOTQzMyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIGlmIChpc0NhbGxhYmxlKHZhbHVlKSkgbWFrZUJ1aWx0SW4odmFsdWUsIG5hbWUsIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5nbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZUdsb2JhbFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMudW5zYWZlKSBkZWxldGUgT1trZXldO1xuICAgICAgZWxzZSBpZiAoT1trZXldKSBzaW1wbGUgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH0gcmV0dXJuIE87XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2OTU1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNDApO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MDEpO1xudmFyIGNsYXNzb2ZSYXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOTUpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oODIyNyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gJE9iamVjdChpdCksIFRPX1NUUklOR19UQUcpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlKE8uY2FsbGVlKSA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjk2OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3NzcpO1xudmFyIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTcpO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjk4MDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzA0MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBOQVRJVkVfU1lNQk9MID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDk1KTtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfU1lNQk9MICYmXG4gICFTeW1ib2wuc2hhbSAmJlxuICB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MDU1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzkpO1xudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOTUpO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzKCcnLnNwbGl0KTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3Ncbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gISRPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mKGl0KSA9PT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogJE9iamVjdChpdCk7XG59IDogJE9iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzA4MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaGFzID0gKF9fd2VicGFja19yZXF1aXJlX18oNDQwMikuaGFzKTtcblxuLy8gUGVyZm9ybSA/IFJlcXVpcmVJbnRlcm5hbFNsb3QoTSwgW1tTZXREYXRhXV0pXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBoYXMoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MzQ3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3NzMpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjk4MCk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mzk3KTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTY5KTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOTcpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTE3KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093bihPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighY2FsbChwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLCBPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3Mzk0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciB1bmN1cnJ5VGhpc0FjY2Vzc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzA2KTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTk1KTtcblxudmFyIEFycmF5QnVmZmVyID0gZ2xvYmFsVGhpcy5BcnJheUJ1ZmZlcjtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWxUaGlzLlR5cGVFcnJvcjtcblxuLy8gSW5jbHVkZXNcbi8vIC0gUGVyZm9ybSA/IFJlcXVpcmVJbnRlcm5hbFNsb3QoTywgW1tBcnJheUJ1ZmZlckRhdGFdXSkuXG4vLyAtIElmIElzU2hhcmVkQXJyYXlCdWZmZXIoTykgaXMgdHJ1ZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxubW9kdWxlLmV4cG9ydHMgPSBBcnJheUJ1ZmZlciAmJiB1bmN1cnJ5VGhpc0FjY2Vzc29yKEFycmF5QnVmZmVyLnByb3RvdHlwZSwgJ2J5dGVMZW5ndGgnLCAnZ2V0JykgfHwgZnVuY3Rpb24gKE8pIHtcbiAgaWYgKGNsYXNzb2YoTykgIT09ICdBcnJheUJ1ZmZlcicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5QnVmZmVyIGV4cGVjdGVkJyk7XG4gIHJldHVybiBPLmJ5dGVMZW5ndGg7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NDE2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oOTAzOSk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MjI3KTtcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oNjM5NSk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9yZWxhdGl2ZS11cmwtc3R5bGUgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgdmFyIHVybCA9IG5ldyBVUkwoJ2I/YT0xJmI9MiZjPTMnLCAnaHR0cHM6Ly9hJyk7XG4gIHZhciBwYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICB2YXIgcGFyYW1zMiA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoJ2E9MSZhPTImYj0zJyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdXJsLnBhdGhuYW1lID0gJ2MlMjBkJztcbiAgcGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICBwYXJhbXNbJ2RlbGV0ZSddKCdiJyk7XG4gICAgcmVzdWx0ICs9IGtleSArIHZhbHVlO1xuICB9KTtcbiAgcGFyYW1zMlsnZGVsZXRlJ10oJ2EnLCAyKTtcbiAgLy8gYHVuZGVmaW5lZGAgY2FzZSBpcyBhIENocm9taXVtIDExNyBidWdcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MTQyMjJcbiAgcGFyYW1zMlsnZGVsZXRlJ10oJ2InLCB1bmRlZmluZWQpO1xuICByZXR1cm4gKElTX1BVUkUgJiYgKCF1cmwudG9KU09OIHx8ICFwYXJhbXMyLmhhcygnYScsIDEpIHx8IHBhcmFtczIuaGFzKCdhJywgMikgfHwgIXBhcmFtczIuaGFzKCdhJywgdW5kZWZpbmVkKSB8fCBwYXJhbXMyLmhhcygnYicpKSlcbiAgICB8fCAoIXBhcmFtcy5zaXplICYmIChJU19QVVJFIHx8ICFERVNDUklQVE9SUykpXG4gICAgfHwgIXBhcmFtcy5zb3J0XG4gICAgfHwgdXJsLmhyZWYgIT09ICdodHRwczovL2EvYyUyMGQ/YT0xJmM9MydcbiAgICB8fCBwYXJhbXMuZ2V0KCdjJykgIT09ICczJ1xuICAgIHx8IFN0cmluZyhuZXcgVVJMU2VhcmNoUGFyYW1zKCc/YT0xJykpICE9PSAnYT0xJ1xuICAgIHx8ICFwYXJhbXNbSVRFUkFUT1JdXG4gICAgLy8gdGhyb3dzIGluIEVkZ2VcbiAgICB8fCBuZXcgVVJMKCdodHRwczovL2FAYicpLnVzZXJuYW1lICE9PSAnYSdcbiAgICB8fCBuZXcgVVJMU2VhcmNoUGFyYW1zKG5ldyBVUkxTZWFyY2hQYXJhbXMoJ2E9YicpKS5nZXQoJ2EnKSAhPT0gJ2InXG4gICAgLy8gbm90IHB1bnljb2RlZCBpbiBFZGdlXG4gICAgfHwgbmV3IFVSTCgnaHR0cHM6Ly/RgtC10YHRgicpLmhvc3QgIT09ICd4bi0tZTFheWJjJ1xuICAgIC8vIG5vdCBlc2NhcGVkIGluIENocm9tZSA2Mi1cbiAgICB8fCBuZXcgVVJMKCdodHRwczovL2Ej0LEnKS5oYXNoICE9PSAnIyVEMCVCMSdcbiAgICAvLyBmYWlscyBpbiBDaHJvbWUgNjYtXG4gICAgfHwgcmVzdWx0ICE9PSAnYTFjMydcbiAgICAvLyB0aHJvd3MgaW4gU2FmYXJpXG4gICAgfHwgbmV3IFVSTCgnaHR0cHM6Ly94JywgdW5kZWZpbmVkKS5ob3N0ICE9PSAneCc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzQ3Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2xhc3NvZlJhdyA9IF9fd2VicGFja19yZXF1aXJlX18oMjE5NSk7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbikge1xuICAvLyBOYXNob3JuIGJ1ZzpcbiAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTEyOFxuICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xMTMwXG4gIGlmIChjbGFzc29mUmF3KGZuKSA9PT0gJ0Z1bmN0aW9uJykgcmV0dXJuIHVuY3VycnlUaGlzKGZuKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc1NjY6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZGVmaW5lQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNjg0MCk7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTUpO1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyODEyKTtcblxudmFyICRVUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXM7XG52YXIgVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlID0gJFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGU7XG52YXIgZ2V0QWxsID0gdW5jdXJyeVRoaXMoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLmdldEFsbCk7XG52YXIgJGhhcyA9IHVuY3VycnlUaGlzKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5oYXMpO1xudmFyIHBhcmFtcyA9IG5ldyAkVVJMU2VhcmNoUGFyYW1zKCdhPTEnKTtcblxuLy8gYHVuZGVmaW5lZGAgY2FzZSBpcyBhIENocm9taXVtIDExNyBidWdcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTE0MjIyXG5pZiAocGFyYW1zLmhhcygnYScsIDIpIHx8ICFwYXJhbXMuaGFzKCdhJywgdW5kZWZpbmVkKSkge1xuICBkZWZpbmVCdWlsdEluKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgJ2hhcycsIGZ1bmN0aW9uIGhhcyhuYW1lIC8qICwgdmFsdWUgKi8pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgJHZhbHVlID0gbGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAobGVuZ3RoICYmICR2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJGhhcyh0aGlzLCBuYW1lKTtcbiAgICB2YXIgdmFsdWVzID0gZ2V0QWxsKHRoaXMsIG5hbWUpOyAvLyBhbHNvIHZhbGlkYXRlcyBgdGhpc2BcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChsZW5ndGgsIDEpO1xuICAgIHZhciB2YWx1ZSA9IHRvU3RyaW5nKCR2YWx1ZSk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICBpZiAodmFsdWVzW2luZGV4KytdID09PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgfSByZXR1cm4gZmFsc2U7XG4gIH0sIHsgZW51bWVyYWJsZTogdHJ1ZSwgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NTg4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2NTIpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMwNik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzY3KTtcbnZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTM5KTtcbnZhciBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTQ5KTtcblxudmFyIGZvckVhY2hXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IoJ2ZvckVhY2gnLCBUeXBlRXJyb3IpO1xuXG4vLyBgSXRlcmF0b3IucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pdGVyYXRvci5wcm90b3R5cGUuZm9yZWFjaFxuJCh7IHRhcmdldDogJ0l0ZXJhdG9yJywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogZm9yRWFjaFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIH0sIHtcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICAgIGFuT2JqZWN0KHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBhQ2FsbGFibGUoZm4pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKHRoaXMsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoZm9yRWFjaFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKSByZXR1cm4gY2FsbChmb3JFYWNoV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IsIHRoaXMsIGZuKTtcblxuICAgIHZhciByZWNvcmQgPSBnZXRJdGVyYXRvckRpcmVjdCh0aGlzKTtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgaXRlcmF0ZShyZWNvcmQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgZm4odmFsdWUsIGNvdW50ZXIrKyk7XG4gICAgfSwgeyBJU19SRUNPUkQ6IHRydWUgfSk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NjI5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mzk1KTtcbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oOTQzMyk7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsVGhpc1tTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFNIQVJFRCwge30pO1xuXG4oc3RvcmUudmVyc2lvbnMgfHwgKHN0b3JlLnZlcnNpb25zID0gW10pKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuNDUuMScsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxNC0yMDI1IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJyxcbiAgbGljZW5zZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuNDUuMS9MSUNFTlNFJyxcbiAgc291cmNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMnXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzY0Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBkaWZmZXJlbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDQwKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oOTAzOSk7XG52YXIgc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkxNik7XG5cbnZhciBTRVRfTElLRV9JTkNPUlJFQ1RfQkVIQVZJT1IgPSAhc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSgnZGlmZmVyZW5jZScsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC5zaXplID09PSAwO1xufSk7XG5cbnZhciBGT1JDRUQgPSBTRVRfTElLRV9JTkNPUlJFQ1RfQkVIQVZJT1IgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Mjg4NTk1XG4gIHZhciBzZXRMaWtlID0ge1xuICAgIHNpemU6IDEsXG4gICAgaGFzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgIGtleXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGRvbmUgPSBpbmRleCsrID4gMTtcbiAgICAgICAgICBpZiAoYmFzZVNldC5oYXMoMSkpIGJhc2VTZXQuY2xlYXIoKTtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiBkb25lLCB2YWx1ZTogMiB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXNldCAtLSB0ZXN0aW5nXG4gIHZhciBiYXNlU2V0ID0gbmV3IFNldChbMSwgMiwgMywgNF0pO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tc2V0LXByb3RvdHlwZS1kaWZmZXJlbmNlIC0tIHRlc3RpbmdcbiAgcmV0dXJuIGJhc2VTZXQuZGlmZmVyZW5jZShzZXRMaWtlKS5zaXplICE9PSAzO1xufSk7XG5cbi8vIGBTZXQucHJvdG90eXBlLmRpZmZlcmVuY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmRpZmZlcmVuY2VcbiQoeyB0YXJnZXQ6ICdTZXQnLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBkaWZmZXJlbmNlOiBkaWZmZXJlbmNlXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzY1Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzkpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MDEpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzYwKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMjc4Nyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNjg0MCk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MjI3KTtcbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mzk1KTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBmYWxzZTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihnZXRQcm90b3R5cGVPZihhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSAhaXNPYmplY3QoSXRlcmF0b3JQcm90b3R5cGUpIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbn0pO1xuXG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbmVsc2UgaWYgKElTX1BVUkUpIEl0ZXJhdG9yUHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuaWYgKCFpc0NhbGxhYmxlKEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSkpIHtcbiAgZGVmaW5lQnVpbHRJbihJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlNcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc2ODA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmN1cnJ5VGhpcyhbXS5zbGljZSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc2OTY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyOTEpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDE0KTtcblxudmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcblxuLy8gYFRvSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXJPckluZmluaXR5KGl0KTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKG51bWJlcik7XG4gIGlmIChudW1iZXIgIT09IGxlbmd0aCkgdGhyb3cgbmV3ICRSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGggb3IgaW5kZXgnKTtcbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc3NDA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5Nyk7XG52YXIgb3duS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTAzMSk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MzQ3KTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkxMyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzT3duKHRhcmdldCwga2V5KSAmJiAhKGV4Y2VwdGlvbnMgJiYgaGFzT3duKGV4Y2VwdGlvbnMsIGtleSkpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NzUwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBpc051bGxPclVuZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDExNyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc051bGxPclVuZGVmaW5lZChpdCkpIHRocm93IG5ldyAkVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc3NTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MDEpO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKGdsb2JhbFRoaXNbbmFtZXNwYWNlXSkgOiBnbG9iYWxUaGlzW25hbWVzcGFjZV0gJiYgZ2xvYmFsVGhpc1tuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3ODExOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tdHlwZWQtYXJyYXlzIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIEFycmF5QnVmZmVyICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBEYXRhVmlldyAhPSAndW5kZWZpbmVkJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzkzNjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciAkdHJhbnNmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2MzYpO1xuXG4vLyBgQXJyYXlCdWZmZXIucHJvdG90eXBlLnRyYW5zZmVyVG9GaXhlZExlbmd0aGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5YnVmZmVyLnByb3RvdHlwZS50cmFuc2ZlcnRvZml4ZWRsZW5ndGhcbmlmICgkdHJhbnNmZXIpICQoeyB0YXJnZXQ6ICdBcnJheUJ1ZmZlcicsIHByb3RvOiB0cnVlIH0sIHtcbiAgdHJhbnNmZXJUb0ZpeGVkTGVuZ3RoOiBmdW5jdGlvbiB0cmFuc2ZlclRvRml4ZWRMZW5ndGgoKSB7XG4gICAgcmV0dXJuICR0cmFuc2Zlcih0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MDA0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcbnZhciBpbnRlcnNlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3NTApO1xudmFyIHNldE1ldGhvZEFjY2VwdFNldExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MTYpO1xuXG52YXIgSU5DT1JSRUNUID0gIXNldE1ldGhvZEFjY2VwdFNldExpa2UoJ2ludGVyc2VjdGlvbicsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC5zaXplID09PSAyICYmIHJlc3VsdC5oYXMoMSkgJiYgcmVzdWx0LmhhcygyKTtcbn0pIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWZyb20sIGVzL25vLXNldCwgZXMvbm8tc2V0LXByb3RvdHlwZS1pbnRlcnNlY3Rpb24gLS0gdGVzdGluZ1xuICByZXR1cm4gU3RyaW5nKEFycmF5LmZyb20obmV3IFNldChbMSwgMiwgM10pLmludGVyc2VjdGlvbihuZXcgU2V0KFszLCAyXSkpKSkgIT09ICczLDInO1xufSk7XG5cbi8vIGBTZXQucHJvdG90eXBlLmludGVyc2VjdGlvbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuaW50ZXJzZWN0aW9uXG4kKHsgdGFyZ2V0OiAnU2V0JywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUIH0sIHtcbiAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb25cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MDE0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjkxKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGxlbiA9IHRvSW50ZWdlck9ySW5maW5pdHkoYXJndW1lbnQpO1xuICByZXR1cm4gbGVuID4gMCA/IG1pbihsZW4sIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODEwMDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciAkdHJhbnNmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2MzYpO1xuXG4vLyBgQXJyYXlCdWZmZXIucHJvdG90eXBlLnRyYW5zZmVyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlidWZmZXIucHJvdG90eXBlLnRyYW5zZmVyXG5pZiAoJHRyYW5zZmVyKSAkKHsgdGFyZ2V0OiAnQXJyYXlCdWZmZXInLCBwcm90bzogdHJ1ZSB9LCB7XG4gIHRyYW5zZmVyOiBmdW5jdGlvbiB0cmFuc2ZlcigpIHtcbiAgICByZXR1cm4gJHRyYW5zZmVyKHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQsIHRydWUpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODExMTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBnbG9iYWxUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTc2KTtcbnZhciBhbkluc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzkpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMjc4Nyk7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTA2KTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNDY1OSk7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzkpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5Nyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MjI3KTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NTcpLkl0ZXJhdG9yUHJvdG90eXBlKTtcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oNjM5NSk7XG5cbnZhciBDT05TVFJVQ1RPUiA9ICdjb25zdHJ1Y3Rvcic7XG52YXIgSVRFUkFUT1IgPSAnSXRlcmF0b3InO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIE5hdGl2ZUl0ZXJhdG9yID0gZ2xvYmFsVGhpc1tJVEVSQVRPUl07XG5cbi8vIEZGNTYtIGhhdmUgbm9uLXN0YW5kYXJkIGdsb2JhbCBoZWxwZXIgYEl0ZXJhdG9yYFxudmFyIEZPUkNFRCA9IElTX1BVUkVcbiAgfHwgIWlzQ2FsbGFibGUoTmF0aXZlSXRlcmF0b3IpXG4gIHx8IE5hdGl2ZUl0ZXJhdG9yLnByb3RvdHlwZSAhPT0gSXRlcmF0b3JQcm90b3R5cGVcbiAgLy8gRkY0NC0gbm9uLXN0YW5kYXJkIGBJdGVyYXRvcmAgcGFzc2VzIHByZXZpb3VzIHRlc3RzXG4gIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7IE5hdGl2ZUl0ZXJhdG9yKHt9KTsgfSk7XG5cbnZhciBJdGVyYXRvckNvbnN0cnVjdG9yID0gZnVuY3Rpb24gSXRlcmF0b3IoKSB7XG4gIGFuSW5zdGFuY2UodGhpcywgSXRlcmF0b3JQcm90b3R5cGUpO1xuICBpZiAoZ2V0UHJvdG90eXBlT2YodGhpcykgPT09IEl0ZXJhdG9yUHJvdG90eXBlKSB0aHJvdyBuZXcgJFR5cGVFcnJvcignQWJzdHJhY3QgY2xhc3MgSXRlcmF0b3Igbm90IGRpcmVjdGx5IGNvbnN0cnVjdGFibGUnKTtcbn07XG5cbnZhciBkZWZpbmVJdGVyYXRvclByb3RvdHlwZUFjY2Vzc29yID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKEl0ZXJhdG9yUHJvdG90eXBlLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgYW5PYmplY3QodGhpcyk7XG4gICAgICAgIGlmICh0aGlzID09PSBJdGVyYXRvclByb3RvdHlwZSkgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJZb3UgY2FuJ3QgcmVkZWZpbmUgdGhpcyBwcm9wZXJ0eVwiKTtcbiAgICAgICAgaWYgKGhhc093bih0aGlzLCBrZXkpKSB0aGlzW2tleV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgZWxzZSBjcmVhdGVQcm9wZXJ0eSh0aGlzLCBrZXksIHJlcGxhY2VtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIEl0ZXJhdG9yUHJvdG90eXBlW2tleV0gPSB2YWx1ZTtcbn07XG5cbmlmICghaGFzT3duKEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkgZGVmaW5lSXRlcmF0b3JQcm90b3R5cGVBY2Nlc3NvcihUT19TVFJJTkdfVEFHLCBJVEVSQVRPUik7XG5cbmlmIChGT1JDRUQgfHwgIWhhc093bihJdGVyYXRvclByb3RvdHlwZSwgQ09OU1RSVUNUT1IpIHx8IEl0ZXJhdG9yUHJvdG90eXBlW0NPTlNUUlVDVE9SXSA9PT0gT2JqZWN0KSB7XG4gIGRlZmluZUl0ZXJhdG9yUHJvdG90eXBlQWNjZXNzb3IoQ09OU1RSVUNUT1IsIEl0ZXJhdG9yQ29uc3RydWN0b3IpO1xufVxuXG5JdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IEl0ZXJhdG9yUHJvdG90eXBlO1xuXG4vLyBgSXRlcmF0b3JgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yXG4kKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBJdGVyYXRvcjogSXRlcmF0b3JDb25zdHJ1Y3RvclxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgyMjc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTc0NSk7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mjk3KTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzOTIpO1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0OTUpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDQwKTtcblxudmFyIFN5bWJvbCA9IGdsb2JhbFRoaXMuU3ltYm9sO1xudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2xbJ2ZvciddIHx8IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24oV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSkge1xuICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IE5BVElWRV9TWU1CT0wgJiYgaGFzT3duKFN5bWJvbCwgbmFtZSlcbiAgICAgID8gU3ltYm9sW25hbWVdXG4gICAgICA6IGNyZWF0ZVdlbGxLbm93blN5bWJvbCgnU3ltYm9sLicgKyBuYW1lKTtcbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODIzNTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5Nyk7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbnZhciAkcGFyc2VJbnQgPSBwYXJzZUludDtcbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyIGF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcbnZhciBzbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcbnZhciBleGVjID0gdW5jdXJyeVRoaXMoLy4vLmV4ZWMpO1xuXG52YXIgY29kZVBvaW50cyA9IHtcbiAgJ1xcXFxcIic6ICdcIicsXG4gICdcXFxcXFxcXCc6ICdcXFxcJyxcbiAgJ1xcXFwvJzogJy8nLFxuICAnXFxcXGInOiAnXFxiJyxcbiAgJ1xcXFxmJzogJ1xcZicsXG4gICdcXFxcbic6ICdcXG4nLFxuICAnXFxcXHInOiAnXFxyJyxcbiAgJ1xcXFx0JzogJ1xcdCdcbn07XG5cbnZhciBJU180X0hFWF9ESUdJVFMgPSAvXltcXGRhLWZdezR9JC9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1jb250cm9sLWNoYXJhY3RlciAtLSBzYWZlXG52YXIgSVNfQzBfQ09OVFJPTF9DT0RFID0gL15bXFx1MDAwMC1cXHUwMDFGXSQvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzb3VyY2UsIGkpIHtcbiAgdmFyIHVudGVybWluYXRlZCA9IHRydWU7XG4gIHZhciB2YWx1ZSA9ICcnO1xuICB3aGlsZSAoaSA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICB2YXIgY2hyID0gYXQoc291cmNlLCBpKTtcbiAgICBpZiAoY2hyID09PSAnXFxcXCcpIHtcbiAgICAgIHZhciB0d29DaGFycyA9IHNsaWNlKHNvdXJjZSwgaSwgaSArIDIpO1xuICAgICAgaWYgKGhhc093bihjb2RlUG9pbnRzLCB0d29DaGFycykpIHtcbiAgICAgICAgdmFsdWUgKz0gY29kZVBvaW50c1t0d29DaGFyc107XG4gICAgICAgIGkgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAodHdvQ2hhcnMgPT09ICdcXFxcdScpIHtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICB2YXIgZm91ckhleERpZ2l0cyA9IHNsaWNlKHNvdXJjZSwgaSwgaSArIDQpO1xuICAgICAgICBpZiAoIWV4ZWMoSVNfNF9IRVhfRElHSVRTLCBmb3VySGV4RGlnaXRzKSkgdGhyb3cgbmV3ICRTeW50YXhFcnJvcignQmFkIFVuaWNvZGUgZXNjYXBlIGF0OiAnICsgaSk7XG4gICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZSgkcGFyc2VJbnQoZm91ckhleERpZ2l0cywgMTYpKTtcbiAgICAgICAgaSArPSA0O1xuICAgICAgfSBlbHNlIHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ1Vua25vd24gZXNjYXBlIHNlcXVlbmNlOiBcIicgKyB0d29DaGFycyArICdcIicpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAnXCInKSB7XG4gICAgICB1bnRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgIGkrKztcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXhlYyhJU19DMF9DT05UUk9MX0NPREUsIGNocikpIHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ0JhZCBjb250cm9sIGNoYXJhY3RlciBpbiBzdHJpbmcgbGl0ZXJhbCBhdDogJyArIGkpO1xuICAgICAgdmFsdWUgKz0gY2hyO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuICBpZiAodW50ZXJtaW5hdGVkKSB0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdVbnRlcm1pbmF0ZWQgc3RyaW5nIGF0OiAnICsgaSk7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZW5kOiBpIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MjM3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1MTgpO1xudmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2NTIpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMwNik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzY3KTtcbnZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTM5KTtcbnZhciBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTQ5KTtcbnZhciBhcHBseSA9IF9fd2VicGFja19yZXF1aXJlX18oODc0NSk7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzkpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MTY1MVxudmFyIEZBSUxTX09OX0lOSVRJQUxfVU5ERUZJTkVEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8taXRlcmF0b3ItcHJvdG90eXBlLXJlZHVjZSwgZXMvbm8tYXJyYXktcHJvdG90eXBlLWtleXMsIGFycmF5LWNhbGxiYWNrLXJldHVybiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBbXS5rZXlzKCkucmVkdWNlKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgdW5kZWZpbmVkKTtcbn0pO1xuXG52YXIgcmVkdWNlV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSAhRkFJTFNfT05fSU5JVElBTF9VTkRFRklORUQgJiYgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcigncmVkdWNlJywgJFR5cGVFcnJvcik7XG5cbi8vIGBJdGVyYXRvci5wcm90b3R5cGUucmVkdWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXRlcmF0b3IucHJvdG90eXBlLnJlZHVjZVxuJCh7IHRhcmdldDogJ0l0ZXJhdG9yJywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fSU5JVElBTF9VTkRFRklORUQgfHwgcmVkdWNlV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgfSwge1xuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShyZWR1Y2VyIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgYW5PYmplY3QodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGFDYWxsYWJsZShyZWR1Y2VyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZSh0aGlzLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuXG4gICAgdmFyIG5vSW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPCAyO1xuICAgIHZhciBhY2N1bXVsYXRvciA9IG5vSW5pdGlhbCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAocmVkdWNlV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IpIHtcbiAgICAgIHJldHVybiBhcHBseShyZWR1Y2VXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciwgdGhpcywgbm9Jbml0aWFsID8gW3JlZHVjZXJdIDogW3JlZHVjZXIsIGFjY3VtdWxhdG9yXSk7XG4gICAgfVxuICAgIHZhciByZWNvcmQgPSBnZXRJdGVyYXRvckRpcmVjdCh0aGlzKTtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgaXRlcmF0ZShyZWNvcmQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKG5vSW5pdGlhbCkge1xuICAgICAgICBub0luaXRpYWwgPSBmYWxzZTtcbiAgICAgICAgYWNjdW11bGF0b3IgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gcmVkdWNlcihhY2N1bXVsYXRvciwgdmFsdWUsIGNvdW50ZXIpO1xuICAgICAgfVxuICAgICAgY291bnRlcisrO1xuICAgIH0sIHsgSVNfUkVDT1JEOiB0cnVlIH0pO1xuICAgIGlmIChub0luaXRpYWwpIHRocm93IG5ldyAkVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgaXRlcmF0b3Igd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODMzNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTE4KTtcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzc1MSk7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MDEpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNDM3Nik7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mjk3KTtcbnZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNjU1KTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjE5OCk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2NTkpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM5KTtcbnZhciBwYXJzZUpTT05TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyMzUpO1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0OTUpO1xuXG52YXIgSlNPTiA9IGdsb2JhbFRoaXMuSlNPTjtcbnZhciBOdW1iZXIgPSBnbG9iYWxUaGlzLk51bWJlcjtcbnZhciBTeW50YXhFcnJvciA9IGdsb2JhbFRoaXMuU3ludGF4RXJyb3I7XG52YXIgbmF0aXZlUGFyc2UgPSBKU09OICYmIEpTT04ucGFyc2U7XG52YXIgZW51bWVyYWJsZU93blByb3BlcnRpZXMgPSBnZXRCdWlsdEluKCdPYmplY3QnLCAna2V5cycpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgYXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQXQpO1xudmFyIHNsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcygvLi8uZXhlYyk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xuXG52YXIgSVNfRElHSVQgPSAvXlxcZCQvO1xudmFyIElTX05PTl9aRVJPX0RJR0lUID0gL15bMS05XSQvO1xudmFyIElTX05VTUJFUl9TVEFSVCA9IC9eW1xcZC1dJC87XG52YXIgSVNfV0hJVEVTUEFDRSA9IC9eW1xcdFxcblxcciBdJC87XG5cbnZhciBQUklNSVRJVkUgPSAwO1xudmFyIE9CSkVDVCA9IDE7XG5cbnZhciAkcGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCByZXZpdmVyKSB7XG4gIHNvdXJjZSA9IHRvU3RyaW5nKHNvdXJjZSk7XG4gIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQoc291cmNlLCAwLCAnJyk7XG4gIHZhciByb290ID0gY29udGV4dC5wYXJzZSgpO1xuICB2YXIgdmFsdWUgPSByb290LnZhbHVlO1xuICB2YXIgZW5kSW5kZXggPSBjb250ZXh0LnNraXAoSVNfV0hJVEVTUEFDRSwgcm9vdC5lbmQpO1xuICBpZiAoZW5kSW5kZXggPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGV4dHJhIGNoYXJhY3RlcjogXCInICsgYXQoc291cmNlLCBlbmRJbmRleCkgKyAnXCIgYWZ0ZXIgdGhlIHBhcnNlZCBkYXRhIGF0OiAnICsgZW5kSW5kZXgpO1xuICB9XG4gIHJldHVybiBpc0NhbGxhYmxlKHJldml2ZXIpID8gaW50ZXJuYWxpemUoeyAnJzogdmFsdWUgfSwgJycsIHJldml2ZXIsIHJvb3QpIDogdmFsdWU7XG59O1xuXG52YXIgaW50ZXJuYWxpemUgPSBmdW5jdGlvbiAoaG9sZGVyLCBuYW1lLCByZXZpdmVyLCBub2RlKSB7XG4gIHZhciB2YWwgPSBob2xkZXJbbmFtZV07XG4gIHZhciB1bm1vZGlmaWVkID0gbm9kZSAmJiB2YWwgPT09IG5vZGUudmFsdWU7XG4gIHZhciBjb250ZXh0ID0gdW5tb2RpZmllZCAmJiB0eXBlb2Ygbm9kZS5zb3VyY2UgPT0gJ3N0cmluZycgPyB7IHNvdXJjZTogbm9kZS5zb3VyY2UgfSA6IHt9O1xuICB2YXIgZWxlbWVudFJlY29yZHNMZW4sIGtleXMsIGxlbiwgaSwgUDtcbiAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICB2YXIgbm9kZUlzQXJyYXkgPSBpc0FycmF5KHZhbCk7XG4gICAgdmFyIG5vZGVzID0gdW5tb2RpZmllZCA/IG5vZGUubm9kZXMgOiBub2RlSXNBcnJheSA/IFtdIDoge307XG4gICAgaWYgKG5vZGVJc0FycmF5KSB7XG4gICAgICBlbGVtZW50UmVjb3Jkc0xlbiA9IG5vZGVzLmxlbmd0aDtcbiAgICAgIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKHZhbCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaW50ZXJuYWxpemVQcm9wZXJ0eSh2YWwsIGksIGludGVybmFsaXplKHZhbCwgJycgKyBpLCByZXZpdmVyLCBpIDwgZWxlbWVudFJlY29yZHNMZW4gPyBub2Rlc1tpXSA6IHVuZGVmaW5lZCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gZW51bWVyYWJsZU93blByb3BlcnRpZXModmFsKTtcbiAgICAgIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKGtleXMpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIFAgPSBrZXlzW2ldO1xuICAgICAgICBpbnRlcm5hbGl6ZVByb3BlcnR5KHZhbCwgUCwgaW50ZXJuYWxpemUodmFsLCBQLCByZXZpdmVyLCBoYXNPd24obm9kZXMsIFApID8gbm9kZXNbUF0gOiB1bmRlZmluZWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbGwocmV2aXZlciwgaG9sZGVyLCBuYW1lLCB2YWwsIGNvbnRleHQpO1xufTtcblxudmFyIGludGVybmFsaXplUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwga2V5KTtcbiAgICBpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGUpIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIG9iamVjdFtrZXldO1xuICBlbHNlIGNyZWF0ZVByb3BlcnR5KG9iamVjdCwga2V5LCB2YWx1ZSk7XG59O1xuXG52YXIgTm9kZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5kLCBzb3VyY2UsIG5vZGVzKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5lbmQgPSBlbmQ7XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLm5vZGVzID0gbm9kZXM7XG59O1xuXG52YXIgQ29udGV4dCA9IGZ1bmN0aW9uIChzb3VyY2UsIGluZGV4KSB7XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLmluZGV4ID0gaW5kZXg7XG59O1xuXG4vLyBodHRwczovL3d3dy5qc29uLm9yZy9qc29uLWVuLmh0bWxcbkNvbnRleHQucHJvdG90eXBlID0ge1xuICBmb3JrOiBmdW5jdGlvbiAobmV4dEluZGV4KSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZXh0KHRoaXMuc291cmNlLCBuZXh0SW5kZXgpO1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgaSA9IHRoaXMuc2tpcChJU19XSElURVNQQUNFLCB0aGlzLmluZGV4KTtcbiAgICB2YXIgZm9yayA9IHRoaXMuZm9yayhpKTtcbiAgICB2YXIgY2hyID0gYXQoc291cmNlLCBpKTtcbiAgICBpZiAoZXhlYyhJU19OVU1CRVJfU1RBUlQsIGNocikpIHJldHVybiBmb3JrLm51bWJlcigpO1xuICAgIHN3aXRjaCAoY2hyKSB7XG4gICAgICBjYXNlICd7JzpcbiAgICAgICAgcmV0dXJuIGZvcmsub2JqZWN0KCk7XG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgcmV0dXJuIGZvcmsuYXJyYXkoKTtcbiAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgcmV0dXJuIGZvcmsuc3RyaW5nKCk7XG4gICAgICBjYXNlICd0JzpcbiAgICAgICAgcmV0dXJuIGZvcmsua2V5d29yZCh0cnVlKTtcbiAgICAgIGNhc2UgJ2YnOlxuICAgICAgICByZXR1cm4gZm9yay5rZXl3b3JkKGZhbHNlKTtcbiAgICAgIGNhc2UgJ24nOlxuICAgICAgICByZXR1cm4gZm9yay5rZXl3b3JkKG51bGwpO1xuICAgIH0gdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGNoYXJhY3RlcjogXCInICsgY2hyICsgJ1wiIGF0OiAnICsgaSk7XG4gIH0sXG4gIG5vZGU6IGZ1bmN0aW9uICh0eXBlLCB2YWx1ZSwgc3RhcnQsIGVuZCwgbm9kZXMpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodmFsdWUsIGVuZCwgdHlwZSA/IG51bGwgOiBzbGljZSh0aGlzLnNvdXJjZSwgc3RhcnQsIGVuZCksIG5vZGVzKTtcbiAgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIHZhciBpID0gdGhpcy5pbmRleCArIDE7XG4gICAgdmFyIGV4cGVjdEtleXBhaXIgPSBmYWxzZTtcbiAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgdmFyIG5vZGVzID0ge307XG4gICAgd2hpbGUgKGkgPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICBpID0gdGhpcy51bnRpbChbJ1wiJywgJ30nXSwgaSk7XG4gICAgICBpZiAoYXQoc291cmNlLCBpKSA9PT0gJ30nICYmICFleHBlY3RLZXlwYWlyKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBQYXJzaW5nIHRoZSBrZXlcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmZvcmsoaSkuc3RyaW5nKCk7XG4gICAgICB2YXIga2V5ID0gcmVzdWx0LnZhbHVlO1xuICAgICAgaSA9IHJlc3VsdC5lbmQ7XG4gICAgICBpID0gdGhpcy51bnRpbChbJzonXSwgaSkgKyAxO1xuICAgICAgLy8gUGFyc2luZyB2YWx1ZVxuICAgICAgaSA9IHRoaXMuc2tpcChJU19XSElURVNQQUNFLCBpKTtcbiAgICAgIHJlc3VsdCA9IHRoaXMuZm9yayhpKS5wYXJzZSgpO1xuICAgICAgY3JlYXRlUHJvcGVydHkobm9kZXMsIGtleSwgcmVzdWx0KTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KG9iamVjdCwga2V5LCByZXN1bHQudmFsdWUpO1xuICAgICAgaSA9IHRoaXMudW50aWwoWycsJywgJ30nXSwgcmVzdWx0LmVuZCk7XG4gICAgICB2YXIgY2hyID0gYXQoc291cmNlLCBpKTtcbiAgICAgIGlmIChjaHIgPT09ICcsJykge1xuICAgICAgICBleHBlY3RLZXlwYWlyID0gdHJ1ZTtcbiAgICAgICAgaSsrO1xuICAgICAgfSBlbHNlIGlmIChjaHIgPT09ICd9Jykge1xuICAgICAgICBpKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ub2RlKE9CSkVDVCwgb2JqZWN0LCB0aGlzLmluZGV4LCBpLCBub2Rlcyk7XG4gIH0sXG4gIGFycmF5OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIHZhciBpID0gdGhpcy5pbmRleCArIDE7XG4gICAgdmFyIGV4cGVjdEVsZW1lbnQgPSBmYWxzZTtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB3aGlsZSAoaSA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIGkgPSB0aGlzLnNraXAoSVNfV0hJVEVTUEFDRSwgaSk7XG4gICAgICBpZiAoYXQoc291cmNlLCBpKSA9PT0gJ10nICYmICFleHBlY3RFbGVtZW50KSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5mb3JrKGkpLnBhcnNlKCk7XG4gICAgICBwdXNoKG5vZGVzLCByZXN1bHQpO1xuICAgICAgcHVzaChhcnJheSwgcmVzdWx0LnZhbHVlKTtcbiAgICAgIGkgPSB0aGlzLnVudGlsKFsnLCcsICddJ10sIHJlc3VsdC5lbmQpO1xuICAgICAgaWYgKGF0KHNvdXJjZSwgaSkgPT09ICcsJykge1xuICAgICAgICBleHBlY3RFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgaSsrO1xuICAgICAgfSBlbHNlIGlmIChhdChzb3VyY2UsIGkpID09PSAnXScpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubm9kZShPQkpFQ1QsIGFycmF5LCB0aGlzLmluZGV4LCBpLCBub2Rlcyk7XG4gIH0sXG4gIHN0cmluZzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSlNPTlN0cmluZyh0aGlzLnNvdXJjZSwgdGhpcy5pbmRleCArIDEpO1xuICAgIHJldHVybiB0aGlzLm5vZGUoUFJJTUlUSVZFLCBwYXJzZWQudmFsdWUsIGluZGV4LCBwYXJzZWQuZW5kKTtcbiAgfSxcbiAgbnVtYmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIHZhciBzdGFydEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB2YXIgaSA9IHN0YXJ0SW5kZXg7XG4gICAgaWYgKGF0KHNvdXJjZSwgaSkgPT09ICctJykgaSsrO1xuICAgIGlmIChhdChzb3VyY2UsIGkpID09PSAnMCcpIGkrKztcbiAgICBlbHNlIGlmIChleGVjKElTX05PTl9aRVJPX0RJR0lULCBhdChzb3VyY2UsIGkpKSkgaSA9IHRoaXMuc2tpcChJU19ESUdJVCwgaSArIDEpO1xuICAgIGVsc2UgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgbnVtYmVyIGF0OiAnICsgaSk7XG4gICAgaWYgKGF0KHNvdXJjZSwgaSkgPT09ICcuJykgaSA9IHRoaXMuc2tpcChJU19ESUdJVCwgaSArIDEpO1xuICAgIGlmIChhdChzb3VyY2UsIGkpID09PSAnZScgfHwgYXQoc291cmNlLCBpKSA9PT0gJ0UnKSB7XG4gICAgICBpKys7XG4gICAgICBpZiAoYXQoc291cmNlLCBpKSA9PT0gJysnIHx8IGF0KHNvdXJjZSwgaSkgPT09ICctJykgaSsrO1xuICAgICAgdmFyIGV4cG9uZW50U3RhcnRJbmRleCA9IGk7XG4gICAgICBpID0gdGhpcy5za2lwKElTX0RJR0lULCBpKTtcbiAgICAgIGlmIChleHBvbmVudFN0YXJ0SW5kZXggPT09IGkpIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBudW1iZXIncyBleHBvbmVudCB2YWx1ZSBhdDogXCIgKyBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubm9kZShQUklNSVRJVkUsIE51bWJlcihzbGljZShzb3VyY2UsIHN0YXJ0SW5kZXgsIGkpKSwgc3RhcnRJbmRleCwgaSk7XG4gIH0sXG4gIGtleXdvcmQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBrZXl3b3JkID0gJycgKyB2YWx1ZTtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgIHZhciBlbmRJbmRleCA9IGluZGV4ICsga2V5d29yZC5sZW5ndGg7XG4gICAgaWYgKHNsaWNlKHRoaXMuc291cmNlLCBpbmRleCwgZW5kSW5kZXgpICE9PSBrZXl3b3JkKSB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSB2YWx1ZSBhdDogJyArIGluZGV4KTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKFBSSU1JVElWRSwgdmFsdWUsIGluZGV4LCBlbmRJbmRleCk7XG4gIH0sXG4gIHNraXA6IGZ1bmN0aW9uIChyZWdleCwgaSkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICBmb3IgKDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykgaWYgKCFleGVjKHJlZ2V4LCBhdChzb3VyY2UsIGkpKSkgYnJlYWs7XG4gICAgcmV0dXJuIGk7XG4gIH0sXG4gIHVudGlsOiBmdW5jdGlvbiAoYXJyYXksIGkpIHtcbiAgICBpID0gdGhpcy5za2lwKElTX1dISVRFU1BBQ0UsIGkpO1xuICAgIHZhciBjaHIgPSBhdCh0aGlzLnNvdXJjZSwgaSk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcnJheS5sZW5ndGg7IGorKykgaWYgKGFycmF5W2pdID09PSBjaHIpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiJyArIGNociArICdcIiBhdDogJyArIGkpO1xuICB9XG59O1xuXG52YXIgTk9fU09VUkNFX1NVUFBPUlQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciB1bnNhZmVJbnQgPSAnOTAwNzE5OTI1NDc0MDk5Myc7XG4gIHZhciBzb3VyY2U7XG4gIG5hdGl2ZVBhcnNlKHVuc2FmZUludCwgZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICBzb3VyY2UgPSBjb250ZXh0LnNvdXJjZTtcbiAgfSk7XG4gIHJldHVybiBzb3VyY2UgIT09IHVuc2FmZUludDtcbn0pO1xuXG52YXIgUFJPUEVSX0JBU0VfUEFSU0UgPSBOQVRJVkVfU1lNQk9MICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFNhZmFyaSA5IGJ1Z1xuICByZXR1cm4gMSAvIG5hdGl2ZVBhcnNlKCctMCBcXHQnKSAhPT0gLUluZmluaXR5O1xufSk7XG5cbi8vIGBKU09OLnBhcnNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtanNvbi5wYXJzZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtanNvbi1wYXJzZS13aXRoLXNvdXJjZVxuJCh7IHRhcmdldDogJ0pTT04nLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE5PX1NPVVJDRV9TVVBQT1JUIH0sIHtcbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHRleHQsIHJldml2ZXIpIHtcbiAgICByZXR1cm4gUFJPUEVSX0JBU0VfUEFSU0UgJiYgIWlzQ2FsbGFibGUocmV2aXZlcikgPyBuYXRpdmVQYXJzZSh0ZXh0KSA6ICRwYXJzZSh0ZXh0LCByZXZpdmVyKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg0Njk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcbnZhciBpdGVyYXRlU2ltcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDcpO1xudmFyIFNldEhlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDIpO1xuXG52YXIgU2V0ID0gU2V0SGVscGVycy5TZXQ7XG52YXIgU2V0UHJvdG90eXBlID0gU2V0SGVscGVycy5wcm90bztcbnZhciBmb3JFYWNoID0gdW5jdXJyeVRoaXMoU2V0UHJvdG90eXBlLmZvckVhY2gpO1xudmFyIGtleXMgPSB1bmN1cnJ5VGhpcyhTZXRQcm90b3R5cGUua2V5cyk7XG52YXIgbmV4dCA9IGtleXMobmV3IFNldCgpKS5uZXh0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXQsIGZuLCBpbnRlcnJ1cHRpYmxlKSB7XG4gIHJldHVybiBpbnRlcnJ1cHRpYmxlID8gaXRlcmF0ZVNpbXBsZSh7IGl0ZXJhdG9yOiBrZXlzKHNldCksIG5leHQ6IG5leHQgfSwgZm4pIDogZm9yRWFjaChzZXQsIGZuKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg0ODA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgyOCk7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3MjcpO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODUyNzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgYVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oNzA4MCk7XG52YXIgaGFzID0gKF9fd2VicGFja19yZXF1aXJlX18oNDQwMikuaGFzKTtcbnZhciBzaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTcwKTtcbnZhciBnZXRTZXRSZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3ODkpO1xudmFyIGl0ZXJhdGVTaW1wbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwNyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTUzOSk7XG5cbi8vIGBTZXQucHJvdG90eXBlLmlzU3VwZXJzZXRPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuaXNzdXBlcnNldG9mXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU3VwZXJzZXRPZihvdGhlcikge1xuICB2YXIgTyA9IGFTZXQodGhpcyk7XG4gIHZhciBvdGhlclJlYyA9IGdldFNldFJlY29yZChvdGhlcik7XG4gIGlmIChzaXplKE8pIDwgb3RoZXJSZWMuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgaXRlcmF0b3IgPSBvdGhlclJlYy5nZXRJdGVyYXRvcigpO1xuICByZXR1cm4gaXRlcmF0ZVNpbXBsZShpdGVyYXRvciwgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIWhhcyhPLCBlKSkgcmV0dXJuIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICdub3JtYWwnLCBmYWxzZSk7XG4gIH0pICE9PSBmYWxzZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg1NTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJFN0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg1NzQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTA0KTtcblxudmFyICRFcnJvciA9IEVycm9yO1xudmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcblxudmFyIFRFU1QgPSAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gU3RyaW5nKG5ldyAkRXJyb3IoYXJnKS5zdGFjayk7IH0pKCd6eGNhc2QnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWRvcy9uby12dWxuZXJhYmxlLCBzb25hcmpzL3Nsb3ctcmVnZXggLS0gc2FmZVxudmFyIFY4X09SX0NIQUtSQV9TVEFDS19FTlRSWSA9IC9cXG5cXHMqYXQgW146XSo6W15cXG5dKi87XG52YXIgSVNfVjhfT1JfQ0hBS1JBX1NUQUNLID0gVjhfT1JfQ0hBS1JBX1NUQUNLX0VOVFJZLnRlc3QoVEVTVCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0YWNrLCBkcm9wRW50cmllcykge1xuICBpZiAoSVNfVjhfT1JfQ0hBS1JBX1NUQUNLICYmIHR5cGVvZiBzdGFjayA9PSAnc3RyaW5nJyAmJiAhJEVycm9yLnByZXBhcmVTdGFja1RyYWNlKSB7XG4gICAgd2hpbGUgKGRyb3BFbnRyaWVzLS0pIHN0YWNrID0gcmVwbGFjZShzdGFjaywgVjhfT1JfQ0hBS1JBX1NUQUNLX0VOVFJZLCAnJyk7XG4gIH0gcmV0dXJuIHN0YWNrO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODYyMjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkwMSk7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsVGhpcy5XZWFrTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQ2FsbGFibGUoV2Vha01hcCkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFN0cmluZyhXZWFrTWFwKSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg2NDY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1NjUpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUxKTtcbnZhciBnZXRJdGVyYXRvckRpcmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTc2Nyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1MSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgc3RyaW5nSGFuZGxpbmcpIHtcbiAgaWYgKCFzdHJpbmdIYW5kbGluZyB8fCB0eXBlb2Ygb2JqICE9PSAnc3RyaW5nJykgYW5PYmplY3Qob2JqKTtcbiAgdmFyIG1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKG9iaik7XG4gIHJldHVybiBnZXRJdGVyYXRvckRpcmVjdChhbk9iamVjdChtZXRob2QgIT09IHVuZGVmaW5lZCA/IGNhbGwobWV0aG9kLCBvYmopIDogb2JqKSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4Njg2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyNCk7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzkpO1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9PSA0Mjtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NzIxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzI0KTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUwNCk7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTA2KTtcblxudmFyIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSA9IFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGU7XG52YXIgZm9yRWFjaCA9IHVuY3VycnlUaGlzKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5mb3JFYWNoKTtcblxuLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuc2l6ZWAgZ2V0dGVyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3VybC9wdWxsLzczNFxuaWYgKERFU0NSSVBUT1JTICYmICEoJ3NpemUnIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSkpIHtcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBzaXplKCkge1xuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIGZvckVhY2godGhpcywgZnVuY3Rpb24gKCkgeyBjb3VudCsrOyB9KTtcbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NzI3OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODc0NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgTkFUSVZFX0JJTkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxNik7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xudmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQsIGVzL25vLXJlZmxlY3QgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgUmVmbGVjdCA9PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmFwcGx5IHx8IChOQVRJVkVfQklORCA/IGNhbGwuYmluZChhcHBseSkgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsLmFwcGx5KGFwcGx5LCBhcmd1bWVudHMpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg3NTA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwODApO1xudmFyIFNldEhlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDIpO1xudmFyIHNpemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxNzApO1xudmFyIGdldFNldFJlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzc4OSk7XG52YXIgaXRlcmF0ZVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oODQ2OSk7XG52YXIgaXRlcmF0ZVNpbXBsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA3KTtcblxudmFyIFNldCA9IFNldEhlbHBlcnMuU2V0O1xudmFyIGFkZCA9IFNldEhlbHBlcnMuYWRkO1xudmFyIGhhcyA9IFNldEhlbHBlcnMuaGFzO1xuXG4vLyBgU2V0LnByb3RvdHlwZS5pbnRlcnNlY3Rpb25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmludGVyc2VjdGlvblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgdmFyIE8gPSBhU2V0KHRoaXMpO1xuICB2YXIgb3RoZXJSZWMgPSBnZXRTZXRSZWNvcmQob3RoZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFNldCgpO1xuXG4gIGlmIChzaXplKE8pID4gb3RoZXJSZWMuc2l6ZSkge1xuICAgIGl0ZXJhdGVTaW1wbGUob3RoZXJSZWMuZ2V0SXRlcmF0b3IoKSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChoYXMoTywgZSkpIGFkZChyZXN1bHQsIGUpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJhdGVTZXQoTywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChvdGhlclJlYy5pbmNsdWRlcyhlKSkgYWRkKHJlc3VsdCwgZSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODc3Mzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODk4MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzc1MCk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTAzOTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTE0Mzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xudmFyIGFuT2JqZWN0T3JVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5NzIpO1xudmFyIGFTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NjMpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5Nyk7XG52YXIgYmFzZTY0TWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygyODA0KTtcbnZhciBnZXRBbHBoYWJldE9wdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oOTQ0KTtcbnZhciBub3REZXRhY2hlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTE2OSk7XG5cbnZhciBiYXNlNjRBbHBoYWJldCA9IGJhc2U2NE1hcC5jMmk7XG52YXIgYmFzZTY0VXJsQWxwaGFiZXQgPSBiYXNlNjRNYXAuYzJpVXJsO1xuXG52YXIgU3ludGF4RXJyb3IgPSBnbG9iYWxUaGlzLlN5bnRheEVycm9yO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbFRoaXMuVHlwZUVycm9yO1xudmFyIGF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcblxudmFyIHNraXBBc2NpaVdoaXRlc3BhY2UgPSBmdW5jdGlvbiAoc3RyaW5nLCBpbmRleCkge1xuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgZm9yICg7aW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICB2YXIgY2hyID0gYXQoc3RyaW5nLCBpbmRleCk7XG4gICAgaWYgKGNociAhPT0gJyAnICYmIGNociAhPT0gJ1xcdCcgJiYgY2hyICE9PSAnXFxuJyAmJiBjaHIgIT09ICdcXGYnICYmIGNociAhPT0gJ1xccicpIGJyZWFrO1xuICB9IHJldHVybiBpbmRleDtcbn07XG5cbnZhciBkZWNvZGVCYXNlNjRDaHVuayA9IGZ1bmN0aW9uIChjaHVuaywgYWxwaGFiZXQsIHRocm93T25FeHRyYUJpdHMpIHtcbiAgdmFyIGNodW5rTGVuZ3RoID0gY2h1bmsubGVuZ3RoO1xuXG4gIGlmIChjaHVua0xlbmd0aCA8IDQpIHtcbiAgICBjaHVuayArPSBjaHVua0xlbmd0aCA9PT0gMiA/ICdBQScgOiAnQSc7XG4gIH1cblxuICB2YXIgdHJpcGxldCA9IChhbHBoYWJldFthdChjaHVuaywgMCldIDw8IDE4KVxuICAgICsgKGFscGhhYmV0W2F0KGNodW5rLCAxKV0gPDwgMTIpXG4gICAgKyAoYWxwaGFiZXRbYXQoY2h1bmssIDIpXSA8PCA2KVxuICAgICsgYWxwaGFiZXRbYXQoY2h1bmssIDMpXTtcblxuICB2YXIgY2h1bmtCeXRlcyA9IFtcbiAgICAodHJpcGxldCA+PiAxNikgJiAyNTUsXG4gICAgKHRyaXBsZXQgPj4gOCkgJiAyNTUsXG4gICAgdHJpcGxldCAmIDI1NVxuICBdO1xuXG4gIGlmIChjaHVua0xlbmd0aCA9PT0gMikge1xuICAgIGlmICh0aHJvd09uRXh0cmFCaXRzICYmIGNodW5rQnl0ZXNbMV0gIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRXh0cmEgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gW2NodW5rQnl0ZXNbMF1dO1xuICB9XG5cbiAgaWYgKGNodW5rTGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKHRocm93T25FeHRyYUJpdHMgJiYgY2h1bmtCeXRlc1syXSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdFeHRyYSBiaXRzJyk7XG4gICAgfVxuICAgIHJldHVybiBbY2h1bmtCeXRlc1swXSwgY2h1bmtCeXRlc1sxXV07XG4gIH1cblxuICByZXR1cm4gY2h1bmtCeXRlcztcbn07XG5cbnZhciB3cml0ZUJ5dGVzID0gZnVuY3Rpb24gKGJ5dGVzLCBlbGVtZW50cywgd3JpdHRlbikge1xuICB2YXIgZWxlbWVudHNMZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBlbGVtZW50c0xlbmd0aDsgaW5kZXgrKykge1xuICAgIGJ5dGVzW3dyaXR0ZW4gKyBpbmRleF0gPSBlbGVtZW50c1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIHdyaXR0ZW4gKyBlbGVtZW50c0xlbmd0aDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzLCBtYXgtZGVwdGggLS0gVE9ETyAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyaW5nLCBvcHRpb25zLCBpbnRvLCBtYXhMZW5ndGgpIHtcbiAgYVN0cmluZyhzdHJpbmcpO1xuICBhbk9iamVjdE9yVW5kZWZpbmVkKG9wdGlvbnMpO1xuICB2YXIgYWxwaGFiZXQgPSBnZXRBbHBoYWJldE9wdGlvbihvcHRpb25zKSA9PT0gJ2Jhc2U2NCcgPyBiYXNlNjRBbHBoYWJldCA6IGJhc2U2NFVybEFscGhhYmV0O1xuICB2YXIgbGFzdENodW5rSGFuZGxpbmcgPSBvcHRpb25zID8gb3B0aW9ucy5sYXN0Q2h1bmtIYW5kbGluZyA6IHVuZGVmaW5lZDtcblxuICBpZiAobGFzdENodW5rSGFuZGxpbmcgPT09IHVuZGVmaW5lZCkgbGFzdENodW5rSGFuZGxpbmcgPSAnbG9vc2UnO1xuXG4gIGlmIChsYXN0Q2h1bmtIYW5kbGluZyAhPT0gJ2xvb3NlJyAmJiBsYXN0Q2h1bmtIYW5kbGluZyAhPT0gJ3N0cmljdCcgJiYgbGFzdENodW5rSGFuZGxpbmcgIT09ICdzdG9wLWJlZm9yZS1wYXJ0aWFsJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0luY29ycmVjdCBgbGFzdENodW5rSGFuZGxpbmdgIG9wdGlvbicpO1xuICB9XG5cbiAgaWYgKGludG8pIG5vdERldGFjaGVkKGludG8uYnVmZmVyKTtcblxuICB2YXIgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgdmFyIGJ5dGVzID0gaW50byB8fCBbXTtcbiAgdmFyIHdyaXR0ZW4gPSAwO1xuICB2YXIgcmVhZCA9IDA7XG4gIHZhciBjaHVuayA9ICcnO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIGlmIChtYXhMZW5ndGgpIHdoaWxlICh0cnVlKSB7XG4gICAgaW5kZXggPSBza2lwQXNjaWlXaGl0ZXNwYWNlKHN0cmluZywgaW5kZXgpO1xuICAgIGlmIChpbmRleCA9PT0gc3RyaW5nTGVuZ3RoKSB7XG4gICAgICBpZiAoY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAobGFzdENodW5rSGFuZGxpbmcgPT09ICdzdG9wLWJlZm9yZS1wYXJ0aWFsJykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Q2h1bmtIYW5kbGluZyA9PT0gJ2xvb3NlJykge1xuICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignTWFsZm9ybWVkIHBhZGRpbmc6IGV4YWN0bHkgb25lIGFkZGl0aW9uYWwgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdyaXR0ZW4gPSB3cml0ZUJ5dGVzKGJ5dGVzLCBkZWNvZGVCYXNlNjRDaHVuayhjaHVuaywgYWxwaGFiZXQsIGZhbHNlKSwgd3JpdHRlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdNaXNzaW5nIHBhZGRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVhZCA9IHN0cmluZ0xlbmd0aDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgY2hyID0gYXQoc3RyaW5nLCBpbmRleCk7XG4gICAgKytpbmRleDtcbiAgICBpZiAoY2hyID09PSAnPScpIHtcbiAgICAgIGlmIChjaHVuay5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignUGFkZGluZyBpcyB0b28gZWFybHknKTtcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gc2tpcEFzY2lpV2hpdGVzcGFjZShzdHJpbmcsIGluZGV4KTtcbiAgICAgIGlmIChjaHVuay5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSBzdHJpbmdMZW5ndGgpIHtcbiAgICAgICAgICBpZiAobGFzdENodW5rSGFuZGxpbmcgPT09ICdzdG9wLWJlZm9yZS1wYXJ0aWFsJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignTWFsZm9ybWVkIHBhZGRpbmc6IG9ubHkgb25lID0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXQoc3RyaW5nLCBpbmRleCkgPT09ICc9Jykge1xuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgaW5kZXggPSBza2lwQXNjaWlXaGl0ZXNwYWNlKHN0cmluZywgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPCBzdHJpbmdMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGNoYXJhY3RlciBhZnRlciBwYWRkaW5nJyk7XG4gICAgICB9XG4gICAgICB3cml0dGVuID0gd3JpdGVCeXRlcyhieXRlcywgZGVjb2RlQmFzZTY0Q2h1bmsoY2h1bmssIGFscGhhYmV0LCBsYXN0Q2h1bmtIYW5kbGluZyA9PT0gJ3N0cmljdCcpLCB3cml0dGVuKTtcbiAgICAgIHJlYWQgPSBzdHJpbmdMZW5ndGg7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFoYXNPd24oYWxwaGFiZXQsIGNocikpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBjaGFyYWN0ZXInKTtcbiAgICB9XG4gICAgdmFyIHJlbWFpbmluZ0J5dGVzID0gbWF4TGVuZ3RoIC0gd3JpdHRlbjtcbiAgICBpZiAocmVtYWluaW5nQnl0ZXMgPT09IDEgJiYgY2h1bmsubGVuZ3RoID09PSAyIHx8IHJlbWFpbmluZ0J5dGVzID09PSAyICYmIGNodW5rLmxlbmd0aCA9PT0gMykge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlOiB3ZSBjYW4gZml0IGV4YWN0bHkgdGhlIG51bWJlciBvZiBieXRlcyBjdXJyZW50bHkgcmVwcmVzZW50ZWQgYnkgY2h1bmssIHNvIHdlIHdlcmUganVzdCBjaGVja2luZyBmb3IgYD1gXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaHVuayArPSBjaHI7XG4gICAgaWYgKGNodW5rLmxlbmd0aCA9PT0gNCkge1xuICAgICAgd3JpdHRlbiA9IHdyaXRlQnl0ZXMoYnl0ZXMsIGRlY29kZUJhc2U2NENodW5rKGNodW5rLCBhbHBoYWJldCwgZmFsc2UpLCB3cml0dGVuKTtcbiAgICAgIGNodW5rID0gJyc7XG4gICAgICByZWFkID0gaW5kZXg7XG4gICAgICBpZiAod3JpdHRlbiA9PT0gbWF4TGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGJ5dGVzOiBieXRlcywgcmVhZDogcmVhZCwgd3JpdHRlbjogd3JpdHRlbiB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTI4Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgU2V0SGVscGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQwMik7XG52YXIgaXRlcmF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oODQ2OSk7XG5cbnZhciBTZXQgPSBTZXRIZWxwZXJzLlNldDtcbnZhciBhZGQgPSBTZXRIZWxwZXJzLmFkZDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2V0KSB7XG4gIHZhciByZXN1bHQgPSBuZXcgU2V0KCk7XG4gIGl0ZXJhdGUoc2V0LCBmdW5jdGlvbiAoaXQpIHtcbiAgICBhZGQocmVzdWx0LCBpdCk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTI5Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OTgxKTtcblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoe30uaGFzT3duUHJvcGVydHkpO1xuXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1oYXNvd24gLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0b09iamVjdChpdCksIGtleSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MzA2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTAxKTtcbnZhciB0cnlUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNjgyMyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzMTQ6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzY3KTtcbnZhciBub3RBTmFOID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTQ5KTtcbnZhciB0b1Bvc2l0aXZlSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTU5MCk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTUzOSk7XG52YXIgY3JlYXRlSXRlcmF0b3JQcm94eSA9IF9fd2VicGFja19yZXF1aXJlX18oOTQ2Mik7XG52YXIgaXRlcmF0b3JIZWxwZXJUaHJvd3NPbkludmFsaWRJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjg0KTtcbnZhciBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTQ5KTtcbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mzk1KTtcblxudmFyIERST1BfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SID0gIUlTX1BVUkUgJiYgIWl0ZXJhdG9ySGVscGVyVGhyb3dzT25JbnZhbGlkSXRlcmF0b3IoJ2Ryb3AnLCAwKTtcbnZhciBkcm9wV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSAhSVNfUFVSRSAmJiAhRFJPUF9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1JcbiAgJiYgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcignZHJvcCcsIFJhbmdlRXJyb3IpO1xuXG52YXIgRk9SQ0VEID0gSVNfUFVSRSB8fCBEUk9QX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiB8fCBkcm9wV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3I7XG5cbnZhciBJdGVyYXRvclByb3h5ID0gY3JlYXRlSXRlcmF0b3JQcm94eShmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3I7XG4gIHZhciBuZXh0ID0gdGhpcy5uZXh0O1xuICB2YXIgcmVzdWx0LCBkb25lO1xuICB3aGlsZSAodGhpcy5yZW1haW5pbmcpIHtcbiAgICB0aGlzLnJlbWFpbmluZy0tO1xuICAgIHJlc3VsdCA9IGFuT2JqZWN0KGNhbGwobmV4dCwgaXRlcmF0b3IpKTtcbiAgICBkb25lID0gdGhpcy5kb25lID0gISFyZXN1bHQuZG9uZTtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICB9XG4gIHJlc3VsdCA9IGFuT2JqZWN0KGNhbGwobmV4dCwgaXRlcmF0b3IpKTtcbiAgZG9uZSA9IHRoaXMuZG9uZSA9ICEhcmVzdWx0LmRvbmU7XG4gIGlmICghZG9uZSkgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn0pO1xuXG4vLyBgSXRlcmF0b3IucHJvdG90eXBlLmRyb3BgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pdGVyYXRvci5wcm90b3R5cGUuZHJvcFxuJCh7IHRhcmdldDogJ0l0ZXJhdG9yJywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgZHJvcDogZnVuY3Rpb24gZHJvcChsaW1pdCkge1xuICAgIGFuT2JqZWN0KHRoaXMpO1xuICAgIHZhciByZW1haW5pbmc7XG4gICAgdHJ5IHtcbiAgICAgIHJlbWFpbmluZyA9IHRvUG9zaXRpdmVJbnRlZ2VyKG5vdEFOYU4oK2xpbWl0KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UodGhpcywgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChkcm9wV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IpIHJldHVybiBjYWxsKGRyb3BXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciwgdGhpcywgcmVtYWluaW5nKTtcblxuICAgIHJldHVybiBuZXcgSXRlcmF0b3JQcm94eShnZXRJdGVyYXRvckRpcmVjdCh0aGlzKSwge1xuICAgICAgcmVtYWluaW5nOiByZW1haW5pbmdcbiAgICB9KTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk0Mjk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdsb2JhbFRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1NzYpO1xudmFyIElTX05PREUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxOTMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmIChJU19OT0RFKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzLnByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShuYW1lKTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBzYWZlXG4gICAgICByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiByZXF1aXJlKFwiJyArIG5hbWUgKyAnXCIpJykoKTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk0MzI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxuX193ZWJwYWNrX3JlcXVpcmVfXyg1MjEzKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTQzMzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywga2V5LCB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWxUaGlzW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NDYyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTY1KTtcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNjApO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNjY5OSk7XG52YXIgZGVmaW5lQnVpbHRJbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyNzkpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oODIyNyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTE4MSk7XG52YXIgZ2V0TWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTY2KTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NTcpLkl0ZXJhdG9yUHJvdG90eXBlKTtcbnZhciBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTI5KTtcbnZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTM5KTtcbnZhciBpdGVyYXRvckNsb3NlQWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzg1KTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgSVRFUkFUT1JfSEVMUEVSID0gJ0l0ZXJhdG9ySGVscGVyJztcbnZhciBXUkFQX0ZPUl9WQUxJRF9JVEVSQVRPUiA9ICdXcmFwRm9yVmFsaWRJdGVyYXRvcic7XG52YXIgTk9STUFMID0gJ25vcm1hbCc7XG52YXIgVEhST1cgPSAndGhyb3cnO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcblxudmFyIGNyZWF0ZUl0ZXJhdG9yUHJveHlQcm90b3R5cGUgPSBmdW5jdGlvbiAoSVNfSVRFUkFUT1IpIHtcbiAgdmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihJU19JVEVSQVRPUiA/IFdSQVBfRk9SX1ZBTElEX0lURVJBVE9SIDogSVRFUkFUT1JfSEVMUEVSKTtcblxuICByZXR1cm4gZGVmaW5lQnVpbHRJbnMoY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKSwge1xuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgLy8gZm9yIHNpbXBsaWZpY2F0aW9uOlxuICAgICAgLy8gICBmb3IgYCVXcmFwRm9yVmFsaWRJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgb3Igd2l0aCBgc3RhdGUucmV0dXJuSGFuZGxlclJlc3VsdGAgb3VyIGBuZXh0SGFuZGxlcmAgcmV0dXJucyBgSXRlclJlc3VsdE9iamVjdGBcbiAgICAgIC8vICAgZm9yIGAlSXRlcmF0b3JIZWxwZXJQcm90b3R5cGUlLm5leHRgIC0ganVzdCBhIHZhbHVlXG4gICAgICBpZiAoSVNfSVRFUkFUT1IpIHJldHVybiBzdGF0ZS5uZXh0SGFuZGxlcigpO1xuICAgICAgaWYgKHN0YXRlLmRvbmUpIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gc3RhdGUubmV4dEhhbmRsZXIoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnJldHVybkhhbmRsZXJSZXN1bHQgPyByZXN1bHQgOiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHJlc3VsdCwgc3RhdGUuZG9uZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgIHZhciBpdGVyYXRvciA9IHN0YXRlLml0ZXJhdG9yO1xuICAgICAgc3RhdGUuZG9uZSA9IHRydWU7XG4gICAgICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICAgICAgdmFyIHJldHVybk1ldGhvZCA9IGdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xuICAgICAgICByZXR1cm4gcmV0dXJuTWV0aG9kID8gY2FsbChyZXR1cm5NZXRob2QsIGl0ZXJhdG9yKSA6IGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pbm5lcikgdHJ5IHtcbiAgICAgICAgaXRlcmF0b3JDbG9zZShzdGF0ZS5pbm5lci5pdGVyYXRvciwgTk9STUFMKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBUSFJPVywgZXJyb3IpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLm9wZW5JdGVycykgdHJ5IHtcbiAgICAgICAgaXRlcmF0b3JDbG9zZUFsbChzdGF0ZS5vcGVuSXRlcnMsIE5PUk1BTCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgVEhST1csIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRvcikgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgTk9STUFMKTtcbiAgICAgIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBXcmFwRm9yVmFsaWRJdGVyYXRvclByb3RvdHlwZSA9IGNyZWF0ZUl0ZXJhdG9yUHJveHlQcm90b3R5cGUodHJ1ZSk7XG52YXIgSXRlcmF0b3JIZWxwZXJQcm90b3R5cGUgPSBjcmVhdGVJdGVyYXRvclByb3h5UHJvdG90eXBlKGZhbHNlKTtcblxuY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhdG9ySGVscGVyUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCAnSXRlcmF0b3IgSGVscGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5leHRIYW5kbGVyLCBJU19JVEVSQVRPUiwgUkVUVVJOX0hBTkRMRVJfUkVTVUxUKSB7XG4gIHZhciBJdGVyYXRvclByb3h5ID0gZnVuY3Rpb24gSXRlcmF0b3IocmVjb3JkLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgc3RhdGUuaXRlcmF0b3IgPSByZWNvcmQuaXRlcmF0b3I7XG4gICAgICBzdGF0ZS5uZXh0ID0gcmVjb3JkLm5leHQ7XG4gICAgfSBlbHNlIHN0YXRlID0gcmVjb3JkO1xuICAgIHN0YXRlLnR5cGUgPSBJU19JVEVSQVRPUiA/IFdSQVBfRk9SX1ZBTElEX0lURVJBVE9SIDogSVRFUkFUT1JfSEVMUEVSO1xuICAgIHN0YXRlLnJldHVybkhhbmRsZXJSZXN1bHQgPSAhIVJFVFVSTl9IQU5ETEVSX1JFU1VMVDtcbiAgICBzdGF0ZS5uZXh0SGFuZGxlciA9IG5leHRIYW5kbGVyO1xuICAgIHN0YXRlLmNvdW50ZXIgPSAwO1xuICAgIHN0YXRlLmRvbmUgPSBmYWxzZTtcbiAgICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHN0YXRlKTtcbiAgfTtcblxuICBJdGVyYXRvclByb3h5LnByb3RvdHlwZSA9IElTX0lURVJBVE9SID8gV3JhcEZvclZhbGlkSXRlcmF0b3JQcm90b3R5cGUgOiBJdGVyYXRvckhlbHBlclByb3RvdHlwZTtcblxuICByZXR1cm4gSXRlcmF0b3JQcm94eTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk0ODY6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUxOCk7XG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MDQpO1xudmFyIGFuT2JqZWN0T3JVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5NzIpO1xudmFyIGFuVWludDhBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNDE1NCk7XG52YXIgbm90RGV0YWNoZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxNjkpO1xudmFyIGJhc2U2NE1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgwNCk7XG52YXIgZ2V0QWxwaGFiZXRPcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0NCk7XG5cbnZhciBiYXNlNjRBbHBoYWJldCA9IGJhc2U2NE1hcC5pMmM7XG52YXIgYmFzZTY0VXJsQWxwaGFiZXQgPSBiYXNlNjRNYXAuaTJjVXJsO1xuXG52YXIgY2hhckF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcblxudmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWxUaGlzLlVpbnQ4QXJyYXk7XG5cbnZhciBJTkNPUlJFQ1RfQkVIQVZJT1JfT1JfRE9FU05UX0VYSVNUUyA9ICFVaW50OEFycmF5IHx8ICFVaW50OEFycmF5LnByb3RvdHlwZS50b0Jhc2U2NCB8fCAhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciB0YXJnZXQgPSBuZXcgVWludDhBcnJheSgpO1xuICAgIHRhcmdldC50b0Jhc2U2NChudWxsKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSgpO1xuXG4vLyBgVWludDhBcnJheS5wcm90b3R5cGUudG9CYXNlNjRgIG1ldGhvZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXlidWZmZXItYmFzZTY0XG5pZiAoVWludDhBcnJheSkgJCh7IHRhcmdldDogJ1VpbnQ4QXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfQkVIQVZJT1JfT1JfRE9FU05UX0VYSVNUUyB9LCB7XG4gIHRvQmFzZTY0OiBmdW5jdGlvbiB0b0Jhc2U2NCgvKiBvcHRpb25zICovKSB7XG4gICAgdmFyIGFycmF5ID0gYW5VaW50OEFycmF5KHRoaXMpO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA/IGFuT2JqZWN0T3JVbmRlZmluZWQoYXJndW1lbnRzWzBdKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgYWxwaGFiZXQgPSBnZXRBbHBoYWJldE9wdGlvbihvcHRpb25zKSA9PT0gJ2Jhc2U2NCcgPyBiYXNlNjRBbHBoYWJldCA6IGJhc2U2NFVybEFscGhhYmV0O1xuICAgIHZhciBvbWl0UGFkZGluZyA9ICEhb3B0aW9ucyAmJiAhIW9wdGlvbnMub21pdFBhZGRpbmc7XG4gICAgbm90RGV0YWNoZWQodGhpcy5idWZmZXIpO1xuXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciB0cmlwbGV0O1xuXG4gICAgdmFyIGF0ID0gZnVuY3Rpb24gKHNoaWZ0KSB7XG4gICAgICByZXR1cm4gY2hhckF0KGFscGhhYmV0LCAodHJpcGxldCA+PiAoNiAqIHNoaWZ0KSkgJiA2Myk7XG4gICAgfTtcblxuICAgIGZvciAoOyBpICsgMiA8IGxlbmd0aDsgaSArPSAzKSB7XG4gICAgICB0cmlwbGV0ID0gKGFycmF5W2ldIDw8IDE2KSArIChhcnJheVtpICsgMV0gPDwgOCkgKyBhcnJheVtpICsgMl07XG4gICAgICByZXN1bHQgKz0gYXQoMykgKyBhdCgyKSArIGF0KDEpICsgYXQoMCk7XG4gICAgfVxuICAgIGlmIChpICsgMiA9PT0gbGVuZ3RoKSB7XG4gICAgICB0cmlwbGV0ID0gKGFycmF5W2ldIDw8IDE2KSArIChhcnJheVtpICsgMV0gPDwgOCk7XG4gICAgICByZXN1bHQgKz0gYXQoMykgKyBhdCgyKSArIGF0KDEpICsgKG9taXRQYWRkaW5nID8gJycgOiAnPScpO1xuICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgdHJpcGxldCA9IGFycmF5W2ldIDw8IDE2O1xuICAgICAgcmVzdWx0ICs9IGF0KDMpICsgYXQoMikgKyAob21pdFBhZGRpbmcgPyAnJyA6ICc9PScpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NTA0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBOQVRJVkVfQklORCA9IF9fd2VicGFja19yZXF1aXJlX18oNjE2KTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIHNhZmVcbnZhciB1bmN1cnJ5VGhpc1dpdGhCaW5kID0gTkFUSVZFX0JJTkQgJiYgRnVuY3Rpb25Qcm90b3R5cGUuYmluZC5iaW5kKGNhbGwsIGNhbGwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gdW5jdXJyeVRoaXNXaXRoQmluZCA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTUxOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsVGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3Nik7XG52YXIgdXNlckFnZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyODM5KTtcblxudmFyIHByb2Nlc3MgPSBnbG9iYWxUaGlzLnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbFRoaXMuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucyB8fCBEZW5vICYmIERlbm8udmVyc2lvbjtcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICAvLyBpbiBvbGQgQ2hyb21lLCB2ZXJzaW9ucyBvZiBWOCBpc24ndCBWOCA9IENocm9tZSAvIDEwXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXG4gIHZlcnNpb24gPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG59XG5cbi8vIEJyb3dzZXJGUyBOb2RlSlMgYHByb2Nlc3NgIHBvbHlmaWxsIGluY29ycmVjdGx5IHNldCBgLnY4YCB0byBgMC4wYFxuLy8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVyc2lvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTUzOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2NSk7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTEpO1xudmFyIGdldE1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTk2Nik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBraW5kLCB2YWx1ZSkge1xuICB2YXIgaW5uZXJSZXN1bHQsIGlubmVyRXJyb3I7XG4gIGFuT2JqZWN0KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xuICAgIGlmICghaW5uZXJSZXN1bHQpIHtcbiAgICAgIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaW5uZXJSZXN1bHQgPSBjYWxsKGlubmVyUmVzdWx0LCBpdGVyYXRvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW5uZXJFcnJvciA9IHRydWU7XG4gICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgfVxuICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gIGlmIChpbm5lckVycm9yKSB0aHJvdyBpbm5lclJlc3VsdDtcbiAgYW5PYmplY3QoaW5uZXJSZXN1bHQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NTY1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBOQVRJVkVfQklORCA9IF9fd2VicGFja19yZXF1aXJlX18oNjE2KTtcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gY2FsbC5iaW5kKGNhbGwpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbC5hcHBseShjYWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTU3Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBhcnJheVdpdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MjgpO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2NDQpO1xudmFyIGlzQmlnSW50QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMDgpO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyOTEpO1xudmFyIHRvQmlnSW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1ODU0KTtcblxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xuXG52YXIgUFJPUEVSX09SREVSID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsLCBlcy9uby10eXBlZC1hcnJheXMsIGVzL25vLWFycmF5LXByb3RvdHlwZS13aXRoIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgbmV3IEludDhBcnJheSgxKVsnd2l0aCddKDIsIHsgdmFsdWVPZjogZnVuY3Rpb24gKCkgeyB0aHJvdyA4OyB9IH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIHNvbWUgZWFybHkgaW1wbGVtZW50YXRpb25zLCBsaWtlIFdlYktpdCwgZG9lcyBub3QgZm9sbG93IHRoZSBmaW5hbCBzZW1hbnRpY1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWNoYW5nZS1hcnJheS1ieS1jb3B5L3B1bGwvODZcbiAgICByZXR1cm4gZXJyb3IgPT09IDg7XG4gIH1cbn0oKTtcblxuLy8gQnVnIGluIFdlYktpdC4gSXQgc2hvdWxkIHRydW5jYXRlIGEgbmVnYXRpdmUgZnJhY3Rpb25hbCBpbmRleCB0byB6ZXJvLCBidXQgaW5zdGVhZCB0aHJvd3MgYW4gZXJyb3JcbnZhciBUSFJPV19PTl9ORUdBVElWRV9GUkFDVElPTkFMX0lOREVYID0gUFJPUEVSX09SREVSICYmIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tdHlwZWQtYXJyYXlzLCBlcy9uby1hcnJheS1wcm90b3R5cGUtd2l0aCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIG5ldyBJbnQ4QXJyYXkoMSlbJ3dpdGgnXSgtMC41LCAxKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSgpO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS53aXRoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS53aXRoXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCd3aXRoJywgeyAnd2l0aCc6IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgdmFyIE8gPSBhVHlwZWRBcnJheSh0aGlzKTtcbiAgdmFyIHJlbGF0aXZlSW5kZXggPSB0b0ludGVnZXJPckluZmluaXR5KGluZGV4KTtcbiAgdmFyIGFjdHVhbFZhbHVlID0gaXNCaWdJbnRBcnJheShPKSA/IHRvQmlnSW50KHZhbHVlKSA6ICt2YWx1ZTtcbiAgcmV0dXJuIGFycmF5V2l0aChPLCBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IoTyksIHJlbGF0aXZlSW5kZXgsIGFjdHVhbFZhbHVlKTtcbn0gfVsnd2l0aCddLCAhUFJPUEVSX09SREVSIHx8IFRIUk9XX09OX05FR0FUSVZFX0ZSQUNUSU9OQUxfSU5ERVgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NTkwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjkxKTtcblxudmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IHRvSW50ZWdlck9ySW5maW5pdHkoaXQpO1xuICBpZiAocmVzdWx0IDwgMCkgdGhyb3cgbmV3ICRSYW5nZUVycm9yKFwiVGhlIGFyZ3VtZW50IGNhbid0IGJlIGxlc3MgdGhhbiAwXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTYxNzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mzk3KTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2MTApO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTk4KTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT09IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT09IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk2MzE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxuX193ZWJwYWNrX3JlcXVpcmVfXyg5NDg2KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTc5Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQyMjYpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODM1OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG4vLyBTaG91bGQgZ2V0IGl0ZXJhdG9yIHJlY29yZCBvZiBhIHNldC1saWtlIG9iamVjdCBiZWZvcmUgY2xvbmluZyB0aGlzXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Mjg5NDMwXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1zZXQgLS0gbmVlZGVkIGZvciB0ZXN0XG4gICAgdmFyIGJhc2VTZXQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHNldExpa2UgPSB7XG4gICAgICBzaXplOiAwLFxuICAgICAgaGFzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAga2V5czogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIG5lZWRlZCBmb3IgdGVzdFxuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnbmV4dCcsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGJhc2VTZXQuY2xlYXIoKTtcbiAgICAgICAgICAgIGJhc2VTZXQuYWRkKDQpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VTZXRbTUVUSE9EX05BTUVdKHNldExpa2UpO1xuXG4gICAgcmV0dXJuIHJlc3VsdC5zaXplID09PSAxICYmIHJlc3VsdC52YWx1ZXMoKS5uZXh0KCkudmFsdWUgPT09IDQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5OTI4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjE5OCk7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMTI5MSk7XG5cbnZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLndpdGhcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS53aXRoXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBDLCBpbmRleCwgdmFsdWUpIHtcbiAgdmFyIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICB2YXIgcmVsYXRpdmVJbmRleCA9IHRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xuICB2YXIgYWN0dWFsSW5kZXggPSByZWxhdGl2ZUluZGV4IDwgMCA/IGxlbiArIHJlbGF0aXZlSW5kZXggOiByZWxhdGl2ZUluZGV4O1xuICBpZiAoYWN0dWFsSW5kZXggPj0gbGVuIHx8IGFjdHVhbEluZGV4IDwgMCkgdGhyb3cgbmV3ICRSYW5nZUVycm9yKCdJbmNvcnJlY3QgaW5kZXgnKTtcbiAgdmFyIEEgPSBuZXcgQyhsZW4pO1xuICB2YXIgayA9IDA7XG4gIGZvciAoOyBrIDwgbGVuOyBrKyspIEFba10gPSBrID09PSBhY3R1YWxJbmRleCA/IHZhbHVlIDogT1trXTtcbiAgcmV0dXJuIEE7XG59O1xuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFxuLyoqKioqKi8gLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0fTtcbi8qKioqKiovIFxuLyoqKioqKi8gXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcbi8qKioqKiovIFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gfVxuLyoqKioqKi8gXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyAoKCkgPT4ge1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnB1c2guanNcbnZhciBlc19hcnJheV9wdXNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTE0KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LWJ1ZmZlci5kZXRhY2hlZC5qc1xudmFyIGVzX2FycmF5X2J1ZmZlcl9kZXRhY2hlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNjU3Myk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS1idWZmZXIudHJhbnNmZXIuanNcbnZhciBlc19hcnJheV9idWZmZXJfdHJhbnNmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxMDApO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXktYnVmZmVyLnRyYW5zZmVyLXRvLWZpeGVkLWxlbmd0aC5qc1xudmFyIGVzX2FycmF5X2J1ZmZlcl90cmFuc2Zlcl90b19maXhlZF9sZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5MzYpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IuY29uc3RydWN0b3IuanNcbnZhciBlc19pdGVyYXRvcl9jb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oODExMSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5pdGVyYXRvci5yZWR1Y2UuanNcbnZhciBlc19pdGVyYXRvcl9yZWR1Y2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyMzcpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS50cnkuanNcbnZhciBlc19wcm9taXNlX3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMTY4OSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS53aXRoLmpzXG52YXIgZXNfdHlwZWRfYXJyYXlfd2l0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOTU3Nyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQubWF0aC5zdW0tcHJlY2lzZS5qc1xudmFyIGVzbmV4dF9tYXRoX3N1bV9wcmVjaXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjM1KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC51aW50OC1hcnJheS5mcm9tLWJhc2U2NC5qc1xudmFyIGVzbmV4dF91aW50OF9hcnJheV9mcm9tX2Jhc2U2NCA9IF9fd2VicGFja19yZXF1aXJlX18oOTQzMik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQudWludDgtYXJyYXkuc2V0LWZyb20tYmFzZTY0LmpzXG52YXIgZXNuZXh0X3VpbnQ4X2FycmF5X3NldF9mcm9tX2Jhc2U2NCA9IF9fd2VicGFja19yZXF1aXJlX18oMTU0OSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQudWludDgtYXJyYXkuc2V0LWZyb20taGV4LmpzXG52YXIgZXNuZXh0X3VpbnQ4X2FycmF5X3NldF9mcm9tX2hleCA9IF9fd2VicGFja19yZXF1aXJlX18oOTc5Nyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQudWludDgtYXJyYXkudG8tYmFzZTY0LmpzXG52YXIgZXNuZXh0X3VpbnQ4X2FycmF5X3RvX2Jhc2U2NCA9IF9fd2VicGFja19yZXF1aXJlX18oOTYzMSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQudWludDgtYXJyYXkudG8taGV4LmpzXG52YXIgZXNuZXh0X3VpbnQ4X2FycmF5X3RvX2hleCA9IF9fd2VicGFja19yZXF1aXJlX18oNTYyMyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWV4Y2VwdGlvbi5zdGFjay5qc1xudmFyIHdlYl9kb21fZXhjZXB0aW9uX3N0YWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTc5KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi51cmwucGFyc2UuanNcbnZhciB3ZWJfdXJsX3BhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzgxKTtcbjsvLyAuL3NyYy9zaGFyZWQvdXRpbC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBpc05vZGVKUyA9IHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgKyBcIlwiID09PSBcIltvYmplY3QgcHJvY2Vzc11cIiAmJiAhcHJvY2Vzcy52ZXJzaW9ucy5udyAmJiAhKHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gJiYgcHJvY2Vzcy50eXBlICYmIHByb2Nlc3MudHlwZSAhPT0gXCJicm93c2VyXCIpO1xuY29uc3QgRk9OVF9JREVOVElUWV9NQVRSSVggPSBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXTtcbmNvbnN0IExJTkVfRkFDVE9SID0gMS4zNTtcbmNvbnN0IExJTkVfREVTQ0VOVF9GQUNUT1IgPSAwLjM1O1xuY29uc3QgQkFTRUxJTkVfRkFDVE9SID0gTElORV9ERVNDRU5UX0ZBQ1RPUiAvIExJTkVfRkFDVE9SO1xuY29uc3QgUmVuZGVyaW5nSW50ZW50RmxhZyA9IHtcbiAgQU5ZOiAweDAxLFxuICBESVNQTEFZOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgU0FWRTogMHgwOCxcbiAgQU5OT1RBVElPTlNfRk9STVM6IDB4MTAsXG4gIEFOTk9UQVRJT05TX1NUT1JBR0U6IDB4MjAsXG4gIEFOTk9UQVRJT05TX0RJU0FCTEU6IDB4NDAsXG4gIElTX0VESVRJTkc6IDB4ODAsXG4gIE9QTElTVDogMHgxMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uTW9kZSA9IHtcbiAgRElTQUJMRTogMCxcbiAgRU5BQkxFOiAxLFxuICBFTkFCTEVfRk9STVM6IDIsXG4gIEVOQUJMRV9TVE9SQUdFOiAzXG59O1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfZWRpdG9yX1wiO1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclR5cGUgPSB7XG4gIERJU0FCTEU6IC0xLFxuICBOT05FOiAwLFxuICBGUkVFVEVYVDogMyxcbiAgSElHSExJR0hUOiA5LFxuICBTVEFNUDogMTMsXG4gIElOSzogMTUsXG4gIFBPUFVQOiAxNixcbiAgU0lHTkFUVVJFOiAxMDEsXG4gIENPTU1FTlQ6IDEwMlxufTtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlID0ge1xuICBSRVNJWkU6IDEsXG4gIENSRUFURTogMixcbiAgRlJFRVRFWFRfU0laRTogMTEsXG4gIEZSRUVURVhUX0NPTE9SOiAxMixcbiAgRlJFRVRFWFRfT1BBQ0lUWTogMTMsXG4gIElOS19DT0xPUjogMjEsXG4gIElOS19USElDS05FU1M6IDIyLFxuICBJTktfT1BBQ0lUWTogMjMsXG4gIEhJR0hMSUdIVF9DT0xPUjogMzEsXG4gIEhJR0hMSUdIVF9USElDS05FU1M6IDMyLFxuICBISUdITElHSFRfRlJFRTogMzMsXG4gIEhJR0hMSUdIVF9TSE9XX0FMTDogMzQsXG4gIERSQVdfU1RFUDogNDFcbn07XG5jb25zdCBQZXJtaXNzaW9uRmxhZyA9IHtcbiAgUFJJTlQ6IDB4MDQsXG4gIE1PRElGWV9DT05URU5UUzogMHgwOCxcbiAgQ09QWTogMHgxMCxcbiAgTU9ESUZZX0FOTk9UQVRJT05TOiAweDIwLFxuICBGSUxMX0lOVEVSQUNUSVZFX0ZPUk1TOiAweDEwMCxcbiAgQ09QWV9GT1JfQUNDRVNTSUJJTElUWTogMHgyMDAsXG4gIEFTU0VNQkxFOiAweDQwMCxcbiAgUFJJTlRfSElHSF9RVUFMSVRZOiAweDgwMFxufTtcbmNvbnN0IFRleHRSZW5kZXJpbmdNb2RlID0ge1xuICBGSUxMOiAwLFxuICBTVFJPS0U6IDEsXG4gIEZJTExfU1RST0tFOiAyLFxuICBJTlZJU0lCTEU6IDMsXG4gIEZJTExfQUREX1RPX1BBVEg6IDQsXG4gIFNUUk9LRV9BRERfVE9fUEFUSDogNSxcbiAgRklMTF9TVFJPS0VfQUREX1RPX1BBVEg6IDYsXG4gIEFERF9UT19QQVRIOiA3LFxuICBGSUxMX1NUUk9LRV9NQVNLOiAzLFxuICBBRERfVE9fUEFUSF9GTEFHOiA0XG59O1xuY29uc3QgdXRpbF9JbWFnZUtpbmQgPSB7XG4gIEdSQVlTQ0FMRV8xQlBQOiAxLFxuICBSR0JfMjRCUFA6IDIsXG4gIFJHQkFfMzJCUFA6IDNcbn07XG5jb25zdCBBbm5vdGF0aW9uVHlwZSA9IHtcbiAgVEVYVDogMSxcbiAgTElOSzogMixcbiAgRlJFRVRFWFQ6IDMsXG4gIExJTkU6IDQsXG4gIFNRVUFSRTogNSxcbiAgQ0lSQ0xFOiA2LFxuICBQT0xZR09OOiA3LFxuICBQT0xZTElORTogOCxcbiAgSElHSExJR0hUOiA5LFxuICBVTkRFUkxJTkU6IDEwLFxuICBTUVVJR0dMWTogMTEsXG4gIFNUUklLRU9VVDogMTIsXG4gIFNUQU1QOiAxMyxcbiAgQ0FSRVQ6IDE0LFxuICBJTks6IDE1LFxuICBQT1BVUDogMTYsXG4gIEZJTEVBVFRBQ0hNRU5UOiAxNyxcbiAgU09VTkQ6IDE4LFxuICBNT1ZJRTogMTksXG4gIFdJREdFVDogMjAsXG4gIFNDUkVFTjogMjEsXG4gIFBSSU5URVJNQVJLOiAyMixcbiAgVFJBUE5FVDogMjMsXG4gIFdBVEVSTUFSSzogMjQsXG4gIFRIUkVFRDogMjUsXG4gIFJFREFDVDogMjZcbn07XG5jb25zdCBBbm5vdGF0aW9uUmVwbHlUeXBlID0ge1xuICBHUk9VUDogXCJHcm91cFwiLFxuICBSRVBMWTogXCJSXCJcbn07XG5jb25zdCBBbm5vdGF0aW9uRmxhZyA9IHtcbiAgSU5WSVNJQkxFOiAweDAxLFxuICBISURERU46IDB4MDIsXG4gIFBSSU5UOiAweDA0LFxuICBOT1pPT006IDB4MDgsXG4gIE5PUk9UQVRFOiAweDEwLFxuICBOT1ZJRVc6IDB4MjAsXG4gIFJFQURPTkxZOiAweDQwLFxuICBMT0NLRUQ6IDB4ODAsXG4gIFRPR0dMRU5PVklFVzogMHgxMDAsXG4gIExPQ0tFRENPTlRFTlRTOiAweDIwMFxufTtcbmNvbnN0IEFubm90YXRpb25GaWVsZEZsYWcgPSB7XG4gIFJFQURPTkxZOiAweDAwMDAwMDEsXG4gIFJFUVVJUkVEOiAweDAwMDAwMDIsXG4gIE5PRVhQT1JUOiAweDAwMDAwMDQsXG4gIE1VTFRJTElORTogMHgwMDAxMDAwLFxuICBQQVNTV09SRDogMHgwMDAyMDAwLFxuICBOT1RPR0dMRVRPT0ZGOiAweDAwMDQwMDAsXG4gIFJBRElPOiAweDAwMDgwMDAsXG4gIFBVU0hCVVRUT046IDB4MDAxMDAwMCxcbiAgQ09NQk86IDB4MDAyMDAwMCxcbiAgRURJVDogMHgwMDQwMDAwLFxuICBTT1JUOiAweDAwODAwMDAsXG4gIEZJTEVTRUxFQ1Q6IDB4MDEwMDAwMCxcbiAgTVVMVElTRUxFQ1Q6IDB4MDIwMDAwMCxcbiAgRE9OT1RTUEVMTENIRUNLOiAweDA0MDAwMDAsXG4gIERPTk9UU0NST0xMOiAweDA4MDAwMDAsXG4gIENPTUI6IDB4MTAwMDAwMCxcbiAgUklDSFRFWFQ6IDB4MjAwMDAwMCxcbiAgUkFESU9TSU5VTklTT046IDB4MjAwMDAwMCxcbiAgQ09NTUlUT05TRUxDSEFOR0U6IDB4NDAwMDAwMFxufTtcbmNvbnN0IEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUgPSB7XG4gIFNPTElEOiAxLFxuICBEQVNIRUQ6IDIsXG4gIEJFVkVMRUQ6IDMsXG4gIElOU0VUOiA0LFxuICBVTkRFUkxJTkU6IDVcbn07XG5jb25zdCBBbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlID0ge1xuICBFOiBcIk1vdXNlIEVudGVyXCIsXG4gIFg6IFwiTW91c2UgRXhpdFwiLFxuICBEOiBcIk1vdXNlIERvd25cIixcbiAgVTogXCJNb3VzZSBVcFwiLFxuICBGbzogXCJGb2N1c1wiLFxuICBCbDogXCJCbHVyXCIsXG4gIFBPOiBcIlBhZ2VPcGVuXCIsXG4gIFBDOiBcIlBhZ2VDbG9zZVwiLFxuICBQVjogXCJQYWdlVmlzaWJsZVwiLFxuICBQSTogXCJQYWdlSW52aXNpYmxlXCIsXG4gIEs6IFwiS2V5c3Ryb2tlXCIsXG4gIEY6IFwiRm9ybWF0XCIsXG4gIFY6IFwiVmFsaWRhdGVcIixcbiAgQzogXCJDYWxjdWxhdGVcIlxufTtcbmNvbnN0IERvY3VtZW50QWN0aW9uRXZlbnRUeXBlID0ge1xuICBXQzogXCJXaWxsQ2xvc2VcIixcbiAgV1M6IFwiV2lsbFNhdmVcIixcbiAgRFM6IFwiRGlkU2F2ZVwiLFxuICBXUDogXCJXaWxsUHJpbnRcIixcbiAgRFA6IFwiRGlkUHJpbnRcIlxufTtcbmNvbnN0IFBhZ2VBY3Rpb25FdmVudFR5cGUgPSB7XG4gIE86IFwiUGFnZU9wZW5cIixcbiAgQzogXCJQYWdlQ2xvc2VcIlxufTtcbmNvbnN0IFZlcmJvc2l0eUxldmVsID0ge1xuICBFUlJPUlM6IDAsXG4gIFdBUk5JTkdTOiAxLFxuICBJTkZPUzogNVxufTtcbmNvbnN0IE9QUyA9IHtcbiAgZGVwZW5kZW5jeTogMSxcbiAgc2V0TGluZVdpZHRoOiAyLFxuICBzZXRMaW5lQ2FwOiAzLFxuICBzZXRMaW5lSm9pbjogNCxcbiAgc2V0TWl0ZXJMaW1pdDogNSxcbiAgc2V0RGFzaDogNixcbiAgc2V0UmVuZGVyaW5nSW50ZW50OiA3LFxuICBzZXRGbGF0bmVzczogOCxcbiAgc2V0R1N0YXRlOiA5LFxuICBzYXZlOiAxMCxcbiAgcmVzdG9yZTogMTEsXG4gIHRyYW5zZm9ybTogMTIsXG4gIG1vdmVUbzogMTMsXG4gIGxpbmVUbzogMTQsXG4gIGN1cnZlVG86IDE1LFxuICBjdXJ2ZVRvMjogMTYsXG4gIGN1cnZlVG8zOiAxNyxcbiAgY2xvc2VQYXRoOiAxOCxcbiAgcmVjdGFuZ2xlOiAxOSxcbiAgc3Ryb2tlOiAyMCxcbiAgY2xvc2VTdHJva2U6IDIxLFxuICBmaWxsOiAyMixcbiAgZW9GaWxsOiAyMyxcbiAgZmlsbFN0cm9rZTogMjQsXG4gIGVvRmlsbFN0cm9rZTogMjUsXG4gIGNsb3NlRmlsbFN0cm9rZTogMjYsXG4gIGNsb3NlRU9GaWxsU3Ryb2tlOiAyNyxcbiAgZW5kUGF0aDogMjgsXG4gIGNsaXA6IDI5LFxuICBlb0NsaXA6IDMwLFxuICBiZWdpblRleHQ6IDMxLFxuICBlbmRUZXh0OiAzMixcbiAgc2V0Q2hhclNwYWNpbmc6IDMzLFxuICBzZXRXb3JkU3BhY2luZzogMzQsXG4gIHNldEhTY2FsZTogMzUsXG4gIHNldExlYWRpbmc6IDM2LFxuICBzZXRGb250OiAzNyxcbiAgc2V0VGV4dFJlbmRlcmluZ01vZGU6IDM4LFxuICBzZXRUZXh0UmlzZTogMzksXG4gIG1vdmVUZXh0OiA0MCxcbiAgc2V0TGVhZGluZ01vdmVUZXh0OiA0MSxcbiAgc2V0VGV4dE1hdHJpeDogNDIsXG4gIG5leHRMaW5lOiA0MyxcbiAgc2hvd1RleHQ6IDQ0LFxuICBzaG93U3BhY2VkVGV4dDogNDUsXG4gIG5leHRMaW5lU2hvd1RleHQ6IDQ2LFxuICBuZXh0TGluZVNldFNwYWNpbmdTaG93VGV4dDogNDcsXG4gIHNldENoYXJXaWR0aDogNDgsXG4gIHNldENoYXJXaWR0aEFuZEJvdW5kczogNDksXG4gIHNldFN0cm9rZUNvbG9yU3BhY2U6IDUwLFxuICBzZXRGaWxsQ29sb3JTcGFjZTogNTEsXG4gIHNldFN0cm9rZUNvbG9yOiA1MixcbiAgc2V0U3Ryb2tlQ29sb3JOOiA1MyxcbiAgc2V0RmlsbENvbG9yOiA1NCxcbiAgc2V0RmlsbENvbG9yTjogNTUsXG4gIHNldFN0cm9rZUdyYXk6IDU2LFxuICBzZXRGaWxsR3JheTogNTcsXG4gIHNldFN0cm9rZVJHQkNvbG9yOiA1OCxcbiAgc2V0RmlsbFJHQkNvbG9yOiA1OSxcbiAgc2V0U3Ryb2tlQ01ZS0NvbG9yOiA2MCxcbiAgc2V0RmlsbENNWUtDb2xvcjogNjEsXG4gIHNoYWRpbmdGaWxsOiA2MixcbiAgYmVnaW5JbmxpbmVJbWFnZTogNjMsXG4gIGJlZ2luSW1hZ2VEYXRhOiA2NCxcbiAgZW5kSW5saW5lSW1hZ2U6IDY1LFxuICBwYWludFhPYmplY3Q6IDY2LFxuICBtYXJrUG9pbnQ6IDY3LFxuICBtYXJrUG9pbnRQcm9wczogNjgsXG4gIGJlZ2luTWFya2VkQ29udGVudDogNjksXG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzOiA3MCxcbiAgZW5kTWFya2VkQ29udGVudDogNzEsXG4gIGJlZ2luQ29tcGF0OiA3MixcbiAgZW5kQ29tcGF0OiA3MyxcbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luOiA3NCxcbiAgcGFpbnRGb3JtWE9iamVjdEVuZDogNzUsXG4gIGJlZ2luR3JvdXA6IDc2LFxuICBlbmRHcm91cDogNzcsXG4gIGJlZ2luQW5ub3RhdGlvbjogODAsXG4gIGVuZEFubm90YXRpb246IDgxLFxuICBwYWludEltYWdlTWFza1hPYmplY3Q6IDgzLFxuICBwYWludEltYWdlTWFza1hPYmplY3RHcm91cDogODQsXG4gIHBhaW50SW1hZ2VYT2JqZWN0OiA4NSxcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3Q6IDg2LFxuICBwYWludElubGluZUltYWdlWE9iamVjdEdyb3VwOiA4NyxcbiAgcGFpbnRJbWFnZVhPYmplY3RSZXBlYXQ6IDg4LFxuICBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQ6IDg5LFxuICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2s6IDkwLFxuICBjb25zdHJ1Y3RQYXRoOiA5MSxcbiAgc2V0U3Ryb2tlVHJhbnNwYXJlbnQ6IDkyLFxuICBzZXRGaWxsVHJhbnNwYXJlbnQ6IDkzLFxuICByYXdGaWxsUGF0aDogOTRcbn07XG5jb25zdCBEcmF3T1BTID0ge1xuICBtb3ZlVG86IDAsXG4gIGxpbmVUbzogMSxcbiAgY3VydmVUbzogMixcbiAgY2xvc2VQYXRoOiAzXG59O1xuY29uc3QgUGFzc3dvcmRSZXNwb25zZXMgPSB7XG4gIE5FRURfUEFTU1dPUkQ6IDEsXG4gIElOQ09SUkVDVF9QQVNTV09SRDogMlxufTtcbmxldCB2ZXJib3NpdHkgPSBWZXJib3NpdHlMZXZlbC5XQVJOSU5HUztcbmZ1bmN0aW9uIHNldFZlcmJvc2l0eUxldmVsKGxldmVsKSB7XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGxldmVsKSkge1xuICAgIHZlcmJvc2l0eSA9IGxldmVsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWZXJib3NpdHlMZXZlbCgpIHtcbiAgcmV0dXJuIHZlcmJvc2l0eTtcbn1cbmZ1bmN0aW9uIGluZm8obXNnKSB7XG4gIGlmICh2ZXJib3NpdHkgPj0gVmVyYm9zaXR5TGV2ZWwuSU5GT1MpIHtcbiAgICBjb25zb2xlLmluZm8oYEluZm86ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTKSB7XG4gICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiAke21zZ31gKTtcbiAgfVxufVxuZnVuY3Rpb24gdW5yZWFjaGFibGUobXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1zZykge1xuICBpZiAoIWNvbmQpIHtcbiAgICB1bnJlYWNoYWJsZShtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBfaXNWYWxpZFByb3RvY29sKHVybCkge1xuICBzd2l0Y2ggKHVybD8ucHJvdG9jb2wpIHtcbiAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICBjYXNlIFwiaHR0cHM6XCI6XG4gICAgY2FzZSBcImZ0cDpcIjpcbiAgICBjYXNlIFwibWFpbHRvOlwiOlxuICAgIGNhc2UgXCJ0ZWw6XCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVWYWxpZEFic29sdXRlVXJsKHVybCwgYmFzZVVybCA9IG51bGwsIG9wdGlvbnMgPSBudWxsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChvcHRpb25zLmFkZERlZmF1bHRQcm90b2NvbCAmJiB1cmwuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICAgIGNvbnN0IGRvdHMgPSB1cmwubWF0Y2goL1xcLi9nKTtcbiAgICAgIGlmIChkb3RzPy5sZW5ndGggPj0gMikge1xuICAgICAgICB1cmwgPSBgaHR0cDovLyR7dXJsfWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRyeUNvbnZlcnRFbmNvZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdXJsID0gc3RyaW5nVG9VVEY4U3RyaW5nKHVybCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICB9XG4gIGNvbnN0IGFic29sdXRlVXJsID0gYmFzZVVybCA/IFVSTC5wYXJzZSh1cmwsIGJhc2VVcmwpIDogVVJMLnBhcnNlKHVybCk7XG4gIHJldHVybiBfaXNWYWxpZFByb3RvY29sKGFic29sdXRlVXJsKSA/IGFic29sdXRlVXJsIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVVybEhhc2godXJsLCBoYXNoLCBhbGxvd1JlbCA9IGZhbHNlKSB7XG4gIGNvbnN0IHJlcyA9IFVSTC5wYXJzZSh1cmwpO1xuICBpZiAocmVzKSB7XG4gICAgcmVzLmhhc2ggPSBoYXNoO1xuICAgIHJldHVybiByZXMuaHJlZjtcbiAgfVxuICBpZiAoYWxsb3dSZWwgJiYgY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCh1cmwsIFwiaHR0cDovL2V4YW1wbGUuY29tXCIpKSB7XG4gICAgcmV0dXJuIHVybC5zcGxpdChcIiNcIiwgMSlbMF0gKyBgJHtoYXNoID8gYCMke2hhc2h9YCA6IFwiXCJ9YDtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIHNoYWRvdyhvYmosIHByb3AsIHZhbHVlLCBub25TZXJpYWxpemFibGUgPSBmYWxzZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgdmFsdWUsXG4gICAgZW51bWVyYWJsZTogIW5vblNlcmlhbGl6YWJsZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBCYXNlRXhjZXB0aW9uID0gZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIEJhc2VFeGNlcHRpb24obWVzc2FnZSwgbmFtZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuICBCYXNlRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICBCYXNlRXhjZXB0aW9uLmNvbnN0cnVjdG9yID0gQmFzZUV4Y2VwdGlvbjtcbiAgcmV0dXJuIEJhc2VFeGNlcHRpb247XG59KCk7XG5jbGFzcyBQYXNzd29yZEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGNvZGUpIHtcbiAgICBzdXBlcihtc2csIFwiUGFzc3dvcmRFeGNlcHRpb25cIik7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxuY2xhc3MgVW5rbm93bkVycm9yRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgZGV0YWlscykge1xuICAgIHN1cGVyKG1zZywgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIik7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufVxuY2xhc3MgSW52YWxpZFBERkV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiKTtcbiAgfVxufVxuY2xhc3MgUmVzcG9uc2VFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBzdGF0dXMsIG1pc3NpbmcpIHtcbiAgICBzdXBlcihtc2csIFwiUmVzcG9uc2VFeGNlcHRpb25cIik7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5taXNzaW5nID0gbWlzc2luZztcbiAgfVxufVxuY2xhc3MgRm9ybWF0RXJyb3IgZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkZvcm1hdEVycm9yXCIpO1xuICB9XG59XG5jbGFzcyBBYm9ydEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiQWJvcnRFeGNlcHRpb25cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyAhPT0gXCJvYmplY3RcIiB8fCBieXRlcz8ubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB1bnJlYWNoYWJsZShcIkludmFsaWQgYXJndW1lbnQgZm9yIGJ5dGVzVG9TdHJpbmdcIik7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICBjb25zdCBNQVhfQVJHVU1FTlRfQ09VTlQgPSA4MTkyO1xuICBpZiAobGVuZ3RoIDwgTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpO1xuICB9XG4gIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICBjb25zdCBjaHVua0VuZCA9IE1hdGgubWluKGkgKyBNQVhfQVJHVU1FTlRfQ09VTlQsIGxlbmd0aCk7XG4gICAgY29uc3QgY2h1bmsgPSBieXRlcy5zdWJhcnJheShpLCBjaHVua0VuZCk7XG4gICAgc3RyQnVmLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjaHVuaykpO1xuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdW5yZWFjaGFibGUoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBzdHJpbmdUb0J5dGVzXCIpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzW2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIHN0cmluZzMyKHZhbHVlKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlID4+IDI0ICYgMHhmZiwgdmFsdWUgPj4gMTYgJiAweGZmLCB2YWx1ZSA+PiA4ICYgMHhmZiwgdmFsdWUgJiAweGZmKTtcbn1cbmZ1bmN0aW9uIG9iamVjdFNpemUob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzTGl0dGxlRW5kaWFuKCkge1xuICBjb25zdCBidWZmZXI4ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGJ1ZmZlcjhbMF0gPSAxO1xuICBjb25zdCB2aWV3MzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyOC5idWZmZXIsIDAsIDEpO1xuICByZXR1cm4gdmlldzMyWzBdID09PSAxO1xufVxuZnVuY3Rpb24gaXNFdmFsU3VwcG9ydGVkKCkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihcIlwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyB1dGlsX0ZlYXR1cmVUZXN0IHtcbiAgc3RhdGljIGdldCBpc0xpdHRsZUVuZGlhbigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNMaXR0bGVFbmRpYW5cIiwgaXNMaXR0bGVFbmRpYW4oKSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0V2YWxTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzRXZhbFN1cHBvcnRlZFwiLCBpc0V2YWxTdXBwb3J0ZWQoKSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWRcIiwgdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCBpc0ltYWdlRGVjb2RlclN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNJbWFnZURlY29kZXJTdXBwb3J0ZWRcIiwgdHlwZW9mIEltYWdlRGVjb2RlciAhPT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCBwbGF0Zm9ybSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIHVzZXJBZ2VudFxuICAgIH0gPSBuYXZpZ2F0b3I7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInBsYXRmb3JtXCIsIHtcbiAgICAgIGlzQW5kcm9pZDogdXNlckFnZW50LmluY2x1ZGVzKFwiQW5kcm9pZFwiKSxcbiAgICAgIGlzTGludXg6IHBsYXRmb3JtLmluY2x1ZGVzKFwiTGludXhcIiksXG4gICAgICBpc01hYzogcGxhdGZvcm0uaW5jbHVkZXMoXCJNYWNcIiksXG4gICAgICBpc1dpbmRvd3M6IHBsYXRmb3JtLmluY2x1ZGVzKFwiV2luXCIpLFxuICAgICAgaXNGaXJlZm94OiB1c2VyQWdlbnQuaW5jbHVkZXMoXCJGaXJlZm94XCIpXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0NTU1JvdW5kU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0NTU1JvdW5kU3VwcG9ydGVkXCIsIGdsb2JhbFRoaXMuQ1NTPy5zdXBwb3J0cz8uKFwid2lkdGg6IHJvdW5kKDEuNXB4LCAxcHgpXCIpKTtcbiAgfVxufVxuY29uc3QgaGV4TnVtYmVycyA9IEFycmF5LmZyb20oQXJyYXkoMjU2KS5rZXlzKCksIG4gPT4gbi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcbmNsYXNzIFV0aWwge1xuICBzdGF0aWMgbWFrZUhleENvbG9yKHIsIGcsIGIpIHtcbiAgICByZXR1cm4gYCMke2hleE51bWJlcnNbcl19JHtoZXhOdW1iZXJzW2ddfSR7aGV4TnVtYmVyc1tiXX1gO1xuICB9XG4gIHN0YXRpYyBkb21NYXRyaXhUb1RyYW5zZm9ybShkbSkge1xuICAgIHJldHVybiBbZG0uYSwgZG0uYiwgZG0uYywgZG0uZCwgZG0uZSwgZG0uZl07XG4gIH1cbiAgc3RhdGljIHNjYWxlTWluTWF4KHRyYW5zZm9ybSwgbWluTWF4KSB7XG4gICAgbGV0IHRlbXA7XG4gICAgaWYgKHRyYW5zZm9ybVswXSkge1xuICAgICAgaWYgKHRyYW5zZm9ybVswXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFswXTtcbiAgICAgICAgbWluTWF4WzBdID0gbWluTWF4WzJdO1xuICAgICAgICBtaW5NYXhbMl0gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzBdICo9IHRyYW5zZm9ybVswXTtcbiAgICAgIG1pbk1heFsyXSAqPSB0cmFuc2Zvcm1bMF07XG4gICAgICBpZiAodHJhbnNmb3JtWzNdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzFdO1xuICAgICAgICBtaW5NYXhbMV0gPSBtaW5NYXhbM107XG4gICAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMV0gKj0gdHJhbnNmb3JtWzNdO1xuICAgICAgbWluTWF4WzNdICo9IHRyYW5zZm9ybVszXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcCA9IG1pbk1heFswXTtcbiAgICAgIG1pbk1heFswXSA9IG1pbk1heFsxXTtcbiAgICAgIG1pbk1heFsxXSA9IHRlbXA7XG4gICAgICB0ZW1wID0gbWluTWF4WzJdO1xuICAgICAgbWluTWF4WzJdID0gbWluTWF4WzNdO1xuICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMV0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMV07XG4gICAgICAgIG1pbk1heFsxXSA9IG1pbk1heFszXTtcbiAgICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFsxXSAqPSB0cmFuc2Zvcm1bMV07XG4gICAgICBtaW5NYXhbM10gKj0gdHJhbnNmb3JtWzFdO1xuICAgICAgaWYgKHRyYW5zZm9ybVsyXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFswXTtcbiAgICAgICAgbWluTWF4WzBdID0gbWluTWF4WzJdO1xuICAgICAgICBtaW5NYXhbMl0gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzBdICo9IHRyYW5zZm9ybVsyXTtcbiAgICAgIG1pbk1heFsyXSAqPSB0cmFuc2Zvcm1bMl07XG4gICAgfVxuICAgIG1pbk1heFswXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzFdICs9IHRyYW5zZm9ybVs1XTtcbiAgICBtaW5NYXhbMl0gKz0gdHJhbnNmb3JtWzRdO1xuICAgIG1pbk1heFszXSArPSB0cmFuc2Zvcm1bNV07XG4gIH1cbiAgc3RhdGljIHRyYW5zZm9ybShtMSwgbTIpIHtcbiAgICByZXR1cm4gW20xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdLCBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXSwgbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM10sIG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdLCBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdLCBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdXTtcbiAgfVxuICBzdGF0aWMgbXVsdGlwbHlCeURPTU1hdHJpeChtLCBtZCkge1xuICAgIHJldHVybiBbbVswXSAqIG1kLmEgKyBtWzJdICogbWQuYiwgbVsxXSAqIG1kLmEgKyBtWzNdICogbWQuYiwgbVswXSAqIG1kLmMgKyBtWzJdICogbWQuZCwgbVsxXSAqIG1kLmMgKyBtWzNdICogbWQuZCwgbVswXSAqIG1kLmUgKyBtWzJdICogbWQuZiArIG1bNF0sIG1bMV0gKiBtZC5lICsgbVszXSAqIG1kLmYgKyBtWzVdXTtcbiAgfVxuICBzdGF0aWMgYXBwbHlUcmFuc2Zvcm0ocCwgbSwgcG9zID0gMCkge1xuICAgIGNvbnN0IHAwID0gcFtwb3NdO1xuICAgIGNvbnN0IHAxID0gcFtwb3MgKyAxXTtcbiAgICBwW3Bvc10gPSBwMCAqIG1bMF0gKyBwMSAqIG1bMl0gKyBtWzRdO1xuICAgIHBbcG9zICsgMV0gPSBwMCAqIG1bMV0gKyBwMSAqIG1bM10gKyBtWzVdO1xuICB9XG4gIHN0YXRpYyBhcHBseVRyYW5zZm9ybVRvQmV6aWVyKHAsIHRyYW5zZm9ybSwgcG9zID0gMCkge1xuICAgIGNvbnN0IG0wID0gdHJhbnNmb3JtWzBdO1xuICAgIGNvbnN0IG0xID0gdHJhbnNmb3JtWzFdO1xuICAgIGNvbnN0IG0yID0gdHJhbnNmb3JtWzJdO1xuICAgIGNvbnN0IG0zID0gdHJhbnNmb3JtWzNdO1xuICAgIGNvbnN0IG00ID0gdHJhbnNmb3JtWzRdO1xuICAgIGNvbnN0IG01ID0gdHJhbnNmb3JtWzVdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSArPSAyKSB7XG4gICAgICBjb25zdCBwSSA9IHBbcG9zICsgaV07XG4gICAgICBjb25zdCBwSTEgPSBwW3BvcyArIGkgKyAxXTtcbiAgICAgIHBbcG9zICsgaV0gPSBwSSAqIG0wICsgcEkxICogbTIgKyBtNDtcbiAgICAgIHBbcG9zICsgaSArIDFdID0gcEkgKiBtMSArIHBJMSAqIG0zICsgbTU7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgbSkge1xuICAgIGNvbnN0IHAwID0gcFswXTtcbiAgICBjb25zdCBwMSA9IHBbMV07XG4gICAgY29uc3QgZCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XG4gICAgcFswXSA9IChwMCAqIG1bM10gLSBwMSAqIG1bMl0gKyBtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQ7XG4gICAgcFsxXSA9ICgtcDAgKiBtWzFdICsgcDEgKiBtWzBdICsgbVs0XSAqIG1bMV0gLSBtWzVdICogbVswXSkgLyBkO1xuICB9XG4gIHN0YXRpYyBheGlhbEFsaWduZWRCb3VuZGluZ0JveChyZWN0LCB0cmFuc2Zvcm0sIG91dHB1dCkge1xuICAgIGNvbnN0IG0wID0gdHJhbnNmb3JtWzBdO1xuICAgIGNvbnN0IG0xID0gdHJhbnNmb3JtWzFdO1xuICAgIGNvbnN0IG0yID0gdHJhbnNmb3JtWzJdO1xuICAgIGNvbnN0IG0zID0gdHJhbnNmb3JtWzNdO1xuICAgIGNvbnN0IG00ID0gdHJhbnNmb3JtWzRdO1xuICAgIGNvbnN0IG01ID0gdHJhbnNmb3JtWzVdO1xuICAgIGNvbnN0IHIwID0gcmVjdFswXTtcbiAgICBjb25zdCByMSA9IHJlY3RbMV07XG4gICAgY29uc3QgcjIgPSByZWN0WzJdO1xuICAgIGNvbnN0IHIzID0gcmVjdFszXTtcbiAgICBsZXQgYTAgPSBtMCAqIHIwICsgbTQ7XG4gICAgbGV0IGEyID0gYTA7XG4gICAgbGV0IGExID0gbTAgKiByMiArIG00O1xuICAgIGxldCBhMyA9IGExO1xuICAgIGxldCBiMCA9IG0zICogcjEgKyBtNTtcbiAgICBsZXQgYjIgPSBiMDtcbiAgICBsZXQgYjEgPSBtMyAqIHIzICsgbTU7XG4gICAgbGV0IGIzID0gYjE7XG4gICAgaWYgKG0xICE9PSAwIHx8IG0yICE9PSAwKSB7XG4gICAgICBjb25zdCBtMXIwID0gbTEgKiByMDtcbiAgICAgIGNvbnN0IG0xcjIgPSBtMSAqIHIyO1xuICAgICAgY29uc3QgbTJyMSA9IG0yICogcjE7XG4gICAgICBjb25zdCBtMnIzID0gbTIgKiByMztcbiAgICAgIGEwICs9IG0ycjE7XG4gICAgICBhMyArPSBtMnIxO1xuICAgICAgYTEgKz0gbTJyMztcbiAgICAgIGEyICs9IG0ycjM7XG4gICAgICBiMCArPSBtMXIwO1xuICAgICAgYjMgKz0gbTFyMDtcbiAgICAgIGIxICs9IG0xcjI7XG4gICAgICBiMiArPSBtMXIyO1xuICAgIH1cbiAgICBvdXRwdXRbMF0gPSBNYXRoLm1pbihvdXRwdXRbMF0sIGEwLCBhMSwgYTIsIGEzKTtcbiAgICBvdXRwdXRbMV0gPSBNYXRoLm1pbihvdXRwdXRbMV0sIGIwLCBiMSwgYjIsIGIzKTtcbiAgICBvdXRwdXRbMl0gPSBNYXRoLm1heChvdXRwdXRbMl0sIGEwLCBhMSwgYTIsIGEzKTtcbiAgICBvdXRwdXRbM10gPSBNYXRoLm1heChvdXRwdXRbM10sIGIwLCBiMSwgYjIsIGIzKTtcbiAgfVxuICBzdGF0aWMgaW52ZXJzZVRyYW5zZm9ybShtKSB7XG4gICAgY29uc3QgZCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XG4gICAgcmV0dXJuIFttWzNdIC8gZCwgLW1bMV0gLyBkLCAtbVsyXSAvIGQsIG1bMF0gLyBkLCAobVsyXSAqIG1bNV0gLSBtWzRdICogbVszXSkgLyBkLCAobVs0XSAqIG1bMV0gLSBtWzVdICogbVswXSkgLyBkXTtcbiAgfVxuICBzdGF0aWMgc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUobWF0cml4LCBvdXRwdXQpIHtcbiAgICBjb25zdCBtMCA9IG1hdHJpeFswXTtcbiAgICBjb25zdCBtMSA9IG1hdHJpeFsxXTtcbiAgICBjb25zdCBtMiA9IG1hdHJpeFsyXTtcbiAgICBjb25zdCBtMyA9IG1hdHJpeFszXTtcbiAgICBjb25zdCBhID0gbTAgKiogMiArIG0xICoqIDI7XG4gICAgY29uc3QgYiA9IG0wICogbTIgKyBtMSAqIG0zO1xuICAgIGNvbnN0IGMgPSBtMiAqKiAyICsgbTMgKiogMjtcbiAgICBjb25zdCBmaXJzdCA9IChhICsgYykgLyAyO1xuICAgIGNvbnN0IHNlY29uZCA9IE1hdGguc3FydChmaXJzdCAqKiAyIC0gKGEgKiBjIC0gYiAqKiAyKSk7XG4gICAgb3V0cHV0WzBdID0gTWF0aC5zcXJ0KGZpcnN0ICsgc2Vjb25kIHx8IDEpO1xuICAgIG91dHB1dFsxXSA9IE1hdGguc3FydChmaXJzdCAtIHNlY29uZCB8fCAxKTtcbiAgfVxuICBzdGF0aWMgbm9ybWFsaXplUmVjdChyZWN0KSB7XG4gICAgY29uc3QgciA9IHJlY3Quc2xpY2UoMCk7XG4gICAgaWYgKHJlY3RbMF0gPiByZWN0WzJdKSB7XG4gICAgICByWzBdID0gcmVjdFsyXTtcbiAgICAgIHJbMl0gPSByZWN0WzBdO1xuICAgIH1cbiAgICBpZiAocmVjdFsxXSA+IHJlY3RbM10pIHtcbiAgICAgIHJbMV0gPSByZWN0WzNdO1xuICAgICAgclszXSA9IHJlY3RbMV07XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHN0YXRpYyBpbnRlcnNlY3QocmVjdDEsIHJlY3QyKSB7XG4gICAgY29uc3QgeExvdyA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QxWzBdLCByZWN0MVsyXSksIE1hdGgubWluKHJlY3QyWzBdLCByZWN0MlsyXSkpO1xuICAgIGNvbnN0IHhIaWdoID0gTWF0aC5taW4oTWF0aC5tYXgocmVjdDFbMF0sIHJlY3QxWzJdKSwgTWF0aC5tYXgocmVjdDJbMF0sIHJlY3QyWzJdKSk7XG4gICAgaWYgKHhMb3cgPiB4SGlnaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHlMb3cgPSBNYXRoLm1heChNYXRoLm1pbihyZWN0MVsxXSwgcmVjdDFbM10pLCBNYXRoLm1pbihyZWN0MlsxXSwgcmVjdDJbM10pKTtcbiAgICBjb25zdCB5SGlnaCA9IE1hdGgubWluKE1hdGgubWF4KHJlY3QxWzFdLCByZWN0MVszXSksIE1hdGgubWF4KHJlY3QyWzFdLCByZWN0MlszXSkpO1xuICAgIGlmICh5TG93ID4geUhpZ2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gW3hMb3csIHlMb3csIHhIaWdoLCB5SGlnaF07XG4gIH1cbiAgc3RhdGljIHBvaW50Qm91bmRpbmdCb3goeCwgeSwgbWluTWF4KSB7XG4gICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCB4KTtcbiAgICBtaW5NYXhbMV0gPSBNYXRoLm1pbihtaW5NYXhbMV0sIHkpO1xuICAgIG1pbk1heFsyXSA9IE1hdGgubWF4KG1pbk1heFsyXSwgeCk7XG4gICAgbWluTWF4WzNdID0gTWF0aC5tYXgobWluTWF4WzNdLCB5KTtcbiAgfVxuICBzdGF0aWMgcmVjdEJvdW5kaW5nQm94KHgwLCB5MCwgeDEsIHkxLCBtaW5NYXgpIHtcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgwLCB4MSk7XG4gICAgbWluTWF4WzFdID0gTWF0aC5taW4obWluTWF4WzFdLCB5MCwgeTEpO1xuICAgIG1pbk1heFsyXSA9IE1hdGgubWF4KG1pbk1heFsyXSwgeDAsIHgxKTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkwLCB5MSk7XG4gIH1cbiAgc3RhdGljICNnZXRFeHRyZW11bU9uQ3VydmUoeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCB0LCBtaW5NYXgpIHtcbiAgICBpZiAodCA8PSAwIHx8IHQgPj0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtdCA9IDEgLSB0O1xuICAgIGNvbnN0IHR0ID0gdCAqIHQ7XG4gICAgY29uc3QgdHR0ID0gdHQgKiB0O1xuICAgIGNvbnN0IHggPSBtdCAqIChtdCAqIChtdCAqIHgwICsgMyAqIHQgKiB4MSkgKyAzICogdHQgKiB4MikgKyB0dHQgKiB4MztcbiAgICBjb25zdCB5ID0gbXQgKiAobXQgKiAobXQgKiB5MCArIDMgKiB0ICogeTEpICsgMyAqIHR0ICogeTIpICsgdHR0ICogeTM7XG4gICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCB4KTtcbiAgICBtaW5NYXhbMV0gPSBNYXRoLm1pbihtaW5NYXhbMV0sIHkpO1xuICAgIG1pbk1heFsyXSA9IE1hdGgubWF4KG1pbk1heFsyXSwgeCk7XG4gICAgbWluTWF4WzNdID0gTWF0aC5tYXgobWluTWF4WzNdLCB5KTtcbiAgfVxuICBzdGF0aWMgI2dldEV4dHJlbXVtKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgYSwgYiwgYywgbWluTWF4KSB7XG4gICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgIGlmIChNYXRoLmFicyhiKSA+PSAxZS0xMikge1xuICAgICAgICB0aGlzLiNnZXRFeHRyZW11bU9uQ3VydmUoeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAtYyAvIGIsIG1pbk1heCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhID0gYiAqKiAyIC0gNCAqIGMgKiBhO1xuICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3FydERlbHRhID0gTWF0aC5zcXJ0KGRlbHRhKTtcbiAgICBjb25zdCBhMiA9IDIgKiBhO1xuICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsICgtYiArIHNxcnREZWx0YSkgLyBhMiwgbWluTWF4KTtcbiAgICB0aGlzLiNnZXRFeHRyZW11bU9uQ3VydmUoeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAoLWIgLSBzcXJ0RGVsdGEpIC8gYTIsIG1pbk1heCk7XG4gIH1cbiAgc3RhdGljIGJlemllckJvdW5kaW5nQm94KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbWluTWF4KSB7XG4gICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCB4MCwgeDMpO1xuICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeTAsIHkzKTtcbiAgICBtaW5NYXhbMl0gPSBNYXRoLm1heChtaW5NYXhbMl0sIHgwLCB4Myk7XG4gICAgbWluTWF4WzNdID0gTWF0aC5tYXgobWluTWF4WzNdLCB5MCwgeTMpO1xuICAgIHRoaXMuI2dldEV4dHJlbXVtKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgMyAqICgteDAgKyAzICogKHgxIC0geDIpICsgeDMpLCA2ICogKHgwIC0gMiAqIHgxICsgeDIpLCAzICogKHgxIC0geDApLCBtaW5NYXgpO1xuICAgIHRoaXMuI2dldEV4dHJlbXVtKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgMyAqICgteTAgKyAzICogKHkxIC0geTIpICsgeTMpLCA2ICogKHkwIC0gMiAqIHkxICsgeTIpLCAzICogKHkxIC0geTApLCBtaW5NYXgpO1xuICB9XG59XG5jb25zdCBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSA9ICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDJkOCwgMHgyYzcsIDB4MmM2LCAweDJkOSwgMHgyZGQsIDB4MmRiLCAweDJkYSwgMHgyZGMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MjAyMiwgMHgyMDIwLCAweDIwMjEsIDB4MjAyNiwgMHgyMDE0LCAweDIwMTMsIDB4MTkyLCAweDIwNDQsIDB4MjAzOSwgMHgyMDNhLCAweDIyMTIsIDB4MjAzMCwgMHgyMDFlLCAweDIwMWMsIDB4MjAxZCwgMHgyMDE4LCAweDIwMTksIDB4MjAxYSwgMHgyMTIyLCAweGZiMDEsIDB4ZmIwMiwgMHgxNDEsIDB4MTUyLCAweDE2MCwgMHgxNzgsIDB4MTdkLCAweDEzMSwgMHgxNDIsIDB4MTUzLCAweDE2MSwgMHgxN2UsIDAsIDB4MjBhY10pKTtcbmZ1bmN0aW9uIHN0cmluZ1RvUERGU3RyaW5nKHN0ciwga2VlcEVzY2FwZVNlcXVlbmNlID0gZmFsc2UpIHtcbiAgaWYgKHN0clswXSA+PSBcIlxceEVGXCIpIHtcbiAgICBsZXQgZW5jb2Rpbmc7XG4gICAgaWYgKHN0clswXSA9PT0gXCJcXHhGRVwiICYmIHN0clsxXSA9PT0gXCJcXHhGRlwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLTE2YmVcIjtcbiAgICAgIGlmIChzdHIubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyWzBdID09PSBcIlxceEZGXCIgJiYgc3RyWzFdID09PSBcIlxceEZFXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtMTZsZVwiO1xuICAgICAgaWYgKHN0ci5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RUZcIiAmJiBzdHJbMV0gPT09IFwiXFx4QkJcIiAmJiBzdHJbMl0gPT09IFwiXFx4QkZcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi04XCI7XG4gICAgfVxuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywge1xuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBzdHJpbmdUb0J5dGVzKHN0cik7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgICBpZiAoa2VlcEVzY2FwZVNlcXVlbmNlIHx8ICFkZWNvZGVkLmluY2x1ZGVzKFwiXFx4MWJcIikpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb2RlZC5yZXBsYWNlQWxsKC9cXHgxYlteXFx4MWJdKig/OlxceDFifCQpL2csIFwiXCIpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgd2Fybihgc3RyaW5nVG9QREZTdHJpbmc6IFwiJHtleH1cIi5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgc3RyQnVmID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHN0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgY29uc3QgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoIWtlZXBFc2NhcGVTZXF1ZW5jZSAmJiBjaGFyQ29kZSA9PT0gMHgxYikge1xuICAgICAgd2hpbGUgKCsraSA8IGlpICYmIHN0ci5jaGFyQ29kZUF0KGkpICE9PSAweDFiKSB7fVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZVtjaGFyQ29kZV07XG4gICAgc3RyQnVmLnB1c2goY29kZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgOiBzdHIuY2hhckF0KGkpKTtcbiAgfVxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb1VURjhTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cikpO1xufVxuZnVuY3Rpb24gdXRmOFN0cmluZ1RvU3RyaW5nKHN0cikge1xuICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufVxuZnVuY3Rpb24gaXNBcnJheUVxdWFsKGFycjEsIGFycjIpIHtcbiAgaWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcnIxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldE1vZGlmaWNhdGlvbkRhdGUoZGF0ZSA9IG5ldyBEYXRlKCkpIHtcbiAgaWYgKCEoZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IFtkYXRlLmdldFVUQ0Z1bGxZZWFyKCkudG9TdHJpbmcoKSwgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0RhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENIb3VycygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ01pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENTZWNvbmRzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIildO1xuICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcIik7XG59XG5sZXQgTm9ybWFsaXplUmVnZXggPSBudWxsO1xubGV0IE5vcm1hbGl6YXRpb25NYXAgPSBudWxsO1xuZnVuY3Rpb24gbm9ybWFsaXplVW5pY29kZShzdHIpIHtcbiAgaWYgKCFOb3JtYWxpemVSZWdleCkge1xuICAgIE5vcm1hbGl6ZVJlZ2V4ID0gLyhbXFx1MDBhMFxcdTAwYjVcXHUwMzdlXFx1MGViM1xcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMTI2XFx1ZmIwMC1cXHVmYjA0XFx1ZmIwNlxcdWZiMjAtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiYTFcXHVmYmE0LVxcdWZiYTlcXHVmYmFlLVxcdWZiYjFcXHVmYmQzLVxcdWZiZGNcXHVmYmRlLVxcdWZiZTdcXHVmYmVhLVxcdWZiZjhcXHVmYmZjLVxcdWZiZmRcXHVmYzAwLVxcdWZjNWRcXHVmYzY0LVxcdWZjZjFcXHVmY2Y1LVxcdWZkM2RcXHVmZDg4XFx1ZmRmNFxcdWZkZmEtXFx1ZmRmYlxcdWZlNzFcXHVmZTc3XFx1ZmU3OVxcdWZlN2JcXHVmZTdkXSspfChcXHVmYjA1KykvZ3U7XG4gICAgTm9ybWFsaXphdGlvbk1hcCA9IG5ldyBNYXAoW1tcIu+shVwiLCBcIsW/dFwiXV0pO1xuICB9XG4gIHJldHVybiBzdHIucmVwbGFjZUFsbChOb3JtYWxpemVSZWdleCwgKF8sIHAxLCBwMikgPT4gcDEgPyBwMS5ub3JtYWxpemUoXCJORktDXCIpIDogTm9ybWFsaXphdGlvbk1hcC5nZXQocDIpKTtcbn1cbmZ1bmN0aW9uIGdldFV1aWQoKSB7XG4gIGlmICh0eXBlb2YgY3J5cHRvLnJhbmRvbVVVSUQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICB9XG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhidWYpO1xuICByZXR1cm4gYnl0ZXNUb1N0cmluZyhidWYpO1xufVxuY29uc3QgQW5ub3RhdGlvblByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfaWRfXCI7XG5mdW5jdGlvbiBfaXNWYWxpZEV4cGxpY2l0RGVzdCh2YWxpZFJlZiwgdmFsaWROYW1lLCBkZXN0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShkZXN0KSB8fCBkZXN0Lmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgW3BhZ2UsIHpvb20sIC4uLmFyZ3NdID0gZGVzdDtcbiAgaWYgKCF2YWxpZFJlZihwYWdlKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihwYWdlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIXZhbGlkTmFtZSh6b29tKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIGxldCBhbGxvd051bGwgPSB0cnVlO1xuICBzd2l0Y2ggKHpvb20ubmFtZSkge1xuICAgIGNhc2UgXCJYWVpcIjpcbiAgICAgIGlmIChhcmdzTGVuIDwgMiB8fCBhcmdzTGVuID4gMykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRml0XCI6XG4gICAgY2FzZSBcIkZpdEJcIjpcbiAgICAgIHJldHVybiBhcmdzTGVuID09PSAwO1xuICAgIGNhc2UgXCJGaXRIXCI6XG4gICAgY2FzZSBcIkZpdEJIXCI6XG4gICAgY2FzZSBcIkZpdFZcIjpcbiAgICBjYXNlIFwiRml0QlZcIjpcbiAgICAgIGlmIChhcmdzTGVuID4gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRml0UlwiOlxuICAgICAgaWYgKGFyZ3NMZW4gIT09IDQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYWxsb3dOdWxsID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIiB8fCBhbGxvd051bGwgJiYgYXJnID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gTWF0aENsYW1wKHYsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xufVxuZnVuY3Rpb24gdG9IZXhVdGlsKGFycikge1xuICBpZiAoVWludDhBcnJheS5wcm90b3R5cGUudG9IZXgpIHtcbiAgICByZXR1cm4gYXJyLnRvSGV4KCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oYXJyLCBudW0gPT4gaGV4TnVtYmVyc1tudW1dKS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gdG9CYXNlNjRVdGlsKGFycikge1xuICBpZiAoVWludDhBcnJheS5wcm90b3R5cGUudG9CYXNlNjQpIHtcbiAgICByZXR1cm4gYXJyLnRvQmFzZTY0KCk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EoYnl0ZXNUb1N0cmluZyhhcnIpKTtcbn1cbmZ1bmN0aW9uIGZyb21CYXNlNjRVdGlsKHN0cikge1xuICBpZiAoVWludDhBcnJheS5mcm9tQmFzZTY0KSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUJhc2U2NChzdHIpO1xuICB9XG4gIHJldHVybiBzdHJpbmdUb0J5dGVzKGF0b2Ioc3RyKSk7XG59XG5pZiAodHlwZW9mIE1hdGguc3VtUHJlY2lzZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIE1hdGguc3VtUHJlY2lzZSA9IGZ1bmN0aW9uIChudW1iZXJzKSB7XG4gICAgcmV0dXJuIG51bWJlcnMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gIH07XG59XG5pZiAodHlwZW9mIEFib3J0U2lnbmFsLmFueSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIEFib3J0U2lnbmFsLmFueSA9IGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hbFxuICAgIH0gPSBhYztcbiAgICBmb3IgKGNvbnN0IHMgb2YgaXRlcmFibGUpIHtcbiAgICAgIGlmIChzLmFib3J0ZWQpIHtcbiAgICAgICAgYWMuYWJvcnQocy5yZWFzb24pO1xuICAgICAgICByZXR1cm4gc2lnbmFsO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHMgb2YgaXRlcmFibGUpIHtcbiAgICAgIHMuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgYWMuYWJvcnQocy5yZWFzb24pO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2lnbmFsO1xuICB9O1xufVxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5pdGVyYXRvci5tYXAuanNcbnZhciBlc19pdGVyYXRvcl9tYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MDEpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnVybC1zZWFyY2gtcGFyYW1zLmRlbGV0ZS5qc1xudmFyIHdlYl91cmxfc2VhcmNoX3BhcmFtc19kZWxldGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2MDMpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnVybC1zZWFyY2gtcGFyYW1zLmhhcy5qc1xudmFyIHdlYl91cmxfc2VhcmNoX3BhcmFtc19oYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1NjYpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnVybC1zZWFyY2gtcGFyYW1zLnNpemUuanNcbnZhciB3ZWJfdXJsX3NlYXJjaF9wYXJhbXNfc2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oODcyMSk7XG47Ly8gLi9zcmMvZGlzcGxheS94ZmFfdGV4dC5qc1xuXG5jbGFzcyBYZmFUZXh0IHtcbiAgc3RhdGljIHRleHRDb250ZW50KHhmYSkge1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgaXRlbXMsXG4gICAgICBzdHlsZXM6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdhbGsobm9kZSkge1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzdHIgPSBudWxsO1xuICAgICAgY29uc3QgbmFtZSA9IG5vZGUubmFtZTtcbiAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgc3RyID0gbm9kZS52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIVhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobm9kZT8uYXR0cmlidXRlcz8udGV4dENvbnRlbnQpIHtcbiAgICAgICAgc3RyID0gbm9kZS5hdHRyaWJ1dGVzLnRleHRDb250ZW50O1xuICAgICAgfSBlbHNlIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RyICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgIHN0clxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgd2FsayhjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHdhbGsoeGZhKTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHN0YXRpYyBzaG91bGRCdWlsZFRleHQobmFtZSkge1xuICAgIHJldHVybiAhKG5hbWUgPT09IFwidGV4dGFyZWFcIiB8fCBuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJvcHRpb25cIiB8fCBuYW1lID09PSBcInNlbGVjdFwiKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS94ZmFfbGF5ZXIuanNcblxuXG5jbGFzcyBYZmFMYXllciB7XG4gIHN0YXRpYyBzZXR1cFN0b3JhZ2UoaHRtbCwgaWQsIGVsZW1lbnQsIHN0b3JhZ2UsIGludGVudCkge1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0pO1xuICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBodG1sLnRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgaWYgKGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIgfHwgZWxlbWVudC5hdHRyaWJ1dGVzLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT24pIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0b3JlZERhdGEudmFsdWUgPT09IGVsZW1lbnQuYXR0cmlidXRlcy54ZmFPZmYpIHtcbiAgICAgICAgICAgIGh0bWwucmVtb3ZlQXR0cmlidXRlKFwiY2hlY2tlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkID8gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9uXCIpIDogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9mZlwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBzdG9yZWREYXRhLnZhbHVlKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBlbGVtZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uLmF0dHJpYnV0ZXMudmFsdWUgPT09IHN0b3JlZERhdGEudmFsdWUpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLmF0dHJpYnV0ZXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb24uYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShcInNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb24uYXR0cmlidXRlcy5zZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC50YXJnZXQub3B0aW9ucztcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBcIlwiIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIHNldEF0dHJpYnV0ZXMoe1xuICAgIGh0bWwsXG4gICAgZWxlbWVudCxcbiAgICBzdG9yYWdlID0gbnVsbCxcbiAgICBpbnRlbnQsXG4gICAgbGlua1NlcnZpY2VcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9ID0gZWxlbWVudDtcbiAgICBjb25zdCBpc0hUTUxBbmNob3JFbGVtZW50ID0gaHRtbCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50O1xuICAgIGlmIChhdHRyaWJ1dGVzLnR5cGUgPT09IFwicmFkaW9cIikge1xuICAgICAgYXR0cmlidXRlcy5uYW1lID0gYCR7YXR0cmlidXRlcy5uYW1lfS0ke2ludGVudH1gO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSkge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRhSWRcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGh0bWwuc3R5bGUsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghaXNIVE1MQW5jaG9yRWxlbWVudCB8fCBrZXkgIT09IFwiaHJlZlwiICYmIGtleSAhPT0gXCJuZXdXaW5kb3dcIikge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNIVE1MQW5jaG9yRWxlbWVudCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMoaHRtbCwgYXR0cmlidXRlcy5ocmVmLCBhdHRyaWJ1dGVzLm5ld1dpbmRvdyk7XG4gICAgfVxuICAgIGlmIChzdG9yYWdlICYmIGF0dHJpYnV0ZXMuZGF0YUlkKSB7XG4gICAgICB0aGlzLnNldHVwU3RvcmFnZShodG1sLCBhdHRyaWJ1dGVzLmRhdGFJZCwgZWxlbWVudCwgc3RvcmFnZSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyByZW5kZXIocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGxpbmtTZXJ2aWNlID0gcGFyYW1ldGVycy5saW5rU2VydmljZTtcbiAgICBjb25zdCByb290ID0gcGFyYW1ldGVycy54ZmFIdG1sO1xuICAgIGNvbnN0IGludGVudCA9IHBhcmFtZXRlcnMuaW50ZW50IHx8IFwiZGlzcGxheVwiO1xuICAgIGNvbnN0IHJvb3RIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChyb290Lm5hbWUpO1xuICAgIGlmIChyb290LmF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgIGh0bWw6IHJvb3RIdG1sLFxuICAgICAgICBlbGVtZW50OiByb290LFxuICAgICAgICBpbnRlbnQsXG4gICAgICAgIGxpbmtTZXJ2aWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgaXNOb3RGb3JSaWNoVGV4dCA9IGludGVudCAhPT0gXCJyaWNoVGV4dFwiO1xuICAgIGNvbnN0IHJvb3REaXYgPSBwYXJhbWV0ZXJzLmRpdjtcbiAgICByb290RGl2LmFwcGVuZChyb290SHRtbCk7XG4gICAgaWYgKHBhcmFtZXRlcnMudmlld3BvcnQpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGBtYXRyaXgoJHtwYXJhbWV0ZXJzLnZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKFwiLFwiKX0pYDtcbiAgICAgIHJvb3REaXYuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgICBpZiAoaXNOb3RGb3JSaWNoVGV4dCkge1xuICAgICAgcm9vdERpdi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInhmYUxheWVyIHhmYUZvbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHRleHREaXZzID0gW107XG4gICAgaWYgKHJvb3QuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocm9vdC52YWx1ZSk7XG4gICAgICAgIHJvb3RIdG1sLmFwcGVuZChub2RlKTtcbiAgICAgICAgaWYgKGlzTm90Rm9yUmljaFRleHQgJiYgWGZhVGV4dC5zaG91bGRCdWlsZFRleHQocm9vdC5uYW1lKSkge1xuICAgICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHREaXZzXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IFtbcm9vdCwgLTEsIHJvb3RIdG1sXV07XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IFtwYXJlbnQsIGksIGh0bWxdID0gc3RhY2suYXQoLTEpO1xuICAgICAgaWYgKGkgKyAxID09PSBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuWysrc3RhY2suYXQoLTEpWzFdXTtcbiAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IGNoaWxkO1xuICAgICAgaWYgKG5hbWUgPT09IFwiI3RleHRcIikge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICBodG1sLmFwcGVuZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZEh0bWwgPSBjaGlsZD8uYXR0cmlidXRlcz8ueG1sbnMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoY2hpbGQuYXR0cmlidXRlcy54bWxucywgbmFtZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xuICAgICAgaHRtbC5hcHBlbmQoY2hpbGRIdG1sKTtcbiAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgaHRtbDogY2hpbGRIdG1sLFxuICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkLFxuICAgICAgICAgIHN0b3JhZ2UsXG4gICAgICAgICAgaW50ZW50LFxuICAgICAgICAgIGxpbmtTZXJ2aWNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuPy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0YWNrLnB1c2goW2NoaWxkLCAtMSwgY2hpbGRIdG1sXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZC52YWx1ZSk7XG4gICAgICAgIGlmIChpc05vdEZvclJpY2hUZXh0ICYmIFhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KG5hbWUpKSB7XG4gICAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZEh0bWwuYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsIG9mIHJvb3REaXYucXVlcnlTZWxlY3RvckFsbChcIi54ZmFOb25JbnRlcmFjdGl2ZSBpbnB1dCwgLnhmYU5vbkludGVyYWN0aXZlIHRleHRhcmVhXCIpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJyZWFkT25seVwiLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHREaXZzXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgcGFyYW1ldGVycy5kaXYuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIHBhcmFtZXRlcnMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2Rpc3BsYXlfdXRpbHMuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgU1ZHX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuY2xhc3MgUGl4ZWxzUGVySW5jaCB7XG4gIHN0YXRpYyBDU1MgPSA5Ni4wO1xuICBzdGF0aWMgUERGID0gNzIuMDtcbiAgc3RhdGljIFBERl9UT19DU1NfVU5JVFMgPSB0aGlzLkNTUyAvIHRoaXMuUERGO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKHVybCwgdHlwZSA9IFwidGV4dFwiKSB7XG4gIGlmIChpc1ZhbGlkRmV0Y2hVcmwodXJsLCBkb2N1bWVudC5iYXNlVVJJKSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vcGVuKFwiR0VUXCIsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0eXBlO1xuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gMCkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZWplY3QobmV3IEVycm9yKHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xuICAgIH07XG4gICAgcmVxdWVzdC5zZW5kKG51bGwpO1xuICB9KTtcbn1cbmNsYXNzIFBhZ2VWaWV3cG9ydCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB2aWV3Qm94LFxuICAgIHVzZXJVbml0LFxuICAgIHNjYWxlLFxuICAgIHJvdGF0aW9uLFxuICAgIG9mZnNldFggPSAwLFxuICAgIG9mZnNldFkgPSAwLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMudmlld0JveCA9IHZpZXdCb3g7XG4gICAgdGhpcy51c2VyVW5pdCA9IHVzZXJVbml0O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WDtcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZO1xuICAgIHNjYWxlICo9IHVzZXJVbml0O1xuICAgIGNvbnN0IGNlbnRlclggPSAodmlld0JveFsyXSArIHZpZXdCb3hbMF0pIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKHZpZXdCb3hbM10gKyB2aWV3Qm94WzFdKSAvIDI7XG4gICAgbGV0IHJvdGF0ZUEsIHJvdGF0ZUIsIHJvdGF0ZUMsIHJvdGF0ZUQ7XG4gICAgcm90YXRpb24gJT0gMzYwO1xuICAgIGlmIChyb3RhdGlvbiA8IDApIHtcbiAgICAgIHJvdGF0aW9uICs9IDM2MDtcbiAgICB9XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJvdGF0ZUEgPSAtMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IDE7XG4gICAgICAgIHJvdGF0ZUMgPSAxO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcm90YXRlQSA9IDA7XG4gICAgICAgIHJvdGF0ZUIgPSAtMTtcbiAgICAgICAgcm90YXRlQyA9IC0xO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJvdGF0ZUEgPSAxO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYWdlVmlld3BvcnQ6IEludmFsaWQgcm90YXRpb24sIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA5MCBkZWdyZWVzLlwiKTtcbiAgICB9XG4gICAgaWYgKGRvbnRGbGlwKSB7XG4gICAgICByb3RhdGVDID0gLXJvdGF0ZUM7XG4gICAgICByb3RhdGVEID0gLXJvdGF0ZUQ7XG4gICAgfVxuICAgIGxldCBvZmZzZXRDYW52YXNYLCBvZmZzZXRDYW52YXNZO1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgIGlmIChyb3RhdGVBID09PSAwKSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybSA9IFtyb3RhdGVBICogc2NhbGUsIHJvdGF0ZUIgKiBzY2FsZSwgcm90YXRlQyAqIHNjYWxlLCByb3RhdGVEICogc2NhbGUsIG9mZnNldENhbnZhc1ggLSByb3RhdGVBICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlQyAqIHNjYWxlICogY2VudGVyWSwgb2Zmc2V0Q2FudmFzWSAtIHJvdGF0ZUIgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVEICogc2NhbGUgKiBjZW50ZXJZXTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZ2V0IHJhd0RpbXMoKSB7XG4gICAgY29uc3QgZGltcyA9IHRoaXMudmlld0JveDtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwicmF3RGltc1wiLCB7XG4gICAgICBwYWdlV2lkdGg6IGRpbXNbMl0gLSBkaW1zWzBdLFxuICAgICAgcGFnZUhlaWdodDogZGltc1szXSAtIGRpbXNbMV0sXG4gICAgICBwYWdlWDogZGltc1swXSxcbiAgICAgIHBhZ2VZOiBkaW1zWzFdXG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoe1xuICAgIHNjYWxlID0gdGhpcy5zY2FsZSxcbiAgICByb3RhdGlvbiA9IHRoaXMucm90YXRpb24sXG4gICAgb2Zmc2V0WCA9IHRoaXMub2Zmc2V0WCxcbiAgICBvZmZzZXRZID0gdGhpcy5vZmZzZXRZLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94LnNsaWNlKCksXG4gICAgICB1c2VyVW5pdDogdGhpcy51c2VyVW5pdCxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGRvbnRGbGlwXG4gICAgfSk7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRQb2ludCh4LCB5KSB7XG4gICAgY29uc3QgcCA9IFt4LCB5XTtcbiAgICBVdGlsLmFwcGx5VHJhbnNmb3JtKHAsIHRoaXMudHJhbnNmb3JtKTtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZShyZWN0KSB7XG4gICAgY29uc3QgdG9wTGVmdCA9IFtyZWN0WzBdLCByZWN0WzFdXTtcbiAgICBVdGlsLmFwcGx5VHJhbnNmb3JtKHRvcExlZnQsIHRoaXMudHJhbnNmb3JtKTtcbiAgICBjb25zdCBib3R0b21SaWdodCA9IFtyZWN0WzJdLCByZWN0WzNdXTtcbiAgICBVdGlsLmFwcGx5VHJhbnNmb3JtKGJvdHRvbVJpZ2h0LCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIFt0b3BMZWZ0WzBdLCB0b3BMZWZ0WzFdLCBib3R0b21SaWdodFswXSwgYm90dG9tUmlnaHRbMV1dO1xuICB9XG4gIGNvbnZlcnRUb1BkZlBvaW50KHgsIHkpIHtcbiAgICBjb25zdCBwID0gW3gsIHldO1xuICAgIFV0aWwuYXBwbHlJbnZlcnNlVHJhbnNmb3JtKHAsIHRoaXMudHJhbnNmb3JtKTtcbiAgICByZXR1cm4gcDtcbiAgfVxufVxuY2xhc3MgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgZXh0cmFEZWxheSA9IDApIHtcbiAgICBzdXBlcihtc2csIFwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuZXh0cmFEZWxheSA9IGV4dHJhRGVsYXk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRGF0YVNjaGVtZSh1cmwpIHtcbiAgY29uc3QgaWkgPSB1cmwubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgaWkgJiYgdXJsW2ldLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gdXJsLnN1YnN0cmluZyhpLCBpICsgNSkudG9Mb3dlckNhc2UoKSA9PT0gXCJkYXRhOlwiO1xufVxuZnVuY3Rpb24gaXNQZGZGaWxlKGZpbGVuYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgZmlsZW5hbWUgPT09IFwic3RyaW5nXCIgJiYgL1xcLnBkZiQvaS50ZXN0KGZpbGVuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbVVybCh1cmwpIHtcbiAgW3VybF0gPSB1cmwuc3BsaXQoL1sjP10vLCAxKTtcbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcodXJsLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xufVxuZnVuY3Rpb24gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsKHVybCwgZGVmYXVsdEZpbGVuYW1lID0gXCJkb2N1bWVudC5wZGZcIikge1xuICBpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cbiAgaWYgKGlzRGF0YVNjaGVtZSh1cmwpKSB7XG4gICAgd2FybignZ2V0UGRmRmlsZW5hbWVGcm9tVXJsOiBpZ25vcmUgXCJkYXRhOlwiLVVSTCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4nKTtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGNvbnN0IGdldFVSTCA9IHVybFN0cmluZyA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgVVJMKHVybFN0cmluZyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTChkZWNvZGVVUklDb21wb25lbnQodXJsU3RyaW5nKSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVSTCh1cmxTdHJpbmcsIFwiaHR0cHM6Ly9mb28uYmFyXCIpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwoZGVjb2RlVVJJQ29tcG9uZW50KHVybFN0cmluZyksIFwiaHR0cHM6Ly9mb28uYmFyXCIpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBuZXdVUkwgPSBnZXRVUkwodXJsKTtcbiAgaWYgKCFuZXdVUkwpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGNvbnN0IGRlY29kZSA9IG5hbWUgPT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudChuYW1lKTtcbiAgICAgIGlmIChkZWNvZGVkLmluY2x1ZGVzKFwiL1wiKSkge1xuICAgICAgICBkZWNvZGVkID0gZGVjb2RlZC5zcGxpdChcIi9cIikuYXQoLTEpO1xuICAgICAgICBpZiAoZGVjb2RlZC50ZXN0KC9eXFwucGRmJC9pKSkge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBkZlJlZ2V4ID0gL1xcLnBkZiQvaTtcbiAgY29uc3QgZmlsZW5hbWUgPSBuZXdVUkwucGF0aG5hbWUuc3BsaXQoXCIvXCIpLmF0KC0xKTtcbiAgaWYgKHBkZlJlZ2V4LnRlc3QoZmlsZW5hbWUpKSB7XG4gICAgcmV0dXJuIGRlY29kZShmaWxlbmFtZSk7XG4gIH1cbiAgaWYgKG5ld1VSTC5zZWFyY2hQYXJhbXMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5mcm9tKG5ld1VSTC5zZWFyY2hQYXJhbXMudmFsdWVzKCkpLnJldmVyc2UoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHBkZlJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbShuZXdVUkwuc2VhcmNoUGFyYW1zLmtleXMoKSkucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmIChwZGZSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobmV3VVJMLmhhc2gpIHtcbiAgICBjb25zdCByZUZpbGVuYW1lID0gL1teLz8jPV0rXFwucGRmXFxiKD8hLipcXC5wZGZcXGIpL2k7XG4gICAgY29uc3QgaGFzaEZpbGVuYW1lID0gcmVGaWxlbmFtZS5leGVjKG5ld1VSTC5oYXNoKTtcbiAgICBpZiAoaGFzaEZpbGVuYW1lKSB7XG4gICAgICByZXR1cm4gZGVjb2RlKGhhc2hGaWxlbmFtZVswXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG59XG5jbGFzcyBTdGF0VGltZXIge1xuICBzdGFydGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGltZXMgPSBbXTtcbiAgdGltZShuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4gdGhpcy5zdGFydGVkKSB7XG4gICAgICB3YXJuKGBUaW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcgZm9yICR7bmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy5zdGFydGVkW25hbWVdID0gRGF0ZS5ub3coKTtcbiAgfVxuICB0aW1lRW5kKG5hbWUpIHtcbiAgICBpZiAoIShuYW1lIGluIHRoaXMuc3RhcnRlZCkpIHtcbiAgICAgIHdhcm4oYFRpbWVyIGhhcyBub3QgYmVlbiBzdGFydGVkIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMudGltZXMucHVzaCh7XG4gICAgICBuYW1lLFxuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnRlZFtuYW1lXSxcbiAgICAgIGVuZDogRGF0ZS5ub3coKVxuICAgIH0pO1xuICAgIGRlbGV0ZSB0aGlzLnN0YXJ0ZWRbbmFtZV07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qgb3V0QnVmID0gW107XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZVxuICAgIH0gb2YgdGhpcy50aW1lcykge1xuICAgICAgbG9uZ2VzdCA9IE1hdGgubWF4KG5hbWUubGVuZ3RoLCBsb25nZXN0KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgc3RhcnQsXG4gICAgICBlbmRcbiAgICB9IG9mIHRoaXMudGltZXMpIHtcbiAgICAgIG91dEJ1Zi5wdXNoKGAke25hbWUucGFkRW5kKGxvbmdlc3QpfSAke2VuZCAtIHN0YXJ0fW1zXFxuYCk7XG4gICAgfVxuICAgIHJldHVybiBvdXRCdWYuam9pbihcIlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZEZldGNoVXJsKHVybCwgYmFzZVVybCkge1xuICBjb25zdCByZXMgPSBiYXNlVXJsID8gVVJMLnBhcnNlKHVybCwgYmFzZVVybCkgOiBVUkwucGFyc2UodXJsKTtcbiAgcmV0dXJuIHJlcz8ucHJvdG9jb2wgPT09IFwiaHR0cDpcIiB8fCByZXM/LnByb3RvY29sID09PSBcImh0dHBzOlwiO1xufVxuZnVuY3Rpb24gbm9Db250ZXh0TWVudShlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIHN0b3BFdmVudChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoZGV0YWlscykge1xuICBjb25zb2xlLmxvZyhcIkRlcHJlY2F0ZWQgQVBJIHVzYWdlOiBcIiArIGRldGFpbHMpO1xufVxuY2xhc3MgUERGRGF0ZVN0cmluZyB7XG4gIHN0YXRpYyAjcmVnZXg7XG4gIHN0YXRpYyB0b0RhdGVPYmplY3QoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jcmVnZXggfHw9IG5ldyBSZWdFeHAoXCJeRDpcIiArIFwiKFxcXFxkezR9KVwiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoW1p8K3wtXSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIic/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIic/XCIpO1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLiNyZWdleC5leGVjKGlucHV0KTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB5ZWFyID0gcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApO1xuICAgIGxldCBtb250aCA9IHBhcnNlSW50KG1hdGNoZXNbMl0sIDEwKTtcbiAgICBtb250aCA9IG1vbnRoID49IDEgJiYgbW9udGggPD0gMTIgPyBtb250aCAtIDEgOiAwO1xuICAgIGxldCBkYXkgPSBwYXJzZUludChtYXRjaGVzWzNdLCAxMCk7XG4gICAgZGF5ID0gZGF5ID49IDEgJiYgZGF5IDw9IDMxID8gZGF5IDogMTtcbiAgICBsZXQgaG91ciA9IHBhcnNlSW50KG1hdGNoZXNbNF0sIDEwKTtcbiAgICBob3VyID0gaG91ciA+PSAwICYmIGhvdXIgPD0gMjMgPyBob3VyIDogMDtcbiAgICBsZXQgbWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgIG1pbnV0ZSA9IG1pbnV0ZSA+PSAwICYmIG1pbnV0ZSA8PSA1OSA/IG1pbnV0ZSA6IDA7XG4gICAgbGV0IHNlY29uZCA9IHBhcnNlSW50KG1hdGNoZXNbNl0sIDEwKTtcbiAgICBzZWNvbmQgPSBzZWNvbmQgPj0gMCAmJiBzZWNvbmQgPD0gNTkgPyBzZWNvbmQgOiAwO1xuICAgIGNvbnN0IHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9IG1hdGNoZXNbN10gfHwgXCJaXCI7XG4gICAgbGV0IG9mZnNldEhvdXIgPSBwYXJzZUludChtYXRjaGVzWzhdLCAxMCk7XG4gICAgb2Zmc2V0SG91ciA9IG9mZnNldEhvdXIgPj0gMCAmJiBvZmZzZXRIb3VyIDw9IDIzID8gb2Zmc2V0SG91ciA6IDA7XG4gICAgbGV0IG9mZnNldE1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoZXNbOV0sIDEwKSB8fCAwO1xuICAgIG9mZnNldE1pbnV0ZSA9IG9mZnNldE1pbnV0ZSA+PSAwICYmIG9mZnNldE1pbnV0ZSA8PSA1OSA/IG9mZnNldE1pbnV0ZSA6IDA7XG4gICAgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCItXCIpIHtcbiAgICAgIGhvdXIgKz0gb2Zmc2V0SG91cjtcbiAgICAgIG1pbnV0ZSArPSBvZmZzZXRNaW51dGU7XG4gICAgfSBlbHNlIGlmICh1bml2ZXJzYWxUaW1lUmVsYXRpb24gPT09IFwiK1wiKSB7XG4gICAgICBob3VyIC09IG9mZnNldEhvdXI7XG4gICAgICBtaW51dGUgLT0gb2Zmc2V0TWludXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0WGZhUGFnZVZpZXdwb3J0KHhmYVBhZ2UsIHtcbiAgc2NhbGUgPSAxLFxuICByb3RhdGlvbiA9IDBcbn0pIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0geGZhUGFnZS5hdHRyaWJ1dGVzLnN0eWxlO1xuICBjb25zdCB2aWV3Qm94ID0gWzAsIDAsIHBhcnNlSW50KHdpZHRoKSwgcGFyc2VJbnQoaGVpZ2h0KV07XG4gIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICB2aWV3Qm94LFxuICAgIHVzZXJVbml0OiAxLFxuICAgIHNjYWxlLFxuICAgIHJvdGF0aW9uXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UkdCKGNvbG9yKSB7XG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgIGNvbnN0IGNvbG9yUkdCID0gcGFyc2VJbnQoY29sb3Iuc2xpY2UoMSksIDE2KTtcbiAgICByZXR1cm4gWyhjb2xvclJHQiAmIDB4ZmYwMDAwKSA+PiAxNiwgKGNvbG9yUkdCICYgMHgwMGZmMDApID4+IDgsIGNvbG9yUkdCICYgMHgwMDAwZmZdO1xuICB9XG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwicmdiKFwiKSkge1xuICAgIHJldHVybiBjb2xvci5zbGljZSg0LCAtMSkuc3BsaXQoXCIsXCIpLm1hcCh4ID0+IHBhcnNlSW50KHgpKTtcbiAgfVxuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcInJnYmEoXCIpKSB7XG4gICAgcmV0dXJuIGNvbG9yLnNsaWNlKDUsIC0xKS5zcGxpdChcIixcIikubWFwKHggPT4gcGFyc2VJbnQoeCkpLnNsaWNlKDAsIDMpO1xuICB9XG4gIHdhcm4oYE5vdCBhIHZhbGlkIGNvbG9yIGZvcm1hdDogXCIke2NvbG9yfVwiYCk7XG4gIHJldHVybiBbMCwgMCwgMF07XG59XG5mdW5jdGlvbiBnZXRDb2xvclZhbHVlcyhjb2xvcnMpIHtcbiAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICBzcGFuLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICBzcGFuLnN0eWxlLmNvbG9yU2NoZW1lID0gXCJvbmx5IGxpZ2h0XCI7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kKHNwYW4pO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgY29sb3JzLmtleXMoKSkge1xuICAgIHNwYW4uc3R5bGUuY29sb3IgPSBuYW1lO1xuICAgIGNvbnN0IGNvbXB1dGVkQ29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzcGFuKS5jb2xvcjtcbiAgICBjb2xvcnMuc2V0KG5hbWUsIGdldFJHQihjb21wdXRlZENvbG9yKSk7XG4gIH1cbiAgc3Bhbi5yZW1vdmUoKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZlxuICB9ID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICByZXR1cm4gW2EsIGIsIGMsIGQsIGUsIGZdO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZlxuICB9ID0gY3R4LmdldFRyYW5zZm9ybSgpLmludmVydFNlbGYoKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIHNldExheWVyRGltZW5zaW9ucyhkaXYsIHZpZXdwb3J0LCBtdXN0RmxpcCA9IGZhbHNlLCBtdXN0Um90YXRlID0gdHJ1ZSkge1xuICBpZiAodmlld3BvcnQgaW5zdGFuY2VvZiBQYWdlVmlld3BvcnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIGNvbnN0IHVzZVJvdW5kID0gdXRpbF9GZWF0dXJlVGVzdC5pc0NTU1JvdW5kU3VwcG9ydGVkO1xuICAgIGNvbnN0IHcgPSBgdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSAqICR7cGFnZVdpZHRofXB4YCxcbiAgICAgIGggPSBgdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSAqICR7cGFnZUhlaWdodH1weGA7XG4gICAgY29uc3Qgd2lkdGhTdHIgPSB1c2VSb3VuZCA/IGByb3VuZChkb3duLCAke3d9LCB2YXIoLS1zY2FsZS1yb3VuZC14KSlgIDogYGNhbGMoJHt3fSlgLFxuICAgICAgaGVpZ2h0U3RyID0gdXNlUm91bmQgPyBgcm91bmQoZG93biwgJHtofSwgdmFyKC0tc2NhbGUtcm91bmQteSkpYCA6IGBjYWxjKCR7aH0pYDtcbiAgICBpZiAoIW11c3RGbGlwIHx8IHZpZXdwb3J0LnJvdGF0aW9uICUgMTgwID09PSAwKSB7XG4gICAgICBzdHlsZS53aWR0aCA9IHdpZHRoU3RyO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0U3RyO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGhlaWdodFN0cjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IHdpZHRoU3RyO1xuICAgIH1cbiAgfVxuICBpZiAobXVzdFJvdGF0ZSkge1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIiwgdmlld3BvcnQucm90YXRpb24pO1xuICB9XG59XG5jbGFzcyBPdXRwdXRTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBpeGVsUmF0aW9cbiAgICB9ID0gT3V0cHV0U2NhbGU7XG4gICAgdGhpcy5zeCA9IHBpeGVsUmF0aW87XG4gICAgdGhpcy5zeSA9IHBpeGVsUmF0aW87XG4gIH1cbiAgZ2V0IHNjYWxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zeCAhPT0gMSB8fCB0aGlzLnN5ICE9PSAxO1xuICB9XG4gIGdldCBzeW1tZXRyaWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ggPT09IHRoaXMuc3k7XG4gIH1cbiAgbGltaXRDYW52YXMod2lkdGgsIGhlaWdodCwgbWF4UGl4ZWxzLCBtYXhEaW0sIGNhcEFyZWFGYWN0b3IgPSAtMSkge1xuICAgIGxldCBtYXhBcmVhU2NhbGUgPSBJbmZpbml0eSxcbiAgICAgIG1heFdpZHRoU2NhbGUgPSBJbmZpbml0eSxcbiAgICAgIG1heEhlaWdodFNjYWxlID0gSW5maW5pdHk7XG4gICAgbWF4UGl4ZWxzID0gT3V0cHV0U2NhbGUuY2FwUGl4ZWxzKG1heFBpeGVscywgY2FwQXJlYUZhY3Rvcik7XG4gICAgaWYgKG1heFBpeGVscyA+IDApIHtcbiAgICAgIG1heEFyZWFTY2FsZSA9IE1hdGguc3FydChtYXhQaXhlbHMgLyAod2lkdGggKiBoZWlnaHQpKTtcbiAgICB9XG4gICAgaWYgKG1heERpbSAhPT0gLTEpIHtcbiAgICAgIG1heFdpZHRoU2NhbGUgPSBtYXhEaW0gLyB3aWR0aDtcbiAgICAgIG1heEhlaWdodFNjYWxlID0gbWF4RGltIC8gaGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBtYXhTY2FsZSA9IE1hdGgubWluKG1heEFyZWFTY2FsZSwgbWF4V2lkdGhTY2FsZSwgbWF4SGVpZ2h0U2NhbGUpO1xuICAgIGlmICh0aGlzLnN4ID4gbWF4U2NhbGUgfHwgdGhpcy5zeSA+IG1heFNjYWxlKSB7XG4gICAgICB0aGlzLnN4ID0gbWF4U2NhbGU7XG4gICAgICB0aGlzLnN5ID0gbWF4U2NhbGU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBnZXQgcGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIH1cbiAgc3RhdGljIGNhcFBpeGVscyhtYXhQaXhlbHMsIGNhcEFyZWFGYWN0b3IpIHtcbiAgICBpZiAoY2FwQXJlYUZhY3RvciA+PSAwKSB7XG4gICAgICBjb25zdCB3aW5QaXhlbHMgPSBNYXRoLmNlaWwod2luZG93LnNjcmVlbi5hdmFpbFdpZHRoICogd2luZG93LnNjcmVlbi5hdmFpbEhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyAqKiAyICogKDEgKyBjYXBBcmVhRmFjdG9yIC8gMTAwKSk7XG4gICAgICByZXR1cm4gbWF4UGl4ZWxzID4gMCA/IE1hdGgubWluKG1heFBpeGVscywgd2luUGl4ZWxzKSA6IHdpblBpeGVscztcbiAgICB9XG4gICAgcmV0dXJuIG1heFBpeGVscztcbiAgfVxufVxuY29uc3QgU3VwcG9ydGVkSW1hZ2VNaW1lVHlwZXMgPSBbXCJpbWFnZS9hcG5nXCIsIFwiaW1hZ2UvYXZpZlwiLCBcImltYWdlL2JtcFwiLCBcImltYWdlL2dpZlwiLCBcImltYWdlL2pwZWdcIiwgXCJpbWFnZS9wbmdcIiwgXCJpbWFnZS9zdmcreG1sXCIsIFwiaW1hZ2Uvd2VicFwiLCBcImltYWdlL3gtaWNvblwiXTtcbmNsYXNzIENvbG9yU2NoZW1lIHtcbiAgc3RhdGljIGdldCBpc0RhcmtNb2RlKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0RhcmtNb2RlXCIsICEhd2luZG93Py5tYXRjaE1lZGlhPy4oXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIpLm1hdGNoZXMpO1xuICB9XG59XG5jbGFzcyBDU1NDb25zdGFudHMge1xuICBzdGF0aWMgZ2V0IGNvbW1lbnRGb3JlZ3JvdW5kQ29sb3IoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImNvbW1lbnRcIiwgXCJzaWRlYmFyXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgc3R5bGUud2lkdGggPSBzdHlsZS5oZWlnaHQgPSBcIjBcIjtcbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgc3R5bGUuY29sb3IgPSBcInZhcigtLWNvbW1lbnQtZmctY29sb3IpXCI7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZWxlbWVudCk7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3JcbiAgICB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiY29tbWVudEZvcmVncm91bmRDb2xvclwiLCBnZXRSR0IoY29sb3IpKTtcbiAgfVxufVxuZnVuY3Rpb24gYXBwbHlPcGFjaXR5KHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgb3BhY2l0eSA9IE1hdGgubWluKE1hdGgubWF4KG9wYWNpdHkgPz8gMSwgMCksIDEpO1xuICBjb25zdCB3aGl0ZSA9IDI1NSAqICgxIC0gb3BhY2l0eSk7XG4gIHIgPSBNYXRoLnJvdW5kKHIgKiBvcGFjaXR5ICsgd2hpdGUpO1xuICBnID0gTWF0aC5yb3VuZChnICogb3BhY2l0eSArIHdoaXRlKTtcbiAgYiA9IE1hdGgucm91bmQoYiAqIG9wYWNpdHkgKyB3aGl0ZSk7XG4gIHJldHVybiBbciwgZywgYl07XG59XG5mdW5jdGlvbiBSR0JUb0hTTChyZ2IsIG91dHB1dCkge1xuICBjb25zdCByID0gcmdiWzBdIC8gMjU1O1xuICBjb25zdCBnID0gcmdiWzFdIC8gMjU1O1xuICBjb25zdCBiID0gcmdiWzJdIC8gMjU1O1xuICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGlmIChtYXggPT09IG1pbikge1xuICAgIG91dHB1dFswXSA9IG91dHB1dFsxXSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZCA9IG1heCAtIG1pbjtcbiAgICBvdXRwdXRbMV0gPSBsIDwgMC41ID8gZCAvIChtYXggKyBtaW4pIDogZCAvICgyIC0gbWF4IC0gbWluKTtcbiAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgY2FzZSByOlxuICAgICAgICBvdXRwdXRbMF0gPSAoKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCkpICogNjA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnOlxuICAgICAgICBvdXRwdXRbMF0gPSAoKGIgLSByKSAvIGQgKyAyKSAqIDYwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjpcbiAgICAgICAgb3V0cHV0WzBdID0gKChyIC0gZykgLyBkICsgNCkgKiA2MDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIG91dHB1dFsyXSA9IGw7XG59XG5mdW5jdGlvbiBIU0xUb1JHQihoc2wsIG91dHB1dCkge1xuICBjb25zdCBoID0gaHNsWzBdO1xuICBjb25zdCBzID0gaHNsWzFdO1xuICBjb25zdCBsID0gaHNsWzJdO1xuICBjb25zdCBjID0gKDEgLSBNYXRoLmFicygyICogbCAtIDEpKSAqIHM7XG4gIGNvbnN0IHggPSBjICogKDEgLSBNYXRoLmFicyhoIC8gNjAgJSAyIC0gMSkpO1xuICBjb25zdCBtID0gbCAtIGMgLyAyO1xuICBzd2l0Y2ggKE1hdGguZmxvb3IoaCAvIDYwKSkge1xuICAgIGNhc2UgMDpcbiAgICAgIG91dHB1dFswXSA9IGMgKyBtO1xuICAgICAgb3V0cHV0WzFdID0geCArIG07XG4gICAgICBvdXRwdXRbMl0gPSBtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgb3V0cHV0WzBdID0geCArIG07XG4gICAgICBvdXRwdXRbMV0gPSBjICsgbTtcbiAgICAgIG91dHB1dFsyXSA9IG07XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBvdXRwdXRbMF0gPSBtO1xuICAgICAgb3V0cHV0WzFdID0gYyArIG07XG4gICAgICBvdXRwdXRbMl0gPSB4ICsgbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIG91dHB1dFswXSA9IG07XG4gICAgICBvdXRwdXRbMV0gPSB4ICsgbTtcbiAgICAgIG91dHB1dFsyXSA9IGMgKyBtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgb3V0cHV0WzBdID0geCArIG07XG4gICAgICBvdXRwdXRbMV0gPSBtO1xuICAgICAgb3V0cHV0WzJdID0gYyArIG07XG4gICAgICBicmVhaztcbiAgICBjYXNlIDU6XG4gICAgY2FzZSA2OlxuICAgICAgb3V0cHV0WzBdID0gYyArIG07XG4gICAgICBvdXRwdXRbMV0gPSBtO1xuICAgICAgb3V0cHV0WzJdID0geCArIG07XG4gICAgICBicmVhaztcbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUx1bWluYW5jZSh4KSB7XG4gIHJldHVybiB4IDw9IDAuMDM5MjggPyB4IC8gMTIuOTIgOiAoKHggKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xufVxuZnVuY3Rpb24gY29udHJhc3RSYXRpbyhoc2wxLCBoc2wyLCBvdXRwdXQpIHtcbiAgSFNMVG9SR0IoaHNsMSwgb3V0cHV0KTtcbiAgb3V0cHV0Lm1hcChjb21wdXRlTHVtaW5hbmNlKTtcbiAgY29uc3QgbHVtMSA9IDAuMjEyNiAqIG91dHB1dFswXSArIDAuNzE1MiAqIG91dHB1dFsxXSArIDAuMDcyMiAqIG91dHB1dFsyXTtcbiAgSFNMVG9SR0IoaHNsMiwgb3V0cHV0KTtcbiAgb3V0cHV0Lm1hcChjb21wdXRlTHVtaW5hbmNlKTtcbiAgY29uc3QgbHVtMiA9IDAuMjEyNiAqIG91dHB1dFswXSArIDAuNzE1MiAqIG91dHB1dFsxXSArIDAuMDcyMiAqIG91dHB1dFsyXTtcbiAgcmV0dXJuIGx1bTEgPiBsdW0yID8gKGx1bTEgKyAwLjA1KSAvIChsdW0yICsgMC4wNSkgOiAobHVtMiArIDAuMDUpIC8gKGx1bTEgKyAwLjA1KTtcbn1cbmNvbnN0IGNvbnRyYXN0Q2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBmaW5kQ29udHJhc3RDb2xvcihiYXNlQ29sb3IsIGZpeGVkQ29sb3IpIHtcbiAgY29uc3Qga2V5ID0gYmFzZUNvbG9yWzBdICsgYmFzZUNvbG9yWzFdICogMHgxMDAgKyBiYXNlQ29sb3JbMl0gKiAweDEwMDAwICsgZml4ZWRDb2xvclswXSAqIDB4MTAwMDAwMCArIGZpeGVkQ29sb3JbMV0gKiAweDEwMDAwMDAwMCArIGZpeGVkQ29sb3JbMl0gKiAweDEwMDAwMDAwMDAwO1xuICBsZXQgY2FjaGVkVmFsdWUgPSBjb250cmFzdENhY2hlLmdldChrZXkpO1xuICBpZiAoY2FjaGVkVmFsdWUpIHtcbiAgICByZXR1cm4gY2FjaGVkVmFsdWU7XG4gIH1cbiAgY29uc3QgYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuICBjb25zdCBvdXRwdXQgPSBhcnJheS5zdWJhcnJheSgwLCAzKTtcbiAgY29uc3QgYmFzZUhTTCA9IGFycmF5LnN1YmFycmF5KDMsIDYpO1xuICBSR0JUb0hTTChiYXNlQ29sb3IsIGJhc2VIU0wpO1xuICBjb25zdCBmaXhlZEhTTCA9IGFycmF5LnN1YmFycmF5KDYsIDkpO1xuICBSR0JUb0hTTChmaXhlZENvbG9yLCBmaXhlZEhTTCk7XG4gIGNvbnN0IGlzRml4ZWRDb2xvckRhcmsgPSBmaXhlZEhTTFsyXSA8IDAuNTtcbiAgY29uc3QgbWluQ29udHJhc3QgPSBpc0ZpeGVkQ29sb3JEYXJrID8gMTIgOiA0LjU7XG4gIGJhc2VIU0xbMl0gPSBpc0ZpeGVkQ29sb3JEYXJrID8gTWF0aC5zcXJ0KGJhc2VIU0xbMl0pIDogMSAtIE1hdGguc3FydCgxIC0gYmFzZUhTTFsyXSk7XG4gIGlmIChjb250cmFzdFJhdGlvKGJhc2VIU0wsIGZpeGVkSFNMLCBvdXRwdXQpIDwgbWluQ29udHJhc3QpIHtcbiAgICBsZXQgc3RhcnQsIGVuZDtcbiAgICBpZiAoaXNGaXhlZENvbG9yRGFyaykge1xuICAgICAgc3RhcnQgPSBiYXNlSFNMWzJdO1xuICAgICAgZW5kID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgZW5kID0gYmFzZUhTTFsyXTtcbiAgICB9XG4gICAgY29uc3QgUFJFQ0lTSU9OID0gMC4wMDU7XG4gICAgd2hpbGUgKGVuZCAtIHN0YXJ0ID4gUFJFQ0lTSU9OKSB7XG4gICAgICBjb25zdCBtaWQgPSBiYXNlSFNMWzJdID0gKHN0YXJ0ICsgZW5kKSAvIDI7XG4gICAgICBpZiAoaXNGaXhlZENvbG9yRGFyayA9PT0gY29udHJhc3RSYXRpbyhiYXNlSFNMLCBmaXhlZEhTTCwgb3V0cHV0KSA8IG1pbkNvbnRyYXN0KSB7XG4gICAgICAgIHN0YXJ0ID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gbWlkO1xuICAgICAgfVxuICAgIH1cbiAgICBiYXNlSFNMWzJdID0gaXNGaXhlZENvbG9yRGFyayA/IGVuZCA6IHN0YXJ0O1xuICB9XG4gIEhTTFRvUkdCKGJhc2VIU0wsIG91dHB1dCk7XG4gIGNhY2hlZFZhbHVlID0gVXRpbC5tYWtlSGV4Q29sb3IoTWF0aC5yb3VuZChvdXRwdXRbMF0gKiAyNTUpLCBNYXRoLnJvdW5kKG91dHB1dFsxXSAqIDI1NSksIE1hdGgucm91bmQob3V0cHV0WzJdICogMjU1KSk7XG4gIGNvbnRyYXN0Q2FjaGUuc2V0KGtleSwgY2FjaGVkVmFsdWUpO1xuICByZXR1cm4gY2FjaGVkVmFsdWU7XG59XG5mdW5jdGlvbiByZW5kZXJSaWNoVGV4dCh7XG4gIGh0bWwsXG4gIGRpcixcbiAgY2xhc3NOYW1lXG59LCBjb250YWluZXIpIHtcbiAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIGlmICh0eXBlb2YgaHRtbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICBwLmRpciA9IGRpciB8fCBcImF1dG9cIjtcbiAgICBjb25zdCBsaW5lcyA9IGh0bWwuc3BsaXQoLyg/Olxcclxcbj98XFxuKS8pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpbmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgIHAuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpKTtcbiAgICAgIGlmIChpIDwgaWkgLSAxKSB7XG4gICAgICAgIHAuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZyYWdtZW50LmFwcGVuZChwKTtcbiAgfSBlbHNlIHtcbiAgICBYZmFMYXllci5yZW5kZXIoe1xuICAgICAgeGZhSHRtbDogaHRtbCxcbiAgICAgIGRpdjogZnJhZ21lbnQsXG4gICAgICBpbnRlbnQ6IFwicmljaFRleHRcIlxuICAgIH0pO1xuICB9XG4gIGZyYWdtZW50LmZpcnN0Q2hpbGQuY2xhc3NMaXN0LmFkZChcInJpY2hUZXh0XCIsIGNsYXNzTmFtZSk7XG4gIGNvbnRhaW5lci5hcHBlbmQoZnJhZ21lbnQpO1xufVxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5pdGVyYXRvci50YWtlLmpzXG52YXIgZXNfaXRlcmF0b3JfdGFrZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDk3Mik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLndpdGgtcmVzb2x2ZXJzLmpzXG52YXIgZXNfcHJvbWlzZV93aXRoX3Jlc29sdmVycyA9IF9fd2VicGFja19yZXF1aXJlX18oNDYyOCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQuZGlmZmVyZW5jZS52Mi5qc1xudmFyIGVzX3NldF9kaWZmZXJlbmNlX3YyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjQyKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5pbnRlcnNlY3Rpb24udjIuanNcbnZhciBlc19zZXRfaW50ZXJzZWN0aW9uX3YyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDA0KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5pcy1kaXNqb2ludC1mcm9tLnYyLmpzXG52YXIgZXNfc2V0X2lzX2Rpc2pvaW50X2Zyb21fdjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4NTMpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmlzLXN1YnNldC1vZi52Mi5qc1xudmFyIGVzX3NldF9pc19zdWJzZXRfb2ZfdjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4NzYpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmlzLXN1cGVyc2V0LW9mLnYyLmpzXG52YXIgZXNfc2V0X2lzX3N1cGVyc2V0X29mX3YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDc1KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5zeW1tZXRyaWMtZGlmZmVyZW5jZS52Mi5qc1xudmFyIGVzX3NldF9zeW1tZXRyaWNfZGlmZmVyZW5jZV92MiA9IF9fd2VicGFja19yZXF1aXJlX18oNTAyNCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQudW5pb24udjIuanNcbnZhciBlc19zZXRfdW5pb25fdjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OTgpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IuZHJvcC5qc1xudmFyIGVzX2l0ZXJhdG9yX2Ryb3AgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMTQpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IuZXZlcnkuanNcbnZhciBlc19pdGVyYXRvcl9ldmVyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMTE0OCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5pdGVyYXRvci5zb21lLmpzXG52YXIgZXNfaXRlcmF0b3Jfc29tZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzU3OSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuanNvbi5wYXJzZS5qc1xudmFyIGVzbmV4dF9qc29uX3BhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MzM1KTtcbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci90b29sYmFyLmpzXG5cbmNsYXNzIEVkaXRvclRvb2xiYXIge1xuICAjdG9vbGJhciA9IG51bGw7XG4gICNjb2xvclBpY2tlciA9IG51bGw7XG4gICNlZGl0b3I7XG4gICNidXR0b25zID0gbnVsbDtcbiAgI2FsdFRleHQgPSBudWxsO1xuICAjY29tbWVudCA9IG51bGw7XG4gICNjb21tZW50QnV0dG9uRGl2aWRlciA9IG51bGw7XG4gICNzaWduYXR1cmVEZXNjcmlwdGlvbkJ1dHRvbiA9IG51bGw7XG4gIHN0YXRpYyAjbDEwblJlbW92ZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICBFZGl0b3JUb29sYmFyLiNsMTBuUmVtb3ZlIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIGZyZWV0ZXh0OiBcInBkZmpzLWVkaXRvci1yZW1vdmUtZnJlZXRleHQtYnV0dG9uXCIsXG4gICAgICBoaWdobGlnaHQ6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1oaWdobGlnaHQtYnV0dG9uXCIsXG4gICAgICBpbms6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1pbmstYnV0dG9uXCIsXG4gICAgICBzdGFtcDogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLXN0YW1wLWJ1dHRvblwiLFxuICAgICAgc2lnbmF0dXJlOiBcInBkZmpzLWVkaXRvci1yZW1vdmUtc2lnbmF0dXJlLWJ1dHRvblwiXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGVkaXRUb29sYmFyID0gdGhpcy4jdG9vbGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZWRpdFRvb2xiYXIuY2xhc3NMaXN0LmFkZChcImVkaXRUb29sYmFyXCIsIFwiaGlkZGVuXCIpO1xuICAgIGVkaXRUb29sYmFyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0b29sYmFyXCIpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgaWYgKHNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsICYmICFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGVkaXRUb29sYmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBFZGl0b3JUb29sYmFyLiNwb2ludGVyRG93biwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBidXR0b25zID0gdGhpcy4jYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgYnV0dG9ucy5jbGFzc05hbWUgPSBcImJ1dHRvbnNcIjtcbiAgICBlZGl0VG9vbGJhci5hcHBlbmQoYnV0dG9ucyk7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLiNlZGl0b3IudG9vbGJhclBvc2l0aW9uO1xuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGVkaXRUb29sYmFyO1xuICAgICAgY29uc3QgeCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IDEgLSBwb3NpdGlvblswXSA6IHBvc2l0aW9uWzBdO1xuICAgICAgc3R5bGUuaW5zZXRJbmxpbmVFbmQgPSBgJHsxMDAgKiB4fSVgO1xuICAgICAgc3R5bGUudG9wID0gYGNhbGMoJHsxMDAgKiBwb3NpdGlvblsxXX0lICsgdmFyKC0tZWRpdG9yLXRvb2xiYXItdmVydC1vZmZzZXQpKWA7XG4gICAgfVxuICAgIHJldHVybiBlZGl0VG9vbGJhcjtcbiAgfVxuICBnZXQgZGl2KCkge1xuICAgIHJldHVybiB0aGlzLiN0b29sYmFyO1xuICB9XG4gIHN0YXRpYyAjcG9pbnRlckRvd24oZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgI2ZvY3VzSW4oZSkge1xuICAgIHRoaXMuI2VkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgc3RvcEV2ZW50KGUpO1xuICB9XG4gICNmb2N1c091dChlKSB7XG4gICAgdGhpcy4jZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgIHN0b3BFdmVudChlKTtcbiAgfVxuICAjYWRkTGlzdGVuZXJzVG9FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGlmICghKHNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsKSB8fCBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2ZvY3VzSW4uYmluZCh0aGlzKSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuI2ZvY3VzT3V0LmJpbmQodGhpcyksIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuI3Rvb2xiYXIuY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLiNjb2xvclBpY2tlcj8uaGlkZURyb3Bkb3duKCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICB0aGlzLiN0b29sYmFyLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgdGhpcy4jYWx0VGV4dD8uc2hvd24oKTtcbiAgICB0aGlzLiNjb21tZW50Py5zaG93bigpO1xuICB9XG4gIGFkZERlbGV0ZUJ1dHRvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBlZGl0b3JUeXBlLFxuICAgICAgX3VpTWFuYWdlclxuICAgIH0gPSB0aGlzLiNlZGl0b3I7XG4gICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZChcImJhc2ljXCIsIFwiZGVsZXRlQnV0dG9uXCIpO1xuICAgIGJ1dHRvbi50YWJJbmRleCA9IDA7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBFZGl0b3JUb29sYmFyLiNsMTBuUmVtb3ZlW2VkaXRvclR5cGVdKTtcbiAgICBpZiAodGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbikpIHtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgICAgIF91aU1hbmFnZXIuZGVsZXRlKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbDogX3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uKTtcbiAgfVxuICBnZXQgI2RpdmlkZXIoKSB7XG4gICAgY29uc3QgZGl2aWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2aWRlci5jbGFzc05hbWUgPSBcImRpdmlkZXJcIjtcbiAgICByZXR1cm4gZGl2aWRlcjtcbiAgfVxuICBhc3luYyBhZGRBbHRUZXh0KGFsdFRleHQpIHtcbiAgICBjb25zdCBidXR0b24gPSBhd2FpdCBhbHRUZXh0LnJlbmRlcigpO1xuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIHRoaXMuI2J1dHRvbnMuYXBwZW5kKGJ1dHRvbiwgdGhpcy4jZGl2aWRlcik7XG4gICAgdGhpcy4jYWx0VGV4dCA9IGFsdFRleHQ7XG4gIH1cbiAgYWRkQ29tbWVudChjb21tZW50LCBiZWZvcmVFbGVtZW50ID0gbnVsbCkge1xuICAgIGlmICh0aGlzLiNjb21tZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1dHRvbiA9IGNvbW1lbnQucmVuZGVyRm9yVG9vbGJhcigpO1xuICAgIGlmICghYnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIGNvbnN0IGRpdmlkZXIgPSB0aGlzLiNjb21tZW50QnV0dG9uRGl2aWRlciA9IHRoaXMuI2RpdmlkZXI7XG4gICAgaWYgKCFiZWZvcmVFbGVtZW50KSB7XG4gICAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24sIGRpdmlkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNidXR0b25zLmluc2VydEJlZm9yZShidXR0b24sIGJlZm9yZUVsZW1lbnQpO1xuICAgICAgdGhpcy4jYnV0dG9ucy5pbnNlcnRCZWZvcmUoZGl2aWRlciwgYmVmb3JlRWxlbWVudCk7XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnQgPSBjb21tZW50O1xuICAgIGNvbW1lbnQudG9vbGJhciA9IHRoaXM7XG4gIH1cbiAgYWRkQ29sb3JQaWNrZXIoY29sb3JQaWNrZXIpIHtcbiAgICBpZiAodGhpcy4jY29sb3JQaWNrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29sb3JQaWNrZXIgPSBjb2xvclBpY2tlcjtcbiAgICBjb25zdCBidXR0b24gPSBjb2xvclBpY2tlci5yZW5kZXJCdXR0b24oKTtcbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24sIHRoaXMuI2RpdmlkZXIpO1xuICB9XG4gIGFzeW5jIGFkZEVkaXRTaWduYXR1cmVCdXR0b24oc2lnbmF0dXJlTWFuYWdlcikge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI3NpZ25hdHVyZURlc2NyaXB0aW9uQnV0dG9uID0gYXdhaXQgc2lnbmF0dXJlTWFuYWdlci5yZW5kZXJFZGl0QnV0dG9uKHRoaXMuI2VkaXRvcik7XG4gICAgdGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbik7XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uLCB0aGlzLiNkaXZpZGVyKTtcbiAgfVxuICByZW1vdmVCdXR0b24obmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgdGhpcy4jY29tbWVudD8ucmVtb3ZlVG9vbGJhckNvbW1lbnRCdXR0b24oKTtcbiAgICAgICAgdGhpcy4jY29tbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuI2NvbW1lbnRCdXR0b25EaXZpZGVyPy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy4jY29tbWVudEJ1dHRvbkRpdmlkZXIgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgYXN5bmMgYWRkQnV0dG9uKG5hbWUsIHRvb2wpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJjb2xvclBpY2tlclwiOlxuICAgICAgICB0aGlzLmFkZENvbG9yUGlja2VyKHRvb2wpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhbHRUZXh0XCI6XG4gICAgICAgIGF3YWl0IHRoaXMuYWRkQWx0VGV4dCh0b29sKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZWRpdFNpZ25hdHVyZVwiOlxuICAgICAgICBhd2FpdCB0aGlzLmFkZEVkaXRTaWduYXR1cmVCdXR0b24odG9vbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgICB0aGlzLmFkZERlbGV0ZUJ1dHRvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgIHRoaXMuYWRkQ29tbWVudCh0b29sKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGFzeW5jIGFkZEJ1dHRvbkJlZm9yZShuYW1lLCB0b29sLCBiZWZvcmVTZWxlY3Rvcikge1xuICAgIGNvbnN0IGJlZm9yZUVsZW1lbnQgPSB0aGlzLiNidXR0b25zLnF1ZXJ5U2VsZWN0b3IoYmVmb3JlU2VsZWN0b3IpO1xuICAgIGlmICghYmVmb3JlRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgIHRoaXMuYWRkQ29tbWVudCh0b29sLCBiZWZvcmVFbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlRWRpdFNpZ25hdHVyZUJ1dHRvbihkZXNjcmlwdGlvbikge1xuICAgIGlmICh0aGlzLiNzaWduYXR1cmVEZXNjcmlwdGlvbkJ1dHRvbikge1xuICAgICAgdGhpcy4jc2lnbmF0dXJlRGVzY3JpcHRpb25CdXR0b24udGl0bGUgPSBkZXNjcmlwdGlvbjtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuI3Rvb2xiYXIucmVtb3ZlKCk7XG4gICAgdGhpcy4jY29sb3JQaWNrZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNjb2xvclBpY2tlciA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIEZsb2F0aW5nVG9vbGJhciB7XG4gICNidXR0b25zID0gbnVsbDtcbiAgI3Rvb2xiYXIgPSBudWxsO1xuICAjdWlNYW5hZ2VyO1xuICBjb25zdHJ1Y3Rvcih1aU1hbmFnZXIpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gIH1cbiAgI3JlbmRlcigpIHtcbiAgICBjb25zdCBlZGl0VG9vbGJhciA9IHRoaXMuI3Rvb2xiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGVkaXRUb29sYmFyLmNsYXNzTmFtZSA9IFwiZWRpdFRvb2xiYXJcIjtcbiAgICBlZGl0VG9vbGJhci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbGJhclwiKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBpZiAoc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwgJiYgIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBlZGl0VG9vbGJhci5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBidXR0b25zID0gdGhpcy4jYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgYnV0dG9ucy5jbGFzc05hbWUgPSBcImJ1dHRvbnNcIjtcbiAgICBlZGl0VG9vbGJhci5hcHBlbmQoYnV0dG9ucyk7XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5oYXNDb21tZW50TWFuYWdlcigpKSB7XG4gICAgICB0aGlzLiNtYWtlQnV0dG9uKFwiY29tbWVudEJ1dHRvblwiLCBgcGRmanMtY29tbWVudC1mbG9hdGluZy1idXR0b25gLCBcInBkZmpzLWNvbW1lbnQtZmxvYXRpbmctYnV0dG9uLWxhYmVsXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1lbnRTZWxlY3Rpb24oXCJmbG9hdGluZ19idXR0b25cIik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy4jbWFrZUJ1dHRvbihcImhpZ2hsaWdodEJ1dHRvblwiLCBgcGRmanMtaGlnaGxpZ2h0LWZsb2F0aW5nLWJ1dHRvbjFgLCBcInBkZmpzLWhpZ2hsaWdodC1mbG9hdGluZy1idXR0b24tbGFiZWxcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmhpZ2hsaWdodFNlbGVjdGlvbihcImZsb2F0aW5nX2J1dHRvblwiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWRpdFRvb2xiYXI7XG4gIH1cbiAgI2dldExhc3RQb2ludChib3hlcywgaXNMVFIpIHtcbiAgICBsZXQgbGFzdFkgPSAwO1xuICAgIGxldCBsYXN0WCA9IDA7XG4gICAgZm9yIChjb25zdCBib3ggb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHkgPSBib3gueSArIGJveC5oZWlnaHQ7XG4gICAgICBpZiAoeSA8IGxhc3RZKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9IGJveC54ICsgKGlzTFRSID8gYm94LndpZHRoIDogMCk7XG4gICAgICBpZiAoeSA+IGxhc3RZKSB7XG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xUUikge1xuICAgICAgICBpZiAoeCA+IGxhc3RYKSB7XG4gICAgICAgICAgbGFzdFggPSB4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHggPCBsYXN0WCkge1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbaXNMVFIgPyAxIC0gbGFzdFggOiBsYXN0WCwgbGFzdFldO1xuICB9XG4gIHNob3cocGFyZW50LCBib3hlcywgaXNMVFIpIHtcbiAgICBjb25zdCBbeCwgeV0gPSB0aGlzLiNnZXRMYXN0UG9pbnQoYm94ZXMsIGlzTFRSKTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLiN0b29sYmFyIHx8PSB0aGlzLiNyZW5kZXIoKTtcbiAgICBwYXJlbnQuYXBwZW5kKHRoaXMuI3Rvb2xiYXIpO1xuICAgIHN0eWxlLmluc2V0SW5saW5lRW5kID0gYCR7MTAwICogeH0lYDtcbiAgICBzdHlsZS50b3AgPSBgY2FsYygkezEwMCAqIHl9JSArIHZhcigtLWVkaXRvci10b29sYmFyLXZlcnQtb2Zmc2V0KSlgO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgdGhpcy4jdG9vbGJhci5yZW1vdmUoKTtcbiAgfVxuICAjbWFrZUJ1dHRvbihidXR0b25DbGFzcywgbDEwbklkLCBsYWJlbEwxMG5JZCwgY2xpY2tIYW5kbGVyKSB7XG4gICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZChcImJhc2ljXCIsIGJ1dHRvbkNsYXNzKTtcbiAgICBidXR0b24udGFiSW5kZXggPSAwO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgbDEwbklkKTtcbiAgICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgYnV0dG9uLmFwcGVuZChzcGFuKTtcbiAgICBzcGFuLmNsYXNzTmFtZSA9IFwidmlzdWFsbHlIaWRkZW5cIjtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBsYWJlbEwxMG5JZCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgaWYgKHNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsICYmICFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNsaWNrSGFuZGxlciwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24pO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci90b29scy5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBiaW5kRXZlbnRzKG9iaiwgZWxlbWVudCwgbmFtZXMpIHtcbiAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIG9ialtuYW1lXS5iaW5kKG9iaikpO1xuICB9XG59XG5jbGFzcyBJZE1hbmFnZXIge1xuICAjaWQgPSAwO1xuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIGAke0Fubm90YXRpb25FZGl0b3JQcmVmaXh9JHt0aGlzLiNpZCsrfWA7XG4gIH1cbn1cbmNsYXNzIEltYWdlTWFuYWdlciB7XG4gICNiYXNlSWQgPSBnZXRVdWlkKCk7XG4gICNpZCA9IDA7XG4gICNjYWNoZSA9IG51bGw7XG4gIHN0YXRpYyBnZXQgX2lzU1ZHRml0dGluZ0NhbnZhcygpIHtcbiAgICBjb25zdCBzdmcgPSBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9VVRGLTgsPHN2ZyB2aWV3Qm94PVwiMCAwIDEgMVwiIHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHJlY3Qgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiIHN0eWxlPVwiZmlsbDpyZWQ7XCIvPjwvc3ZnPmA7XG4gICAgY29uc3QgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAzKTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2Uuc3JjID0gc3ZnO1xuICAgIGNvbnN0IHByb21pc2UgPSBpbWFnZS5kZWNvZGUoKS50aGVuKCgpID0+IHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIDEsIDEsIDAsIDAsIDEsIDMpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGEuYnVmZmVyKVswXSA9PT0gMDtcbiAgICB9KTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2lzU1ZHRml0dGluZ0NhbnZhc1wiLCBwcm9taXNlKTtcbiAgfVxuICBhc3luYyAjZ2V0KGtleSwgcmF3RGF0YSkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgbGV0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhPy5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYXRhIHx8PSB7XG4gICAgICAgIGJpdG1hcDogbnVsbCxcbiAgICAgICAgaWQ6IGBpbWFnZV8ke3RoaXMuI2Jhc2VJZH1fJHt0aGlzLiNpZCsrfWAsXG4gICAgICAgIHJlZkNvdW50ZXI6IDAsXG4gICAgICAgIGlzU3ZnOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGxldCBpbWFnZTtcbiAgICAgIGlmICh0eXBlb2YgcmF3RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhLnVybCA9IHJhd0RhdGE7XG4gICAgICAgIGltYWdlID0gYXdhaXQgZmV0Y2hEYXRhKHJhd0RhdGEsIFwiYmxvYlwiKTtcbiAgICAgIH0gZWxzZSBpZiAocmF3RGF0YSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgaW1hZ2UgPSBkYXRhLmZpbGUgPSByYXdEYXRhO1xuICAgICAgfSBlbHNlIGlmIChyYXdEYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBpbWFnZSA9IHJhd0RhdGE7XG4gICAgICB9XG4gICAgICBpZiAoaW1hZ2UudHlwZSA9PT0gXCJpbWFnZS9zdmcreG1sXCIpIHtcbiAgICAgICAgY29uc3QgbXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSA9IEltYWdlTWFuYWdlci5faXNTVkdGaXR0aW5nQ2FudmFzO1xuICAgICAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgY29uc3QgaW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGNvbnN0IGltYWdlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBpbWFnZUVsZW1lbnQub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgZGF0YS5iaXRtYXAgPSBpbWFnZUVsZW1lbnQ7XG4gICAgICAgICAgICBkYXRhLmlzU3ZnID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gZGF0YS5zdmdVcmwgPSBmaWxlUmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgIGltYWdlRWxlbWVudC5zcmMgPSAoYXdhaXQgbXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSkgPyBgJHt1cmx9I3N2Z1ZpZXcocHJlc2VydmVBc3BlY3RSYXRpbyhub25lKSlgIDogdXJsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaW1hZ2VFbGVtZW50Lm9uZXJyb3IgPSBmaWxlUmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoaW1hZ2UpO1xuICAgICAgICBhd2FpdCBpbWFnZVByb21pc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLmJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlKTtcbiAgICAgIH1cbiAgICAgIGRhdGEucmVmQ291bnRlciA9IDE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihlKTtcbiAgICAgIGRhdGEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCBkYXRhKTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KGRhdGEuaWQsIGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBhc3luYyBnZXRGcm9tRmlsZShmaWxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGFzdE1vZGlmaWVkLFxuICAgICAgbmFtZSxcbiAgICAgIHNpemUsXG4gICAgICB0eXBlXG4gICAgfSA9IGZpbGU7XG4gICAgcmV0dXJuIHRoaXMuI2dldChgJHtsYXN0TW9kaWZpZWR9XyR7bmFtZX1fJHtzaXplfV8ke3R5cGV9YCwgZmlsZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbVVybCh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy4jZ2V0KHVybCwgdXJsKTtcbiAgfVxuICBhc3luYyBnZXRGcm9tQmxvYihpZCwgYmxvYlByb21pc2UpIHtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgYmxvYlByb21pc2U7XG4gICAgcmV0dXJuIHRoaXMuI2dldChpZCwgYmxvYik7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YS5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZyb21GaWxlKGRhdGEuZmlsZSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmJsb2JQcm9taXNlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJsb2JQcm9taXNlXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGRlbGV0ZSBkYXRhLmJsb2JQcm9taXNlO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RnJvbUJsb2IoZGF0YS5pZCwgYmxvYlByb21pc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGcm9tVXJsKGRhdGEudXJsKTtcbiAgfVxuICBnZXRGcm9tQ2FudmFzKGlkLCBjYW52YXMpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGxldCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoZGF0YT8uYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjdHguZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG4gICAgZGF0YSA9IHtcbiAgICAgIGJpdG1hcDogb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpLFxuICAgICAgaWQ6IGBpbWFnZV8ke3RoaXMuI2Jhc2VJZH1fJHt0aGlzLiNpZCsrfWAsXG4gICAgICByZWZDb3VudGVyOiAxLFxuICAgICAgaXNTdmc6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoaWQsIGRhdGEpO1xuICAgIHRoaXMuI2NhY2hlLnNldChkYXRhLmlkLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBnZXRTdmdVcmwoaWQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGE/LmlzU3ZnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuc3ZnVXJsO1xuICB9XG4gIGRlbGV0ZUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS5yZWZDb3VudGVyIC09IDE7XG4gICAgaWYgKGRhdGEucmVmQ291bnRlciAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBiaXRtYXBcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIWRhdGEudXJsICYmICFkYXRhLmZpbGUpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiYml0bWFwcmVuZGVyZXJcIik7XG4gICAgICBjdHgudHJhbnNmZXJGcm9tSW1hZ2VCaXRtYXAoYml0bWFwKTtcbiAgICAgIGRhdGEuYmxvYlByb21pc2UgPSBjYW52YXMuY29udmVydFRvQmxvYigpO1xuICAgIH1cbiAgICBiaXRtYXAuY2xvc2U/LigpO1xuICAgIGRhdGEuYml0bWFwID0gbnVsbDtcbiAgfVxuICBpc1ZhbGlkSWQoaWQpIHtcbiAgICByZXR1cm4gaWQuc3RhcnRzV2l0aChgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9X2ApO1xuICB9XG59XG5jbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gICNjb21tYW5kcyA9IFtdO1xuICAjbG9ja2VkID0gZmFsc2U7XG4gICNtYXhTaXplO1xuICAjcG9zaXRpb24gPSAtMTtcbiAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDEyOCkge1xuICAgIHRoaXMuI21heFNpemUgPSBtYXhTaXplO1xuICB9XG4gIGFkZCh7XG4gICAgY21kLFxuICAgIHVuZG8sXG4gICAgcG9zdCxcbiAgICBtdXN0RXhlYyxcbiAgICB0eXBlID0gTmFOLFxuICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGUgPSBmYWxzZSxcbiAgICBrZWVwVW5kbyA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAobXVzdEV4ZWMpIHtcbiAgICAgIGNtZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbG9ja2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNhdmUgPSB7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgcG9zdCxcbiAgICAgIHR5cGVcbiAgICB9O1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIGlmICh0aGlzLiNjb21tYW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3ZlcndyaXRlSWZTYW1lVHlwZSAmJiB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udHlwZSA9PT0gdHlwZSkge1xuICAgICAgaWYgKGtlZXBVbmRvKSB7XG4gICAgICAgIHNhdmUudW5kbyA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS51bmRvO1xuICAgICAgfVxuICAgICAgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dID0gc2F2ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuI3Bvc2l0aW9uICsgMTtcbiAgICBpZiAobmV4dCA9PT0gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKDAsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IG5leHQ7XG4gICAgICBpZiAobmV4dCA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbW1hbmRzLnB1c2goc2F2ZSk7XG4gIH1cbiAgdW5kbygpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgdW5kbyxcbiAgICAgIHBvc3RcbiAgICB9ID0gdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dO1xuICAgIHVuZG8oKTtcbiAgICBwb3N0Py4oKTtcbiAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLiNwb3NpdGlvbiAtPSAxO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uIDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy4jcG9zaXRpb24gKz0gMTtcbiAgICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNtZCxcbiAgICAgICAgcG9zdFxuICAgICAgfSA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXTtcbiAgICAgIGNtZCgpO1xuICAgICAgcG9zdD8uKCk7XG4gICAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9VbmRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiAhPT0gLTE7XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9SZWRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDE7XG4gIH1cbiAgY2xlYW5UeXBlKHR5cGUpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSB0aGlzLiNwb3NpdGlvbjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLiNjb21tYW5kc1tpXS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZShpICsgMSwgdGhpcy4jcG9zaXRpb24gLSBpKTtcbiAgICAgICAgdGhpcy4jcG9zaXRpb24gPSBpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy4jcG9zaXRpb24gPSAtMTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2NvbW1hbmRzID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgS2V5Ym9hcmRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmFsbEtleXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBmb3IgKGNvbnN0IFtrZXlzLCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9XSBvZiBjYWxsYmFja3MpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgaXNNYWNLZXkgPSBrZXkuc3RhcnRzV2l0aChcIm1hYytcIik7XG4gICAgICAgIGlmIChpc01hYyAmJiBpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXkuc2xpY2UoNCksIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWxsS2V5cy5hZGQoa2V5LnNwbGl0KFwiK1wiKS5hdCgtMSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc01hYyAmJiAhaXNNYWNLZXkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zZXQoa2V5LCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFsbEtleXMuYWRkKGtleS5zcGxpdChcIitcIikuYXQoLTEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAjc2VyaWFsaXplKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcImFsdFwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJjdHJsXCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQubWV0YUtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcIm1ldGFcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcInNoaWZ0XCIpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGV2ZW50LmtleSk7XG4gICAgY29uc3Qgc3RyID0gdGhpcy5idWZmZXIuam9pbihcIitcIik7XG4gICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGV4ZWMoc2VsZiwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuYWxsS2V5cy5oYXMoZXZlbnQua2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmZvID0gdGhpcy5jYWxsYmFja3MuZ2V0KHRoaXMuI3NlcmlhbGl6ZShldmVudCkpO1xuICAgIGlmICghaW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYnViYmxlcyA9IGZhbHNlLFxuICAgICAgICBhcmdzID0gW10sXG4gICAgICAgIGNoZWNrZXIgPSBudWxsXG4gICAgICB9XG4gICAgfSA9IGluZm87XG4gICAgaWYgKGNoZWNrZXIgJiYgIWNoZWNrZXIoc2VsZiwgZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrLmJpbmQoc2VsZiwgLi4uYXJncywgZXZlbnQpKCk7XG4gICAgaWYgKCFidWJibGVzKSB7XG4gICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQ29sb3JNYW5hZ2VyIHtcbiAgc3RhdGljIF9jb2xvcnNNYXBwaW5nID0gbmV3IE1hcChbW1wiQ2FudmFzVGV4dFwiLCBbMCwgMCwgMF1dLCBbXCJDYW52YXNcIiwgWzI1NSwgMjU1LCAyNTVdXV0pO1xuICBnZXQgX2NvbG9ycygpIHtcbiAgICBjb25zdCBjb2xvcnMgPSBuZXcgTWFwKFtbXCJDYW52YXNUZXh0XCIsIG51bGxdLCBbXCJDYW52YXNcIiwgbnVsbF1dKTtcbiAgICBnZXRDb2xvclZhbHVlcyhjb2xvcnMpO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfY29sb3JzXCIsIGNvbG9ycyk7XG4gIH1cbiAgY29udmVydChjb2xvcikge1xuICAgIGNvbnN0IHJnYiA9IGdldFJHQihjb2xvcik7XG4gICAgaWYgKCF3aW5kb3cubWF0Y2hNZWRpYShcIihmb3JjZWQtY29sb3JzOiBhY3RpdmUpXCIpLm1hdGNoZXMpIHtcbiAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUsIFJHQl0gb2YgdGhpcy5fY29sb3JzKSB7XG4gICAgICBpZiAoUkdCLmV2ZXJ5KCh4LCBpKSA9PiB4ID09PSByZ2JbaV0pKSB7XG4gICAgICAgIHJldHVybiBDb2xvck1hbmFnZXIuX2NvbG9yc01hcHBpbmcuZ2V0KG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmdiO1xuICB9XG4gIGdldEhleENvZGUobmFtZSkge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX2NvbG9ycy5nZXQobmFtZSk7XG4gICAgaWYgKCFyZ2IpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbC5tYWtlSGV4Q29sb3IoLi4ucmdiKTtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciB7XG4gICNhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAjYWxsRWRpdGFibGVBbm5vdGF0aW9ucyA9IG51bGw7XG4gICNhbGxFZGl0b3JzID0gbmV3IE1hcCgpO1xuICAjYWxsTGF5ZXJzID0gbmV3IE1hcCgpO1xuICAjYWx0VGV4dE1hbmFnZXIgPSBudWxsO1xuICAjYW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsO1xuICAjY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnMgPSBudWxsO1xuICAjY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoKTtcbiAgI2NvbW1lbnRNYW5hZ2VyID0gbnVsbDtcbiAgI2NvcHlQYXN0ZUFDID0gbnVsbDtcbiAgI2N1cnJlbnREcmF3aW5nU2Vzc2lvbiA9IG51bGw7XG4gICNjdXJyZW50UGFnZUluZGV4ID0gMDtcbiAgI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMgPSBuZXcgU2V0KCk7XG4gICNkcmFnZ2luZ0VkaXRvcnMgPSBudWxsO1xuICAjZWRpdG9yVHlwZXMgPSBudWxsO1xuICAjZWRpdG9yc1RvUmVzY2FsZSA9IG5ldyBTZXQoKTtcbiAgX2VkaXRvclVuZG9CYXIgPSBudWxsO1xuICAjZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24gPSBmYWxzZTtcbiAgI2VuYWJsZVVwZGF0ZWRBZGRJbWFnZSA9IGZhbHNlO1xuICAjZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSA9IGZhbHNlO1xuICAjZmlsdGVyRmFjdG9yeSA9IG51bGw7XG4gICNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQgPSBudWxsO1xuICAjZm9jdXNNYW5hZ2VyQUMgPSBudWxsO1xuICAjaGlnaGxpZ2h0Q29sb3JzID0gbnVsbDtcbiAgI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gZmFsc2U7XG4gICNmbG9hdGluZ1Rvb2xiYXIgPSBudWxsO1xuICAjaWRNYW5hZ2VyID0gbmV3IElkTWFuYWdlcigpO1xuICAjaXNFbmFibGVkID0gZmFsc2U7XG4gICNpc1BvaW50ZXJEb3duID0gZmFsc2U7XG4gICNpc1dhaXRpbmcgPSBmYWxzZTtcbiAgI2tleWJvYXJkTWFuYWdlckFDID0gbnVsbDtcbiAgI2xhc3RBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgI21haW5IaWdobGlnaHRDb2xvclBpY2tlciA9IG51bGw7XG4gICNtaXNzaW5nQ2FudmFzZXMgPSBudWxsO1xuICAjbWxNYW5hZ2VyID0gbnVsbDtcbiAgI21vZGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FO1xuICAjc2VsZWN0ZWRFZGl0b3JzID0gbmV3IFNldCgpO1xuICAjc2VsZWN0ZWRUZXh0Tm9kZSA9IG51bGw7XG4gICNzaWduYXR1cmVNYW5hZ2VyID0gbnVsbDtcbiAgI3BhZ2VDb2xvcnMgPSBudWxsO1xuICAjc2hvd0FsbFN0YXRlcyA9IG51bGw7XG4gICNwZGZEb2N1bWVudCA9IG51bGw7XG4gICNwcmV2aW91c1N0YXRlcyA9IHtcbiAgICBpc0VkaXRpbmc6IGZhbHNlLFxuICAgIGlzRW1wdHk6IHRydWUsXG4gICAgaGFzU29tZXRoaW5nVG9VbmRvOiBmYWxzZSxcbiAgICBoYXNTb21ldGhpbmdUb1JlZG86IGZhbHNlLFxuICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZSxcbiAgICBoYXNTZWxlY3RlZFRleHQ6IGZhbHNlXG4gIH07XG4gICN0cmFuc2xhdGlvbiA9IFswLCAwXTtcbiAgI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICN2aWV3ZXIgPSBudWxsO1xuICAjdmlld2VyQWxlcnQgPSBudWxsO1xuICAjdXBkYXRlTW9kZUNhcGFiaWxpdHkgPSBudWxsO1xuICBzdGF0aWMgVFJBTlNMQVRFX1NNQUxMID0gMTtcbiAgc3RhdGljIFRSQU5TTEFURV9CSUcgPSAxMDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5wcm90b3R5cGU7XG4gICAgY29uc3QgYXJyb3dDaGVja2VyID0gc2VsZiA9PiBzZWxmLiNjb250YWluZXIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50YWdOYW1lICE9PSBcIkJVVFRPTlwiICYmIHNlbGYuaGFzU29tZXRoaW5nVG9Db250cm9sKCk7XG4gICAgY29uc3QgdGV4dElucHV0Q2hlY2tlciA9IChfc2VsZiwge1xuICAgICAgdGFyZ2V0OiBlbFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSA9IGVsO1xuICAgICAgICByZXR1cm4gdHlwZSAhPT0gXCJ0ZXh0XCIgJiYgdHlwZSAhPT0gXCJudW1iZXJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3Qgc21hbGwgPSB0aGlzLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSB0aGlzLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9rZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcImN0cmwrYVwiLCBcIm1hYyttZXRhK2FcIl0sIHByb3RvLnNlbGVjdEFsbCwge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCt6XCIsIFwibWFjK21ldGErelwiXSwgcHJvdG8udW5kbywge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCt5XCIsIFwiY3RybCtzaGlmdCt6XCIsIFwibWFjK21ldGErc2hpZnQrelwiLCBcImN0cmwrc2hpZnQrWlwiLCBcIm1hYyttZXRhK3NoaWZ0K1pcIl0sIHByb3RvLnJlZG8sIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcIkJhY2tzcGFjZVwiLCBcImFsdCtCYWNrc3BhY2VcIiwgXCJjdHJsK0JhY2tzcGFjZVwiLCBcInNoaWZ0K0JhY2tzcGFjZVwiLCBcIm1hYytCYWNrc3BhY2VcIiwgXCJtYWMrYWx0K0JhY2tzcGFjZVwiLCBcIm1hYytjdHJsK0JhY2tzcGFjZVwiLCBcIkRlbGV0ZVwiLCBcImN0cmwrRGVsZXRlXCIsIFwic2hpZnQrRGVsZXRlXCIsIFwibWFjK0RlbGV0ZVwiXSwgcHJvdG8uZGVsZXRlLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJFbnRlclwiLCBcIm1hYytFbnRlclwiXSwgcHJvdG8uYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkLCB7XG4gICAgICBjaGVja2VyOiAoc2VsZiwge1xuICAgICAgICB0YXJnZXQ6IGVsXG4gICAgICB9KSA9PiAhKGVsIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpICYmIHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhlbCkgJiYgIXNlbGYuaXNFbnRlckhhbmRsZWRcbiAgICB9XSwgW1tcIiBcIiwgXCJtYWMrIFwiXSwgcHJvdG8uYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkLCB7XG4gICAgICBjaGVja2VyOiAoc2VsZiwge1xuICAgICAgICB0YXJnZXQ6IGVsXG4gICAgICB9KSA9PiAhKGVsIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpICYmIHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgIH1dLCBbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgcHJvdG8udW5zZWxlY3RBbGxdLCBbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbLXNtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0xlZnRcIiwgXCJtYWMrc2hpZnQrQXJyb3dMZWZ0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFstYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFtzbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dSaWdodFwiLCBcIm1hYytzaGlmdCtBcnJvd1JpZ2h0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFtiaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIC1zbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dVcFwiLCBcIm1hYytzaGlmdCtBcnJvd1VwXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCAtYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93RG93blwiLCBcIm1hYytzaGlmdCtBcnJvd0Rvd25cIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIGJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XV0pKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHZpZXdlciwgdmlld2VyQWxlcnQsIGFsdFRleHRNYW5hZ2VyLCBjb21tZW50TWFuYWdlciwgc2lnbmF0dXJlTWFuYWdlciwgZXZlbnRCdXMsIHBkZkRvY3VtZW50LCBwYWdlQ29sb3JzLCBoaWdobGlnaHRDb2xvcnMsIGVuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uLCBlbmFibGVVcGRhdGVkQWRkSW1hZ2UsIGVuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UsIG1sTWFuYWdlciwgZWRpdG9yVW5kb0Jhciwgc3VwcG9ydHNQaW5jaFRvWm9vbSkge1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3NpZ25hbCA9IHRoaXMuI2Fib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3ZpZXdlciA9IHZpZXdlcjtcbiAgICB0aGlzLiN2aWV3ZXJBbGVydCA9IHZpZXdlckFsZXJ0O1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyID0gYWx0VGV4dE1hbmFnZXI7XG4gICAgdGhpcy4jY29tbWVudE1hbmFnZXIgPSBjb21tZW50TWFuYWdlcjtcbiAgICB0aGlzLiNzaWduYXR1cmVNYW5hZ2VyID0gc2lnbmF0dXJlTWFuYWdlcjtcbiAgICB0aGlzLiNwZGZEb2N1bWVudCA9IHBkZkRvY3VtZW50O1xuICAgIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgZXZlbnRCdXMuX29uKFwiZWRpdGluZ2FjdGlvblwiLCB0aGlzLm9uRWRpdGluZ0FjdGlvbi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJwYWdlY2hhbmdpbmdcIiwgdGhpcy5vblBhZ2VDaGFuZ2luZy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJzY2FsZWNoYW5naW5nXCIsIHRoaXMub25TY2FsZUNoYW5naW5nLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInJvdGF0aW9uY2hhbmdpbmdcIiwgdGhpcy5vblJvdGF0aW9uQ2hhbmdpbmcuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic2V0cHJlZmVyZW5jZVwiLCB0aGlzLm9uU2V0UHJlZmVyZW5jZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ycGFyYW1zXCIsIGV2dCA9PiB0aGlzLnVwZGF0ZVBhcmFtcyhldnQudHlwZSwgZXZ0LnZhbHVlKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCAoKSA9PiB7XG4gICAgICB0aGlzLiNpc1BvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICB9LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jaXNQb2ludGVyRG93biA9IGZhbHNlO1xuICAgIH0sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNhZGRTZWxlY3Rpb25MaXN0ZW5lcigpO1xuICAgIHRoaXMuI2FkZERyYWdBbmREcm9wTGlzdGVuZXJzKCk7XG4gICAgdGhpcy4jYWRkS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UgPSBwZGZEb2N1bWVudC5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLiNmaWx0ZXJGYWN0b3J5ID0gcGRmRG9jdW1lbnQuZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLiNwYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLiNoaWdobGlnaHRDb2xvcnMgPSBoaWdobGlnaHRDb2xvcnMgfHwgbnVsbDtcbiAgICB0aGlzLiNlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbiA9IGVuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uO1xuICAgIHRoaXMuI2VuYWJsZVVwZGF0ZWRBZGRJbWFnZSA9IGVuYWJsZVVwZGF0ZWRBZGRJbWFnZTtcbiAgICB0aGlzLiNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlID0gZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZTtcbiAgICB0aGlzLiNtbE1hbmFnZXIgPSBtbE1hbmFnZXIgfHwgbnVsbDtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzID0ge1xuICAgICAgcmVhbFNjYWxlOiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMsXG4gICAgICByb3RhdGlvbjogMFxuICAgIH07XG4gICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IGZhbHNlO1xuICAgIHRoaXMuX2VkaXRvclVuZG9CYXIgPSBlZGl0b3JVbmRvQmFyIHx8IG51bGw7XG4gICAgdGhpcy5fc3VwcG9ydHNQaW5jaFRvWm9vbSA9IHN1cHBvcnRzUGluY2hUb1pvb20gIT09IGZhbHNlO1xuICAgIGNvbW1lbnRNYW5hZ2VyPy5zZXRTaWRlYmFyVWlNYW5hZ2VyKHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHk/LnJlc29sdmUoKTtcbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy4jYWJvcnRDb250cm9sbGVyPy5hYm9ydCgpO1xuICAgIHRoaXMuI2Fib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy5fc2lnbmFsID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLiNhbGxMYXllcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5jbGVhcigpO1xuICAgIHRoaXMuI21pc3NpbmdDYW52YXNlcz8uY2xlYXIoKTtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jc2lnbmF0dXJlTWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhcj8uaGlkZSgpO1xuICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhciA9IG51bGw7XG4gICAgdGhpcy4jbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyID0gbnVsbDtcbiAgICB0aGlzLiNhbGxFZGl0YWJsZUFubm90YXRpb25zID0gbnVsbDtcbiAgICBpZiAodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKTtcbiAgICAgIHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKTtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fZWRpdG9yVW5kb0Jhcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI3BkZkRvY3VtZW50ID0gbnVsbDtcbiAgfVxuICBjb21iaW5lZFNpZ25hbChhYykge1xuICAgIHJldHVybiBBYm9ydFNpZ25hbC5hbnkoW3RoaXMuX3NpZ25hbCwgYWMuc2lnbmFsXSk7XG4gIH1cbiAgZ2V0IG1sTWFuYWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jbWxNYW5hZ2VyO1xuICB9XG4gIGdldCB1c2VOZXdBbHRUZXh0RmxvdygpIHtcbiAgICByZXR1cm4gdGhpcy4jZW5hYmxlVXBkYXRlZEFkZEltYWdlO1xuICB9XG4gIGdldCB1c2VOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLiNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlO1xuICB9XG4gIGdldCBoY21GaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImhjbUZpbHRlclwiLCB0aGlzLiNwYWdlQ29sb3JzID8gdGhpcy4jZmlsdGVyRmFjdG9yeS5hZGRIQ01GaWx0ZXIodGhpcy4jcGFnZUNvbG9ycy5mb3JlZ3JvdW5kLCB0aGlzLiNwYWdlQ29sb3JzLmJhY2tncm91bmQpIDogXCJub25lXCIpO1xuICB9XG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImRpcmVjdGlvblwiLCBnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2NvbnRhaW5lcikuZGlyZWN0aW9uKTtcbiAgfVxuICBnZXQgX2hpZ2hsaWdodENvbG9ycygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2hpZ2hsaWdodENvbG9yc1wiLCB0aGlzLiNoaWdobGlnaHRDb2xvcnMgPyBuZXcgTWFwKHRoaXMuI2hpZ2hsaWdodENvbG9ycy5zcGxpdChcIixcIikubWFwKHBhaXIgPT4ge1xuICAgICAgcGFpciA9IHBhaXIuc3BsaXQoXCI9XCIpLm1hcCh4ID0+IHgudHJpbSgpKTtcbiAgICAgIHBhaXJbMV0gPSBwYWlyWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9KSkgOiBudWxsKTtcbiAgfVxuICBnZXQgaGlnaGxpZ2h0Q29sb3JzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9oaWdobGlnaHRDb2xvcnNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIV9oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIHJldHVybiBzaGFkb3codGhpcywgXCJoaWdobGlnaHRDb2xvcnNcIiwgbnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBoYXNIQ00gPSAhIXRoaXMuI3BhZ2VDb2xvcnM7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgY29sb3JdIG9mIF9oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGlzTmFtZUZvckhDTSA9IG5hbWUuZW5kc1dpdGgoXCJfSENNXCIpO1xuICAgICAgaWYgKGhhc0hDTSAmJiBpc05hbWVGb3JIQ00pIHtcbiAgICAgICAgbWFwLnNldChuYW1lLnJlcGxhY2UoXCJfSENNXCIsIFwiXCIpLCBjb2xvcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNIQ00gJiYgIWlzTmFtZUZvckhDTSkge1xuICAgICAgICBtYXAuc2V0KG5hbWUsIGNvbG9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImhpZ2hsaWdodENvbG9yc1wiLCBtYXApO1xuICB9XG4gIGdldCBoaWdobGlnaHRDb2xvck5hbWVzKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJoaWdobGlnaHRDb2xvck5hbWVzXCIsIHRoaXMuaGlnaGxpZ2h0Q29sb3JzID8gbmV3IE1hcChBcnJheS5mcm9tKHRoaXMuaGlnaGxpZ2h0Q29sb3JzLCBlID0+IGUucmV2ZXJzZSgpKSkgOiBudWxsKTtcbiAgfVxuICBnZXROb25IQ01Db2xvcihjb2xvcikge1xuICAgIGlmICghdGhpcy5faGlnaGxpZ2h0Q29sb3JzKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yTmFtZSA9IHRoaXMuaGlnaGxpZ2h0Q29sb3JOYW1lcy5nZXQoY29sb3IpO1xuICAgIHJldHVybiB0aGlzLl9oaWdobGlnaHRDb2xvcnMuZ2V0KGNvbG9yTmFtZSkgfHwgY29sb3I7XG4gIH1cbiAgZ2V0Tm9uSENNQ29sb3JOYW1lKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaGxpZ2h0Q29sb3JOYW1lcy5nZXQoY29sb3IpIHx8IGNvbG9yO1xuICB9XG4gIHNldEN1cnJlbnREcmF3aW5nU2Vzc2lvbihsYXllcikge1xuICAgIGlmIChsYXllcikge1xuICAgICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdChmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnREcmF3aW5nU2Vzc2lvbiA9IGxheWVyO1xuICB9XG4gIHNldE1haW5IaWdobGlnaHRDb2xvclBpY2tlcihjb2xvclBpY2tlcikge1xuICAgIHRoaXMuI21haW5IaWdobGlnaHRDb2xvclBpY2tlciA9IGNvbG9yUGlja2VyO1xuICB9XG4gIGVkaXRBbHRUZXh0KGVkaXRvciwgZmlyc3RUaW1lID0gZmFsc2UpIHtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlcj8uZWRpdEFsdFRleHQodGhpcywgZWRpdG9yLCBmaXJzdFRpbWUpO1xuICB9XG4gIGhhc0NvbW1lbnRNYW5hZ2VyKCkge1xuICAgIHJldHVybiAhIXRoaXMuI2NvbW1lbnRNYW5hZ2VyO1xuICB9XG4gIGVkaXRDb21tZW50KGVkaXRvciwgcG9zWCwgcG9zWSwgb3B0aW9ucykge1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5zaG93RGlhbG9nKHRoaXMsIGVkaXRvciwgcG9zWCwgcG9zWSwgb3B0aW9ucyk7XG4gIH1cbiAgc2VsZWN0Q29tbWVudChwYWdlSW5kZXgsIHVpZCkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICAgIGNvbnN0IGVkaXRvciA9IGxheWVyPy5nZXRFZGl0b3JCeVVJRCh1aWQpO1xuICAgIGVkaXRvcj8udG9nZ2xlQ29tbWVudCh0cnVlLCB0cnVlKTtcbiAgfVxuICB1cGRhdGVDb21tZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy51cGRhdGVDb21tZW50KGVkaXRvci5nZXREYXRhKCkpO1xuICB9XG4gIHVwZGF0ZVBvcHVwQ29sb3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jY29tbWVudE1hbmFnZXI/LnVwZGF0ZVBvcHVwQ29sb3IoZWRpdG9yKTtcbiAgfVxuICByZW1vdmVDb21tZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5yZW1vdmVDb21tZW50cyhbZWRpdG9yLnVpZF0pO1xuICB9XG4gIHRvZ2dsZUNvbW1lbnQoZWRpdG9yLCBpc1NlbGVjdGVkLCB2aXNpYmlsaXR5ID0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy4jY29tbWVudE1hbmFnZXI/LnRvZ2dsZUNvbW1lbnRQb3B1cChlZGl0b3IsIGlzU2VsZWN0ZWQsIHZpc2liaWxpdHkpO1xuICB9XG4gIG1ha2VDb21tZW50Q29sb3IoY29sb3IsIG9wYWNpdHkpIHtcbiAgICByZXR1cm4gY29sb3IgJiYgdGhpcy4jY29tbWVudE1hbmFnZXI/Lm1ha2VDb21tZW50Q29sb3IoY29sb3IsIG9wYWNpdHkpIHx8IG51bGw7XG4gIH1cbiAgZ2V0Q29tbWVudERpYWxvZ0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5kaWFsb2dFbGVtZW50IHx8IG51bGw7XG4gIH1cbiAgYXN5bmMgd2FpdEZvckVkaXRvcnNSZW5kZXJlZChwYWdlTnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuI2FsbExheWVycy5oYXMocGFnZU51bWJlciAtIDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHJlc29sdmUsXG4gICAgICBwcm9taXNlXG4gICAgfSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIGNvbnN0IG9uRWRpdG9yc1JlbmRlcmVkID0gZXZ0ID0+IHtcbiAgICAgIGlmIChldnQucGFnZU51bWJlciA9PT0gcGFnZU51bWJlcikge1xuICAgICAgICB0aGlzLl9ldmVudEJ1cy5fb2ZmKFwiZWRpdG9yc3JlbmRlcmVkXCIsIG9uRWRpdG9yc1JlbmRlcmVkKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fZXZlbnRCdXMub24oXCJlZGl0b3JzcmVuZGVyZWRcIiwgb25FZGl0b3JzUmVuZGVyZWQpO1xuICAgIGF3YWl0IHByb21pc2U7XG4gIH1cbiAgZ2V0U2lnbmF0dXJlKGVkaXRvcikge1xuICAgIHRoaXMuI3NpZ25hdHVyZU1hbmFnZXI/LmdldFNpZ25hdHVyZSh7XG4gICAgICB1aU1hbmFnZXI6IHRoaXMsXG4gICAgICBlZGl0b3JcbiAgICB9KTtcbiAgfVxuICBnZXQgc2lnbmF0dXJlTWFuYWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2lnbmF0dXJlTWFuYWdlcjtcbiAgfVxuICBzd2l0Y2hUb01vZGUobW9kZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5vbihcImFubm90YXRpb25lZGl0b3Jtb2RlY2hhbmdlZFwiLCBjYWxsYmFjaywge1xuICAgICAgb25jZTogdHJ1ZSxcbiAgICAgIHNpZ25hbDogdGhpcy5fc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzaG93YW5ub3RhdGlvbmVkaXRvcnVpXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIG1vZGVcbiAgICB9KTtcbiAgfVxuICBzZXRQcmVmZXJlbmNlKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzZXRwcmVmZXJlbmNlXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIG5hbWUsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9XG4gIG9uU2V0UHJlZmVyZW5jZSh7XG4gICAgbmFtZSxcbiAgICB2YWx1ZVxuICB9KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwiZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZVwiOlxuICAgICAgICB0aGlzLiNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBvblBhZ2VDaGFuZ2luZyh7XG4gICAgcGFnZU51bWJlclxuICB9KSB7XG4gICAgdGhpcy4jY3VycmVudFBhZ2VJbmRleCA9IHBhZ2VOdW1iZXIgLSAxO1xuICB9XG4gIGZvY3VzTWFpbkNvbnRhaW5lcigpIHtcbiAgICB0aGlzLiNjb250YWluZXIuZm9jdXMoKTtcbiAgfVxuICBmaW5kUGFyZW50KHgsIHkpIHtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4OiBsYXllclgsXG4gICAgICAgIHk6IGxheWVyWSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IGxheWVyLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICh4ID49IGxheWVyWCAmJiB4IDw9IGxheWVyWCArIHdpZHRoICYmIHkgPj0gbGF5ZXJZICYmIHkgPD0gbGF5ZXJZICsgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGlzYWJsZVVzZXJTZWxlY3QodmFsdWUgPSBmYWxzZSkge1xuICAgIHRoaXMuI3ZpZXdlci5jbGFzc0xpc3QudG9nZ2xlKFwibm9Vc2VyU2VsZWN0XCIsIHZhbHVlKTtcbiAgfVxuICBhZGRTaG91bGRSZXNjYWxlKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuYWRkKGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlU2hvdWxkUmVzY2FsZShlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmRlbGV0ZShlZGl0b3IpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZyh7XG4gICAgc2NhbGVcbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZSA9IHNjYWxlICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUpIHtcbiAgICAgIGVkaXRvci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICB9XG4gICAgdGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgfVxuICBvblJvdGF0aW9uQ2hhbmdpbmcoe1xuICAgIHBhZ2VzUm90YXRpb25cbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uID0gcGFnZXNSb3RhdGlvbjtcbiAgfVxuICAjZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbih7XG4gICAgYW5jaG9yTm9kZVxuICB9KSB7XG4gICAgcmV0dXJuIGFuY2hvck5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gYW5jaG9yTm9kZS5wYXJlbnRFbGVtZW50IDogYW5jaG9yTm9kZTtcbiAgfVxuICAjZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudExheWVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGN1cnJlbnRMYXllci5oYXNUZXh0TGF5ZXIodGV4dExheWVyKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRMYXllcjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChsYXllci5oYXNUZXh0TGF5ZXIodGV4dExheWVyKSkge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhpZ2hsaWdodFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uID0gXCJcIiwgY29tbWVudCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldFxuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgdGV4dCA9IHNlbGVjdGlvbi50b1N0cmluZygpO1xuICAgIGNvbnN0IGFuY2hvckVsZW1lbnQgPSB0aGlzLiNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgdGV4dExheWVyID0gYW5jaG9yRWxlbWVudC5jbG9zZXN0KFwiLnRleHRMYXllclwiKTtcbiAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0U2VsZWN0aW9uQm94ZXModGV4dExheWVyKTtcbiAgICBpZiAoIWJveGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGVjdGlvbi5lbXB0eSgpO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKTtcbiAgICBjb25zdCBpc05vbmVNb2RlID0gdGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGVkaXRvciA9IGxheWVyPy5jcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LCBmYWxzZSwge1xuICAgICAgICBtZXRob2RPZkNyZWF0aW9uLFxuICAgICAgICBib3hlcyxcbiAgICAgICAgYW5jaG9yTm9kZSxcbiAgICAgICAgYW5jaG9yT2Zmc2V0LFxuICAgICAgICBmb2N1c05vZGUsXG4gICAgICAgIGZvY3VzT2Zmc2V0LFxuICAgICAgICB0ZXh0XG4gICAgICB9KTtcbiAgICAgIGlmIChpc05vbmVNb2RlKSB7XG4gICAgICAgIHRoaXMuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBlZGl0b3I/LmVkaXRDb21tZW50KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNOb25lTW9kZSkge1xuICAgICAgdGhpcy5zd2l0Y2hUb01vZGUoQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULCBjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH1cbiAgY29tbWVudFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uID0gXCJcIikge1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uKG1ldGhvZE9mQ3JlYXRpb24sIHRydWUpO1xuICB9XG4gICNkaXNwbGF5RmxvYXRpbmdUb29sYmFyKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLmdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcik7XG4gICAgaWYgKCFib3hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNmbG9hdGluZ1Rvb2xiYXIgfHw9IG5ldyBGbG9hdGluZ1Rvb2xiYXIodGhpcyk7XG4gICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyLnNob3codGV4dExheWVyLCBib3hlcywgdGhpcy5kaXJlY3Rpb24gPT09IFwibHRyXCIpO1xuICB9XG4gIGdldEFuZFJlbW92ZURhdGFGcm9tQW5ub3RhdGlvblN0b3JhZ2UoYW5ub3RhdGlvbklkKSB7XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGAke0Fubm90YXRpb25FZGl0b3JQcmVmaXh9JHthbm5vdGF0aW9uSWR9YDtcbiAgICBjb25zdCBzdG9yZWRWYWx1ZSA9IHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKGtleSk7XG4gICAgaWYgKHN0b3JlZFZhbHVlKSB7XG4gICAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5yZW1vdmUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JlZFZhbHVlO1xuICB9XG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNFbXB0eSgpICYmIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlICYmICF0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhMTF5QWxlcnQobWVzc2FnZUlkLCBhcmdzID0gbnVsbCkge1xuICAgIGNvbnN0IHZpZXdlckFsZXJ0ID0gdGhpcy4jdmlld2VyQWxlcnQ7XG4gICAgaWYgKCF2aWV3ZXJBbGVydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2aWV3ZXJBbGVydC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgbWVzc2FnZUlkKTtcbiAgICBpZiAoYXJncykge1xuICAgICAgdmlld2VyQWxlcnQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3ZXJBbGVydC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiKTtcbiAgICB9XG4gIH1cbiAgI3NlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICAgIGlmICh0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhcj8uaGlkZSgpO1xuICAgICAgICB0aGlzLiNzZWxlY3RlZFRleHROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICAgIGhhc1NlbGVjdGVkVGV4dDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvck5vZGVcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGlmIChhbmNob3JOb2RlID09PSB0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvckVsZW1lbnQgPSB0aGlzLiNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgdGV4dExheWVyID0gYW5jaG9yRWxlbWVudC5jbG9zZXN0KFwiLnRleHRMYXllclwiKTtcbiAgICBpZiAoIXRleHRMYXllcikge1xuICAgICAgaWYgKHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUpIHtcbiAgICAgICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyPy5oaWRlKCk7XG4gICAgICAgIHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgICAgaGFzU2VsZWN0ZWRUZXh0OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyPy5oaWRlKCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSA9IGFuY2hvck5vZGU7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRUZXh0OiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCAmJiB0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gdGhpcy5pc1NoaWZ0S2V5RG93bjtcbiAgICBpZiAoIXRoaXMuaXNTaGlmdEtleURvd24pIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUxheWVyID0gdGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUID8gdGhpcy4jZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKSA6IG51bGw7XG4gICAgICBhY3RpdmVMYXllcj8udG9nZ2xlRHJhd2luZygpO1xuICAgICAgaWYgKHRoaXMuI2lzUG9pbnRlckRvd24pIHtcbiAgICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwoYWMpO1xuICAgICAgICBjb25zdCBwb2ludGVydXAgPSBlID0+IHtcbiAgICAgICAgICBpZiAoZS50eXBlID09PSBcInBvaW50ZXJ1cFwiICYmIGUuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgICAgYWN0aXZlTGF5ZXI/LnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJwb2ludGVydXBcIikge1xuICAgICAgICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVydXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVydXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVMYXllcj8udG9nZ2xlRHJhd2luZyh0cnVlKTtcbiAgICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNvblNlbGVjdEVuZChtZXRob2RPZkNyZWF0aW9uID0gXCJcIikge1xuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uKG1ldGhvZE9mQ3JlYXRpb24pO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24pIHtcbiAgICAgIHRoaXMuI2Rpc3BsYXlGbG9hdGluZ1Rvb2xiYXIoKTtcbiAgICB9XG4gIH1cbiAgI2FkZFNlbGVjdGlvbkxpc3RlbmVyKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy4jc2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbDogdGhpcy5fc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI2FkZEZvY3VzTWFuYWdlcigpIHtcbiAgICBpZiAodGhpcy4jZm9jdXNNYW5hZ2VyQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZm9jdXNNYW5hZ2VyQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jb21iaW5lZFNpZ25hbCh0aGlzLiNmb2N1c01hbmFnZXJBQyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLmZvY3VzLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmJsdXIuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3JlbW92ZUZvY3VzTWFuYWdlcigpIHtcbiAgICB0aGlzLiNmb2N1c01hbmFnZXJBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNmb2N1c01hbmFnZXJBQyA9IG51bGw7XG4gIH1cbiAgYmx1cigpIHtcbiAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwKSB7XG4gICAgICB0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IGZhbHNlO1xuICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlRWxlbWVudFxuICAgIH0gPSBkb2N1bWVudDtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50ID0gW2VkaXRvciwgYWN0aXZlRWxlbWVudF07XG4gICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb2N1cygpIHtcbiAgICBpZiAoIXRoaXMuI2xhc3RBY3RpdmVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtsYXN0RWRpdG9yLCBsYXN0QWN0aXZlRWxlbWVudF0gPSB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudDtcbiAgICB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgbGFzdEFjdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKCkgPT4ge1xuICAgICAgbGFzdEVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICB9LCB7XG4gICAgICBvbmNlOiB0cnVlLFxuICAgICAgc2lnbmFsOiB0aGlzLl9zaWduYWxcbiAgICB9KTtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG4gICNhZGRLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgaWYgKHRoaXMuI2tleWJvYXJkTWFuYWdlckFDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2tleWJvYXJkTWFuYWdlckFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwodGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmtleWRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmtleXVwLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgdGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUM/LmFib3J0KCk7XG4gICAgdGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMgPSBudWxsO1xuICB9XG4gICNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI2NvcHlQYXN0ZUFDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvcHlQYXN0ZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwodGhpcy4jY29weVBhc3RlQUMpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIHRoaXMuY29weS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY3V0XCIsIHRoaXMuY3V0LmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCB0aGlzLnBhc3RlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jY29weVBhc3RlQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jY29weVBhc3RlQUMgPSBudWxsO1xuICB9XG4gICNhZGREcmFnQW5kRHJvcExpc3RlbmVycygpIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9zaWduYWw7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIHRoaXMuZHJhZ092ZXIuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgdGhpcy5kcm9wLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGFkZEVkaXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jYWRkS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jYWRkQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVtb3ZlRWRpdExpc3RlbmVycygpIHtcbiAgICB0aGlzLiNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgfVxuICBkcmFnT3ZlcihldmVudCkge1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gb2YgZXZlbnQuZGF0YVRyYW5zZmVyLml0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgaWYgKGVkaXRvclR5cGUuaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKHR5cGUpKSB7XG4gICAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcImNvcHlcIjtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcm9wKGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGV2ZW50LmRhdGFUcmFuc2Zlci5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgZWRpdG9yVHlwZS5wYXN0ZShpdGVtLCB0aGlzLmN1cnJlbnRMYXllcik7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29weShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IGVkaXRvci5zZXJpYWxpemUodHJ1ZSk7XG4gICAgICBpZiAoc2VyaWFsaXplZCkge1xuICAgICAgICBlZGl0b3JzLnB1c2goc2VyaWFsaXplZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlZGl0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi9wZGZqc1wiLCBKU09OLnN0cmluZ2lmeShlZGl0b3JzKSk7XG4gIH1cbiAgY3V0KGV2ZW50KSB7XG4gICAgdGhpcy5jb3B5KGV2ZW50KTtcbiAgICB0aGlzLmRlbGV0ZSgpO1xuICB9XG4gIGFzeW5jIHBhc3RlKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7XG4gICAgICBjbGlwYm9hcmREYXRhXG4gICAgfSA9IGV2ZW50O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjbGlwYm9hcmREYXRhLml0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgaWYgKGVkaXRvclR5cGUuaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKGl0ZW0udHlwZSkpIHtcbiAgICAgICAgICBlZGl0b3JUeXBlLnBhc3RlKGl0ZW0sIHRoaXMuY3VycmVudExheWVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRhdGEgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi9wZGZqc1wiKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB3YXJuKGBwYXN0ZTogXCIke2V4Lm1lc3NhZ2V9XCIuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmN1cnJlbnRMYXllcjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV3RWRpdG9ycyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZGF0YSkge1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWRFZGl0b3IgPSBhd2FpdCBsYXllci5kZXNlcmlhbGl6ZShlZGl0b3IpO1xuICAgICAgICBpZiAoIWRlc2VyaWFsaXplZEVkaXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXdFZGl0b3JzLnB1c2goZGVzZXJpYWxpemVkRWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgbmV3RWRpdG9ycykge1xuICAgICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKG5ld0VkaXRvcnMpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIG5ld0VkaXRvcnMpIHtcbiAgICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgY21kLFxuICAgICAgICB1bmRvLFxuICAgICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHdhcm4oYHBhc3RlOiBcIiR7ZXgubWVzc2FnZX1cIi5gKTtcbiAgICB9XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5pc1NoaWZ0S2V5RG93biAmJiBldmVudC5rZXkgPT09IFwiU2hpZnRcIikge1xuICAgICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FICYmICF0aGlzLmlzRWRpdG9ySGFuZGxpbmdLZXlib2FyZCkge1xuICAgICAgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfVxuICBrZXl1cChldmVudCkge1xuICAgIGlmICh0aGlzLmlzU2hpZnRLZXlEb3duICYmIGV2ZW50LmtleSA9PT0gXCJTaGlmdFwiKSB7XG4gICAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXApIHtcbiAgICAgICAgdGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uRWRpdGluZ0FjdGlvbih7XG4gICAgbmFtZVxuICB9KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwidW5kb1wiOlxuICAgICAgY2FzZSBcInJlZG9cIjpcbiAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgIGNhc2UgXCJzZWxlY3RBbGxcIjpcbiAgICAgICAgdGhpc1tuYW1lXSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJoaWdobGlnaHRTZWxlY3Rpb25cIjpcbiAgICAgICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24oXCJjb250ZXh0X21lbnVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNvbW1lbnRTZWxlY3Rpb25cIjpcbiAgICAgICAgdGhpcy5jb21tZW50U2VsZWN0aW9uKFwiY29udGV4dF9tZW51XCIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKGRldGFpbHMpIHtcbiAgICBjb25zdCBoYXNDaGFuZ2VkID0gT2JqZWN0LmVudHJpZXMoZGV0YWlscykuc29tZSgoW2tleSwgdmFsdWVdKSA9PiB0aGlzLiNwcmV2aW91c1N0YXRlc1trZXldICE9PSB2YWx1ZSk7XG4gICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwiYW5ub3RhdGlvbmVkaXRvcnN0YXRlc2NoYW5nZWRcIiwge1xuICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgIGRldGFpbHM6IE9iamVjdC5hc3NpZ24odGhpcy4jcHJldmlvdXNTdGF0ZXMsIGRldGFpbHMpXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQgJiYgZGV0YWlscy5oYXNTZWxlY3RlZEVkaXRvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9GUkVFLCB0cnVlXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjZGlzcGF0Y2hVcGRhdGVVSShkZXRhaWxzKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJhbm5vdGF0aW9uZWRpdG9ycGFyYW1zY2hhbmdlZFwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBkZXRhaWxzXG4gICAgfSk7XG4gIH1cbiAgc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZykge1xuICAgIGlmIChpc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuI2FkZEZvY3VzTWFuYWdlcigpO1xuICAgICAgdGhpcy4jYWRkQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGlzRWRpdGluZzogdGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSxcbiAgICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpLFxuICAgICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvVW5kbygpLFxuICAgICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvUmVkbygpLFxuICAgICAgICBoYXNTZWxlY3RlZEVkaXRvcjogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNyZW1vdmVGb2N1c01hbmFnZXIoKTtcbiAgICAgIHRoaXMuI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckVkaXRvclR5cGVzKHR5cGVzKSB7XG4gICAgaWYgKHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2VkaXRvclR5cGVzID0gdHlwZXM7XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvclR5cGUuZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLiNpZE1hbmFnZXIuaWQ7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsTGF5ZXJzLmdldCh0aGlzLiNjdXJyZW50UGFnZUluZGV4KTtcbiAgfVxuICBnZXRMYXllcihwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICB9XG4gIGdldCBjdXJyZW50UGFnZUluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50UGFnZUluZGV4O1xuICB9XG4gIGFkZExheWVyKGxheWVyKSB7XG4gICAgdGhpcy4jYWxsTGF5ZXJzLnNldChsYXllci5wYWdlSW5kZXgsIGxheWVyKTtcbiAgICBpZiAodGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICBsYXllci5lbmFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgIH1cbiAgfVxuICByZW1vdmVMYXllcihsYXllcikge1xuICAgIHRoaXMuI2FsbExheWVycy5kZWxldGUobGF5ZXIucGFnZUluZGV4KTtcbiAgfVxuICBhc3luYyB1cGRhdGVNb2RlKG1vZGUsIGVkaXRJZCA9IG51bGwsIGlzRnJvbUtleWJvYXJkID0gZmFsc2UsIG11c3RFbnRlckluRWRpdE1vZGUgPSBmYWxzZSwgZWRpdENvbW1lbnQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLiNtb2RlID09PSBtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSkge1xuICAgICAgYXdhaXQgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIGlmICghdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuI2N1cnJlbnREcmF3aW5nU2Vzc2lvbj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuUE9QVVApIHtcbiAgICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5oaWRlU2lkZWJhcigpO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50TWFuYWdlcj8uZGVzdHJveVBvcHVwKCk7XG4gICAgdGhpcy4jbW9kZSA9IG1vZGU7XG4gICAgaWYgKG1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgIHRoaXMuc2V0RWRpdGluZ1N0YXRlKGZhbHNlKTtcbiAgICAgIHRoaXMuI2Rpc2FibGVBbGwoKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgZWRpdG9yLmhpZGVTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWRpdG9yVW5kb0Jhcj8uaGlkZSgpO1xuICAgICAgdGhpcy50b2dnbGVDb21tZW50KG51bGwpO1xuICAgICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuYWRkU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24oKTtcbiAgICB9XG4gICAgaWYgKG1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlNJR05BVFVSRSkge1xuICAgICAgYXdhaXQgdGhpcy4jc2lnbmF0dXJlTWFuYWdlcj8ubG9hZFNpZ25hdHVyZXMoKTtcbiAgICB9XG4gICAgdGhpcy5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgYXdhaXQgdGhpcy4jZW5hYmxlQWxsKCk7XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBsYXllci51cGRhdGVNb2RlKG1vZGUpO1xuICAgIH1cbiAgICBpZiAobW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuUE9QVVApIHtcbiAgICAgIHRoaXMuI2FsbEVkaXRhYmxlQW5ub3RhdGlvbnMgfHw9IGF3YWl0IHRoaXMuI3BkZkRvY3VtZW50LmdldEFubm90YXRpb25zQnlUeXBlKG5ldyBTZXQodGhpcy4jZWRpdG9yVHlwZXMubWFwKGVkaXRvckNsYXNzID0+IGVkaXRvckNsYXNzLl9lZGl0b3JUeXBlKSkpO1xuICAgICAgY29uc3QgZWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgICAgIGNvbnN0IGFsbENvbW1lbnRzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkLFxuICAgICAgICAgIGhhc0NvbW1lbnQsXG4gICAgICAgICAgZGVsZXRlZFxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICAgIGVsZW1lbnRJZHMuYWRkKGFubm90YXRpb25FbGVtZW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNDb21tZW50ICYmICFkZWxldGVkKSB7XG4gICAgICAgICAgYWxsQ29tbWVudHMucHVzaChlZGl0b3IuZ2V0RGF0YSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBhbm5vdGF0aW9uIG9mIHRoaXMuI2FsbEVkaXRhYmxlQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBvcHVwUmVmLFxuICAgICAgICAgIGNvbnRlbnRzT2JqXG4gICAgICAgIH0gPSBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAocG9wdXBSZWYgJiYgY29udGVudHNPYmo/LnN0ciAmJiAhZWxlbWVudElkcy5oYXMoaWQpICYmICF0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICBhbGxDb21tZW50cy5wdXNoKGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLiNjb21tZW50TWFuYWdlcj8uc2hvd1NpZGViYXIoYWxsQ29tbWVudHMpO1xuICAgIH1cbiAgICBpZiAoIWVkaXRJZCkge1xuICAgICAgaWYgKGlzRnJvbUtleWJvYXJkKSB7XG4gICAgICAgIHRoaXMuYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkKCk7XG4gICAgICB9XG4gICAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IudWlkID09PSBlZGl0SWQpIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZChlZGl0b3IpO1xuICAgICAgICBpZiAoZWRpdENvbW1lbnQpIHtcbiAgICAgICAgICBlZGl0b3IuZWRpdENvbW1lbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtdXN0RW50ZXJJbkVkaXRNb2RlKSB7XG4gICAgICAgICAgZWRpdG9yLmVudGVySW5FZGl0TW9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIGFkZE5ld0VkaXRvckZyb21LZXlib2FyZCgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50TGF5ZXIuY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSkge1xuICAgICAgdGhpcy5jdXJyZW50TGF5ZXIuYWRkTmV3RWRpdG9yKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRvb2xiYXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLm1vZGUgPT09IHRoaXMuI21vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuQ1JFQVRFOlxuICAgICAgICB0aGlzLmN1cnJlbnRMYXllci5hZGROZXdFZGl0b3IodmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9TSE9XX0FMTDpcbiAgICAgICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJyZXBvcnR0ZWxlbWV0cnlcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVkaXRpbmdcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJoaWdobGlnaHRcIixcbiAgICAgICAgICAgICAgYWN0aW9uOiBcInRvZ2dsZV92aXNpYmlsaXR5XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAodGhpcy4jc2hvd0FsbFN0YXRlcyB8fD0gbmV3IE1hcCgpKS5zZXQodHlwZSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICAgIGVkaXRvci51cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgZWRpdG9yVHlwZS51cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hvd0FsbEVkaXRvcnModHlwZSwgdmlzaWJsZSwgdXBkYXRlQnV0dG9uID0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLmVkaXRvclR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgZWRpdG9yLnNob3codmlzaWJsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jc2hvd0FsbFN0YXRlcz8uZ2V0KEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9TSE9XX0FMTCkgPz8gdHJ1ZTtcbiAgICBpZiAoc3RhdGUgIT09IHZpc2libGUpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEwsIHZpc2libGVdXSk7XG4gICAgfVxuICB9XG4gIGVuYWJsZVdhaXRpbmcobXVzdFdhaXQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLiNpc1dhaXRpbmcgPT09IG11c3RXYWl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2lzV2FpdGluZyA9IG11c3RXYWl0O1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBpZiAobXVzdFdhaXQpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZUNsaWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXllci5lbmFibGVDbGljaygpO1xuICAgICAgfVxuICAgICAgbGF5ZXIuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJ3YWl0aW5nXCIsIG11c3RXYWl0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgI2VuYWJsZUFsbCgpIHtcbiAgICBpZiAoIXRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGxheWVyLmVuYWJsZSgpKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgZWRpdG9yLmVuYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjZGlzYWJsZUFsbCgpIHtcbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgaWYgKHRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBsYXllci5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICpnZXRFZGl0b3JzKHBhZ2VJbmRleCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IucGFnZUluZGV4ID09PSBwYWdlSW5kZXgpIHtcbiAgICAgICAgeWllbGQgZWRpdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRFZGl0b3IoaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsRWRpdG9ycy5nZXQoaWQpO1xuICB9XG4gIGFkZEVkaXRvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLnNldChlZGl0b3IuaWQsIGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlRWRpdG9yKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZm9jdXNNYWluQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5kZWxldGUoZWRpdG9yLmlkKTtcbiAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI21pc3NpbmdDYW52YXNlcz8uZGVsZXRlKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICB9XG4gICAgdGhpcy51bnNlbGVjdChlZGl0b3IpO1xuICAgIGlmICghZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgfHwgIXRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuaGFzKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2U/LnJlbW92ZShlZGl0b3IuaWQpO1xuICAgIH1cbiAgfVxuICBhZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5hZGQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIHRoaXMuYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgIGVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgfVxuICBpc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuaGFzKGFubm90YXRpb25FbGVtZW50SWQpO1xuICB9XG4gIHJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmRlbGV0ZShlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgdGhpcy5yZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgZWRpdG9yLmRlbGV0ZWQgPSBmYWxzZTtcbiAgfVxuICAjYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI2FsbExheWVycy5nZXQoZWRpdG9yLnBhZ2VJbmRleCk7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBsYXllci5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBzZXRBY3RpdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI2FjdGl2ZUVkaXRvciA9PT0gZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FjdGl2ZUVkaXRvciA9IGVkaXRvcjtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICBnZXQgI2xhc3RTZWxlY3RlZEVkaXRvcigpIHtcbiAgICBsZXQgZWQgPSBudWxsO1xuICAgIGZvciAoZWQgb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7fVxuICAgIHJldHVybiBlZDtcbiAgfVxuICB1cGRhdGVVSShlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jbGFzdFNlbGVjdGVkRWRpdG9yID09PSBlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVVJRm9yRGVmYXVsdFByb3BlcnRpZXMoZWRpdG9yVHlwZSkge1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yVHlwZS5kZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKTtcbiAgfVxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmhhcyhlZGl0b3IpKSB7XG4gICAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy51cGRhdGVUb29sYmFyKHtcbiAgICAgIG1vZGU6IGVkaXRvci5tb2RlLFxuICAgICAgZWRpdElkOiBlZGl0b3IuaWRcbiAgICB9KTtcbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgZm9yIChjb25zdCBlZCBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZCAhPT0gZWRpdG9yKSB7XG4gICAgICAgIGVkLnVuc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGlzU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5oYXMoZWRpdG9yKTtcbiAgfVxuICBnZXQgZmlyc3RTZWxlY3RlZEVkaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgfVxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGhhc1NlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgIT09IDA7XG4gIH1cbiAgZ2V0IGlzRW50ZXJIYW5kbGVkKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuc2l6ZSA9PT0gMSAmJiB0aGlzLmZpcnN0U2VsZWN0ZWRFZGl0b3IuaXNFbnRlckhhbmRsZWQ7XG4gIH1cbiAgdW5kbygpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci51bmRvKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdHJ1ZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgfVxuICByZWRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnJlZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvUmVkbygpLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuYWRkKHBhcmFtcyk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0cnVlLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiBmYWxzZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gIGNsZWFuVW5kb1N0YWNrKHR5cGUpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5jbGVhblR5cGUodHlwZSk7XG4gIH1cbiAgI2lzRW1wdHkoKSB7XG4gICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLnNpemUgPT09IDEpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5pc0VtcHR5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZWxldGUoKSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIGNvbnN0IGRyYXdpbmdFZGl0b3IgPSB0aGlzLmN1cnJlbnRMYXllcj8uZW5kRHJhd2luZ1Nlc3Npb24odHJ1ZSk7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbiAmJiAhZHJhd2luZ0VkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3JzID0gZHJhd2luZ0VkaXRvciA/IFtkcmF3aW5nRWRpdG9yXSA6IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LnNob3codW5kbywgZWRpdG9ycy5sZW5ndGggPT09IDEgPyBlZGl0b3JzWzBdLmVkaXRvclR5cGUgOiBlZGl0b3JzLmxlbmd0aCk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvQ29udHJvbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yIHx8IHRoaXMuaGFzU2VsZWN0aW9uO1xuICB9XG4gICNzZWxlY3RFZGl0b3JzKGVkaXRvcnMpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0QWxsKCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLmNvbW1pdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpO1xuICB9XG4gIHVuc2VsZWN0QWxsKCkge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IpIHtcbiAgICAgIHRoaXMuI2FjdGl2ZUVkaXRvci5jb21taXRPclJlbW92ZSgpO1xuICAgICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5jb21taXRPclJlbW92ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgdHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHksIG5vQ29tbWl0ID0gZmFsc2UpIHtcbiAgICBpZiAoIW5vQ29tbWl0KSB7XG4gICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdHJhbnNsYXRpb25bMF0gKz0geDtcbiAgICB0aGlzLiN0cmFuc2xhdGlvblsxXSArPSB5O1xuICAgIGNvbnN0IFt0b3RhbFgsIHRvdGFsWV0gPSB0aGlzLiN0cmFuc2xhdGlvbjtcbiAgICBjb25zdCBlZGl0b3JzID0gWy4uLnRoaXMuI3NlbGVjdGVkRWRpdG9yc107XG4gICAgY29uc3QgVElNRV9UT19XQUlUID0gMTAwMDtcbiAgICBpZiAodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCk7XG4gICAgfVxuICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblswXSA9IHRoaXMuI3RyYW5zbGF0aW9uWzFdID0gMDtcbiAgICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHRvdGFsWCwgdG90YWxZKTtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0aW9uRG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UoLXRvdGFsWCwgLXRvdGFsWSk7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGlvbkRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHgsIHkpO1xuICAgICAgZWRpdG9yLnRyYW5zbGF0aW9uRG9uZSgpO1xuICAgIH1cbiAgfVxuICBzZXRVcERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdCh0cnVlKTtcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMuc2V0KGVkaXRvciwge1xuICAgICAgICBzYXZlZFg6IGVkaXRvci54LFxuICAgICAgICBzYXZlZFk6IGVkaXRvci55LFxuICAgICAgICBzYXZlZFBhZ2VJbmRleDogZWRpdG9yLnBhZ2VJbmRleCxcbiAgICAgICAgbmV3WDogMCxcbiAgICAgICAgbmV3WTogMCxcbiAgICAgICAgbmV3UGFnZUluZGV4OiAtMVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVuZERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuI2RyYWdnaW5nRWRpdG9ycztcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBudWxsO1xuICAgIGxldCBtdXN0QmVBZGRlZEluVW5kb1N0YWNrID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBbe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwYWdlSW5kZXhcbiAgICB9LCB2YWx1ZV0gb2YgbWFwKSB7XG4gICAgICB2YWx1ZS5uZXdYID0geDtcbiAgICAgIHZhbHVlLm5ld1kgPSB5O1xuICAgICAgdmFsdWUubmV3UGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgbXVzdEJlQWRkZWRJblVuZG9TdGFjayB8fD0geCAhPT0gdmFsdWUuc2F2ZWRYIHx8IHkgIT09IHZhbHVlLnNhdmVkWSB8fCBwYWdlSW5kZXggIT09IHZhbHVlLnNhdmVkUGFnZUluZGV4O1xuICAgIH1cbiAgICBpZiAoIW11c3RCZUFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbW92ZSA9IChlZGl0b3IsIHgsIHksIHBhZ2VJbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgZWRpdG9yLl9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICAgICAgZWRpdG9yLnggPSB4O1xuICAgICAgICAgIGVkaXRvci55ID0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgbmV3WCxcbiAgICAgICAgICBuZXdZLFxuICAgICAgICAgIG5ld1BhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgbmV3WCwgbmV3WSwgbmV3UGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgc2F2ZWRYLFxuICAgICAgICAgIHNhdmVkWSxcbiAgICAgICAgICBzYXZlZFBhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgc2F2ZWRYLCBzYXZlZFksIHNhdmVkUGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZHJhZ1NlbGVjdGVkRWRpdG9ycyh0eCwgdHkpIHtcbiAgICBpZiAoIXRoaXMuI2RyYWdnaW5nRWRpdG9ycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMua2V5cygpKSB7XG4gICAgICBlZGl0b3IuZHJhZyh0eCwgdHkpO1xuICAgIH1cbiAgfVxuICByZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldExheWVyKGVkaXRvci5wYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgICAgIHBhcmVudC5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IucGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBnZXQgaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkKCkge1xuICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZSgpPy5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHx8IHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplID09PSAxICYmIHRoaXMuZmlyc3RTZWxlY3RlZEVkaXRvci5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpO1xuICB9XG4gIGlzQWN0aXZlKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3IgPT09IGVkaXRvcjtcbiAgfVxuICBnZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvcjtcbiAgfVxuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLiNtb2RlO1xuICB9XG4gIGlzRWRpdGluZ01vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gIH1cbiAgZ2V0IGltYWdlTWFuYWdlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaW1hZ2VNYW5hZ2VyXCIsIG5ldyBJbWFnZU1hbmFnZXIoKSk7XG4gIH1cbiAgZ2V0U2VsZWN0aW9uQm94ZXModGV4dExheWVyKSB7XG4gICAgaWYgKCF0ZXh0TGF5ZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlmICghdGV4dExheWVyLmNvbnRhaW5zKHNlbGVjdGlvbi5nZXRSYW5nZUF0KGkpLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeDogbGF5ZXJYLFxuICAgICAgeTogbGF5ZXJZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGV4dExheWVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCByb3RhdG9yO1xuICAgIHN3aXRjaCAodGV4dExheWVyLmdldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiKSkge1xuICAgICAgY2FzZSBcIjkwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAoeSAtIGxheWVyWSkgLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgeTogMSAtICh4ICsgdyAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB3aWR0aDogaCAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHcgLyBwYXJlbnRXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiMTgwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAxIC0gKHggKyB3IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHk6IDEgLSAoeSArIGggLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3IC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoIC8gcGFyZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIyNzBcIjpcbiAgICAgICAgcm90YXRvciA9ICh4LCB5LCB3LCBoKSA9PiAoe1xuICAgICAgICAgIHg6IDEgLSAoeSArIGggLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHk6ICh4IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHdpZHRoOiBoIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIGhlaWdodDogdyAvIHBhcmVudFdpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAoeCAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB5OiAoeSAtIGxheWVyWSkgLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IHcgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGggLyBwYXJlbnRIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNlbGVjdGlvbi5yYW5nZUNvdW50OyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKTtcbiAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSBvZiByYW5nZS5nZXRDbGllbnRSZWN0cygpKSB7XG4gICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBib3hlcy5wdXNoKHJvdGF0b3IoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm94ZXMubGVuZ3RoID09PSAwID8gbnVsbCA6IGJveGVzO1xuICB9XG4gIGFkZENoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oe1xuICAgIGFubm90YXRpb25FbGVtZW50SWQsXG4gICAgaWRcbiAgfSkge1xuICAgICh0aGlzLiNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucyB8fD0gbmV3IE1hcCgpKS5zZXQoYW5ub3RhdGlvbkVsZW1lbnRJZCwgaWQpO1xuICB9XG4gIHJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oe1xuICAgIGFubm90YXRpb25FbGVtZW50SWRcbiAgfSkge1xuICAgIHRoaXMuI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zPy5kZWxldGUoYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGNvbnN0IGVkaXRvcklkID0gdGhpcy4jY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnM/LmdldChhbm5vdGF0aW9uLmRhdGEuaWQpO1xuICAgIGlmICghZWRpdG9ySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUoZWRpdG9ySWQpO1xuICAgIGlmICghZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FICYmICFlZGl0b3IuaGFzQmVlbk1vZGlmaWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVkaXRvci5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKTtcbiAgfVxuICBzZXRNaXNzaW5nQ2FudmFzKGFubm90YXRpb25JZCwgYW5ub3RhdGlvbkVsZW1lbnRJZCwgY2FudmFzKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jbWlzc2luZ0NhbnZhc2VzPy5nZXQoYW5ub3RhdGlvbklkKTtcbiAgICBpZiAoIWVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZGl0b3Iuc2V0Q2FudmFzKGFubm90YXRpb25FbGVtZW50SWQsIGNhbnZhcyk7XG4gICAgdGhpcy4jbWlzc2luZ0NhbnZhc2VzLmRlbGV0ZShhbm5vdGF0aW9uSWQpO1xuICB9XG4gIGFkZE1pc3NpbmdDYW52YXMoYW5ub3RhdGlvbklkLCBlZGl0b3IpIHtcbiAgICAodGhpcy4jbWlzc2luZ0NhbnZhc2VzIHx8PSBuZXcgTWFwKCkpLnNldChhbm5vdGF0aW9uSWQsIGVkaXRvcik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2FsdF90ZXh0LmpzXG5cbmNsYXNzIEFsdFRleHQge1xuICAjYWx0VGV4dCA9IG51bGw7XG4gICNhbHRUZXh0RGVjb3JhdGl2ZSA9IGZhbHNlO1xuICAjYWx0VGV4dEJ1dHRvbiA9IG51bGw7XG4gICNhbHRUZXh0QnV0dG9uTGFiZWwgPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgI2JhZGdlID0gbnVsbDtcbiAgI2VkaXRvciA9IG51bGw7XG4gICNndWVzc2VkVGV4dCA9IG51bGw7XG4gICN0ZXh0V2l0aERpc2NsYWltZXIgPSBudWxsO1xuICAjdXNlTmV3QWx0VGV4dEZsb3cgPSBmYWxzZTtcbiAgc3RhdGljICNsMTBuTmV3QnV0dG9uID0gbnVsbDtcbiAgc3RhdGljIF9sMTBuID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuI3VzZU5ld0FsdFRleHRGbG93ID0gZWRpdG9yLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3c7XG4gICAgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbiB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBhZGRlZDogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LWFkZGVkLWJ1dHRvblwiLFxuICAgICAgXCJhZGRlZC1sYWJlbFwiOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtYWRkZWQtYnV0dG9uLWxhYmVsXCIsXG4gICAgICBtaXNzaW5nOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtbWlzc2luZy1idXR0b25cIixcbiAgICAgIFwibWlzc2luZy1sYWJlbFwiOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtbWlzc2luZy1idXR0b24tbGFiZWxcIixcbiAgICAgIHJldmlldzogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LXRvLXJldmlldy1idXR0b25cIixcbiAgICAgIFwicmV2aWV3LWxhYmVsXCI6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC10by1yZXZpZXctYnV0dG9uLWxhYmVsXCJcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuKSB7XG4gICAgQWx0VGV4dC5fbDEwbiA/Pz0gbDEwbjtcbiAgfVxuICBhc3luYyByZW5kZXIoKSB7XG4gICAgY29uc3QgYWx0VGV4dCA9IHRoaXMuI2FsdFRleHRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGFsdFRleHQuY2xhc3NOYW1lID0gXCJhbHRUZXh0XCI7XG4gICAgYWx0VGV4dC50YWJJbmRleCA9IFwiMFwiO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy4jYWx0VGV4dEJ1dHRvbkxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgYWx0VGV4dC5hcHBlbmQobGFiZWwpO1xuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgYWx0VGV4dC5jbGFzc0xpc3QuYWRkKFwibmV3XCIpO1xuICAgICAgYWx0VGV4dC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbi5taXNzaW5nKTtcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uW1wibWlzc2luZy1sYWJlbFwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsdFRleHQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWJ1dHRvblwiKTtcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1idXR0b24tbGFiZWxcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZXZlbnQgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IG9uQ2xpY2sgPSBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcy4jZWRpdG9yKTtcbiAgICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgICB0aGlzLiNlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmFsdF90ZXh0LmltYWdlX3N0YXR1c19sYWJlbF9jbGlja2VkXCIsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgbGFiZWw6IHRoaXMuI2xhYmVsXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2ssIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGFsdFRleHQgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCA9IHRydWU7XG4gICAgICAgIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuI3NldFN0YXRlKCk7XG4gICAgcmV0dXJuIGFsdFRleHQ7XG4gIH1cbiAgZ2V0ICNsYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dCAmJiBcImFkZGVkXCIgfHwgdGhpcy4jYWx0VGV4dCA9PT0gbnVsbCAmJiB0aGlzLmd1ZXNzZWRUZXh0ICYmIFwicmV2aWV3XCIgfHwgXCJtaXNzaW5nXCI7XG4gIH1cbiAgZmluaXNoKCkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uLmZvY3VzKHtcbiAgICAgIGZvY3VzVmlzaWJsZTogdGhpcy4jYWx0VGV4dFdhc0Zyb21LZXlCb2FyZFxuICAgIH0pO1xuICAgIHRoaXMuI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FsdFRleHQgPT09IG51bGw7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dERlY29yYXRpdmU7XG4gIH1cbiAgaGFzRGF0YSgpIHtcbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIHJldHVybiB0aGlzLiNhbHRUZXh0ICE9PSBudWxsIHx8ICEhdGhpcy4jZ3Vlc3NlZFRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKTtcbiAgfVxuICBnZXQgZ3Vlc3NlZFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2d1ZXNzZWRUZXh0O1xuICB9XG4gIGFzeW5jIHNldEd1ZXNzZWRUZXh0KGd1ZXNzZWRUZXh0KSB7XG4gICAgaWYgKHRoaXMuI2FsdFRleHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZ3Vlc3NlZFRleHQgPSBndWVzc2VkVGV4dDtcbiAgICB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXIgPSBhd2FpdCBBbHRUZXh0Ll9sMTBuLmdldChcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtZ2VuZXJhdGVkLWFsdC10ZXh0LXdpdGgtZGlzY2xhaW1lclwiLCB7XG4gICAgICBnZW5lcmF0ZWRBbHRUZXh0OiBndWVzc2VkVGV4dFxuICAgIH0pO1xuICAgIHRoaXMuI3NldFN0YXRlKCk7XG4gIH1cbiAgdG9nZ2xlQWx0VGV4dEJhZGdlKHZpc2liaWxpdHkgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cgfHwgdGhpcy4jYWx0VGV4dCkge1xuICAgICAgdGhpcy4jYmFkZ2U/LnJlbW92ZSgpO1xuICAgICAgdGhpcy4jYmFkZ2UgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2JhZGdlKSB7XG4gICAgICBjb25zdCBiYWRnZSA9IHRoaXMuI2JhZGdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGJhZGdlLmNsYXNzTmFtZSA9IFwibm9BbHRUZXh0QmFkZ2VcIjtcbiAgICAgIHRoaXMuI2VkaXRvci5kaXYuYXBwZW5kKGJhZGdlKTtcbiAgICB9XG4gICAgdGhpcy4jYmFkZ2UuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiLCAhdmlzaWJpbGl0eSk7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZykge1xuICAgIGxldCBhbHRUZXh0ID0gdGhpcy4jYWx0VGV4dDtcbiAgICBpZiAoIWlzRm9yQ29weWluZyAmJiB0aGlzLiNndWVzc2VkVGV4dCA9PT0gYWx0VGV4dCkge1xuICAgICAgYWx0VGV4dCA9IHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGFsdFRleHQsXG4gICAgICBkZWNvcmF0aXZlOiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSxcbiAgICAgIGd1ZXNzZWRUZXh0OiB0aGlzLiNndWVzc2VkVGV4dCxcbiAgICAgIHRleHRXaXRoRGlzY2xhaW1lcjogdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyXG4gICAgfTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWx0VGV4dDogdGhpcy4jYWx0VGV4dCxcbiAgICAgIGRlY29yYXRpdmU6IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlXG4gICAgfTtcbiAgfVxuICBzZXQgZGF0YSh7XG4gICAgYWx0VGV4dCxcbiAgICBkZWNvcmF0aXZlLFxuICAgIGd1ZXNzZWRUZXh0LFxuICAgIHRleHRXaXRoRGlzY2xhaW1lcixcbiAgICBjYW5jZWwgPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKGd1ZXNzZWRUZXh0KSB7XG4gICAgICB0aGlzLiNndWVzc2VkVGV4dCA9IGd1ZXNzZWRUZXh0O1xuICAgICAgdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyID0gdGV4dFdpdGhEaXNjbGFpbWVyO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYWx0VGV4dCA9PT0gYWx0VGV4dCAmJiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSA9PT0gZGVjb3JhdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNhbmNlbCkge1xuICAgICAgdGhpcy4jYWx0VGV4dCA9IGFsdFRleHQ7XG4gICAgICB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSA9IGRlY29yYXRpdmU7XG4gICAgfVxuICAgIHRoaXMuI3NldFN0YXRlKCk7XG4gIH1cbiAgdG9nZ2xlKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWVuYWJsZWQgJiYgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHRCdXR0b24uZGlzYWJsZWQgPSAhZW5hYmxlZDtcbiAgfVxuICBzaG93bigpIHtcbiAgICB0aGlzLiNlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwicGRmanMuaW1hZ2UuYWx0X3RleHQuaW1hZ2Vfc3RhdHVzX2xhYmVsX2Rpc3BsYXllZFwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBsYWJlbDogdGhpcy4jbGFiZWxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b24gPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b25MYWJlbCA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICAgIHRoaXMuI2JhZGdlPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNiYWRnZSA9IG51bGw7XG4gIH1cbiAgYXN5bmMgI3NldFN0YXRlKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI2FsdFRleHRCdXR0b247XG4gICAgaWYgKCFidXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZShcImRvbmVcIiwgISF0aGlzLiNhbHRUZXh0KTtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvblt0aGlzLiNsYWJlbF0pO1xuICAgICAgdGhpcy4jYWx0VGV4dEJ1dHRvbkxhYmVsPy5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbltgJHt0aGlzLiNsYWJlbH0tbGFiZWxgXSk7XG4gICAgICBpZiAoIXRoaXMuI2FsdFRleHQpIHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dERlY29yYXRpdmUpIHtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJkb25lXCIpO1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8ucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZG9uZVwiKTtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtZWRpdC1idXR0b25cIik7XG4gICAgfVxuICAgIGxldCB0b29sdGlwID0gdGhpcy4jYWx0VGV4dFRvb2x0aXA7XG4gICAgaWYgKCF0b29sdGlwKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcCA9IHRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHRvb2x0aXAuY2xhc3NOYW1lID0gXCJ0b29sdGlwXCI7XG4gICAgICB0b29sdGlwLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0b29sdGlwXCIpO1xuICAgICAgdG9vbHRpcC5pZCA9IGBhbHQtdGV4dC10b29sdGlwLSR7dGhpcy4jZWRpdG9yLmlkfWA7XG4gICAgICBjb25zdCBERUxBWV9UT19TSE9XX1RPT0xUSVAgPSAxMDA7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpO1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgfSwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAuY2xhc3NMaXN0LmFkZChcInNob3dcIik7XG4gICAgICAgICAgdGhpcy4jZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICAgICAgYWN0aW9uOiBcImFsdF90ZXh0X3Rvb2x0aXBcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBERUxBWV9UT19TSE9XX1RPT0xUSVApO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpO1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYWx0VGV4dERlY29yYXRpdmUpIHtcbiAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWRlY29yYXRpdmUtdG9vbHRpcFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9vbHRpcC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIik7XG4gICAgICB0b29sdGlwLnRleHRDb250ZW50ID0gdGhpcy4jYWx0VGV4dDtcbiAgICB9XG4gICAgaWYgKCF0b29sdGlwLnBhcmVudE5vZGUpIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmQodG9vbHRpcCk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLiNlZGl0b3IuZ2V0RWxlbWVudEZvckFsdFRleHQoKTtcbiAgICBlbGVtZW50Py5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIHRvb2x0aXAuaWQpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9jb21tZW50LmpzXG5cbmNsYXNzIENvbW1lbnQge1xuICAjY29tbWVudFN0YW5kYWxvbmVCdXR0b24gPSBudWxsO1xuICAjY29tbWVudFRvb2xiYXJCdXR0b24gPSBudWxsO1xuICAjY29tbWVudFdhc0Zyb21LZXlCb2FyZCA9IGZhbHNlO1xuICAjZWRpdG9yID0gbnVsbDtcbiAgI2luaXRpYWxUZXh0ID0gbnVsbDtcbiAgI3JpY2hUZXh0ID0gbnVsbDtcbiAgI3RleHQgPSBudWxsO1xuICAjZGF0ZSA9IG51bGw7XG4gICNkZWxldGVkID0gZmFsc2U7XG4gICNwb3B1cFBvc2l0aW9uID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICB9XG4gIHJlbmRlckZvclRvb2xiYXIoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jY29tbWVudFRvb2xiYXJCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImNvbW1lbnRcIjtcbiAgICByZXR1cm4gdGhpcy4jcmVuZGVyKGJ1dHRvbiwgZmFsc2UpO1xuICB9XG4gIHJlbmRlckZvclN0YW5kYWxvbmUoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImFubm90YXRpb25Db21tZW50QnV0dG9uXCI7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLiNlZGl0b3IuY29tbWVudEJ1dHRvblBvc2l0aW9uO1xuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGJ1dHRvbjtcbiAgICAgIHN0eWxlLmluc2V0SW5saW5lRW5kID0gYGNhbGMoJHsxMDAgKiAodGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZGlyZWN0aW9uID09PSBcImx0clwiID8gMSAtIHBvc2l0aW9uWzBdIDogcG9zaXRpb25bMF0pfSUgLSB2YXIoLS1jb21tZW50LWJ1dHRvbi1kaW0pKWA7XG4gICAgICBzdHlsZS50b3AgPSBgY2FsYygkezEwMCAqIHBvc2l0aW9uWzFdfSUgLSB2YXIoLS1jb21tZW50LWJ1dHRvbi1kaW0pKWA7XG4gICAgICBjb25zdCBjb2xvciA9IHRoaXMuI2VkaXRvci5jb21tZW50QnV0dG9uQ29sb3I7XG4gICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNyZW5kZXIoYnV0dG9uLCB0cnVlKTtcbiAgfVxuICBmb2N1c0J1dHRvbigpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICh0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbiA/PyB0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbik/LmZvY3VzKCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgb25VcGRhdGVkQ29sb3IoKSB7XG4gICAgaWYgKCF0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb2xvciA9IHRoaXMuI2VkaXRvci5jb21tZW50QnV0dG9uQ29sb3I7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICB9XG4gICAgdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIudXBkYXRlUG9wdXBDb2xvcih0aGlzLiNlZGl0b3IpO1xuICB9XG4gIGdldCBjb21tZW50QnV0dG9uV2lkdGgoKSB7XG4gICAgcmV0dXJuICh0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbj8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPz8gMCkgLyB0aGlzLiNlZGl0b3IucGFyZW50LmJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aDtcbiAgfVxuICBnZXQgY29tbWVudFBvcHVwUG9zaXRpb25JbkxheWVyKCkge1xuICAgIGlmICh0aGlzLiNwb3B1cFBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy4jcG9wdXBQb3NpdGlvbjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IHBhcmVudFgsXG4gICAgICB5OiBwYXJlbnRZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGhpcy4jZWRpdG9yLnBhcmVudC5ib3VuZGluZ0NsaWVudFJlY3Q7XG4gICAgcmV0dXJuIFsoeCAtIHBhcmVudFgpIC8gcGFyZW50V2lkdGgsICh5ICsgaGVpZ2h0IC0gcGFyZW50WSkgLyBwYXJlbnRIZWlnaHRdO1xuICB9XG4gIHNldCBjb21tZW50UG9wdXBQb3NpdGlvbkluTGF5ZXIocG9zKSB7XG4gICAgdGhpcy4jcG9wdXBQb3NpdGlvbiA9IHBvcztcbiAgfVxuICBoYXNEZWZhdWx0UG9wdXBQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9wdXBQb3NpdGlvbiA9PT0gbnVsbDtcbiAgfVxuICByZW1vdmVTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpIHtcbiAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24gPSBudWxsO1xuICB9XG4gIHJlbW92ZVRvb2xiYXJDb21tZW50QnV0dG9uKCkge1xuICAgIHRoaXMuI2NvbW1lbnRUb29sYmFyQnV0dG9uPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbiA9IG51bGw7XG4gIH1cbiAgc2V0Q29tbWVudEJ1dHRvblN0YXRlcyh7XG4gICAgc2VsZWN0ZWQsXG4gICAgaGFzUG9wdXBcbiAgfSkge1xuICAgIGlmICghdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24uY2xhc3NMaXN0LnRvZ2dsZShcInNlbGVjdGVkXCIsIHNlbGVjdGVkKTtcbiAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbi5hcmlhRXhwYW5kZWQgPSBoYXNQb3B1cDtcbiAgfVxuICAjcmVuZGVyKGNvbW1lbnQsIGlzU3RhbmRhbG9uZSkge1xuICAgIGlmICghdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuaGFzQ29tbWVudE1hbmFnZXIoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbW1lbnQudGFiSW5kZXggPSBcIjBcIjtcbiAgICBjb21tZW50LmFyaWFIYXNQb3B1cCA9IFwiZGlhbG9nXCI7XG4gICAgaWYgKGlzU3RhbmRhbG9uZSkge1xuICAgICAgY29tbWVudC5hcmlhQ29udHJvbHMgPSBcImNvbW1lbnRQb3B1cFwiO1xuICAgICAgY29tbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1zaG93LWNvbW1lbnQtYnV0dG9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21tZW50LmFyaWFDb250cm9sc0VsZW1lbnRzID0gW3RoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmdldENvbW1lbnREaWFsb2dFbGVtZW50KCldO1xuICAgICAgY29tbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItZWRpdC1jb21tZW50LWJ1dHRvblwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBpZiAoIShzaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkgfHwgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH1cbiAgICBjb21tZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBpZiAoaXNTdGFuZGFsb25lKSB7XG4gICAgICBjb21tZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGUgPT4ge1xuICAgICAgICB0aGlzLiNlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgICB9LCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBjb21tZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBlID0+IHtcbiAgICAgICAgdGhpcy4jZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgICB9LCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGV2ZW50ID0+IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBvbkNsaWNrID0gZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmIChjb21tZW50ID09PSB0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbikge1xuICAgICAgICB0aGlzLmVkaXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI2VkaXRvci50b2dnbGVDb21tZW50KHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbGljaywge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gY29tbWVudCAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICB0aGlzLiNjb21tZW50V2FzRnJvbUtleUJvYXJkID0gdHJ1ZTtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmVudGVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMuI2VkaXRvci50b2dnbGVDb21tZW50KGZhbHNlLCB0cnVlKTtcbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb21tZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jZWRpdG9yLnRvZ2dsZUNvbW1lbnQoZmFsc2UsIGZhbHNlKTtcbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuICBlZGl0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuY29tbWVudFBvcHVwUG9zaXRpb25JbkxheWVyO1xuICAgIGxldCBwb3NYLCBwb3NZO1xuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgW3Bvc1gsIHBvc1ldID0gcG9zaXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIFtwb3NYLCBwb3NZXSA9IHRoaXMuI2VkaXRvci5jb21tZW50QnV0dG9uUG9zaXRpb247XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSB0aGlzLiNlZGl0b3I7XG4gICAgICBwb3NYID0geCArIHBvc1ggKiB3aWR0aDtcbiAgICAgIHBvc1kgPSB5ICsgcG9zWSAqIGhlaWdodDtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50RGltZW5zaW9ucyA9IHRoaXMuI2VkaXRvci5wYXJlbnQuYm91bmRpbmdDbGllbnRSZWN0O1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IHBhcmVudFgsXG4gICAgICB5OiBwYXJlbnRZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gcGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5lZGl0Q29tbWVudCh0aGlzLiNlZGl0b3IsIHBhcmVudFggKyBwb3NYICogcGFyZW50V2lkdGgsIHBhcmVudFkgKyBwb3NZICogcGFyZW50SGVpZ2h0LCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcGFyZW50RGltZW5zaW9uc1xuICAgIH0pO1xuICB9XG4gIGZpbmlzaCgpIHtcbiAgICBpZiAoIXRoaXMuI2NvbW1lbnRUb29sYmFyQnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnRUb29sYmFyQnV0dG9uLmZvY3VzKHtcbiAgICAgIGZvY3VzVmlzaWJsZTogdGhpcy4jY29tbWVudFdhc0Zyb21LZXlCb2FyZFxuICAgIH0pO1xuICAgIHRoaXMuI2NvbW1lbnRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgfVxuICBpc0RlbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlbGV0ZWQgfHwgdGhpcy4jdGV4dCA9PT0gXCJcIjtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLiN0ZXh0ID09PSBudWxsO1xuICB9XG4gIGhhc0JlZW5FZGl0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEZWxldGVkKCkgfHwgdGhpcy4jdGV4dCAhPT0gdGhpcy4jaW5pdGlhbFRleHQ7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHRoaXMuI3RleHQsXG4gICAgICByaWNoVGV4dDogdGhpcy4jcmljaFRleHQsXG4gICAgICBkYXRlOiB0aGlzLiNkYXRlLFxuICAgICAgZGVsZXRlZDogdGhpcy5pc0RlbGV0ZWQoKVxuICAgIH07XG4gIH1cbiAgc2V0IGRhdGEodGV4dCkge1xuICAgIGlmICh0ZXh0ICE9PSB0aGlzLiN0ZXh0KSB7XG4gICAgICB0aGlzLiNyaWNoVGV4dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0ZXh0ID09PSBudWxsKSB7XG4gICAgICB0aGlzLiN0ZXh0ID0gXCJcIjtcbiAgICAgIHRoaXMuI2RlbGV0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN0ZXh0ID0gdGV4dDtcbiAgICB0aGlzLiNkYXRlID0gbmV3IERhdGUoKTtcbiAgICB0aGlzLiNkZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgc2V0SW5pdGlhbFRleHQodGV4dCwgcmljaFRleHQgPSBudWxsKSB7XG4gICAgdGhpcy4jaW5pdGlhbFRleHQgPSB0ZXh0O1xuICAgIHRoaXMuZGF0YSA9IHRleHQ7XG4gICAgdGhpcy4jZGF0ZSA9IG51bGw7XG4gICAgdGhpcy4jcmljaFRleHQgPSByaWNoVGV4dDtcbiAgfVxuICBzaG93bigpIHt9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jY29tbWVudFRvb2xiYXJCdXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2NvbW1lbnRUb29sYmFyQnV0dG9uID0gbnVsbDtcbiAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24gPSBudWxsO1xuICAgIHRoaXMuI3RleHQgPSBcIlwiO1xuICAgIHRoaXMuI3JpY2hUZXh0ID0gbnVsbDtcbiAgICB0aGlzLiNkYXRlID0gbnVsbDtcbiAgICB0aGlzLiNlZGl0b3IgPSBudWxsO1xuICAgIHRoaXMuI2NvbW1lbnRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgICB0aGlzLiNkZWxldGVkID0gZmFsc2U7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvdG91Y2hfbWFuYWdlci5qc1xuXG5jbGFzcyBUb3VjaE1hbmFnZXIge1xuICAjY29udGFpbmVyO1xuICAjaXNQaW5jaGluZyA9IGZhbHNlO1xuICAjaXNQaW5jaGluZ1N0b3BwZWQgPSBudWxsO1xuICAjaXNQaW5jaGluZ0Rpc2FibGVkO1xuICAjb25QaW5jaFN0YXJ0O1xuICAjb25QaW5jaGluZztcbiAgI29uUGluY2hFbmQ7XG4gICNwb2ludGVyRG93bkFDID0gbnVsbDtcbiAgI3NpZ25hbDtcbiAgI3RvdWNoSW5mbyA9IG51bGw7XG4gICN0b3VjaE1hbmFnZXJBQztcbiAgI3RvdWNoTW92ZUFDID0gbnVsbDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRhaW5lcixcbiAgICBpc1BpbmNoaW5nRGlzYWJsZWQgPSBudWxsLFxuICAgIGlzUGluY2hpbmdTdG9wcGVkID0gbnVsbCxcbiAgICBvblBpbmNoU3RhcnQgPSBudWxsLFxuICAgIG9uUGluY2hpbmcgPSBudWxsLFxuICAgIG9uUGluY2hFbmQgPSBudWxsLFxuICAgIHNpZ25hbFxuICB9KSB7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI2lzUGluY2hpbmdTdG9wcGVkID0gaXNQaW5jaGluZ1N0b3BwZWQ7XG4gICAgdGhpcy4jaXNQaW5jaGluZ0Rpc2FibGVkID0gaXNQaW5jaGluZ0Rpc2FibGVkO1xuICAgIHRoaXMuI29uUGluY2hTdGFydCA9IG9uUGluY2hTdGFydDtcbiAgICB0aGlzLiNvblBpbmNoaW5nID0gb25QaW5jaGluZztcbiAgICB0aGlzLiNvblBpbmNoRW5kID0gb25QaW5jaEVuZDtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXJBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLiNzaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW3NpZ25hbCwgdGhpcy4jdG91Y2hNYW5hZ2VyQUMuc2lnbmFsXSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuI29uVG91Y2hTdGFydC5iaW5kKHRoaXMpLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbDogdGhpcy4jc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgZ2V0IE1JTl9UT1VDSF9ESVNUQU5DRV9UT19QSU5DSCgpIHtcbiAgICByZXR1cm4gMzUgLyBPdXRwdXRTY2FsZS5waXhlbFJhdGlvO1xuICB9XG4gICNvblRvdWNoU3RhcnQoZXZ0KSB7XG4gICAgaWYgKHRoaXMuI2lzUGluY2hpbmdEaXNhYmxlZD8uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2dC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHRoaXMuI3BvaW50ZXJEb3duQUMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9pbnRlckRvd25BQyA9IHRoaXMuI3BvaW50ZXJEb3duQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW3RoaXMuI3NpZ25hbCwgcG9pbnRlckRvd25BQy5zaWduYWxdKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb25zdCBjYW5jZWxQb2ludGVyRG93biA9IGUgPT4ge1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgdGhpcy4jcG9pbnRlckRvd25BQz8uYWJvcnQoKTtcbiAgICAgICAgICB0aGlzLiNwb2ludGVyRG93bkFDID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZSA9PiB7XG4gICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgICAgICAgY2FuY2VsUG9pbnRlckRvd24oZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIG9wdHMpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgY2FuY2VsUG9pbnRlckRvd24sIG9wdHMpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIGNhbmNlbFBvaW50ZXJEb3duLCBvcHRzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiN0b3VjaE1vdmVBQykge1xuICAgICAgdGhpcy4jdG91Y2hNb3ZlQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW3RoaXMuI3NpZ25hbCwgdGhpcy4jdG91Y2hNb3ZlQUMuc2lnbmFsXSk7XG4gICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLiNjb250YWluZXI7XG4gICAgICBjb25zdCBvcHQgPSB7XG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy4jb25Ub3VjaE1vdmUuYmluZCh0aGlzKSwgb3B0KTtcbiAgICAgIGNvbnN0IG9uVG91Y2hFbmQgPSB0aGlzLiNvblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIG9uVG91Y2hFbmQsIG9wdCk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIG9uVG91Y2hFbmQsIG9wdCk7XG4gICAgICBvcHQuY2FwdHVyZSA9IHRydWU7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHN0b3BFdmVudCwgb3B0KTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgc3RvcEV2ZW50LCBvcHQpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIHN0b3BFdmVudCwgb3B0KTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHN0b3BFdmVudCwgb3B0KTtcbiAgICAgIHRoaXMuI29uUGluY2hTdGFydD8uKCk7XG4gICAgfVxuICAgIHN0b3BFdmVudChldnQpO1xuICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgdGhpcy4jaXNQaW5jaGluZ1N0b3BwZWQ/LigpKSB7XG4gICAgICB0aGlzLiN0b3VjaEluZm8gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgW3RvdWNoMCwgdG91Y2gxXSA9IGV2dC50b3VjaGVzO1xuICAgIGlmICh0b3VjaDAuaWRlbnRpZmllciA+IHRvdWNoMS5pZGVudGlmaWVyKSB7XG4gICAgICBbdG91Y2gwLCB0b3VjaDFdID0gW3RvdWNoMSwgdG91Y2gwXTtcbiAgICB9XG4gICAgdGhpcy4jdG91Y2hJbmZvID0ge1xuICAgICAgdG91Y2gwWDogdG91Y2gwLnNjcmVlblgsXG4gICAgICB0b3VjaDBZOiB0b3VjaDAuc2NyZWVuWSxcbiAgICAgIHRvdWNoMVg6IHRvdWNoMS5zY3JlZW5YLFxuICAgICAgdG91Y2gxWTogdG91Y2gxLnNjcmVlbllcbiAgICB9O1xuICB9XG4gICNvblRvdWNoTW92ZShldnQpIHtcbiAgICBpZiAoIXRoaXMuI3RvdWNoSW5mbyB8fCBldnQudG91Y2hlcy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2dCk7XG4gICAgbGV0IFt0b3VjaDAsIHRvdWNoMV0gPSBldnQudG91Y2hlcztcbiAgICBpZiAodG91Y2gwLmlkZW50aWZpZXIgPiB0b3VjaDEuaWRlbnRpZmllcikge1xuICAgICAgW3RvdWNoMCwgdG91Y2gxXSA9IFt0b3VjaDEsIHRvdWNoMF07XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNjcmVlblg6IHNjcmVlbjBYLFxuICAgICAgc2NyZWVuWTogc2NyZWVuMFlcbiAgICB9ID0gdG91Y2gwO1xuICAgIGNvbnN0IHtcbiAgICAgIHNjcmVlblg6IHNjcmVlbjFYLFxuICAgICAgc2NyZWVuWTogc2NyZWVuMVlcbiAgICB9ID0gdG91Y2gxO1xuICAgIGNvbnN0IHRvdWNoSW5mbyA9IHRoaXMuI3RvdWNoSW5mbztcbiAgICBjb25zdCB7XG4gICAgICB0b3VjaDBYOiBwVG91Y2gwWCxcbiAgICAgIHRvdWNoMFk6IHBUb3VjaDBZLFxuICAgICAgdG91Y2gxWDogcFRvdWNoMVgsXG4gICAgICB0b3VjaDFZOiBwVG91Y2gxWVxuICAgIH0gPSB0b3VjaEluZm87XG4gICAgY29uc3QgcHJldkdhcFggPSBwVG91Y2gxWCAtIHBUb3VjaDBYO1xuICAgIGNvbnN0IHByZXZHYXBZID0gcFRvdWNoMVkgLSBwVG91Y2gwWTtcbiAgICBjb25zdCBjdXJyR2FwWCA9IHNjcmVlbjFYIC0gc2NyZWVuMFg7XG4gICAgY29uc3QgY3VyckdhcFkgPSBzY3JlZW4xWSAtIHNjcmVlbjBZO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5oeXBvdChjdXJyR2FwWCwgY3VyckdhcFkpIHx8IDE7XG4gICAgY29uc3QgcERpc3RhbmNlID0gTWF0aC5oeXBvdChwcmV2R2FwWCwgcHJldkdhcFkpIHx8IDE7XG4gICAgaWYgKCF0aGlzLiNpc1BpbmNoaW5nICYmIE1hdGguYWJzKHBEaXN0YW5jZSAtIGRpc3RhbmNlKSA8PSBUb3VjaE1hbmFnZXIuTUlOX1RPVUNIX0RJU1RBTkNFX1RPX1BJTkNIKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRvdWNoSW5mby50b3VjaDBYID0gc2NyZWVuMFg7XG4gICAgdG91Y2hJbmZvLnRvdWNoMFkgPSBzY3JlZW4wWTtcbiAgICB0b3VjaEluZm8udG91Y2gxWCA9IHNjcmVlbjFYO1xuICAgIHRvdWNoSW5mby50b3VjaDFZID0gc2NyZWVuMVk7XG4gICAgaWYgKCF0aGlzLiNpc1BpbmNoaW5nKSB7XG4gICAgICB0aGlzLiNpc1BpbmNoaW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luID0gWyhzY3JlZW4wWCArIHNjcmVlbjFYKSAvIDIsIChzY3JlZW4wWSArIHNjcmVlbjFZKSAvIDJdO1xuICAgIHRoaXMuI29uUGluY2hpbmc/LihvcmlnaW4sIHBEaXN0YW5jZSwgZGlzdGFuY2UpO1xuICB9XG4gICNvblRvdWNoRW5kKGV2dCkge1xuICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdG91Y2hNb3ZlQUMpIHtcbiAgICAgIHRoaXMuI3RvdWNoTW92ZUFDLmFib3J0KCk7XG4gICAgICB0aGlzLiN0b3VjaE1vdmVBQyA9IG51bGw7XG4gICAgICB0aGlzLiNvblBpbmNoRW5kPy4oKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiN0b3VjaEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2dCk7XG4gICAgdGhpcy4jdG91Y2hJbmZvID0gbnVsbDtcbiAgICB0aGlzLiNpc1BpbmNoaW5nID0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXJBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiN0b3VjaE1hbmFnZXJBQyA9IG51bGw7XG4gICAgdGhpcy4jcG9pbnRlckRvd25BQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNwb2ludGVyRG93bkFDID0gbnVsbDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZWRpdG9yLmpzXG5cblxuXG5cblxuXG5cbmNsYXNzIEFubm90YXRpb25FZGl0b3Ige1xuICAjYWNjZXNzaWJpbGl0eURhdGEgPSBudWxsO1xuICAjYWxsUmVzaXplckRpdnMgPSBudWxsO1xuICAjYWx0VGV4dCA9IG51bGw7XG4gICNjb21tZW50ID0gbnVsbDtcbiAgI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uID0gbnVsbDtcbiAgI2Rpc2FibGVkID0gZmFsc2U7XG4gICNkcmFnUG9pbnRlcklkID0gbnVsbDtcbiAgI2RyYWdQb2ludGVyVHlwZSA9IFwiXCI7XG4gICNyZXNpemVyc0RpdiA9IG51bGw7XG4gICNsYXN0UG9pbnRlckNvb3JkcyA9IG51bGw7XG4gICNzYXZlZERpbWVuc2lvbnMgPSBudWxsO1xuICAjZmFrZUFubm90YXRpb24gPSBudWxsO1xuICAjZm9jdXNBQyA9IG51bGw7XG4gICNmb2N1c2VkUmVzaXplck5hbWUgPSBcIlwiO1xuICAjaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgI2luaXRpYWxSZWN0ID0gbnVsbDtcbiAgI2lzRWRpdGluZyA9IGZhbHNlO1xuICAjaXNJbkVkaXRNb2RlID0gZmFsc2U7XG4gICNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPSBmYWxzZTtcbiAgI21vdmVJbkRPTVRpbWVvdXQgPSBudWxsO1xuICAjcHJldkRyYWdYID0gMDtcbiAgI3ByZXZEcmFnWSA9IDA7XG4gICN0ZWxlbWV0cnlUaW1lb3V0cyA9IG51bGw7XG4gICN0b3VjaE1hbmFnZXIgPSBudWxsO1xuICBpc1NlbGVjdGVkID0gZmFsc2U7XG4gIF9pc0NvcHkgPSBmYWxzZTtcbiAgX2VkaXRUb29sYmFyID0gbnVsbDtcbiAgX2luaXRpYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgX2luaXRpYWxEYXRhID0gbnVsbDtcbiAgX2lzVmlzaWJsZSA9IHRydWU7XG4gIF91aU1hbmFnZXIgPSBudWxsO1xuICBfZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgc3RhdGljIF9sMTBuID0gbnVsbDtcbiAgc3RhdGljIF9sMTBuUmVzaXplciA9IG51bGw7XG4gICNpc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAjekluZGV4ID0gQW5ub3RhdGlvbkVkaXRvci5fekluZGV4Kys7XG4gIHN0YXRpYyBfYm9yZGVyTGluZVdpZHRoID0gLTE7XG4gIHN0YXRpYyBfY29sb3JNYW5hZ2VyID0gbmV3IENvbG9yTWFuYWdlcigpO1xuICBzdGF0aWMgX3pJbmRleCA9IDE7XG4gIHN0YXRpYyBfdGVsZW1ldHJ5VGltZW91dCA9IDEwMDA7XG4gIHN0YXRpYyBnZXQgX3Jlc2l6ZXJLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcmVzaXplID0gQW5ub3RhdGlvbkVkaXRvci5wcm90b3R5cGUuX3Jlc2l6ZVdpdGhLZXlib2FyZDtcbiAgICBjb25zdCBzbWFsbCA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX1NNQUxMO1xuICAgIGNvbnN0IGJpZyA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX3Jlc2l6ZXJLZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF1cbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXVxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ11cbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIHNtYWxsXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddXG4gICAgfV0sIFtbXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBBbm5vdGF0aW9uRWRpdG9yLnByb3RvdHlwZS5fc3RvcFJlc2l6aW5nV2l0aEtleWJvYXJkXV0pKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJhbWV0ZXJzLnBhcmVudDtcbiAgICB0aGlzLmlkID0gcGFyYW1ldGVycy5pZDtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSBudWxsO1xuICAgIHRoaXMucGFnZUluZGV4ID0gcGFyYW1ldGVycy5wYXJlbnQucGFnZUluZGV4O1xuICAgIHRoaXMubmFtZSA9IHBhcmFtZXRlcnMubmFtZTtcbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgdGhpcy5fdWlNYW5hZ2VyID0gcGFyYW1ldGVycy51aU1hbmFnZXI7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkID0gbnVsbDtcbiAgICB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMuaXNDZW50ZXJlZCA9IHBhcmFtZXRlcnMuaXNDZW50ZXJlZDtcbiAgICB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWQgPSBudWxsO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IHBhcmFtZXRlcnMuYW5ub3RhdGlvbkVsZW1lbnRJZCB8fCBudWxsO1xuICAgIHRoaXMuY3JlYXRpb25EYXRlID0gcGFyYW1ldGVycy5jcmVhdGlvbkRhdGUgfHwgbmV3IERhdGUoKTtcbiAgICB0aGlzLm1vZGlmaWNhdGlvbkRhdGUgPSBwYXJhbWV0ZXJzLm1vZGlmaWNhdGlvbkRhdGUgfHwgbnVsbDtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvbixcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICBwYWdlWCxcbiAgICAgICAgcGFnZVlcbiAgICAgIH1cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMucGFnZVJvdGF0aW9uID0gKDM2MCArIHJvdGF0aW9uIC0gdGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uKSAlIDM2MDtcbiAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gICAgdGhpcy5wYWdlVHJhbnNsYXRpb24gPSBbcGFnZVgsIHBhZ2VZXTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy54ID0gcGFyYW1ldGVycy54IC8gd2lkdGg7XG4gICAgdGhpcy55ID0gcGFyYW1ldGVycy55IC8gaGVpZ2h0O1xuICAgIHRoaXMuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgdGhpcy5kZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IGVkaXRvclR5cGUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvci5fdHlwZTtcbiAgfVxuICBnZXQgbW9kZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yLl9lZGl0b3JUeXBlO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNEcmF3ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBnZXQgX2RlZmF1bHRMaW5lQ29sb3IoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9kZWZhdWx0TGluZUNvbG9yXCIsIHRoaXMuX2NvbG9yTWFuYWdlci5nZXRIZXhDb2RlKFwiQ2FudmFzVGV4dFwiKSk7XG4gIH1cbiAgc3RhdGljIGRlbGV0ZUFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIGNvbnN0IGZha2VFZGl0b3IgPSBuZXcgRmFrZUVkaXRvcih7XG4gICAgICBpZDogZWRpdG9yLnBhcmVudC5nZXROZXh0SWQoKSxcbiAgICAgIHBhcmVudDogZWRpdG9yLnBhcmVudCxcbiAgICAgIHVpTWFuYWdlcjogZWRpdG9yLl91aU1hbmFnZXJcbiAgICB9KTtcbiAgICBmYWtlRWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICBmYWtlRWRpdG9yLmRlbGV0ZWQgPSB0cnVlO1xuICAgIGZha2VFZGl0b3IuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGZha2VFZGl0b3IpO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIF91aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuID8/PSBsMTBuO1xuICAgIEFubm90YXRpb25FZGl0b3IuX2wxMG5SZXNpemVyIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIHRvcExlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLWxlZnRcIixcbiAgICAgIHRvcE1pZGRsZTogXCJwZGZqcy1lZGl0b3ItcmVzaXplci10b3AtbWlkZGxlXCIsXG4gICAgICB0b3BSaWdodDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci10b3AtcmlnaHRcIixcbiAgICAgIG1pZGRsZVJpZ2h0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLW1pZGRsZS1yaWdodFwiLFxuICAgICAgYm90dG9tUmlnaHQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItYm90dG9tLXJpZ2h0XCIsXG4gICAgICBib3R0b21NaWRkbGU6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItYm90dG9tLW1pZGRsZVwiLFxuICAgICAgYm90dG9tTGVmdDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1ib3R0b20tbGVmdFwiLFxuICAgICAgbWlkZGxlTGVmdDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1taWRkbGUtbGVmdFwiXG4gICAgfSk7XG4gICAgaWYgKEFubm90YXRpb25FZGl0b3IuX2JvcmRlckxpbmVXaWR0aCAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fYm9yZGVyTGluZVdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1vdXRsaW5lLXdpZHRoXCIpKSB8fCAwO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKF90eXBlLCBfdmFsdWUpIHt9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgc3RhdGljIGlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhtaW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBwYXN0ZShpdGVtLCBwYXJlbnQpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXQgX2lzRHJhZ2dhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0RyYWdnYWJsZTtcbiAgfVxuICBzZXQgX2lzRHJhZ2dhYmxlKHZhbHVlKSB7XG4gICAgdGhpcy4jaXNEcmFnZ2FibGUgPSB2YWx1ZTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LnRvZ2dsZShcImRyYWdnYWJsZVwiLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0IHVpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkIHx8IHRoaXMuaWQ7XG4gIH1cbiAgZ2V0IGlzRW50ZXJIYW5kbGVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNlbnRlcigpIHtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudFJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB0aGlzLnggLT0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0IC8gKHBhZ2VXaWR0aCAqIDIpO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAvIChwYWdlSGVpZ2h0ICogMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHRoaXMueCArPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgdGhpcy54ICs9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAvIChwYWdlV2lkdGggKiAyKTtcbiAgICAgICAgdGhpcy55IC09IHRoaXMud2lkdGggKiBwYWdlV2lkdGggLyAocGFnZUhlaWdodCAqIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMueCAtPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy55IC09IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkQ29tbWFuZHMocGFyYW1zKTtcbiAgfVxuICBnZXQgY3VycmVudExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIuY3VycmVudExheWVyO1xuICB9XG4gIHNldEluQmFja2dyb3VuZCgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSAwO1xuICB9XG4gIHNldEluRm9yZWdyb3VuZCgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSB0aGlzLiN6SW5kZXg7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMucGFnZUluZGV4ID0gcGFyZW50LnBhZ2VJbmRleDtcbiAgICAgIHRoaXMucGFnZURpbWVuc2lvbnMgPSBwYXJlbnQucGFnZURpbWVuc2lvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgICAgdGhpcy4jZmFrZUFubm90YXRpb24/LnJlbW92ZSgpO1xuICAgICAgdGhpcy4jZmFrZUFubm90YXRpb24gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNoYXNCZWVuQ2xpY2tlZCkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvY3Vzb3V0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmICh0YXJnZXQ/LmNsb3Nlc3QoYCMke3RoaXMuaWR9YCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXRoaXMucGFyZW50Py5pc011bHRpcGxlU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoKTtcbiAgfVxuICBhZGRUb0Fubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIHNldEF0KHgsIHksIHR4LCB0eSkge1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBbdHgsIHR5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24odHgsIHR5KTtcbiAgICB0aGlzLnggPSAoeCArIHR4KSAvIHdpZHRoO1xuICAgIHRoaXMueSA9ICh5ICsgdHkpIC8gaGVpZ2h0O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBfbW92ZUFmdGVyUGFzdGUoYmFzZVgsIGJhc2VZKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIHRoaXMuX29uVHJhbnNsYXRlZCgpO1xuICB9XG4gICN0cmFuc2xhdGUoW3dpZHRoLCBoZWlnaHRdLCB4LCB5KSB7XG4gICAgW3gsIHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KTtcbiAgICB0aGlzLnggKz0geCAvIHdpZHRoO1xuICAgIHRoaXMueSArPSB5IC8gaGVpZ2h0O1xuICAgIHRoaXMuX29uVHJhbnNsYXRpbmcodGhpcy54LCB0aGlzLnkpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICB0cmFuc2xhdGUoeCwgeSkge1xuICAgIHRoaXMuI3RyYW5zbGF0ZSh0aGlzLnBhcmVudERpbWVuc2lvbnMsIHgsIHkpO1xuICB9XG4gIHRyYW5zbGF0ZUluUGFnZSh4LCB5KSB7XG4gICAgdGhpcy4jaW5pdGlhbFJlY3QgfHw9IFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdO1xuICAgIHRoaXMuI3RyYW5zbGF0ZSh0aGlzLnBhZ2VEaW1lbnNpb25zLCB4LCB5KTtcbiAgICB0aGlzLmRpdi5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICB9KTtcbiAgfVxuICB0cmFuc2xhdGlvbkRvbmUoKSB7XG4gICAgdGhpcy5fb25UcmFuc2xhdGVkKHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICBkcmFnKHR4LCB0eSkge1xuICAgIHRoaXMuI2luaXRpYWxSZWN0IHx8PSBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XTtcbiAgICBjb25zdCB7XG4gICAgICBkaXYsXG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF1cbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLnggKz0gdHggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLnkgKz0gdHkgLyBwYXJlbnRIZWlnaHQ7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmICh0aGlzLnggPCAwIHx8IHRoaXMueCA+IDEgfHwgdGhpcy55IDwgMCB8fCB0aGlzLnkgPiAxKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAodGhpcy5wYXJlbnQuZmluZE5ld1BhcmVudCh0aGlzLCB4LCB5KSkge1xuICAgICAgICB0aGlzLnggLT0gTWF0aC5mbG9vcih0aGlzLngpO1xuICAgICAgICB0aGlzLnkgLT0gTWF0aC5mbG9vcih0aGlzLnkpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBbYngsIGJ5XSA9IHRoaXMuZ2V0QmFzZVRyYW5zbGF0aW9uKCk7XG4gICAgeCArPSBieDtcbiAgICB5ICs9IGJ5O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIHgpLnRvRml4ZWQoMil9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7KDEwMCAqIHkpLnRvRml4ZWQoMil9JWA7XG4gICAgdGhpcy5fb25UcmFuc2xhdGluZyh4LCB5KTtcbiAgICBkaXYuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH1cbiAgX29uVHJhbnNsYXRpbmcoeCwgeSkge31cbiAgX29uVHJhbnNsYXRlZCh4LCB5KSB7fVxuICBnZXQgX2hhc0JlZW5Nb3ZlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLiNpbml0aWFsUmVjdCAmJiAodGhpcy4jaW5pdGlhbFJlY3RbMF0gIT09IHRoaXMueCB8fCB0aGlzLiNpbml0aWFsUmVjdFsxXSAhPT0gdGhpcy55KTtcbiAgfVxuICBnZXQgX2hhc0JlZW5SZXNpemVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuI2luaXRpYWxSZWN0ICYmICh0aGlzLiNpbml0aWFsUmVjdFsyXSAhPT0gdGhpcy53aWR0aCB8fCB0aGlzLiNpbml0aWFsUmVjdFszXSAhPT0gdGhpcy5oZWlnaHQpO1xuICB9XG4gIGdldEJhc2VUcmFuc2xhdGlvbigpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qge1xuICAgICAgX2JvcmRlckxpbmVXaWR0aFxuICAgIH0gPSBBbm5vdGF0aW9uRWRpdG9yO1xuICAgIGNvbnN0IHggPSBfYm9yZGVyTGluZVdpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgeSA9IF9ib3JkZXJMaW5lV2lkdGggLyBwYXJlbnRIZWlnaHQ7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWy14LCB5XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeCwgLXldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFsteCwgLXldO1xuICAgIH1cbiAgfVxuICBnZXQgX211c3RGaXhQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmaXhBbmRTZXRQb3NpdGlvbihyb3RhdGlvbiA9IHRoaXMucm90YXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXY6IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0sXG4gICAgICBwYWdlRGltZW5zaW9uczogW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF1cbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIHdpZHRoICo9IHBhZ2VXaWR0aDtcbiAgICBoZWlnaHQgKj0gcGFnZUhlaWdodDtcbiAgICB4ICo9IHBhZ2VXaWR0aDtcbiAgICB5ICo9IHBhZ2VIZWlnaHQ7XG4gICAgaWYgKHRoaXMuX211c3RGaXhQb3NpdGlvbikge1xuICAgICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgeCA9IE1hdGhDbGFtcCh4LCAwLCBwYWdlV2lkdGggLSB3aWR0aCk7XG4gICAgICAgICAgeSA9IE1hdGhDbGFtcCh5LCAwLCBwYWdlSGVpZ2h0IC0gaGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICB4ID0gTWF0aENsYW1wKHgsIDAsIHBhZ2VXaWR0aCAtIGhlaWdodCk7XG4gICAgICAgICAgeSA9IE1hdGhDbGFtcCh5LCB3aWR0aCwgcGFnZUhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgIHggPSBNYXRoQ2xhbXAoeCwgd2lkdGgsIHBhZ2VXaWR0aCk7XG4gICAgICAgICAgeSA9IE1hdGhDbGFtcCh5LCBoZWlnaHQsIHBhZ2VIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgICB4ID0gTWF0aENsYW1wKHgsIGhlaWdodCwgcGFnZVdpZHRoKTtcbiAgICAgICAgICB5ID0gTWF0aENsYW1wKHksIDAsIHBhZ2VIZWlnaHQgLSB3aWR0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMueCA9IHggLz0gcGFnZVdpZHRoO1xuICAgIHRoaXMueSA9IHkgLz0gcGFnZUhlaWdodDtcbiAgICBjb25zdCBbYngsIGJ5XSA9IHRoaXMuZ2V0QmFzZVRyYW5zbGF0aW9uKCk7XG4gICAgeCArPSBieDtcbiAgICB5ICs9IGJ5O1xuICAgIHN0eWxlLmxlZnQgPSBgJHsoMTAwICogeCkudG9GaXhlZCgyKX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsoMTAwICogeSkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLm1vdmVJbkRPTSgpO1xuICB9XG4gIHN0YXRpYyAjcm90YXRlUG9pbnQoeCwgeSwgYW5nbGUpIHtcbiAgICBzd2l0Y2ggKGFuZ2xlKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ksIC14XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWy14LCAteV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFsteSwgeF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgfVxuICBzY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3IuI3JvdGF0ZVBvaW50KHgsIHksIHRoaXMucGFyZW50Um90YXRpb24pO1xuICB9XG4gIHBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuKHgsIHkpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvci4jcm90YXRlUG9pbnQoeCwgeSwgMzYwIC0gdGhpcy5wYXJlbnRSb3RhdGlvbik7XG4gIH1cbiAgI2dldFJvdGF0aW9uTWF0cml4KHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgICByZXR1cm4gWzAsIC1wYWdlV2lkdGggLyBwYWdlSGVpZ2h0LCBwYWdlSGVpZ2h0IC8gcGFnZVdpZHRoLCAwXTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbLTEsIDAsIDAsIC0xXTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICAgIHJldHVybiBbMCwgcGFnZVdpZHRoIC8gcGFnZUhlaWdodCwgLXBhZ2VIZWlnaHQgLyBwYWdlV2lkdGgsIDBdO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWzEsIDAsIDAsIDFdO1xuICAgIH1cbiAgfVxuICBnZXQgcGFyZW50U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gIH1cbiAgZ2V0IHBhcmVudFJvdGF0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uICsgdGhpcy5wYWdlUm90YXRpb24pICUgMzYwO1xuICB9XG4gIGdldCBwYXJlbnREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFNjYWxlLFxuICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtwYWdlV2lkdGggKiBwYXJlbnRTY2FsZSwgcGFnZUhlaWdodCAqIHBhcmVudFNjYWxlXTtcbiAgfVxuICBzZXREaW1zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdjoge1xuICAgICAgICBzdHlsZVxuICAgICAgfSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgc3R5bGUud2lkdGggPSBgJHsoMTAwICogd2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgc3R5bGUuaGVpZ2h0ID0gYCR7KDEwMCAqIGhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgfVxuICBnZXRJbml0aWFsVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICAjY3JlYXRlUmVzaXplcnMoKSB7XG4gICAgaWYgKHRoaXMuI3Jlc2l6ZXJzRGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdi5jbGFzc0xpc3QuYWRkKFwicmVzaXplcnNcIik7XG4gICAgY29uc3QgY2xhc3NlcyA9IHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPyBbXCJ0b3BMZWZ0XCIsIFwidG9wUmlnaHRcIiwgXCJib3R0b21SaWdodFwiLCBcImJvdHRvbUxlZnRcIl0gOiBbXCJ0b3BMZWZ0XCIsIFwidG9wTWlkZGxlXCIsIFwidG9wUmlnaHRcIiwgXCJtaWRkbGVSaWdodFwiLCBcImJvdHRvbVJpZ2h0XCIsIFwiYm90dG9tTWlkZGxlXCIsIFwiYm90dG9tTGVmdFwiLCBcIm1pZGRsZUxlZnRcIl07XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGNsYXNzZXMpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLiNyZXNpemVyc0Rpdi5hcHBlbmQoZGl2KTtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwicmVzaXplclwiLCBuYW1lKTtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiLCBuYW1lKTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jcmVzaXplclBvaW50ZXJkb3duLmJpbmQodGhpcywgbmFtZSksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgfVxuICAgIHRoaXMuZGl2LnByZXBlbmQodGhpcy4jcmVzaXplcnNEaXYpO1xuICB9XG4gICNyZXNpemVyUG9pbnRlcmRvd24obmFtZSwgZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZShmYWxzZSk7XG4gICAgY29uc3Qgc2F2ZWREcmFnZ2FibGUgPSB0aGlzLl9pc0RyYWdnYWJsZTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuI2xhc3RQb2ludGVyQ29vcmRzID0gW2V2ZW50LnNjcmVlblgsIGV2ZW50LnNjcmVlblldO1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgdGhpcy5wYXJlbnQudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLiNyZXNpemVyUG9pbnRlcm1vdmUuYmluZCh0aGlzLCBuYW1lKSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBzdG9wRXZlbnQsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSB7XG4gICAgICBzYXZlZFg6IHRoaXMueCxcbiAgICAgIHNhdmVkWTogdGhpcy55LFxuICAgICAgc2F2ZWRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRQYXJlbnRDdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIGNvbnN0IHNhdmVkQ3Vyc29yID0gdGhpcy5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjtcbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKHRydWUpO1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSBzYXZlZERyYWdnYWJsZTtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSBzYXZlZFBhcmVudEN1cnNvcjtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHNhdmVkQ3Vyc29yO1xuICAgICAgdGhpcy4jYWRkUmVzaXplVG9VbmRvU3RhY2soKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZXNpemUoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5zZXREaW1zKCk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIHRoaXMuX29uUmVzaXplZCgpO1xuICB9XG4gIF9vblJlc2l6ZWQoKSB7fVxuICAjYWRkUmVzaXplVG9VbmRvU3RhY2soKSB7XG4gICAgaWYgKCF0aGlzLiNzYXZlZERpbWVuc2lvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc2F2ZWRYLFxuICAgICAgc2F2ZWRZLFxuICAgICAgc2F2ZWRXaWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0XG4gICAgfSA9IHRoaXMuI3NhdmVkRGltZW5zaW9ucztcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSBudWxsO1xuICAgIGNvbnN0IG5ld1ggPSB0aGlzLng7XG4gICAgY29uc3QgbmV3WSA9IHRoaXMueTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgaWYgKG5ld1ggPT09IHNhdmVkWCAmJiBuZXdZID09PSBzYXZlZFkgJiYgbmV3V2lkdGggPT09IHNhdmVkV2lkdGggJiYgbmV3SGVpZ2h0ID09PSBzYXZlZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogdGhpcy4jcmVzaXplLmJpbmQodGhpcywgbmV3WCwgbmV3WSwgbmV3V2lkdGgsIG5ld0hlaWdodCksXG4gICAgICB1bmRvOiB0aGlzLiNyZXNpemUuYmluZCh0aGlzLCBzYXZlZFgsIHNhdmVkWSwgc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgX3JvdW5kKHgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh4ICogMTAwMDApIC8gMTAwMDA7XG4gIH1cbiAgI3Jlc2l6ZXJQb2ludGVybW92ZShuYW1lLCBldmVudCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluV2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgbWluSGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudEhlaWdodDtcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHRyYW5zZiA9ICh4LCB5KSA9PiBbcm90YXRpb25NYXRyaXhbMF0gKiB4ICsgcm90YXRpb25NYXRyaXhbMl0gKiB5LCByb3RhdGlvbk1hdHJpeFsxXSAqIHggKyByb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGNvbnN0IGludlJvdGF0aW9uTWF0cml4ID0gdGhpcy4jZ2V0Um90YXRpb25NYXRyaXgoMzYwIC0gdGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgaW52VHJhbnNmID0gKHgsIHkpID0+IFtpbnZSb3RhdGlvbk1hdHJpeFswXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFsyXSAqIHksIGludlJvdGF0aW9uTWF0cml4WzFdICogeCArIGludlJvdGF0aW9uTWF0cml4WzNdICogeV07XG4gICAgbGV0IGdldFBvaW50O1xuICAgIGxldCBnZXRPcHBvc2l0ZTtcbiAgICBsZXQgaXNEaWFnb25hbCA9IGZhbHNlO1xuICAgIGxldCBpc0hvcml6b250YWwgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJ0b3BMZWZ0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbMCwgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9wTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcFJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWlkZGxlUmlnaHRcIjpcbiAgICAgICAgaXNIb3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIGggLyAyXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIGggLyAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tUmlnaHRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21NaWRkbGVcIjpcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3cgLyAyLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3cgLyAyLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIGhdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZUxlZnRcIjpcbiAgICAgICAgaXNIb3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIGggLyAyXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIGggLyAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ID0gZ2V0UG9pbnQoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGNvbnN0IG9wcG9zaXRlUG9pbnQgPSBnZXRPcHBvc2l0ZShzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgbGV0IHRyYW5zZk9wcG9zaXRlUG9pbnQgPSB0cmFuc2YoLi4ub3Bwb3NpdGVQb2ludCk7XG4gICAgY29uc3Qgb3Bwb3NpdGVYID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRYICsgdHJhbnNmT3Bwb3NpdGVQb2ludFswXSk7XG4gICAgY29uc3Qgb3Bwb3NpdGVZID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRZICsgdHJhbnNmT3Bwb3NpdGVQb2ludFsxXSk7XG4gICAgbGV0IHJhdGlvWCA9IDE7XG4gICAgbGV0IHJhdGlvWSA9IDE7XG4gICAgbGV0IGRlbHRhWCwgZGVsdGFZO1xuICAgIGlmICghZXZlbnQuZnJvbUtleWJvYXJkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNjcmVlblgsXG4gICAgICAgIHNjcmVlbllcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIGNvbnN0IFtsYXN0U2NyZWVuWCwgbGFzdFNjcmVlblldID0gdGhpcy4jbGFzdFBvaW50ZXJDb29yZHM7XG4gICAgICBbZGVsdGFYLCBkZWx0YVldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbihzY3JlZW5YIC0gbGFzdFNjcmVlblgsIHNjcmVlblkgLSBsYXN0U2NyZWVuWSk7XG4gICAgICB0aGlzLiNsYXN0UG9pbnRlckNvb3Jkc1swXSA9IHNjcmVlblg7XG4gICAgICB0aGlzLiNsYXN0UG9pbnRlckNvb3Jkc1sxXSA9IHNjcmVlblk7XG4gICAgfSBlbHNlIHtcbiAgICAgICh7XG4gICAgICAgIGRlbHRhWCxcbiAgICAgICAgZGVsdGFZXG4gICAgICB9ID0gZXZlbnQpO1xuICAgIH1cbiAgICBbZGVsdGFYLCBkZWx0YVldID0gaW52VHJhbnNmKGRlbHRhWCAvIHBhcmVudFdpZHRoLCBkZWx0YVkgLyBwYXJlbnRIZWlnaHQpO1xuICAgIGlmIChpc0RpYWdvbmFsKSB7XG4gICAgICBjb25zdCBvbGREaWFnID0gTWF0aC5oeXBvdChzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgICByYXRpb1ggPSByYXRpb1kgPSBNYXRoLm1heChNYXRoLm1pbihNYXRoLmh5cG90KG9wcG9zaXRlUG9pbnRbMF0gLSBwb2ludFswXSAtIGRlbHRhWCwgb3Bwb3NpdGVQb2ludFsxXSAtIHBvaW50WzFdIC0gZGVsdGFZKSAvIG9sZERpYWcsIDEgLyBzYXZlZFdpZHRoLCAxIC8gc2F2ZWRIZWlnaHQpLCBtaW5XaWR0aCAvIHNhdmVkV2lkdGgsIG1pbkhlaWdodCAvIHNhdmVkSGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgcmF0aW9YID0gTWF0aENsYW1wKE1hdGguYWJzKG9wcG9zaXRlUG9pbnRbMF0gLSBwb2ludFswXSAtIGRlbHRhWCksIG1pbldpZHRoLCAxKSAvIHNhdmVkV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhdGlvWSA9IE1hdGhDbGFtcChNYXRoLmFicyhvcHBvc2l0ZVBvaW50WzFdIC0gcG9pbnRbMV0gLSBkZWx0YVkpLCBtaW5IZWlnaHQsIDEpIC8gc2F2ZWRIZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IG5ld1dpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRXaWR0aCAqIHJhdGlvWCk7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRIZWlnaHQgKiByYXRpb1kpO1xuICAgIHRyYW5zZk9wcG9zaXRlUG9pbnQgPSB0cmFuc2YoLi4uZ2V0T3Bwb3NpdGUobmV3V2lkdGgsIG5ld0hlaWdodCkpO1xuICAgIGNvbnN0IG5ld1ggPSBvcHBvc2l0ZVggLSB0cmFuc2ZPcHBvc2l0ZVBvaW50WzBdO1xuICAgIGNvbnN0IG5ld1kgPSBvcHBvc2l0ZVkgLSB0cmFuc2ZPcHBvc2l0ZVBvaW50WzFdO1xuICAgIHRoaXMuI2luaXRpYWxSZWN0IHx8PSBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XTtcbiAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy54ID0gbmV3WDtcbiAgICB0aGlzLnkgPSBuZXdZO1xuICAgIHRoaXMuc2V0RGltcygpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblJlc2l6aW5nKCk7XG4gIH1cbiAgX29uUmVzaXppbmcoKSB7fVxuICBhbHRUZXh0RmluaXNoKCkge1xuICAgIHRoaXMuI2FsdFRleHQ/LmZpbmlzaCgpO1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBhc3luYyBhZGRFZGl0VG9vbGJhcigpIHtcbiAgICBpZiAodGhpcy5fZWRpdFRvb2xiYXIgfHwgdGhpcy4jaXNJbkVkaXRNb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWRpdFRvb2xiYXI7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyID0gbmV3IEVkaXRvclRvb2xiYXIodGhpcyk7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuX2VkaXRUb29sYmFyLnJlbmRlcigpKTtcbiAgICBjb25zdCB7XG4gICAgICB0b29sYmFyQnV0dG9uc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICh0b29sYmFyQnV0dG9ucykge1xuICAgICAgZm9yIChjb25zdCBbbmFtZSwgdG9vbF0gb2YgdG9vbGJhckJ1dHRvbnMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZWRpdFRvb2xiYXIuYWRkQnV0dG9uKG5hbWUsIHRvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzQ29tbWVudCkge1xuICAgICAgdGhpcy5fZWRpdFRvb2xiYXIuYWRkQnV0dG9uKFwiY29tbWVudFwiLCB0aGlzLmFkZENvbW1lbnRCdXR0b24oKSk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyLmFkZEJ1dHRvbihcImRlbGV0ZVwiKTtcbiAgICByZXR1cm4gdGhpcy5fZWRpdFRvb2xiYXI7XG4gIH1cbiAgYWRkQ29tbWVudEJ1dHRvbkluVG9vbGJhcigpIHtcbiAgICB0aGlzLl9lZGl0VG9vbGJhcj8uYWRkQnV0dG9uQmVmb3JlKFwiY29tbWVudFwiLCB0aGlzLmFkZENvbW1lbnRCdXR0b24oKSwgXCIuZGVsZXRlQnV0dG9uXCIpO1xuICB9XG4gIHJlbW92ZUNvbW1lbnRCdXR0b25Gcm9tVG9vbGJhcigpIHtcbiAgICB0aGlzLl9lZGl0VG9vbGJhcj8ucmVtb3ZlQnV0dG9uKFwiY29tbWVudFwiKTtcbiAgfVxuICByZW1vdmVFZGl0VG9vbGJhcigpIHtcbiAgICB0aGlzLl9lZGl0VG9vbGJhcj8ucmVtb3ZlKCk7XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIgPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHQ/LmRlc3Ryb3koKTtcbiAgfVxuICBhZGRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXJEaXYgPSB0aGlzLl9lZGl0VG9vbGJhcj8uZGl2O1xuICAgIGlmIChlZGl0VG9vbGJhckRpdikge1xuICAgICAgZWRpdFRvb2xiYXJEaXYuYmVmb3JlKGNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChjb250YWluZXIpO1xuICAgIH1cbiAgfVxuICBnZXRDbGllbnREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBjcmVhdGVBbHRUZXh0KCkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dCkge1xuICAgICAgQWx0VGV4dC5pbml0aWFsaXplKEFubm90YXRpb25FZGl0b3IuX2wxMG4pO1xuICAgICAgdGhpcy4jYWx0VGV4dCA9IG5ldyBBbHRUZXh0KHRoaXMpO1xuICAgICAgaWYgKHRoaXMuI2FjY2Vzc2liaWxpdHlEYXRhKSB7XG4gICAgICAgIHRoaXMuI2FsdFRleHQuZGF0YSA9IHRoaXMuI2FjY2Vzc2liaWxpdHlEYXRhO1xuICAgICAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5RGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0O1xuICB9XG4gIGdldCBhbHRUZXh0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uZGF0YTtcbiAgfVxuICBzZXQgYWx0VGV4dERhdGEoZGF0YSkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0LmRhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBndWVzc2VkQWx0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uZ3Vlc3NlZFRleHQ7XG4gIH1cbiAgYXN5bmMgc2V0R3Vlc3NlZEFsdFRleHQodGV4dCkge1xuICAgIGF3YWl0IHRoaXMuI2FsdFRleHQ/LnNldEd1ZXNzZWRUZXh0KHRleHQpO1xuICB9XG4gIHNlcmlhbGl6ZUFsdFRleHQoaXNGb3JDb3B5aW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/LnNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpO1xuICB9XG4gIGhhc0FsdFRleHQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dC5pc0VtcHR5KCk7XG4gIH1cbiAgaGFzQWx0VGV4dERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/Lmhhc0RhdGEoKSA/PyBmYWxzZTtcbiAgfVxuICBmb2N1c0NvbW1lbnRCdXR0b24oKSB7XG4gICAgdGhpcy4jY29tbWVudD8uZm9jdXNCdXR0b24oKTtcbiAgfVxuICBhZGRDb21tZW50QnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50IHx8PSBuZXcgQ29tbWVudCh0aGlzKTtcbiAgfVxuICBhZGRTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpIHtcbiAgICBpZiAodGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24pIHtcbiAgICAgIGlmICh0aGlzLl91aU1hbmFnZXIuaXNFZGl0aW5nTW9kZSgpKSB7XG4gICAgICAgIHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNDb21tZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uID0gdGhpcy4jY29tbWVudC5yZW5kZXJGb3JTdGFuZGFsb25lKCk7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uKTtcbiAgfVxuICByZW1vdmVTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpIHtcbiAgICB0aGlzLiNjb21tZW50LnJlbW92ZVN0YW5kYWxvbmVDb21tZW50QnV0dG9uKCk7XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24gPSBudWxsO1xuICB9XG4gIGhpZGVTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpIHtcbiAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbj8uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgfVxuICBnZXQgY29tbWVudCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJpY2hUZXh0LFxuICAgICAgICB0ZXh0LFxuICAgICAgICBkYXRlLFxuICAgICAgICBkZWxldGVkXG4gICAgICB9XG4gICAgfSA9IHRoaXMuI2NvbW1lbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQsXG4gICAgICByaWNoVGV4dCxcbiAgICAgIGRhdGUsXG4gICAgICBkZWxldGVkLFxuICAgICAgY29sb3I6IHRoaXMuZ2V0Tm9uSENNQ29sb3IoKSxcbiAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSA/PyAxXG4gICAgfTtcbiAgfVxuICBzZXQgY29tbWVudCh0ZXh0KSB7XG4gICAgdGhpcy4jY29tbWVudCB8fD0gbmV3IENvbW1lbnQodGhpcyk7XG4gICAgdGhpcy4jY29tbWVudC5kYXRhID0gdGV4dDtcbiAgICBpZiAodGhpcy5oYXNDb21tZW50KSB7XG4gICAgICB0aGlzLnJlbW92ZUNvbW1lbnRCdXR0b25Gcm9tVG9vbGJhcigpO1xuICAgICAgdGhpcy5hZGRTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZUNvbW1lbnQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkQ29tbWVudEJ1dHRvbkluVG9vbGJhcigpO1xuICAgICAgdGhpcy5yZW1vdmVTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZUNvbW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldENvbW1lbnREYXRhKHtcbiAgICBjb21tZW50LFxuICAgIHBvcHVwUmVmLFxuICAgIHJpY2hUZXh0XG4gIH0pIHtcbiAgICBpZiAoIXBvcHVwUmVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnQgfHw9IG5ldyBDb21tZW50KHRoaXMpO1xuICAgIHRoaXMuI2NvbW1lbnQuc2V0SW5pdGlhbFRleHQoY29tbWVudCwgcmljaFRleHQpO1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlZERhdGEgPSB0aGlzLl91aU1hbmFnZXIuZ2V0QW5kUmVtb3ZlRGF0YUZyb21Bbm5vdGF0aW9uU3RvcmFnZSh0aGlzLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIGlmIChzdG9yZWREYXRhKSB7XG4gICAgICB0aGlzLnVwZGF0ZUZyb21Bbm5vdGF0aW9uTGF5ZXIoc3RvcmVkRGF0YSk7XG4gICAgfVxuICB9XG4gIGdldCBoYXNFZGl0ZWRDb21tZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50Py5oYXNCZWVuRWRpdGVkKCk7XG4gIH1cbiAgZ2V0IGhhc0RlbGV0ZWRDb21tZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50Py5pc0RlbGV0ZWQoKTtcbiAgfVxuICBnZXQgaGFzQ29tbWVudCgpIHtcbiAgICByZXR1cm4gISF0aGlzLiNjb21tZW50ICYmICF0aGlzLiNjb21tZW50LmlzRW1wdHkoKSAmJiAhdGhpcy4jY29tbWVudC5pc0RlbGV0ZWQoKTtcbiAgfVxuICBhc3luYyBlZGl0Q29tbWVudChvcHRpb25zKSB7XG4gICAgdGhpcy4jY29tbWVudCB8fD0gbmV3IENvbW1lbnQodGhpcyk7XG4gICAgdGhpcy4jY29tbWVudC5lZGl0KG9wdGlvbnMpO1xuICB9XG4gIHRvZ2dsZUNvbW1lbnQoaXNTZWxlY3RlZCwgdmlzaWJpbGl0eSA9IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLmhhc0NvbW1lbnQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci50b2dnbGVDb21tZW50KHRoaXMsIGlzU2VsZWN0ZWQsIHZpc2liaWxpdHkpO1xuICAgIH1cbiAgfVxuICBzZXRTZWxlY3RlZENvbW1lbnRCdXR0b24oc2VsZWN0ZWQpIHtcbiAgICB0aGlzLiNjb21tZW50LnNldFNlbGVjdGVkQnV0dG9uKHNlbGVjdGVkKTtcbiAgfVxuICBhZGRDb21tZW50KHNlcmlhbGl6ZWQpIHtcbiAgICBpZiAodGhpcy5oYXNFZGl0ZWRDb21tZW50KSB7XG4gICAgICBjb25zdCBERUZBVUxUX1BPUFVQX1dJRFRIID0gMTgwO1xuICAgICAgY29uc3QgREVGQVVMVF9QT1BVUF9IRUlHSFQgPSAxMDA7XG4gICAgICBjb25zdCBbLCwsIHRyWV0gPSBzZXJpYWxpemVkLnJlY3Q7XG4gICAgICBjb25zdCBbcGFnZVdpZHRoXSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICBjb25zdCBbcGFnZVhdID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgICBjb25zdCBibFggPSBwYWdlWCArIHBhZ2VXaWR0aCArIDE7XG4gICAgICBjb25zdCBibFkgPSB0clkgLSBERUZBVUxUX1BPUFVQX0hFSUdIVDtcbiAgICAgIGNvbnN0IHRyWCA9IGJsWCArIERFRkFVTFRfUE9QVVBfV0lEVEg7XG4gICAgICBzZXJpYWxpemVkLnBvcHVwID0ge1xuICAgICAgICBjb250ZW50czogdGhpcy5jb21tZW50LnRleHQsXG4gICAgICAgIGRlbGV0ZWQ6IHRoaXMuY29tbWVudC5kZWxldGVkLFxuICAgICAgICByZWN0OiBbYmxYLCBibFksIHRyWCwgdHJZXVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlRnJvbUFubm90YXRpb25MYXllcih7XG4gICAgcG9wdXA6IHtcbiAgICAgIGNvbnRlbnRzLFxuICAgICAgZGVsZXRlZFxuICAgIH1cbiAgfSkge1xuICAgIHRoaXMuI2NvbW1lbnQuZGF0YSA9IGRlbGV0ZWQgPyBudWxsIDogY29udGVudHM7XG4gIH1cbiAgZ2V0IHBhcmVudEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuYm91bmRpbmdDbGllbnRSZWN0O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBkaXYgPSB0aGlzLmRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtZWRpdG9yLXJvdGF0aW9uXCIsICgzNjAgLSB0aGlzLnJvdGF0aW9uKSAlIDM2MCk7XG4gICAgZGl2LmNsYXNzTmFtZSA9IHRoaXMubmFtZTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy5pZCk7XG4gICAgZGl2LnRhYkluZGV4ID0gdGhpcy4jZGlzYWJsZWQgPyAtMSA6IDA7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJhcHBsaWNhdGlvblwiKTtcbiAgICBpZiAodGhpcy5kZWZhdWx0TDEwbklkKSB7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIHRoaXMuZGVmYXVsdEwxMG5JZCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB9XG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcbiAgICB0aGlzLiNhZGRGb2N1c0xpc3RlbmVycygpO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBpZiAodGhpcy5wYXJlbnRSb3RhdGlvbiAlIDE4MCAhPT0gMCkge1xuICAgICAgZGl2LnN0eWxlLm1heFdpZHRoID0gYCR7KDEwMCAqIHBhcmVudEhlaWdodCAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgICAgZGl2LnN0eWxlLm1heEhlaWdodCA9IGAkeygxMDAgKiBwYXJlbnRXaWR0aCAvIHBhcmVudEhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLmdldEluaXRpYWxUcmFuc2xhdGlvbigpO1xuICAgIHRoaXMudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgYmluZEV2ZW50cyh0aGlzLCBkaXYsIFtcImtleWRvd25cIiwgXCJwb2ludGVyZG93blwiLCBcImRibGNsaWNrXCJdKTtcbiAgICBpZiAodGhpcy5pc1Jlc2l6YWJsZSAmJiB0aGlzLl91aU1hbmFnZXIuX3N1cHBvcnRzUGluY2hUb1pvb20pIHtcbiAgICAgIHRoaXMuI3RvdWNoTWFuYWdlciB8fD0gbmV3IFRvdWNoTWFuYWdlcih7XG4gICAgICAgIGNvbnRhaW5lcjogZGl2LFxuICAgICAgICBpc1BpbmNoaW5nRGlzYWJsZWQ6ICgpID0+ICF0aGlzLmlzU2VsZWN0ZWQsXG4gICAgICAgIG9uUGluY2hTdGFydDogdGhpcy4jdG91Y2hQaW5jaFN0YXJ0Q2FsbGJhY2suYmluZCh0aGlzKSxcbiAgICAgICAgb25QaW5jaGluZzogdGhpcy4jdG91Y2hQaW5jaENhbGxiYWNrLmJpbmQodGhpcyksXG4gICAgICAgIG9uUGluY2hFbmQ6IHRoaXMuI3RvdWNoUGluY2hFbmRDYWxsYmFjay5iaW5kKHRoaXMpLFxuICAgICAgICBzaWduYWw6IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5hZGRTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5fZWRpdG9yVW5kb0Jhcj8uaGlkZSgpO1xuICAgIHJldHVybiBkaXY7XG4gIH1cbiAgI3RvdWNoUGluY2hTdGFydENhbGxiYWNrKCkge1xuICAgIHRoaXMuI3NhdmVkRGltZW5zaW9ucyA9IHtcbiAgICAgIHNhdmVkWDogdGhpcy54LFxuICAgICAgc2F2ZWRZOiB0aGlzLnksXG4gICAgICBzYXZlZFdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgc2F2ZWRIZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGUoZmFsc2UpO1xuICAgIHRoaXMucGFyZW50LnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICB9XG4gICN0b3VjaFBpbmNoQ2FsbGJhY2soX29yaWdpbiwgcHJldkRpc3RhbmNlLCBkaXN0YW5jZSkge1xuICAgIGNvbnN0IHNsb3dEb3duRmFjdG9yID0gMC43O1xuICAgIGxldCBmYWN0b3IgPSBzbG93RG93bkZhY3RvciAqIChkaXN0YW5jZSAvIHByZXZEaXN0YW5jZSkgKyAxIC0gc2xvd0Rvd25GYWN0b3I7XG4gICAgaWYgKGZhY3RvciA9PT0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHRyYW5zZiA9ICh4LCB5KSA9PiBbcm90YXRpb25NYXRyaXhbMF0gKiB4ICsgcm90YXRpb25NYXRyaXhbMl0gKiB5LCByb3RhdGlvbk1hdHJpeFsxXSAqIHggKyByb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluV2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgbWluSGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudEhlaWdodDtcbiAgICBmYWN0b3IgPSBNYXRoLm1heChNYXRoLm1pbihmYWN0b3IsIDEgLyBzYXZlZFdpZHRoLCAxIC8gc2F2ZWRIZWlnaHQpLCBtaW5XaWR0aCAvIHNhdmVkV2lkdGgsIG1pbkhlaWdodCAvIHNhdmVkSGVpZ2h0KTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkV2lkdGggKiBmYWN0b3IpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkSGVpZ2h0ICogZmFjdG9yKTtcbiAgICBpZiAobmV3V2lkdGggPT09IHNhdmVkV2lkdGggJiYgbmV3SGVpZ2h0ID09PSBzYXZlZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNpbml0aWFsUmVjdCB8fD0gW3NhdmVkWCwgc2F2ZWRZLCBzYXZlZFdpZHRoLCBzYXZlZEhlaWdodF07XG4gICAgY29uc3QgdHJhbnNmQ2VudGVyUG9pbnQgPSB0cmFuc2Yoc2F2ZWRXaWR0aCAvIDIsIHNhdmVkSGVpZ2h0IC8gMik7XG4gICAgY29uc3QgY2VudGVyWCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkWCArIHRyYW5zZkNlbnRlclBvaW50WzBdKTtcbiAgICBjb25zdCBjZW50ZXJZID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRZICsgdHJhbnNmQ2VudGVyUG9pbnRbMV0pO1xuICAgIGNvbnN0IG5ld1RyYW5zZkNlbnRlclBvaW50ID0gdHJhbnNmKG5ld1dpZHRoIC8gMiwgbmV3SGVpZ2h0IC8gMik7XG4gICAgdGhpcy54ID0gY2VudGVyWCAtIG5ld1RyYW5zZkNlbnRlclBvaW50WzBdO1xuICAgIHRoaXMueSA9IGNlbnRlclkgLSBuZXdUcmFuc2ZDZW50ZXJQb2ludFsxXTtcbiAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1zKCk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIHRoaXMuX29uUmVzaXppbmcoKTtcbiAgfVxuICAjdG91Y2hQaW5jaEVuZENhbGxiYWNrKCkge1xuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZSh0cnVlKTtcbiAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgIHRoaXMuI2FkZFJlc2l6ZVRvVW5kb1N0YWNrKCk7XG4gIH1cbiAgcG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9pc0RyYWdnYWJsZSkge1xuICAgICAgdGhpcy4jc2V0VXBEcmFnU2Vzc2lvbihldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdE9uUG9pbnRlckV2ZW50KGV2ZW50KTtcbiAgfVxuICAjc2VsZWN0T25Qb2ludGVyRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5jdHJsS2V5ICYmICFpc01hYyB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5tZXRhS2V5ICYmIGlzTWFjKSB7XG4gICAgICB0aGlzLnBhcmVudC50b2dnbGVTZWxlY3RlZCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgfVxuICB9XG4gICNzZXRVcERyYWdTZXNzaW9uKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNTZWxlY3RlZFxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuX3VpTWFuYWdlci5zZXRVcERyYWdTZXNzaW9uKCk7XG4gICAgbGV0IGhhc0RyYWdnaW5nU3RhcnRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH07XG4gICAgY29uc3QgY2FuY2VsRHJhZyA9IGUgPT4ge1xuICAgICAgYWMuYWJvcnQoKTtcbiAgICAgIHRoaXMuI2RyYWdQb2ludGVySWQgPSBudWxsO1xuICAgICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLmVuZERyYWdTZXNzaW9uKCkpIHtcbiAgICAgICAgdGhpcy4jc2VsZWN0T25Qb2ludGVyRXZlbnQoZSk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzRHJhZ2dpbmdTdGFydGVkKSB7XG4gICAgICAgIHRoaXMuX29uU3RvcERyYWdnaW5nKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy4jcHJldkRyYWdYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIHRoaXMuI3ByZXZEcmFnWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICB0aGlzLiNkcmFnUG9pbnRlcklkID0gZXZlbnQucG9pbnRlcklkO1xuICAgICAgdGhpcy4jZHJhZ1BvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGUgPT4ge1xuICAgICAgICBpZiAoIWhhc0RyYWdnaW5nU3RhcnRlZCkge1xuICAgICAgICAgIGhhc0RyYWdnaW5nU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLnRvZ2dsZUNvbW1lbnQodGhpcywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgIHRoaXMuX29uU3RhcnREcmFnZ2luZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjbGllbnRYOiB4LFxuICAgICAgICAgIGNsaWVudFk6IHksXG4gICAgICAgICAgcG9pbnRlcklkXG4gICAgICAgIH0gPSBlO1xuICAgICAgICBpZiAocG9pbnRlcklkICE9PSB0aGlzLiNkcmFnUG9pbnRlcklkKSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCAtIHRoaXMuI3ByZXZEcmFnWCwgeSAtIHRoaXMuI3ByZXZEcmFnWSk7XG4gICAgICAgIHRoaXMuI3ByZXZEcmFnWCA9IHg7XG4gICAgICAgIHRoaXMuI3ByZXZEcmFnWSA9IHk7XG4gICAgICAgIHRoaXMuX3VpTWFuYWdlci5kcmFnU2VsZWN0ZWRFZGl0b3JzKHR4LCB0eSk7XG4gICAgICB9LCBvcHRzKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHN0b3BFdmVudCwgb3B0cyk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGUgPT4ge1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gdGhpcy4jZHJhZ1BvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuI3RvdWNoTWFuYWdlciB8fCBlLmlzUHJpbWFyeSkge1xuICAgICAgICAgICAgY2FuY2VsRHJhZyhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfSwgb3B0cyk7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ZXJVcENhbGxiYWNrID0gZSA9PiB7XG4gICAgICBpZiAoIXRoaXMuI2RyYWdQb2ludGVySWQgfHwgdGhpcy4jZHJhZ1BvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgY2FuY2VsRHJhZyhlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RvcEV2ZW50KGUpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgX29uU3RhcnREcmFnZ2luZygpIHt9XG4gIF9vblN0b3BEcmFnZ2luZygpIHt9XG4gIG1vdmVJbkRPTSgpIHtcbiAgICBpZiAodGhpcy4jbW92ZUluRE9NVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpO1xuICAgIH1cbiAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMucGFyZW50Py5tb3ZlRWRpdG9ySW5ET00odGhpcyk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX3NldFBhcmVudEFuZFBvc2l0aW9uKHBhcmVudCwgeCwgeSkge1xuICAgIHBhcmVudC5jaGFuZ2VQYXJlbnQodGhpcyk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblRyYW5zbGF0ZWQoKTtcbiAgfVxuICBnZXRSZWN0KHR4LCB0eSwgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IHNoaWZ0WCA9IHR4IC8gc2NhbGU7XG4gICAgY29uc3Qgc2hpZnRZID0gdHkgLyBzY2FsZTtcbiAgICBjb25zdCB4ID0gdGhpcy54ICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IHkgPSB0aGlzLnkgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3ggKyBzaGlmdFggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFkgLSBoZWlnaHQgKyBwYWdlWSwgeCArIHNoaWZ0WCArIHdpZHRoICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRZICsgcGFnZVldO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt4ICsgc2hpZnRZICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRYICsgcGFnZVksIHggKyBzaGlmdFkgKyBoZWlnaHQgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFggKyB3aWR0aCArIHBhZ2VZXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3ggLSBzaGlmdFggLSB3aWR0aCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WSArIHBhZ2VZLCB4IC0gc2hpZnRYICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRZICsgaGVpZ2h0ICsgcGFnZVldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeCAtIHNoaWZ0WSAtIGhlaWdodCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WCAtIHdpZHRoICsgcGFnZVksIHggLSBzaGlmdFkgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFggKyBwYWdlWV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBnZXRSZWN0SW5DdXJyZW50Q29vcmRzKHJlY3QsIHBhZ2VIZWlnaHQpIHtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gcmVjdDtcbiAgICBjb25zdCB3aWR0aCA9IHgyIC0geDE7XG4gICAgY29uc3QgaGVpZ2h0ID0geTIgLSB5MTtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFt4MSwgcGFnZUhlaWdodCAtIHkyLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeDEsIHBhZ2VIZWlnaHQgLSB5MSwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4MiwgcGFnZUhlaWdodCAtIHkxLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3gyLCBwYWdlSGVpZ2h0IC0geTIsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0UERGUmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZWN0KDAsIDApO1xuICB9XG4gIGdldE5vbkhDTUNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yICYmIEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuX3VpTWFuYWdlci5nZXROb25IQ01Db2xvcih0aGlzLmNvbG9yKSk7XG4gIH1cbiAgb25VcGRhdGVkQ29sb3IoKSB7XG4gICAgdGhpcy4jY29tbWVudD8ub25VcGRhdGVkQ29sb3IoKTtcbiAgfVxuICBnZXREYXRhKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgdGV4dDogc3RyLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgZGF0ZSxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgZGVsZXRlZCxcbiAgICAgICAgcmljaFRleHRcbiAgICAgIH0sXG4gICAgICB1aWQ6IGlkLFxuICAgICAgcGFnZUluZGV4LFxuICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgbW9kaWZpY2F0aW9uRGF0ZVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpLFxuICAgICAgcmljaFRleHQsXG4gICAgICBjb250ZW50c09iajoge1xuICAgICAgICBzdHJcbiAgICAgIH0sXG4gICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICBtb2RpZmljYXRpb25EYXRlOiBkYXRlIHx8IG1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICBwb3B1cFJlZjogIWRlbGV0ZWQsXG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHlcbiAgICB9O1xuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge31cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKGZhbHNlKTtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIHRoaXMuI2lzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlzSW5FZGl0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNJbkVkaXRNb2RlO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQ7XG4gIH1cbiAgbmVlZHNUb0JlUmVidWlsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYgJiYgIXRoaXMuaXNBdHRhY2hlZFRvRE9NO1xuICB9XG4gIGdldCBpc09uU2NyZWVuKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICBib3R0b20sXG4gICAgICByaWdodFxuICAgIH0gPSB0aGlzLmdldENsaWVudERpbWVuc2lvbnMoKTtcbiAgICBjb25zdCB7XG4gICAgICBpbm5lckhlaWdodCxcbiAgICAgIGlubmVyV2lkdGhcbiAgICB9ID0gd2luZG93O1xuICAgIHJldHVybiBsZWZ0IDwgaW5uZXJXaWR0aCAmJiByaWdodCA+IDAgJiYgdG9wIDwgaW5uZXJIZWlnaHQgJiYgYm90dG9tID4gMDtcbiAgfVxuICAjYWRkRm9jdXNMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI2ZvY3VzQUMgfHwgIXRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2ZvY3VzQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2ZvY3VzQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuZm9jdXNpbi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy5mb2N1c291dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIHRoaXMuI2FkZEZvY3VzTGlzdGVuZXJzKCk7XG4gIH1cbiAgcm90YXRlKF9hbmdsZSkge31cbiAgcmVzaXplKCkge31cbiAgc2VyaWFsaXplRGVsZXRlZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgIGRlbGV0ZWQ6IHRydWUsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcG9wdXBSZWY6IHRoaXMuX2luaXRpYWxEYXRhPy5wb3B1cFJlZiB8fCBcIlwiXG4gICAgfTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFubm90YXRpb25UeXBlOiB0aGlzLm1vZGUsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdDogdGhpcy5nZXRQREZSZWN0KCksXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkLFxuICAgICAgcG9wdXBSZWY6IHRoaXMuX2luaXRpYWxEYXRhPy5wb3B1cFJlZiB8fCBcIlwiXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBuZXcgdGhpcy5wcm90b3R5cGUuY29uc3RydWN0b3Ioe1xuICAgICAgcGFyZW50LFxuICAgICAgaWQ6IHBhcmVudC5nZXROZXh0SWQoKSxcbiAgICAgIHVpTWFuYWdlcixcbiAgICAgIGFubm90YXRpb25FbGVtZW50SWQ6IGRhdGEuYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgIGNyZWF0aW9uRGF0ZTogZGF0YS5jcmVhdGlvbkRhdGUsXG4gICAgICBtb2RpZmljYXRpb25EYXRlOiBkYXRhLm1vZGlmaWNhdGlvbkRhdGVcbiAgICB9KTtcbiAgICBlZGl0b3Iucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xuICAgIGVkaXRvci4jYWNjZXNzaWJpbGl0eURhdGEgPSBkYXRhLmFjY2Vzc2liaWxpdHlEYXRhO1xuICAgIGVkaXRvci5faXNDb3B5ID0gZGF0YS5pc0NvcHkgfHwgZmFsc2U7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gZWRpdG9yLmdldFJlY3RJbkN1cnJlbnRDb29yZHMoZGF0YS5yZWN0LCBwYWdlSGVpZ2h0KTtcbiAgICBlZGl0b3IueCA9IHggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLnkgPSB5IC8gcGFnZUhlaWdodDtcbiAgICBlZGl0b3Iud2lkdGggPSB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICBlZGl0b3IuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIGdldCBoYXNCZWVuTW9kaWZpZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICh0aGlzLmRlbGV0ZWQgfHwgdGhpcy5zZXJpYWxpemUoKSAhPT0gbnVsbCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuI2ZvY3VzQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jZm9jdXNBQyA9IG51bGw7XG4gICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVFZGl0b3IodGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jbW92ZUluRE9NVGltZW91dCk7XG4gICAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgdGhpcy5yZW1vdmVFZGl0VG9vbGJhcigpO1xuICAgIGlmICh0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cykge1xuICAgICAgZm9yIChjb25zdCB0aW1lb3V0IG9mIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLnZhbHVlcygpKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuI3RvdWNoTWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI3RvdWNoTWFuYWdlciA9IG51bGw7XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYWtlUmVzaXphYmxlKCkge1xuICAgIGlmICh0aGlzLmlzUmVzaXphYmxlKSB7XG4gICAgICB0aGlzLiNjcmVhdGVSZXNpemVycygpO1xuICAgICAgdGhpcy4jcmVzaXplcnNEaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRvb2xiYXJQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIuZGlyZWN0aW9uID09PSBcImx0clwiID8gWzEsIDBdIDogWzAsIDBdO1xuICB9XG4gIGdldCBjb21tZW50QnV0dG9uUG9zaXRpb25JblBhZ2UoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudEJ1dHRvblBvc2l0aW9uOiBbcG9zWCwgcG9zWV1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBbYmxYLCBibFksIHRyWCwgdHJZXSA9IHRoaXMuZ2V0UERGUmVjdCgpO1xuICAgIHJldHVybiBbQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoYmxYICsgKHRyWCAtIGJsWCkgKiBwb3NYKSwgQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoYmxZICsgKHRyWSAtIGJsWSkgKiAoMSAtIHBvc1kpKV07XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Db2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLm1ha2VDb21tZW50Q29sb3IodGhpcy5nZXROb25IQ01Db2xvcigpLCB0aGlzLm9wYWNpdHkpO1xuICB9XG4gIGdldCBjb21tZW50UG9wdXBQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jY29tbWVudC5jb21tZW50UG9wdXBQb3NpdGlvbkluTGF5ZXI7XG4gIH1cbiAgc2V0IGNvbW1lbnRQb3B1cFBvc2l0aW9uKHBvcykge1xuICAgIHRoaXMuI2NvbW1lbnQuY29tbWVudFBvcHVwUG9zaXRpb25JbkxheWVyID0gcG9zO1xuICB9XG4gIGhhc0RlZmF1bHRQb3B1cFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50Lmhhc0RlZmF1bHRQb3B1cFBvc2l0aW9uKCk7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25XaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29tbWVudC5jb21tZW50QnV0dG9uV2lkdGg7XG4gIH1cbiAgZ2V0IGVsZW1lbnRCZWZvcmVQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgc2V0Q29tbWVudEJ1dHRvblN0YXRlcyhvcHRpb25zKSB7XG4gICAgdGhpcy4jY29tbWVudC5zZXRDb21tZW50QnV0dG9uU3RhdGVzKG9wdGlvbnMpO1xuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNSZXNpemFibGUgfHwgZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdiB8fCBldmVudC5rZXkgIT09IFwiRW50ZXJcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl91aU1hbmFnZXIuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgdGhpcy4jc2F2ZWREaW1lbnNpb25zID0ge1xuICAgICAgc2F2ZWRYOiB0aGlzLngsXG4gICAgICBzYXZlZFk6IHRoaXMueSxcbiAgICAgIHNhdmVkV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBzYXZlZEhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy4jcmVzaXplcnNEaXYuY2hpbGRyZW47XG4gICAgaWYgKCF0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgdGhpcy4jYWxsUmVzaXplckRpdnMgPSBBcnJheS5mcm9tKGNoaWxkcmVuKTtcbiAgICAgIGNvbnN0IGJvdW5kUmVzaXplcktleWRvd24gPSB0aGlzLiNyZXNpemVyS2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgICAgY29uc3QgYm91bmRSZXNpemVyQmx1ciA9IHRoaXMuI3Jlc2l6ZXJCbHVyLmJpbmQodGhpcyk7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICAgIGZvciAoY29uc3QgZGl2IG9mIHRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBkaXYuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZXNpemVyLW5hbWVcIik7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic3BpbmJ1dHRvblwiKTtcbiAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGJvdW5kUmVzaXplcktleWRvd24sIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBib3VuZFJlc2l6ZXJCbHVyLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuI3Jlc2l6ZXJGb2N1cy5iaW5kKHRoaXMsIG5hbWUpLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFubm90YXRpb25FZGl0b3IuX2wxMG5SZXNpemVyW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLiNhbGxSZXNpemVyRGl2c1swXTtcbiAgICBsZXQgZmlyc3RQb3NpdGlvbiA9IDA7XG4gICAgZm9yIChjb25zdCBkaXYgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChkaXYgPT09IGZpcnN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZmlyc3RQb3NpdGlvbisrO1xuICAgIH1cbiAgICBjb25zdCBuZXh0Rmlyc3RQb3NpdGlvbiA9ICgzNjAgLSB0aGlzLnJvdGF0aW9uICsgdGhpcy5wYXJlbnRSb3RhdGlvbikgJSAzNjAgLyA5MCAqICh0aGlzLiNhbGxSZXNpemVyRGl2cy5sZW5ndGggLyA0KTtcbiAgICBpZiAobmV4dEZpcnN0UG9zaXRpb24gIT09IGZpcnN0UG9zaXRpb24pIHtcbiAgICAgIGlmIChuZXh0Rmlyc3RQb3NpdGlvbiA8IGZpcnN0UG9zaXRpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaXJzdFBvc2l0aW9uIC0gbmV4dEZpcnN0UG9zaXRpb247IGkrKykge1xuICAgICAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmFwcGVuZCh0aGlzLiNyZXNpemVyc0Rpdi5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXh0Rmlyc3RQb3NpdGlvbiA+IGZpcnN0UG9zaXRpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0Rmlyc3RQb3NpdGlvbiAtIGZpcnN0UG9zaXRpb247IGkrKykge1xuICAgICAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmZpcnN0Q2hpbGQuYmVmb3JlKHRoaXMuI3Jlc2l6ZXJzRGl2Lmxhc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgZGl2ID0gdGhpcy4jYWxsUmVzaXplckRpdnNbaSsrXTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGRpdi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiKTtcbiAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFubm90YXRpb25FZGl0b3IuX2wxMG5SZXNpemVyW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2V0UmVzaXplclRhYkluZGV4KDApO1xuICAgIHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA9IHRydWU7XG4gICAgdGhpcy4jcmVzaXplcnNEaXYuZmlyc3RDaGlsZC5mb2N1cyh7XG4gICAgICBmb2N1c1Zpc2libGU6IHRydWVcbiAgICB9KTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICB9XG4gICNyZXNpemVyS2V5ZG93bihldmVudCkge1xuICAgIEFubm90YXRpb25FZGl0b3IuX3Jlc2l6ZXJLZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgI3Jlc2l6ZXJCbHVyKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCAmJiBldmVudC5yZWxhdGVkVGFyZ2V0Py5wYXJlbnROb2RlICE9PSB0aGlzLiNyZXNpemVyc0Rpdikge1xuICAgICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgfVxuICB9XG4gICNyZXNpemVyRm9jdXMobmFtZSkge1xuICAgIHRoaXMuI2ZvY3VzZWRSZXNpemVyTmFtZSA9IHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA/IG5hbWUgOiBcIlwiO1xuICB9XG4gICNzZXRSZXNpemVyVGFiSW5kZXgodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZGl2IG9mIHRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICBkaXYudGFiSW5kZXggPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgX3Jlc2l6ZVdpdGhLZXlib2FyZCh4LCB5KSB7XG4gICAgaWYgKCF0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcmVzaXplclBvaW50ZXJtb3ZlKHRoaXMuI2ZvY3VzZWRSZXNpemVyTmFtZSwge1xuICAgICAgZGVsdGFYOiB4LFxuICAgICAgZGVsdGFZOiB5LFxuICAgICAgZnJvbUtleWJvYXJkOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI3N0b3BSZXNpemluZygpIHtcbiAgICB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPSBmYWxzZTtcbiAgICB0aGlzLiNzZXRSZXNpemVyVGFiSW5kZXgoLTEpO1xuICAgIHRoaXMuI2FkZFJlc2l6ZVRvVW5kb1N0YWNrKCk7XG4gIH1cbiAgX3N0b3BSZXNpemluZ1dpdGhLZXlib2FyZCgpIHtcbiAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIHNlbGVjdCgpIHtcbiAgICBpZiAodGhpcy5pc1NlbGVjdGVkICYmIHRoaXMuX2VkaXRUb29sYmFyKSB7XG4gICAgICB0aGlzLl9lZGl0VG9vbGJhci5zaG93KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgdGhpcy5tYWtlUmVzaXphYmxlKCk7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICBpZiAoIXRoaXMuX2VkaXRUb29sYmFyKSB7XG4gICAgICB0aGlzLmFkZEVkaXRUb29sYmFyKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmRpdj8uY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VsZWN0ZWRFZGl0b3JcIikpIHtcbiAgICAgICAgICB0aGlzLl9lZGl0VG9vbGJhcj8uc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXI/LnNob3coKTtcbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGVBbHRUZXh0QmFkZ2UoZmFsc2UpO1xuICB9XG4gIGZvY3VzKCkge1xuICAgIGlmICh0aGlzLmRpdiAmJiAhdGhpcy5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kaXY/LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSksIDApO1xuICAgIH1cbiAgfVxuICB1bnNlbGVjdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdj8uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIGlmICh0aGlzLmRpdj8uY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5jdXJyZW50TGF5ZXIuZGl2LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyPy5oaWRlKCk7XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlQWx0VGV4dEJhZGdlKHRydWUpO1xuICAgIGlmICh0aGlzLmhhc0NvbW1lbnQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci50b2dnbGVDb21tZW50KHRoaXMsIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge31cbiAgZGlzYWJsZUVkaXRpbmcoKSB7fVxuICBlbmFibGVFZGl0aW5nKCkge31cbiAgZ2V0IGNhbkNoYW5nZUNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVudGVySW5FZGl0TW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuY2FuQ2hhbmdlQ29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfVxuICBkYmxjbGljayhldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQubm9kZU5hbWUgPT09IFwiQlVUVE9OXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbnRlckluRWRpdE1vZGUoKTtcbiAgICB0aGlzLnBhcmVudC51cGRhdGVUb29sYmFyKHtcbiAgICAgIG1vZGU6IHRoaXMuY29uc3RydWN0b3IuX2VkaXRvclR5cGUsXG4gICAgICBlZGl0SWQ6IHRoaXMuaWRcbiAgICB9KTtcbiAgfVxuICBnZXRFbGVtZW50Rm9yQWx0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgZ2V0IGNvbnRlbnREaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIGdldCBpc0VkaXRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzRWRpdGluZztcbiAgfVxuICBzZXQgaXNFZGl0aW5nKHZhbHVlKSB7XG4gICAgdGhpcy4jaXNFZGl0aW5nID0gdmFsdWU7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgdGhpcy5wYXJlbnQuc2V0QWN0aXZlRWRpdG9yKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRBY3RpdmVFZGl0b3IobnVsbCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgTUlOX1NJWkUoKSB7XG4gICAgcmV0dXJuIDE2O1xuICB9XG4gIHN0YXRpYyBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgdGVsZW1ldHJ5SW5pdGlhbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogXCJhZGRlZFwiXG4gICAgfTtcbiAgfVxuICBnZXQgdGVsZW1ldHJ5RmluYWxEYXRhKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9yZXBvcnRUZWxlbWV0cnkoZGF0YSwgbXVzdFdhaXQgPSBmYWxzZSkge1xuICAgIGlmIChtdXN0V2FpdCkge1xuICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMgfHw9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aW9uXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGxldCB0aW1lb3V0ID0gdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuZ2V0KGFjdGlvbik7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeShkYXRhKTtcbiAgICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuZGVsZXRlKGFjdGlvbik7XG4gICAgICAgIGlmICh0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LCBBbm5vdGF0aW9uRWRpdG9yLl90ZWxlbWV0cnlUaW1lb3V0KTtcbiAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLnNldChhY3Rpb24sIHRpbWVvdXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhLnR5cGUgfHw9IHRoaXMuZWRpdG9yVHlwZTtcbiAgICB0aGlzLl91aU1hbmFnZXIuX2V2ZW50QnVzLmRpc3BhdGNoKFwicmVwb3J0dGVsZW1ldHJ5XCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgdHlwZTogXCJlZGl0aW5nXCIsXG4gICAgICAgIGRhdGFcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzaG93KHZpc2libGUgPSB0aGlzLl9pc1Zpc2libGUpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsICF2aXNpYmxlKTtcbiAgICB0aGlzLl9pc1Zpc2libGUgPSB2aXNpYmxlO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gMDtcbiAgICB9XG4gICAgdGhpcy4jZGlzYWJsZWQgPSBmYWxzZTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5kaXYudGFiSW5kZXggPSAtMTtcbiAgICB9XG4gICAgdGhpcy4jZGlzYWJsZWQgPSB0cnVlO1xuICB9XG4gIHVwZGF0ZUZha2VBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uTGF5ZXIpIHtcbiAgICBpZiAoIXRoaXMuI2Zha2VBbm5vdGF0aW9uICYmICF0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHRoaXMuI2Zha2VBbm5vdGF0aW9uID0gYW5ub3RhdGlvbkxheWVyLmFkZEZha2VBbm5vdGF0aW9uKHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICB0aGlzLiNmYWtlQW5ub3RhdGlvbi5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI2Zha2VBbm5vdGF0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzRWRpdGVkQ29tbWVudCB8fCB0aGlzLl9oYXNCZWVuTW92ZWQgfHwgdGhpcy5faGFzQmVlblJlc2l6ZWQpIHtcbiAgICAgIHRoaXMuI2Zha2VBbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpLFxuICAgICAgICBwb3B1cDogdGhpcy5jb21tZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGFubm90YXRpb24uaGlkZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBjb250ZW50ID0gYW5ub3RhdGlvbi5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5hbm5vdGF0aW9uQ29udGVudFwiKTtcbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvbkNvbnRlbnRcIiwgdGhpcy5lZGl0b3JUeXBlKTtcbiAgICAgIGFubm90YXRpb24uY29udGFpbmVyLnByZXBlbmQoY29udGVudCk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjb250ZW50O1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uQ29udGVudFwiLCB0aGlzLmVkaXRvclR5cGUpO1xuICAgICAgY2FudmFzLmJlZm9yZShjb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgcmVzZXRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgZmlyc3RDaGlsZFxuICAgIH0gPSBhbm5vdGF0aW9uLmNvbnRhaW5lcjtcbiAgICBpZiAoZmlyc3RDaGlsZD8ubm9kZU5hbWUgPT09IFwiRElWXCIgJiYgZmlyc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoXCJhbm5vdGF0aW9uQ29udGVudFwiKSkge1xuICAgICAgZmlyc3RDaGlsZC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEZha2VFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBwYXJhbXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICB0aGlzLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9tdXJtdXJoYXNoMy5qc1xuXG5cblxuXG5cblxuXG5cbmNvbnN0IFNFRUQgPSAweGMzZDJlMWYwO1xuY29uc3QgTUFTS19ISUdIID0gMHhmZmZmMDAwMDtcbmNvbnN0IE1BU0tfTE9XID0gMHhmZmZmO1xuY2xhc3MgTXVybXVySGFzaDNfNjQge1xuICBjb25zdHJ1Y3RvcihzZWVkKSB7XG4gICAgdGhpcy5oMSA9IHNlZWQgPyBzZWVkICYgMHhmZmZmZmZmZiA6IFNFRUQ7XG4gICAgdGhpcy5oMiA9IHNlZWQgPyBzZWVkICYgMHhmZmZmZmZmZiA6IFNFRUQ7XG4gIH1cbiAgdXBkYXRlKGlucHV0KSB7XG4gICAgbGV0IGRhdGEsIGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoICogMik7XG4gICAgICBsZW5ndGggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPD0gMHhmZikge1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGUgPj4+IDg7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGlucHV0KSkge1xuICAgICAgZGF0YSA9IGlucHV0LnNsaWNlKCk7XG4gICAgICBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSBmb3JtYXQsIG11c3QgYmUgYSBzdHJpbmcgb3IgVHlwZWRBcnJheS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrQ291bnRzID0gbGVuZ3RoID4+IDI7XG4gICAgY29uc3QgdGFpbExlbmd0aCA9IGxlbmd0aCAtIGJsb2NrQ291bnRzICogNDtcbiAgICBjb25zdCBkYXRhVWludDMyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEuYnVmZmVyLCAwLCBibG9ja0NvdW50cyk7XG4gICAgbGV0IGsxID0gMCxcbiAgICAgIGsyID0gMDtcbiAgICBsZXQgaDEgPSB0aGlzLmgxLFxuICAgICAgaDIgPSB0aGlzLmgyO1xuICAgIGNvbnN0IEMxID0gMHhjYzllMmQ1MSxcbiAgICAgIEMyID0gMHgxYjg3MzU5MztcbiAgICBjb25zdCBDMV9MT1cgPSBDMSAmIE1BU0tfTE9XLFxuICAgICAgQzJfTE9XID0gQzIgJiBNQVNLX0xPVztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrQ291bnRzOyBpKyspIHtcbiAgICAgIGlmIChpICYgMSkge1xuICAgICAgICBrMSA9IGRhdGFVaW50MzJbaV07XG4gICAgICAgIGsxID0gazEgKiBDMSAmIE1BU0tfSElHSCB8IGsxICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgICAgIGsxID0gazEgKiBDMiAmIE1BU0tfSElHSCB8IGsxICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGgxIF49IGsxO1xuICAgICAgICBoMSA9IGgxIDw8IDEzIHwgaDEgPj4+IDE5O1xuICAgICAgICBoMSA9IGgxICogNSArIDB4ZTY1NDZiNjQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrMiA9IGRhdGFVaW50MzJbaV07XG4gICAgICAgIGsyID0gazIgKiBDMSAmIE1BU0tfSElHSCB8IGsyICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsyID0gazIgPDwgMTUgfCBrMiA+Pj4gMTc7XG4gICAgICAgIGsyID0gazIgKiBDMiAmIE1BU0tfSElHSCB8IGsyICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGgyIF49IGsyO1xuICAgICAgICBoMiA9IGgyIDw8IDEzIHwgaDIgPj4+IDE5O1xuICAgICAgICBoMiA9IGgyICogNSArIDB4ZTY1NDZiNjQ7XG4gICAgICB9XG4gICAgfVxuICAgIGsxID0gMDtcbiAgICBzd2l0Y2ggKHRhaWxMZW5ndGgpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDQgKyAyXSA8PCAxNjtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDQgKyAxXSA8PCA4O1xuICAgICAgY2FzZSAxOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNF07XG4gICAgICAgIGsxID0gazEgKiBDMSAmIE1BU0tfSElHSCB8IGsxICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgICAgIGsxID0gazEgKiBDMiAmIE1BU0tfSElHSCB8IGsxICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGlmIChibG9ja0NvdW50cyAmIDEpIHtcbiAgICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoMiBePSBrMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmgxID0gaDE7XG4gICAgdGhpcy5oMiA9IGgyO1xuICB9XG4gIGhleGRpZ2VzdCgpIHtcbiAgICBsZXQgaDEgPSB0aGlzLmgxLFxuICAgICAgaDIgPSB0aGlzLmgyO1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGgxID0gaDEgKiAweGVkNTU4Y2NkICYgTUFTS19ISUdIIHwgaDEgKiAweDhjY2QgJiBNQVNLX0xPVztcbiAgICBoMiA9IGgyICogMHhmZjUxYWZkNyAmIE1BU0tfSElHSCB8ICgoaDIgPDwgMTYgfCBoMSA+Pj4gMTYpICogMHhhZmQ3ZWQ1NSAmIE1BU0tfSElHSCkgPj4+IDE2O1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGgxID0gaDEgKiAweDFhODVlYzUzICYgTUFTS19ISUdIIHwgaDEgKiAweGVjNTMgJiBNQVNLX0xPVztcbiAgICBoMiA9IGgyICogMHhjNGNlYjlmZSAmIE1BU0tfSElHSCB8ICgoaDIgPDwgMTYgfCBoMSA+Pj4gMTYpICogMHhiOWZlMWE4NSAmIE1BU0tfSElHSCkgPj4+IDE2O1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIHJldHVybiAoaDEgPj4+IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIikgKyAoaDIgPj4+IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvYW5ub3RhdGlvbl9zdG9yYWdlLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgU2VyaWFsaXphYmxlRW1wdHkgPSBPYmplY3QuZnJlZXplKHtcbiAgbWFwOiBudWxsLFxuICBoYXNoOiBcIlwiLFxuICB0cmFuc2ZlcjogdW5kZWZpbmVkXG59KTtcbmNsYXNzIEFubm90YXRpb25TdG9yYWdlIHtcbiAgI21vZGlmaWVkID0gZmFsc2U7XG4gICNtb2RpZmllZElkcyA9IG51bGw7XG4gICNlZGl0b3JzTWFwID0gbnVsbDtcbiAgI3N0b3JhZ2UgPSBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMub25TZXRNb2RpZmllZCA9IG51bGw7XG4gICAgdGhpcy5vblJlc2V0TW9kaWZpZWQgPSBudWxsO1xuICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID0gbnVsbDtcbiAgfVxuICBnZXRWYWx1ZShrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVmYXVsdFZhbHVlLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0UmF3VmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gIH1cbiAgcmVtb3ZlKGtleSkge1xuICAgIGNvbnN0IHN0b3JlZFZhbHVlID0gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgICBpZiAoc3RvcmVkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RvcmVkVmFsdWUgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yKSB7XG4gICAgICB0aGlzLiNlZGl0b3JzTWFwLmRlbGV0ZShzdG9yZWRWYWx1ZS5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICB9XG4gICAgdGhpcy4jc3RvcmFnZS5kZWxldGUoa2V5KTtcbiAgICBpZiAodGhpcy4jc3RvcmFnZS5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI3N0b3JhZ2UudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IobnVsbCk7XG4gICAgfVxuICB9XG4gIHNldFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICAgIGxldCBtb2RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChjb25zdCBbZW50cnksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIGlmIChvYmpbZW50cnldICE9PSB2YWwpIHtcbiAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgb2JqW2VudHJ5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICB0aGlzLiNzdG9yYWdlLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yKSB7XG4gICAgICAodGhpcy4jZWRpdG9yc01hcCB8fD0gbmV3IE1hcCgpKS5zZXQodmFsdWUuYW5ub3RhdGlvbkVsZW1lbnRJZCwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yKHZhbHVlLmNvbnN0cnVjdG9yLl90eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmhhcyhrZXkpO1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLnNpemU7XG4gIH1cbiAgI3NldE1vZGlmaWVkKCkge1xuICAgIGlmICghdGhpcy4jbW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI21vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblNldE1vZGlmaWVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vblNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc2V0TW9kaWZpZWQoKSB7XG4gICAgaWYgKHRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uUmVzZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25SZXNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBwcmludCgpIHtcbiAgICByZXR1cm4gbmV3IFByaW50QW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICBpZiAodGhpcy4jc3RvcmFnZS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gU2VyaWFsaXphYmxlRW1wdHk7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKSxcbiAgICAgIGhhc2ggPSBuZXcgTXVybXVySGFzaDNfNjQoKSxcbiAgICAgIHRyYW5zZmVyID0gW107XG4gICAgY29uc3QgY29udGV4dCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGhhc0JpdG1hcCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzLiNzdG9yYWdlKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gdmFsIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvciA/IHZhbC5zZXJpYWxpemUoZmFsc2UsIGNvbnRleHQpIDogdmFsO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgbWFwLnNldChrZXksIHNlcmlhbGl6ZWQpO1xuICAgICAgICBoYXNoLnVwZGF0ZShgJHtrZXl9OiR7SlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplZCl9YCk7XG4gICAgICAgIGhhc0JpdG1hcCB8fD0gISFzZXJpYWxpemVkLmJpdG1hcDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0JpdG1hcCkge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBtYXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmJpdG1hcCkge1xuICAgICAgICAgIHRyYW5zZmVyLnB1c2godmFsdWUuYml0bWFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwLnNpemUgPiAwID8ge1xuICAgICAgbWFwLFxuICAgICAgaGFzaDogaGFzaC5oZXhkaWdlc3QoKSxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA6IFNlcmlhbGl6YWJsZUVtcHR5O1xuICB9XG4gIGdldCBlZGl0b3JTdGF0cygpIHtcbiAgICBsZXQgc3RhdHMgPSBudWxsO1xuICAgIGNvbnN0IHR5cGVUb0VkaXRvciA9IG5ldyBNYXAoKTtcbiAgICBsZXQgbnVtYmVyT2ZFZGl0ZWRDb21tZW50cyA9IDA7XG4gICAgbGV0IG51bWJlck9mRGVsZXRlZENvbW1lbnRzID0gMDtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI3N0b3JhZ2UudmFsdWVzKCkpIHtcbiAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikpIHtcbiAgICAgICAgaWYgKHZhbHVlLnBvcHVwKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLnBvcHVwLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIG51bWJlck9mRGVsZXRlZENvbW1lbnRzICs9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG51bWJlck9mRWRpdGVkQ29tbWVudHMgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUuaXNDb21tZW50RGVsZXRlZCkge1xuICAgICAgICBudW1iZXJPZkRlbGV0ZWRDb21tZW50cyArPSAxO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5oYXNFZGl0ZWRDb21tZW50KSB7XG4gICAgICAgIG51bWJlck9mRWRpdGVkQ29tbWVudHMgKz0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkaXRvclN0YXRzID0gdmFsdWUudGVsZW1ldHJ5RmluYWxEYXRhO1xuICAgICAgaWYgKCFlZGl0b3JTdGF0cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IGVkaXRvclN0YXRzO1xuICAgICAgaWYgKCF0eXBlVG9FZGl0b3IuaGFzKHR5cGUpKSB7XG4gICAgICAgIHR5cGVUb0VkaXRvci5zZXQodHlwZSwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKS5jb25zdHJ1Y3Rvcik7XG4gICAgICB9XG4gICAgICBzdGF0cyB8fD0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGNvbnN0IG1hcCA9IHN0YXRzW3R5cGVdIHx8PSBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMoZWRpdG9yU3RhdHMpKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ZXJzID0gbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWNvdW50ZXJzKSB7XG4gICAgICAgICAgY291bnRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgbWFwLnNldChrZXksIGNvdW50ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb3VudCA9IGNvdW50ZXJzLmdldCh2YWwpID8/IDA7XG4gICAgICAgIGNvdW50ZXJzLnNldCh2YWwsIGNvdW50ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudW1iZXJPZkRlbGV0ZWRDb21tZW50cyA+IDAgfHwgbnVtYmVyT2ZFZGl0ZWRDb21tZW50cyA+IDApIHtcbiAgICAgIHN0YXRzIHx8PSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgc3RhdHMuY29tbWVudHMgPSB7XG4gICAgICAgIGRlbGV0ZWQ6IG51bWJlck9mRGVsZXRlZENvbW1lbnRzLFxuICAgICAgICBlZGl0ZWQ6IG51bWJlck9mRWRpdGVkQ29tbWVudHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghc3RhdHMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBlZGl0b3JdIG9mIHR5cGVUb0VkaXRvcikge1xuICAgICAgc3RhdHNbdHlwZV0gPSBlZGl0b3IuY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShzdGF0c1t0eXBlXSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0cztcbiAgfVxuICByZXNldE1vZGlmaWVkSWRzKCkge1xuICAgIHRoaXMuI21vZGlmaWVkSWRzID0gbnVsbDtcbiAgfVxuICB1cGRhdGVFZGl0b3IoYW5ub3RhdGlvbklkLCBkYXRhKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNlZGl0b3JzTWFwPy5nZXQoYW5ub3RhdGlvbklkKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHZhbHVlLnVwZGF0ZUZyb21Bbm5vdGF0aW9uTGF5ZXIoZGF0YSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldEVkaXRvcihhbm5vdGF0aW9uSWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdG9yc01hcD8uZ2V0KGFubm90YXRpb25JZCkgfHwgbnVsbDtcbiAgfVxuICBnZXQgbW9kaWZpZWRJZHMoKSB7XG4gICAgaWYgKHRoaXMuI21vZGlmaWVkSWRzKSB7XG4gICAgICByZXR1cm4gdGhpcy4jbW9kaWZpZWRJZHM7XG4gICAgfVxuICAgIGNvbnN0IGlkcyA9IFtdO1xuICAgIGlmICh0aGlzLiNlZGl0b3JzTWFwKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI2VkaXRvcnNNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKCF2YWx1ZS5zZXJpYWxpemUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlkcy5wdXNoKHZhbHVlLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jbW9kaWZpZWRJZHMgPSB7XG4gICAgICBpZHM6IG5ldyBTZXQoaWRzKSxcbiAgICAgIGhhc2g6IGlkcy5qb2luKFwiLFwiKVxuICAgIH07XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2UuZW50cmllcygpO1xuICB9XG59XG5jbGFzcyBQcmludEFubm90YXRpb25TdG9yYWdlIGV4dGVuZHMgQW5ub3RhdGlvblN0b3JhZ2Uge1xuICAjc2VyaWFsaXphYmxlO1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlclxuICAgIH0gPSBwYXJlbnQuc2VyaWFsaXphYmxlO1xuICAgIGNvbnN0IGNsb25lID0gc3RydWN0dXJlZENsb25lKG1hcCwgdHJhbnNmZXIgPyB7XG4gICAgICB0cmFuc2ZlclxuICAgIH0gOiBudWxsKTtcbiAgICB0aGlzLiNzZXJpYWxpemFibGUgPSB7XG4gICAgICBtYXA6IGNsb25lLFxuICAgICAgaGFzaCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfTtcbiAgfVxuICBnZXQgcHJpbnQoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJTaG91bGQgbm90IGNhbGwgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZS5wcmludFwiKTtcbiAgfVxuICBnZXQgc2VyaWFsaXphYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNzZXJpYWxpemFibGU7XG4gIH1cbiAgZ2V0IG1vZGlmaWVkSWRzKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJtb2RpZmllZElkc1wiLCB7XG4gICAgICBpZHM6IG5ldyBTZXQoKSxcbiAgICAgIGhhc2g6IFwiXCJcbiAgICB9KTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9mb250X2xvYWRlci5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5jbGFzcyBGb250TG9hZGVyIHtcbiAgI3N5c3RlbUZvbnRzID0gbmV3IFNldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQsXG4gICAgc3R5bGVFbGVtZW50ID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmxvYWRpbmdSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMubG9hZFRlc3RGb250SWQgPSAwO1xuICB9XG4gIGFkZE5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIHJlbW92ZU5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGlmICghdGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmQodGhpcy5zdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZVNoZWV0ID0gdGhpcy5zdHlsZUVsZW1lbnQuc2hlZXQ7XG4gICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IG5hdGl2ZUZvbnRGYWNlIG9mIHRoaXMubmF0aXZlRm9udEZhY2VzKSB7XG4gICAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICAgIH1cbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5jbGVhcigpO1xuICAgIHRoaXMuI3N5c3RlbUZvbnRzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbG9hZFN5c3RlbUZvbnQoe1xuICAgIHN5c3RlbUZvbnRJbmZvOiBpbmZvLFxuICAgIGRpc2FibGVGb250RmFjZSxcbiAgICBfaW5zcGVjdEZvbnRcbiAgfSkge1xuICAgIGlmICghaW5mbyB8fCB0aGlzLiNzeXN0ZW1Gb250cy5oYXMoaW5mby5sb2FkZWROYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3NlcnQoIWRpc2FibGVGb250RmFjZSwgXCJsb2FkU3lzdGVtRm9udCBzaG91bGRuJ3QgYmUgY2FsbGVkIHdoZW4gYGRpc2FibGVGb250RmFjZWAgaXMgc2V0LlwiKTtcbiAgICBpZiAodGhpcy5pc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxvYWRlZE5hbWUsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBpbmZvO1xuICAgICAgY29uc3QgZm9udEZhY2UgPSBuZXcgRm9udEZhY2UobG9hZGVkTmFtZSwgc3JjLCBzdHlsZSk7XG4gICAgICB0aGlzLmFkZE5hdGl2ZUZvbnRGYWNlKGZvbnRGYWNlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZvbnRGYWNlLmxvYWQoKTtcbiAgICAgICAgdGhpcy4jc3lzdGVtRm9udHMuYWRkKGxvYWRlZE5hbWUpO1xuICAgICAgICBfaW5zcGVjdEZvbnQ/LihpbmZvKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB3YXJuKGBDYW5ub3QgbG9hZCBzeXN0ZW0gZm9udDogJHtpbmZvLmJhc2VGb250TmFtZX0sIGluc3RhbGxpbmcgaXQgY291bGQgaGVscCB0byBpbXByb3ZlIFBERiByZW5kZXJpbmcuYCk7XG4gICAgICAgIHRoaXMucmVtb3ZlTmF0aXZlRm9udEZhY2UoZm9udEZhY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZDogbG9hZFN5c3RlbUZvbnQgd2l0aG91dCB0aGUgRm9udCBMb2FkaW5nIEFQSS5cIik7XG4gIH1cbiAgYXN5bmMgYmluZChmb250KSB7XG4gICAgaWYgKGZvbnQuYXR0YWNoZWQgfHwgZm9udC5taXNzaW5nRmlsZSAmJiAhZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb250LmF0dGFjaGVkID0gdHJ1ZTtcbiAgICBpZiAoZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgYXdhaXQgdGhpcy5sb2FkU3lzdGVtRm9udChmb250KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCkge1xuICAgICAgY29uc3QgbmF0aXZlRm9udEZhY2UgPSBmb250LmNyZWF0ZU5hdGl2ZUZvbnRGYWNlKCk7XG4gICAgICBpZiAobmF0aXZlRm9udEZhY2UpIHtcbiAgICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbmF0aXZlRm9udEZhY2UubG9hZGVkO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBsb2FkIGZvbnQgJyR7bmF0aXZlRm9udEZhY2UuZmFtaWx5fSc6ICcke2V4fScuYCk7XG4gICAgICAgICAgZm9udC5kaXNhYmxlRm9udEZhY2UgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBmb250LmNyZWF0ZUZvbnRGYWNlUnVsZSgpO1xuICAgIGlmIChydWxlKSB7XG4gICAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgICBpZiAodGhpcy5pc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKHJlc29sdmUpO1xuICAgICAgICB0aGlzLl9wcmVwYXJlRm9udExvYWRFdmVudChmb250LCByZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCgpIHtcbiAgICBjb25zdCBoYXNGb250cyA9ICEhdGhpcy5fZG9jdW1lbnQ/LmZvbnRzO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkXCIsIGhhc0ZvbnRzKTtcbiAgfVxuICBnZXQgaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkXCIsIGlzTm9kZUpTIHx8IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm0uaXNGaXJlZm94KTtcbiAgfVxuICBfcXVldWVMb2FkaW5nQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZVJlcXVlc3QoKSB7XG4gICAgICBhc3NlcnQoIXJlcXVlc3QuZG9uZSwgXCJjb21wbGV0ZVJlcXVlc3QoKSBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlLlwiKTtcbiAgICAgIHJlcXVlc3QuZG9uZSA9IHRydWU7XG4gICAgICB3aGlsZSAobG9hZGluZ1JlcXVlc3RzLmxlbmd0aCA+IDAgJiYgbG9hZGluZ1JlcXVlc3RzWzBdLmRvbmUpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJSZXF1ZXN0ID0gbG9hZGluZ1JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHNldFRpbWVvdXQob3RoZXJSZXF1ZXN0LmNhbGxiYWNrLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbG9hZGluZ1JlcXVlc3RzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgY29tcGxldGU6IGNvbXBsZXRlUmVxdWVzdCxcbiAgICAgIGNhbGxiYWNrXG4gICAgfTtcbiAgICBsb2FkaW5nUmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuICBnZXQgX2xvYWRUZXN0Rm9udCgpIHtcbiAgICBjb25zdCB0ZXN0Rm9udCA9IGF0b2IoXCJUMVJVVHdBTEFJQUFBd0F3UTBaR0lESHRaZzRBQUFPWUFBQUFnVVpHVkUxbGt6WndBQUFFSEFBQUFCeEhSRVZHQUJRQVwiICsgXCJGUUFBQkRnQUFBQWVUMU12TWxZTll3a0FBQUVnQUFBQVlHTnRZWEFCRFFMVUFBQUNOQUFBQVVKb1pXRmsveFZGRFFBQVwiICsgXCJBTHdBQUFBMmFHaGxZUWRrQStvQUFBRDBBQUFBSkdodGRIZ0Q2QUFBQUFBRVdBQUFBQVp0WVhod0FBSlFBQUFBQVJnQVwiICsgXCJBQUFHYm1GdFpWam1kSDRBQUFHQUFBQUFzWEJ2YzNUL2hnQXpBQUFEZUFBQUFDQUFBUUFBQUFFQUFMWlJGc1JmRHp6MVwiICsgXCJBQXNENkFBQUFBRE9CT1RMQUFBQUFNNEtIRHdBQUFBQUErZ0RJUUFBQUFnQUFnQUFBQUFBQUFBQkFBQURJUUFBQUZvRFwiICsgXCI2QUFBQUFBRDZBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFVQUFBQWdBQUFBUUQ2QUgwQUFVQUFBS0tBcndBQUFDTVwiICsgXCJBb29DdkFBQUFlQUFNUUVDQUFBQ0FBWUpBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUZCbVJXUUF3QUF1QUM0RFwiICsgXCJJUDg0QUZvRElRQUFBQUFBQVFBQUFBQUFBQUFBQUNBQUlBQUJBQUFBRGdDdUFBRUFBQUFBQUFBQUFRQUFBQUVBQUFBQVwiICsgXCJBQUVBQVFBQUFBRUFBQUFBQUFJQUFRQUFBQUVBQUFBQUFBTUFBUUFBQUFFQUFBQUFBQVFBQVFBQUFBRUFBQUFBQUFVQVwiICsgXCJBUUFBQUFFQUFBQUFBQVlBQVFBQUFBTUFBUVFKQUFBQUFnQUJBQU1BQVFRSkFBRUFBZ0FCQUFNQUFRUUpBQUlBQWdBQlwiICsgXCJBQU1BQVFRSkFBTUFBZ0FCQUFNQUFRUUpBQVFBQWdBQkFBTUFBUVFKQUFVQUFnQUJBQU1BQVFRSkFBWUFBZ0FCV0FCWVwiICsgXCJBQUFBQUFBQUF3QUFBQU1BQUFBY0FBRUFBQUFBQUR3QUF3QUJBQUFBSEFBRUFDQUFBQUFFQUFRQUFRQUFBQzcvL3dBQVwiICsgXCJBQzcvLy8vVEFBRUFBQUFBQUFBQkJnQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNQUFBQUFBQUQvZ3dBeUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFCQUFRRUFBRUJBUUpZQUFFQkFTSDREd0Q0R3dIRUF2Z2NBL2dYQkl3TUFZdUwrbno1dFFYa0Q1ajNDQkxuRVFBQ1wiICsgXCJBUUVCSVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlBQUFCQVFBQUR3QUNBUUVFRS90M1wiICsgXCJEb3Y2ZkFINmZBVCtmUHA4K253SERvc01Ddm0xQ3ZtMURBejZmQlFBQUFBQUFBQUJBQUFBQU1tSmJ6RUFBQUFBemdUalwiICsgXCJGUUFBQUFET0JPUXBBQUVBQUFBQUFBQUFEQUFVQUFRQUFBQUJBQUFBQWdBQkFBQUFBQUFBQUFBRDZBQUFBQUFBQUE9PVwiKTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2xvYWRUZXN0Rm9udFwiLCB0ZXN0Rm9udCk7XG4gIH1cbiAgX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpIHtcbiAgICBmdW5jdGlvbiBpbnQzMihkYXRhLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA8PCAxNiB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAyKSA8PCA4IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDMpICYgMHhmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaWNlU3RyaW5nKHMsIG9mZnNldCwgcmVtb3ZlLCBpbnNlcnQpIHtcbiAgICAgIGNvbnN0IGNodW5rMSA9IHMuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICBjb25zdCBjaHVuazIgPSBzLnN1YnN0cmluZyhvZmZzZXQgKyByZW1vdmUpO1xuICAgICAgcmV0dXJuIGNodW5rMSArIGluc2VydCArIGNodW5rMjtcbiAgICB9XG4gICAgbGV0IGksIGlpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gMTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGxldCBjYWxsZWQgPSAwO1xuICAgIGZ1bmN0aW9uIGlzRm9udFJlYWR5KG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoKytjYWxsZWQgPiAzMCkge1xuICAgICAgICB3YXJuKFwiTG9hZCB0ZXN0IGZvbnQgbmV2ZXIgbG9hZGVkLlwiKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmZvbnQgPSBcIjMwcHggXCIgKyBuYW1lO1xuICAgICAgY3R4LmZpbGxUZXh0KFwiLlwiLCAwLCAyMCk7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuICAgICAgaWYgKGltYWdlRGF0YS5kYXRhWzNdID4gMCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGlzRm9udFJlYWR5LmJpbmQobnVsbCwgbmFtZSwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZFRlc3RGb250SWQgPSBgbHQke0RhdGUubm93KCl9JHt0aGlzLmxvYWRUZXN0Rm9udElkKyt9YDtcbiAgICBsZXQgZGF0YSA9IHRoaXMuX2xvYWRUZXN0Rm9udDtcbiAgICBjb25zdCBDT01NRU5UX09GRlNFVCA9IDk3NjtcbiAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENPTU1FTlRfT0ZGU0VULCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgsIGxvYWRUZXN0Rm9udElkKTtcbiAgICBjb25zdCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUID0gMTY7XG4gICAgY29uc3QgWFhYWF9WQUxVRSA9IDB4NTg1ODU4NTg7XG4gICAgbGV0IGNoZWNrc3VtID0gaW50MzIoZGF0YSwgQ0ZGX0NIRUNLU1VNX09GRlNFVCk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBsb2FkVGVzdEZvbnRJZC5sZW5ndGggLSAzOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCwgaSkgfCAwO1xuICAgIH1cbiAgICBpZiAoaSA8IGxvYWRUZXN0Rm9udElkLmxlbmd0aCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCArIFwiWFhYXCIsIGkpIHwgMDtcbiAgICB9XG4gICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VULCA0LCBzdHJpbmczMihjaGVja3N1bSkpO1xuICAgIGNvbnN0IHVybCA9IGB1cmwoZGF0YTpmb250L29wZW50eXBlO2Jhc2U2NCwke2J0b2EoZGF0YSl9KTtgO1xuICAgIGNvbnN0IHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke2xvYWRUZXN0Rm9udElkfVwiO3NyYzoke3VybH19YDtcbiAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgY29uc3QgZGl2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9IFwiMTBweFwiO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYuc3R5bGUudG9wID0gZGl2LnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBbZm9udC5sb2FkZWROYW1lLCBsb2FkVGVzdEZvbnRJZF0pIHtcbiAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIkhpXCI7XG4gICAgICBzcGFuLnN0eWxlLmZvbnRGYW1pbHkgPSBuYW1lO1xuICAgICAgZGl2LmFwcGVuZChzcGFuKTtcbiAgICB9XG4gICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICBpc0ZvbnRSZWFkeShsb2FkVGVzdEZvbnRJZCwgKCkgPT4ge1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBGb250RmFjZU9iamVjdCB7XG4gICNmb250RGF0YTtcbiAgY29uc3RydWN0b3IodHJhbnNsYXRlZERhdGEsIGluc3BlY3RGb250ID0gbnVsbCwgZXh0cmEsIGNoYXJQcm9jT3BlcmF0b3JMaXN0KSB7XG4gICAgdGhpcy5jb21waWxlZEdseXBocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy4jZm9udERhdGEgPSB0cmFuc2xhdGVkRGF0YTtcbiAgICB0aGlzLl9pbnNwZWN0Rm9udCA9IGluc3BlY3RGb250O1xuICAgIGlmIChleHRyYSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBleHRyYSk7XG4gICAgfVxuICAgIGlmIChjaGFyUHJvY09wZXJhdG9yTGlzdCkge1xuICAgICAgdGhpcy5jaGFyUHJvY09wZXJhdG9yTGlzdCA9IGNoYXJQcm9jT3BlcmF0b3JMaXN0O1xuICAgIH1cbiAgfVxuICBjcmVhdGVOYXRpdmVGb250RmFjZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBuYXRpdmVGb250RmFjZTtcbiAgICBpZiAoIXRoaXMuY3NzRm9udEluZm8pIHtcbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMubG9hZGVkTmFtZSwgdGhpcy5kYXRhLCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNzcyA9IHtcbiAgICAgICAgd2VpZ2h0OiB0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3Muc3R5bGUgPSBgb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnYDtcbiAgICAgIH1cbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMuY3NzRm9udEluZm8uZm9udEZhbWlseSwgdGhpcy5kYXRhLCBjc3MpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMpO1xuICAgIHJldHVybiBuYXRpdmVGb250RmFjZTtcbiAgfVxuICBjcmVhdGVGb250RmFjZVJ1bGUoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6JHt0aGlzLm1pbWV0eXBlfTtiYXNlNjQsJHt0b0Jhc2U2NFV0aWwodGhpcy5kYXRhKX0pO2A7XG4gICAgbGV0IHJ1bGU7XG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmxvYWRlZE5hbWV9XCI7c3JjOiR7dXJsfX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY3NzID0gYGZvbnQtd2VpZ2h0OiAke3RoaXMuY3NzRm9udEluZm8uZm9udFdlaWdodH07YDtcbiAgICAgIGlmICh0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlKSB7XG4gICAgICAgIGNzcyArPSBgZm9udC1zdHlsZTogb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnO2A7XG4gICAgICB9XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHl9XCI7JHtjc3N9c3JjOiR7dXJsfX1gO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMsIHVybCk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgZ2V0UGF0aEdlbmVyYXRvcihvYmpzLCBjaGFyYWN0ZXIpIHtcbiAgICBpZiAodGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl07XG4gICAgfVxuICAgIGNvbnN0IG9iaklkID0gdGhpcy5sb2FkZWROYW1lICsgXCJfcGF0aF9cIiArIGNoYXJhY3RlcjtcbiAgICBsZXQgY21kcztcbiAgICB0cnkge1xuICAgICAgY21kcyA9IG9ianMuZ2V0KG9iaklkKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgd2FybihgZ2V0UGF0aEdlbmVyYXRvciAtIGlnbm9yaW5nIGNoYXJhY3RlcjogXCIke2V4fVwiLmApO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgyRChjbWRzIHx8IFwiXCIpO1xuICAgIGlmICghdGhpcy5mb250RXh0cmFQcm9wZXJ0aWVzKSB7XG4gICAgICBvYmpzLmRlbGV0ZShvYmpJZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBwYXRoO1xuICB9XG4gIGdldCBibGFjaygpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuYmxhY2s7XG4gIH1cbiAgZ2V0IGJvbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmJvbGQ7XG4gIH1cbiAgZ2V0IGRpc2FibGVGb250RmFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuZGlzYWJsZUZvbnRGYWNlID8/IGZhbHNlO1xuICB9XG4gIGdldCBmb250RXh0cmFQcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5mb250RXh0cmFQcm9wZXJ0aWVzID8/IGZhbHNlO1xuICB9XG4gIGdldCBpc0ludmFsaWRQREZqc0ZvbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmlzSW52YWxpZFBERmpzRm9udDtcbiAgfVxuICBnZXQgaXNUeXBlM0ZvbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmlzVHlwZTNGb250O1xuICB9XG4gIGdldCBpdGFsaWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLml0YWxpYztcbiAgfVxuICBnZXQgbWlzc2luZ0ZpbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLm1pc3NpbmdGaWxlO1xuICB9XG4gIGdldCByZW1lYXN1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLnJlbWVhc3VyZTtcbiAgfVxuICBnZXQgdmVydGljYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLnZlcnRpY2FsO1xuICB9XG4gIGdldCBhc2NlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmFzY2VudDtcbiAgfVxuICBnZXQgZGVmYXVsdFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5kZWZhdWx0V2lkdGg7XG4gIH1cbiAgZ2V0IGRlc2NlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmRlc2NlbnQ7XG4gIH1cbiAgZ2V0IGJib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmJib3g7XG4gIH1cbiAgZ2V0IGZvbnRNYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmZvbnRNYXRyaXg7XG4gIH1cbiAgZ2V0IGZhbGxiYWNrTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuZmFsbGJhY2tOYW1lO1xuICB9XG4gIGdldCBsb2FkZWROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5sb2FkZWROYW1lO1xuICB9XG4gIGdldCBtaW1ldHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEubWltZXR5cGU7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLm5hbWU7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmRhdGE7XG4gIH1cbiAgY2xlYXJEYXRhKCkge1xuICAgIHRoaXMuI2ZvbnREYXRhLmNsZWFyRGF0YSgpO1xuICB9XG4gIGdldCBjc3NGb250SW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuY3NzRm9udEluZm87XG4gIH1cbiAgZ2V0IHN5c3RlbUZvbnRJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5zeXN0ZW1Gb250SW5mbztcbiAgfVxuICBnZXQgZGVmYXVsdFZNZXRyaWNzKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5kZWZhdWx0Vk1ldHJpY3M7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvYXBpX3V0aWxzLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZ2V0VXJsUHJvcCh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHJldHVybiB2YWwuaHJlZjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChpc05vZGVKUykge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gVVJMLnBhcnNlKHZhbCwgd2luZG93LmxvY2F0aW9uKTtcbiAgICBpZiAodXJsKSB7XG4gICAgICByZXR1cm4gdXJsLmhyZWY7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUERGIHVybCBkYXRhOiBcIiArIFwiZWl0aGVyIHN0cmluZyBvciBVUkwtb2JqZWN0IGlzIGV4cGVjdGVkIGluIHRoZSB1cmwgcHJvcGVydHkuXCIpO1xufVxuZnVuY3Rpb24gZ2V0RGF0YVByb3AodmFsKSB7XG4gIGlmIChpc05vZGVKUyAmJiB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGJpbmFyeSBkYXRhIGFzIGBVaW50OEFycmF5YCwgcmF0aGVyIHRoYW4gYEJ1ZmZlcmAuXCIpO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHZhbC5ieXRlTGVuZ3RoID09PSB2YWwuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvQnl0ZXModmFsKTtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhaXNOYU4odmFsPy5sZW5ndGgpKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgYmluYXJ5IGRhdGE6IGVpdGhlciBUeXBlZEFycmF5LCBcIiArIFwic3RyaW5nLCBvciBhcnJheS1saWtlIG9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgZGF0YSBwcm9wZXJ0eS5cIik7XG59XG5mdW5jdGlvbiBnZXRGYWN0b3J5VXJsUHJvcCh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodmFsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZhY3RvcnkgdXJsOiBcIiR7dmFsfVwiIG11c3QgaW5jbHVkZSB0cmFpbGluZyBzbGFzaC5gKTtcbn1cbmNvbnN0IGlzUmVmUHJveHkgPSB2ID0+IHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIE51bWJlci5pc0ludGVnZXIodj8ubnVtKSAmJiB2Lm51bSA+PSAwICYmIE51bWJlci5pc0ludGVnZXIodj8uZ2VuKSAmJiB2LmdlbiA+PSAwO1xuY29uc3QgaXNOYW1lUHJveHkgPSB2ID0+IHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2Py5uYW1lID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNWYWxpZEV4cGxpY2l0RGVzdCA9IF9pc1ZhbGlkRXhwbGljaXREZXN0LmJpbmQobnVsbCwgaXNSZWZQcm94eSwgaXNOYW1lUHJveHkpO1xuY2xhc3MgTG9vcGJhY2tQb3J0IHtcbiAgI2xpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgI2RlZmVycmVkID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHBvc3RNZXNzYWdlKG9iaiwgdHJhbnNmZXIpIHtcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIGRhdGE6IHN0cnVjdHVyZWRDbG9uZShvYmosIHRyYW5zZmVyID8ge1xuICAgICAgICB0cmFuc2ZlclxuICAgICAgfSA6IG51bGwpXG4gICAgfTtcbiAgICB0aGlzLiNkZWZlcnJlZC50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgW2xpc3RlbmVyXSBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lciwgb3B0aW9ucyA9IG51bGwpIHtcbiAgICBsZXQgcm1BYm9ydCA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnM/LnNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgd2FybihcIkxvb3BiYWNrUG9ydCAtIGNhbm5vdCB1c2UgYW4gYGFib3J0ZWRgIHNpZ25hbC5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpO1xuICAgICAgcm1BYm9ydCA9ICgpID0+IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgIH1cbiAgICB0aGlzLiNsaXN0ZW5lcnMuc2V0KGxpc3RlbmVyLCBybUFib3J0KTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3Qgcm1BYm9ydCA9IHRoaXMuI2xpc3RlbmVycy5nZXQobGlzdGVuZXIpO1xuICAgIHJtQWJvcnQ/LigpO1xuICAgIHRoaXMuI2xpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICB9XG4gIHRlcm1pbmF0ZSgpIHtcbiAgICBmb3IgKGNvbnN0IFssIHJtQWJvcnRdIG9mIHRoaXMuI2xpc3RlbmVycykge1xuICAgICAgcm1BYm9ydD8uKCk7XG4gICAgfVxuICAgIHRoaXMuI2xpc3RlbmVycy5jbGVhcigpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9zaGFyZWQvbWVzc2FnZV9oYW5kbGVyLmpzXG5cblxuXG5jb25zdCBDYWxsYmFja0tpbmQgPSB7XG4gIERBVEE6IDEsXG4gIEVSUk9SOiAyXG59O1xuY29uc3QgU3RyZWFtS2luZCA9IHtcbiAgQ0FOQ0VMOiAxLFxuICBDQU5DRUxfQ09NUExFVEU6IDIsXG4gIENMT1NFOiAzLFxuICBFTlFVRVVFOiA0LFxuICBFUlJPUjogNSxcbiAgUFVMTDogNixcbiAgUFVMTF9DT01QTEVURTogNyxcbiAgU1RBUlRfQ09NUExFVEU6IDhcbn07XG5mdW5jdGlvbiBvbkZuKCkge31cbmZ1bmN0aW9uIHdyYXBSZWFzb24oZXgpIHtcbiAgaWYgKGV4IGluc3RhbmNlb2YgQWJvcnRFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBJbnZhbGlkUERGRXhjZXB0aW9uIHx8IGV4IGluc3RhbmNlb2YgUGFzc3dvcmRFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBSZXNwb25zZUV4Y2VwdGlvbiB8fCBleCBpbnN0YW5jZW9mIFVua25vd25FcnJvckV4Y2VwdGlvbikge1xuICAgIHJldHVybiBleDtcbiAgfVxuICBpZiAoIShleCBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiBleCA9PT0gXCJvYmplY3RcIiAmJiBleCAhPT0gbnVsbCkpIHtcbiAgICB1bnJlYWNoYWJsZSgnd3JhcFJlYXNvbjogRXhwZWN0ZWQgXCJyZWFzb25cIiB0byBiZSBhIChwb3NzaWJseSBjbG9uZWQpIEVycm9yLicpO1xuICB9XG4gIHN3aXRjaCAoZXgubmFtZSkge1xuICAgIGNhc2UgXCJBYm9ydEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBBYm9ydEV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICBjYXNlIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkUERGRXhjZXB0aW9uKGV4Lm1lc3NhZ2UpO1xuICAgIGNhc2UgXCJQYXNzd29yZEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBQYXNzd29yZEV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5jb2RlKTtcbiAgICBjYXNlIFwiUmVzcG9uc2VFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2VFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguc3RhdHVzLCBleC5taXNzaW5nKTtcbiAgICBjYXNlIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IFVua25vd25FcnJvckV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5kZXRhaWxzKTtcbiAgfVxuICByZXR1cm4gbmV3IFVua25vd25FcnJvckV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC50b1N0cmluZygpKTtcbn1cbmNsYXNzIE1lc3NhZ2VIYW5kbGVyIHtcbiAgI21lc3NhZ2VBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgY29uc3RydWN0b3Ioc291cmNlTmFtZSwgdGFyZ2V0TmFtZSwgY29tT2JqKSB7XG4gICAgdGhpcy5zb3VyY2VOYW1lID0gc291cmNlTmFtZTtcbiAgICB0aGlzLnRhcmdldE5hbWUgPSB0YXJnZXROYW1lO1xuICAgIHRoaXMuY29tT2JqID0gY29tT2JqO1xuICAgIHRoaXMuY2FsbGJhY2tJZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1JZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1TaW5rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hY3Rpb25IYW5kbGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb21PYmouYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy4jb25NZXNzYWdlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbDogdGhpcy4jbWVzc2FnZUFDLnNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNvbk1lc3NhZ2Uoe1xuICAgIGRhdGFcbiAgfSkge1xuICAgIGlmIChkYXRhLnRhcmdldE5hbWUgIT09IHRoaXMuc291cmNlTmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5zdHJlYW0pIHtcbiAgICAgIHRoaXMuI3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jYWxsYmFjaykge1xuICAgICAgY29uc3QgY2FsbGJhY2tJZCA9IGRhdGEuY2FsbGJhY2tJZDtcbiAgICAgIGNvbnN0IGNhcGFiaWxpdHkgPSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuICAgICAgaWYgKCFjYXBhYmlsaXR5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlc29sdmUgY2FsbGJhY2sgJHtjYWxsYmFja0lkfWApO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkRBVEEpIHtcbiAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEuZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5FUlJPUikge1xuICAgICAgICBjYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNhbGxiYWNrIGNhc2VcIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhY3Rpb24gZnJvbSB3b3JrZXI6ICR7ZGF0YS5hY3Rpb259YCk7XG4gICAgfVxuICAgIGlmIChkYXRhLmNhbGxiYWNrSWQpIHtcbiAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgICAgUHJvbWlzZS50cnkoYWN0aW9uLCBkYXRhLmRhdGEpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkRBVEEsXG4gICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgIGRhdGE6IHJlc3VsdFxuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5FUlJPUixcbiAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuc3RyZWFtSWQpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdGlvbihkYXRhLmRhdGEpO1xuICB9XG4gIG9uKGFjdGlvbk5hbWUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBhaCA9IHRoaXMuYWN0aW9uSGFuZGxlcjtcbiAgICBpZiAoYWhbYWN0aW9uTmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhbiBhY3Rpb25OYW1lIGNhbGxlZCBcIiR7YWN0aW9uTmFtZX1cImApO1xuICAgIH1cbiAgICBhaFthY3Rpb25OYW1lXSA9IGhhbmRsZXI7XG4gIH1cbiAgc2VuZChhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICBkYXRhXG4gICAgfSwgdHJhbnNmZXJzKTtcbiAgfVxuICBzZW5kV2l0aFByb21pc2UoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tJZCA9IHRoaXMuY2FsbGJhY2tJZCsrO1xuICAgIGNvbnN0IGNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdID0gY2FwYWJpbGl0eTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICBjYWxsYmFja0lkLFxuICAgICAgICBkYXRhXG4gICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjYXBhYmlsaXR5LnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc2VuZFdpdGhTdHJlYW0oYWN0aW9uTmFtZSwgZGF0YSwgcXVldWVpbmdTdHJhdGVneSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSB0aGlzLnN0cmVhbUlkKyssXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBzdGFydENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0gPSB7XG4gICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICBzdGFydENhbGw6IHN0YXJ0Q2FwYWJpbGl0eSxcbiAgICAgICAgICBwdWxsQ2FsbDogbnVsbCxcbiAgICAgICAgICBjYW5jZWxDYWxsOiBudWxsLFxuICAgICAgICAgIGlzQ2xvc2VkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgICByZXR1cm4gc3RhcnRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgcHVsbDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIGNvbnN0IHB1bGxDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnB1bGxDYWxsID0gcHVsbENhcGFiaWxpdHk7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHVsbENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6IHJlYXNvbiA9PiB7XG4gICAgICAgIGFzc2VydChyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJjYW5jZWwgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBjb25zdCBjYW5jZWxDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmNhbmNlbENhbGwgPSBjYW5jZWxDYXBhYmlsaXR5O1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUwsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYW5jZWxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9XG4gICAgfSwgcXVldWVpbmdTdHJhdGVneSk7XG4gIH1cbiAgI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZCxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMsXG4gICAgICBhY3Rpb24gPSB0aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuICAgIGNvbnN0IHN0cmVhbVNpbmsgPSB7XG4gICAgICBlbnF1ZXVlKGNodW5rLCBzaXplID0gMSwgdHJhbnNmZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3REZXNpcmVkU2l6ZSA9IHRoaXMuZGVzaXJlZFNpemU7XG4gICAgICAgIHRoaXMuZGVzaXJlZFNpemUgLT0gc2l6ZTtcbiAgICAgICAgaWYgKGxhc3REZXNpcmVkU2l6ZSA+IDAgJiYgdGhpcy5kZXNpcmVkU2l6ZSA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5zaW5rQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0aGlzLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVOUVVFVUUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgY2h1bmtcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgIH0sXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DTE9TRSxcbiAgICAgICAgICBzdHJlYW1JZFxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHNlbGYuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgfSxcbiAgICAgIGVycm9yKHJlYXNvbikge1xuICAgICAgICBhc3NlcnQocmVhc29uIGluc3RhbmNlb2YgRXJyb3IsIFwiZXJyb3IgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVSUk9SLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNpbmtDYXBhYmlsaXR5OiBQcm9taXNlLndpdGhSZXNvbHZlcnMoKSxcbiAgICAgIG9uUHVsbDogbnVsbCxcbiAgICAgIG9uQ2FuY2VsOiBudWxsLFxuICAgICAgaXNDYW5jZWxsZWQ6IGZhbHNlLFxuICAgICAgZGVzaXJlZFNpemU6IGRhdGEuZGVzaXJlZFNpemUsXG4gICAgICByZWFkeTogbnVsbFxuICAgIH07XG4gICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgc3RyZWFtU2luay5yZWFkeSA9IHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXSA9IHN0cmVhbVNpbms7XG4gICAgUHJvbWlzZS50cnkoYWN0aW9uLCBkYXRhLmRhdGEsIHN0cmVhbVNpbmspLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gICNwcm9jZXNzU3RyZWFtTWVzc2FnZShkYXRhKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICBjb25zdCBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0sXG4gICAgICBzdHJlYW1TaW5rID0gdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgc3dpdGNoIChkYXRhLnN0cmVhbSkge1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5QVUxMOlxuICAgICAgICBpZiAoIXN0cmVhbVNpbmspIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW1TaW5rLmRlc2lyZWRTaXplIDw9IDAgJiYgZGF0YS5kZXNpcmVkU2l6ZSA+IDApIHtcbiAgICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1TaW5rLmRlc2lyZWRTaXplID0gZGF0YS5kZXNpcmVkU2l6ZTtcbiAgICAgICAgUHJvbWlzZS50cnkoc3RyZWFtU2luay5vblB1bGwgfHwgb25GbikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRU5RVUVVRTpcbiAgICAgICAgYXNzZXJ0KHN0cmVhbUNvbnRyb2xsZXIsIFwiZW5xdWV1ZSBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgaWYgKHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhLmNodW5rKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0xPU0U6XG4gICAgICAgIGFzc2VydChzdHJlYW1Db250cm9sbGVyLCBcImNsb3NlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkVSUk9SOlxuICAgICAgICBhc3NlcnQoc3RyZWFtQ29udHJvbGxlciwgXCJlcnJvciBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YVJlYXNvbiA9IHdyYXBSZWFzb24oZGF0YS5yZWFzb24pO1xuICAgICAgICBQcm9taXNlLnRyeShzdHJlYW1TaW5rLm9uQ2FuY2VsIHx8IG9uRm4sIGRhdGFSZWFzb24pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlamVjdChkYXRhUmVhc29uKTtcbiAgICAgICAgc3RyZWFtU2luay5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHN0cmVhbSBjYXNlXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyAjZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbD8ucHJvbWlzZV0pO1xuICAgIGRlbGV0ZSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI21lc3NhZ2VBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNtZXNzYWdlQUMgPSBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NhbnZhc19mYWN0b3J5LmpzXG5cbmNsYXNzIEJhc2VDYW52YXNGYWN0b3J5IHtcbiAgI2VuYWJsZUhXQSA9IGZhbHNlO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZW5hYmxlSFdBID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMuI2VuYWJsZUhXQSA9IGVuYWJsZUhXQTtcbiAgfVxuICBjcmVhdGUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIGNvbnRleHQ6IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICF0aGlzLiNlbmFibGVIV0FcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICByZXNldChjYW52YXNBbmRDb250ZXh0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBkZXN0cm95KGNhbnZhc0FuZENvbnRleHQpIHtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQuY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMgPSBudWxsO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVDYW52YXNgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudCxcbiAgICBlbmFibGVIV0EgPSBmYWxzZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgZW5hYmxlSFdBXG4gICAgfSk7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NtYXBfcmVhZGVyX2ZhY3RvcnkuanNcblxuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsLFxuICAgIGlzQ29tcHJlc3NlZCA9IHRydWVcbiAgfSkge1xuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgdGhpcy5pc0NvbXByZXNzZWQgPSBpc0NvbXByZXNzZWQ7XG4gIH1cbiAgYXN5bmMgZmV0Y2goe1xuICAgIG5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCB0aGUgYGNNYXBVcmxgIGFuZCBgY01hcFBhY2tlZGAgQVBJIHBhcmFtZXRlcnMgYXJlIHByb3ZpZGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDTWFwIG5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSB0aGlzLmJhc2VVcmwgKyBuYW1lICsgKHRoaXMuaXNDb21wcmVzc2VkID8gXCIuYmNtYXBcIiA6IFwiXCIpO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwpLnRoZW4oY01hcERhdGEgPT4gKHtcbiAgICAgIGNNYXBEYXRhLFxuICAgICAgaXNDb21wcmVzc2VkOiB0aGlzLmlzQ29tcHJlc3NlZFxuICAgIH0pKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCAke3RoaXMuaXNDb21wcmVzc2VkID8gXCJiaW5hcnkgXCIgOiBcIlwifUNNYXAgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01DTWFwUmVhZGVyRmFjdG9yeSBleHRlbmRzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hEYXRhKHVybCwgdGhpcy5pc0NvbXByZXNzZWQgPyBcImFycmF5YnVmZmVyXCIgOiBcInRleHRcIik7XG4gICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KGRhdGEpIDogc3RyaW5nVG9CeXRlcyhkYXRhKTtcbiAgfVxufVxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5pdGVyYXRvci5maWx0ZXIuanNcbnZhciBlc19pdGVyYXRvcl9maWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0ODkpO1xuOy8vIC4vc3JjL2Rpc3BsYXkvZmlsdGVyX2ZhY3RvcnkuanNcblxuXG5cblxuY2xhc3MgQmFzZUZpbHRlckZhY3Rvcnkge1xuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvcikge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRBbHBoYUZpbHRlcihtYXApIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkTHVtaW5vc2l0eUZpbHRlcihtYXApIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZpbHRlck5hbWUsIGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHt9XG59XG5jbGFzcyBET01GaWx0ZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUZpbHRlckZhY3Rvcnkge1xuICAjYmFzZVVybDtcbiAgI19jYWNoZTtcbiAgI19kZWZzO1xuICAjZG9jSWQ7XG4gICNkb2N1bWVudDtcbiAgI19oY21DYWNoZTtcbiAgI2lkID0gMDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRvY0lkLFxuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI2RvY0lkID0gZG9jSWQ7XG4gICAgdGhpcy4jZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIGdldCAjY2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI19jYWNoZSB8fD0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCAjaGNtQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI19oY21DYWNoZSB8fD0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCAjZGVmcygpIHtcbiAgICBpZiAoIXRoaXMuI19kZWZzKSB7XG4gICAgICBjb25zdCBkaXYgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGRpdjtcbiAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgc3R5bGUuY29udGFpbiA9IFwic3RyaWN0XCI7XG4gICAgICBzdHlsZS53aWR0aCA9IHN0eWxlLmhlaWdodCA9IDA7XG4gICAgICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIHN0eWxlLnRvcCA9IHN0eWxlLmxlZnQgPSAwO1xuICAgICAgc3R5bGUuekluZGV4ID0gLTE7XG4gICAgICBjb25zdCBzdmcgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcInN2Z1wiKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgICB0aGlzLiNfZGVmcyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZGVmc1wiKTtcbiAgICAgIGRpdi5hcHBlbmQoc3ZnKTtcbiAgICAgIHN2Zy5hcHBlbmQodGhpcy4jX2RlZnMpO1xuICAgICAgdGhpcy4jZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI19kZWZzO1xuICB9XG4gICNjcmVhdGVUYWJsZXMobWFwcykge1xuICAgIGlmIChtYXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgbWFwUiA9IG1hcHNbMF07XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYnVmZmVyW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhYmxlID0gYnVmZmVyLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIFt0YWJsZSwgdGFibGUsIHRhYmxlXTtcbiAgICB9XG4gICAgY29uc3QgW21hcFIsIG1hcEcsIG1hcEJdID0gbWFwcztcbiAgICBjb25zdCBidWZmZXJSID0gbmV3IEFycmF5KDI1Nik7XG4gICAgY29uc3QgYnVmZmVyRyA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGNvbnN0IGJ1ZmZlckIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBidWZmZXJSW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgIGJ1ZmZlckdbaV0gPSBtYXBHW2ldIC8gMjU1O1xuICAgICAgYnVmZmVyQltpXSA9IG1hcEJbaV0gLyAyNTU7XG4gICAgfVxuICAgIHJldHVybiBbYnVmZmVyUi5qb2luKFwiLFwiKSwgYnVmZmVyRy5qb2luKFwiLFwiKSwgYnVmZmVyQi5qb2luKFwiLFwiKV07XG4gIH1cbiAgI2NyZWF0ZVVybChpZCkge1xuICAgIGlmICh0aGlzLiNiYXNlVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuI2Jhc2VVcmwgPSBcIlwiO1xuICAgICAgY29uc3QgdXJsID0gdGhpcy4jZG9jdW1lbnQuVVJMO1xuICAgICAgaWYgKHVybCAhPT0gdGhpcy4jZG9jdW1lbnQuYmFzZVVSSSkge1xuICAgICAgICBpZiAoaXNEYXRhU2NoZW1lKHVybCkpIHtcbiAgICAgICAgICB3YXJuKCcjY3JlYXRlVXJsOiBpZ25vcmUgXCJkYXRhOlwiLVVSTCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNiYXNlVXJsID0gdXBkYXRlVXJsSGFzaCh1cmwsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgdXJsKCR7dGhpcy4jYmFzZVVybH0jJHtpZH0pYDtcbiAgfVxuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIGlmICghbWFwcykge1xuICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgIH1cbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwcyk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IFt0YWJsZVIsIHRhYmxlRywgdGFibGVCXSA9IHRoaXMuI2NyZWF0ZVRhYmxlcyhtYXBzKTtcbiAgICBjb25zdCBrZXkgPSBtYXBzLmxlbmd0aCA9PT0gMSA/IHRhYmxlUiA6IGAke3RhYmxlUn0ke3RhYmxlR30ke3RhYmxlQn1gO1xuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X3RyYW5zZmVyX21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXBzLCB1cmwpO1xuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIHVybCk7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGVSLCB0YWJsZUcsIHRhYmxlQiwgZmlsdGVyKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfWA7XG4gICAgY29uc3QgZmlsdGVyTmFtZSA9IFwiYmFzZVwiO1xuICAgIGxldCBpbmZvID0gdGhpcy4jaGNtQ2FjaGUuZ2V0KGZpbHRlck5hbWUpO1xuICAgIGlmIChpbmZvPy5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBpZiAoaW5mbykge1xuICAgICAgaW5mby5maWx0ZXI/LnJlbW92ZSgpO1xuICAgICAgaW5mby5rZXkgPSBrZXk7XG4gICAgICBpbmZvLnVybCA9IFwibm9uZVwiO1xuICAgICAgaW5mby5maWx0ZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvID0ge1xuICAgICAgICBrZXksXG4gICAgICAgIHVybDogXCJub25lXCIsXG4gICAgICAgIGZpbHRlcjogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuI2hjbUNhY2hlLnNldChmaWx0ZXJOYW1lLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKCFmZ0NvbG9yIHx8ICFiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGNvbnN0IGZnUkdCID0gdGhpcy4jZ2V0UkdCKGZnQ29sb3IpO1xuICAgIGZnQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5mZ1JHQik7XG4gICAgY29uc3QgYmdSR0IgPSB0aGlzLiNnZXRSR0IoYmdDb2xvcik7XG4gICAgYmdDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmJnUkdCKTtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBpZiAoZmdDb2xvciA9PT0gXCIjMDAwMDAwXCIgJiYgYmdDb2xvciA9PT0gXCIjZmZmZmZmXCIgfHwgZmdDb2xvciA9PT0gYmdDb2xvcikge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAyNTU7IGkrKykge1xuICAgICAgY29uc3QgeCA9IGkgLyAyNTU7XG4gICAgICBtYXBbaV0gPSB4IDw9IDAuMDM5MjggPyB4IC8gMTIuOTIgOiAoKHggKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xuICAgIH1cbiAgICBjb25zdCB0YWJsZSA9IG1hcC5qb2luKFwiLFwiKTtcbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2hjbV9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IGluZm8uZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGUsIHRhYmxlLCB0YWJsZSwgZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIGNvbnN0IGdldFN0ZXBzID0gKGMsIG4pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZmdSR0JbY10gLyAyNTU7XG4gICAgICBjb25zdCBlbmQgPSBiZ1JHQltjXSAvIDI1NTtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShuICsgMSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gc3RhcnQgKyBpIC8gbiAqIChlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKGdldFN0ZXBzKDAsIDUpLCBnZXRTdGVwcygxLCA1KSwgZ2V0U3RlcHMoMiwgNSksIGZpbHRlcik7XG4gICAgaW5mby51cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHJldHVybiBpbmZvLnVybDtcbiAgfVxuICBhZGRBbHBoYUZpbHRlcihtYXApIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgW3RhYmxlQV0gPSB0aGlzLiNjcmVhdGVUYWJsZXMoW21hcF0pO1xuICAgIGNvbnN0IGtleSA9IGBhbHBoYV8ke3RhYmxlQX1gO1xuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1fYWxwaGFfbWFwXyR7dGhpcy4jaWQrK31gO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24odGFibGVBLCBmaWx0ZXIpO1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgYWRkTHVtaW5vc2l0eUZpbHRlcihtYXApIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwIHx8IFwibHVtaW5vc2l0eVwiKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IHRhYmxlQSwga2V5O1xuICAgIGlmIChtYXApIHtcbiAgICAgIFt0YWJsZUFdID0gdGhpcy4jY3JlYXRlVGFibGVzKFttYXBdKTtcbiAgICAgIGtleSA9IGBsdW1pbm9zaXR5XyR7dGFibGVBfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IFwibHVtaW5vc2l0eVwiO1xuICAgIH1cbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2x1bWlub3NpdHlfbWFwXyR7dGhpcy4jaWQrK31gO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkTHVtaW5vc2l0eUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICBpZiAobWFwKSB7XG4gICAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcEFscGhhQ29udmVyc2lvbih0YWJsZUEsIGZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZpbHRlck5hbWUsIGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtmZ0NvbG9yfS0ke2JnQ29sb3J9LSR7bmV3RmdDb2xvcn0tJHtuZXdCZ0NvbG9yfWA7XG4gICAgbGV0IGluZm8gPSB0aGlzLiNoY21DYWNoZS5nZXQoZmlsdGVyTmFtZSk7XG4gICAgaWYgKGluZm8/LmtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGlmIChpbmZvKSB7XG4gICAgICBpbmZvLmZpbHRlcj8ucmVtb3ZlKCk7XG4gICAgICBpbmZvLmtleSA9IGtleTtcbiAgICAgIGluZm8udXJsID0gXCJub25lXCI7XG4gICAgICBpbmZvLmZpbHRlciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gPSB7XG4gICAgICAgIGtleSxcbiAgICAgICAgdXJsOiBcIm5vbmVcIixcbiAgICAgICAgZmlsdGVyOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy4jaGNtQ2FjaGUuc2V0KGZpbHRlck5hbWUsIGluZm8pO1xuICAgIH1cbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgY29uc3QgW2ZnUkdCLCBiZ1JHQl0gPSBbZmdDb2xvciwgYmdDb2xvcl0ubWFwKHRoaXMuI2dldFJHQi5iaW5kKHRoaXMpKTtcbiAgICBsZXQgZmdHcmF5ID0gTWF0aC5yb3VuZCgwLjIxMjYgKiBmZ1JHQlswXSArIDAuNzE1MiAqIGZnUkdCWzFdICsgMC4wNzIyICogZmdSR0JbMl0pO1xuICAgIGxldCBiZ0dyYXkgPSBNYXRoLnJvdW5kKDAuMjEyNiAqIGJnUkdCWzBdICsgMC43MTUyICogYmdSR0JbMV0gKyAwLjA3MjIgKiBiZ1JHQlsyXSk7XG4gICAgbGV0IFtuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW25ld0ZnQ29sb3IsIG5ld0JnQ29sb3JdLm1hcCh0aGlzLiNnZXRSR0IuYmluZCh0aGlzKSk7XG4gICAgaWYgKGJnR3JheSA8IGZnR3JheSkge1xuICAgICAgW2ZnR3JheSwgYmdHcmF5LCBuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW2JnR3JheSwgZmdHcmF5LCBuZXdCZ1JHQiwgbmV3RmdSR0JdO1xuICAgIH1cbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBjb25zdCBnZXRTdGVwcyA9IChmZywgYmcsIG4pID0+IHtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgY29uc3Qgc3RlcCA9IChiZ0dyYXkgLSBmZ0dyYXkpIC8gbjtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gZmcgLyAyNTU7XG4gICAgICBjb25zdCBuZXdTdGVwID0gKGJnIC0gZmcpIC8gKDI1NSAqIG4pO1xuICAgICAgbGV0IHByZXYgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBNYXRoLnJvdW5kKGZnR3JheSArIGkgKiBzdGVwKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXdTdGFydCArIGkgKiBuZXdTdGVwO1xuICAgICAgICBmb3IgKGxldCBqID0gcHJldjsgaiA8PSBrOyBqKyspIHtcbiAgICAgICAgICBhcnJbal0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gayArIDE7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gcHJldjsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFycltwcmV2IC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21fJHtmaWx0ZXJOYW1lfV9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IGluZm8uZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihnZXRTdGVwcyhuZXdGZ1JHQlswXSwgbmV3QmdSR0JbMF0sIDUpLCBnZXRTdGVwcyhuZXdGZ1JHQlsxXSwgbmV3QmdSR0JbMV0sIDUpLCBnZXRTdGVwcyhuZXdGZ1JHQlsyXSwgbmV3QmdSR0JbMl0sIDUpLCBmaWx0ZXIpO1xuICAgIGluZm8udXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICByZXR1cm4gaW5mby51cmw7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHtcbiAgICBpZiAoa2VlcEhDTSAmJiB0aGlzLiNfaGNtQ2FjaGU/LnNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jX2RlZnM/LnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICB0aGlzLiNfZGVmcyA9IG51bGw7XG4gICAgdGhpcy4jX2NhY2hlPy5jbGVhcigpO1xuICAgIHRoaXMuI19jYWNoZSA9IG51bGw7XG4gICAgdGhpcy4jX2hjbUNhY2hlPy5jbGVhcigpO1xuICAgIHRoaXMuI19oY21DYWNoZSA9IG51bGw7XG4gICAgdGhpcy4jaWQgPSAwO1xuICB9XG4gICNhZGRMdW1pbm9zaXR5Q29udmVyc2lvbihmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbG9yTWF0cml4ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbG9yTWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInZhbHVlc1wiLCBcIjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMyAwLjU5IDAuMTEgMCAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29sb3JNYXRyaXggPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29sb3JNYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwibWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidmFsdWVzXCIsIFwiMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMCAwIDAgMSAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2NyZWF0ZUZpbHRlcihpZCkge1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmlsdGVyXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIiwgXCJzUkdCXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgdGhpcy4jZGVmcy5hcHBlbmQoZmlsdGVyKTtcbiAgICByZXR1cm4gZmlsdGVyO1xuICB9XG4gICNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgZnVuYywgdGFibGUpIHtcbiAgICBjb25zdCBmZUZ1bmMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBmdW5jKTtcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImRpc2NyZXRlXCIpO1xuICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoXCJ0YWJsZVZhbHVlc1wiLCB0YWJsZSk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmQoZmVGdW5jKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHJUYWJsZSwgZ1RhYmxlLCBiVGFibGUsIGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29tcG9uZW50VHJhbnNmZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29tcG9uZW50VHJhbnNmZXJcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNSXCIsIHJUYWJsZSk7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jR1wiLCBnVGFibGUpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0JcIiwgYlRhYmxlKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24oYVRhYmxlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbXBvbmVudFRyYW5zZmVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jQVwiLCBhVGFibGUpO1xuICB9XG4gICNnZXRSR0IoY29sb3IpIHtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgcmV0dXJuIGdldFJHQihnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2RlZnMpLmdldFByb3BlcnR5VmFsdWUoXCJjb2xvclwiKSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvc3RhbmRhcmRfZm9udGRhdGFfZmFjdG9yeS5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5jbGFzcyBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFzZVVybCA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gIH1cbiAgYXN5bmMgZmV0Y2goe1xuICAgIGZpbGVuYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoYXQgdGhlIGBzdGFuZGFyZEZvbnREYXRhVXJsYCBBUEkgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFmaWxlbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9udCBmaWxlbmFtZSBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0ke2ZpbGVuYW1lfWA7XG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoKHVybCkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgZm9udCBkYXRhIGF0OiAke3VybH1gKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9mZXRjaGAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgZXh0ZW5kcyBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoRGF0YSh1cmwsIFwiYXJyYXlidWZmZXJcIik7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3dhc21fZmFjdG9yeS5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5jbGFzcyBCYXNlV2FzbUZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFzZVVybCA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gIH1cbiAgYXN5bmMgZmV0Y2goe1xuICAgIGZpbGVuYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoYXQgdGhlIGB3YXNtVXJsYCBBUEkgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFmaWxlbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FzbSBmaWxlbmFtZSBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0ke2ZpbGVuYW1lfWA7XG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoKHVybCkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgd2FzbSBkYXRhIGF0OiAke3VybH1gKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9mZXRjaGAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgRE9NV2FzbUZhY3RvcnkgZXh0ZW5kcyBCYXNlV2FzbUZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoRGF0YSh1cmwsIFwiYXJyYXlidWZmZXJcIik7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L25vZGVfdXRpbHMuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5pZiAoaXNOb2RlSlMpIHtcbiAgbGV0IGNhbnZhcztcbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1aXJlID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwibW9kdWxlXCIpLmNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbiAgICB0cnkge1xuICAgICAgY2FudmFzID0gcmVxdWlyZShcIkBuYXBpLXJzL2NhbnZhc1wiKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgd2FybihgQ2Fubm90IGxvYWQgXCJAbmFwaS1ycy9jYW52YXNcIiBwYWNrYWdlOiBcIiR7ZXh9XCIuYCk7XG4gICAgfVxuICB9IGNhdGNoIChleCkge1xuICAgIHdhcm4oYENhbm5vdCBhY2Nlc3MgdGhlIFxcYHJlcXVpcmVcXGAgZnVuY3Rpb246IFwiJHtleH1cIi5gKTtcbiAgfVxuICBpZiAoIWdsb2JhbFRoaXMuRE9NTWF0cml4KSB7XG4gICAgaWYgKGNhbnZhcz8uRE9NTWF0cml4KSB7XG4gICAgICBnbG9iYWxUaGlzLkRPTU1hdHJpeCA9IGNhbnZhcy5ET01NYXRyaXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXCJDYW5ub3QgcG9seWZpbGwgYERPTU1hdHJpeGAsIHJlbmRlcmluZyBtYXkgYmUgYnJva2VuLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFnbG9iYWxUaGlzLkltYWdlRGF0YSkge1xuICAgIGlmIChjYW52YXM/LkltYWdlRGF0YSkge1xuICAgICAgZ2xvYmFsVGhpcy5JbWFnZURhdGEgPSBjYW52YXMuSW1hZ2VEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHBvbHlmaWxsIGBJbWFnZURhdGFgLCByZW5kZXJpbmcgbWF5IGJlIGJyb2tlbi5cIik7XG4gICAgfVxuICB9XG4gIGlmICghZ2xvYmFsVGhpcy5QYXRoMkQpIHtcbiAgICBpZiAoY2FudmFzPy5QYXRoMkQpIHtcbiAgICAgIGdsb2JhbFRoaXMuUGF0aDJEID0gY2FudmFzLlBhdGgyRDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcIkNhbm5vdCBwb2x5ZmlsbCBgUGF0aDJEYCwgcmVuZGVyaW5nIG1heSBiZSBicm9rZW4uXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoIWdsb2JhbFRoaXMubmF2aWdhdG9yPy5sYW5ndWFnZSkge1xuICAgIGdsb2JhbFRoaXMubmF2aWdhdG9yID0ge1xuICAgICAgbGFuZ3VhZ2U6IFwiZW4tVVNcIixcbiAgICAgIHBsYXRmb3JtOiBcIlwiLFxuICAgICAgdXNlckFnZW50OiBcIlwiXG4gICAgfTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gbm9kZV91dGlsc19mZXRjaERhdGEodXJsKSB7XG4gIGNvbnN0IGZzID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwiZnNcIik7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZSh1cmwpO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG59XG5jbGFzcyBOb2RlRmlsdGVyRmFjdG9yeSBleHRlbmRzIEJhc2VGaWx0ZXJGYWN0b3J5IHt9XG5jbGFzcyBOb2RlQ2FudmFzRmFjdG9yeSBleHRlbmRzIEJhc2VDYW52YXNGYWN0b3J5IHtcbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVxdWlyZSA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcIm1vZHVsZVwiKS5jcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybCk7XG4gICAgY29uc3QgY2FudmFzID0gcmVxdWlyZShcIkBuYXBpLXJzL2NhbnZhc1wiKTtcbiAgICByZXR1cm4gY2FudmFzLmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxufVxuY2xhc3MgTm9kZUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHJldHVybiBub2RlX3V0aWxzX2ZldGNoRGF0YSh1cmwpO1xuICB9XG59XG5jbGFzcyBOb2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgZXh0ZW5kcyBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgcmV0dXJuIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCk7XG4gIH1cbn1cbmNsYXNzIE5vZGVXYXNtRmFjdG9yeSBleHRlbmRzIEJhc2VXYXNtRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICByZXR1cm4gbm9kZV91dGlsc19mZXRjaERhdGEodXJsKTtcbiAgfVxufVxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5pdGVyYXRvci5mb3ItZWFjaC5qc1xudmFyIGVzX2l0ZXJhdG9yX2Zvcl9lYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTg4KTtcbjsvLyAuL3NyYy9kaXNwbGF5L2NhbnZhc19kZXBlbmRlbmN5X3RyYWNrZXIuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUwgPSBcIl9fZm9yY2VkRGVwZW5kZW5jeVwiO1xuY29uc3Qge1xuICBmbG9vcixcbiAgY2VpbFxufSA9IE1hdGg7XG5mdW5jdGlvbiBleHBhbmRCQm94KGFycmF5LCBpbmRleCwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSkge1xuICBhcnJheVtpbmRleCAqIDQgKyAwXSA9IE1hdGgubWluKGFycmF5W2luZGV4ICogNCArIDBdLCBtaW5YKTtcbiAgYXJyYXlbaW5kZXggKiA0ICsgMV0gPSBNYXRoLm1pbihhcnJheVtpbmRleCAqIDQgKyAxXSwgbWluWSk7XG4gIGFycmF5W2luZGV4ICogNCArIDJdID0gTWF0aC5tYXgoYXJyYXlbaW5kZXggKiA0ICsgMl0sIG1heFgpO1xuICBhcnJheVtpbmRleCAqIDQgKyAzXSA9IE1hdGgubWF4KGFycmF5W2luZGV4ICogNCArIDNdLCBtYXhZKTtcbn1cbmNvbnN0IEVNUFRZX0JCT1ggPSBuZXcgVWludDMyQXJyYXkobmV3IFVpbnQ4QXJyYXkoWzI1NSwgMjU1LCAwLCAwXSkuYnVmZmVyKVswXTtcbmNsYXNzIEJCb3hSZWFkZXIge1xuICAjYmJveGVzO1xuICAjY29vcmRzO1xuICBjb25zdHJ1Y3RvcihiYm94ZXMsIGNvb3Jkcykge1xuICAgIHRoaXMuI2Jib3hlcyA9IGJib3hlcztcbiAgICB0aGlzLiNjb29yZHMgPSBjb29yZHM7XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYmJveGVzLmxlbmd0aDtcbiAgfVxuICBpc0VtcHR5KGkpIHtcbiAgICByZXR1cm4gdGhpcy4jYmJveGVzW2ldID09PSBFTVBUWV9CQk9YO1xuICB9XG4gIG1pblgoaSkge1xuICAgIHJldHVybiB0aGlzLiNjb29yZHNbaSAqIDQgKyAwXSAvIDI1NjtcbiAgfVxuICBtaW5ZKGkpIHtcbiAgICByZXR1cm4gdGhpcy4jY29vcmRzW2kgKiA0ICsgMV0gLyAyNTY7XG4gIH1cbiAgbWF4WChpKSB7XG4gICAgcmV0dXJuICh0aGlzLiNjb29yZHNbaSAqIDQgKyAyXSArIDEpIC8gMjU2O1xuICB9XG4gIG1heFkoaSkge1xuICAgIHJldHVybiAodGhpcy4jY29vcmRzW2kgKiA0ICsgM10gKyAxKSAvIDI1NjtcbiAgfVxufVxuY29uc3QgZW5zdXJlRGVidWdNZXRhZGF0YSA9IChtYXAsIGtleSkgPT4ge1xuICBpZiAoIW1hcCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgbGV0IHZhbHVlID0gbWFwLmdldChrZXkpO1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdmFsdWUgPSB7XG4gICAgICBkZXBlbmRlbmNpZXM6IG5ldyBTZXQoKSxcbiAgICAgIGlzUmVuZGVyaW5nT3BlcmF0aW9uOiBmYWxzZVxuICAgIH07XG4gICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgQ2FudmFzRGVwZW5kZW5jeVRyYWNrZXIge1xuICAjc2ltcGxlID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbFxuICB9O1xuICAjaW5jcmVtZW50YWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHRyYW5zZm9ybTogW10sXG4gICAgbW92ZVRleHQ6IFtdLFxuICAgIHNhbWVMaW5lVGV4dDogW10sXG4gICAgW0ZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMXTogW11cbiAgfTtcbiAgI25hbWVkRGVwZW5kZW5jaWVzID0gbmV3IE1hcCgpO1xuICAjc2F2ZXNTdGFjayA9IFtdO1xuICAjbWFya2VkQ29udGVudFN0YWNrID0gW107XG4gICNiYXNlVHJhbnNmb3JtU3RhY2sgPSBbWzEsIDAsIDAsIDEsIDAsIDBdXTtcbiAgI2NsaXBCb3ggPSBbLUluZmluaXR5LCAtSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eV07XG4gICNwZW5kaW5nQkJveCA9IG5ldyBGbG9hdDY0QXJyYXkoW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldKTtcbiAgI3BlbmRpbmdCQm94SWR4ID0gLTE7XG4gICNwZW5kaW5nRGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAjb3BlcmF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgI2ZvbnRCQm94VHJ1c3R3b3J0aHkgPSBuZXcgTWFwKCk7XG4gICNjYW52YXNXaWR0aDtcbiAgI2NhbnZhc0hlaWdodDtcbiAgI2Jib3hlc0Nvb3JkcztcbiAgI2Jib3hlcztcbiAgI2RlYnVnTWV0YWRhdGE7XG4gIGNvbnN0cnVjdG9yKGNhbnZhcywgb3BlcmF0aW9uc0NvdW50LCByZWNvcmREZWJ1Z01ldGFkYXRhID0gZmFsc2UpIHtcbiAgICB0aGlzLiNjYW52YXNXaWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB0aGlzLiNjYW52YXNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgIHRoaXMuI2luaXRpYWxpemVCQm94ZXMob3BlcmF0aW9uc0NvdW50KTtcbiAgICBpZiAocmVjb3JkRGVidWdNZXRhZGF0YSkge1xuICAgICAgdGhpcy4jZGVidWdNZXRhZGF0YSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbiAgZ3Jvd09wZXJhdGlvbnNDb3VudChvcGVyYXRpb25zQ291bnQpIHtcbiAgICBpZiAob3BlcmF0aW9uc0NvdW50ID49IHRoaXMuI2Jib3hlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuI2luaXRpYWxpemVCQm94ZXMob3BlcmF0aW9uc0NvdW50LCB0aGlzLiNiYm94ZXMpO1xuICAgIH1cbiAgfVxuICAjaW5pdGlhbGl6ZUJCb3hlcyhvcGVyYXRpb25zQ291bnQsIG9sZEJCb3hlcykge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihvcGVyYXRpb25zQ291bnQgKiA0KTtcbiAgICB0aGlzLiNiYm94ZXNDb29yZHMgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoYnVmZmVyKTtcbiAgICB0aGlzLiNiYm94ZXMgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICBpZiAob2xkQkJveGVzICYmIG9sZEJCb3hlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLiNiYm94ZXMuc2V0KG9sZEJCb3hlcyk7XG4gICAgICB0aGlzLiNiYm94ZXMuZmlsbChFTVBUWV9CQk9YLCBvbGRCQm94ZXMubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jYmJveGVzLmZpbGwoRU1QVFlfQkJPWCk7XG4gICAgfVxuICB9XG4gIHNhdmUob3BJZHgpIHtcbiAgICB0aGlzLiNzaW1wbGUgPSB7XG4gICAgICBfX3Byb3RvX186IHRoaXMuI3NpbXBsZVxuICAgIH07XG4gICAgdGhpcy4jaW5jcmVtZW50YWwgPSB7XG4gICAgICBfX3Byb3RvX186IHRoaXMuI2luY3JlbWVudGFsLFxuICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIF9fcHJvdG9fXzogdGhpcy4jaW5jcmVtZW50YWwudHJhbnNmb3JtXG4gICAgICB9LFxuICAgICAgbW92ZVRleHQ6IHtcbiAgICAgICAgX19wcm90b19fOiB0aGlzLiNpbmNyZW1lbnRhbC5tb3ZlVGV4dFxuICAgICAgfSxcbiAgICAgIHNhbWVMaW5lVGV4dDoge1xuICAgICAgICBfX3Byb3RvX186IHRoaXMuI2luY3JlbWVudGFsLnNhbWVMaW5lVGV4dFxuICAgICAgfSxcbiAgICAgIFtGT1JDRURfREVQRU5ERU5DWV9MQUJFTF06IHtcbiAgICAgICAgX19wcm90b19fOiB0aGlzLiNpbmNyZW1lbnRhbFtGT1JDRURfREVQRU5ERU5DWV9MQUJFTF1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuI2NsaXBCb3ggPSB7XG4gICAgICBfX3Byb3RvX186IHRoaXMuI2NsaXBCb3hcbiAgICB9O1xuICAgIHRoaXMuI3NhdmVzU3RhY2sucHVzaChvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzdG9yZShvcElkeCkge1xuICAgIGNvbnN0IHByZXZpb3VzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuI3NpbXBsZSk7XG4gICAgaWYgKHByZXZpb3VzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy4jc2ltcGxlID0gcHJldmlvdXM7XG4gICAgdGhpcy4jaW5jcmVtZW50YWwgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy4jaW5jcmVtZW50YWwpO1xuICAgIHRoaXMuI2NsaXBCb3ggPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy4jY2xpcEJveCk7XG4gICAgY29uc3QgbGFzdFNhdmUgPSB0aGlzLiNzYXZlc1N0YWNrLnBvcCgpO1xuICAgIGlmIChsYXN0U2F2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbnN1cmVEZWJ1Z01ldGFkYXRhKHRoaXMuI2RlYnVnTWV0YWRhdGEsIG9wSWR4KT8uZGVwZW5kZW5jaWVzLmFkZChsYXN0U2F2ZSk7XG4gICAgICB0aGlzLiNiYm94ZXNbb3BJZHhdID0gdGhpcy4jYmJveGVzW2xhc3RTYXZlXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkT3Blbk1hcmtlcihpZHgpIHtcbiAgICB0aGlzLiNzYXZlc1N0YWNrLnB1c2goaWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRPcGVuTWFya2VyKCkge1xuICAgIGlmICh0aGlzLiNzYXZlc1N0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNzYXZlc1N0YWNrLmF0KC0xKTtcbiAgfVxuICByZWNvcmRDbG9zZU1hcmtlcihvcElkeCkge1xuICAgIGNvbnN0IGxhc3RTYXZlID0gdGhpcy4jc2F2ZXNTdGFjay5wb3AoKTtcbiAgICBpZiAobGFzdFNhdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5zdXJlRGVidWdNZXRhZGF0YSh0aGlzLiNkZWJ1Z01ldGFkYXRhLCBvcElkeCk/LmRlcGVuZGVuY2llcy5hZGQobGFzdFNhdmUpO1xuICAgICAgdGhpcy4jYmJveGVzW29wSWR4XSA9IHRoaXMuI2Jib3hlc1tsYXN0U2F2ZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGJlZ2luTWFya2VkQ29udGVudChvcElkeCkge1xuICAgIHRoaXMuI21hcmtlZENvbnRlbnRTdGFjay5wdXNoKG9wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBlbmRNYXJrZWRDb250ZW50KG9wSWR4KSB7XG4gICAgY29uc3QgbGFzdFNhdmUgPSB0aGlzLiNtYXJrZWRDb250ZW50U3RhY2sucG9wKCk7XG4gICAgaWYgKGxhc3RTYXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuc3VyZURlYnVnTWV0YWRhdGEodGhpcy4jZGVidWdNZXRhZGF0YSwgb3BJZHgpPy5kZXBlbmRlbmNpZXMuYWRkKGxhc3RTYXZlKTtcbiAgICAgIHRoaXMuI2Jib3hlc1tvcElkeF0gPSB0aGlzLiNiYm94ZXNbbGFzdFNhdmVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwdXNoQmFzZVRyYW5zZm9ybShjdHgpIHtcbiAgICB0aGlzLiNiYXNlVHJhbnNmb3JtU3RhY2sucHVzaChVdGlsLm11bHRpcGx5QnlET01NYXRyaXgodGhpcy4jYmFzZVRyYW5zZm9ybVN0YWNrLmF0KC0xKSwgY3R4LmdldFRyYW5zZm9ybSgpKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcG9wQmFzZVRyYW5zZm9ybSgpIHtcbiAgICBpZiAodGhpcy4jYmFzZVRyYW5zZm9ybVN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuI2Jhc2VUcmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkU2ltcGxlRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNzaW1wbGVbbmFtZV0gPSBpZHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkSW5jcmVtZW50YWxEYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI2luY3JlbWVudGFsW25hbWVdLnB1c2goaWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNldEluY3JlbWVudGFsRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNpbmNyZW1lbnRhbFtuYW1lXS5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE5hbWVkRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNuYW1lZERlcGVuZGVuY2llcy5zZXQobmFtZSwgaWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRTaW1wbGVEYXRhRnJvbU5hbWVkKG5hbWUsIGRlcE5hbWUsIGZhbGxiYWNrSWR4KSB7XG4gICAgdGhpcy4jc2ltcGxlW25hbWVdID0gdGhpcy4jbmFtZWREZXBlbmRlbmNpZXMuZ2V0KGRlcE5hbWUpID8/IGZhbGxiYWNrSWR4O1xuICB9XG4gIHJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3kobmFtZSwgaWR4KSB7XG4gICAgdGhpcy5yZWNvcmRJbmNyZW1lbnRhbERhdGEoRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUwsIGlkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW5oZXJpdFNpbXBsZURhdGFBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcyhuYW1lcykge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgaWYgKG5hbWUgaW4gdGhpcy4jc2ltcGxlKSB7XG4gICAgICAgIHRoaXMucmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShuYW1lLCB0aGlzLiNzaW1wbGVbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbmhlcml0UGVuZGluZ0RlcGVuZGVuY2llc0FzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKCkge1xuICAgIGZvciAoY29uc3QgZGVwIG9mIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMucmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShGT1JDRURfREVQRU5ERU5DWV9MQUJFTCwgZGVwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzZXRCQm94KGlkeCkge1xuICAgIGlmICh0aGlzLiNwZW5kaW5nQkJveElkeCAhPT0gaWR4KSB7XG4gICAgICB0aGlzLiNwZW5kaW5nQkJveElkeCA9IGlkeDtcbiAgICAgIHRoaXMuI3BlbmRpbmdCQm94WzBdID0gSW5maW5pdHk7XG4gICAgICB0aGlzLiNwZW5kaW5nQkJveFsxXSA9IEluZmluaXR5O1xuICAgICAgdGhpcy4jcGVuZGluZ0JCb3hbMl0gPSAtSW5maW5pdHk7XG4gICAgICB0aGlzLiNwZW5kaW5nQkJveFszXSA9IC1JbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkQ2xpcEJveChpZHgsIGN0eCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IFV0aWwubXVsdGlwbHlCeURPTU1hdHJpeCh0aGlzLiNiYXNlVHJhbnNmb3JtU3RhY2suYXQoLTEpLCBjdHguZ2V0VHJhbnNmb3JtKCkpO1xuICAgIGNvbnN0IGNsaXBCb3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0sIHRyYW5zZm9ybSwgY2xpcEJveCk7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uID0gVXRpbC5pbnRlcnNlY3QodGhpcy4jY2xpcEJveCwgY2xpcEJveCk7XG4gICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgdGhpcy4jY2xpcEJveFswXSA9IGludGVyc2VjdGlvblswXTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMV0gPSBpbnRlcnNlY3Rpb25bMV07XG4gICAgICB0aGlzLiNjbGlwQm94WzJdID0gaW50ZXJzZWN0aW9uWzJdO1xuICAgICAgdGhpcy4jY2xpcEJveFszXSA9IGludGVyc2VjdGlvblszXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jY2xpcEJveFswXSA9IHRoaXMuI2NsaXBCb3hbMV0gPSBJbmZpbml0eTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMl0gPSB0aGlzLiNjbGlwQm94WzNdID0gLUluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRCQm94KGlkeCwgY3R4LCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XG4gICAgY29uc3QgY2xpcEJveCA9IHRoaXMuI2NsaXBCb3g7XG4gICAgaWYgKGNsaXBCb3hbMF0gPT09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgdHJhbnNmb3JtID0gVXRpbC5tdWx0aXBseUJ5RE9NTWF0cml4KHRoaXMuI2Jhc2VUcmFuc2Zvcm1TdGFjay5hdCgtMSksIGN0eC5nZXRUcmFuc2Zvcm0oKSk7XG4gICAgaWYgKGNsaXBCb3hbMF0gPT09IC1JbmZpbml0eSkge1xuICAgICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0sIHRyYW5zZm9ybSwgdGhpcy4jcGVuZGluZ0JCb3gpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IGJib3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0sIHRyYW5zZm9ybSwgYmJveCk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMF0gPSBNYXRoLm1pbih0aGlzLiNwZW5kaW5nQkJveFswXSwgTWF0aC5tYXgoYmJveFswXSwgY2xpcEJveFswXSkpO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzFdID0gTWF0aC5taW4odGhpcy4jcGVuZGluZ0JCb3hbMV0sIE1hdGgubWF4KGJib3hbMV0sIGNsaXBCb3hbMV0pKTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFsyXSA9IE1hdGgubWF4KHRoaXMuI3BlbmRpbmdCQm94WzJdLCBNYXRoLm1pbihiYm94WzJdLCBjbGlwQm94WzJdKSk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbM10gPSBNYXRoLm1heCh0aGlzLiNwZW5kaW5nQkJveFszXSwgTWF0aC5taW4oYmJveFszXSwgY2xpcEJveFszXSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZENoYXJhY3RlckJCb3goaWR4LCBjdHgsIGZvbnQsIHNjYWxlID0gMSwgeCA9IDAsIHkgPSAwLCBnZXRNZWFzdXJlKSB7XG4gICAgY29uc3QgZm9udEJCb3ggPSBmb250LmJib3g7XG4gICAgbGV0IGlzQkJveFRydXN0d29ydGh5O1xuICAgIGxldCBjb21wdXRlZEJCb3g7XG4gICAgaWYgKGZvbnRCQm94KSB7XG4gICAgICBpc0JCb3hUcnVzdHdvcnRoeSA9IGZvbnRCQm94WzJdICE9PSBmb250QkJveFswXSAmJiBmb250QkJveFszXSAhPT0gZm9udEJCb3hbMV0gJiYgdGhpcy4jZm9udEJCb3hUcnVzdHdvcnRoeS5nZXQoZm9udCk7XG4gICAgICBpZiAoaXNCQm94VHJ1c3R3b3J0aHkgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbXB1dGVkQkJveCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChmb250QkJveCwgZm9udC5mb250TWF0cml4LCBjb21wdXRlZEJCb3gpO1xuICAgICAgICBpZiAoc2NhbGUgIT09IDEgfHwgeCAhPT0gMCB8fCB5ICE9PSAwKSB7XG4gICAgICAgICAgVXRpbC5zY2FsZU1pbk1heChbc2NhbGUsIDAsIDAsIC1zY2FsZSwgeCwgeV0sIGNvbXB1dGVkQkJveCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQkJveFRydXN0d29ydGh5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVjb3JkQkJveChpZHgsIGN0eCwgY29tcHV0ZWRCQm94WzBdLCBjb21wdXRlZEJCb3hbMl0sIGNvbXB1dGVkQkJveFsxXSwgY29tcHV0ZWRCQm94WzNdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWdldE1lYXN1cmUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlY29yZEZ1bGxQYWdlQkJveChpZHgpO1xuICAgIH1cbiAgICBjb25zdCBtZWFzdXJlID0gZ2V0TWVhc3VyZSgpO1xuICAgIGlmIChmb250QkJveCAmJiBjb21wdXRlZEJCb3ggJiYgaXNCQm94VHJ1c3R3b3J0aHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaXNCQm94VHJ1c3R3b3J0aHkgPSBjb21wdXRlZEJCb3hbMF0gPD0geCAtIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hMZWZ0ICYmIGNvbXB1dGVkQkJveFsyXSA+PSB4ICsgbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0ICYmIGNvbXB1dGVkQkJveFsxXSA8PSB5IC0gbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCAmJiBjb21wdXRlZEJCb3hbM10gPj0geSArIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgICAgdGhpcy4jZm9udEJCb3hUcnVzdHdvcnRoeS5zZXQoZm9udCwgaXNCQm94VHJ1c3R3b3J0aHkpO1xuICAgICAgaWYgKGlzQkJveFRydXN0d29ydGh5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY29yZEJCb3goaWR4LCBjdHgsIGNvbXB1dGVkQkJveFswXSwgY29tcHV0ZWRCQm94WzJdLCBjb21wdXRlZEJCb3hbMV0sIGNvbXB1dGVkQkJveFszXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlY29yZEJCb3goaWR4LCBjdHgsIHggLSBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94TGVmdCwgeCArIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hSaWdodCwgeSAtIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsIHkgKyBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCk7XG4gIH1cbiAgcmVjb3JkRnVsbFBhZ2VCQm94KGlkeCkge1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzBdID0gTWF0aC5tYXgoMCwgdGhpcy4jY2xpcEJveFswXSk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMV0gPSBNYXRoLm1heCgwLCB0aGlzLiNjbGlwQm94WzFdKTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFsyXSA9IE1hdGgubWluKHRoaXMuI2NhbnZhc1dpZHRoLCB0aGlzLiNjbGlwQm94WzJdKTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFszXSA9IE1hdGgubWluKHRoaXMuI2NhbnZhc0hlaWdodCwgdGhpcy4jY2xpcEJveFszXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0U2ltcGxlSW5kZXgoZGVwZW5kZW5jeU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy4jc2ltcGxlW2RlcGVuZGVuY3lOYW1lXTtcbiAgfVxuICByZWNvcmREZXBlbmRlbmNpZXMoaWR4LCBkZXBlbmRlbmN5TmFtZXMpIHtcbiAgICBjb25zdCBwZW5kaW5nRGVwZW5kZW5jaWVzID0gdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcztcbiAgICBjb25zdCBzaW1wbGUgPSB0aGlzLiNzaW1wbGU7XG4gICAgY29uc3QgaW5jcmVtZW50YWwgPSB0aGlzLiNpbmNyZW1lbnRhbDtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZGVwZW5kZW5jeU5hbWVzKSB7XG4gICAgICBpZiAobmFtZSBpbiB0aGlzLiNzaW1wbGUpIHtcbiAgICAgICAgcGVuZGluZ0RlcGVuZGVuY2llcy5hZGQoc2ltcGxlW25hbWVdKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSBpbiBpbmNyZW1lbnRhbCkge1xuICAgICAgICBpbmNyZW1lbnRhbFtuYW1lXS5mb3JFYWNoKHBlbmRpbmdEZXBlbmRlbmNpZXMuYWRkLCBwZW5kaW5nRGVwZW5kZW5jaWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkTmFtZWREZXBlbmRlbmN5KGlkeCwgbmFtZSkge1xuICAgIGlmICh0aGlzLiNuYW1lZERlcGVuZGVuY2llcy5oYXMobmFtZSkpIHtcbiAgICAgIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMuYWRkKHRoaXMuI25hbWVkRGVwZW5kZW5jaWVzLmdldChuYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE9wZXJhdGlvbihpZHgsIHByZXNlcnZlID0gZmFsc2UpIHtcbiAgICB0aGlzLnJlY29yZERlcGVuZGVuY2llcyhpZHgsIFtGT1JDRURfREVQRU5ERU5DWV9MQUJFTF0pO1xuICAgIGlmICh0aGlzLiNkZWJ1Z01ldGFkYXRhKSB7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGVuc3VyZURlYnVnTWV0YWRhdGEodGhpcy4jZGVidWdNZXRhZGF0YSwgaWR4KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGVwZW5kZW5jaWVzXG4gICAgICB9ID0gbWV0YWRhdGE7XG4gICAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzLmZvckVhY2goZGVwZW5kZW5jaWVzLmFkZCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIHRoaXMuI3NhdmVzU3RhY2suZm9yRWFjaChkZXBlbmRlbmNpZXMuYWRkLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgdGhpcy4jbWFya2VkQ29udGVudFN0YWNrLmZvckVhY2goZGVwZW5kZW5jaWVzLmFkZCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIGRlcGVuZGVuY2llcy5kZWxldGUoaWR4KTtcbiAgICAgIG1ldGFkYXRhLmlzUmVuZGVyaW5nT3BlcmF0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BlbmRpbmdCQm94SWR4ID09PSBpZHgpIHtcbiAgICAgIGNvbnN0IG1pblggPSBmbG9vcih0aGlzLiNwZW5kaW5nQkJveFswXSAqIDI1NiAvIHRoaXMuI2NhbnZhc1dpZHRoKTtcbiAgICAgIGNvbnN0IG1pblkgPSBmbG9vcih0aGlzLiNwZW5kaW5nQkJveFsxXSAqIDI1NiAvIHRoaXMuI2NhbnZhc0hlaWdodCk7XG4gICAgICBjb25zdCBtYXhYID0gY2VpbCh0aGlzLiNwZW5kaW5nQkJveFsyXSAqIDI1NiAvIHRoaXMuI2NhbnZhc1dpZHRoKTtcbiAgICAgIGNvbnN0IG1heFkgPSBjZWlsKHRoaXMuI3BlbmRpbmdCQm94WzNdICogMjU2IC8gdGhpcy4jY2FudmFzSGVpZ2h0KTtcbiAgICAgIGV4cGFuZEJCb3godGhpcy4jYmJveGVzQ29vcmRzLCBpZHgsIG1pblgsIG1pblksIG1heFgsIG1heFkpO1xuICAgICAgZm9yIChjb25zdCBkZXBJZHggb2YgdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoZGVwSWR4ICE9PSBpZHgpIHtcbiAgICAgICAgICBleHBhbmRCQm94KHRoaXMuI2Jib3hlc0Nvb3JkcywgZGVwSWR4LCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzYXZlSWR4IG9mIHRoaXMuI3NhdmVzU3RhY2spIHtcbiAgICAgICAgaWYgKHNhdmVJZHggIT09IGlkeCkge1xuICAgICAgICAgIGV4cGFuZEJCb3godGhpcy4jYmJveGVzQ29vcmRzLCBzYXZlSWR4LCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzYXZlSWR4IG9mIHRoaXMuI21hcmtlZENvbnRlbnRTdGFjaykge1xuICAgICAgICBpZiAoc2F2ZUlkeCAhPT0gaWR4KSB7XG4gICAgICAgICAgZXhwYW5kQkJveCh0aGlzLiNiYm94ZXNDb29yZHMsIHNhdmVJZHgsIG1pblgsIG1pblksIG1heFgsIG1heFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0JCb3hJZHggPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkU2hvd1RleHRPcGVyYXRpb24oaWR4LCBwcmVzZXJ2ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgZGVwcyA9IEFycmF5LmZyb20odGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcyk7XG4gICAgdGhpcy5yZWNvcmRPcGVyYXRpb24oaWR4LCBwcmVzZXJ2ZSk7XG4gICAgdGhpcy5yZWNvcmRJbmNyZW1lbnRhbERhdGEoXCJzYW1lTGluZVRleHRcIiwgaWR4KTtcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XG4gICAgICB0aGlzLnJlY29yZEluY3JlbWVudGFsRGF0YShcInNhbWVMaW5lVGV4dFwiLCBkZXApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiYm94VG9DbGlwQm94RHJvcE9wZXJhdGlvbihpZHgsIHByZXNlcnZlID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy4jcGVuZGluZ0JCb3hJZHggPT09IGlkeCkge1xuICAgICAgdGhpcy4jcGVuZGluZ0JCb3hJZHggPSAtMTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMF0gPSBNYXRoLm1heCh0aGlzLiNjbGlwQm94WzBdLCB0aGlzLiNwZW5kaW5nQkJveFswXSk7XG4gICAgICB0aGlzLiNjbGlwQm94WzFdID0gTWF0aC5tYXgodGhpcy4jY2xpcEJveFsxXSwgdGhpcy4jcGVuZGluZ0JCb3hbMV0pO1xuICAgICAgdGhpcy4jY2xpcEJveFsyXSA9IE1hdGgubWluKHRoaXMuI2NsaXBCb3hbMl0sIHRoaXMuI3BlbmRpbmdCQm94WzJdKTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbM10gPSBNYXRoLm1pbih0aGlzLiNjbGlwQm94WzNdLCB0aGlzLiNwZW5kaW5nQkJveFszXSk7XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX3Rha2VQZW5kaW5nRGVwZW5kZW5jaWVzKCkge1xuICAgIGNvbnN0IHBlbmRpbmdEZXBlbmRlbmNpZXMgPSB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzO1xuICAgIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCk7XG4gICAgcmV0dXJuIHBlbmRpbmdEZXBlbmRlbmNpZXM7XG4gIH1cbiAgX2V4dHJhY3RPcGVyYXRpb24oaWR4KSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy4jb3BlcmF0aW9ucy5nZXQoaWR4KTtcbiAgICB0aGlzLiNvcGVyYXRpb25zLmRlbGV0ZShpZHgpO1xuICAgIHJldHVybiBvcGVyYXRpb247XG4gIH1cbiAgX3B1c2hQZW5kaW5nRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcykge1xuICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcy5hZGQoZGVwKTtcbiAgICB9XG4gIH1cbiAgdGFrZSgpIHtcbiAgICB0aGlzLiNmb250QkJveFRydXN0d29ydGh5LmNsZWFyKCk7XG4gICAgcmV0dXJuIG5ldyBCQm94UmVhZGVyKHRoaXMuI2Jib3hlcywgdGhpcy4jYmJveGVzQ29vcmRzKTtcbiAgfVxuICB0YWtlRGVidWdNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVidWdNZXRhZGF0YTtcbiAgfVxufVxuY2xhc3MgQ2FudmFzTmVzdGVkRGVwZW5kZW5jeVRyYWNrZXIge1xuICAjZGVwZW5kZW5jeVRyYWNrZXI7XG4gICNvcElkeDtcbiAgI2lnbm9yZUJCb3hlcztcbiAgI25lc3RpbmdMZXZlbCA9IDA7XG4gICNzYXZlc0xldmVsID0gMDtcbiAgY29uc3RydWN0b3IoZGVwZW5kZW5jeVRyYWNrZXIsIG9wSWR4LCBpZ25vcmVCQm94ZXMpIHtcbiAgICBpZiAoZGVwZW5kZW5jeVRyYWNrZXIgaW5zdGFuY2VvZiBDYW52YXNOZXN0ZWREZXBlbmRlbmN5VHJhY2tlciAmJiBkZXBlbmRlbmN5VHJhY2tlci4jaWdub3JlQkJveGVzID09PSAhIWlnbm9yZUJCb3hlcykge1xuICAgICAgcmV0dXJuIGRlcGVuZGVuY3lUcmFja2VyO1xuICAgIH1cbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlciA9IGRlcGVuZGVuY3lUcmFja2VyO1xuICAgIHRoaXMuI29wSWR4ID0gb3BJZHg7XG4gICAgdGhpcy4jaWdub3JlQkJveGVzID0gISFpZ25vcmVCQm94ZXM7XG4gIH1cbiAgZ3Jvd09wZXJhdGlvbnNDb3VudCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZVwiKTtcbiAgfVxuICBzYXZlKG9wSWR4KSB7XG4gICAgdGhpcy4jc2F2ZXNMZXZlbCsrO1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnNhdmUodGhpcy4jb3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc3RvcmUob3BJZHgpIHtcbiAgICBpZiAodGhpcy4jc2F2ZXNMZXZlbCA+IDApIHtcbiAgICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlc3RvcmUodGhpcy4jb3BJZHgpO1xuICAgICAgdGhpcy4jc2F2ZXNMZXZlbC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRPcGVuTWFya2VyKGlkeCkge1xuICAgIHRoaXMuI25lc3RpbmdMZXZlbCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldE9wZW5NYXJrZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI25lc3RpbmdMZXZlbCA+IDAgPyB0aGlzLiNvcElkeCA6IHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLmdldE9wZW5NYXJrZXIoKTtcbiAgfVxuICByZWNvcmRDbG9zZU1hcmtlcihpZHgpIHtcbiAgICB0aGlzLiNuZXN0aW5nTGV2ZWwtLTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiZWdpbk1hcmtlZENvbnRlbnQob3BJZHgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBlbmRNYXJrZWRDb250ZW50KG9wSWR4KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcHVzaEJhc2VUcmFuc2Zvcm0oY3R4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucHVzaEJhc2VUcmFuc2Zvcm0oY3R4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwb3BCYXNlVHJhbnNmb3JtKCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnBvcEJhc2VUcmFuc2Zvcm0oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRTaW1wbGVEYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZFNpbXBsZURhdGEobmFtZSwgdGhpcy4jb3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEluY3JlbWVudGFsRGF0YShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRJbmNyZW1lbnRhbERhdGEobmFtZSwgdGhpcy4jb3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2V0SW5jcmVtZW50YWxEYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlc2V0SW5jcmVtZW50YWxEYXRhKG5hbWUsIHRoaXMuI29wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmROYW1lZERhdGEobmFtZSwgaWR4KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkU2ltcGxlRGF0YUZyb21OYW1lZChuYW1lLCBkZXBOYW1lLCBmYWxsYmFja0lkeCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZFNpbXBsZURhdGFGcm9tTmFtZWQobmFtZSwgZGVwTmFtZSwgdGhpcy4jb3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3kobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShuYW1lLCB0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW5oZXJpdFNpbXBsZURhdGFBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcyhuYW1lcykge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLmluaGVyaXRTaW1wbGVEYXRhQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMobmFtZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGluaGVyaXRQZW5kaW5nRGVwZW5kZW5jaWVzQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMoKSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuaW5oZXJpdFBlbmRpbmdEZXBlbmRlbmNpZXNBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2V0QkJveChpZHgpIHtcbiAgICBpZiAoIXRoaXMuI2lnbm9yZUJCb3hlcykge1xuICAgICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVzZXRCQm94KHRoaXMuI29wSWR4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkQ2xpcEJveChpZHgsIGN0eCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xuICAgIGlmICghdGhpcy4jaWdub3JlQkJveGVzKSB7XG4gICAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRDbGlwQm94KHRoaXMuI29wSWR4LCBjdHgsIG1pblgsIG1heFgsIG1pblksIG1heFkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRCQm94KGlkeCwgY3R4LCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XG4gICAgaWYgKCF0aGlzLiNpZ25vcmVCQm94ZXMpIHtcbiAgICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZEJCb3godGhpcy4jb3BJZHgsIGN0eCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZENoYXJhY3RlckJCb3goaWR4LCBjdHgsIGZvbnQsIHNjYWxlLCB4LCB5LCBnZXRNZWFzdXJlKSB7XG4gICAgaWYgKCF0aGlzLiNpZ25vcmVCQm94ZXMpIHtcbiAgICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZENoYXJhY3RlckJCb3godGhpcy4jb3BJZHgsIGN0eCwgZm9udCwgc2NhbGUsIHgsIHksIGdldE1lYXN1cmUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRGdWxsUGFnZUJCb3goaWR4KSB7XG4gICAgaWYgKCF0aGlzLiNpZ25vcmVCQm94ZXMpIHtcbiAgICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZEZ1bGxQYWdlQkJveCh0aGlzLiNvcElkeCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldFNpbXBsZUluZGV4KGRlcGVuZGVuY3lOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLmdldFNpbXBsZUluZGV4KGRlcGVuZGVuY3lOYW1lKTtcbiAgfVxuICByZWNvcmREZXBlbmRlbmNpZXMoaWR4LCBkZXBlbmRlbmN5TmFtZXMpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmREZXBlbmRlbmNpZXModGhpcy4jb3BJZHgsIGRlcGVuZGVuY3lOYW1lcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkTmFtZWREZXBlbmRlbmN5KGlkeCwgbmFtZSkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZE5hbWVkRGVwZW5kZW5jeSh0aGlzLiNvcElkeCwgbmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkT3BlcmF0aW9uKGlkeCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZE9wZXJhdGlvbih0aGlzLiNvcElkeCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkU2hvd1RleHRPcGVyYXRpb24oaWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkU2hvd1RleHRPcGVyYXRpb24odGhpcy4jb3BJZHgsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGJib3hUb0NsaXBCb3hEcm9wT3BlcmF0aW9uKGlkeCkge1xuICAgIGlmICghdGhpcy4jaWdub3JlQkJveGVzKSB7XG4gICAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5iYm94VG9DbGlwQm94RHJvcE9wZXJhdGlvbih0aGlzLiNvcElkeCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRha2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWFjaGFibGVcIik7XG4gIH1cbiAgdGFrZURlYnVnTWV0YWRhdGEoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWFjaGFibGVcIik7XG4gIH1cbn1cbmNvbnN0IERlcGVuZGVuY2llcyA9IHtcbiAgc3Ryb2tlOiBbXCJwYXRoXCIsIFwidHJhbnNmb3JtXCIsIFwiZmlsdGVyXCIsIFwic3Ryb2tlQ29sb3JcIiwgXCJzdHJva2VBbHBoYVwiLCBcImxpbmVXaWR0aFwiLCBcImxpbmVDYXBcIiwgXCJsaW5lSm9pblwiLCBcIm1pdGVyTGltaXRcIiwgXCJkYXNoXCJdLFxuICBmaWxsOiBbXCJwYXRoXCIsIFwidHJhbnNmb3JtXCIsIFwiZmlsdGVyXCIsIFwiZmlsbENvbG9yXCIsIFwiZmlsbEFscGhhXCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIFwiU01hc2tcIl0sXG4gIGltYWdlWE9iamVjdDogW1widHJhbnNmb3JtXCIsIFwiU01hc2tcIiwgXCJmaWx0ZXJcIiwgXCJmaWxsQWxwaGFcIiwgXCJzdHJva2VBbHBoYVwiLCBcImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblwiXSxcbiAgcmF3RmlsbFBhdGg6IFtcImZpbHRlclwiLCBcImZpbGxDb2xvclwiLCBcImZpbGxBbHBoYVwiXSxcbiAgc2hvd1RleHQ6IFtcInRyYW5zZm9ybVwiLCBcImxlYWRpbmdcIiwgXCJjaGFyU3BhY2luZ1wiLCBcIndvcmRTcGFjaW5nXCIsIFwiaFNjYWxlXCIsIFwidGV4dFJpc2VcIiwgXCJtb3ZlVGV4dFwiLCBcInRleHRNYXRyaXhcIiwgXCJmb250XCIsIFwiZm9udE9ialwiLCBcImZpbHRlclwiLCBcImZpbGxDb2xvclwiLCBcInRleHRSZW5kZXJpbmdNb2RlXCIsIFwiU01hc2tcIiwgXCJmaWxsQWxwaGFcIiwgXCJzdHJva2VBbHBoYVwiLCBcImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblwiLCBcInNhbWVMaW5lVGV4dFwiXSxcbiAgdHJhbnNmb3JtOiBbXCJ0cmFuc2Zvcm1cIl0sXG4gIHRyYW5zZm9ybUFuZEZpbGw6IFtcInRyYW5zZm9ybVwiLCBcImZpbGxDb2xvclwiXVxufTtcblxuOy8vIC4vc3JjL2Rpc3BsYXkvcGF0dGVybl9oZWxwZXIuanNcblxuXG5cblxuXG5cbmNvbnN0IFBhdGhUeXBlID0ge1xuICBGSUxMOiBcIkZpbGxcIixcbiAgU1RST0tFOiBcIlN0cm9rZVwiLFxuICBTSEFESU5HOiBcIlNoYWRpbmdcIlxufTtcbmZ1bmN0aW9uIGFwcGx5Qm91bmRpbmdCb3goY3R4LCBiYm94KSB7XG4gIGlmICghYmJveCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICBjb25zdCBoZWlnaHQgPSBiYm94WzNdIC0gYmJveFsxXTtcbiAgY29uc3QgcmVnaW9uID0gbmV3IFBhdGgyRCgpO1xuICByZWdpb24ucmVjdChiYm94WzBdLCBiYm94WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY3R4LmNsaXAocmVnaW9uKTtcbn1cbmNsYXNzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGlzTW9kaWZ5aW5nQ3VycmVudFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0UGF0dGVybigpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgZ2V0UGF0dGVybmAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKElSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl90eXBlID0gSVJbMV07XG4gICAgdGhpcy5fYmJveCA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9yU3RvcHMgPSBJUlszXTtcbiAgICB0aGlzLl9wMCA9IElSWzRdO1xuICAgIHRoaXMuX3AxID0gSVJbNV07XG4gICAgdGhpcy5fcjAgPSBJUls2XTtcbiAgICB0aGlzLl9yMSA9IElSWzddO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlR3JhZGllbnQoY3R4KSB7XG4gICAgbGV0IGdyYWQ7XG4gICAgaWYgKHRoaXMuX3R5cGUgPT09IFwiYXhpYWxcIikge1xuICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLl9wMFswXSwgdGhpcy5fcDBbMV0sIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBcInJhZGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcjAsIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSwgdGhpcy5fcjEpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbG9yU3RvcCBvZiB0aGlzLl9jb2xvclN0b3BzKSB7XG4gICAgICBncmFkLmFkZENvbG9yU3RvcChjb2xvclN0b3BbMF0sIGNvbG9yU3RvcFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBncmFkO1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNUUk9LRSB8fCBwYXRoVHlwZSA9PT0gUGF0aFR5cGUuRklMTCkge1xuICAgICAgY29uc3Qgb3duZXJCQm94ID0gb3duZXIuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlLCBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCkpIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKG93bmVyQkJveFsyXSAtIG93bmVyQkJveFswXSkgfHwgMTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChvd25lckJCb3hbM10gLSBvd25lckJCb3hbMV0pIHx8IDE7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICB0bXBDdHguY2xlYXJSZWN0KDAsIDAsIHRtcEN0eC5jYW52YXMud2lkdGgsIHRtcEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRtcEN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRtcEN0eC5yZWN0KDAsIDAsIHRtcEN0eC5jYW52YXMud2lkdGgsIHRtcEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRtcEN0eC50cmFuc2xhdGUoLW93bmVyQkJveFswXSwgLW93bmVyQkJveFsxXSk7XG4gICAgICBpbnZlcnNlID0gVXRpbC50cmFuc2Zvcm0oaW52ZXJzZSwgWzEsIDAsIDAsIDEsIG93bmVyQkJveFswXSwgb3duZXJCQm94WzFdXSk7XG4gICAgICB0bXBDdHgudHJhbnNmb3JtKC4uLm93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIHRtcEN0eC50cmFuc2Zvcm0oLi4udGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgICAgYXBwbHlCb3VuZGluZ0JveCh0bXBDdHgsIHRoaXMuX2Jib3gpO1xuICAgICAgdG1wQ3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NyZWF0ZUdyYWRpZW50KHRtcEN0eCk7XG4gICAgICB0bXBDdHguZmlsbCgpO1xuICAgICAgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRtcENhbnZhcy5jYW52YXMsIFwibm8tcmVwZWF0XCIpO1xuICAgICAgY29uc3QgZG9tTWF0cml4ID0gbmV3IERPTU1hdHJpeChpbnZlcnNlKTtcbiAgICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKGRvbU1hdHJpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGx5Qm91bmRpbmdCb3goY3R4LCB0aGlzLl9iYm94KTtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLl9jcmVhdGVHcmFkaWVudChjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxufVxuZnVuY3Rpb24gZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHAxLCBwMiwgcDMsIGMxLCBjMiwgYzMpIHtcbiAgY29uc3QgY29vcmRzID0gY29udGV4dC5jb29yZHMsXG4gICAgY29sb3JzID0gY29udGV4dC5jb2xvcnM7XG4gIGNvbnN0IGJ5dGVzID0gZGF0YS5kYXRhLFxuICAgIHJvd1NpemUgPSBkYXRhLndpZHRoICogNDtcbiAgbGV0IHRtcDtcbiAgaWYgKGNvb3Jkc1twMSArIDFdID4gY29vcmRzW3AyICsgMV0pIHtcbiAgICB0bXAgPSBwMTtcbiAgICBwMSA9IHAyO1xuICAgIHAyID0gdG1wO1xuICAgIHRtcCA9IGMxO1xuICAgIGMxID0gYzI7XG4gICAgYzIgPSB0bXA7XG4gIH1cbiAgaWYgKGNvb3Jkc1twMiArIDFdID4gY29vcmRzW3AzICsgMV0pIHtcbiAgICB0bXAgPSBwMjtcbiAgICBwMiA9IHAzO1xuICAgIHAzID0gdG1wO1xuICAgIHRtcCA9IGMyO1xuICAgIGMyID0gYzM7XG4gICAgYzMgPSB0bXA7XG4gIH1cbiAgaWYgKGNvb3Jkc1twMSArIDFdID4gY29vcmRzW3AyICsgMV0pIHtcbiAgICB0bXAgPSBwMTtcbiAgICBwMSA9IHAyO1xuICAgIHAyID0gdG1wO1xuICAgIHRtcCA9IGMxO1xuICAgIGMxID0gYzI7XG4gICAgYzIgPSB0bXA7XG4gIH1cbiAgY29uc3QgeDEgPSAoY29vcmRzW3AxXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTEgPSAoY29vcmRzW3AxICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGNvbnN0IHgyID0gKGNvb3Jkc1twMl0gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkyID0gKGNvb3Jkc1twMiArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBjb25zdCB4MyA9IChjb29yZHNbcDNdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MyA9IChjb29yZHNbcDMgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgaWYgKHkxID49IHkzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGMxciA9IGNvbG9yc1tjMV0sXG4gICAgYzFnID0gY29sb3JzW2MxICsgMV0sXG4gICAgYzFiID0gY29sb3JzW2MxICsgMl07XG4gIGNvbnN0IGMyciA9IGNvbG9yc1tjMl0sXG4gICAgYzJnID0gY29sb3JzW2MyICsgMV0sXG4gICAgYzJiID0gY29sb3JzW2MyICsgMl07XG4gIGNvbnN0IGMzciA9IGNvbG9yc1tjM10sXG4gICAgYzNnID0gY29sb3JzW2MzICsgMV0sXG4gICAgYzNiID0gY29sb3JzW2MzICsgMl07XG4gIGNvbnN0IG1pblkgPSBNYXRoLnJvdW5kKHkxKSxcbiAgICBtYXhZID0gTWF0aC5yb3VuZCh5Myk7XG4gIGxldCB4YSwgY2FyLCBjYWcsIGNhYjtcbiAgbGV0IHhiLCBjYnIsIGNiZywgY2JiO1xuICBmb3IgKGxldCB5ID0gbWluWTsgeSA8PSBtYXhZOyB5KyspIHtcbiAgICBpZiAoeSA8IHkyKSB7XG4gICAgICBjb25zdCBrID0geSA8IHkxID8gMCA6ICh5MSAtIHkpIC8gKHkxIC0geTIpO1xuICAgICAgeGEgPSB4MSAtICh4MSAtIHgyKSAqIGs7XG4gICAgICBjYXIgPSBjMXIgLSAoYzFyIC0gYzJyKSAqIGs7XG4gICAgICBjYWcgPSBjMWcgLSAoYzFnIC0gYzJnKSAqIGs7XG4gICAgICBjYWIgPSBjMWIgLSAoYzFiIC0gYzJiKSAqIGs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBrO1xuICAgICAgaWYgKHkgPiB5Mykge1xuICAgICAgICBrID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoeTIgPT09IHkzKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayA9ICh5MiAtIHkpIC8gKHkyIC0geTMpO1xuICAgICAgfVxuICAgICAgeGEgPSB4MiAtICh4MiAtIHgzKSAqIGs7XG4gICAgICBjYXIgPSBjMnIgLSAoYzJyIC0gYzNyKSAqIGs7XG4gICAgICBjYWcgPSBjMmcgLSAoYzJnIC0gYzNnKSAqIGs7XG4gICAgICBjYWIgPSBjMmIgLSAoYzJiIC0gYzNiKSAqIGs7XG4gICAgfVxuICAgIGxldCBrO1xuICAgIGlmICh5IDwgeTEpIHtcbiAgICAgIGsgPSAwO1xuICAgIH0gZWxzZSBpZiAoeSA+IHkzKSB7XG4gICAgICBrID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgayA9ICh5MSAtIHkpIC8gKHkxIC0geTMpO1xuICAgIH1cbiAgICB4YiA9IHgxIC0gKHgxIC0geDMpICogaztcbiAgICBjYnIgPSBjMXIgLSAoYzFyIC0gYzNyKSAqIGs7XG4gICAgY2JnID0gYzFnIC0gKGMxZyAtIGMzZykgKiBrO1xuICAgIGNiYiA9IGMxYiAtIChjMWIgLSBjM2IpICogaztcbiAgICBjb25zdCB4MV8gPSBNYXRoLnJvdW5kKE1hdGgubWluKHhhLCB4YikpO1xuICAgIGNvbnN0IHgyXyA9IE1hdGgucm91bmQoTWF0aC5tYXgoeGEsIHhiKSk7XG4gICAgbGV0IGogPSByb3dTaXplICogeSArIHgxXyAqIDQ7XG4gICAgZm9yIChsZXQgeCA9IHgxXzsgeCA8PSB4Ml87IHgrKykge1xuICAgICAgayA9ICh4YSAtIHgpIC8gKHhhIC0geGIpO1xuICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIGlmIChrID4gMSkge1xuICAgICAgICBrID0gMTtcbiAgICAgIH1cbiAgICAgIGJ5dGVzW2orK10gPSBjYXIgLSAoY2FyIC0gY2JyKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IGNhZyAtIChjYWcgLSBjYmcpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gY2FiIC0gKGNhYiAtIGNiYikgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSAyNTU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCkge1xuICBjb25zdCBwcyA9IGZpZ3VyZS5jb29yZHM7XG4gIGNvbnN0IGNzID0gZmlndXJlLmNvbG9ycztcbiAgbGV0IGksIGlpO1xuICBzd2l0Y2ggKGZpZ3VyZS50eXBlKSB7XG4gICAgY2FzZSBcImxhdHRpY2VcIjpcbiAgICAgIGNvbnN0IHZlcnRpY2VzUGVyUm93ID0gZmlndXJlLnZlcnRpY2VzUGVyUm93O1xuICAgICAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3IocHMubGVuZ3RoIC8gdmVydGljZXNQZXJSb3cpIC0gMTtcbiAgICAgIGNvbnN0IGNvbHMgPSB2ZXJ0aWNlc1BlclJvdyAtIDE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgIGxldCBxID0gaSAqIHZlcnRpY2VzUGVyUm93O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7IGorKywgcSsrKSB7XG4gICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3FdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3FdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1txICsgdmVydGljZXNQZXJSb3cgKyAxXSwgcHNbcSArIDFdLCBwc1txICsgdmVydGljZXNQZXJSb3ddLCBjc1txICsgdmVydGljZXNQZXJSb3cgKyAxXSwgY3NbcSArIDFdLCBjc1txICsgdmVydGljZXNQZXJSb3ddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRyaWFuZ2xlc1wiOlxuICAgICAgZm9yIChpID0gMCwgaWkgPSBwcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XG4gICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1tpXSwgcHNbaSArIDFdLCBwc1tpICsgMl0sIGNzW2ldLCBjc1tpICsgMV0sIGNzW2kgKyAyXSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBmaWd1cmVcIik7XG4gIH1cbn1cbmNsYXNzIE1lc2hTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKElSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb29yZHMgPSBJUlsyXTtcbiAgICB0aGlzLl9jb2xvcnMgPSBJUlszXTtcbiAgICB0aGlzLl9maWd1cmVzID0gSVJbNF07XG4gICAgdGhpcy5fYm91bmRzID0gSVJbNV07XG4gICAgdGhpcy5fYmJveCA9IElSWzZdO1xuICAgIHRoaXMuX2JhY2tncm91bmQgPSBJUls3XTtcbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZU1lc2hDYW52YXMoY29tYmluZWRTY2FsZSwgYmFja2dyb3VuZENvbG9yLCBjYWNoZWRDYW52YXNlcykge1xuICAgIGNvbnN0IEVYUEVDVEVEX1NDQUxFID0gMS4xO1xuICAgIGNvbnN0IE1BWF9QQVRURVJOX1NJWkUgPSAzMDAwO1xuICAgIGNvbnN0IEJPUkRFUl9TSVpFID0gMjtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5mbG9vcih0aGlzLl9ib3VuZHNbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmZsb29yKHRoaXMuX2JvdW5kc1sxXSk7XG4gICAgY29uc3QgYm91bmRzV2lkdGggPSBNYXRoLmNlaWwodGhpcy5fYm91bmRzWzJdKSAtIG9mZnNldFg7XG4gICAgY29uc3QgYm91bmRzSGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMuX2JvdW5kc1szXSkgLSBvZmZzZXRZO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5taW4oTWF0aC5jZWlsKE1hdGguYWJzKGJvdW5kc1dpZHRoICogY29tYmluZWRTY2FsZVswXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWluKE1hdGguY2VpbChNYXRoLmFicyhib3VuZHNIZWlnaHQgKiBjb21iaW5lZFNjYWxlWzFdICogRVhQRUNURURfU0NBTEUpKSwgTUFYX1BBVFRFUk5fU0laRSk7XG4gICAgY29uc3Qgc2NhbGVYID0gYm91bmRzV2lkdGggLyB3aWR0aDtcbiAgICBjb25zdCBzY2FsZVkgPSBib3VuZHNIZWlnaHQgLyBoZWlnaHQ7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGNvb3JkczogdGhpcy5fY29vcmRzLFxuICAgICAgY29sb3JzOiB0aGlzLl9jb2xvcnMsXG4gICAgICBvZmZzZXRYOiAtb2Zmc2V0WCxcbiAgICAgIG9mZnNldFk6IC1vZmZzZXRZLFxuICAgICAgc2NhbGVYOiAxIC8gc2NhbGVYLFxuICAgICAgc2NhbGVZOiAxIC8gc2NhbGVZXG4gICAgfTtcbiAgICBjb25zdCBwYWRkZWRXaWR0aCA9IHdpZHRoICsgQk9SREVSX1NJWkUgKiAyO1xuICAgIGNvbnN0IHBhZGRlZEhlaWdodCA9IGhlaWdodCArIEJPUkRFUl9TSVpFICogMjtcbiAgICBjb25zdCB0bXBDYW52YXMgPSBjYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtZXNoXCIsIHBhZGRlZFdpZHRoLCBwYWRkZWRIZWlnaHQpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGRhdGEgPSB0bXBDdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gZGF0YS5kYXRhO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYnl0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgICBieXRlc1tpXSA9IGJhY2tncm91bmRDb2xvclswXTtcbiAgICAgICAgYnl0ZXNbaSArIDFdID0gYmFja2dyb3VuZENvbG9yWzFdO1xuICAgICAgICBieXRlc1tpICsgMl0gPSBiYWNrZ3JvdW5kQ29sb3JbMl07XG4gICAgICAgIGJ5dGVzW2kgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWd1cmUgb2YgdGhpcy5fZmlndXJlcykge1xuICAgICAgZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpO1xuICAgIH1cbiAgICB0bXBDdHgucHV0SW1hZ2VEYXRhKGRhdGEsIEJPUkRFUl9TSVpFLCBCT1JERVJfU0laRSk7XG4gICAgY29uc3QgY2FudmFzID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgb2Zmc2V0WDogb2Zmc2V0WCAtIEJPUkRFUl9TSVpFICogc2NhbGVYLFxuICAgICAgb2Zmc2V0WTogb2Zmc2V0WSAtIEJPUkRFUl9TSVpFICogc2NhbGVZLFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZXG4gICAgfTtcbiAgfVxuICBpc01vZGlmeWluZ0N1cnJlbnRUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGFwcGx5Qm91bmRpbmdCb3goY3R4LCB0aGlzLl9iYm94KTtcbiAgICBjb25zdCBzY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgaWYgKHBhdGhUeXBlID09PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSwgc2NhbGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5tYXRyaXgsIHNjYWxlKTtcbiAgICAgIGNvbnN0IFttYXRyaXhTY2FsZVgsIG1hdHJpeFNjYWxlWV0gPSBzY2FsZTtcbiAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUob3duZXIuYmFzZVRyYW5zZm9ybSwgc2NhbGUpO1xuICAgICAgc2NhbGVbMF0gKj0gbWF0cml4U2NhbGVYO1xuICAgICAgc2NhbGVbMV0gKj0gbWF0cml4U2NhbGVZO1xuICAgIH0gZWxzZSB7XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG93bmVyLmJhc2VUcmFuc2Zvcm0sIHNjYWxlKTtcbiAgICB9XG4gICAgY29uc3QgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IHRoaXMuX2NyZWF0ZU1lc2hDYW52YXMoc2NhbGUsIHBhdGhUeXBlID09PSBQYXRoVHlwZS5TSEFESU5HID8gbnVsbCA6IHRoaXMuX2JhY2tncm91bmQsIG93bmVyLmNhY2hlZENhbnZhc2VzKTtcbiAgICBpZiAocGF0aFR5cGUgIT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ub3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC50cmFuc2xhdGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFkpO1xuICAgIGN0eC5zY2FsZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVkpO1xuICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gIH1cbn1cbmNsYXNzIER1bW15U2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBnZXRQYXR0ZXJuKCkge1xuICAgIHJldHVybiBcImhvdHBpbmtcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2hhZGluZ1BhdHRlcm4oSVIpIHtcbiAgc3dpdGNoIChJUlswXSkge1xuICAgIGNhc2UgXCJSYWRpYWxBeGlhbFwiOlxuICAgICAgcmV0dXJuIG5ldyBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuKElSKTtcbiAgICBjYXNlIFwiTWVzaFwiOlxuICAgICAgcmV0dXJuIG5ldyBNZXNoU2hhZGluZ1BhdHRlcm4oSVIpO1xuICAgIGNhc2UgXCJEdW1teVwiOlxuICAgICAgcmV0dXJuIG5ldyBEdW1teVNoYWRpbmdQYXR0ZXJuKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIElSIHR5cGU6ICR7SVJbMF19YCk7XG59XG5jb25zdCBQYWludFR5cGUgPSB7XG4gIENPTE9SRUQ6IDEsXG4gIFVOQ09MT1JFRDogMlxufTtcbmNsYXNzIFRpbGluZ1BhdHRlcm4ge1xuICBzdGF0aWMgTUFYX1BBVFRFUk5fU0laRSA9IDMwMDA7XG4gIGNvbnN0cnVjdG9yKElSLCBjdHgsIGNhbnZhc0dyYXBoaWNzRmFjdG9yeSwgYmFzZVRyYW5zZm9ybSkge1xuICAgIHRoaXMuY29sb3IgPSBJUlsxXTtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IElSWzJdO1xuICAgIHRoaXMubWF0cml4ID0gSVJbM107XG4gICAgdGhpcy5iYm94ID0gSVJbNF07XG4gICAgdGhpcy54c3RlcCA9IElSWzVdO1xuICAgIHRoaXMueXN0ZXAgPSBJUls2XTtcbiAgICB0aGlzLnBhaW50VHlwZSA9IElSWzddO1xuICAgIHRoaXMudGlsaW5nVHlwZSA9IElSWzhdO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5O1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IGJhc2VUcmFuc2Zvcm07XG4gIH1cbiAgY3JlYXRlUGF0dGVybkNhbnZhcyhvd25lciwgb3BJZHgpIHtcbiAgICBjb25zdCB7XG4gICAgICBiYm94LFxuICAgICAgb3BlcmF0b3JMaXN0LFxuICAgICAgcGFpbnRUeXBlLFxuICAgICAgdGlsaW5nVHlwZSxcbiAgICAgIGNvbG9yLFxuICAgICAgY2FudmFzR3JhcGhpY3NGYWN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHhzdGVwLFxuICAgICAgeXN0ZXBcbiAgICB9ID0gdGhpcztcbiAgICB4c3RlcCA9IE1hdGguYWJzKHhzdGVwKTtcbiAgICB5c3RlcCA9IE1hdGguYWJzKHlzdGVwKTtcbiAgICBpbmZvKFwiVGlsaW5nVHlwZTogXCIgKyB0aWxpbmdUeXBlKTtcbiAgICBjb25zdCB4MCA9IGJib3hbMF0sXG4gICAgICB5MCA9IGJib3hbMV0sXG4gICAgICB4MSA9IGJib3hbMl0sXG4gICAgICB5MSA9IGJib3hbM107XG4gICAgY29uc3Qgd2lkdGggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGhlaWdodCA9IHkxIC0geTA7XG4gICAgY29uc3Qgc2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5tYXRyaXgsIHNjYWxlKTtcbiAgICBjb25zdCBbbWF0cml4U2NhbGVYLCBtYXRyaXhTY2FsZVldID0gc2NhbGU7XG4gICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLmJhc2VUcmFuc2Zvcm0sIHNjYWxlKTtcbiAgICBjb25zdCBjb21iaW5lZFNjYWxlWCA9IG1hdHJpeFNjYWxlWCAqIHNjYWxlWzBdO1xuICAgIGNvbnN0IGNvbWJpbmVkU2NhbGVZID0gbWF0cml4U2NhbGVZICogc2NhbGVbMV07XG4gICAgbGV0IGNhbnZhc1dpZHRoID0gd2lkdGgsXG4gICAgICBjYW52YXNIZWlnaHQgPSBoZWlnaHQsXG4gICAgICByZWRyYXdIb3Jpem9udGFsbHkgPSBmYWxzZSxcbiAgICAgIHJlZHJhd1ZlcnRpY2FsbHkgPSBmYWxzZTtcbiAgICBjb25zdCB4U2NhbGVkU3RlcCA9IE1hdGguY2VpbCh4c3RlcCAqIGNvbWJpbmVkU2NhbGVYKTtcbiAgICBjb25zdCB5U2NhbGVkU3RlcCA9IE1hdGguY2VpbCh5c3RlcCAqIGNvbWJpbmVkU2NhbGVZKTtcbiAgICBjb25zdCB4U2NhbGVkV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgeVNjYWxlZEhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBjb21iaW5lZFNjYWxlWSk7XG4gICAgaWYgKHhTY2FsZWRTdGVwID49IHhTY2FsZWRXaWR0aCkge1xuICAgICAgY2FudmFzV2lkdGggPSB4c3RlcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkcmF3SG9yaXpvbnRhbGx5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHlTY2FsZWRTdGVwID49IHlTY2FsZWRIZWlnaHQpIHtcbiAgICAgIGNhbnZhc0hlaWdodCA9IHlzdGVwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWRyYXdWZXJ0aWNhbGx5ID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZGlteCA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc1dpZHRoLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIGNvbWJpbmVkU2NhbGVYKTtcbiAgICBjb25zdCBkaW15ID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoY2FudmFzSGVpZ2h0LCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0LCBjb21iaW5lZFNjYWxlWSk7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVyblwiLCBkaW14LnNpemUsIGRpbXkuc2l6ZSk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgZ3JhcGhpY3MgPSBjYW52YXNHcmFwaGljc0ZhY3RvcnkuY3JlYXRlQ2FudmFzR3JhcGhpY3ModG1wQ3R4LCBvcElkeCk7XG4gICAgZ3JhcGhpY3MuZ3JvdXBMZXZlbCA9IG93bmVyLmdyb3VwTGV2ZWw7XG4gICAgdGhpcy5zZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQoZ3JhcGhpY3MsIHBhaW50VHlwZSwgY29sb3IpO1xuICAgIHRtcEN0eC50cmFuc2xhdGUoLWRpbXguc2NhbGUgKiB4MCwgLWRpbXkuc2NhbGUgKiB5MCk7XG4gICAgZ3JhcGhpY3MudHJhbnNmb3JtKDAsIGRpbXguc2NhbGUsIDAsIDAsIGRpbXkuc2NhbGUsIDAsIDApO1xuICAgIHRtcEN0eC5zYXZlKCk7XG4gICAgZ3JhcGhpY3MuZGVwZW5kZW5jeVRyYWNrZXI/LnNhdmUoKTtcbiAgICB0aGlzLmNsaXBCYm94KGdyYXBoaWNzLCB4MCwgeTAsIHgxLCB5MSk7XG4gICAgZ3JhcGhpY3MuYmFzZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oZ3JhcGhpY3MuY3R4KTtcbiAgICBncmFwaGljcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgZ3JhcGhpY3MuZW5kRHJhd2luZygpO1xuICAgIGdyYXBoaWNzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXN0b3JlKCk7XG4gICAgdG1wQ3R4LnJlc3RvcmUoKTtcbiAgICBpZiAocmVkcmF3SG9yaXpvbnRhbGx5IHx8IHJlZHJhd1ZlcnRpY2FsbHkpIHtcbiAgICAgIGNvbnN0IGltYWdlID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgIGlmIChyZWRyYXdIb3Jpem9udGFsbHkpIHtcbiAgICAgICAgY2FudmFzV2lkdGggPSB4c3RlcDtcbiAgICAgIH1cbiAgICAgIGlmIChyZWRyYXdWZXJ0aWNhbGx5KSB7XG4gICAgICAgIGNhbnZhc0hlaWdodCA9IHlzdGVwO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlteDIgPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNXaWR0aCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCBjb21iaW5lZFNjYWxlWCk7XG4gICAgICBjb25zdCBkaW15MiA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc0hlaWdodCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCwgY29tYmluZWRTY2FsZVkpO1xuICAgICAgY29uc3QgeFNpemUgPSBkaW14Mi5zaXplO1xuICAgICAgY29uc3QgeVNpemUgPSBkaW15Mi5zaXplO1xuICAgICAgY29uc3QgdG1wQ2FudmFzMiA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm4td29ya2Fyb3VuZFwiLCB4U2l6ZSwgeVNpemUpO1xuICAgICAgY29uc3QgdG1wQ3R4MiA9IHRtcENhbnZhczIuY29udGV4dDtcbiAgICAgIGNvbnN0IGlpID0gcmVkcmF3SG9yaXpvbnRhbGx5ID8gTWF0aC5mbG9vcih3aWR0aCAvIHhzdGVwKSA6IDA7XG4gICAgICBjb25zdCBqaiA9IHJlZHJhd1ZlcnRpY2FsbHkgPyBNYXRoLmZsb29yKGhlaWdodCAvIHlzdGVwKSA6IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpaTsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IGpqOyBqKyspIHtcbiAgICAgICAgICB0bXBDdHgyLmRyYXdJbWFnZShpbWFnZSwgeFNpemUgKiBpLCB5U2l6ZSAqIGosIHhTaXplLCB5U2l6ZSwgMCwgMCwgeFNpemUsIHlTaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FudmFzOiB0bXBDYW52YXMyLmNhbnZhcyxcbiAgICAgICAgc2NhbGVYOiBkaW14Mi5zY2FsZSxcbiAgICAgICAgc2NhbGVZOiBkaW15Mi5zY2FsZSxcbiAgICAgICAgb2Zmc2V0WDogeDAsXG4gICAgICAgIG9mZnNldFk6IHkwXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiB0bXBDYW52YXMuY2FudmFzLFxuICAgICAgc2NhbGVYOiBkaW14LnNjYWxlLFxuICAgICAgc2NhbGVZOiBkaW15LnNjYWxlLFxuICAgICAgb2Zmc2V0WDogeDAsXG4gICAgICBvZmZzZXRZOiB5MFxuICAgIH07XG4gIH1cbiAgZ2V0U2l6ZUFuZFNjYWxlKHN0ZXAsIHJlYWxPdXRwdXRTaXplLCBzY2FsZSkge1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heChUaWxpbmdQYXR0ZXJuLk1BWF9QQVRURVJOX1NJWkUsIHJlYWxPdXRwdXRTaXplKTtcbiAgICBsZXQgc2l6ZSA9IE1hdGguY2VpbChzdGVwICogc2NhbGUpO1xuICAgIGlmIChzaXplID49IG1heFNpemUpIHtcbiAgICAgIHNpemUgPSBtYXhTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IHNpemUgLyBzdGVwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGUsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBjbGlwQmJveChncmFwaGljcywgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBjb25zdCBiYm94V2lkdGggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGJib3hIZWlnaHQgPSB5MSAtIHkwO1xuICAgIGdyYXBoaWNzLmN0eC5yZWN0KHgwLCB5MCwgYmJveFdpZHRoLCBiYm94SGVpZ2h0KTtcbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFt4MCwgeTAsIHgxLCB5MV0sIGdldEN1cnJlbnRUcmFuc2Zvcm0oZ3JhcGhpY3MuY3R4KSwgZ3JhcGhpY3MuY3VycmVudC5taW5NYXgpO1xuICAgIGdyYXBoaWNzLmNsaXAoKTtcbiAgICBncmFwaGljcy5lbmRQYXRoKCk7XG4gIH1cbiAgc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmN0eCxcbiAgICAgIGN1cnJlbnQgPSBncmFwaGljcy5jdXJyZW50O1xuICAgIHN3aXRjaCAocGFpbnRUeXBlKSB7XG4gICAgICBjYXNlIFBhaW50VHlwZS5DT0xPUkVEOlxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZmlsbFN0eWxlLFxuICAgICAgICAgIHN0cm9rZVN0eWxlXG4gICAgICAgIH0gPSB0aGlzLmN0eDtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjdXJyZW50LmZpbGxDb2xvciA9IGZpbGxTdHlsZTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBhaW50VHlwZS5VTkNPTE9SRUQ6XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdXJyZW50LmZpbGxDb2xvciA9IGN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYFVuc3VwcG9ydGVkIHBhaW50IHR5cGU6ICR7cGFpbnRUeXBlfWApO1xuICAgIH1cbiAgfVxuICBpc01vZGlmeWluZ0N1cnJlbnRUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUsIG9wSWR4KSB7XG4gICAgbGV0IG1hdHJpeCA9IGludmVyc2U7XG4gICAgaWYgKHBhdGhUeXBlICE9PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBtYXRyaXggPSBVdGlsLnRyYW5zZm9ybShtYXRyaXgsIG93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIG1hdHJpeCA9IFV0aWwudHJhbnNmb3JtKG1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5jcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyLCBvcElkeCk7XG4gICAgbGV0IGRvbU1hdHJpeCA9IG5ldyBET01NYXRyaXgobWF0cml4KTtcbiAgICBkb21NYXRyaXggPSBkb21NYXRyaXgudHJhbnNsYXRlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRZKTtcbiAgICBkb21NYXRyaXggPSBkb21NYXRyaXguc2NhbGUoMSAvIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVYLCAxIC8gdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVkpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLmNhbnZhcywgXCJyZXBlYXRcIik7XG4gICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0oZG9tTWF0cml4KTtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxufVxuXG47Ly8gLi9zcmMvc2hhcmVkL2ltYWdlX3V0aWxzLmpzXG5cblxuXG5cblxuZnVuY3Rpb24gY29udmVydFRvUkdCQShwYXJhbXMpIHtcbiAgc3dpdGNoIChwYXJhbXMua2luZCkge1xuICAgIGNhc2UgSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHBhcmFtcyk7XG4gICAgY2FzZSBJbWFnZUtpbmQuUkdCXzI0QlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRSR0JUb1JHQkEocGFyYW1zKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHtcbiAgc3JjLFxuICBzcmNQb3MgPSAwLFxuICBkZXN0LFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBub25CbGFja0NvbG9yID0gMHhmZmZmZmZmZixcbiAgaW52ZXJzZURlY29kZSA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IGJsYWNrID0gdXRpbF9GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbiA/IDB4ZmYwMDAwMDAgOiAweDAwMDAwMGZmO1xuICBjb25zdCBbemVyb01hcHBpbmcsIG9uZU1hcHBpbmddID0gaW52ZXJzZURlY29kZSA/IFtub25CbGFja0NvbG9yLCBibGFja10gOiBbYmxhY2ssIG5vbkJsYWNrQ29sb3JdO1xuICBjb25zdCB3aWR0aEluU291cmNlID0gd2lkdGggPj4gMztcbiAgY29uc3Qgd2lkdGhSZW1haW5kZXIgPSB3aWR0aCAmIDc7XG4gIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5sZW5ndGg7XG4gIGRlc3QgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIpO1xuICBsZXQgZGVzdFBvcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBmb3IgKGNvbnN0IG1heCA9IHNyY1BvcyArIHdpZHRoSW5Tb3VyY2U7IHNyY1BvcyA8IG1heDsgc3JjUG9zKyspIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zXSA6IDI1NTtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMSA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG4gICAgaWYgKHdpZHRoUmVtYWluZGVyID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZWxlbSA9IHNyY1BvcyA8IHNyY0xlbmd0aCA/IHNyY1tzcmNQb3MrK10gOiAyNTU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aFJlbWFpbmRlcjsgaisrKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMSA8PCA3IC0gaiA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcmNQb3MsXG4gICAgZGVzdFBvc1xuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFJHQlRvUkdCQSh7XG4gIHNyYyxcbiAgc3JjUG9zID0gMCxcbiAgZGVzdCxcbiAgZGVzdFBvcyA9IDAsXG4gIHdpZHRoLFxuICBoZWlnaHRcbn0pIHtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSB3aWR0aCAqIGhlaWdodCAqIDM7XG4gIGNvbnN0IGxlbjMyID0gbGVuID4+IDI7XG4gIGNvbnN0IHNyYzMyID0gbmV3IFVpbnQzMkFycmF5KHNyYy5idWZmZXIsIHNyY1BvcywgbGVuMzIpO1xuICBpZiAoRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4pIHtcbiAgICBmb3IgKDsgaSA8IGxlbjMyIC0gMjsgaSArPSAzLCBkZXN0UG9zICs9IDQpIHtcbiAgICAgIGNvbnN0IHMxID0gc3JjMzJbaV07XG4gICAgICBjb25zdCBzMiA9IHNyYzMyW2kgKyAxXTtcbiAgICAgIGNvbnN0IHMzID0gc3JjMzJbaSArIDJdO1xuICAgICAgZGVzdFtkZXN0UG9zXSA9IHMxIHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDFdID0gczEgPj4+IDI0IHwgczIgPDwgOCB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAyXSA9IHMyID4+PiAxNiB8IHMzIDw8IDE2IHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDNdID0gczMgPj4+IDggfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaSAqIDQsIGpqID0gc3JjUG9zICsgbGVuOyBqIDwgamo7IGogKz0gMykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW2pdIHwgc3JjW2ogKyAxXSA8PCA4IHwgc3JjW2ogKyAyXSA8PCAxNiB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoOyBpIDwgbGVuMzIgLSAyOyBpICs9IDMsIGRlc3RQb3MgKz0gNCkge1xuICAgICAgY29uc3QgczEgPSBzcmMzMltpXTtcbiAgICAgIGNvbnN0IHMyID0gc3JjMzJbaSArIDFdO1xuICAgICAgY29uc3QgczMgPSBzcmMzMltpICsgMl07XG4gICAgICBkZXN0W2Rlc3RQb3NdID0gczEgfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMV0gPSBzMSA8PCAyNCB8IHMyID4+PiA4IHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDJdID0gczIgPDwgMTYgfCBzMyA+Pj4gMTYgfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgM10gPSBzMyA8PCA4IHwgMHhmZjtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGkgKiA0LCBqaiA9IHNyY1BvcyArIGxlbjsgaiA8IGpqOyBqICs9IDMpIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tqXSA8PCAyNCB8IHNyY1tqICsgMV0gPDwgMTYgfCBzcmNbaiArIDJdIDw8IDggfCAweGZmO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNyY1Bvczogc3JjUG9zICsgbGVuLFxuICAgIGRlc3RQb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGdyYXlUb1JHQkEoc3JjLCBkZXN0KSB7XG4gIGlmIChGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbikge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMSB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMTAwIHwgMHgwMDAwMDBmZjtcbiAgICB9XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvY2FudmFzLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IE1JTl9GT05UX1NJWkUgPSAxNjtcbmNvbnN0IE1BWF9GT05UX1NJWkUgPSAxMDA7XG5jb25zdCBFWEVDVVRJT05fVElNRSA9IDE1O1xuY29uc3QgRVhFQ1VUSU9OX1NURVBTID0gMTA7XG5jb25zdCBGVUxMX0NIVU5LX0hFSUdIVCA9IDE2O1xuY29uc3QgU0NBTEVfTUFUUklYID0gbmV3IERPTU1hdHJpeCgpO1xuY29uc3QgWFkgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuY29uc3QgTUlOX01BWF9JTklUID0gbmV3IEZsb2F0MzJBcnJheShbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV0pO1xuZnVuY3Rpb24gbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCBkZXN0Q3R4KSB7XG4gIGlmIChjdHguX3JlbW92ZU1pcnJvcmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRleHQgaXMgYWxyZWFkeSBmb3J3YXJkaW5nIG9wZXJhdGlvbnMuXCIpO1xuICB9XG4gIGN0eC5fX29yaWdpbmFsU2F2ZSA9IGN0eC5zYXZlO1xuICBjdHguX19vcmlnaW5hbFJlc3RvcmUgPSBjdHgucmVzdG9yZTtcbiAgY3R4Ll9fb3JpZ2luYWxSb3RhdGUgPSBjdHgucm90YXRlO1xuICBjdHguX19vcmlnaW5hbFNjYWxlID0gY3R4LnNjYWxlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZSA9IGN0eC50cmFuc2xhdGU7XG4gIGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtID0gY3R4LnRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0gPSBjdHguc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtID0gY3R4LnJlc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbENsaXAgPSBjdHguY2xpcDtcbiAgY3R4Ll9fb3JpZ2luYWxNb3ZlVG8gPSBjdHgubW92ZVRvO1xuICBjdHguX19vcmlnaW5hbExpbmVUbyA9IGN0eC5saW5lVG87XG4gIGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyA9IGN0eC5iZXppZXJDdXJ2ZVRvO1xuICBjdHguX19vcmlnaW5hbFJlY3QgPSBjdHgucmVjdDtcbiAgY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGggPSBjdHguY2xvc2VQYXRoO1xuICBjdHguX19vcmlnaW5hbEJlZ2luUGF0aCA9IGN0eC5iZWdpblBhdGg7XG4gIGN0eC5fcmVtb3ZlTWlycm9yaW5nID0gKCkgPT4ge1xuICAgIGN0eC5zYXZlID0gY3R4Ll9fb3JpZ2luYWxTYXZlO1xuICAgIGN0eC5yZXN0b3JlID0gY3R4Ll9fb3JpZ2luYWxSZXN0b3JlO1xuICAgIGN0eC5yb3RhdGUgPSBjdHguX19vcmlnaW5hbFJvdGF0ZTtcbiAgICBjdHguc2NhbGUgPSBjdHguX19vcmlnaW5hbFNjYWxlO1xuICAgIGN0eC50cmFuc2xhdGUgPSBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZTtcbiAgICBjdHgudHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxUcmFuc2Zvcm07XG4gICAgY3R4LnNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsU2V0VHJhbnNmb3JtO1xuICAgIGN0eC5yZXNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm07XG4gICAgY3R4LmNsaXAgPSBjdHguX19vcmlnaW5hbENsaXA7XG4gICAgY3R4Lm1vdmVUbyA9IGN0eC5fX29yaWdpbmFsTW92ZVRvO1xuICAgIGN0eC5saW5lVG8gPSBjdHguX19vcmlnaW5hbExpbmVUbztcbiAgICBjdHguYmV6aWVyQ3VydmVUbyA9IGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbztcbiAgICBjdHgucmVjdCA9IGN0eC5fX29yaWdpbmFsUmVjdDtcbiAgICBjdHguY2xvc2VQYXRoID0gY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGg7XG4gICAgY3R4LmJlZ2luUGF0aCA9IGN0eC5fX29yaWdpbmFsQmVnaW5QYXRoO1xuICAgIGRlbGV0ZSBjdHguX3JlbW92ZU1pcnJvcmluZztcbiAgfTtcbiAgY3R4LnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5zYXZlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsU2F2ZSgpO1xuICB9O1xuICBjdHgucmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZXN0b3JlKCk7XG4gIH07XG4gIGN0eC50cmFuc2xhdGUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbFRyYW5zbGF0ZSh4LCB5KTtcbiAgfTtcbiAgY3R4LnNjYWxlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnNjYWxlKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNjYWxlKHgsIHkpO1xuICB9O1xuICBjdHgudHJhbnNmb3JtID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGRlc3RDdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgfTtcbiAgY3R4LnJlc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSgpO1xuICB9O1xuICBjdHgucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgZGVzdEN0eC5yb3RhdGUoYW5nbGUpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJvdGF0ZShhbmdsZSk7XG4gIH07XG4gIGN0eC5jbGlwID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBkZXN0Q3R4LmNsaXAocnVsZSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xpcChydWxlKTtcbiAgfTtcbiAgY3R4Lm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsTW92ZVRvKHgsIHkpO1xuICB9O1xuICBjdHgubGluZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4LmxpbmVUbyh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxMaW5lVG8oeCwgeSk7XG4gIH07XG4gIGN0eC5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24gKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcbiAgICBkZXN0Q3R4LmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgfTtcbiAgY3R4LnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGRlc3RDdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuICBjdHguY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xvc2VQYXRoKCk7XG4gIH07XG4gIGN0eC5iZWdpblBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5iZWdpblBhdGgoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxCZWdpblBhdGgoKTtcbiAgfTtcbn1cbmNsYXNzIENhY2hlZENhbnZhc2VzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzRmFjdG9yeSkge1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgZ2V0Q2FudmFzKGlkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgbGV0IGNhbnZhc0VudHJ5O1xuICAgIGlmICh0aGlzLmNhY2hlW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LnJlc2V0KGNhbnZhc0VudHJ5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBjYW52YXNFbnRyeTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhc0VudHJ5O1xuICB9XG4gIGRlbGV0ZShpZCkge1xuICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2lkXTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIGNvbnN0IGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkuZGVzdHJveShjYW52YXNFbnRyeSk7XG4gICAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRlc3RYLCBkZXN0WSwgZGVzdFcsIGRlc3RIKSB7XG4gIGNvbnN0IFthLCBiLCBjLCBkLCB0eCwgdHldID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICBpZiAoYiA9PT0gMCAmJiBjID09PSAwKSB7XG4gICAgY29uc3QgdGxYID0gZGVzdFggKiBhICsgdHg7XG4gICAgY29uc3QgclRsWCA9IE1hdGgucm91bmQodGxYKTtcbiAgICBjb25zdCB0bFkgPSBkZXN0WSAqIGQgKyB0eTtcbiAgICBjb25zdCByVGxZID0gTWF0aC5yb3VuZCh0bFkpO1xuICAgIGNvbnN0IGJyWCA9IChkZXN0WCArIGRlc3RXKSAqIGEgKyB0eDtcbiAgICBjb25zdCByV2lkdGggPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWCkgLSByVGxYKSB8fCAxO1xuICAgIGNvbnN0IGJyWSA9IChkZXN0WSArIGRlc3RIKSAqIGQgKyB0eTtcbiAgICBjb25zdCBySGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclkpIC0gclRsWSkgfHwgMTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKE1hdGguc2lnbihhKSwgMCwgMCwgTWF0aC5zaWduKGQpLCByVGxYLCByVGxZKTtcbiAgICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgMCwgMCwgcldpZHRoLCBySGVpZ2h0KTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIHR4LCB0eSk7XG4gICAgcmV0dXJuIFtyV2lkdGgsIHJIZWlnaHRdO1xuICB9XG4gIGlmIChhID09PSAwICYmIGQgPT09IDApIHtcbiAgICBjb25zdCB0bFggPSBkZXN0WSAqIGMgKyB0eDtcbiAgICBjb25zdCByVGxYID0gTWF0aC5yb3VuZCh0bFgpO1xuICAgIGNvbnN0IHRsWSA9IGRlc3RYICogYiArIHR5O1xuICAgIGNvbnN0IHJUbFkgPSBNYXRoLnJvdW5kKHRsWSk7XG4gICAgY29uc3QgYnJYID0gKGRlc3RZICsgZGVzdEgpICogYyArIHR4O1xuICAgIGNvbnN0IHJXaWR0aCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJYKSAtIHJUbFgpIHx8IDE7XG4gICAgY29uc3QgYnJZID0gKGRlc3RYICsgZGVzdFcpICogYiArIHR5O1xuICAgIGNvbnN0IHJIZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWSkgLSByVGxZKSB8fCAxO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMCwgTWF0aC5zaWduKGIpLCBNYXRoLnNpZ24oYyksIDAsIHJUbFgsIHJUbFkpO1xuICAgIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCAwLCAwLCBySGVpZ2h0LCByV2lkdGgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgdHgsIHR5KTtcbiAgICByZXR1cm4gW3JIZWlnaHQsIHJXaWR0aF07XG4gIH1cbiAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRlc3RYLCBkZXN0WSwgZGVzdFcsIGRlc3RIKTtcbiAgY29uc3Qgc2NhbGVYID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgY29uc3Qgc2NhbGVZID0gTWF0aC5oeXBvdChjLCBkKTtcbiAgcmV0dXJuIFtzY2FsZVggKiBkZXN0Vywgc2NhbGVZICogZGVzdEhdO1xufVxuY2xhc3MgQ2FudmFzRXh0cmFTdGF0ZSB7XG4gIGFscGhhSXNTaGFwZSA9IGZhbHNlO1xuICBmb250U2l6ZSA9IDA7XG4gIGZvbnRTaXplU2NhbGUgPSAxO1xuICB0ZXh0TWF0cml4ID0gbnVsbDtcbiAgdGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgZm9udE1hdHJpeCA9IEZPTlRfSURFTlRJVFlfTUFUUklYO1xuICBsZWFkaW5nID0gMDtcbiAgeCA9IDA7XG4gIHkgPSAwO1xuICBsaW5lWCA9IDA7XG4gIGxpbmVZID0gMDtcbiAgY2hhclNwYWNpbmcgPSAwO1xuICB3b3JkU3BhY2luZyA9IDA7XG4gIHRleHRIU2NhbGUgPSAxO1xuICB0ZXh0UmVuZGVyaW5nTW9kZSA9IFRleHRSZW5kZXJpbmdNb2RlLkZJTEw7XG4gIHRleHRSaXNlID0gMDtcbiAgZmlsbENvbG9yID0gXCIjMDAwMDAwXCI7XG4gIHN0cm9rZUNvbG9yID0gXCIjMDAwMDAwXCI7XG4gIHBhdHRlcm5GaWxsID0gZmFsc2U7XG4gIHBhdHRlcm5TdHJva2UgPSBmYWxzZTtcbiAgZmlsbEFscGhhID0gMTtcbiAgc3Ryb2tlQWxwaGEgPSAxO1xuICBsaW5lV2lkdGggPSAxO1xuICBhY3RpdmVTTWFzayA9IG51bGw7XG4gIHRyYW5zZmVyTWFwcyA9IFwibm9uZVwiO1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBwcmVJbml0KSB7XG4gICAgcHJlSW5pdD8uKHRoaXMpO1xuICAgIHRoaXMuY2xpcEJveCA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIHdpZHRoLCBoZWlnaHRdKTtcbiAgICB0aGlzLm1pbk1heCA9IE1JTl9NQVhfSU5JVC5zbGljZSgpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICBjbG9uZS5jbGlwQm94ID0gdGhpcy5jbGlwQm94LnNsaWNlKCk7XG4gICAgY2xvbmUubWluTWF4ID0gdGhpcy5taW5NYXguc2xpY2UoKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgZ2V0UGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlID0gUGF0aFR5cGUuRklMTCwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIGNvbnN0IGJveCA9IHRoaXMubWluTWF4LnNsaWNlKCk7XG4gICAgaWYgKHBhdGhUeXBlID09PSBQYXRoVHlwZS5TVFJPS0UpIHtcbiAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgIHVucmVhY2hhYmxlKFwiU3Ryb2tlIGJvdW5kaW5nIGJveCBtdXN0IGluY2x1ZGUgdHJhbnNmb3JtLlwiKTtcbiAgICAgIH1cbiAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmb3JtLCBYWSk7XG4gICAgICBjb25zdCB4U3Ryb2tlUGFkID0gWFlbMF0gKiB0aGlzLmxpbmVXaWR0aCAvIDI7XG4gICAgICBjb25zdCB5U3Ryb2tlUGFkID0gWFlbMV0gKiB0aGlzLmxpbmVXaWR0aCAvIDI7XG4gICAgICBib3hbMF0gLT0geFN0cm9rZVBhZDtcbiAgICAgIGJveFsxXSAtPSB5U3Ryb2tlUGFkO1xuICAgICAgYm94WzJdICs9IHhTdHJva2VQYWQ7XG4gICAgICBib3hbM10gKz0geVN0cm9rZVBhZDtcbiAgICB9XG4gICAgcmV0dXJuIGJveDtcbiAgfVxuICB1cGRhdGVDbGlwRnJvbVBhdGgoKSB7XG4gICAgY29uc3QgaW50ZXJzZWN0ID0gVXRpbC5pbnRlcnNlY3QodGhpcy5jbGlwQm94LCB0aGlzLmdldFBhdGhCb3VuZGluZ0JveCgpKTtcbiAgICB0aGlzLnN0YXJ0TmV3UGF0aEFuZENsaXBCb3goaW50ZXJzZWN0IHx8IFswLCAwLCAwLCAwXSk7XG4gIH1cbiAgaXNFbXB0eUNsaXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluTWF4WzBdID09PSBJbmZpbml0eTtcbiAgfVxuICBzdGFydE5ld1BhdGhBbmRDbGlwQm94KGJveCkge1xuICAgIHRoaXMuY2xpcEJveC5zZXQoYm94LCAwKTtcbiAgICB0aGlzLm1pbk1heC5zZXQoTUlOX01BWF9JTklULCAwKTtcbiAgfVxuICBnZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlID0gUGF0aFR5cGUuRklMTCwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIHJldHVybiBVdGlsLmludGVyc2VjdCh0aGlzLmNsaXBCb3gsIHRoaXMuZ2V0UGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlLCB0cmFuc2Zvcm0pKTtcbiAgfVxufVxuZnVuY3Rpb24gcHV0QmluYXJ5SW1hZ2VEYXRhKGN0eCwgaW1nRGF0YSkge1xuICBpZiAoaW1nRGF0YSBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgY29uc3QgcGFydGlhbENodW5rSGVpZ2h0ID0gaGVpZ2h0ICUgRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IGZ1bGxDaHVua3MgPSAoaGVpZ2h0IC0gcGFydGlhbENodW5rSGVpZ2h0KSAvIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCB0b3RhbENodW5rcyA9IHBhcnRpYWxDaHVua0hlaWdodCA9PT0gMCA/IGZ1bGxDaHVua3MgOiBmdWxsQ2h1bmtzICsgMTtcbiAgY29uc3QgY2h1bmtJbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgRlVMTF9DSFVOS19IRUlHSFQpO1xuICBsZXQgc3JjUG9zID0gMCxcbiAgICBkZXN0UG9zO1xuICBjb25zdCBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gIGNvbnN0IGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcbiAgbGV0IGksIGosIHRoaXNDaHVua0hlaWdodCwgZWxlbXNJblRoaXNDaHVuaztcbiAgaWYgKGltZ0RhdGEua2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFApIHtcbiAgICBjb25zdCBzcmNMZW5ndGggPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBkZXN0MzIgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIsIDAsIGRlc3QuYnl0ZUxlbmd0aCA+PiAyKTtcbiAgICBjb25zdCBkZXN0MzJEYXRhTGVuZ3RoID0gZGVzdDMyLmxlbmd0aDtcbiAgICBjb25zdCBmdWxsU3JjRGlmZiA9IHdpZHRoICsgNyA+PiAzO1xuICAgIGNvbnN0IHdoaXRlID0gMHhmZmZmZmZmZjtcbiAgICBjb25zdCBibGFjayA9IHV0aWxfRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXNDaHVua0hlaWdodDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNyY0RpZmYgPSBzcmNMZW5ndGggLSBzcmNQb3M7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgY29uc3Qga0VuZCA9IHNyY0RpZmYgPiBmdWxsU3JjRGlmZiA/IHdpZHRoIDogc3JjRGlmZiAqIDggLSA3O1xuICAgICAgICBjb25zdCBrRW5kVW5yb2xsZWQgPSBrRW5kICYgfjc7XG4gICAgICAgIGxldCBtYXNrID0gMDtcbiAgICAgICAgbGV0IHNyY0J5dGUgPSAwO1xuICAgICAgICBmb3IgKDsgayA8IGtFbmRVbnJvbGxlZDsgayArPSA4KSB7XG4gICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTI4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA2NCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMzIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDE2ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgayA8IGtFbmQ7IGsrKykge1xuICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICAgIG1hc2sgPSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIG1hc2sgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChkZXN0UG9zIDwgZGVzdDMyRGF0YUxlbmd0aCkge1xuICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IDA7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsX0ltYWdlS2luZC5SR0JBXzMyQlBQKSB7XG4gICAgaiA9IDA7XG4gICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogRlVMTF9DSFVOS19IRUlHSFQgKiA0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIHNyY1BvcyArPSBlbGVtc0luVGhpc0NodW5rO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgICAgaiArPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICB9XG4gICAgaWYgKGkgPCB0b3RhbENodW5rcykge1xuICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogcGFydGlhbENodW5rSGVpZ2h0ICogNDtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsX0ltYWdlS2luZC5SR0JfMjRCUFApIHtcbiAgICB0aGlzQ2h1bmtIZWlnaHQgPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGlmIChpID49IGZ1bGxDaHVua3MpIHtcbiAgICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgICB9XG4gICAgICBkZXN0UG9zID0gMDtcbiAgICAgIGZvciAoaiA9IGVsZW1zSW5UaGlzQ2h1bms7IGotLTspIHtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgYmFkIGltYWdlIGtpbmQ6ICR7aW1nRGF0YS5raW5kfWApO1xuICB9XG59XG5mdW5jdGlvbiBwdXRCaW5hcnlJbWFnZU1hc2soY3R4LCBpbWdEYXRhKSB7XG4gIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1nRGF0YS5iaXRtYXAsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDA7XG4gIGNvbnN0IHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgY29uc3QgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICBjb25zdCB0aGlzQ2h1bmtIZWlnaHQgPSBpIDwgZnVsbENodW5rcyA/IEZVTExfQ0hVTktfSEVJR0hUIDogcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICh7XG4gICAgICBzcmNQb3NcbiAgICB9ID0gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe1xuICAgICAgc3JjLFxuICAgICAgc3JjUG9zLFxuICAgICAgZGVzdCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzQ2h1bmtIZWlnaHQsXG4gICAgICBub25CbGFja0NvbG9yOiAwXG4gICAgfSkpO1xuICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICB9XG59XG5mdW5jdGlvbiBjb3B5Q3R4U3RhdGUoc291cmNlQ3R4LCBkZXN0Q3R4KSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBbXCJzdHJva2VTdHlsZVwiLCBcImZpbGxTdHlsZVwiLCBcImZpbGxSdWxlXCIsIFwiZ2xvYmFsQWxwaGFcIiwgXCJsaW5lV2lkdGhcIiwgXCJsaW5lQ2FwXCIsIFwibGluZUpvaW5cIiwgXCJtaXRlckxpbWl0XCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIFwiZm9udFwiLCBcImZpbHRlclwiXTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHNvdXJjZUN0eFtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdEN0eFtwcm9wZXJ0eV0gPSBzb3VyY2VDdHhbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuICBpZiAoc291cmNlQ3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZXN0Q3R4LnNldExpbmVEYXNoKHNvdXJjZUN0eC5nZXRMaW5lRGFzaCgpKTtcbiAgICBkZXN0Q3R4LmxpbmVEYXNoT2Zmc2V0ID0gc291cmNlQ3R4LmxpbmVEYXNoT2Zmc2V0O1xuICB9XG59XG5mdW5jdGlvbiByZXNldEN0eFRvRGVmYXVsdChjdHgpIHtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IFwiIzAwMDAwMFwiO1xuICBjdHguZmlsbFJ1bGUgPSBcIm5vbnplcm9cIjtcbiAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gIGN0eC5saW5lQ2FwID0gXCJidXR0XCI7XG4gIGN0eC5saW5lSm9pbiA9IFwibWl0ZXJcIjtcbiAgY3R4Lm1pdGVyTGltaXQgPSAxMDtcbiAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgY3R4LmZvbnQgPSBcIjEwcHggc2Fucy1zZXJpZlwiO1xuICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG4gIH1cbiAgY29uc3Qge1xuICAgIGZpbHRlclxuICB9ID0gY3R4O1xuICBpZiAoZmlsdGVyICE9PSBcIm5vbmVcIiAmJiBmaWx0ZXIgIT09IFwiXCIpIHtcbiAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEltYWdlU21vb3RoaW5nRW5hYmxlZCh0cmFuc2Zvcm0sIGludGVycG9sYXRlKSB7XG4gIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmb3JtLCBYWSk7XG4gIGNvbnN0IGFjdHVhbFNjYWxlID0gTWF0aC5mcm91bmQoT3V0cHV0U2NhbGUucGl4ZWxSYXRpbyAqIFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gIHJldHVybiBYWVswXSA8PSBhY3R1YWxTY2FsZSAmJiBYWVsxXSA8PSBhY3R1YWxTY2FsZTtcbn1cbmNvbnN0IExJTkVfQ0FQX1NUWUxFUyA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcbmNvbnN0IExJTkVfSk9JTl9TVFlMRVMgPSBbXCJtaXRlclwiLCBcInJvdW5kXCIsIFwiYmV2ZWxcIl07XG5jb25zdCBOT1JNQUxfQ0xJUCA9IHt9O1xuY29uc3QgRU9fQ0xJUCA9IHt9O1xuY2xhc3MgQ2FudmFzR3JhcGhpY3Mge1xuICBjb25zdHJ1Y3RvcihjYW52YXNDdHgsIGNvbW1vbk9ianMsIG9ianMsIGNhbnZhc0ZhY3RvcnksIGZpbHRlckZhY3RvcnksIHtcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWcsXG4gICAgbWFya2VkQ29udGVudFN0YWNrID0gbnVsbFxuICB9LCBhbm5vdGF0aW9uQ2FudmFzTWFwLCBwYWdlQ29sb3JzLCBkZXBlbmRlbmN5VHJhY2tlcikge1xuICAgIHRoaXMuY3R4ID0gY2FudmFzQ3R4O1xuICAgIHRoaXMuY3VycmVudCA9IG5ldyBDYW52YXNFeHRyYVN0YXRlKHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5zdGF0ZVN0YWNrID0gW107XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgdGhpcy5yZXMgPSBudWxsO1xuICAgIHRoaXMueG9ianMgPSBudWxsO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5ncm91cFN0YWNrID0gW107XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gbnVsbDtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCA9IDA7XG4gICAgdGhpcy5zbWFza1N0YWNrID0gW107XG4gICAgdGhpcy5zbWFza0NvdW50ZXIgPSAwO1xuICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IG51bGw7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sgPSBtYXJrZWRDb250ZW50U3RhY2sgfHwgW107XG4gICAgdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcgPSBvcHRpb25hbENvbnRlbnRDb25maWc7XG4gICAgdGhpcy5jYWNoZWRDYW52YXNlcyA9IG5ldyBDYWNoZWRDYW52YXNlcyh0aGlzLmNhbnZhc0ZhY3RvcnkpO1xuICAgIHRoaXMuY2FjaGVkUGF0dGVybnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLnZpZXdwb3J0U2NhbGUgPSAxO1xuICAgIHRoaXMub3V0cHV0U2NhbGVYID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWSA9IDE7XG4gICAgdGhpcy5wYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nID0gWy0xLCAwXTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPSBkZXBlbmRlbmN5VHJhY2tlciA/PyBudWxsO1xuICB9XG4gIGdldE9iamVjdChvcElkeCwgZGF0YSwgZmFsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmROYW1lZERlcGVuZGVuY3kob3BJZHgsIGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGEuc3RhcnRzV2l0aChcImdfXCIpID8gdGhpcy5jb21tb25PYmpzLmdldChkYXRhKSA6IHRoaXMub2Jqcy5nZXQoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxuICBiZWdpbkRyYXdpbmcoe1xuICAgIHRyYW5zZm9ybSxcbiAgICB2aWV3cG9ydCxcbiAgICB0cmFuc3BhcmVuY3kgPSBmYWxzZSxcbiAgICBiYWNrZ3JvdW5kID0gbnVsbFxuICB9KSB7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmN0eC5jYW52YXMud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jdHguY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBzYXZlZEZpbGxTdHlsZSA9IHRoaXMuY3R4LmZpbGxTdHlsZTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kIHx8IFwiI2ZmZmZmZlwiO1xuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHNhdmVkRmlsbFN0eWxlO1xuICAgIGlmICh0cmFuc3BhcmVuY3kpIHtcbiAgICAgIGNvbnN0IHRyYW5zcGFyZW50Q2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJ0cmFuc3BhcmVudFwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY29tcG9zaXRlQ3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLnRyYW5zcGFyZW50Q2FudmFzID0gdHJhbnNwYXJlbnRDYW52YXMuY2FudmFzO1xuICAgICAgdGhpcy5jdHggPSB0cmFuc3BhcmVudENhbnZhcy5jb250ZXh0O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLmdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jb21wb3NpdGVDdHgpKTtcbiAgICB9XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICAgIHRoaXMub3V0cHV0U2NhbGVYID0gdHJhbnNmb3JtWzBdO1xuICAgICAgdGhpcy5vdXRwdXRTY2FsZVkgPSB0cmFuc2Zvcm1bMF07XG4gICAgfVxuICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi52aWV3cG9ydC50cmFuc2Zvcm0pO1xuICAgIHRoaXMudmlld3BvcnRTY2FsZSA9IHZpZXdwb3J0LnNjYWxlO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICB9XG4gIGV4ZWN1dGVPcGVyYXRvckxpc3Qob3BlcmF0b3JMaXN0LCBleGVjdXRpb25TdGFydElkeCwgY29udGludWVDYWxsYmFjaywgc3RlcHBlciwgb3BlcmF0aW9uc0ZpbHRlcikge1xuICAgIGNvbnN0IGFyZ3NBcnJheSA9IG9wZXJhdG9yTGlzdC5hcmdzQXJyYXk7XG4gICAgY29uc3QgZm5BcnJheSA9IG9wZXJhdG9yTGlzdC5mbkFycmF5O1xuICAgIGxldCBpID0gZXhlY3V0aW9uU3RhcnRJZHggfHwgMDtcbiAgICBjb25zdCBhcmdzQXJyYXlMZW4gPSBhcmdzQXJyYXkubGVuZ3RoO1xuICAgIGlmIChhcmdzQXJyYXlMZW4gPT09IGkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBjb25zdCBjaHVua09wZXJhdGlvbnMgPSBhcmdzQXJyYXlMZW4gLSBpID4gRVhFQ1VUSU9OX1NURVBTICYmIHR5cGVvZiBjb250aW51ZUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCI7XG4gICAgY29uc3QgZW5kVGltZSA9IGNodW5rT3BlcmF0aW9ucyA/IERhdGUubm93KCkgKyBFWEVDVVRJT05fVElNRSA6IDA7XG4gICAgbGV0IHN0ZXBzID0gMDtcbiAgICBjb25zdCBjb21tb25PYmpzID0gdGhpcy5jb21tb25PYmpzO1xuICAgIGNvbnN0IG9ianMgPSB0aGlzLm9ianM7XG4gICAgbGV0IGZuSWQsIGZuQXJncztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHN0ZXBwZXIgIT09IHVuZGVmaW5lZCAmJiBpID09PSBzdGVwcGVyLm5leHRCcmVha1BvaW50KSB7XG4gICAgICAgIHN0ZXBwZXIuYnJlYWtJdChpLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBpZiAoIW9wZXJhdGlvbnNGaWx0ZXIgfHwgb3BlcmF0aW9uc0ZpbHRlcihpKSkge1xuICAgICAgICBmbklkID0gZm5BcnJheVtpXTtcbiAgICAgICAgZm5BcmdzID0gYXJnc0FycmF5W2ldID8/IG51bGw7XG4gICAgICAgIGlmIChmbklkICE9PSBPUFMuZGVwZW5kZW5jeSkge1xuICAgICAgICAgIGlmIChmbkFyZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXNbZm5JZF0oaSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbZm5JZF0oaSwgLi4uZm5BcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBkZXBPYmpJZCBvZiBmbkFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE5hbWVkRGF0YShkZXBPYmpJZCwgaSk7XG4gICAgICAgICAgICBjb25zdCBvYmpzUG9vbCA9IGRlcE9iaklkLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IGNvbW1vbk9ianMgOiBvYmpzO1xuICAgICAgICAgICAgaWYgKCFvYmpzUG9vbC5oYXMoZGVwT2JqSWQpKSB7XG4gICAgICAgICAgICAgIG9ianNQb29sLmdldChkZXBPYmpJZCwgY29udGludWVDYWxsYmFjayk7XG4gICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSsrO1xuICAgICAgaWYgKGkgPT09IGFyZ3NBcnJheUxlbikge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVua09wZXJhdGlvbnMgJiYgKytzdGVwcyA+IEVYRUNVVElPTl9TVEVQUykge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IGVuZFRpbWUpIHtcbiAgICAgICAgICBjb250aW51ZUNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcHMgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjcmVzdG9yZUluaXRpYWxTdGF0ZSgpIHtcbiAgICB3aGlsZSAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCB8fCB0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgaWYgKHRoaXMudHJhbnNwYXJlbnRDYW52YXMpIHtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5jb21wb3NpdGVDdHg7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UodGhpcy50cmFuc3BhcmVudENhbnZhcywgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLnRyYW5zcGFyZW50Q2FudmFzID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZW5kRHJhd2luZygpIHtcbiAgICB0aGlzLiNyZXN0b3JlSW5pdGlhbFN0YXRlKCk7XG4gICAgdGhpcy5jYWNoZWRDYW52YXNlcy5jbGVhcigpO1xuICAgIHRoaXMuY2FjaGVkUGF0dGVybnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGNhY2hlIG9mIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgY2FudmFzIG9mIGNhY2hlLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcC5jbGVhcigpO1xuICAgIHRoaXMuI2RyYXdGaWx0ZXIoKTtcbiAgfVxuICAjZHJhd0ZpbHRlcigpIHtcbiAgICBpZiAodGhpcy5wYWdlQ29sb3JzKSB7XG4gICAgICBjb25zdCBoY21GaWx0ZXJJZCA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRIQ01GaWx0ZXIodGhpcy5wYWdlQ29sb3JzLmZvcmVncm91bmQsIHRoaXMucGFnZUNvbG9ycy5iYWNrZ3JvdW5kKTtcbiAgICAgIGlmIChoY21GaWx0ZXJJZCAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgY29uc3Qgc2F2ZWRGaWx0ZXIgPSB0aGlzLmN0eC5maWx0ZXI7XG4gICAgICAgIHRoaXMuY3R4LmZpbHRlciA9IGhjbUZpbHRlcklkO1xuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UodGhpcy5jdHguY2FudmFzLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gc2F2ZWRGaWx0ZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9zY2FsZUltYWdlKGltZywgaW52ZXJzZVRyYW5zZm9ybSkge1xuICAgIGNvbnN0IHdpZHRoID0gaW1nLndpZHRoID8/IGltZy5kaXNwbGF5V2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nLmhlaWdodCA/PyBpbWcuZGlzcGxheUhlaWdodDtcbiAgICBsZXQgd2lkdGhTY2FsZSA9IE1hdGgubWF4KE1hdGguaHlwb3QoaW52ZXJzZVRyYW5zZm9ybVswXSwgaW52ZXJzZVRyYW5zZm9ybVsxXSksIDEpO1xuICAgIGxldCBoZWlnaHRTY2FsZSA9IE1hdGgubWF4KE1hdGguaHlwb3QoaW52ZXJzZVRyYW5zZm9ybVsyXSwgaW52ZXJzZVRyYW5zZm9ybVszXSksIDEpO1xuICAgIGxldCBwYWludFdpZHRoID0gd2lkdGgsXG4gICAgICBwYWludEhlaWdodCA9IGhlaWdodDtcbiAgICBsZXQgdG1wQ2FudmFzSWQgPSBcInByZXNjYWxlMVwiO1xuICAgIGxldCB0bXBDYW52YXMsIHRtcEN0eDtcbiAgICB3aGlsZSAod2lkdGhTY2FsZSA+IDIgJiYgcGFpbnRXaWR0aCA+IDEgfHwgaGVpZ2h0U2NhbGUgPiAyICYmIHBhaW50SGVpZ2h0ID4gMSkge1xuICAgICAgbGV0IG5ld1dpZHRoID0gcGFpbnRXaWR0aCxcbiAgICAgICAgbmV3SGVpZ2h0ID0gcGFpbnRIZWlnaHQ7XG4gICAgICBpZiAod2lkdGhTY2FsZSA+IDIgJiYgcGFpbnRXaWR0aCA+IDEpIHtcbiAgICAgICAgbmV3V2lkdGggPSBwYWludFdpZHRoID49IDE2Mzg0ID8gTWF0aC5mbG9vcihwYWludFdpZHRoIC8gMikgLSAxIHx8IDEgOiBNYXRoLmNlaWwocGFpbnRXaWR0aCAvIDIpO1xuICAgICAgICB3aWR0aFNjYWxlIC89IHBhaW50V2lkdGggLyBuZXdXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHRTY2FsZSA+IDIgJiYgcGFpbnRIZWlnaHQgPiAxKSB7XG4gICAgICAgIG5ld0hlaWdodCA9IHBhaW50SGVpZ2h0ID49IDE2Mzg0ID8gTWF0aC5mbG9vcihwYWludEhlaWdodCAvIDIpIC0gMSB8fCAxIDogTWF0aC5jZWlsKHBhaW50SGVpZ2h0KSAvIDI7XG4gICAgICAgIGhlaWdodFNjYWxlIC89IHBhaW50SGVpZ2h0IC8gbmV3SGVpZ2h0O1xuICAgICAgfVxuICAgICAgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXModG1wQ2FudmFzSWQsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICB0bXBDdHguY2xlYXJSZWN0KDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgdG1wQ3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHBhaW50V2lkdGgsIHBhaW50SGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIGltZyA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgICBwYWludFdpZHRoID0gbmV3V2lkdGg7XG4gICAgICBwYWludEhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIHRtcENhbnZhc0lkID0gdG1wQ2FudmFzSWQgPT09IFwicHJlc2NhbGUxXCIgPyBcInByZXNjYWxlMlwiIDogXCJwcmVzY2FsZTFcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGltZyxcbiAgICAgIHBhaW50V2lkdGgsXG4gICAgICBwYWludEhlaWdodFxuICAgIH07XG4gIH1cbiAgX2NyZWF0ZU1hc2tDYW52YXMob3BJZHgsIGltZykge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltZztcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICBsZXQgY2FjaGUsIGNhY2hlS2V5LCBzY2FsZWQsIG1hc2tDYW52YXM7XG4gICAgaWYgKChpbWcuYml0bWFwIHx8IGltZy5kYXRhKSAmJiBpbWcuY291bnQgPiAxKSB7XG4gICAgICBjb25zdCBtYWluS2V5ID0gaW1nLmJpdG1hcCB8fCBpbWcuZGF0YS5idWZmZXI7XG4gICAgICBjYWNoZUtleSA9IEpTT04uc3RyaW5naWZ5KGlzUGF0dGVybkZpbGwgPyBjdXJyZW50VHJhbnNmb3JtIDogW2N1cnJlbnRUcmFuc2Zvcm0uc2xpY2UoMCwgNCksIGZpbGxDb2xvcl0pO1xuICAgICAgY2FjaGUgPSB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLmdldChtYWluS2V5KTtcbiAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuc2V0KG1haW5LZXksIGNhY2hlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhY2hlZEltYWdlID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmIChjYWNoZWRJbWFnZSAmJiAhaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5yb3VuZChNYXRoLm1pbihjdXJyZW50VHJhbnNmb3JtWzBdLCBjdXJyZW50VHJhbnNmb3JtWzJdKSArIGN1cnJlbnRUcmFuc2Zvcm1bNF0pO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5yb3VuZChNYXRoLm1pbihjdXJyZW50VHJhbnNmb3JtWzFdLCBjdXJyZW50VHJhbnNmb3JtWzNdKSArIGN1cnJlbnRUcmFuc2Zvcm1bNV0pO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy50cmFuc2Zvcm1BbmRGaWxsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW52YXM6IGNhY2hlZEltYWdlLFxuICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc2NhbGVkID0gY2FjaGVkSW1hZ2U7XG4gICAgfVxuICAgIGlmICghc2NhbGVkKSB7XG4gICAgICBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDYW52YXMuY29udGV4dCwgaW1nKTtcbiAgICB9XG4gICAgbGV0IG1hc2tUb0NhbnZhcyA9IFV0aWwudHJhbnNmb3JtKGN1cnJlbnRUcmFuc2Zvcm0sIFsxIC8gd2lkdGgsIDAsIDAsIC0xIC8gaGVpZ2h0LCAwLCAwXSk7XG4gICAgbWFza1RvQ2FudmFzID0gVXRpbC50cmFuc2Zvcm0obWFza1RvQ2FudmFzLCBbMSwgMCwgMCwgMSwgMCwgLWhlaWdodF0pO1xuICAgIGNvbnN0IG1pbk1heCA9IE1JTl9NQVhfSU5JVC5zbGljZSgpO1xuICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBtYXNrVG9DYW52YXMsIG1pbk1heCk7XG4gICAgY29uc3QgW21pblgsIG1pblksIG1heFgsIG1heFldID0gbWluTWF4O1xuICAgIGNvbnN0IGRyYXduV2lkdGggPSBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSB8fCAxO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gTWF0aC5yb3VuZChtYXhZIC0gbWluWSkgfHwgMTtcbiAgICBjb25zdCBmaWxsQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJmaWxsQ2FudmFzXCIsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBmaWxsQ3R4ID0gZmlsbENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IG9mZnNldFggPSBtaW5YO1xuICAgIGNvbnN0IG9mZnNldFkgPSBtaW5ZO1xuICAgIGZpbGxDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZmlsbEN0eC50cmFuc2Zvcm0oLi4ubWFza1RvQ2FudmFzKTtcbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShtYXNrQ2FudmFzLmNhbnZhcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoZmlsbEN0eCkpO1xuICAgICAgc2NhbGVkID0gc2NhbGVkLmltZztcbiAgICAgIGlmIChjYWNoZSAmJiBpc1BhdHRlcm5GaWxsKSB7XG4gICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgc2NhbGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmlsbEN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoZ2V0Q3VycmVudFRyYW5zZm9ybShmaWxsQ3R4KSwgaW1nLmludGVycG9sYXRlKTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoZmlsbEN0eCwgc2NhbGVkLCAwLCAwLCBzY2FsZWQud2lkdGgsIHNjYWxlZC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGZpbGxDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2UtaW5cIjtcbiAgICBjb25zdCBpbnZlcnNlID0gVXRpbC50cmFuc2Zvcm0oZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoZmlsbEN0eCksIFsxLCAwLCAwLCAxLCAtb2Zmc2V0WCwgLW9mZnNldFldKTtcbiAgICBmaWxsQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGludmVyc2UsIFBhdGhUeXBlLkZJTEwsIG9wSWR4KSA6IGZpbGxDb2xvcjtcbiAgICBmaWxsQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChjYWNoZSAmJiAhaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgdGhpcy5jYWNoZWRDYW52YXNlcy5kZWxldGUoXCJmaWxsQ2FudmFzXCIpO1xuICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBmaWxsQ2FudmFzLmNhbnZhcyk7XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnRyYW5zZm9ybUFuZEZpbGwpO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXM6IGZpbGxDYW52YXMuY2FudmFzLFxuICAgICAgb2Zmc2V0WDogTWF0aC5yb3VuZChvZmZzZXRYKSxcbiAgICAgIG9mZnNldFk6IE1hdGgucm91bmQob2Zmc2V0WSlcbiAgICB9O1xuICB9XG4gIHNldExpbmVXaWR0aChvcElkeCwgd2lkdGgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwibGluZVdpZHRoXCIsIG9wSWR4KTtcbiAgICBpZiAod2lkdGggIT09IHRoaXMuY3VycmVudC5saW5lV2lkdGgpIHtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuICB9XG4gIHNldExpbmVDYXAob3BJZHgsIHN0eWxlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImxpbmVDYXBcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3R4LmxpbmVDYXAgPSBMSU5FX0NBUF9TVFlMRVNbc3R5bGVdO1xuICB9XG4gIHNldExpbmVKb2luKG9wSWR4LCBzdHlsZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJsaW5lSm9pblwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHgubGluZUpvaW4gPSBMSU5FX0pPSU5fU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRNaXRlckxpbWl0KG9wSWR4LCBsaW1pdCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJtaXRlckxpbWl0XCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5taXRlckxpbWl0ID0gbGltaXQ7XG4gIH1cbiAgc2V0RGFzaChvcElkeCwgZGFzaEFycmF5LCBkYXNoUGhhc2UpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZGFzaFwiLCBvcElkeCk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaEFycmF5KTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hQaGFzZTtcbiAgICB9XG4gIH1cbiAgc2V0UmVuZGVyaW5nSW50ZW50KG9wSWR4LCBpbnRlbnQpIHt9XG4gIHNldEZsYXRuZXNzKG9wSWR4LCBmbGF0bmVzcykge31cbiAgc2V0R1N0YXRlKG9wSWR4LCBzdGF0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdGF0ZXMpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJMV1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKG9wSWR4LCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMQ1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUNhcChvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVKb2luKG9wSWR4LCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNTFwiOlxuICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdChvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgIHRoaXMuc2V0RGFzaChvcElkeCwgdmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgdGhpcy5zZXRSZW5kZXJpbmdJbnRlbnQob3BJZHgsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZMXCI6XG4gICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyhvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIHRoaXMuc2V0Rm9udChvcElkeCwgdmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNBXCI6XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInN0cm9rZUFscGhhXCIsIG9wSWR4KTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImZpbGxBbHBoYVwiLCBvcElkeCk7XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuZmlsbEFscGhhID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJCTVwiOlxuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgb3BJZHgpO1xuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU01hc2tcIjpcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiU01hc2tcIiwgb3BJZHgpO1xuICAgICAgICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IHZhbHVlID8gdGhpcy50ZW1wU01hc2sgOiBudWxsO1xuICAgICAgICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVFJcIjpcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZmlsdGVyXCIsIG9wSWR4KTtcbiAgICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEZpbHRlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBpblNNYXNrTW9kZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnN1c3BlbmRlZEN0eDtcbiAgfVxuICBjaGVja1NNYXNrU3RhdGUoKSB7XG4gICAgY29uc3QgaW5TTWFza01vZGUgPSB0aGlzLmluU01hc2tNb2RlO1xuICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgJiYgIWluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmJlZ2luU01hc2tNb2RlKCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmIGluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgIH1cbiAgfVxuICBiZWdpblNNYXNrTW9kZShvcElkeCkge1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiZWdpblNNYXNrTW9kZSBjYWxsZWQgd2hpbGUgYWxyZWFkeSBpbiBzbWFzayBtb2RlXCIpO1xuICAgIH1cbiAgICBjb25zdCBkcmF3bldpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gdGhpcy5jdHguY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBjYWNoZUlkID0gXCJzbWFza0dyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICBjb25zdCBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnN1c3BlbmRlZEN0eC5nZXRUcmFuc2Zvcm0oKSk7XG4gICAgY29weUN0eFN0YXRlKHRoaXMuc3VzcGVuZGVkQ3R4LCBjdHgpO1xuICAgIG1pcnJvckNvbnRleHRPcGVyYXRpb25zKGN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgIHRoaXMuc2V0R1N0YXRlKG9wSWR4LCBbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXV0pO1xuICB9XG4gIGVuZFNNYXNrTW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVuZFNNYXNrTW9kZSBjYWxsZWQgd2hpbGUgbm90IGluIHNtYXNrIG1vZGVcIik7XG4gICAgfVxuICAgIHRoaXMuY3R4Ll9yZW1vdmVNaXJyb3JpbmcoKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gbnVsbDtcbiAgfVxuICBjb21wb3NlKGRpcnR5Qm94KSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkaXJ0eUJveCkge1xuICAgICAgZGlydHlCb3ggPSBbMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlCb3hbMF0gPSBNYXRoLmZsb29yKGRpcnR5Qm94WzBdKTtcbiAgICAgIGRpcnR5Qm94WzFdID0gTWF0aC5mbG9vcihkaXJ0eUJveFsxXSk7XG4gICAgICBkaXJ0eUJveFsyXSA9IE1hdGguY2VpbChkaXJ0eUJveFsyXSk7XG4gICAgICBkaXJ0eUJveFszXSA9IE1hdGguY2VpbChkaXJ0eUJveFszXSk7XG4gICAgfVxuICAgIGNvbnN0IHNtYXNrID0gdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrO1xuICAgIGNvbnN0IHN1c3BlbmRlZEN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuY29tcG9zZVNNYXNrKHN1c3BlbmRlZEN0eCwgc21hc2ssIHRoaXMuY3R4LCBkaXJ0eUJveCk7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgY29tcG9zZVNNYXNrKGN0eCwgc21hc2ssIGxheWVyQ3R4LCBsYXllckJveCkge1xuICAgIGNvbnN0IGxheWVyT2Zmc2V0WCA9IGxheWVyQm94WzBdO1xuICAgIGNvbnN0IGxheWVyT2Zmc2V0WSA9IGxheWVyQm94WzFdO1xuICAgIGNvbnN0IGxheWVyV2lkdGggPSBsYXllckJveFsyXSAtIGxheWVyT2Zmc2V0WDtcbiAgICBjb25zdCBsYXllckhlaWdodCA9IGxheWVyQm94WzNdIC0gbGF5ZXJPZmZzZXRZO1xuICAgIGlmIChsYXllcldpZHRoID09PSAwIHx8IGxheWVySGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ2VuZXJpY0NvbXBvc2VTTWFzayhzbWFzay5jb250ZXh0LCBsYXllckN0eCwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHQsIHNtYXNrLnN1YnR5cGUsIHNtYXNrLmJhY2tkcm9wLCBzbWFzay50cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHNtYXNrLm9mZnNldFgsIHNtYXNrLm9mZnNldFkpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmRyYXdJbWFnZShsYXllckN0eC5jYW52YXMsIDAsIDApO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZ2VuZXJpY0NvbXBvc2VTTWFzayhtYXNrQ3R4LCBsYXllckN0eCwgd2lkdGgsIGhlaWdodCwgc3VidHlwZSwgYmFja2Ryb3AsIHRyYW5zZmVyTWFwLCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgbWFza09mZnNldFgsIG1hc2tPZmZzZXRZKSB7XG4gICAgbGV0IG1hc2tDYW52YXMgPSBtYXNrQ3R4LmNhbnZhcztcbiAgICBsZXQgbWFza1ggPSBsYXllck9mZnNldFggLSBtYXNrT2Zmc2V0WDtcbiAgICBsZXQgbWFza1kgPSBsYXllck9mZnNldFkgLSBtYXNrT2Zmc2V0WTtcbiAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgIGlmIChtYXNrWCA8IDAgfHwgbWFza1kgPCAwIHx8IG1hc2tYICsgd2lkdGggPiBtYXNrQ2FudmFzLndpZHRoIHx8IG1hc2tZICsgaGVpZ2h0ID4gbWFza0NhbnZhcy5oZWlnaHQpIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrRXh0ZW5zaW9uXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuY29udGV4dDtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCAtbWFza1gsIC1tYXNrWSk7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWF0b3BcIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgIG1hc2tDYW52YXMgPSBjYW52YXMuY2FudmFzO1xuICAgICAgICBtYXNrWCA9IG1hc2tZID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgICBtYXNrQ3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgbWFza0N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIGNsaXAucmVjdChtYXNrWCwgbWFza1ksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtYXNrQ3R4LmNsaXAoY2xpcCk7XG4gICAgICAgIG1hc2tDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1hdG9wXCI7XG4gICAgICAgIG1hc2tDdHguZmlsbFN0eWxlID0gYmFja2Ryb3A7XG4gICAgICAgIG1hc2tDdHguZmlsbFJlY3QobWFza1gsIG1hc2tZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxheWVyQ3R4LnNhdmUoKTtcbiAgICBsYXllckN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgbGF5ZXJDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGlmIChzdWJ0eXBlID09PSBcIkFscGhhXCIgJiYgdHJhbnNmZXJNYXApIHtcbiAgICAgIGxheWVyQ3R4LmZpbHRlciA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRBbHBoYUZpbHRlcih0cmFuc2Zlck1hcCk7XG4gICAgfSBlbHNlIGlmIChzdWJ0eXBlID09PSBcIkx1bWlub3NpdHlcIikge1xuICAgICAgbGF5ZXJDdHguZmlsdGVyID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEx1bWlub3NpdHlGaWx0ZXIodHJhbnNmZXJNYXApO1xuICAgIH1cbiAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgIGNsaXAucmVjdChsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgd2lkdGgsIGhlaWdodCk7XG4gICAgbGF5ZXJDdHguY2xpcChjbGlwKTtcbiAgICBsYXllckN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWluXCI7XG4gICAgbGF5ZXJDdHguZHJhd0ltYWdlKG1hc2tDYW52YXMsIG1hc2tYLCBtYXNrWSwgd2lkdGgsIGhlaWdodCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGxheWVyQ3R4LnJlc3RvcmUoKTtcbiAgfVxuICBzYXZlKG9wSWR4KSB7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIGNvcHlDdHhTdGF0ZSh0aGlzLmN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgY29uc3Qgb2xkID0gdGhpcy5jdXJyZW50O1xuICAgIHRoaXMuc3RhdGVTdGFjay5wdXNoKG9sZCk7XG4gICAgdGhpcy5jdXJyZW50ID0gb2xkLmNsb25lKCk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8uc2F2ZShvcElkeCk7XG4gIH1cbiAgcmVzdG9yZShvcElkeCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc3RvcmUob3BJZHgpO1xuICAgIGlmICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnN0YXRlU3RhY2sucG9wKCk7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICBjb3B5Q3R4U3RhdGUodGhpcy5zdXNwZW5kZWRDdHgsIHRoaXMuY3R4KTtcbiAgICB9XG4gICAgdGhpcy5jaGVja1NNYXNrU3RhdGUoKTtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gIH1cbiAgdHJhbnNmb3JtKG9wSWR4LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkSW5jcmVtZW50YWxEYXRhKFwidHJhbnNmb3JtXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICB9XG4gIGNvbnN0cnVjdFBhdGgob3BJZHgsIG9wLCBkYXRhLCBtaW5NYXgpIHtcbiAgICBsZXQgW3BhdGhdID0gZGF0YTtcbiAgICBpZiAoIW1pbk1heCkge1xuICAgICAgcGF0aCB8fD0gZGF0YVswXSA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHRoaXNbb3BdKG9wSWR4LCBwYXRoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG91dGVyRXh0cmFTaXplID0gb3AgPT09IE9QUy5zdHJva2UgPyB0aGlzLmN1cnJlbnQubGluZVdpZHRoIC8gMiA6IDA7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyLnJlc2V0QkJveChvcElkeCkucmVjb3JkQkJveChvcElkeCwgdGhpcy5jdHgsIG1pbk1heFswXSAtIG91dGVyRXh0cmFTaXplLCBtaW5NYXhbMl0gKyBvdXRlckV4dHJhU2l6ZSwgbWluTWF4WzFdIC0gb3V0ZXJFeHRyYVNpemUsIG1pbk1heFszXSArIG91dGVyRXh0cmFTaXplKS5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIFtcInRyYW5zZm9ybVwiXSk7XG4gICAgfVxuICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBQYXRoMkQpKSB7XG4gICAgICBjb25zdCBwYXRoMmQgPSBkYXRhWzBdID0gbmV3IFBhdGgyRCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTspIHtcbiAgICAgICAgc3dpdGNoIChwYXRoW2krK10pIHtcbiAgICAgICAgICBjYXNlIERyYXdPUFMubW92ZVRvOlxuICAgICAgICAgICAgcGF0aDJkLm1vdmVUbyhwYXRoW2krK10sIHBhdGhbaSsrXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIERyYXdPUFMubGluZVRvOlxuICAgICAgICAgICAgcGF0aDJkLmxpbmVUbyhwYXRoW2krK10sIHBhdGhbaSsrXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIERyYXdPUFMuY3VydmVUbzpcbiAgICAgICAgICAgIHBhdGgyZC5iZXppZXJDdXJ2ZVRvKHBhdGhbaSsrXSwgcGF0aFtpKytdLCBwYXRoW2krK10sIHBhdGhbaSsrXSwgcGF0aFtpKytdLCBwYXRoW2krK10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBEcmF3T1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICAgIHBhdGgyZC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB3YXJuKGBVbnJlY29nbml6ZWQgZHJhd2luZyBwYXRoIG9wZXJhdG9yOiAke3BhdGhbaSAtIDFdfWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhdGggPSBwYXRoMmQ7XG4gICAgfVxuICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3gobWluTWF4LCBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KSwgdGhpcy5jdXJyZW50Lm1pbk1heCk7XG4gICAgdGhpc1tvcF0ob3BJZHgsIHBhdGgpO1xuICAgIHRoaXMuX3BhdGhTdGFydElkeCA9IG9wSWR4O1xuICB9XG4gIGNsb3NlUGF0aChvcElkeCkge1xuICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICB9XG4gIHN0cm9rZShvcElkeCwgcGF0aCwgY29uc3VtZVBhdGggPSB0cnVlKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3I7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhO1xuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cm9rZUNvbG9yID09PSBcIm9iamVjdFwiICYmIHN0cm9rZUNvbG9yPy5nZXRQYXR0ZXJuKSB7XG4gICAgICAgIGNvbnN0IGJhc2VUcmFuc2Zvcm0gPSBzdHJva2VDb2xvci5pc01vZGlmeWluZ0N1cnJlbnRUcmFuc2Zvcm0oKSA/IGN0eC5nZXRUcmFuc2Zvcm0oKSA6IG51bGw7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5TVFJPS0UsIG9wSWR4KTtcbiAgICAgICAgaWYgKGJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBjb25zdCBuZXdQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBjdHguZ2V0VHJhbnNmb3JtKCkuaW52ZXJ0U2VsZigpLm11bHRpcGx5U2VsZihiYXNlVHJhbnNmb3JtKSk7XG4gICAgICAgICAgcGF0aCA9IG5ld1BhdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNjYWxlQW5kU3Ryb2tlKHBhdGgsIGZhbHNlKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzY2FsZUFuZFN0cm9rZShwYXRoLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuc3Ryb2tlKTtcbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgob3BJZHgsIHBhdGgsIHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KFBhdGhUeXBlLlNUUk9LRSwgZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCkpKTtcbiAgICB9XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LmZpbGxBbHBoYTtcbiAgfVxuICBjbG9zZVN0cm9rZShvcElkeCwgcGF0aCkge1xuICAgIHRoaXMuc3Ryb2tlKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBmaWxsKG9wSWR4LCBwYXRoLCBjb25zdW1lUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgbGV0IG5lZWRSZXN0b3JlID0gZmFsc2U7XG4gICAgaWYgKGlzUGF0dGVybkZpbGwpIHtcbiAgICAgIGNvbnN0IGJhc2VUcmFuc2Zvcm0gPSBmaWxsQ29sb3IuaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkgPyBjdHguZ2V0VHJhbnNmb3JtKCkgOiBudWxsO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8uc2F2ZShvcElkeCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuRklMTCwgb3BJZHgpO1xuICAgICAgaWYgKGJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgY29uc3QgbmV3UGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgbmV3UGF0aC5hZGRQYXRoKHBhdGgsIGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCkubXVsdGlwbHlTZWxmKGJhc2VUcmFuc2Zvcm0pKTtcbiAgICAgICAgcGF0aCA9IG5ld1BhdGg7XG4gICAgICB9XG4gICAgICBuZWVkUmVzdG9yZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGludGVyc2VjdCA9IHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCk7XG4gICAgaWYgKHRoaXMuY29udGVudFZpc2libGUgJiYgaW50ZXJzZWN0ICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nRU9GaWxsKSB7XG4gICAgICAgIGN0eC5maWxsKHBhdGgsIFwiZXZlbm9kZFwiKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbChwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuZmlsbCk7XG4gICAgaWYgKG5lZWRSZXN0b3JlKSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzdG9yZShvcElkeCk7XG4gICAgfVxuICAgIGlmIChjb25zdW1lUGF0aCkge1xuICAgICAgdGhpcy5jb25zdW1lUGF0aChvcElkeCwgcGF0aCwgaW50ZXJzZWN0KTtcbiAgICB9XG4gIH1cbiAgZW9GaWxsKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLmZpbGwob3BJZHgsIHBhdGgpO1xuICB9XG4gIGZpbGxTdHJva2Uob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLmZpbGwob3BJZHgsIHBhdGgsIGZhbHNlKTtcbiAgICB0aGlzLnN0cm9rZShvcElkeCwgcGF0aCwgZmFsc2UpO1xuICAgIHRoaXMuY29uc3VtZVBhdGgob3BJZHgsIHBhdGgpO1xuICB9XG4gIGVvRmlsbFN0cm9rZShvcElkeCwgcGF0aCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsU3Ryb2tlKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBjbG9zZUZpbGxTdHJva2Uob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLmZpbGxTdHJva2Uob3BJZHgsIHBhdGgpO1xuICB9XG4gIGNsb3NlRU9GaWxsU3Ryb2tlKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLmZpbGxTdHJva2Uob3BJZHgsIHBhdGgpO1xuICB9XG4gIGVuZFBhdGgob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLmNvbnN1bWVQYXRoKG9wSWR4LCBwYXRoKTtcbiAgfVxuICByYXdGaWxsUGF0aChvcElkeCwgcGF0aCkge1xuICAgIHRoaXMuY3R4LmZpbGwocGF0aCk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMucmF3RmlsbFBhdGgpLnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gIH1cbiAgY2xpcChvcElkeCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3koXCJjbGlwTW9kZVwiLCBvcElkeCk7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IE5PUk1BTF9DTElQO1xuICB9XG4gIGVvQ2xpcChvcElkeCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3koXCJjbGlwTW9kZVwiLCBvcElkeCk7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IEVPX0NMSVA7XG4gIH1cbiAgYmVnaW5UZXh0KG9wSWR4KSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXggPSBudWxsO1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYID0gMDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSA9IDA7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkT3Blbk1hcmtlcihvcElkeCkucmVzZXRJbmNyZW1lbnRhbERhdGEoXCJzYW1lTGluZVRleHRcIikucmVzZXRJbmNyZW1lbnRhbERhdGEoXCJtb3ZlVGV4dFwiLCBvcElkeCk7XG4gIH1cbiAgZW5kVGV4dChvcElkeCkge1xuICAgIGNvbnN0IHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICh0aGlzLmRlcGVuZGVuY3lUcmFja2VyKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRlcGVuZGVuY3lUcmFja2VyXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGlmIChwYXRocyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlcGVuZGVuY3lUcmFja2VyLnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3koXCJ0ZXh0Q2xpcFwiLCBkZXBlbmRlbmN5VHJhY2tlci5nZXRPcGVuTWFya2VyKCkpLnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3koXCJ0ZXh0Q2xpcFwiLCBvcElkeCk7XG4gICAgICB9XG4gICAgICBkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRDbG9zZU1hcmtlcihvcElkeCk7XG4gICAgfVxuICAgIGlmIChwYXRocyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBuZXdQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgICAgY29uc3QgaW52VHJhbnNmID0gY3R4LmdldFRyYW5zZm9ybSgpLmludmVydFNlbGYoKTtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBwYXRoXG4gICAgICB9IG9mIHBhdGhzKSB7XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBuZXcgRE9NTWF0cml4KHRyYW5zZm9ybSkucHJlTXVsdGlwbHlTZWxmKGludlRyYW5zZikudHJhbnNsYXRlKHgsIHkpLnNjYWxlKGZvbnRTaXplLCAtZm9udFNpemUpKTtcbiAgICAgIH1cbiAgICAgIGN0eC5jbGlwKG5ld1BhdGgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICB9XG4gIHNldENoYXJTcGFjaW5nKG9wSWR4LCBzcGFjaW5nKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImNoYXJTcGFjaW5nXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQuY2hhclNwYWNpbmcgPSBzcGFjaW5nO1xuICB9XG4gIHNldFdvcmRTcGFjaW5nKG9wSWR4LCBzcGFjaW5nKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcIndvcmRTcGFjaW5nXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQud29yZFNwYWNpbmcgPSBzcGFjaW5nO1xuICB9XG4gIHNldEhTY2FsZShvcElkeCwgc2NhbGUpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiaFNjYWxlXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQudGV4dEhTY2FsZSA9IHNjYWxlIC8gMTAwO1xuICB9XG4gIHNldExlYWRpbmcob3BJZHgsIGxlYWRpbmcpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwibGVhZGluZ1wiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LmxlYWRpbmcgPSAtbGVhZGluZztcbiAgfVxuICBzZXRGb250KG9wSWR4LCBmb250UmVmTmFtZSwgc2l6ZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJmb250XCIsIG9wSWR4KS5yZWNvcmRTaW1wbGVEYXRhRnJvbU5hbWVkKFwiZm9udE9ialwiLCBmb250UmVmTmFtZSwgb3BJZHgpO1xuICAgIGNvbnN0IGZvbnRPYmogPSB0aGlzLmNvbW1vbk9ianMuZ2V0KGZvbnRSZWZOYW1lKTtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmICghZm9udE9iaikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBmaW5kIGZvbnQgZm9yICR7Zm9udFJlZk5hbWV9YCk7XG4gICAgfVxuICAgIGN1cnJlbnQuZm9udE1hdHJpeCA9IGZvbnRPYmouZm9udE1hdHJpeCB8fCBGT05UX0lERU5USVRZX01BVFJJWDtcbiAgICBpZiAoY3VycmVudC5mb250TWF0cml4WzBdID09PSAwIHx8IGN1cnJlbnQuZm9udE1hdHJpeFszXSA9PT0gMCkge1xuICAgICAgd2FybihcIkludmFsaWQgZm9udCBtYXRyaXggZm9yIGZvbnQgXCIgKyBmb250UmVmTmFtZSk7XG4gICAgfVxuICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgc2l6ZSA9IC1zaXplO1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IDE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5mb250ID0gZm9udE9iajtcbiAgICB0aGlzLmN1cnJlbnQuZm9udFNpemUgPSBzaXplO1xuICAgIGlmIChmb250T2JqLmlzVHlwZTNGb250KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBmb250T2JqLmxvYWRlZE5hbWUgfHwgXCJzYW5zLXNlcmlmXCI7XG4gICAgY29uc3QgdHlwZWZhY2UgPSBmb250T2JqLnN5c3RlbUZvbnRJbmZvPy5jc3MgfHwgYFwiJHtuYW1lfVwiLCAke2ZvbnRPYmouZmFsbGJhY2tOYW1lfWA7XG4gICAgbGV0IGJvbGQgPSBcIm5vcm1hbFwiO1xuICAgIGlmIChmb250T2JqLmJsYWNrKSB7XG4gICAgICBib2xkID0gXCI5MDBcIjtcbiAgICB9IGVsc2UgaWYgKGZvbnRPYmouYm9sZCkge1xuICAgICAgYm9sZCA9IFwiYm9sZFwiO1xuICAgIH1cbiAgICBjb25zdCBpdGFsaWMgPSBmb250T2JqLml0YWxpYyA/IFwiaXRhbGljXCIgOiBcIm5vcm1hbFwiO1xuICAgIGxldCBicm93c2VyRm9udFNpemUgPSBzaXplO1xuICAgIGlmIChzaXplIDwgTUlOX0ZPTlRfU0laRSkge1xuICAgICAgYnJvd3NlckZvbnRTaXplID0gTUlOX0ZPTlRfU0laRTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPiBNQVhfRk9OVF9TSVpFKSB7XG4gICAgICBicm93c2VyRm9udFNpemUgPSBNQVhfRk9OVF9TSVpFO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuZm9udFNpemVTY2FsZSA9IHNpemUgLyBicm93c2VyRm9udFNpemU7XG4gICAgdGhpcy5jdHguZm9udCA9IGAke2l0YWxpY30gJHtib2xkfSAke2Jyb3dzZXJGb250U2l6ZX1weCAke3R5cGVmYWNlfWA7XG4gIH1cbiAgc2V0VGV4dFJlbmRlcmluZ01vZGUob3BJZHgsIG1vZGUpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwidGV4dFJlbmRlcmluZ01vZGVcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9IG1vZGU7XG4gIH1cbiAgc2V0VGV4dFJpc2Uob3BJZHgsIHJpc2UpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwidGV4dFJpc2VcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmlzZSA9IHJpc2U7XG4gIH1cbiAgbW92ZVRleHQob3BJZHgsIHgsIHkpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXNldEluY3JlbWVudGFsRGF0YShcInNhbWVMaW5lVGV4dFwiKS5yZWNvcmRJbmNyZW1lbnRhbERhdGEoXCJtb3ZlVGV4dFwiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggKz0geDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSArPSB5O1xuICB9XG4gIHNldExlYWRpbmdNb3ZlVGV4dChvcElkeCwgeCwgeSkge1xuICAgIHRoaXMuc2V0TGVhZGluZyhvcElkeCwgLXkpO1xuICAgIHRoaXMubW92ZVRleHQob3BJZHgsIHgsIHkpO1xuICB9XG4gIHNldFRleHRNYXRyaXgob3BJZHgsIG1hdHJpeCkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJ0ZXh0TWF0cml4XCIsIG9wSWR4KTtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50XG4gICAgfSA9IHRoaXM7XG4gICAgY3VycmVudC50ZXh0TWF0cml4ID0gbWF0cml4O1xuICAgIGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gTWF0aC5oeXBvdChtYXRyaXhbMF0sIG1hdHJpeFsxXSk7XG4gICAgY3VycmVudC54ID0gY3VycmVudC5saW5lWCA9IDA7XG4gICAgY3VycmVudC55ID0gY3VycmVudC5saW5lWSA9IDA7XG4gIH1cbiAgbmV4dExpbmUob3BJZHgpIHtcbiAgICB0aGlzLm1vdmVUZXh0KG9wSWR4LCAwLCB0aGlzLmN1cnJlbnQubGVhZGluZyk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkSW5jcmVtZW50YWxEYXRhKFwibW92ZVRleHRcIiwgdGhpcy5kZXBlbmRlbmN5VHJhY2tlci5nZXRTaW1wbGVJbmRleChcImxlYWRpbmdcIikgPz8gb3BJZHgpO1xuICB9XG4gICNnZXRTY2FsZWRQYXRoKHBhdGgsIGN1cnJlbnRUcmFuc2Zvcm0sIHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IG5ld1BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgbmV3UGF0aC5hZGRQYXRoKHBhdGgsIG5ldyBET01NYXRyaXgodHJhbnNmb3JtKS5pbnZlcnRTZWxmKCkubXVsdGlwbHlTZWxmKGN1cnJlbnRUcmFuc2Zvcm0pKTtcbiAgICByZXR1cm4gbmV3UGF0aDtcbiAgfVxuICBwYWludENoYXIob3BJZHgsIGNoYXJhY3RlciwgeCwgeSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgdGV4dFJlbmRlcmluZ01vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlO1xuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZSAvIGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IHRleHRSZW5kZXJpbmdNb2RlICYgVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcbiAgICBjb25zdCBpc0FkZFRvUGF0aFNldCA9ICEhKHRleHRSZW5kZXJpbmdNb2RlICYgVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRyk7XG4gICAgY29uc3QgcGF0dGVybkZpbGwgPSBjdXJyZW50LnBhdHRlcm5GaWxsICYmICFmb250Lm1pc3NpbmdGaWxlO1xuICAgIGNvbnN0IHBhdHRlcm5TdHJva2UgPSBjdXJyZW50LnBhdHRlcm5TdHJva2UgJiYgIWZvbnQubWlzc2luZ0ZpbGU7XG4gICAgbGV0IHBhdGg7XG4gICAgaWYgKChmb250LmRpc2FibGVGb250RmFjZSB8fCBpc0FkZFRvUGF0aFNldCB8fCBwYXR0ZXJuRmlsbCB8fCBwYXR0ZXJuU3Ryb2tlKSAmJiAhZm9udC5taXNzaW5nRmlsZSkge1xuICAgICAgcGF0aCA9IGZvbnQuZ2V0UGF0aEdlbmVyYXRvcih0aGlzLmNvbW1vbk9ianMsIGNoYXJhY3Rlcik7XG4gICAgfVxuICAgIGlmIChwYXRoICYmIChmb250LmRpc2FibGVGb250RmFjZSB8fCBwYXR0ZXJuRmlsbCB8fCBwYXR0ZXJuU3Ryb2tlKSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHguc2NhbGUoZm9udFNpemUsIC1mb250U2l6ZSk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDaGFyYWN0ZXJCQm94KG9wSWR4LCBjdHgsIGZvbnQpO1xuICAgICAgbGV0IGN1cnJlbnRUcmFuc2Zvcm07XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuRmlsbFRyYW5zZm9ybSkge1xuICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0gPSBjdHguZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5wYXR0ZXJuRmlsbFRyYW5zZm9ybSk7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkUGF0aCA9IHRoaXMuI2dldFNjYWxlZFBhdGgocGF0aCwgY3VycmVudFRyYW5zZm9ybSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0pO1xuICAgICAgICAgIGN0eC5maWxsKHNjYWxlZFBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5maWxsKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgaWYgKHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtIHx8PSBjdHguZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5wYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBkXG4gICAgICAgICAgfSA9IGN1cnJlbnRUcmFuc2Zvcm07XG4gICAgICAgICAgY29uc3QgaW52UGF0dGVyblRyYW5zZm9ybSA9IFV0aWwuaW52ZXJzZVRyYW5zZm9ybShwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKTtcbiAgICAgICAgICBjb25zdCB0cmFuc2YgPSBVdGlsLnRyYW5zZm9ybShbYSwgYiwgYywgZCwgMCwgMF0sIGludlBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgICAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmLCBYWSk7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCAqPSBNYXRoLm1heChYWVswXSwgWFlbMV0pIC8gZm9udFNpemU7XG4gICAgICAgICAgY3R4LnN0cm9rZSh0aGlzLiNnZXRTY2FsZWRQYXRoKHBhdGgsIGN1cnJlbnRUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgubGluZVdpZHRoIC89IGZvbnRTaXplO1xuICAgICAgICAgIGN0eC5zdHJva2UocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZENoYXJhY3RlckJCb3gob3BJZHgsIGN0eCwgZm9udCwgZm9udFNpemUsIHgsIHksICgpID0+IGN0eC5tZWFzdXJlVGV4dChjaGFyYWN0ZXIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZENoYXJhY3RlckJCb3gob3BJZHgsIGN0eCwgZm9udCwgZm9udFNpemUsIHgsIHksICgpID0+IGN0eC5tZWFzdXJlVGV4dChjaGFyYWN0ZXIpKS5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy5zdHJva2UpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2VUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0FkZFRvUGF0aFNldCkge1xuICAgICAgY29uc3QgcGF0aHMgPSB0aGlzLnBlbmRpbmdUZXh0UGF0aHMgfHw9IFtdO1xuICAgICAgcGF0aHMucHVzaCh7XG4gICAgICAgIHRyYW5zZm9ybTogZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgcGF0aFxuICAgICAgfSk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDaGFyYWN0ZXJCQm94KG9wSWR4LCBjdHgsIGZvbnQsIGZvbnRTaXplLCB4LCB5KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzRm9udFN1YnBpeGVsQUFFbmFibGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQ6IGN0eFxuICAgIH0gPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlzRm9udFN1YnBpeGVsQUFFbmFibGVkXCIsIDEwLCAxMCk7XG4gICAgY3R4LnNjYWxlKDEuNSwgMSk7XG4gICAgY3R4LmZpbGxUZXh0KFwiSVwiLCAwLCAxMCk7XG4gICAgY29uc3QgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMTAsIDEwKS5kYXRhO1xuICAgIGxldCBlbmFibGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBpZiAoZGF0YVtpXSA+IDAgJiYgZGF0YVtpXSA8IDI1NSkge1xuICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgfVxuICBzaG93VGV4dChvcElkeCwgZ2x5cGhzKSB7XG4gICAgaWYgKHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuc2hvd1RleHQpLnJlc2V0QkJveChvcElkeCk7XG4gICAgICBpZiAodGhpcy5jdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRykge1xuICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyLnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3koXCJ0ZXh0Q2xpcFwiLCBvcElkeCkuaW5oZXJpdFBlbmRpbmdEZXBlbmRlbmNpZXNBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcygpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgaWYgKGZvbnQuaXNUeXBlM0ZvbnQpIHtcbiAgICAgIHRoaXMuc2hvd1R5cGUzVGV4dChvcElkeCwgZ2x5cGhzKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNob3dUZXh0T3BlcmF0aW9uKG9wSWR4KTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICBpZiAoZm9udFNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmb250U2l6ZVNjYWxlID0gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgIGNvbnN0IHZlcnRpY2FsID0gZm9udC52ZXJ0aWNhbDtcbiAgICBjb25zdCBzcGFjaW5nRGlyID0gdmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgZGVmYXVsdFZNZXRyaWNzID0gZm9udC5kZWZhdWx0Vk1ldHJpY3M7XG4gICAgY29uc3Qgd2lkdGhBZHZhbmNlU2NhbGUgPSBmb250U2l6ZSAqIGN1cnJlbnQuZm9udE1hdHJpeFswXTtcbiAgICBjb25zdCBzaW1wbGVGaWxsVGV4dCA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTEwgJiYgIWZvbnQuZGlzYWJsZUZvbnRGYWNlICYmICFjdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgaWYgKGN1cnJlbnQudGV4dE1hdHJpeCkge1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi5jdXJyZW50LnRleHRNYXRyaXgpO1xuICAgIH1cbiAgICBjdHgudHJhbnNsYXRlKGN1cnJlbnQueCwgY3VycmVudC55ICsgY3VycmVudC50ZXh0UmlzZSk7XG4gICAgaWYgKGZvbnREaXJlY3Rpb24gPiAwKSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgMSk7XG4gICAgfVxuICAgIGxldCBwYXR0ZXJuRmlsbFRyYW5zZm9ybSwgcGF0dGVyblN0cm9rZVRyYW5zZm9ybTtcbiAgICBpZiAoY3VycmVudC5wYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdXJyZW50LmZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuRklMTCwgb3BJZHgpO1xuICAgICAgcGF0dGVybkZpbGxUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHBhdHRlcm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50LnBhdHRlcm5TdHJva2UpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gY3VycmVudC5zdHJva2VDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuU1RST0tFLCBvcElkeCk7XG4gICAgICBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHBhdHRlcm47XG4gICAgfVxuICAgIGxldCBsaW5lV2lkdGggPSBjdXJyZW50LmxpbmVXaWR0aDtcbiAgICBjb25zdCBzY2FsZSA9IGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlO1xuICAgIGlmIChzY2FsZSA9PT0gMCB8fCBsaW5lV2lkdGggPT09IDApIHtcbiAgICAgIGNvbnN0IGZpbGxTdHJva2VNb2RlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgbGluZVdpZHRoID0gdGhpcy5nZXRTaW5nbGVQaXhlbFdpZHRoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVXaWR0aCAvPSBzY2FsZTtcbiAgICB9XG4gICAgaWYgKGZvbnRTaXplU2NhbGUgIT09IDEuMCkge1xuICAgICAgY3R4LnNjYWxlKGZvbnRTaXplU2NhbGUsIGZvbnRTaXplU2NhbGUpO1xuICAgICAgbGluZVdpZHRoIC89IGZvbnRTaXplU2NhbGU7XG4gICAgfVxuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgaWYgKGZvbnQuaXNJbnZhbGlkUERGanNGb250KSB7XG4gICAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgIGZvciAoY29uc3QgZ2x5cGggb2YgZ2x5cGhzKSB7XG4gICAgICAgIGNoYXJzLnB1c2goZ2x5cGgudW5pY29kZSk7XG4gICAgICAgIHdpZHRoICs9IGdseXBoLndpZHRoO1xuICAgICAgfVxuICAgICAgY29uc3Qgam9pbmVkQ2hhcnMgPSBjaGFycy5qb2luKFwiXCIpO1xuICAgICAgY3R4LmZpbGxUZXh0KGpvaW5lZENoYXJzLCAwLCAwKTtcbiAgICAgIGlmICh0aGlzLmRlcGVuZGVuY3lUcmFja2VyICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmUgPSBjdHgubWVhc3VyZVRleHQoam9pbmVkQ2hhcnMpO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyLnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCAtbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveExlZnQsIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hSaWdodCwgLW1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50KS5yZWNvcmRTaG93VGV4dE9wZXJhdGlvbihvcElkeCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50LnggKz0gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAqIHRleHRIU2NhbGU7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5jb21wb3NlKCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgeCA9IDAsXG4gICAgICBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHNMZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICBpZiAodHlwZW9mIGdseXBoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHggKz0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN0b3JlTmVlZGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBjaGFyYWN0ZXIgPSBnbHlwaC5mb250Q2hhcjtcbiAgICAgIGNvbnN0IGFjY2VudCA9IGdseXBoLmFjY2VudDtcbiAgICAgIGxldCBzY2FsZWRYLCBzY2FsZWRZO1xuICAgICAgbGV0IHdpZHRoID0gZ2x5cGgud2lkdGg7XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgY29uc3Qgdm1ldHJpYyA9IGdseXBoLnZtZXRyaWMgfHwgZGVmYXVsdFZNZXRyaWNzO1xuICAgICAgICBjb25zdCB2eCA9IC0oZ2x5cGgudm1ldHJpYyA/IHZtZXRyaWNbMV0gOiB3aWR0aCAqIDAuNSkgKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgY29uc3QgdnkgPSB2bWV0cmljWzJdICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIHdpZHRoID0gdm1ldHJpYyA/IC12bWV0cmljWzBdIDogd2lkdGg7XG4gICAgICAgIHNjYWxlZFggPSB2eCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAoeCArIHZ5KSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZWRYID0geCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAwO1xuICAgICAgfVxuICAgICAgbGV0IG1lYXN1cmU7XG4gICAgICBpZiAoZm9udC5yZW1lYXN1cmUgJiYgd2lkdGggPiAwKSB7XG4gICAgICAgIG1lYXN1cmUgPSBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKTtcbiAgICAgICAgY29uc3QgbWVhc3VyZWRXaWR0aCA9IG1lYXN1cmUud2lkdGggKiAxMDAwIC8gZm9udFNpemUgKiBmb250U2l6ZVNjYWxlO1xuICAgICAgICBpZiAod2lkdGggPCBtZWFzdXJlZFdpZHRoICYmIHRoaXMuaXNGb250U3VicGl4ZWxBQUVuYWJsZWQpIHtcbiAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJTY2FsZVggPSB3aWR0aCAvIG1lYXN1cmVkV2lkdGg7XG4gICAgICAgICAgcmVzdG9yZU5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBjdHguc2NhbGUoY2hhcmFjdGVyU2NhbGVYLCAxKTtcbiAgICAgICAgICBzY2FsZWRYIC89IGNoYXJhY3RlclNjYWxlWDtcbiAgICAgICAgfSBlbHNlIGlmICh3aWR0aCAhPT0gbWVhc3VyZWRXaWR0aCkge1xuICAgICAgICAgIHNjYWxlZFggKz0gKHdpZHRoIC0gbWVhc3VyZWRXaWR0aCkgLyAyMDAwICogZm9udFNpemUgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSAmJiAoZ2x5cGguaXNJbkZvbnQgfHwgZm9udC5taXNzaW5nRmlsZSkpIHtcbiAgICAgICAgaWYgKHNpbXBsZUZpbGxUZXh0ICYmICFhY2NlbnQpIHtcbiAgICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZKTtcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDaGFyYWN0ZXJCQm94KG9wSWR4LCBjdHgsIG1lYXN1cmUgPyB7XG4gICAgICAgICAgICBiYm94OiBudWxsXG4gICAgICAgICAgfSA6IGZvbnQsIGZvbnRTaXplIC8gZm9udFNpemVTY2FsZSwgc2NhbGVkWCwgc2NhbGVkWSwgKCkgPT4gbWVhc3VyZSA/PyBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYWludENoYXIob3BJZHgsIGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pO1xuICAgICAgICAgIGlmIChhY2NlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZEFjY2VudFggPSBzY2FsZWRYICsgZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQWNjZW50WSA9IHNjYWxlZFkgLSBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q2hhcihvcElkeCwgYWNjZW50LmZvbnRDaGFyLCBzY2FsZWRBY2NlbnRYLCBzY2FsZWRBY2NlbnRZLCBwYXR0ZXJuRmlsbFRyYW5zZm9ybSwgcGF0dGVyblN0cm9rZVRyYW5zZm9ybSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFyV2lkdGggPSB2ZXJ0aWNhbCA/IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgLSBzcGFjaW5nICogZm9udERpcmVjdGlvbiA6IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKyBzcGFjaW5nICogZm9udERpcmVjdGlvbjtcbiAgICAgIHggKz0gY2hhcldpZHRoO1xuICAgICAgaWYgKHJlc3RvcmVOZWVkZWQpIHtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICBjdXJyZW50LnkgLT0geDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC54ICs9IHggKiB0ZXh0SFNjYWxlO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNob3dUZXh0T3BlcmF0aW9uKG9wSWR4KTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHNob3dUeXBlM1RleHQob3BJZHgsIGdseXBocykge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBzcGFjaW5nRGlyID0gZm9udC52ZXJ0aWNhbCA/IDEgOiAtMTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IHRleHRIU2NhbGUgPSBjdXJyZW50LnRleHRIU2NhbGUgKiBmb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IGZvbnRNYXRyaXggPSBjdXJyZW50LmZvbnRNYXRyaXggfHwgRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCBpc1RleHRJbnZpc2libGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5JTlZJU0lCTEU7XG4gICAgbGV0IGksIGdseXBoLCB3aWR0aCwgc3BhY2luZ0xlbmd0aDtcbiAgICBpZiAoaXNUZXh0SW52aXNpYmxlIHx8IGZvbnRTaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChjdXJyZW50LnRleHRNYXRyaXgpIHtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4uY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICB9XG4gICAgY3R4LnRyYW5zbGF0ZShjdXJyZW50LngsIGN1cnJlbnQueSArIGN1cnJlbnQudGV4dFJpc2UpO1xuICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCBmb250RGlyZWN0aW9uKTtcbiAgICBjb25zdCBkZXBlbmRlbmN5VHJhY2tlciA9IHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlciA9IGRlcGVuZGVuY3lUcmFja2VyID8gbmV3IENhbnZhc05lc3RlZERlcGVuZGVuY3lUcmFja2VyKGRlcGVuZGVuY3lUcmFja2VyLCBvcElkeCkgOiBudWxsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHNMZW5ndGg7ICsraSkge1xuICAgICAgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICBpZiAodHlwZW9mIGdseXBoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHNwYWNpbmdMZW5ndGggPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgIHRoaXMuY3R4LnRyYW5zbGF0ZShzcGFjaW5nTGVuZ3RoLCAwKTtcbiAgICAgICAgY3VycmVudC54ICs9IHNwYWNpbmdMZW5ndGggKiB0ZXh0SFNjYWxlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IG9wZXJhdG9yTGlzdCA9IGZvbnQuY2hhclByb2NPcGVyYXRvckxpc3RbZ2x5cGgub3BlcmF0b3JMaXN0SWRdO1xuICAgICAgaWYgKCFvcGVyYXRvckxpc3QpIHtcbiAgICAgICAgd2FybihgVHlwZTMgY2hhcmFjdGVyIFwiJHtnbHlwaC5vcGVyYXRvckxpc3RJZH1cIiBpcyBub3QgYXZhaWxhYmxlLmApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICBjdHguc2NhbGUoZm9udFNpemUsIGZvbnRTaXplKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi5mb250TWF0cml4KTtcbiAgICAgICAgdGhpcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcCA9IFtnbHlwaC53aWR0aCwgMF07XG4gICAgICBVdGlsLmFwcGx5VHJhbnNmb3JtKHAsIGZvbnRNYXRyaXgpO1xuICAgICAgd2lkdGggPSBwWzBdICogZm9udFNpemUgKyBzcGFjaW5nO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCwgMCk7XG4gICAgICBjdXJyZW50LnggKz0gd2lkdGggKiB0ZXh0SFNjYWxlO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGlmIChkZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlciA9IGRlcGVuZGVuY3lUcmFja2VyO1xuICAgIH1cbiAgfVxuICBzZXRDaGFyV2lkdGgob3BJZHgsIHhXaWR0aCwgeVdpZHRoKSB7fVxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHMob3BJZHgsIHhXaWR0aCwgeVdpZHRoLCBsbHgsIGxseSwgdXJ4LCB1cnkpIHtcbiAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgIGNsaXAucmVjdChsbHgsIGxseSwgdXJ4IC0gbGx4LCB1cnkgLSBsbHkpO1xuICAgIHRoaXMuY3R4LmNsaXAoY2xpcCk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQkJveChvcElkeCwgdGhpcy5jdHgsIGxseCwgdXJ4LCBsbHksIHVyeSkucmVjb3JkQ2xpcEJveChvcElkeCwgdGhpcy5jdHgsIGxseCwgdXJ4LCBsbHksIHVyeSk7XG4gICAgdGhpcy5lbmRQYXRoKG9wSWR4KTtcbiAgfVxuICBnZXRDb2xvck5fUGF0dGVybihvcElkeCwgSVIpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAoSVJbMF0gPT09IFwiVGlsaW5nUGF0dGVyblwiKSB7XG4gICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gdGhpcy5iYXNlVHJhbnNmb3JtIHx8IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgICAgY29uc3QgY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0ge1xuICAgICAgICBjcmVhdGVDYW52YXNHcmFwaGljczogKGN0eCwgcmVuZGVyaW5nT3BJZHgpID0+IG5ldyBDYW52YXNHcmFwaGljcyhjdHgsIHRoaXMuY29tbW9uT2JqcywgdGhpcy5vYmpzLCB0aGlzLmNhbnZhc0ZhY3RvcnksIHRoaXMuZmlsdGVyRmFjdG9yeSwge1xuICAgICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZzogdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcsXG4gICAgICAgICAgbWFya2VkQ29udGVudFN0YWNrOiB0aGlzLm1hcmtlZENvbnRlbnRTdGFja1xuICAgICAgICB9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcy5kZXBlbmRlbmN5VHJhY2tlciA/IG5ldyBDYW52YXNOZXN0ZWREZXBlbmRlbmN5VHJhY2tlcih0aGlzLmRlcGVuZGVuY3lUcmFja2VyLCByZW5kZXJpbmdPcElkeCwgdHJ1ZSkgOiBudWxsKVxuICAgICAgfTtcbiAgICAgIHBhdHRlcm4gPSBuZXcgVGlsaW5nUGF0dGVybihJUiwgdGhpcy5jdHgsIGNhbnZhc0dyYXBoaWNzRmFjdG9yeSwgYmFzZVRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLl9nZXRQYXR0ZXJuKG9wSWR4LCBJUlsxXSwgSVJbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzZXRTdHJva2VDb2xvck4ob3BJZHgsIC4uLmFyZ3MpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwic3Ryb2tlQ29sb3JcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4ob3BJZHgsIGFyZ3MpO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuU3Ryb2tlID0gdHJ1ZTtcbiAgfVxuICBzZXRGaWxsQ29sb3JOKG9wSWR4LCAuLi5hcmdzKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImZpbGxDb2xvclwiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4ob3BJZHgsIGFyZ3MpO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbCA9IHRydWU7XG4gIH1cbiAgc2V0U3Ryb2tlUkdCQ29sb3Iob3BJZHgsIGNvbG9yKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInN0cm9rZUNvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuU3Ryb2tlID0gZmFsc2U7XG4gIH1cbiAgc2V0U3Ryb2tlVHJhbnNwYXJlbnQob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwic3Ryb2tlQ29sb3JcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuU3Ryb2tlID0gZmFsc2U7XG4gIH1cbiAgc2V0RmlsbFJHQkNvbG9yKG9wSWR4LCBjb2xvcikge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJmaWxsQ29sb3JcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBzZXRGaWxsVHJhbnNwYXJlbnQob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZmlsbENvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICB9XG4gIF9nZXRQYXR0ZXJuKG9wSWR4LCBvYmpJZCwgbWF0cml4ID0gbnVsbCkge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmICh0aGlzLmNhY2hlZFBhdHRlcm5zLmhhcyhvYmpJZCkpIHtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLmNhY2hlZFBhdHRlcm5zLmdldChvYmpJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4gPSBnZXRTaGFkaW5nUGF0dGVybih0aGlzLmdldE9iamVjdChvcElkeCwgb2JqSWQpKTtcbiAgICAgIHRoaXMuY2FjaGVkUGF0dGVybnMuc2V0KG9iaklkLCBwYXR0ZXJuKTtcbiAgICB9XG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgcGF0dGVybi5tYXRyaXggPSBtYXRyaXg7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG4gIHNoYWRpbmdGaWxsKG9wSWR4LCBvYmpJZCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLnNhdmUob3BJZHgpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl9nZXRQYXR0ZXJuKG9wSWR4LCBvYmpJZCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHBhdHRlcm4uZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLlNIQURJTkcsIG9wSWR4KTtcbiAgICBjb25zdCBpbnYgPSBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpO1xuICAgIGlmIChpbnYpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IGN0eC5jYW52YXM7XG4gICAgICBjb25zdCBtaW5NYXggPSBNSU5fTUFYX0lOSVQuc2xpY2UoKTtcbiAgICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBpbnYsIG1pbk1heCk7XG4gICAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gbWluTWF4O1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoLTFlMTAsIC0xZTEwLCAyZTEwLCAyZTEwKTtcbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KS5yZWNvcmRGdWxsUGFnZUJCb3gob3BJZHgpLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnRyYW5zZm9ybSkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuZmlsbCkucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgICB0aGlzLmNvbXBvc2UodGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5yZXN0b3JlKG9wSWR4KTtcbiAgfVxuICBiZWdpbklubGluZUltYWdlKCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW5saW5lSW1hZ2VcIik7XG4gIH1cbiAgYmVnaW5JbWFnZURhdGEoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJTaG91bGQgbm90IGNhbGwgYmVnaW5JbWFnZURhdGFcIik7XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luKG9wSWR4LCBtYXRyaXgsIGJib3gpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zYXZlKG9wSWR4KTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wdXNoKHRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgdGhpcy50cmFuc2Zvcm0ob3BJZHgsIC4uLm1hdHJpeCk7XG4gICAgfVxuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgIGlmIChiYm94KSB7XG4gICAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KGJib3gsIHRoaXMuYmFzZVRyYW5zZm9ybSwgdGhpcy5jdXJyZW50Lm1pbk1heCk7XG4gICAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gYmJveDtcbiAgICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgICBjbGlwLnJlY3QoeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbiAgICAgIHRoaXMuY3R4LmNsaXAoY2xpcCk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDbGlwQm94KG9wSWR4LCB0aGlzLmN0eCwgeDAsIHgxLCB5MCwgeTEpO1xuICAgICAgdGhpcy5lbmRQYXRoKG9wSWR4KTtcbiAgICB9XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEVuZChvcElkeCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlc3RvcmUob3BJZHgpO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICB9XG4gIGJlZ2luR3JvdXAob3BJZHgsIGdyb3VwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2F2ZShvcElkeCk7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMuZW5kU01hc2tNb2RlKCk7XG4gICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Q3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKCFncm91cC5pc29sYXRlZCkge1xuICAgICAgaW5mbyhcIlRPRE86IFN1cHBvcnQgbm9uLWlzb2xhdGVkIGdyb3Vwcy5cIik7XG4gICAgfVxuICAgIGlmIChncm91cC5rbm9ja291dCkge1xuICAgICAgd2FybihcIktub2Nrb3V0IGdyb3VwcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3VycmVudEN0eCk7XG4gICAgaWYgKGdyb3VwLm1hdHJpeCkge1xuICAgICAgY3VycmVudEN0eC50cmFuc2Zvcm0oLi4uZ3JvdXAubWF0cml4KTtcbiAgICB9XG4gICAgaWYgKCFncm91cC5iYm94KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3VuZGluZyBib3ggaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBsZXQgYm91bmRzID0gTUlOX01BWF9JTklULnNsaWNlKCk7XG4gICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChncm91cC5iYm94LCBnZXRDdXJyZW50VHJhbnNmb3JtKGN1cnJlbnRDdHgpLCBib3VuZHMpO1xuICAgIGNvbnN0IGNhbnZhc0JvdW5kcyA9IFswLCAwLCBjdXJyZW50Q3R4LmNhbnZhcy53aWR0aCwgY3VycmVudEN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICBib3VuZHMgPSBVdGlsLmludGVyc2VjdChib3VuZHMsIGNhbnZhc0JvdW5kcykgfHwgWzAsIDAsIDAsIDBdO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKGJvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IoYm91bmRzWzFdKTtcbiAgICBjb25zdCBkcmF3bldpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKGJvdW5kc1syXSkgLSBvZmZzZXRYLCAxKTtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbM10pIC0gb2Zmc2V0WSwgMSk7XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3goWzAsIDAsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0XSk7XG4gICAgbGV0IGNhY2hlSWQgPSBcImdyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIGNhY2hlSWQgKz0gXCJfc21hc2tfXCIgKyB0aGlzLnNtYXNrQ291bnRlcisrICUgMjtcbiAgICB9XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBncm91cEN0eCA9IHNjcmF0Y2hDYW52YXMuY29udGV4dDtcbiAgICBncm91cEN0eC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgICBncm91cEN0eC50cmFuc2Zvcm0oLi4uY3VycmVudFRyYW5zZm9ybSk7XG4gICAgbGV0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IGdyb3VwLmJib3g7XG4gICAgY2xpcC5yZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgaWYgKGdyb3VwLm1hdHJpeCkge1xuICAgICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHBhdGguYWRkUGF0aChjbGlwLCBuZXcgRE9NTWF0cml4KGdyb3VwLm1hdHJpeCkpO1xuICAgICAgY2xpcCA9IHBhdGg7XG4gICAgfVxuICAgIGdyb3VwQ3R4LmNsaXAoY2xpcCk7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnNtYXNrU3RhY2sucHVzaCh7XG4gICAgICAgIGNhbnZhczogc2NyYXRjaENhbnZhcy5jYW52YXMsXG4gICAgICAgIGNvbnRleHQ6IGdyb3VwQ3R4LFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgICAgICBzdWJ0eXBlOiBncm91cC5zbWFzay5zdWJ0eXBlLFxuICAgICAgICBiYWNrZHJvcDogZ3JvdXAuc21hc2suYmFja2Ryb3AsXG4gICAgICAgIHRyYW5zZmVyTWFwOiBncm91cC5zbWFzay50cmFuc2Zlck1hcCB8fCBudWxsLFxuICAgICAgICBzdGFydFRyYW5zZm9ybUludmVyc2U6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWdyb3VwLnNtYXNrIHx8IHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICAgIGN1cnJlbnRDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY3VycmVudEN0eC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICBjdXJyZW50Q3R4LnNhdmUoKTtcbiAgICB9XG4gICAgY29weUN0eFN0YXRlKGN1cnJlbnRDdHgsIGdyb3VwQ3R4KTtcbiAgICB0aGlzLmN0eCA9IGdyb3VwQ3R4O1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LmluaGVyaXRTaW1wbGVEYXRhQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMoW1wiZmlsbEFscGhhXCIsIFwic3Ryb2tlQWxwaGFcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIl0pLnB1c2hCYXNlVHJhbnNmb3JtKGN1cnJlbnRDdHgpO1xuICAgIHRoaXMuc2V0R1N0YXRlKG9wSWR4LCBbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXSwgW1wiY2FcIiwgMV0sIFtcIkNBXCIsIDFdXSk7XG4gICAgdGhpcy5ncm91cFN0YWNrLnB1c2goY3VycmVudEN0eCk7XG4gICAgdGhpcy5ncm91cExldmVsKys7XG4gIH1cbiAgZW5kR3JvdXAob3BJZHgsIGdyb3VwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ3JvdXBMZXZlbC0tO1xuICAgIGNvbnN0IGdyb3VwQ3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5ncm91cFN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnBvcEJhc2VUcmFuc2Zvcm0oKTtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIHRoaXMudGVtcFNNYXNrID0gdGhpcy5zbWFza1N0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5yZXN0b3JlKG9wSWR4KTtcbiAgICAgIGlmICh0aGlzLmRlcGVuZGVuY3lUcmFja2VyKSB7XG4gICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgY29uc3QgY3VycmVudE10eCA9IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgICAgdGhpcy5yZXN0b3JlKG9wSWR4KTtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSguLi5jdXJyZW50TXR4KTtcbiAgICAgIGNvbnN0IGRpcnR5Qm94ID0gTUlOX01BWF9JTklULnNsaWNlKCk7XG4gICAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCBncm91cEN0eC5jYW52YXMud2lkdGgsIGdyb3VwQ3R4LmNhbnZhcy5oZWlnaHRdLCBjdXJyZW50TXR4LCBkaXJ0eUJveCk7XG4gICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoZ3JvdXBDdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZShkaXJ0eUJveCk7XG4gICAgfVxuICB9XG4gIGJlZ2luQW5ub3RhdGlvbihvcElkeCwgaWQsIHJlY3QsIHRyYW5zZm9ybSwgbWF0cml4LCBoYXNPd25DYW52YXMpIHtcbiAgICB0aGlzLiNyZXN0b3JlSW5pdGlhbFN0YXRlKCk7XG4gICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB0aGlzLnNhdmUob3BJZHgpO1xuICAgIGlmICh0aGlzLmJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSguLi50aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAocmVjdCkge1xuICAgICAgY29uc3Qgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgICAgaWYgKGhhc093bkNhbnZhcyAmJiB0aGlzLmFubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLnNsaWNlKCk7XG4gICAgICAgIHRyYW5zZm9ybVs0XSAtPSByZWN0WzBdO1xuICAgICAgICB0cmFuc2Zvcm1bNV0gLT0gcmVjdFsxXTtcbiAgICAgICAgcmVjdCA9IHJlY3Quc2xpY2UoKTtcbiAgICAgICAgcmVjdFswXSA9IHJlY3RbMV0gPSAwO1xuICAgICAgICByZWN0WzJdID0gd2lkdGg7XG4gICAgICAgIHJlY3RbM10gPSBoZWlnaHQ7XG4gICAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCksIFhZKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHZpZXdwb3J0U2NhbGVcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogdGhpcy5vdXRwdXRTY2FsZVggKiB2aWV3cG9ydFNjYWxlKTtcbiAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIHRoaXMub3V0cHV0U2NhbGVZICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhcyA9IHRoaXMuY2FudmFzRmFjdG9yeS5jcmVhdGUoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9ID0gdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAuc2V0KGlkLCBjYW52YXMpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHggPSB0aGlzLmN0eDtcbiAgICAgICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShYWVswXSwgMCwgMCwgLVhZWzFdLCAwLCBoZWlnaHQgKiBYWVsxXSk7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKG9wSWR4KTtcbiAgICAgICAgY29uc3QgY2xpcCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgY2xpcC5yZWN0KHJlY3RbMF0sIHJlY3RbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmN0eC5jbGlwKGNsaXApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSh0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMudHJhbnNmb3JtKG9wSWR4LCAuLi50cmFuc2Zvcm0pO1xuICAgIHRoaXMudHJhbnNmb3JtKG9wSWR4LCAuLi5tYXRyaXgpO1xuICB9XG4gIGVuZEFubm90YXRpb24ob3BJZHgpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uQ2FudmFzKSB7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLiNkcmF3RmlsdGVyKCk7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMuYW5ub3RhdGlvbkNhbnZhcy5zYXZlZEN0eDtcbiAgICAgIGRlbGV0ZSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgIH1cbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3Qob3BJZHgsIGltZykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb3VudCA9IGltZy5jb3VudDtcbiAgICBpbWcgPSB0aGlzLmdldE9iamVjdChvcElkeCwgaW1nLmRhdGEsIGltZyk7XG4gICAgaW1nLmNvdW50ID0gY291bnQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgbWFzayA9IHRoaXMuX2NyZWF0ZU1hc2tDYW52YXMob3BJZHgsIGltZyk7XG4gICAgY29uc3QgbWFza0NhbnZhcyA9IG1hc2suY2FudmFzO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBjdHguZHJhd0ltYWdlKG1hc2tDYW52YXMsIG1hc2sub2Zmc2V0WCwgbWFzay5vZmZzZXRZKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXNldEJCb3gob3BJZHgpLnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCBtYXNrLm9mZnNldFgsIG1hc2sub2Zmc2V0WCArIG1hc2tDYW52YXMud2lkdGgsIG1hc2sub2Zmc2V0WSwgbWFzay5vZmZzZXRZICsgbWFza0NhbnZhcy5oZWlnaHQpLnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQob3BJZHgsIGltZywgc2NhbGVYLCBza2V3WCA9IDAsIHNrZXdZID0gMCwgc2NhbGVZLCBwb3NpdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIGltZy5kYXRhLCBpbWcpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICBjdHgudHJhbnNmb3JtKHNjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIDAsIDApO1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKG9wSWR4LCBpbWcpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgbWFzay5vZmZzZXRYIC0gY3VycmVudFRyYW5zZm9ybVs0XSwgbWFzay5vZmZzZXRZIC0gY3VycmVudFRyYW5zZm9ybVs1XSk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgY29uc3QgdHJhbnMgPSBVdGlsLnRyYW5zZm9ybShjdXJyZW50VHJhbnNmb3JtLCBbc2NhbGVYLCBza2V3WCwgc2tld1ksIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdXSk7XG4gICAgICBjdHguZHJhd0ltYWdlKG1hc2suY2FudmFzLCB0cmFuc1s0XSwgdHJhbnNbNV0pO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQkJveChvcElkeCwgdGhpcy5jdHgsIHRyYW5zWzRdLCB0cmFuc1s0XSArIG1hc2suY2FudmFzLndpZHRoLCB0cmFuc1s1XSwgdHJhbnNbNV0gKyBtYXNrLmNhbnZhcy5oZWlnaHQpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXAob3BJZHgsIGltYWdlcykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KS5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy50cmFuc2Zvcm1BbmRGaWxsKTtcbiAgICBmb3IgKGNvbnN0IGltYWdlIG9mIGltYWdlcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB0cmFuc2Zvcm1cbiAgICAgIH0gPSBpbWFnZTtcbiAgICAgIGNvbnN0IG1hc2tDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tDYW52YXNcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBtYXNrQ3R4ID0gbWFza0NhbnZhcy5jb250ZXh0O1xuICAgICAgbWFza0N0eC5zYXZlKCk7XG4gICAgICBjb25zdCBpbWcgPSB0aGlzLmdldE9iamVjdChvcElkeCwgZGF0YSwgaW1hZ2UpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDdHgsIGltZyk7XG4gICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihtYXNrQ3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5GSUxMLCBvcElkeCkgOiBmaWxsQ29sb3I7XG4gICAgICBtYXNrQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIG1hc2tDYW52YXMuY2FudmFzLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAtMSwgMSwgMSk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRCQm94KG9wSWR4LCBjdHgsIDAsIHdpZHRoLCAwLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdChvcElkeCwgb2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW1nRGF0YSA9IHRoaXMuZ2V0T2JqZWN0KG9wSWR4LCBvYmpJZCk7XG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICB3YXJuKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChvcElkeCwgaW1nRGF0YSk7XG4gIH1cbiAgcGFpbnRJbWFnZVhPYmplY3RSZXBlYXQob3BJZHgsIG9iaklkLCBzY2FsZVgsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvcElkeCwgb2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgd2FybihcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBtYXAgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgbWFwLnB1c2goe1xuICAgICAgICB0cmFuc2Zvcm06IFtzY2FsZVgsIDAsIDAsIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdXSxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdzogd2lkdGgsXG4gICAgICAgIGg6IGhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChvcElkeCwgaW1nRGF0YSwgbWFwKTtcbiAgfVxuICBhcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKGN0eCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzICE9PSBcIm5vbmVcIikge1xuICAgICAgY3R4LmZpbHRlciA9IHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHM7XG4gICAgICBjdHguZHJhd0ltYWdlKGN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIH1cbiAgICByZXR1cm4gY3R4LmNhbnZhcztcbiAgfVxuICBhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwKGltZ0RhdGEpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9PT0gXCJub25lXCIpIHtcbiAgICAgIHJldHVybiBpbWdEYXRhLmJpdG1hcDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYml0bWFwLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1nRGF0YTtcbiAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIHRtcEN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzO1xuICAgIHRtcEN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwKTtcbiAgICB0bXBDdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgcmV0dXJuIHRtcENhbnZhcy5jYW52YXM7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3Qob3BJZHgsIGltZ0RhdGEpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuc2F2ZShvcElkeCk7XG4gICAgY29uc3Qge1xuICAgICAgZmlsdGVyXG4gICAgfSA9IGN0eDtcbiAgICBpZiAoZmlsdGVyICE9PSBcIm5vbmVcIiAmJiBmaWx0ZXIgIT09IFwiXCIpIHtcbiAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgY3R4LnNjYWxlKDEgLyB3aWR0aCwgLTEgLyBoZWlnaHQpO1xuICAgIGxldCBpbWdUb1BhaW50O1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcChpbWdEYXRhKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCAhaW1nRGF0YS5kYXRhKSB7XG4gICAgICBpbWdUb1BhaW50ID0gaW1nRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgcHV0QmluYXJ5SW1hZ2VEYXRhKHRtcEN0eCwgaW1nRGF0YSk7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKHRtcEN0eCk7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UoaW1nVG9QYWludCwgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSk7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGdldEltYWdlU21vb3RoaW5nRW5hYmxlZChnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCksIGltZ0RhdGEuaW50ZXJwb2xhdGUpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCkucmVjb3JkQkJveChvcElkeCwgY3R4LCAwLCB3aWR0aCwgLWhlaWdodCwgMCkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuaW1hZ2VYT2JqZWN0KS5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIHNjYWxlZC5pbWcsIDAsIDAsIHNjYWxlZC5wYWludFdpZHRoLCBzY2FsZWQucGFpbnRIZWlnaHQsIDAsIC1oZWlnaHQsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChvcElkeCwgaW1nRGF0YSwgbWFwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGxldCBpbWdUb1BhaW50O1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgaW1nVG9QYWludCA9IGltZ0RhdGEuYml0bWFwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3ID0gaW1nRGF0YS53aWR0aDtcbiAgICAgIGNvbnN0IGggPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgdywgaCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHB1dEJpbmFyeUltYWdlRGF0YSh0bXBDdHgsIGltZ0RhdGEpO1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyh0bXBDdHgpO1xuICAgIH1cbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXNldEJCb3gob3BJZHgpO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgbWFwKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi5lbnRyeS50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIGltZ1RvUGFpbnQsIGVudHJ5LngsIGVudHJ5LnksIGVudHJ5LncsIGVudHJ5LmgsIDAsIC0xLCAxLCAxKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEJCb3gob3BJZHgsIGN0eCwgMCwgMSwgLTEsIDApO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2sob3BJZHgpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KS5yZWNvcmRCQm94KG9wSWR4LCB0aGlzLmN0eCwgMCwgMSwgMCwgMSkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuZmlsbCkucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBtYXJrUG9pbnQob3BJZHgsIHRhZykge31cbiAgbWFya1BvaW50UHJvcHMob3BJZHgsIHRhZywgcHJvcGVydGllcykge31cbiAgYmVnaW5NYXJrZWRDb250ZW50KG9wSWR4LCB0YWcpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5iZWdpbk1hcmtlZENvbnRlbnQob3BJZHgpO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzKG9wSWR4LCB0YWcsIHByb3BlcnRpZXMpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5iZWdpbk1hcmtlZENvbnRlbnQob3BJZHgpO1xuICAgIGlmICh0YWcgPT09IFwiT0NcIikge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLmlzVmlzaWJsZShwcm9wZXJ0aWVzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG4gIGVuZE1hcmtlZENvbnRlbnQob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5lbmRNYXJrZWRDb250ZW50KG9wSWR4KTtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wb3AoKTtcbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gIH1cbiAgYmVnaW5Db21wYXQob3BJZHgpIHt9XG4gIGVuZENvbXBhdChvcElkeCkge31cbiAgY29uc3VtZVBhdGgob3BJZHgsIHBhdGgsIGNsaXBCb3gpIHtcbiAgICBjb25zdCBpc0VtcHR5ID0gdGhpcy5jdXJyZW50LmlzRW1wdHlDbGlwKCk7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIHRoaXMuY3VycmVudC51cGRhdGVDbGlwRnJvbVBhdGgoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICB0aGlzLmNvbXBvc2UoY2xpcEJveCk7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NsaXAgPT09IEVPX0NMSVApIHtcbiAgICAgICAgICBjdHguY2xpcChwYXRoLCBcImV2ZW5vZGRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmNsaXAocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8uYmJveFRvQ2xpcEJveERyb3BPcGVyYXRpb24ob3BJZHgpLnJlY29yZEZ1dHVyZUZvcmNlZERlcGVuZGVuY3koXCJjbGlwUGF0aFwiLCBvcElkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5zdGFydE5ld1BhdGhBbmRDbGlwQm94KHRoaXMuY3VycmVudC5jbGlwQm94KTtcbiAgfVxuICBnZXRTaW5nbGVQaXhlbFdpZHRoKCkge1xuICAgIGlmICghdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCkge1xuICAgICAgY29uc3QgbSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgICAgaWYgKG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gMSAvIE1hdGgubWluKE1hdGguYWJzKG1bMF0pLCBNYXRoLmFicyhtWzNdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KG1bMF0sIG1bMl0pO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QobVsxXSwgbVszXSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBNYXRoLm1heChub3JtWCwgbm9ybVkpIC8gYWJzRGV0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aDtcbiAgfVxuICBnZXRTY2FsZUZvclN0cm9raW5nKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID09PSAtMSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lV2lkdGhcbiAgICAgIH0gPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIGMsXG4gICAgICAgIGRcbiAgICAgIH0gPSB0aGlzLmN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgIGxldCBzY2FsZVgsIHNjYWxlWTtcbiAgICAgIGlmIChiID09PSAwICYmIGMgPT09IDApIHtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmFicyhhKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmFicyhkKTtcbiAgICAgICAgaWYgKG5vcm1YID09PSBub3JtWSkge1xuICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IDEgLyBub3JtWDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgICBzY2FsZVggPSBzY2FsZVkgPSBzY2FsZWRMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZExpbmVXaWR0aCA6IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHNjYWxlWCA9IDEgLyBub3JtWDtcbiAgICAgICAgICBzY2FsZVkgPSAxIC8gbm9ybVk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWExpbmVXaWR0aCA9IG5vcm1YICogbGluZVdpZHRoO1xuICAgICAgICAgIGNvbnN0IHNjYWxlZFlMaW5lV2lkdGggPSBub3JtWSAqIGxpbmVXaWR0aDtcbiAgICAgICAgICBzY2FsZVggPSBzY2FsZWRYTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRYTGluZVdpZHRoIDogMTtcbiAgICAgICAgICBzY2FsZVkgPSBzY2FsZWRZTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRZTGluZVdpZHRoIDogMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWJzRGV0ID0gTWF0aC5hYnMoYSAqIGQgLSBiICogYyk7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmh5cG90KGMsIGQpO1xuICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gbm9ybVkgLyBhYnNEZXQ7XG4gICAgICAgICAgc2NhbGVZID0gbm9ybVggLyBhYnNEZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYmFzZUFyZWEgPSBsaW5lV2lkdGggKiBhYnNEZXQ7XG4gICAgICAgICAgc2NhbGVYID0gbm9ybVkgPiBiYXNlQXJlYSA/IG5vcm1ZIC8gYmFzZUFyZWEgOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IG5vcm1YID4gYmFzZUFyZWEgPyBub3JtWCAvIGJhc2VBcmVhIDogMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IHNjYWxlWDtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMV0gPSBzY2FsZVk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nO1xuICB9XG4gIHJlc2NhbGVBbmRTdHJva2UocGF0aCwgc2F2ZVJlc3RvcmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdHgsXG4gICAgICBjdXJyZW50OiB7XG4gICAgICAgIGxpbmVXaWR0aFxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtzY2FsZVgsIHNjYWxlWV0gPSB0aGlzLmdldFNjYWxlRm9yU3Ryb2tpbmcoKTtcbiAgICBpZiAoc2NhbGVYID09PSBzY2FsZVkpIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAobGluZVdpZHRoIHx8IDEpICogc2NhbGVYO1xuICAgICAgY3R4LnN0cm9rZShwYXRoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGFzaGVzID0gY3R4LmdldExpbmVEYXNoKCk7XG4gICAgaWYgKHNhdmVSZXN0b3JlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgIH1cbiAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgIFNDQUxFX01BVFJJWC5hID0gMSAvIHNjYWxlWDtcbiAgICBTQ0FMRV9NQVRSSVguZCA9IDEgLyBzY2FsZVk7XG4gICAgY29uc3QgbmV3UGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICBuZXdQYXRoLmFkZFBhdGgocGF0aCwgU0NBTEVfTUFUUklYKTtcbiAgICBpZiAoZGFzaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcy5tYXAoeCA9PiB4IC8gc2NhbGUpKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCAvPSBzY2FsZTtcbiAgICB9XG4gICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCB8fCAxO1xuICAgIGN0eC5zdHJva2UobmV3UGF0aCk7XG4gICAgaWYgKHNhdmVSZXN0b3JlKSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBpc0NvbnRlbnRWaXNpYmxlKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKCF0aGlzLm1hcmtlZENvbnRlbnRTdGFja1tpXS52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZvciAoY29uc3Qgb3AgaW4gT1BTKSB7XG4gIGlmIChDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICBDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbT1BTW29wXV0gPSBDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbb3BdO1xuICB9XG59XG5cbjsvLyAuL3NyYy9zaGFyZWQvb2JqLWJpbi10cmFuc2Zvcm0uanNcblxuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgQ3NzRm9udEluZm8ge1xuICAjYnVmZmVyO1xuICAjdmlldztcbiAgI2RlY29kZXI7XG4gIHN0YXRpYyBzdHJpbmdzID0gW1wiZm9udEZhbWlseVwiLCBcImZvbnRXZWlnaHRcIiwgXCJpdGFsaWNBbmdsZVwiXTtcbiAgc3RhdGljIHdyaXRlKGluZm8pIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZW5jb2RlZFN0cmluZ3MgPSB7fTtcbiAgICBsZXQgc3RyaW5nc0xlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIENzc0ZvbnRJbmZvLnN0cmluZ3MpIHtcbiAgICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVyLmVuY29kZShpbmZvW3Byb3BdKTtcbiAgICAgIGVuY29kZWRTdHJpbmdzW3Byb3BdID0gZW5jb2RlZDtcbiAgICAgIHN0cmluZ3NMZW5ndGggKz0gNCArIGVuY29kZWQubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc3RyaW5nc0xlbmd0aCk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBDc3NGb250SW5mby5zdHJpbmdzKSB7XG4gICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2RlZFN0cmluZ3NbcHJvcF07XG4gICAgICBjb25zdCBsZW5ndGggPSBlbmNvZGVkLmxlbmd0aDtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGRhdGEuc2V0KGVuY29kZWQsIG9mZnNldCArIDQpO1xuICAgICAgb2Zmc2V0ICs9IDQgKyBsZW5ndGg7XG4gICAgfVxuICAgIGFzc2VydChvZmZzZXQgPT09IGJ1ZmZlci5ieXRlTGVuZ3RoLCBcIkNzc0ZvbnRJbmZvLndyaXRlOiBCdWZmZXIgb3ZlcmZsb3dcIik7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICB0aGlzLiNidWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy4jdmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLiNidWZmZXIpO1xuICAgIHRoaXMuI2RlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgfVxuICAjcmVhZFN0cmluZyhpbmRleCkge1xuICAgIGFzc2VydChpbmRleCA8IENzc0ZvbnRJbmZvLnN0cmluZ3MubGVuZ3RoLCBcIkludmFsaWQgc3RyaW5nIGluZGV4XCIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgb2Zmc2V0ICs9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCkgKyA0O1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIHJldHVybiB0aGlzLiNkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSh0aGlzLiNidWZmZXIsIG9mZnNldCArIDQsIGxlbmd0aCkpO1xuICB9XG4gIGdldCBmb250RmFtaWx5KCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDApO1xuICB9XG4gIGdldCBmb250V2VpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDEpO1xuICB9XG4gIGdldCBpdGFsaWNBbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygyKTtcbiAgfVxufVxuY2xhc3MgU3lzdGVtRm9udEluZm8ge1xuICAjYnVmZmVyO1xuICAjdmlldztcbiAgI2RlY29kZXI7XG4gIHN0YXRpYyBzdHJpbmdzID0gW1wiY3NzXCIsIFwibG9hZGVkTmFtZVwiLCBcImJhc2VGb250TmFtZVwiLCBcInNyY1wiXTtcbiAgc3RhdGljIHdyaXRlKGluZm8pIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZW5jb2RlZFN0cmluZ3MgPSB7fTtcbiAgICBsZXQgc3RyaW5nc0xlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIFN5c3RlbUZvbnRJbmZvLnN0cmluZ3MpIHtcbiAgICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVyLmVuY29kZShpbmZvW3Byb3BdKTtcbiAgICAgIGVuY29kZWRTdHJpbmdzW3Byb3BdID0gZW5jb2RlZDtcbiAgICAgIHN0cmluZ3NMZW5ndGggKz0gNCArIGVuY29kZWQubGVuZ3RoO1xuICAgIH1cbiAgICBzdHJpbmdzTGVuZ3RoICs9IDQ7XG4gICAgbGV0IGVuY29kZWRTdHlsZVN0eWxlLFxuICAgICAgZW5jb2RlZFN0eWxlV2VpZ2h0LFxuICAgICAgbGVuZ3RoRXN0aW1hdGUgPSAxICsgc3RyaW5nc0xlbmd0aDtcbiAgICBpZiAoaW5mby5zdHlsZSkge1xuICAgICAgZW5jb2RlZFN0eWxlU3R5bGUgPSBlbmNvZGVyLmVuY29kZShpbmZvLnN0eWxlLnN0eWxlKTtcbiAgICAgIGVuY29kZWRTdHlsZVdlaWdodCA9IGVuY29kZXIuZW5jb2RlKGluZm8uc3R5bGUud2VpZ2h0KTtcbiAgICAgIGxlbmd0aEVzdGltYXRlICs9IDQgKyBlbmNvZGVkU3R5bGVTdHlsZS5sZW5ndGggKyA0ICsgZW5jb2RlZFN0eWxlV2VpZ2h0Lmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aEVzdGltYXRlKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgaW5mby5ndWVzc0ZhbGxiYWNrID8gMSA6IDApO1xuICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgMCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgc3RyaW5nc0xlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIFN5c3RlbUZvbnRJbmZvLnN0cmluZ3MpIHtcbiAgICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVkU3RyaW5nc1twcm9wXTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgc3RyaW5nc0xlbmd0aCArPSA0ICsgbGVuZ3RoO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgZGF0YS5zZXQoZW5jb2RlZCwgb2Zmc2V0ICsgNCk7XG4gICAgICBvZmZzZXQgKz0gNCArIGxlbmd0aDtcbiAgICB9XG4gICAgdmlldy5zZXRVaW50MzIob2Zmc2V0IC0gc3RyaW5nc0xlbmd0aCAtIDQsIHN0cmluZ3NMZW5ndGgpO1xuICAgIGlmIChpbmZvLnN0eWxlKSB7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIGVuY29kZWRTdHlsZVN0eWxlLmxlbmd0aCk7XG4gICAgICBkYXRhLnNldChlbmNvZGVkU3R5bGVTdHlsZSwgb2Zmc2V0ICsgNCk7XG4gICAgICBvZmZzZXQgKz0gNCArIGVuY29kZWRTdHlsZVN0eWxlLmxlbmd0aDtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgZW5jb2RlZFN0eWxlV2VpZ2h0Lmxlbmd0aCk7XG4gICAgICBkYXRhLnNldChlbmNvZGVkU3R5bGVXZWlnaHQsIG9mZnNldCArIDQpO1xuICAgICAgb2Zmc2V0ICs9IDQgKyBlbmNvZGVkU3R5bGVXZWlnaHQubGVuZ3RoO1xuICAgIH1cbiAgICBhc3NlcnQob2Zmc2V0IDw9IGJ1ZmZlci5ieXRlTGVuZ3RoLCBcIlN1YnN0aXRpb25JbmZvLndyaXRlOiBCdWZmZXIgb3ZlcmZsb3dcIik7XG4gICAgcmV0dXJuIGJ1ZmZlci50cmFuc2ZlclRvRml4ZWRMZW5ndGgob2Zmc2V0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICB0aGlzLiNidWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy4jdmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLiNidWZmZXIpO1xuICAgIHRoaXMuI2RlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgfVxuICBnZXQgZ3Vlc3NGYWxsYmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy4jdmlldy5nZXRVaW50OCgwKSAhPT0gMDtcbiAgfVxuICAjcmVhZFN0cmluZyhpbmRleCkge1xuICAgIGFzc2VydChpbmRleCA8IFN5c3RlbUZvbnRJbmZvLnN0cmluZ3MubGVuZ3RoLCBcIkludmFsaWQgc3RyaW5nIGluZGV4XCIpO1xuICAgIGxldCBvZmZzZXQgPSA1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgb2Zmc2V0ICs9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCkgKyA0O1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIHJldHVybiB0aGlzLiNkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSh0aGlzLiNidWZmZXIsIG9mZnNldCArIDQsIGxlbmd0aCkpO1xuICB9XG4gIGdldCBjc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMCk7XG4gIH1cbiAgZ2V0IGxvYWRlZE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMSk7XG4gIH1cbiAgZ2V0IGJhc2VGb250TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygyKTtcbiAgfVxuICBnZXQgc3JjKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDMpO1xuICB9XG4gIGdldCBzdHlsZSgpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMTtcbiAgICBvZmZzZXQgKz0gNCArIHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgY29uc3Qgc3R5bGVMZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy4jZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkodGhpcy4jYnVmZmVyLCBvZmZzZXQgKyA0LCBzdHlsZUxlbmd0aCkpO1xuICAgIG9mZnNldCArPSA0ICsgc3R5bGVMZW5ndGg7XG4gICAgY29uc3Qgd2VpZ2h0TGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBjb25zdCB3ZWlnaHQgPSB0aGlzLiNkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSh0aGlzLiNidWZmZXIsIG9mZnNldCArIDQsIHdlaWdodExlbmd0aCkpO1xuICAgIHJldHVybiB7XG4gICAgICBzdHlsZSxcbiAgICAgIHdlaWdodFxuICAgIH07XG4gIH1cbn1cbmNsYXNzIEZvbnRJbmZvIHtcbiAgc3RhdGljIGJvb2xzID0gW1wiYmxhY2tcIiwgXCJib2xkXCIsIFwiZGlzYWJsZUZvbnRGYWNlXCIsIFwiZm9udEV4dHJhUHJvcGVydGllc1wiLCBcImlzSW52YWxpZFBERmpzRm9udFwiLCBcImlzVHlwZTNGb250XCIsIFwiaXRhbGljXCIsIFwibWlzc2luZ0ZpbGVcIiwgXCJyZW1lYXN1cmVcIiwgXCJ2ZXJ0aWNhbFwiXTtcbiAgc3RhdGljIG51bWJlcnMgPSBbXCJhc2NlbnRcIiwgXCJkZWZhdWx0V2lkdGhcIiwgXCJkZXNjZW50XCJdO1xuICBzdGF0aWMgc3RyaW5ncyA9IFtcImZhbGxiYWNrTmFtZVwiLCBcImxvYWRlZE5hbWVcIiwgXCJtaW1ldHlwZVwiLCBcIm5hbWVcIl07XG4gIHN0YXRpYyAjT0ZGU0VUX05VTUJFUlMgPSBNYXRoLmNlaWwodGhpcy5ib29scy5sZW5ndGggKiAyIC8gOCk7XG4gIHN0YXRpYyAjT0ZGU0VUX0JCT1ggPSB0aGlzLiNPRkZTRVRfTlVNQkVSUyArIHRoaXMubnVtYmVycy5sZW5ndGggKiA4O1xuICBzdGF0aWMgI09GRlNFVF9GT05UX01BVFJJWCA9IHRoaXMuI09GRlNFVF9CQk9YICsgMSArIDIgKiA0O1xuICBzdGF0aWMgI09GRlNFVF9ERUZBVUxUX1ZNRVRSSUNTID0gdGhpcy4jT0ZGU0VUX0ZPTlRfTUFUUklYICsgMSArIDggKiA2O1xuICBzdGF0aWMgI09GRlNFVF9TVFJJTkdTID0gdGhpcy4jT0ZGU0VUX0RFRkFVTFRfVk1FVFJJQ1MgKyAxICsgMiAqIDM7XG4gICNidWZmZXI7XG4gICNkZWNvZGVyO1xuICAjdmlldztcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgZXh0cmFcbiAgfSkge1xuICAgIHRoaXMuI2J1ZmZlciA9IGRhdGE7XG4gICAgdGhpcy4jZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIHRoaXMuI3ZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy4jYnVmZmVyKTtcbiAgICBpZiAoZXh0cmEpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgZXh0cmEpO1xuICAgIH1cbiAgfVxuICAjcmVhZEJvb2xlYW4oaW5kZXgpIHtcbiAgICBhc3NlcnQoaW5kZXggPCBGb250SW5mby5ib29scy5sZW5ndGgsIFwiSW52YWxpZCBib29sZWFuIGluZGV4XCIpO1xuICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBNYXRoLmZsb29yKGluZGV4IC8gNCk7XG4gICAgY29uc3QgYml0T2Zmc2V0ID0gaW5kZXggKiAyICUgODtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCkgPj4gYml0T2Zmc2V0ICYgMHgwMztcbiAgICByZXR1cm4gdmFsdWUgPT09IDB4MDAgPyB1bmRlZmluZWQgOiB2YWx1ZSA9PT0gMHgwMjtcbiAgfVxuICBnZXQgYmxhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRCb29sZWFuKDApO1xuICB9XG4gIGdldCBib2xkKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkQm9vbGVhbigxKTtcbiAgfVxuICBnZXQgZGlzYWJsZUZvbnRGYWNlKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkQm9vbGVhbigyKTtcbiAgfVxuICBnZXQgZm9udEV4dHJhUHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oMyk7XG4gIH1cbiAgZ2V0IGlzSW52YWxpZFBERmpzRm9udCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oNCk7XG4gIH1cbiAgZ2V0IGlzVHlwZTNGb250KCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkQm9vbGVhbig1KTtcbiAgfVxuICBnZXQgaXRhbGljKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkQm9vbGVhbig2KTtcbiAgfVxuICBnZXQgbWlzc2luZ0ZpbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRCb29sZWFuKDcpO1xuICB9XG4gIGdldCByZW1lYXN1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRCb29sZWFuKDgpO1xuICB9XG4gIGdldCB2ZXJ0aWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oOSk7XG4gIH1cbiAgI3JlYWROdW1iZXIoaW5kZXgpIHtcbiAgICBhc3NlcnQoaW5kZXggPCBGb250SW5mby5udW1iZXJzLmxlbmd0aCwgXCJJbnZhbGlkIG51bWJlciBpbmRleFwiKTtcbiAgICByZXR1cm4gdGhpcy4jdmlldy5nZXRGbG9hdDY0KEZvbnRJbmZvLiNPRkZTRVRfTlVNQkVSUyArIGluZGV4ICogOCk7XG4gIH1cbiAgZ2V0IGFzY2VudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZE51bWJlcigwKTtcbiAgfVxuICBnZXQgZGVmYXVsdFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkTnVtYmVyKDEpO1xuICB9XG4gIGdldCBkZXNjZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkTnVtYmVyKDIpO1xuICB9XG4gIGdldCBiYm94KCkge1xuICAgIGxldCBvZmZzZXQgPSBGb250SW5mby4jT0ZGU0VUX0JCT1g7XG4gICAgY29uc3QgbnVtQ29vcmRzID0gdGhpcy4jdmlldy5nZXRVaW50OChvZmZzZXQpO1xuICAgIGlmIChudW1Db29yZHMgPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9mZnNldCArPSAxO1xuICAgIGNvbnN0IGJib3ggPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgYmJveC5wdXNoKHRoaXMuI3ZpZXcuZ2V0SW50MTYob2Zmc2V0LCB0cnVlKSk7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICB9XG4gICAgcmV0dXJuIGJib3g7XG4gIH1cbiAgZ2V0IGZvbnRNYXRyaXgoKSB7XG4gICAgbGV0IG9mZnNldCA9IEZvbnRJbmZvLiNPRkZTRVRfRk9OVF9NQVRSSVg7XG4gICAgY29uc3QgbnVtUG9pbnRzID0gdGhpcy4jdmlldy5nZXRVaW50OChvZmZzZXQpO1xuICAgIGlmIChudW1Qb2ludHMgPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9mZnNldCArPSAxO1xuICAgIGNvbnN0IGZvbnRNYXRyaXggPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgZm9udE1hdHJpeC5wdXNoKHRoaXMuI3ZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQsIHRydWUpKTtcbiAgICAgIG9mZnNldCArPSA4O1xuICAgIH1cbiAgICByZXR1cm4gZm9udE1hdHJpeDtcbiAgfVxuICBnZXQgZGVmYXVsdFZNZXRyaWNzKCkge1xuICAgIGxldCBvZmZzZXQgPSBGb250SW5mby4jT0ZGU0VUX0RFRkFVTFRfVk1FVFJJQ1M7XG4gICAgY29uc3QgbnVtTWV0cmljcyA9IHRoaXMuI3ZpZXcuZ2V0VWludDgob2Zmc2V0KTtcbiAgICBpZiAobnVtTWV0cmljcyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgY29uc3QgZGVmYXVsdFZNZXRyaWNzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGRlZmF1bHRWTWV0cmljcy5wdXNoKHRoaXMuI3ZpZXcuZ2V0SW50MTYob2Zmc2V0LCB0cnVlKSk7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRWTWV0cmljcztcbiAgfVxuICAjcmVhZFN0cmluZyhpbmRleCkge1xuICAgIGFzc2VydChpbmRleCA8IEZvbnRJbmZvLnN0cmluZ3MubGVuZ3RoLCBcIkludmFsaWQgc3RyaW5nIGluZGV4XCIpO1xuICAgIGxldCBvZmZzZXQgPSBGb250SW5mby4jT0ZGU0VUX1NUUklOR1MgKyA0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgb2Zmc2V0ICs9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCkgKyA0O1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIGNvbnN0IHN0cmluZ0RhdGEgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHN0cmluZ0RhdGEuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuI2J1ZmZlciwgb2Zmc2V0ICsgNCwgbGVuZ3RoKSk7XG4gICAgcmV0dXJuIHRoaXMuI2RlY29kZXIuZGVjb2RlKHN0cmluZ0RhdGEpO1xuICB9XG4gIGdldCBmYWxsYmFja05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMCk7XG4gIH1cbiAgZ2V0IGxvYWRlZE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMSk7XG4gIH1cbiAgZ2V0IG1pbWV0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDIpO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDMpO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIGxldCBvZmZzZXQgPSBGb250SW5mby4jT0ZGU0VUX1NUUklOR1M7XG4gICAgY29uc3Qgc3RyaW5nc0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQgKyBzdHJpbmdzTGVuZ3RoO1xuICAgIGNvbnN0IHN5c3RlbUZvbnRJbmZvTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNCArIHN5c3RlbUZvbnRJbmZvTGVuZ3RoO1xuICAgIGNvbnN0IGNzc0ZvbnRJbmZvTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNCArIGNzc0ZvbnRJbmZvTGVuZ3RoO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuI2J1ZmZlciwgb2Zmc2V0ICsgNCwgbGVuZ3RoKTtcbiAgfVxuICBjbGVhckRhdGEoKSB7XG4gICAgbGV0IG9mZnNldCA9IEZvbnRJbmZvLiNPRkZTRVRfU1RSSU5HUztcbiAgICBjb25zdCBzdHJpbmdzTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNCArIHN0cmluZ3NMZW5ndGg7XG4gICAgY29uc3Qgc3lzdGVtRm9udEluZm9MZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0ICsgc3lzdGVtRm9udEluZm9MZW5ndGg7XG4gICAgY29uc3QgY3NzRm9udEluZm9MZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0ICsgY3NzRm9udEluZm9MZW5ndGg7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYnVmZmVyLCBvZmZzZXQgKyA0LCBsZW5ndGgpO1xuICAgIGRhdGEuZmlsbCgwKTtcbiAgICB0aGlzLiN2aWV3LnNldFVpbnQzMihvZmZzZXQsIDApO1xuICB9XG4gIGdldCBjc3NGb250SW5mbygpIHtcbiAgICBsZXQgb2Zmc2V0ID0gRm9udEluZm8uI09GRlNFVF9TVFJJTkdTO1xuICAgIGNvbnN0IHN0cmluZ3NMZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0ICsgc3RyaW5nc0xlbmd0aDtcbiAgICBjb25zdCBzeXN0ZW1Gb250SW5mb0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQgKyBzeXN0ZW1Gb250SW5mb0xlbmd0aDtcbiAgICBjb25zdCBjc3NGb250SW5mb0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgaWYgKGNzc0ZvbnRJbmZvTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3NzRm9udEluZm9EYXRhID0gbmV3IFVpbnQ4QXJyYXkoY3NzRm9udEluZm9MZW5ndGgpO1xuICAgIGNzc0ZvbnRJbmZvRGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy4jYnVmZmVyLCBvZmZzZXQgKyA0LCBjc3NGb250SW5mb0xlbmd0aCkpO1xuICAgIHJldHVybiBuZXcgQ3NzRm9udEluZm8oY3NzRm9udEluZm9EYXRhLmJ1ZmZlcik7XG4gIH1cbiAgZ2V0IHN5c3RlbUZvbnRJbmZvKCkge1xuICAgIGxldCBvZmZzZXQgPSBGb250SW5mby4jT0ZGU0VUX1NUUklOR1M7XG4gICAgY29uc3Qgc3RyaW5nc0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQgKyBzdHJpbmdzTGVuZ3RoO1xuICAgIGNvbnN0IHN5c3RlbUZvbnRJbmZvTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBpZiAoc3lzdGVtRm9udEluZm9MZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzeXN0ZW1Gb250SW5mb0RhdGEgPSBuZXcgVWludDhBcnJheShzeXN0ZW1Gb250SW5mb0xlbmd0aCk7XG4gICAgc3lzdGVtRm9udEluZm9EYXRhLnNldChuZXcgVWludDhBcnJheSh0aGlzLiNidWZmZXIsIG9mZnNldCArIDQsIHN5c3RlbUZvbnRJbmZvTGVuZ3RoKSk7XG4gICAgcmV0dXJuIG5ldyBTeXN0ZW1Gb250SW5mbyhzeXN0ZW1Gb250SW5mb0RhdGEuYnVmZmVyKTtcbiAgfVxuICBzdGF0aWMgd3JpdGUoZm9udCkge1xuICAgIGNvbnN0IHN5c3RlbUZvbnRJbmZvQnVmZmVyID0gZm9udC5zeXN0ZW1Gb250SW5mbyA/IFN5c3RlbUZvbnRJbmZvLndyaXRlKGZvbnQuc3lzdGVtRm9udEluZm8pIDogbnVsbDtcbiAgICBjb25zdCBjc3NGb250SW5mb0J1ZmZlciA9IGZvbnQuY3NzRm9udEluZm8gPyBDc3NGb250SW5mby53cml0ZShmb250LmNzc0ZvbnRJbmZvKSA6IG51bGw7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWRTdHJpbmdzID0ge307XG4gICAgbGV0IHN0cmluZ3NMZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBGb250SW5mby5zdHJpbmdzKSB7XG4gICAgICBlbmNvZGVkU3RyaW5nc1twcm9wXSA9IGVuY29kZXIuZW5jb2RlKGZvbnRbcHJvcF0pO1xuICAgICAgc3RyaW5nc0xlbmd0aCArPSA0ICsgZW5jb2RlZFN0cmluZ3NbcHJvcF0ubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGhFc3RpbWF0ZSA9IEZvbnRJbmZvLiNPRkZTRVRfU1RSSU5HUyArIDQgKyBzdHJpbmdzTGVuZ3RoICsgNCArIChzeXN0ZW1Gb250SW5mb0J1ZmZlciA/IHN5c3RlbUZvbnRJbmZvQnVmZmVyLmJ5dGVMZW5ndGggOiAwKSArIDQgKyAoY3NzRm9udEluZm9CdWZmZXIgPyBjc3NGb250SW5mb0J1ZmZlci5ieXRlTGVuZ3RoIDogMCkgKyA0ICsgKGZvbnQuZGF0YSA/IGZvbnQuZGF0YS5sZW5ndGggOiAwKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoRXN0aW1hdGUpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBudW1Cb29scyA9IEZvbnRJbmZvLmJvb2xzLmxlbmd0aDtcbiAgICBsZXQgYm9vbEJ5dGUgPSAwLFxuICAgICAgYm9vbEJpdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Cb29sczsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGZvbnRbRm9udEluZm8uYm9vbHNbaV1dO1xuICAgICAgY29uc3QgYml0cyA9IHZhbHVlID09PSB1bmRlZmluZWQgPyAweDAwIDogdmFsdWUgPyAweDAyIDogMHgwMTtcbiAgICAgIGJvb2xCeXRlIHw9IGJpdHMgPDwgYm9vbEJpdDtcbiAgICAgIGJvb2xCaXQgKz0gMjtcbiAgICAgIGlmIChib29sQml0ID09PSA4IHx8IGkgPT09IG51bUJvb2xzIC0gMSkge1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBib29sQnl0ZSk7XG4gICAgICAgIGJvb2xCeXRlID0gMDtcbiAgICAgICAgYm9vbEJpdCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2VydChvZmZzZXQgPT09IEZvbnRJbmZvLiNPRkZTRVRfTlVNQkVSUywgXCJGb250SW5mby53cml0ZTogQm9vbGVhbiBwcm9wZXJ0aWVzIG9mZnNldCBtaXNtYXRjaFwiKTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgRm9udEluZm8ubnVtYmVycykge1xuICAgICAgdmlldy5zZXRGbG9hdDY0KG9mZnNldCwgZm9udFtwcm9wXSk7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICB9XG4gICAgYXNzZXJ0KG9mZnNldCA9PT0gRm9udEluZm8uI09GRlNFVF9CQk9YLCBcIkZvbnRJbmZvLndyaXRlOiBOdW1iZXIgcHJvcGVydGllcyBvZmZzZXQgbWlzbWF0Y2hcIik7XG4gICAgaWYgKGZvbnQuYmJveCkge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgNCk7XG4gICAgICBmb3IgKGNvbnN0IGNvb3JkIG9mIGZvbnQuYmJveCkge1xuICAgICAgICB2aWV3LnNldEludDE2KG9mZnNldCwgY29vcmQsIHRydWUpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMCk7XG4gICAgICBvZmZzZXQgKz0gMiAqIDQ7XG4gICAgfVxuICAgIGFzc2VydChvZmZzZXQgPT09IEZvbnRJbmZvLiNPRkZTRVRfRk9OVF9NQVRSSVgsIFwiRm9udEluZm8ud3JpdGU6IEJCb3ggcHJvcGVydGllcyBvZmZzZXQgbWlzbWF0Y2hcIik7XG4gICAgaWYgKGZvbnQuZm9udE1hdHJpeCkge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgNik7XG4gICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGZvbnQuZm9udE1hdHJpeCkge1xuICAgICAgICB2aWV3LnNldEZsb2F0NjQob2Zmc2V0LCBwb2ludCwgdHJ1ZSk7XG4gICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAwKTtcbiAgICAgIG9mZnNldCArPSA4ICogNjtcbiAgICB9XG4gICAgYXNzZXJ0KG9mZnNldCA9PT0gRm9udEluZm8uI09GRlNFVF9ERUZBVUxUX1ZNRVRSSUNTLCBcIkZvbnRJbmZvLndyaXRlOiBGb250TWF0cml4IHByb3BlcnRpZXMgb2Zmc2V0IG1pc21hdGNoXCIpO1xuICAgIGlmIChmb250LmRlZmF1bHRWTWV0cmljcykge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMSk7XG4gICAgICBmb3IgKGNvbnN0IG1ldHJpYyBvZiBmb250LmRlZmF1bHRWTWV0cmljcykge1xuICAgICAgICB2aWV3LnNldEludDE2KG9mZnNldCwgbWV0cmljLCB0cnVlKTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDApO1xuICAgICAgb2Zmc2V0ICs9IDMgKiAyO1xuICAgIH1cbiAgICBhc3NlcnQob2Zmc2V0ID09PSBGb250SW5mby4jT0ZGU0VUX1NUUklOR1MsIFwiRm9udEluZm8ud3JpdGU6IERlZmF1bHRWTWV0cmljcyBwcm9wZXJ0aWVzIG9mZnNldCBtaXNtYXRjaFwiKTtcbiAgICB2aWV3LnNldFVpbnQzMihGb250SW5mby4jT0ZGU0VUX1NUUklOR1MsIDApO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBGb250SW5mby5zdHJpbmdzKSB7XG4gICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2RlZFN0cmluZ3NbcHJvcF07XG4gICAgICBjb25zdCBsZW5ndGggPSBlbmNvZGVkLmxlbmd0aDtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGRhdGEuc2V0KGVuY29kZWQsIG9mZnNldCArIDQpO1xuICAgICAgb2Zmc2V0ICs9IDQgKyBsZW5ndGg7XG4gICAgfVxuICAgIHZpZXcuc2V0VWludDMyKEZvbnRJbmZvLiNPRkZTRVRfU1RSSU5HUywgb2Zmc2V0IC0gRm9udEluZm8uI09GRlNFVF9TVFJJTkdTIC0gNCk7XG4gICAgaWYgKCFzeXN0ZW1Gb250SW5mb0J1ZmZlcikge1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCAwKTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBzeXN0ZW1Gb250SW5mb0J1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYXNzZXJ0KG9mZnNldCArIDQgKyBsZW5ndGggPD0gYnVmZmVyLmJ5dGVMZW5ndGgsIFwiRm9udEluZm8ud3JpdGU6IEJ1ZmZlciBvdmVyZmxvdyBhdCBzeXN0ZW1Gb250SW5mb1wiKTtcbiAgICAgIGRhdGEuc2V0KG5ldyBVaW50OEFycmF5KHN5c3RlbUZvbnRJbmZvQnVmZmVyKSwgb2Zmc2V0ICsgNCk7XG4gICAgICBvZmZzZXQgKz0gNCArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKCFjc3NGb250SW5mb0J1ZmZlcikge1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCAwKTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBjc3NGb250SW5mb0J1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYXNzZXJ0KG9mZnNldCArIDQgKyBsZW5ndGggPD0gYnVmZmVyLmJ5dGVMZW5ndGgsIFwiRm9udEluZm8ud3JpdGU6IEJ1ZmZlciBvdmVyZmxvdyBhdCBjc3NGb250SW5mb1wiKTtcbiAgICAgIGRhdGEuc2V0KG5ldyBVaW50OEFycmF5KGNzc0ZvbnRJbmZvQnVmZmVyKSwgb2Zmc2V0ICsgNCk7XG4gICAgICBvZmZzZXQgKz0gNCArIGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGZvbnQuZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIDApO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgZm9udC5kYXRhLmxlbmd0aCk7XG4gICAgICBkYXRhLnNldChmb250LmRhdGEsIG9mZnNldCArIDQpO1xuICAgICAgb2Zmc2V0ICs9IDQgKyBmb250LmRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBhc3NlcnQob2Zmc2V0IDw9IGJ1ZmZlci5ieXRlTGVuZ3RoLCBcIkZvbnRJbmZvLndyaXRlOiBCdWZmZXIgb3ZlcmZsb3dcIik7XG4gICAgcmV0dXJuIGJ1ZmZlci50cmFuc2ZlclRvRml4ZWRMZW5ndGgob2Zmc2V0KTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS93b3JrZXJfb3B0aW9ucy5qc1xuY2xhc3MgR2xvYmFsV29ya2VyT3B0aW9ucyB7XG4gIHN0YXRpYyAjcG9ydCA9IG51bGw7XG4gIHN0YXRpYyAjc3JjID0gXCJcIjtcbiAgc3RhdGljIGdldCB3b3JrZXJQb3J0KCkge1xuICAgIHJldHVybiB0aGlzLiNwb3J0O1xuICB9XG4gIHN0YXRpYyBzZXQgd29ya2VyUG9ydCh2YWwpIHtcbiAgICBpZiAoISh0eXBlb2YgV29ya2VyICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbCBpbnN0YW5jZW9mIFdvcmtlcikgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGB3b3JrZXJQb3J0YCB0eXBlLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jcG9ydCA9IHZhbDtcbiAgfVxuICBzdGF0aWMgZ2V0IHdvcmtlclNyYygpIHtcbiAgICByZXR1cm4gdGhpcy4jc3JjO1xuICB9XG4gIHN0YXRpYyBzZXQgd29ya2VyU3JjKHZhbCkge1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGB3b3JrZXJTcmNgIHR5cGUuXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzcmMgPSB2YWw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbWV0YWRhdGEuanNcbmNsYXNzIE1ldGFkYXRhIHtcbiAgI21hcDtcbiAgI2RhdGE7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJzZWREYXRhLFxuICAgIHJhd0RhdGFcbiAgfSkge1xuICAgIHRoaXMuI21hcCA9IHBhcnNlZERhdGE7XG4gICAgdGhpcy4jZGF0YSA9IHJhd0RhdGE7XG4gIH1cbiAgZ2V0UmF3KCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhO1xuICB9XG4gIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hcC5nZXQobmFtZSkgPz8gbnVsbDtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmVudHJpZXMoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9vcHRpb25hbF9jb250ZW50X2NvbmZpZy5qc1xuXG5cbmNvbnN0IElOVEVSTkFMID0gU3ltYm9sKFwiSU5URVJOQUxcIik7XG5jbGFzcyBPcHRpb25hbENvbnRlbnRHcm91cCB7XG4gICNpc0Rpc3BsYXkgPSBmYWxzZTtcbiAgI2lzUHJpbnQgPSBmYWxzZTtcbiAgI3VzZXJTZXQgPSBmYWxzZTtcbiAgI3Zpc2libGUgPSB0cnVlO1xuICBjb25zdHJ1Y3RvcihyZW5kZXJpbmdJbnRlbnQsIHtcbiAgICBuYW1lLFxuICAgIGludGVudCxcbiAgICB1c2FnZSxcbiAgICByYkdyb3Vwc1xuICB9KSB7XG4gICAgdGhpcy4jaXNEaXNwbGF5ID0gISEocmVuZGVyaW5nSW50ZW50ICYgUmVuZGVyaW5nSW50ZW50RmxhZy5ESVNQTEFZKTtcbiAgICB0aGlzLiNpc1ByaW50ID0gISEocmVuZGVyaW5nSW50ZW50ICYgUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVCk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmludGVudCA9IGludGVudDtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2U7XG4gICAgdGhpcy5yYkdyb3VwcyA9IHJiR3JvdXBzO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIGlmICh0aGlzLiN1c2VyU2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy4jdmlzaWJsZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiN2aXNpYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHByaW50LFxuICAgICAgdmlld1xuICAgIH0gPSB0aGlzLnVzYWdlO1xuICAgIGlmICh0aGlzLiNpc0Rpc3BsYXkpIHtcbiAgICAgIHJldHVybiB2aWV3Py52aWV3U3RhdGUgIT09IFwiT0ZGXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNpc1ByaW50KSB7XG4gICAgICByZXR1cm4gcHJpbnQ/LnByaW50U3RhdGUgIT09IFwiT0ZGXCI7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zZXRWaXNpYmxlKGludGVybmFsLCB2aXNpYmxlLCB1c2VyU2V0ID0gZmFsc2UpIHtcbiAgICBpZiAoaW50ZXJuYWwgIT09IElOVEVSTkFMKSB7XG4gICAgICB1bnJlYWNoYWJsZShcIkludGVybmFsIG1ldGhvZCBgX3NldFZpc2libGVgIGNhbGxlZC5cIik7XG4gICAgfVxuICAgIHRoaXMuI3VzZXJTZXQgPSB1c2VyU2V0O1xuICAgIHRoaXMuI3Zpc2libGUgPSB2aXNpYmxlO1xuICB9XG59XG5jbGFzcyBPcHRpb25hbENvbnRlbnRDb25maWcge1xuICAjY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gICNncm91cHMgPSBuZXcgTWFwKCk7XG4gICNpbml0aWFsSGFzaCA9IG51bGw7XG4gICNvcmRlciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWSkge1xuICAgIHRoaXMucmVuZGVyaW5nSW50ZW50ID0gcmVuZGVyaW5nSW50ZW50O1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5jcmVhdG9yID0gbnVsbDtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgdGhpcy5jcmVhdG9yID0gZGF0YS5jcmVhdG9yO1xuICAgIHRoaXMuI29yZGVyID0gZGF0YS5vcmRlcjtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGRhdGEuZ3JvdXBzKSB7XG4gICAgICB0aGlzLiNncm91cHMuc2V0KGdyb3VwLmlkLCBuZXcgT3B0aW9uYWxDb250ZW50R3JvdXAocmVuZGVyaW5nSW50ZW50LCBncm91cCkpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5iYXNlU3RhdGUgPT09IFwiT0ZGXCIpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgdGhpcy4jZ3JvdXBzLnZhbHVlcygpKSB7XG4gICAgICAgIGdyb3VwLl9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb24gb2YgZGF0YS5vbikge1xuICAgICAgdGhpcy4jZ3JvdXBzLmdldChvbikuX3NldFZpc2libGUoSU5URVJOQUwsIHRydWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9mZiBvZiBkYXRhLm9mZikge1xuICAgICAgdGhpcy4jZ3JvdXBzLmdldChvZmYpLl9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuI2luaXRpYWxIYXNoID0gdGhpcy5nZXRIYXNoKCk7XG4gIH1cbiAgI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oYXJyYXkpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBvcGVyYXRvciA9IGFycmF5WzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICAgIGxldCBzdGF0ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy4jZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jZ3JvdXBzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuI2dyb3Vwcy5nZXQoZWxlbWVudCkudmlzaWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2VsZW1lbnR9YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlIFwiQW5kXCI6XG4gICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk9yXCI6XG4gICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJOb3RcIjpcbiAgICAgICAgICByZXR1cm4gIXN0YXRlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiQW5kXCI7XG4gIH1cbiAgaXNWaXNpYmxlKGdyb3VwKSB7XG4gICAgaWYgKHRoaXMuI2dyb3Vwcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgaW5mbyhcIk9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGRlZmluZWQuXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChncm91cC50eXBlID09PSBcIk9DR1wiKSB7XG4gICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoZ3JvdXAuaWQpKSB7XG4gICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2dyb3VwLmlkfWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGdyb3VwLmlkKS52aXNpYmxlO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ01EXCIpIHtcbiAgICAgIGlmIChncm91cC5leHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGdyb3VwLmV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgICAgaWYgKCFncm91cC5wb2xpY3kgfHwgZ3JvdXAucG9saWN5ID09PSBcIkFueU9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9mZlwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB3YXJuKGBVbmtub3duIG9wdGlvbmFsIGNvbnRlbnQgcG9saWN5ICR7Z3JvdXAucG9saWN5fS5gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB3YXJuKGBVbmtub3duIGdyb3VwIHR5cGUgJHtncm91cC50eXBlfS5gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzZXRWaXNpYmlsaXR5KGlkLCB2aXNpYmxlID0gdHJ1ZSwgcHJlc2VydmVSQiA9IHRydWUpIHtcbiAgICBjb25zdCBncm91cCA9IHRoaXMuI2dyb3Vwcy5nZXQoaWQpO1xuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJlc2VydmVSQiAmJiB2aXNpYmxlICYmIGdyb3VwLnJiR3JvdXBzLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCByYkdyb3VwIG9mIGdyb3VwLnJiR3JvdXBzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3RoZXJJZCBvZiByYkdyb3VwKSB7XG4gICAgICAgICAgaWYgKG90aGVySWQgIT09IGlkKSB7XG4gICAgICAgICAgICB0aGlzLiNncm91cHMuZ2V0KG90aGVySWQpPy5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBncm91cC5fc2V0VmlzaWJsZShJTlRFUk5BTCwgISF2aXNpYmxlLCB0cnVlKTtcbiAgICB0aGlzLiNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgfVxuICBzZXRPQ0dTdGF0ZSh7XG4gICAgc3RhdGUsXG4gICAgcHJlc2VydmVSQlxuICB9KSB7XG4gICAgbGV0IG9wZXJhdG9yO1xuICAgIGZvciAoY29uc3QgZWxlbSBvZiBzdGF0ZSkge1xuICAgICAgc3dpdGNoIChlbGVtKSB7XG4gICAgICAgIGNhc2UgXCJPTlwiOlxuICAgICAgICBjYXNlIFwiT0ZGXCI6XG4gICAgICAgIGNhc2UgXCJUb2dnbGVcIjpcbiAgICAgICAgICBvcGVyYXRvciA9IGVsZW07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBncm91cCA9IHRoaXMuI2dyb3Vwcy5nZXQoZWxlbSk7XG4gICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlIFwiT05cIjpcbiAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoZWxlbSwgdHJ1ZSwgcHJlc2VydmVSQik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPRkZcIjpcbiAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoZWxlbSwgZmFsc2UsIHByZXNlcnZlUkIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVG9nZ2xlXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sICFncm91cC52aXNpYmxlLCBwcmVzZXJ2ZVJCKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gIH1cbiAgZ2V0IGhhc0luaXRpYWxWaXNpYmlsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLiNpbml0aWFsSGFzaCA9PT0gbnVsbCB8fCB0aGlzLmdldEhhc2goKSA9PT0gdGhpcy4jaW5pdGlhbEhhc2g7XG4gIH1cbiAgZ2V0T3JkZXIoKSB7XG4gICAgaWYgKCF0aGlzLiNncm91cHMuc2l6ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLiNvcmRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuI29yZGVyLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBbLi4udGhpcy4jZ3JvdXBzLmtleXMoKV07XG4gIH1cbiAgZ2V0R3JvdXAoaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLmdldChpZCkgfHwgbnVsbDtcbiAgfVxuICBnZXRIYXNoKCkge1xuICAgIGlmICh0aGlzLiNjYWNoZWRHZXRIYXNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy4jY2FjaGVkR2V0SGFzaDtcbiAgICB9XG4gICAgY29uc3QgaGFzaCA9IG5ldyBNdXJtdXJIYXNoM182NCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBncm91cF0gb2YgdGhpcy4jZ3JvdXBzKSB7XG4gICAgICBoYXNoLnVwZGF0ZShgJHtpZH06JHtncm91cC52aXNpYmxlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVkR2V0SGFzaCA9IGhhc2guaGV4ZGlnZXN0KCk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5lbnRyaWVzKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvdHJhbnNwb3J0X3N0cmVhbS5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW0ge1xuICBjb25zdHJ1Y3RvcihwZGZEYXRhUmFuZ2VUcmFuc3BvcnQsIHtcbiAgICBkaXNhYmxlUmFuZ2UgPSBmYWxzZSxcbiAgICBkaXNhYmxlU3RyZWFtID0gZmFsc2VcbiAgfSkge1xuICAgIGFzc2VydChwZGZEYXRhUmFuZ2VUcmFuc3BvcnQsICdQREZEYXRhVHJhbnNwb3J0U3RyZWFtIC0gbWlzc2luZyByZXF1aXJlZCBcInBkZkRhdGFSYW5nZVRyYW5zcG9ydFwiIGFyZ3VtZW50LicpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aCxcbiAgICAgIGluaXRpYWxEYXRhLFxuICAgICAgcHJvZ3Jlc3NpdmVEb25lLFxuICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWVcbiAgICB9ID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0O1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lO1xuICAgIGlmIChpbml0aWFsRGF0YT8ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYnVmZmVyID0gaW5pdGlhbERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGluaXRpYWxEYXRhLmJ5dGVMZW5ndGggPT09IGluaXRpYWxEYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoID8gaW5pdGlhbERhdGEuYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoaW5pdGlhbERhdGEpLmJ1ZmZlcjtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgfVxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydCA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFkaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhZGlzYWJsZVJhbmdlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVhZGVycyA9IFtdO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRSYW5nZUxpc3RlbmVyKChiZWdpbiwgY2h1bmspID0+IHtcbiAgICAgIHRoaXMuX29uUmVjZWl2ZURhdGEoe1xuICAgICAgICBiZWdpbixcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc0xpc3RlbmVyKChsb2FkZWQsIHRvdGFsKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzKHtcbiAgICAgICAgbG9hZGVkLFxuICAgICAgICB0b3RhbFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGNodW5rID0+IHtcbiAgICAgIHRoaXMuX29uUmVjZWl2ZURhdGEoe1xuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHRoaXMuX29uUHJvZ3Jlc3NpdmVEb25lKCk7XG4gICAgfSk7XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnRyYW5zcG9ydFJlYWR5KCk7XG4gIH1cbiAgX29uUmVjZWl2ZURhdGEoe1xuICAgIGJlZ2luLFxuICAgIGNodW5rXG4gIH0pIHtcbiAgICBjb25zdCBidWZmZXIgPSBjaHVuayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgY2h1bmsuYnl0ZUxlbmd0aCA9PT0gY2h1bmsuYnVmZmVyLmJ5dGVMZW5ndGggPyBjaHVuay5idWZmZXIgOiBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIGlmIChiZWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIuX2VucXVldWUoYnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZvdW5kID0gdGhpcy5fcmFuZ2VSZWFkZXJzLnNvbWUoZnVuY3Rpb24gKHJhbmdlUmVhZGVyKSB7XG4gICAgICAgIGlmIChyYW5nZVJlYWRlci5fYmVnaW4gIT09IGJlZ2luKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlUmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgICBhc3NlcnQoZm91bmQsIFwiX29uUmVjZWl2ZURhdGEgLSBubyBgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyYCBpbnN0YW5jZSBmb3VuZC5cIik7XG4gICAgfVxuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIGlmIChldnQudG90YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzWzBdPy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8ub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX29uUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5wcm9ncmVzc2l2ZURvbmUoKTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSB0cnVlO1xuICB9XG4gIF9yZW1vdmVSYW5nZVJlYWRlcihyZWFkZXIpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fcmFuZ2VSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICBjb25zdCBxdWV1ZWRDaHVua3MgPSB0aGlzLl9xdWV1ZWRDaHVua3M7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gbnVsbDtcbiAgICByZXR1cm4gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIodGhpcywgcXVldWVkQ2h1bmtzLCB0aGlzLl9wcm9ncmVzc2l2ZURvbmUsIHRoaXMuX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lKTtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5yZXF1ZXN0RGF0YVJhbmdlKGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVhZGVycy5wdXNoKHJlYWRlcik7XG4gICAgcmV0dXJuIHJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hYm9ydCgpO1xuICB9XG59XG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBxdWV1ZWRDaHVua3MsIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlLCBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fZG9uZSA9IHByb2dyZXNzaXZlRG9uZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9maWxlbmFtZSA9IGlzUGRmRmlsZShjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSkgPyBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA6IG51bGw7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gcXVldWVkQ2h1bmtzIHx8IFtdO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiB0aGlzLl9xdWV1ZWRDaHVua3MpIHtcbiAgICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2hlYWRlcnNSZWFkeSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHN0cmVhbS5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX2VucXVldWUoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChjaHVuayk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNSZWFkeTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICB9XG4gIHByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2JlZ2luID0gYmVnaW47XG4gICAgdGhpcy5fZW5kID0gZW5kO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBjaHVuaztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVxdWVzdHNDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RzQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVuaykge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9jb250ZW50X2Rpc3Bvc2l0aW9uLmpzXG5cblxuXG5mdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIoY29udGVudERpc3Bvc2l0aW9uKSB7XG4gIGxldCBuZWVkc0VuY29kaW5nRml4dXAgPSB0cnVlO1xuICBsZXQgdG1wID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCpcIiwgXCJpXCIpLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uKTtcbiAgaWYgKHRtcCkge1xuICAgIHRtcCA9IHRtcFsxXTtcbiAgICBsZXQgZmlsZW5hbWUgPSByZmMyNjE2dW5xdW90ZSh0bXApO1xuICAgIGZpbGVuYW1lID0gdW5lc2NhcGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjNTk4N2RlY29kZShmaWxlbmFtZSk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgdG1wID0gcmZjMjIzMWdldHBhcmFtKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICBjb25zdCBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUodG1wKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgdG1wID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuICBmdW5jdGlvbiB0b1BhcmFtUmVnRXhwKGF0dHJpYnV0ZVBhdHRlcm4sIGZsYWdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpefDspXFxcXHMqXCIgKyBhdHRyaWJ1dGVQYXR0ZXJuICsgXCJcXFxccyo9XFxcXHMqXCIgKyBcIihcIiArICdbXlwiO1xcXFxzXVteO1xcXFxzXSonICsgXCJ8XCIgKyAnXCIoPzpbXlwiXFxcXFxcXFxdfFxcXFxcXFxcXCI/KStcIj8nICsgXCIpXCIsIGZsYWdzKTtcbiAgfVxuICBmdW5jdGlvbiB0ZXh0ZGVjb2RlKGVuY29kaW5nLCB2YWx1ZSkge1xuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgaWYgKCEvXltcXHgwMC1cXHhGRl0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywge1xuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgICBuZWVkc0VuY29kaW5nRml4dXAgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGZpeHVwRW5jb2RpbmcodmFsdWUpIHtcbiAgICBpZiAobmVlZHNFbmNvZGluZ0ZpeHVwICYmIC9bXFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwidXRmLThcIiwgdmFsdWUpO1xuICAgICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCkge1xuICAgICAgICB2YWx1ZSA9IHRleHRkZWNvZGUoXCJpc28tODg1OS0xXCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb25TdHIpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgbGV0IG1hdGNoO1xuICAgIGNvbnN0IGl0ZXIgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcXFxcKigoPyEwXFxcXGQpXFxcXGQrKShcXFxcKj8pXCIsIFwiaWdcIik7XG4gICAgd2hpbGUgKChtYXRjaCA9IGl0ZXIuZXhlYyhjb250ZW50RGlzcG9zaXRpb25TdHIpKSAhPT0gbnVsbCkge1xuICAgICAgbGV0IFssIG4sIHF1b3QsIHBhcnRdID0gbWF0Y2g7XG4gICAgICBuID0gcGFyc2VJbnQobiwgMTApO1xuICAgICAgaWYgKG4gaW4gbWF0Y2hlcykge1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbWF0Y2hlc1tuXSA9IFtxdW90LCBwYXJ0XTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IG1hdGNoZXMubGVuZ3RoOyArK24pIHtcbiAgICAgIGlmICghKG4gaW4gbWF0Y2hlcykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgW3F1b3QsIHBhcnRdID0gbWF0Y2hlc1tuXTtcbiAgICAgIHBhcnQgPSByZmMyNjE2dW5xdW90ZShwYXJ0KTtcbiAgICAgIGlmIChxdW90KSB7XG4gICAgICAgIHBhcnQgPSB1bmVzY2FwZShwYXJ0KTtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBwYXJ0ID0gcmZjNTk4N2RlY29kZShwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gcmZjMjYxNnVucXVvdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnXCInKSkge1xuICAgICAgY29uc3QgcGFydHMgPSB2YWx1ZS5zbGljZSgxKS5zcGxpdCgnXFxcXFwiJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHF1b3RpbmRleCA9IHBhcnRzW2ldLmluZGV4T2YoJ1wiJyk7XG4gICAgICAgIGlmIChxdW90aW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcGFydHNbaV0gPSBwYXJ0c1tpXS5zbGljZSgwLCBxdW90aW5kZXgpO1xuICAgICAgICAgIHBhcnRzLmxlbmd0aCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0ucmVwbGFjZUFsbCgvXFxcXCguKS9nLCBcIiQxXCIpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcmZjNTk4N2RlY29kZShleHR2YWx1ZSkge1xuICAgIGNvbnN0IGVuY29kaW5nZW5kID0gZXh0dmFsdWUuaW5kZXhPZihcIidcIik7XG4gICAgaWYgKGVuY29kaW5nZW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIGV4dHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGluZyA9IGV4dHZhbHVlLnNsaWNlKDAsIGVuY29kaW5nZW5kKTtcbiAgICBjb25zdCBsYW5ndmFsdWUgPSBleHR2YWx1ZS5zbGljZShlbmNvZGluZ2VuZCArIDEpO1xuICAgIGNvbnN0IHZhbHVlID0gbGFuZ3ZhbHVlLnJlcGxhY2UoL15bXiddKicvLCBcIlwiKTtcbiAgICByZXR1cm4gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIwNDdkZWNvZGUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoXCI9P1wiKSB8fCAvW1xceDAwLVxceDE5XFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZUFsbCgvPVxcPyhbXFx3LV0qKVxcPyhbUXFCYl0pXFw/KCg/OlteP118XFw/KD8hPSkpKilcXD89L2csIGZ1bmN0aW9uIChtYXRjaGVzLCBjaGFyc2V0LCBlbmNvZGluZywgdGV4dCkge1xuICAgICAgaWYgKGVuY29kaW5nID09PSBcInFcIiB8fCBlbmNvZGluZyA9PT0gXCJRXCIpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbChcIl9cIiwgXCIgXCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlQWxsKC89KFswLTlhLWZBLUZdezJ9KS9nLCBmdW5jdGlvbiAobWF0Y2gsIGhleCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGV4dCA9IGF0b2IodGV4dCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgICByZXR1cm4gdGV4dGRlY29kZShjaGFyc2V0LCB0ZXh0KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbmV0d29ya191dGlscy5qc1xuXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXJzKGlzSHR0cCwgaHR0cEhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGlmICghaXNIdHRwIHx8ICFodHRwSGVhZGVycyB8fCB0eXBlb2YgaHR0cEhlYWRlcnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBodHRwSGVhZGVycykge1xuICAgIGNvbnN0IHZhbCA9IGh0dHBIZWFkZXJzW2tleV07XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuZnVuY3Rpb24gZ2V0UmVzcG9uc2VPcmlnaW4odXJsKSB7XG4gIHJldHVybiBVUkwucGFyc2UodXJsKT8ub3JpZ2luID8/IG51bGw7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gIHJlc3BvbnNlSGVhZGVycyxcbiAgaXNIdHRwLFxuICByYW5nZUNodW5rU2l6ZSxcbiAgZGlzYWJsZVJhbmdlXG59KSB7XG4gIGNvbnN0IHJldHVyblZhbHVlcyA9IHtcbiAgICBhbGxvd1JhbmdlUmVxdWVzdHM6IGZhbHNlLFxuICAgIHN1Z2dlc3RlZExlbmd0aDogdW5kZWZpbmVkXG4gIH07XG4gIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSwgMTApO1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobGVuZ3RoKSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgcmV0dXJuVmFsdWVzLnN1Z2dlc3RlZExlbmd0aCA9IGxlbmd0aDtcbiAgaWYgKGxlbmd0aCA8PSAyICogcmFuZ2VDaHVua1NpemUpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGlmIChkaXNhYmxlUmFuZ2UgfHwgIWlzSHR0cCkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgaWYgKHJlc3BvbnNlSGVhZGVycy5nZXQoXCJBY2NlcHQtUmFuZ2VzXCIpICE9PSBcImJ5dGVzXCIpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LUVuY29kaW5nXCIpIHx8IFwiaWRlbnRpdHlcIjtcbiAgaWYgKGNvbnRlbnRFbmNvZGluZyAhPT0gXCJpZGVudGl0eVwiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICByZXR1cm5WYWx1ZXMuYWxsb3dSYW5nZVJlcXVlc3RzID0gdHJ1ZTtcbiAgcmV0dXJuIHJldHVyblZhbHVlcztcbn1cbmZ1bmN0aW9uIGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIocmVzcG9uc2VIZWFkZXJzKSB7XG4gIGNvbnN0IGNvbnRlbnREaXNwb3NpdGlvbiA9IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIpO1xuICBpZiAoY29udGVudERpc3Bvc2l0aW9uKSB7XG4gICAgbGV0IGZpbGVuYW1lID0gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gICAgaWYgKGZpbGVuYW1lLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmlsZW5hbWUgPSBkZWNvZGVVUklDb21wb25lbnQoZmlsZW5hbWUpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICBpZiAoaXNQZGZGaWxlKGZpbGVuYW1lKSkge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlRXJyb3Ioc3RhdHVzLCB1cmwpIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZUV4Y2VwdGlvbihgVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2UgKCR7c3RhdHVzfSkgd2hpbGUgcmV0cmlldmluZyBQREYgXCIke3VybH1cIi5gLCBzdGF0dXMsIHN0YXR1cyA9PT0gNDA0IHx8IHN0YXR1cyA9PT0gMCAmJiB1cmwuc3RhcnRzV2l0aChcImZpbGU6XCIpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmVzcG9uc2VTdGF0dXMoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwNjtcbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZmV0Y2hfc3RyZWFtLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgd2l0aENyZWRlbnRpYWxzLCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVycyxcbiAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgY3JlZGVudGlhbHM6IHdpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJzYW1lLW9yaWdpblwiLFxuICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcih2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gdmFsLmJ1ZmZlcjtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHdhcm4oYGdldEFycmF5QnVmZmVyIC0gdW5leHBlY3RlZCBkYXRhIGZvcm1hdDogJHt2YWx9YCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheSh2YWwpLmJ1ZmZlcjtcbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtIHtcbiAgX3Jlc3BvbnNlT3JpZ2luID0gbnVsbDtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5pc0h0dHAgPSAvXmh0dHBzPzovaS50ZXN0KHNvdXJjZS51cmwpO1xuICAgIHRoaXMuaGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5pc0h0dHAsIHNvdXJjZS5odHRwSGVhZGVycyk7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGRmV0Y2hTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SZWFkZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHN0cmVhbS5oZWFkZXJzKTtcbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBzdHJlYW0uX3Jlc3BvbnNlT3JpZ2luID0gZ2V0UmVzcG9uc2VPcmlnaW4ocmVzcG9uc2UudXJsKTtcbiAgICAgIGlmICghdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZVJlc3BvbnNlRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCB1cmwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgICB9ID0gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMoe1xuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGlzSHR0cDogc3RyZWFtLmlzSHR0cCxcbiAgICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gYWxsb3dSYW5nZVJlcXVlc3RzO1xuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgICAgdGhpcy5fZmlsZW5hbWUgPSBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKHJlc3BvbnNlSGVhZGVycyk7XG4gICAgICBpZiAoIXRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwobmV3IEFib3J0RXhjZXB0aW9uKFwiU3RyZWFtaW5nIGlzIGRpc2FibGVkLlwiKSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2godGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRvbmVcbiAgICB9ID0gYXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGdldEFycmF5QnVmZmVyKHZhbHVlKSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fcmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhzdHJlYW0uaGVhZGVycyk7XG4gICAgaGVhZGVycy5hcHBlbmQoXCJSYW5nZVwiLCBgYnl0ZXM9JHtiZWdpbn0tJHtlbmQgLSAxfWApO1xuICAgIGNvbnN0IHVybCA9IHNvdXJjZS51cmw7XG4gICAgZmV0Y2godXJsLCBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgdGhpcy5fd2l0aENyZWRlbnRpYWxzLCB0aGlzLl9hYm9ydENvbnRyb2xsZXIpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlT3JpZ2luID0gZ2V0UmVzcG9uc2VPcmlnaW4ocmVzcG9uc2UudXJsKTtcbiAgICAgIGlmIChyZXNwb25zZU9yaWdpbiAhPT0gc3RyZWFtLl9yZXNwb25zZU9yaWdpbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHJhbmdlIHJlc3BvbnNlLW9yaWdpbiBcIiR7cmVzcG9uc2VPcmlnaW59XCIgdG8gbWF0Y2ggXCIke3N0cmVhbS5fcmVzcG9uc2VPcmlnaW59XCIuYCk7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbGlkYXRlUmVzcG9uc2VTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVSZXNwb25zZUVycm9yKHJlc3BvbnNlLnN0YXR1cywgdXJsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHRoaXMuX3JlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgfSkuY2F0Y2godGhpcy5fcmVhZENhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZG9uZVxuICAgIH0gPSBhd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGdldEFycmF5QnVmZmVyKHZhbHVlKSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fcmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9uZXR3b3JrLmpzXG5cblxuXG5cblxuXG5jb25zdCBPS19SRVNQT05TRSA9IDIwMDtcbmNvbnN0IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRSA9IDIwNjtcbmZ1bmN0aW9uIG5ldHdvcmtfZ2V0QXJyYXlCdWZmZXIoeGhyKSB7XG4gIGNvbnN0IGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBzdHJpbmdUb0J5dGVzKGRhdGEpLmJ1ZmZlcjtcbn1cbmNsYXNzIE5ldHdvcmtNYW5hZ2VyIHtcbiAgX3Jlc3BvbnNlT3JpZ2luID0gbnVsbDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCxcbiAgICBodHRwSGVhZGVycyxcbiAgICB3aXRoQ3JlZGVudGlhbHNcbiAgfSkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdCh1cmwpO1xuICAgIHRoaXMuaGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5pc0h0dHAsIGh0dHBIZWFkZXJzKTtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLmN1cnJYaHJJZCA9IDA7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIHJlcXVlc3QoYXJncykge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIGNvbnN0IHhocklkID0gdGhpcy5jdXJyWGhySWQrKztcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXSA9IHtcbiAgICAgIHhoclxuICAgIH07XG4gICAgeGhyLm9wZW4oXCJHRVRcIiwgdGhpcy51cmwpO1xuICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy5oZWFkZXJzKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSHR0cCAmJiBcImJlZ2luXCIgaW4gYXJncyAmJiBcImVuZFwiIGluIGFyZ3MpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIiwgYGJ5dGVzPSR7YXJncy5iZWdpbn0tJHthcmdzLmVuZCAtIDF9YCk7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPSBPS19SRVNQT05TRTtcbiAgICB9XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICBhc3NlcnQoYXJncy5vbkVycm9yLCBcIkV4cGVjdGVkIGBvbkVycm9yYCBjYWxsYmFjayB0byBiZSBwcm92aWRlZC5cIik7XG4gICAgeGhyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICBhcmdzLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgfTtcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5vblByb2dyZXNzLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkID0gYXJncy5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUgPSBhcmdzLm9uRG9uZTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yID0gYXJncy5vbkVycm9yO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3MgPSBhcmdzLm9uUHJvZ3Jlc3M7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gICAgcmV0dXJuIHhocklkO1xuICB9XG4gIG9uUHJvZ3Jlc3MoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcz8uKGV2dCk7XG4gIH1cbiAgb25TdGF0ZUNoYW5nZSh4aHJJZCwgZXZ0KSB7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKCFwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHIgPSBwZW5kaW5nUmVxdWVzdC54aHI7XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID49IDIgJiYgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKCk7XG4gICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgfVxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCAmJiB0aGlzLmlzSHR0cCkge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyU3RhdHVzID0geGhyLnN0YXR1cyB8fCBPS19SRVNQT05TRTtcbiAgICBjb25zdCBva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0ID0geGhyU3RhdHVzID09PSBPS19SRVNQT05TRSAmJiBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9PT0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFO1xuICAgIGlmICghb2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCAmJiB4aHJTdGF0dXMgIT09IHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IG5ldHdvcmtfZ2V0QXJyYXlCdWZmZXIoeGhyKTtcbiAgICBpZiAoeGhyU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UpIHtcbiAgICAgIGNvbnN0IHJhbmdlSGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1SYW5nZVwiKTtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSAvYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKS8uZXhlYyhyYW5nZUhlYWRlcik7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICAgIGJlZ2luOiBwYXJzZUludChtYXRjaGVzWzFdLCAxMCksXG4gICAgICAgICAgY2h1bmtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKGBNaXNzaW5nIG9yIGludmFsaWQgXCJDb250ZW50LVJhbmdlXCIgaGVhZGVyLmApO1xuICAgICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yKDApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2h1bmspIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgIGJlZ2luOiAwLFxuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGdldFJlcXVlc3RYaHIoeGhySWQpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdLnhocjtcbiAgfVxuICBpc1BlbmRpbmdSZXF1ZXN0KHhocklkKSB7XG4gICAgcmV0dXJuIHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzO1xuICB9XG4gIGFib3J0UmVxdWVzdCh4aHJJZCkge1xuICAgIGNvbnN0IHhociA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICB4aHIuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbmV3IE5ldHdvcmtNYW5hZ2VyKHNvdXJjZSk7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQocmVhZGVyKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuaW5kZXhPZihyZWFkZXIpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGTmV0d29ya1N0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIodGhpcy5fbWFuYWdlciwgdGhpcy5fc291cmNlKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIGJlZ2luLCBlbmQpO1xuICAgIHJlYWRlci5vbkNsb3NlZCA9IHRoaXMuX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJlYWRlcik7XG4gICAgcmV0dXJuIHJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlciwgc291cmNlKSB7XG4gICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5fdXJsID0gc291cmNlLnVybDtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdElkID0gbWFuYWdlci5yZXF1ZXN0KHtcbiAgICAgIG9uSGVhZGVyc1JlY2VpdmVkOiB0aGlzLl9vbkhlYWRlcnNSZWNlaXZlZC5iaW5kKHRoaXMpLFxuICAgICAgb25Eb25lOiB0aGlzLl9vbkRvbmUuYmluZCh0aGlzKSxcbiAgICAgIG9uRXJyb3I6IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uUHJvZ3Jlc3M6IHRoaXMuX29uUHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9vbkhlYWRlcnNSZWNlaXZlZCgpIHtcbiAgICBjb25zdCBmdWxsUmVxdWVzdFhocklkID0gdGhpcy5fZnVsbFJlcXVlc3RJZDtcbiAgICBjb25zdCBmdWxsUmVxdWVzdFhociA9IHRoaXMuX21hbmFnZXIuZ2V0UmVxdWVzdFhocihmdWxsUmVxdWVzdFhocklkKTtcbiAgICB0aGlzLl9tYW5hZ2VyLl9yZXNwb25zZU9yaWdpbiA9IGdldFJlc3BvbnNlT3JpZ2luKGZ1bGxSZXF1ZXN0WGhyLnJlc3BvbnNlVVJMKTtcbiAgICBjb25zdCByYXdSZXNwb25zZUhlYWRlcnMgPSBmdWxsUmVxdWVzdFhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBuZXcgSGVhZGVycyhyYXdSZXNwb25zZUhlYWRlcnMgPyByYXdSZXNwb25zZUhlYWRlcnMudHJpbVN0YXJ0KCkucmVwbGFjZSgvW15cXFMgXSskLywgXCJcIikuc3BsaXQoL1tcXHJcXG5dKy8pLm1hcCh4ID0+IHtcbiAgICAgIGNvbnN0IFtrZXksIC4uLnZhbF0gPSB4LnNwbGl0KFwiOiBcIik7XG4gICAgICByZXR1cm4gW2tleSwgdmFsLmpvaW4oXCI6IFwiKV07XG4gICAgfSkgOiBbXSk7XG4gICAgY29uc3Qge1xuICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgfSA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIGlzSHR0cDogdGhpcy5fbWFuYWdlci5pc0h0dHAsXG4gICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgIH0pO1xuICAgIGlmIChhbGxvd1JhbmdlUmVxdWVzdHMpIHtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKHJlc3BvbnNlSGVhZGVycyk7XG4gICAgaWYgKHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KGZ1bGxSZXF1ZXN0WGhySWQpO1xuICAgIH1cbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGRhdGEuY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRDaHVua3MucHVzaChkYXRhLmNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGNyZWF0ZVJlc3BvbnNlRXJyb3Ioc3RhdHVzLCB0aGlzLl91cmwpO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID0gMDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICB0b3RhbDogZXZ0Lmxlbmd0aENvbXB1dGFibGUgPyBldnQudG90YWwgOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jYWNoZWRDaHVua3Muc2hpZnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9mdWxsUmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCk7XG4gICAgfVxuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLl91cmwgPSBtYW5hZ2VyLnVybDtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3Qoe1xuICAgICAgYmVnaW4sXG4gICAgICBlbmQsXG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLm9uQ2xvc2VkID0gbnVsbDtcbiAgfVxuICBfb25IZWFkZXJzUmVjZWl2ZWQoKSB7XG4gICAgY29uc3QgcmVzcG9uc2VPcmlnaW4gPSBnZXRSZXNwb25zZU9yaWdpbih0aGlzLl9tYW5hZ2VyLmdldFJlcXVlc3RYaHIodGhpcy5fcmVxdWVzdElkKT8ucmVzcG9uc2VVUkwpO1xuICAgIGlmIChyZXNwb25zZU9yaWdpbiAhPT0gdGhpcy5fbWFuYWdlci5fcmVzcG9uc2VPcmlnaW4pIHtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbmV3IEVycm9yKGBFeHBlY3RlZCByYW5nZSByZXNwb25zZS1vcmlnaW4gXCIke3Jlc3BvbnNlT3JpZ2lufVwiIHRvIG1hdGNoIFwiJHt0aGlzLl9tYW5hZ2VyLl9yZXNwb25zZU9yaWdpbn1cIi5gKTtcbiAgICAgIHRoaXMuX29uRXJyb3IoMCk7XG4gICAgfVxuICB9XG4gIF9jbG9zZSgpIHtcbiAgICB0aGlzLm9uQ2xvc2VkPy4odGhpcyk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgY29uc3QgY2h1bmsgPSBkYXRhLmNodW5rO1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jbG9zZSgpO1xuICB9XG4gIF9vbkVycm9yKHN0YXR1cykge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID8/PSBjcmVhdGVSZXNwb25zZUVycm9yKHN0YXR1cywgdGhpcy5fdXJsKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICBpZiAoIXRoaXMuaXNTdHJlYW1pbmdTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVuayAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9jbG9zZSgpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L25vZGVfc3RyZWFtLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCB1cmxSZWdleCA9IC9eW2Etel1bYS16MC05XFwtKy5dKzovaTtcbmZ1bmN0aW9uIHBhcnNlVXJsT3JQYXRoKHNvdXJjZVVybCkge1xuICBpZiAodXJsUmVnZXgudGVzdChzb3VyY2VVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoc291cmNlVXJsKTtcbiAgfVxuICBjb25zdCB1cmwgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJ1cmxcIik7XG4gIHJldHVybiBuZXcgVVJMKHVybC5wYXRoVG9GaWxlVVJMKHNvdXJjZVVybCkpO1xufVxuY2xhc3MgUERGTm9kZVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gcGFyc2VVcmxPclBhdGgoc291cmNlLnVybCk7XG4gICAgYXNzZXJ0KHRoaXMudXJsLnByb3RvY29sID09PSBcImZpbGU6XCIsIFwiUERGTm9kZVN0cmVhbSBvbmx5IHN1cHBvcnRzIGZpbGU6Ly8gVVJMcy5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGTm9kZVN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByYW5nZVJlYWRlciA9IG5ldyBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlcih0aGlzLCBzdGFydCwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmFuZ2VSZWFkZXIpO1xuICAgIHJldHVybiByYW5nZVJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3VybCA9IHN0cmVhbS51cmw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIGNvbnN0IGZzID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwiZnNcIik7XG4gICAgZnMucHJvbWlzZXMubHN0YXQodGhpcy5fdXJsKS50aGVuKHN0YXQgPT4ge1xuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN0YXQuc2l6ZTtcbiAgICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKGZzLmNyZWF0ZVJlYWRTdHJlYW0odGhpcy5fdXJsKSk7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSwgZXJyb3IgPT4ge1xuICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgZXJyb3IgPSBjcmVhdGVSZXNwb25zZUVycm9yKDAsIHRoaXMuX3VybC5ocmVmKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXJyb3I7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5yZWFkKCk7XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZCgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHJlYXNvbik7XG4gIH1cbiAgX2Vycm9yKHJlYXNvbikge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBfc2V0UmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwicmVhZGFibGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9lcnJvcihuZXcgQWJvcnRFeGNlcHRpb24oXCJzdHJlYW1pbmcgaXMgZGlzYWJsZWRcIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgY29uc3QgZnMgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJmc1wiKTtcbiAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHRoaXMuX3VybCwge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmQ6IGVuZCAtIDFcbiAgICB9KSk7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuICBfZXJyb3IocmVhc29uKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9wZGZfb2JqZWN0cy5qc1xuXG5jb25zdCBJTklUSUFMX0RBVEEgPSBTeW1ib2woXCJJTklUSUFMX0RBVEFcIik7XG5jbGFzcyBQREZPYmplY3RzIHtcbiAgI29ianMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAjZW5zdXJlT2JqKG9iaklkKSB7XG4gICAgcmV0dXJuIHRoaXMuI29ianNbb2JqSWRdIHx8PSB7XG4gICAgICAuLi5Qcm9taXNlLndpdGhSZXNvbHZlcnMoKSxcbiAgICAgIGRhdGE6IElOSVRJQUxfREFUQVxuICAgIH07XG4gIH1cbiAgZ2V0KG9iaklkLCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgICBvYmoucHJvbWlzZS50aGVuKCgpID0+IGNhbGxiYWNrKG9iai5kYXRhKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgaWYgKCFvYmogfHwgb2JqLmRhdGEgPT09IElOSVRJQUxfREFUQSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1ZXN0aW5nIG9iamVjdCB0aGF0IGlzbid0IHJlc29sdmVkIHlldCAke29iaklkfS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5kYXRhO1xuICB9XG4gIGhhcyhvYmpJZCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIHJldHVybiAhIW9iaiAmJiBvYmouZGF0YSAhPT0gSU5JVElBTF9EQVRBO1xuICB9XG4gIGRlbGV0ZShvYmpJZCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIGlmICghb2JqIHx8IG9iai5kYXRhID09PSBJTklUSUFMX0RBVEEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuI29ianNbb2JqSWRdO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJlc29sdmUob2JqSWQsIGRhdGEgPSBudWxsKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jZW5zdXJlT2JqKG9iaklkKTtcbiAgICBvYmouZGF0YSA9IGRhdGE7XG4gICAgb2JqLnJlc29sdmUoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IG9iaklkIGluIHRoaXMuI29ianMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgICAgZGF0YT8uYml0bWFwPy5jbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLiNvYmpzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgZm9yIChjb25zdCBvYmpJZCBpbiB0aGlzLiNvYmpzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICAgIGlmIChkYXRhID09PSBJTklUSUFMX0RBVEEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB5aWVsZCBbb2JqSWQsIGRhdGFdO1xuICAgIH1cbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS90ZXh0X2xheWVyLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgTUFYX1RFWFRfRElWU19UT19SRU5ERVIgPSAxMDAwMDA7XG5jb25zdCBERUZBVUxUX0ZPTlRfU0laRSA9IDMwO1xuY2xhc3MgVGV4dExheWVyIHtcbiAgI2NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICNkaXNhYmxlUHJvY2Vzc0l0ZW1zID0gZmFsc2U7XG4gICNmb250SW5zcGVjdG9yRW5hYmxlZCA9ICEhZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yPy5lbmFibGVkO1xuICAjbGFuZyA9IG51bGw7XG4gICNsYXlvdXRUZXh0UGFyYW1zID0gbnVsbDtcbiAgI3BhZ2VIZWlnaHQgPSAwO1xuICAjcGFnZVdpZHRoID0gMDtcbiAgI3JlYWRlciA9IG51bGw7XG4gICNyb290Q29udGFpbmVyID0gbnVsbDtcbiAgI3JvdGF0aW9uID0gMDtcbiAgI3NjYWxlID0gMDtcbiAgI3N0eWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAjdGV4dENvbnRlbnRJdGVtc1N0ciA9IFtdO1xuICAjdGV4dENvbnRlbnRTb3VyY2UgPSBudWxsO1xuICAjdGV4dERpdnMgPSBbXTtcbiAgI3RleHREaXZQcm9wZXJ0aWVzID0gbmV3IFdlYWtNYXAoKTtcbiAgI3RyYW5zZm9ybSA9IG51bGw7XG4gIHN0YXRpYyAjYXNjZW50Q2FjaGUgPSBuZXcgTWFwKCk7XG4gIHN0YXRpYyAjY2FudmFzQ29udGV4dHMgPSBuZXcgTWFwKCk7XG4gIHN0YXRpYyAjY2FudmFzQ3R4Rm9udHMgPSBuZXcgV2Vha01hcCgpO1xuICBzdGF0aWMgI21pbkZvbnRTaXplID0gbnVsbDtcbiAgc3RhdGljICNwZW5kaW5nVGV4dExheWVycyA9IG5ldyBTZXQoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRleHRDb250ZW50U291cmNlLFxuICAgIGNvbnRhaW5lcixcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgaWYgKHRleHRDb250ZW50U291cmNlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuI3RleHRDb250ZW50U291cmNlID0gdGV4dENvbnRlbnRTb3VyY2U7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGV4dENvbnRlbnRTb3VyY2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRoaXMuI3RleHRDb250ZW50U291cmNlID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0Q29udGVudFNvdXJjZSk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBcInRleHRDb250ZW50U291cmNlXCIgcGFyYW1ldGVyIHNwZWNpZmllZC4nKTtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyID0gdGhpcy4jcm9vdENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiNzY2FsZSA9IHZpZXdwb3J0LnNjYWxlICogT3V0cHV0U2NhbGUucGl4ZWxSYXRpbztcbiAgICB0aGlzLiNyb3RhdGlvbiA9IHZpZXdwb3J0LnJvdGF0aW9uO1xuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMgPSB7XG4gICAgICBkaXY6IG51bGwsXG4gICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgY3R4OiBudWxsXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIHRoaXMuI3RyYW5zZm9ybSA9IFsxLCAwLCAwLCAtMSwgLXBhZ2VYLCBwYWdlWSArIHBhZ2VIZWlnaHRdO1xuICAgIHRoaXMuI3BhZ2VXaWR0aCA9IHBhZ2VXaWR0aDtcbiAgICB0aGlzLiNwYWdlSGVpZ2h0ID0gcGFnZUhlaWdodDtcbiAgICBUZXh0TGF5ZXIuI2Vuc3VyZU1pbkZvbnRTaXplQ29tcHV0ZWQoKTtcbiAgICBzZXRMYXllckRpbWVuc2lvbnMoY29udGFpbmVyLCB2aWV3cG9ydCk7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5wcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgVGV4dExheWVyLiNwZW5kaW5nVGV4dExheWVycy5kZWxldGUodGhpcyk7XG4gICAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zID0gbnVsbDtcbiAgICAgIHRoaXMuI3N0eWxlQ2FjaGUgPSBudWxsO1xuICAgIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IGZvbnRGYW1pbHlNYXAoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNXaW5kb3dzLFxuICAgICAgaXNGaXJlZm94XG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImZvbnRGYW1pbHlNYXBcIiwgbmV3IE1hcChbW1wic2Fucy1zZXJpZlwiLCBgJHtpc1dpbmRvd3MgJiYgaXNGaXJlZm94ID8gXCJDYWxpYnJpLCBcIiA6IFwiXCJ9c2Fucy1zZXJpZmBdLCBbXCJtb25vc3BhY2VcIiwgYCR7aXNXaW5kb3dzICYmIGlzRmlyZWZveCA/IFwiTHVjaWRhIENvbnNvbGUsIFwiIDogXCJcIn1tb25vc3BhY2VgXV0pKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgcHVtcCA9ICgpID0+IHtcbiAgICAgIHRoaXMuI3JlYWRlci5yZWFkKCkudGhlbigoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIHRoaXMuI2NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNsYW5nID8/PSB2YWx1ZS5sYW5nO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuI3N0eWxlQ2FjaGUsIHZhbHVlLnN0eWxlcyk7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3NJdGVtcyh2YWx1ZS5pdGVtcyk7XG4gICAgICAgIHB1bXAoKTtcbiAgICAgIH0sIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB9O1xuICAgIHRoaXMuI3JlYWRlciA9IHRoaXMuI3RleHRDb250ZW50U291cmNlLmdldFJlYWRlcigpO1xuICAgIFRleHRMYXllci4jcGVuZGluZ1RleHRMYXllcnMuYWRkKHRoaXMpO1xuICAgIHB1bXAoKTtcbiAgICByZXR1cm4gdGhpcy4jY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHVwZGF0ZSh7XG4gICAgdmlld3BvcnQsXG4gICAgb25CZWZvcmUgPSBudWxsXG4gIH0pIHtcbiAgICBjb25zdCBzY2FsZSA9IHZpZXdwb3J0LnNjYWxlICogT3V0cHV0U2NhbGUucGl4ZWxSYXRpbztcbiAgICBjb25zdCByb3RhdGlvbiA9IHZpZXdwb3J0LnJvdGF0aW9uO1xuICAgIGlmIChyb3RhdGlvbiAhPT0gdGhpcy4jcm90YXRpb24pIHtcbiAgICAgIG9uQmVmb3JlPy4oKTtcbiAgICAgIHRoaXMuI3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgICBzZXRMYXllckRpbWVuc2lvbnModGhpcy4jcm9vdENvbnRhaW5lciwge1xuICAgICAgICByb3RhdGlvblxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2FsZSAhPT0gdGhpcy4jc2NhbGUpIHtcbiAgICAgIG9uQmVmb3JlPy4oKTtcbiAgICAgIHRoaXMuI3NjYWxlID0gc2NhbGU7XG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgY3R4OiBUZXh0TGF5ZXIuI2dldEN0eCh0aGlzLiNsYW5nKVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgZGl2IG9mIHRoaXMuI3RleHREaXZzKSB7XG4gICAgICAgIHBhcmFtcy5wcm9wZXJ0aWVzID0gdGhpcy4jdGV4dERpdlByb3BlcnRpZXMuZ2V0KGRpdik7XG4gICAgICAgIHBhcmFtcy5kaXYgPSBkaXY7XG4gICAgICAgIHRoaXMuI2xheW91dChwYXJhbXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgY29uc3QgYWJvcnRFeCA9IG5ldyBBYm9ydEV4Y2VwdGlvbihcIlRleHRMYXllciB0YXNrIGNhbmNlbGxlZC5cIik7XG4gICAgdGhpcy4jcmVhZGVyPy5jYW5jZWwoYWJvcnRFeCkuY2F0Y2goKCkgPT4ge30pO1xuICAgIHRoaXMuI3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5yZWplY3QoYWJvcnRFeCk7XG4gIH1cbiAgZ2V0IHRleHREaXZzKCkge1xuICAgIHJldHVybiB0aGlzLiN0ZXh0RGl2cztcbiAgfVxuICBnZXQgdGV4dENvbnRlbnRJdGVtc1N0cigpIHtcbiAgICByZXR1cm4gdGhpcy4jdGV4dENvbnRlbnRJdGVtc1N0cjtcbiAgfVxuICAjcHJvY2Vzc0l0ZW1zKGl0ZW1zKSB7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVQcm9jZXNzSXRlbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcy5jdHggPz89IFRleHRMYXllci4jZ2V0Q3R4KHRoaXMuI2xhbmcpO1xuICAgIGNvbnN0IHRleHREaXZzID0gdGhpcy4jdGV4dERpdnMsXG4gICAgICB0ZXh0Q29udGVudEl0ZW1zU3RyID0gdGhpcy4jdGV4dENvbnRlbnRJdGVtc1N0cjtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGlmICh0ZXh0RGl2cy5sZW5ndGggPiBNQVhfVEVYVF9ESVZTX1RPX1JFTkRFUikge1xuICAgICAgICB3YXJuKFwiSWdub3JpbmcgYWRkaXRpb25hbCB0ZXh0RGl2cyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cIik7XG4gICAgICAgIHRoaXMuI2Rpc2FibGVQcm9jZXNzSXRlbXMgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXRlbS5zdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcImJlZ2luTWFya2VkQ29udGVudFByb3BzXCIgfHwgaXRlbS50eXBlID09PSBcImJlZ2luTWFya2VkQ29udGVudFwiKSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy4jY29udGFpbmVyO1xuICAgICAgICAgIHRoaXMuI2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFya2VkQ29udGVudFwiKTtcbiAgICAgICAgICBpZiAoaXRlbS5pZCkge1xuICAgICAgICAgICAgdGhpcy4jY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImlkXCIsIGAke2l0ZW0uaWR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudC5hcHBlbmQodGhpcy4jY29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFwiZW5kTWFya2VkQ29udGVudFwiKSB7XG4gICAgICAgICAgdGhpcy4jY29udGFpbmVyID0gdGhpcy4jY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0ZXh0Q29udGVudEl0ZW1zU3RyLnB1c2goaXRlbS5zdHIpO1xuICAgICAgdGhpcy4jYXBwZW5kVGV4dChpdGVtKTtcbiAgICB9XG4gIH1cbiAgI2FwcGVuZFRleHQoZ2VvbSkge1xuICAgIGNvbnN0IHRleHREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBjb25zdCB0ZXh0RGl2UHJvcGVydGllcyA9IHtcbiAgICAgIGFuZ2xlOiAwLFxuICAgICAgY2FudmFzV2lkdGg6IDAsXG4gICAgICBoYXNUZXh0OiBnZW9tLnN0ciAhPT0gXCJcIixcbiAgICAgIGhhc0VPTDogZ2VvbS5oYXNFT0wsXG4gICAgICBmb250U2l6ZTogMFxuICAgIH07XG4gICAgdGhpcy4jdGV4dERpdnMucHVzaCh0ZXh0RGl2KTtcbiAgICBjb25zdCB0eCA9IFV0aWwudHJhbnNmb3JtKHRoaXMuI3RyYW5zZm9ybSwgZ2VvbS50cmFuc2Zvcm0pO1xuICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIodHhbMV0sIHR4WzBdKTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuI3N0eWxlQ2FjaGVbZ2VvbS5mb250TmFtZV07XG4gICAgaWYgKHN0eWxlLnZlcnRpY2FsKSB7XG4gICAgICBhbmdsZSArPSBNYXRoLlBJIC8gMjtcbiAgICB9XG4gICAgbGV0IGZvbnRGYW1pbHkgPSB0aGlzLiNmb250SW5zcGVjdG9yRW5hYmxlZCAmJiBzdHlsZS5mb250U3Vic3RpdHV0aW9uIHx8IHN0eWxlLmZvbnRGYW1pbHk7XG4gICAgZm9udEZhbWlseSA9IFRleHRMYXllci5mb250RmFtaWx5TWFwLmdldChmb250RmFtaWx5KSB8fCBmb250RmFtaWx5O1xuICAgIGNvbnN0IGZvbnRIZWlnaHQgPSBNYXRoLmh5cG90KHR4WzJdLCB0eFszXSk7XG4gICAgY29uc3QgZm9udEFzY2VudCA9IGZvbnRIZWlnaHQgKiBUZXh0TGF5ZXIuI2dldEFzY2VudChmb250RmFtaWx5LCBzdHlsZSwgdGhpcy4jbGFuZyk7XG4gICAgbGV0IGxlZnQsIHRvcDtcbiAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgIGxlZnQgPSB0eFs0XTtcbiAgICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IHR4WzRdICsgZm9udEFzY2VudCAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudCAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVGYWN0b3JTdHIgPSBcImNhbGModmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSAqXCI7XG4gICAgY29uc3QgZGl2U3R5bGUgPSB0ZXh0RGl2LnN0eWxlO1xuICAgIGlmICh0aGlzLiNjb250YWluZXIgPT09IHRoaXMuI3Jvb3RDb250YWluZXIpIHtcbiAgICAgIGRpdlN0eWxlLmxlZnQgPSBgJHsoMTAwICogbGVmdCAvIHRoaXMuI3BhZ2VXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICAgIGRpdlN0eWxlLnRvcCA9IGAkeygxMDAgKiB0b3AgLyB0aGlzLiNwYWdlSGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXZTdHlsZS5sZWZ0ID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHtsZWZ0LnRvRml4ZWQoMil9cHgpYDtcbiAgICAgIGRpdlN0eWxlLnRvcCA9IGAke3NjYWxlRmFjdG9yU3RyfSR7dG9wLnRvRml4ZWQoMil9cHgpYDtcbiAgICB9XG4gICAgZGl2U3R5bGUuZm9udFNpemUgPSBgJHtzY2FsZUZhY3RvclN0cn0keyhUZXh0TGF5ZXIuI21pbkZvbnRTaXplICogZm9udEhlaWdodCkudG9GaXhlZCgyKX1weClgO1xuICAgIGRpdlN0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgIHRleHREaXZQcm9wZXJ0aWVzLmZvbnRTaXplID0gZm9udEhlaWdodDtcbiAgICB0ZXh0RGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgdGV4dERpdi50ZXh0Q29udGVudCA9IGdlb20uc3RyO1xuICAgIHRleHREaXYuZGlyID0gZ2VvbS5kaXI7XG4gICAgaWYgKHRoaXMuI2ZvbnRJbnNwZWN0b3JFbmFibGVkKSB7XG4gICAgICB0ZXh0RGl2LmRhdGFzZXQuZm9udE5hbWUgPSBzdHlsZS5mb250U3Vic3RpdHV0aW9uTG9hZGVkTmFtZSB8fCBnZW9tLmZvbnROYW1lO1xuICAgIH1cbiAgICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmFuZ2xlID0gYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSk7XG4gICAgfVxuICAgIGxldCBzaG91bGRTY2FsZVRleHQgPSBmYWxzZTtcbiAgICBpZiAoZ2VvbS5zdHIubGVuZ3RoID4gMSkge1xuICAgICAgc2hvdWxkU2NhbGVUZXh0ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGdlb20uc3RyICE9PSBcIiBcIiAmJiBnZW9tLnRyYW5zZm9ybVswXSAhPT0gZ2VvbS50cmFuc2Zvcm1bM10pIHtcbiAgICAgIGNvbnN0IGFic1NjYWxlWCA9IE1hdGguYWJzKGdlb20udHJhbnNmb3JtWzBdKSxcbiAgICAgICAgYWJzU2NhbGVZID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bM10pO1xuICAgICAgaWYgKGFic1NjYWxlWCAhPT0gYWJzU2NhbGVZICYmIE1hdGgubWF4KGFic1NjYWxlWCwgYWJzU2NhbGVZKSAvIE1hdGgubWluKGFic1NjYWxlWCwgYWJzU2NhbGVZKSA+IDEuNSkge1xuICAgICAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkU2NhbGVUZXh0KSB7XG4gICAgICB0ZXh0RGl2UHJvcGVydGllcy5jYW52YXNXaWR0aCA9IHN0eWxlLnZlcnRpY2FsID8gZ2VvbS5oZWlnaHQgOiBnZW9tLndpZHRoO1xuICAgIH1cbiAgICB0aGlzLiN0ZXh0RGl2UHJvcGVydGllcy5zZXQodGV4dERpdiwgdGV4dERpdlByb3BlcnRpZXMpO1xuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMuZGl2ID0gdGV4dERpdjtcbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zLnByb3BlcnRpZXMgPSB0ZXh0RGl2UHJvcGVydGllcztcbiAgICB0aGlzLiNsYXlvdXQodGhpcy4jbGF5b3V0VGV4dFBhcmFtcyk7XG4gICAgaWYgKHRleHREaXZQcm9wZXJ0aWVzLmhhc1RleHQpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQodGV4dERpdik7XG4gICAgfVxuICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5oYXNFT0wpIHtcbiAgICAgIGNvbnN0IGJyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgICAgYnIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQoYnIpO1xuICAgIH1cbiAgfVxuICAjbGF5b3V0KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdixcbiAgICAgIHByb3BlcnRpZXMsXG4gICAgICBjdHhcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBsZXQgdHJhbnNmb3JtID0gXCJcIjtcbiAgICBpZiAoVGV4dExheWVyLiNtaW5Gb250U2l6ZSA+IDEpIHtcbiAgICAgIHRyYW5zZm9ybSA9IGBzY2FsZSgkezEgLyBUZXh0TGF5ZXIuI21pbkZvbnRTaXplfSlgO1xuICAgIH1cbiAgICBpZiAocHJvcGVydGllcy5jYW52YXNXaWR0aCAhPT0gMCAmJiBwcm9wZXJ0aWVzLmhhc1RleHQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZm9udEZhbWlseVxuICAgICAgfSA9IHN0eWxlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjYW52YXNXaWR0aCxcbiAgICAgICAgZm9udFNpemVcbiAgICAgIH0gPSBwcm9wZXJ0aWVzO1xuICAgICAgVGV4dExheWVyLiNlbnN1cmVDdHhGb250KGN0eCwgZm9udFNpemUgKiB0aGlzLiNzY2FsZSwgZm9udEZhbWlseSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoXG4gICAgICB9ID0gY3R4Lm1lYXN1cmVUZXh0KGRpdi50ZXh0Q29udGVudCk7XG4gICAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IGBzY2FsZVgoJHtjYW52YXNXaWR0aCAqIHRoaXMuI3NjYWxlIC8gd2lkdGh9KSAke3RyYW5zZm9ybX1gO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcGVydGllcy5hbmdsZSAhPT0gMCkge1xuICAgICAgdHJhbnNmb3JtID0gYHJvdGF0ZSgke3Byb3BlcnRpZXMuYW5nbGV9ZGVnKSAke3RyYW5zZm9ybX1gO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuI3BlbmRpbmdUZXh0TGF5ZXJzLnNpemUgPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FzY2VudENhY2hlLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBjYW52YXNcbiAgICB9IG9mIHRoaXMuI2NhbnZhc0NvbnRleHRzLnZhbHVlcygpKSB7XG4gICAgICBjYW52YXMucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuI2NhbnZhc0NvbnRleHRzLmNsZWFyKCk7XG4gIH1cbiAgc3RhdGljICNnZXRDdHgobGFuZyA9IG51bGwpIHtcbiAgICBsZXQgY3R4ID0gdGhpcy4jY2FudmFzQ29udGV4dHMuZ2V0KGxhbmcgfHw9IFwiXCIpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IFwiaGlkZGVuQ2FudmFzRWxlbWVudFwiO1xuICAgICAgY2FudmFzLmxhbmcgPSBsYW5nO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoY2FudmFzKTtcbiAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICBhbHBoYTogZmFsc2UsXG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLiNjYW52YXNDb250ZXh0cy5zZXQobGFuZywgY3R4KTtcbiAgICAgIHRoaXMuI2NhbnZhc0N0eEZvbnRzLnNldChjdHgsIHtcbiAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgZmFtaWx5OiBcIlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuICBzdGF0aWMgI2Vuc3VyZUN0eEZvbnQoY3R4LCBzaXplLCBmYW1pbHkpIHtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLiNjYW52YXNDdHhGb250cy5nZXQoY3R4KTtcbiAgICBpZiAoc2l6ZSA9PT0gY2FjaGVkLnNpemUgJiYgZmFtaWx5ID09PSBjYWNoZWQuZmFtaWx5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5mb250ID0gYCR7c2l6ZX1weCAke2ZhbWlseX1gO1xuICAgIGNhY2hlZC5zaXplID0gc2l6ZTtcbiAgICBjYWNoZWQuZmFtaWx5ID0gZmFtaWx5O1xuICB9XG4gIHN0YXRpYyAjZW5zdXJlTWluRm9udFNpemVDb21wdXRlZCgpIHtcbiAgICBpZiAodGhpcy4jbWluRm9udFNpemUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgZGl2LnN0eWxlLmxpbmVIZWlnaHQgPSAxO1xuICAgIGRpdi5zdHlsZS5mb250U2l6ZSA9IFwiMXB4XCI7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGRpdi50ZXh0Q29udGVudCA9IFwiWFwiO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgdGhpcy4jbWluRm9udFNpemUgPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIGRpdi5yZW1vdmUoKTtcbiAgfVxuICBzdGF0aWMgI2dldEFzY2VudChmb250RmFtaWx5LCBzdHlsZSwgbGFuZykge1xuICAgIGNvbnN0IGNhY2hlZEFzY2VudCA9IHRoaXMuI2FzY2VudENhY2hlLmdldChmb250RmFtaWx5KTtcbiAgICBpZiAoY2FjaGVkQXNjZW50KSB7XG4gICAgICByZXR1cm4gY2FjaGVkQXNjZW50O1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLiNnZXRDdHgobGFuZyk7XG4gICAgY3R4LmNhbnZhcy53aWR0aCA9IGN0eC5jYW52YXMuaGVpZ2h0ID0gREVGQVVMVF9GT05UX1NJWkU7XG4gICAgdGhpcy4jZW5zdXJlQ3R4Rm9udChjdHgsIERFRkFVTFRfRk9OVF9TSVpFLCBmb250RmFtaWx5KTtcbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KFwiXCIpO1xuICAgIGNvbnN0IGFzY2VudCA9IG1ldHJpY3MuZm9udEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGNvbnN0IGRlc2NlbnQgPSBNYXRoLmFicyhtZXRyaWNzLmZvbnRCb3VuZGluZ0JveERlc2NlbnQpO1xuICAgIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IDA7XG4gICAgbGV0IHJhdGlvID0gMC44O1xuICAgIGlmIChhc2NlbnQpIHtcbiAgICAgIHJhdGlvID0gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc0ZpcmVmb3gpIHtcbiAgICAgICAgd2FybihcIkVuYWJsZSB0aGUgYGRvbS50ZXh0TWV0cmljcy5mb250Qm91bmRpbmdCb3guZW5hYmxlZGAgcHJlZmVyZW5jZSBcIiArIFwiaW4gYGFib3V0OmNvbmZpZ2AgdG8gaW1wcm92ZSBUZXh0TGF5ZXIgcmVuZGVyaW5nLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZS5hc2NlbnQpIHtcbiAgICAgICAgcmF0aW8gPSBzdHlsZS5hc2NlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHN0eWxlLmRlc2NlbnQpIHtcbiAgICAgICAgcmF0aW8gPSAxICsgc3R5bGUuZGVzY2VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jYXNjZW50Q2FjaGUuc2V0KGZvbnRGYW1pbHksIHJhdGlvKTtcbiAgICByZXR1cm4gcmF0aW87XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvYXBpLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUID0gMTAwO1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoc3JjID0ge30pIHtcbiAgaWYgKHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIgfHwgc3JjIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgc3JjID0ge1xuICAgICAgdXJsOiBzcmNcbiAgICB9O1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhzcmMpKSB7XG4gICAgc3JjID0ge1xuICAgICAgZGF0YTogc3JjXG4gICAgfTtcbiAgfVxuICBjb25zdCB0YXNrID0gbmV3IFBERkRvY3VtZW50TG9hZGluZ1Rhc2soKTtcbiAgY29uc3Qge1xuICAgIGRvY0lkXG4gIH0gPSB0YXNrO1xuICBjb25zdCB1cmwgPSBzcmMudXJsID8gZ2V0VXJsUHJvcChzcmMudXJsKSA6IG51bGw7XG4gIGNvbnN0IGRhdGEgPSBzcmMuZGF0YSA/IGdldERhdGFQcm9wKHNyYy5kYXRhKSA6IG51bGw7XG4gIGNvbnN0IGh0dHBIZWFkZXJzID0gc3JjLmh0dHBIZWFkZXJzIHx8IG51bGw7XG4gIGNvbnN0IHdpdGhDcmVkZW50aWFscyA9IHNyYy53aXRoQ3JlZGVudGlhbHMgPT09IHRydWU7XG4gIGNvbnN0IHBhc3N3b3JkID0gc3JjLnBhc3N3b3JkID8/IG51bGw7XG4gIGNvbnN0IHJhbmdlVHJhbnNwb3J0ID0gc3JjLnJhbmdlIGluc3RhbmNlb2YgUERGRGF0YVJhbmdlVHJhbnNwb3J0ID8gc3JjLnJhbmdlIDogbnVsbDtcbiAgY29uc3QgcmFuZ2VDaHVua1NpemUgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5yYW5nZUNodW5rU2l6ZSkgJiYgc3JjLnJhbmdlQ2h1bmtTaXplID4gMCA/IHNyYy5yYW5nZUNodW5rU2l6ZSA6IDIgKiogMTY7XG4gIGxldCB3b3JrZXIgPSBzcmMud29ya2VyIGluc3RhbmNlb2YgUERGV29ya2VyID8gc3JjLndvcmtlciA6IG51bGw7XG4gIGNvbnN0IHZlcmJvc2l0eSA9IHNyYy52ZXJib3NpdHk7XG4gIGNvbnN0IGRvY0Jhc2VVcmwgPSB0eXBlb2Ygc3JjLmRvY0Jhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgIWlzRGF0YVNjaGVtZShzcmMuZG9jQmFzZVVybCkgPyBzcmMuZG9jQmFzZVVybCA6IG51bGw7XG4gIGNvbnN0IGNNYXBVcmwgPSBnZXRGYWN0b3J5VXJsUHJvcChzcmMuY01hcFVybCk7XG4gIGNvbnN0IGNNYXBQYWNrZWQgPSBzcmMuY01hcFBhY2tlZCAhPT0gZmFsc2U7XG4gIGNvbnN0IENNYXBSZWFkZXJGYWN0b3J5ID0gc3JjLkNNYXBSZWFkZXJGYWN0b3J5IHx8IChpc05vZGVKUyA/IE5vZGVDTWFwUmVhZGVyRmFjdG9yeSA6IERPTUNNYXBSZWFkZXJGYWN0b3J5KTtcbiAgY29uc3QgaWNjVXJsID0gZ2V0RmFjdG9yeVVybFByb3Aoc3JjLmljY1VybCk7XG4gIGNvbnN0IHN0YW5kYXJkRm9udERhdGFVcmwgPSBnZXRGYWN0b3J5VXJsUHJvcChzcmMuc3RhbmRhcmRGb250RGF0YVVybCk7XG4gIGNvbnN0IFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gc3JjLlN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHx8IChpc05vZGVKUyA/IE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA6IERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5KTtcbiAgY29uc3Qgd2FzbVVybCA9IGdldEZhY3RvcnlVcmxQcm9wKHNyYy53YXNtVXJsKTtcbiAgY29uc3QgV2FzbUZhY3RvcnkgPSBzcmMuV2FzbUZhY3RvcnkgfHwgKGlzTm9kZUpTID8gTm9kZVdhc21GYWN0b3J5IDogRE9NV2FzbUZhY3RvcnkpO1xuICBjb25zdCBpZ25vcmVFcnJvcnMgPSBzcmMuc3RvcEF0RXJyb3JzICE9PSB0cnVlO1xuICBjb25zdCBtYXhJbWFnZVNpemUgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5tYXhJbWFnZVNpemUpICYmIHNyYy5tYXhJbWFnZVNpemUgPiAtMSA/IHNyYy5tYXhJbWFnZVNpemUgOiAtMTtcbiAgY29uc3QgaXNFdmFsU3VwcG9ydGVkID0gc3JjLmlzRXZhbFN1cHBvcnRlZCAhPT0gZmFsc2U7XG4gIGNvbnN0IGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID0gdHlwZW9mIHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA9PT0gXCJib29sZWFuXCIgPyBzcmMuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgOiAhaXNOb2RlSlM7XG4gIGNvbnN0IGlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkID0gdHlwZW9mIHNyYy5pc0ltYWdlRGVjb2RlclN1cHBvcnRlZCA9PT0gXCJib29sZWFuXCIgPyBzcmMuaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQgOiAhaXNOb2RlSlMgJiYgKHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm0uaXNGaXJlZm94IHx8ICFnbG9iYWxUaGlzLmNocm9tZSk7XG4gIGNvbnN0IGNhbnZhc01heEFyZWFJbkJ5dGVzID0gTnVtYmVyLmlzSW50ZWdlcihzcmMuY2FudmFzTWF4QXJlYUluQnl0ZXMpID8gc3JjLmNhbnZhc01heEFyZWFJbkJ5dGVzIDogLTE7XG4gIGNvbnN0IGRpc2FibGVGb250RmFjZSA9IHR5cGVvZiBzcmMuZGlzYWJsZUZvbnRGYWNlID09PSBcImJvb2xlYW5cIiA/IHNyYy5kaXNhYmxlRm9udEZhY2UgOiBpc05vZGVKUztcbiAgY29uc3QgZm9udEV4dHJhUHJvcGVydGllcyA9IHNyYy5mb250RXh0cmFQcm9wZXJ0aWVzID09PSB0cnVlO1xuICBjb25zdCBlbmFibGVYZmEgPSBzcmMuZW5hYmxlWGZhID09PSB0cnVlO1xuICBjb25zdCBvd25lckRvY3VtZW50ID0gc3JjLm93bmVyRG9jdW1lbnQgfHwgZ2xvYmFsVGhpcy5kb2N1bWVudDtcbiAgY29uc3QgZGlzYWJsZVJhbmdlID0gc3JjLmRpc2FibGVSYW5nZSA9PT0gdHJ1ZTtcbiAgY29uc3QgZGlzYWJsZVN0cmVhbSA9IHNyYy5kaXNhYmxlU3RyZWFtID09PSB0cnVlO1xuICBjb25zdCBkaXNhYmxlQXV0b0ZldGNoID0gc3JjLmRpc2FibGVBdXRvRmV0Y2ggPT09IHRydWU7XG4gIGNvbnN0IHBkZkJ1ZyA9IHNyYy5wZGZCdWcgPT09IHRydWU7XG4gIGNvbnN0IENhbnZhc0ZhY3RvcnkgPSBzcmMuQ2FudmFzRmFjdG9yeSB8fCAoaXNOb2RlSlMgPyBOb2RlQ2FudmFzRmFjdG9yeSA6IERPTUNhbnZhc0ZhY3RvcnkpO1xuICBjb25zdCBGaWx0ZXJGYWN0b3J5ID0gc3JjLkZpbHRlckZhY3RvcnkgfHwgKGlzTm9kZUpTID8gTm9kZUZpbHRlckZhY3RvcnkgOiBET01GaWx0ZXJGYWN0b3J5KTtcbiAgY29uc3QgZW5hYmxlSFdBID0gc3JjLmVuYWJsZUhXQSA9PT0gdHJ1ZTtcbiAgY29uc3QgdXNlV2FzbSA9IHNyYy51c2VXYXNtICE9PSBmYWxzZTtcbiAgY29uc3QgbGVuZ3RoID0gcmFuZ2VUcmFuc3BvcnQgPyByYW5nZVRyYW5zcG9ydC5sZW5ndGggOiBzcmMubGVuZ3RoID8/IE5hTjtcbiAgY29uc3QgdXNlU3lzdGVtRm9udHMgPSB0eXBlb2Ygc3JjLnVzZVN5c3RlbUZvbnRzID09PSBcImJvb2xlYW5cIiA/IHNyYy51c2VTeXN0ZW1Gb250cyA6ICFpc05vZGVKUyAmJiAhZGlzYWJsZUZvbnRGYWNlO1xuICBjb25zdCB1c2VXb3JrZXJGZXRjaCA9IHR5cGVvZiBzcmMudXNlV29ya2VyRmV0Y2ggPT09IFwiYm9vbGVhblwiID8gc3JjLnVzZVdvcmtlckZldGNoIDogISEoQ01hcFJlYWRlckZhY3RvcnkgPT09IERPTUNNYXBSZWFkZXJGYWN0b3J5ICYmIFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID09PSBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSAmJiBXYXNtRmFjdG9yeSA9PT0gRE9NV2FzbUZhY3RvcnkgJiYgY01hcFVybCAmJiBzdGFuZGFyZEZvbnREYXRhVXJsICYmIHdhc21VcmwgJiYgaXNWYWxpZEZldGNoVXJsKGNNYXBVcmwsIGRvY3VtZW50LmJhc2VVUkkpICYmIGlzVmFsaWRGZXRjaFVybChzdGFuZGFyZEZvbnREYXRhVXJsLCBkb2N1bWVudC5iYXNlVVJJKSAmJiBpc1ZhbGlkRmV0Y2hVcmwod2FzbVVybCwgZG9jdW1lbnQuYmFzZVVSSSkpO1xuICBjb25zdCBzdHlsZUVsZW1lbnQgPSBudWxsO1xuICBzZXRWZXJib3NpdHlMZXZlbCh2ZXJib3NpdHkpO1xuICBjb25zdCB0cmFuc3BvcnRGYWN0b3J5ID0ge1xuICAgIGNhbnZhc0ZhY3Rvcnk6IG5ldyBDYW52YXNGYWN0b3J5KHtcbiAgICAgIG93bmVyRG9jdW1lbnQsXG4gICAgICBlbmFibGVIV0FcbiAgICB9KSxcbiAgICBmaWx0ZXJGYWN0b3J5OiBuZXcgRmlsdGVyRmFjdG9yeSh7XG4gICAgICBkb2NJZCxcbiAgICAgIG93bmVyRG9jdW1lbnRcbiAgICB9KSxcbiAgICBjTWFwUmVhZGVyRmFjdG9yeTogdXNlV29ya2VyRmV0Y2ggPyBudWxsIDogbmV3IENNYXBSZWFkZXJGYWN0b3J5KHtcbiAgICAgIGJhc2VVcmw6IGNNYXBVcmwsXG4gICAgICBpc0NvbXByZXNzZWQ6IGNNYXBQYWNrZWRcbiAgICB9KSxcbiAgICBzdGFuZGFyZEZvbnREYXRhRmFjdG9yeTogdXNlV29ya2VyRmV0Y2ggPyBudWxsIDogbmV3IFN0YW5kYXJkRm9udERhdGFGYWN0b3J5KHtcbiAgICAgIGJhc2VVcmw6IHN0YW5kYXJkRm9udERhdGFVcmxcbiAgICB9KSxcbiAgICB3YXNtRmFjdG9yeTogdXNlV29ya2VyRmV0Y2ggPyBudWxsIDogbmV3IFdhc21GYWN0b3J5KHtcbiAgICAgIGJhc2VVcmw6IHdhc21VcmxcbiAgICB9KVxuICB9O1xuICBpZiAoIXdvcmtlcikge1xuICAgIHdvcmtlciA9IFBERldvcmtlci5jcmVhdGUoe1xuICAgICAgdmVyYm9zaXR5LFxuICAgICAgcG9ydDogR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJQb3J0XG4gICAgfSk7XG4gICAgdGFzay5fd29ya2VyID0gd29ya2VyO1xuICB9XG4gIGNvbnN0IGRvY1BhcmFtcyA9IHtcbiAgICBkb2NJZCxcbiAgICBhcGlWZXJzaW9uOiBcIjUuNC4yOTZcIixcbiAgICBkYXRhLFxuICAgIHBhc3N3b3JkLFxuICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgcmFuZ2VDaHVua1NpemUsXG4gICAgbGVuZ3RoLFxuICAgIGRvY0Jhc2VVcmwsXG4gICAgZW5hYmxlWGZhLFxuICAgIGV2YWx1YXRvck9wdGlvbnM6IHtcbiAgICAgIG1heEltYWdlU2l6ZSxcbiAgICAgIGRpc2FibGVGb250RmFjZSxcbiAgICAgIGlnbm9yZUVycm9ycyxcbiAgICAgIGlzRXZhbFN1cHBvcnRlZCxcbiAgICAgIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkLFxuICAgICAgaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQsXG4gICAgICBjYW52YXNNYXhBcmVhSW5CeXRlcyxcbiAgICAgIGZvbnRFeHRyYVByb3BlcnRpZXMsXG4gICAgICB1c2VTeXN0ZW1Gb250cyxcbiAgICAgIHVzZVdhc20sXG4gICAgICB1c2VXb3JrZXJGZXRjaCxcbiAgICAgIGNNYXBVcmwsXG4gICAgICBpY2NVcmwsXG4gICAgICBzdGFuZGFyZEZvbnREYXRhVXJsLFxuICAgICAgd2FzbVVybFxuICAgIH1cbiAgfTtcbiAgY29uc3QgdHJhbnNwb3J0UGFyYW1zID0ge1xuICAgIG93bmVyRG9jdW1lbnQsXG4gICAgcGRmQnVnLFxuICAgIHN0eWxlRWxlbWVudCxcbiAgICBsb2FkaW5nUGFyYW1zOiB7XG4gICAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgICAgZW5hYmxlWGZhXG4gICAgfVxuICB9O1xuICB3b3JrZXIucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvYWRpbmcgYWJvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB3b3JrZXJJZFByb21pc2UgPSB3b3JrZXIubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RG9jUmVxdWVzdFwiLCBkb2NQYXJhbXMsIGRhdGEgPyBbZGF0YS5idWZmZXJdIDogbnVsbCk7XG4gICAgbGV0IG5ldHdvcmtTdHJlYW07XG4gICAgaWYgKHJhbmdlVHJhbnNwb3J0KSB7XG4gICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW0ocmFuZ2VUcmFuc3BvcnQsIHtcbiAgICAgICAgZGlzYWJsZVJhbmdlLFxuICAgICAgICBkaXNhYmxlU3RyZWFtXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFkYXRhKSB7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXREb2N1bWVudCAtIG5vIGB1cmxgIHBhcmFtZXRlciBwcm92aWRlZC5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBOZXR3b3JrU3RyZWFtID0gaXNWYWxpZEZldGNoVXJsKHVybCkgPyBQREZGZXRjaFN0cmVhbSA6IGlzTm9kZUpTID8gUERGTm9kZVN0cmVhbSA6IFBERk5ldHdvcmtTdHJlYW07XG4gICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IE5ldHdvcmtTdHJlYW0oe1xuICAgICAgICB1cmwsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgaHR0cEhlYWRlcnMsXG4gICAgICAgIHdpdGhDcmVkZW50aWFscyxcbiAgICAgICAgcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZSxcbiAgICAgICAgZGlzYWJsZVN0cmVhbVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB3b3JrZXJJZFByb21pc2UudGhlbih3b3JrZXJJZCA9PiB7XG4gICAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihkb2NJZCwgd29ya2VySWQsIHdvcmtlci5wb3J0KTtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBXb3JrZXJUcmFuc3BvcnQobWVzc2FnZUhhbmRsZXIsIHRhc2ssIG5ldHdvcmtTdHJlYW0sIHRyYW5zcG9ydFBhcmFtcywgdHJhbnNwb3J0RmFjdG9yeSwgZW5hYmxlSFdBKTtcbiAgICAgIHRhc2suX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJSZWFkeVwiLCBudWxsKTtcbiAgICB9KTtcbiAgfSkuY2F0Y2godGFzay5fY2FwYWJpbGl0eS5yZWplY3QpO1xuICByZXR1cm4gdGFzaztcbn1cbmNsYXNzIFBERkRvY3VtZW50TG9hZGluZ1Rhc2sge1xuICBzdGF0aWMgI2RvY0lkID0gMDtcbiAgX2NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgX3RyYW5zcG9ydCA9IG51bGw7XG4gIF93b3JrZXIgPSBudWxsO1xuICBkb2NJZCA9IGBkJHtQREZEb2N1bWVudExvYWRpbmdUYXNrLiNkb2NJZCsrfWA7XG4gIGRlc3Ryb3llZCA9IGZhbHNlO1xuICBvblBhc3N3b3JkID0gbnVsbDtcbiAgb25Qcm9ncmVzcyA9IG51bGw7XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl93b3JrZXI/LnBvcnQpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyLl9wZW5kaW5nRGVzdHJveSA9IHRydWU7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnQ/LmRlc3Ryb3koKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKHRoaXMuX3dvcmtlcj8ucG9ydCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fd29ya2VyLl9wZW5kaW5nRGVzdHJveTtcbiAgICAgIH1cbiAgICAgIHRocm93IGV4O1xuICAgIH1cbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dvcmtlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gIH1cbiAgYXN5bmMgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERhdGEoKTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVJhbmdlVHJhbnNwb3J0IHtcbiAgI2NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgI3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycyA9IFtdO1xuICAjcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzID0gW107XG4gICNwcm9ncmVzc0xpc3RlbmVycyA9IFtdO1xuICAjcmFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBpbml0aWFsRGF0YSwgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuaW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICB0aGlzLnByb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLmNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU7XG4gIH1cbiAgYWRkUmFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuI3JhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLiNwcm9ncmVzc0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuI3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuI3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBvbkRhdGFSYW5nZShiZWdpbiwgY2h1bmspIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuI3JhbmdlTGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcihiZWdpbiwgY2h1bmspO1xuICAgIH1cbiAgfVxuICBvbkRhdGFQcm9ncmVzcyhsb2FkZWQsIHRvdGFsKSB7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNwcm9ncmVzc0xpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihsb2FkZWQsIHRvdGFsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbkRhdGFQcm9ncmVzc2l2ZVJlYWQoY2h1bmspIHtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuI3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdHJhbnNwb3J0UmVhZHkoKSB7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgcmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgUERGRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2VcIik7XG4gIH1cbiAgYWJvcnQoKSB7fVxufVxuY2xhc3MgUERGRG9jdW1lbnRQcm94eSB7XG4gIGNvbnN0cnVjdG9yKHBkZkluZm8sIHRyYW5zcG9ydCkge1xuICAgIHRoaXMuX3BkZkluZm8gPSBwZGZJbmZvO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgfVxuICBnZXQgYW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgfVxuICBnZXQgY2FudmFzRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmNhbnZhc0ZhY3Rvcnk7XG4gIH1cbiAgZ2V0IGZpbHRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5O1xuICB9XG4gIGdldCBudW1QYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5udW1QYWdlcztcbiAgfVxuICBnZXQgZmluZ2VycHJpbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wZGZJbmZvLmZpbmdlcnByaW50cztcbiAgfVxuICBnZXQgaXNQdXJlWGZhKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc1B1cmVYZmFcIiwgISF0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpO1xuICB9XG4gIGdldCBhbGxYZmFIdG1sKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmE7XG4gIH1cbiAgZ2V0UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlKHBhZ2VOdW1iZXIpO1xuICB9XG4gIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VJbmRleChyZWYpO1xuICB9XG4gIGdldERlc3RpbmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9ucygpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREZXN0aW5hdGlvbihpZCk7XG4gIH1cbiAgZ2V0UGFnZUxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VMYWJlbHMoKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxheW91dCgpO1xuICB9XG4gIGdldFBhZ2VNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZU1vZGUoKTtcbiAgfVxuICBnZXRWaWV3ZXJQcmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFZpZXdlclByZWZlcmVuY2VzKCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wZW5BY3Rpb24oKTtcbiAgfVxuICBnZXRBdHRhY2htZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEF0dGFjaG1lbnRzKCk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvbnNCeVR5cGUodHlwZXMsIHBhZ2VJbmRleGVzVG9Ta2lwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRBbm5vdGF0aW9uc0J5VHlwZSh0eXBlcywgcGFnZUluZGV4ZXNUb1NraXApO1xuICB9XG4gIGdldEpTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERvY0pTQWN0aW9ucygpO1xuICB9XG4gIGdldE91dGxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPdXRsaW5lKCk7XG4gIH1cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIlxuICB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJpbmdJbnRlbnRcbiAgICB9ID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHJlbmRlcmluZ0ludGVudCk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQZXJtaXNzaW9ucygpO1xuICB9XG4gIGdldE1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWV0YWRhdGEoKTtcbiAgfVxuICBnZXRNYXJrSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1hcmtJbmZvKCk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERhdGEoKTtcbiAgfVxuICBzYXZlRG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zYXZlRG9jdW1lbnQoKTtcbiAgfVxuICBnZXREb3dubG9hZEluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2xlYW51cChrZWVwTG9hZGVkRm9udHMgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc3RhcnRDbGVhbnVwKGtlZXBMb2FkZWRGb250cyB8fCB0aGlzLmlzUHVyZVhmYSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkaW5nVGFzay5kZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVkUGFnZU51bWJlcihyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmNhY2hlZFBhZ2VOdW1iZXIocmVmKTtcbiAgfVxuICBnZXQgbG9hZGluZ1BhcmFtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdQYXJhbXM7XG4gIH1cbiAgZ2V0IGxvYWRpbmdUYXNrKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1Rhc2s7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RmllbGRPYmplY3RzKCk7XG4gIH1cbiAgaGFzSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuaGFzSlNBY3Rpb25zKCk7XG4gIH1cbiAgZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldENhbGN1bGF0aW9uT3JkZXJJZHMoKTtcbiAgfVxufVxuY2xhc3MgUERGUGFnZVByb3h5IHtcbiAgI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHBhZ2VJbmRleCwgcGFnZUluZm8sIHRyYW5zcG9ydCwgcGRmQnVnID0gZmFsc2UpIHtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5fcGFnZUluZm8gPSBwYWdlSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5fc3RhdHMgPSBwZGZCdWcgPyBuZXcgU3RhdFRpbWVyKCkgOiBudWxsO1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSB0cmFuc3BvcnQuY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuX2ludGVudFN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMucmVjb3JkZWRCQm94ZXMgPSBudWxsO1xuICB9XG4gIGdldCBwYWdlTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5kZXggKyAxO1xuICB9XG4gIGdldCByb3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJvdGF0ZTtcbiAgfVxuICBnZXQgcmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yZWY7XG4gIH1cbiAgZ2V0IHVzZXJVbml0KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby51c2VyVW5pdDtcbiAgfVxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8udmlldztcbiAgfVxuICBnZXRWaWV3cG9ydCh7XG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0ZSxcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlldyxcbiAgICAgIHVzZXJVbml0OiB0aGlzLnVzZXJVbml0LFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuICBnZXRBbm5vdGF0aW9ucyh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCJcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50XG4gICAgfSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEFubm90YXRpb25zKHRoaXMuX3BhZ2VJbmRleCwgcmVuZGVyaW5nSW50ZW50KTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSlNBY3Rpb25zKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGZpbHRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5O1xuICB9XG4gIGdldCBpc1B1cmVYZmEoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzUHVyZVhmYVwiLCAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSk7XG4gIH1cbiAgYXN5bmMgZ2V0WGZhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmE/LmNoaWxkcmVuW3RoaXMuX3BhZ2VJbmRleF0gfHwgbnVsbDtcbiAgfVxuICByZW5kZXIoe1xuICAgIGNhbnZhc0NvbnRleHQsXG4gICAgY2FudmFzID0gY2FudmFzQ29udGV4dC5jYW52YXMsXG4gICAgdmlld3BvcnQsXG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCIsXG4gICAgYW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZS5FTkFCTEUsXG4gICAgdHJhbnNmb3JtID0gbnVsbCxcbiAgICBiYWNrZ3JvdW5kID0gbnVsbCxcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gbnVsbCxcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwID0gbnVsbCxcbiAgICBwYWdlQ29sb3JzID0gbnVsbCxcbiAgICBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbCxcbiAgICBpc0VkaXRpbmcgPSBmYWxzZSxcbiAgICByZWNvcmRPcGVyYXRpb25zID0gZmFsc2UsXG4gICAgb3BlcmF0aW9uc0ZpbHRlciA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiT3ZlcmFsbFwiKTtcbiAgICBjb25zdCBpbnRlbnRBcmdzID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlLCBwcmludEFubm90YXRpb25TdG9yYWdlLCBpc0VkaXRpbmcpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5XG4gICAgfSA9IGludGVudEFyZ3M7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlIHx8PSB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHJlbmRlcmluZ0ludGVudCk7XG4gICAgbGV0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLnNldChjYWNoZUtleSwgaW50ZW50U3RhdGUpO1xuICAgIH1cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGludGVudFByaW50ID0gISEocmVuZGVyaW5nSW50ZW50ICYgUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVCk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QgPSB7XG4gICAgICAgIGZuQXJyYXk6IFtdLFxuICAgICAgICBhcmdzQXJyYXk6IFtdLFxuICAgICAgICBsYXN0Q2h1bms6IGZhbHNlLFxuICAgICAgICBzZXBhcmF0ZUFubm90czogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdChpbnRlbnRBcmdzKTtcbiAgICB9XG4gICAgY29uc3QgcmVjb3JkRm9yRGVidWdnZXIgPSBCb29sZWFuKHRoaXMuX3BkZkJ1ZyAmJiBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyPy5lbmFibGVkKTtcbiAgICBjb25zdCBzaG91bGRSZWNvcmRPcGVyYXRpb25zID0gIXRoaXMucmVjb3JkZWRCQm94ZXMgJiYgKHJlY29yZE9wZXJhdGlvbnMgfHwgcmVjb3JkRm9yRGVidWdnZXIpO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gZXJyb3IgPT4ge1xuICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MuZGVsZXRlKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgICBpZiAoc2hvdWxkUmVjb3JkT3BlcmF0aW9ucykge1xuICAgICAgICBjb25zdCByZWNvcmRlZEJCb3hlcyA9IGludGVybmFsUmVuZGVyVGFzay5nZng/LmRlcGVuZGVuY3lUcmFja2VyLnRha2UoKTtcbiAgICAgICAgaWYgKHJlY29yZGVkQkJveGVzKSB7XG4gICAgICAgICAgaWYgKGludGVybmFsUmVuZGVyVGFzay5zdGVwcGVyKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suc3RlcHBlci5zZXRPcGVyYXRvckJCb3hlcyhyZWNvcmRlZEJCb3hlcywgaW50ZXJuYWxSZW5kZXJUYXNrLmdmeC5kZXBlbmRlbmN5VHJhY2tlci50YWtlRGVidWdNZXRhZGF0YSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlY29yZE9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkZWRCQm94ZXMgPSByZWNvcmRlZEJCb3hlcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnRlbnRQcmludCkge1xuICAgICAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLiN0cnlDbGVhbnVwKCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcbiAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zdGF0cykge1xuICAgICAgICB0aGlzLl9zdGF0cy50aW1lRW5kKFwiUmVuZGVyaW5nXCIpO1xuICAgICAgICB0aGlzLl9zdGF0cy50aW1lRW5kKFwiT3ZlcmFsbFwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuU3RhdHM/LmVuYWJsZWQpIHtcbiAgICAgICAgICBnbG9iYWxUaGlzLlN0YXRzLmFkZCh0aGlzLnBhZ2VOdW1iZXIsIHRoaXMuX3N0YXRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrID0gbmV3IEludGVybmFsUmVuZGVyVGFzayh7XG4gICAgICBjYWxsYmFjazogY29tcGxldGUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgY2FudmFzLFxuICAgICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgICBkZXBlbmRlbmN5VHJhY2tlcjogc2hvdWxkUmVjb3JkT3BlcmF0aW9ucyA/IG5ldyBDYW52YXNEZXBlbmRlbmN5VHJhY2tlcihjYW52YXMsIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sZW5ndGgsIHJlY29yZEZvckRlYnVnZ2VyKSA6IG51bGwsXG4gICAgICAgIHZpZXdwb3J0LFxuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIGJhY2tncm91bmRcbiAgICAgIH0sXG4gICAgICBvYmpzOiB0aGlzLm9ianMsXG4gICAgICBjb21tb25PYmpzOiB0aGlzLmNvbW1vbk9ianMsXG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgICAgb3BlcmF0b3JMaXN0OiBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGNhbnZhc0ZhY3Rvcnk6IHRoaXMuX3RyYW5zcG9ydC5jYW52YXNGYWN0b3J5LFxuICAgICAgZmlsdGVyRmFjdG9yeTogdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3RvcnksXG4gICAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWU6ICFpbnRlbnRQcmludCxcbiAgICAgIHBkZkJ1ZzogdGhpcy5fcGRmQnVnLFxuICAgICAgcGFnZUNvbG9ycyxcbiAgICAgIGVuYWJsZUhXQTogdGhpcy5fdHJhbnNwb3J0LmVuYWJsZUhXQSxcbiAgICAgIG9wZXJhdGlvbnNGaWx0ZXJcbiAgICB9KTtcbiAgICAoaW50ZW50U3RhdGUucmVuZGVyVGFza3MgfHw9IG5ldyBTZXQoKSkuYWRkKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgY29uc3QgcmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzay50YXNrO1xuICAgIFByb21pc2UuYWxsKFtpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnByb21pc2UsIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2VdKS50aGVuKChbdHJhbnNwYXJlbmN5LCBvcHRpb25hbENvbnRlbnRDb25maWddKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJSZW5kZXJpbmdcIik7XG4gICAgICBpZiAoIShvcHRpb25hbENvbnRlbnRDb25maWcucmVuZGVyaW5nSW50ZW50ICYgcmVuZGVyaW5nSW50ZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHVzZSB0aGUgc2FtZSBgaW50ZW50YC1hcmd1bWVudCB3aGVuIGNhbGxpbmcgdGhlIGBQREZQYWdlUHJveHkucmVuZGVyYCBcIiArIFwiYW5kIGBQREZEb2N1bWVudFByb3h5LmdldE9wdGlvbmFsQ29udGVudENvbmZpZ2AgbWV0aG9kcy5cIik7XG4gICAgICB9XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2suaW5pdGlhbGl6ZUdyYXBoaWNzKHtcbiAgICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgICAgIH0pO1xuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICB9KS5jYXRjaChjb21wbGV0ZSk7XG4gICAgcmV0dXJuIHJlbmRlclRhc2s7XG4gIH1cbiAgZ2V0T3BlcmF0b3JMaXN0KHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIixcbiAgICBhbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlLkVOQUJMRSxcbiAgICBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbCxcbiAgICBpc0VkaXRpbmcgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBmdW5jdGlvbiBvcGVyYXRvckxpc3RDaGFuZ2VkKCkge1xuICAgICAgaWYgKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucmVzb2x2ZShpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QpO1xuICAgICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5kZWxldGUob3BMaXN0VGFzayk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UsIGlzRWRpdGluZywgdHJ1ZSk7XG4gICAgbGV0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChpbnRlbnRBcmdzLmNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICBpbnRlbnRTdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGludGVudEFyZ3MuY2FjaGVLZXksIGludGVudFN0YXRlKTtcbiAgICB9XG4gICAgbGV0IG9wTGlzdFRhc2s7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgb3BMaXN0VGFzayA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBvcExpc3RUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQgPSBvcGVyYXRvckxpc3RDaGFuZ2VkO1xuICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyB8fD0gbmV3IFNldCgpKS5hZGQob3BMaXN0VGFzayk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QgPSB7XG4gICAgICAgIGZuQXJyYXk6IFtdLFxuICAgICAgICBhcmdzQXJyYXk6IFtdLFxuICAgICAgICBsYXN0Q2h1bms6IGZhbHNlLFxuICAgICAgICBzZXBhcmF0ZUFubm90czogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdChpbnRlbnRBcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc3RyZWFtVGV4dENvbnRlbnQoe1xuICAgIGluY2x1ZGVNYXJrZWRDb250ZW50ID0gZmFsc2UsXG4gICAgZGlzYWJsZU5vcm1hbGl6YXRpb24gPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBjb25zdCBURVhUX0NPTlRFTlRfQ0hVTktfU0laRSA9IDEwMDtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoU3RyZWFtKFwiR2V0VGV4dENvbnRlbnRcIiwge1xuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBpbmNsdWRlTWFya2VkQ29udGVudDogaW5jbHVkZU1hcmtlZENvbnRlbnQgPT09IHRydWUsXG4gICAgICBkaXNhYmxlTm9ybWFsaXphdGlvbjogZGlzYWJsZU5vcm1hbGl6YXRpb24gPT09IHRydWVcbiAgICB9LCB7XG4gICAgICBoaWdoV2F0ZXJNYXJrOiBURVhUX0NPTlRFTlRfQ0hVTktfU0laRSxcbiAgICAgIHNpemUodGV4dENvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRleHRDb250ZW50Lml0ZW1zLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUZXh0Q29udGVudChwYXJhbXMgPSB7fSkge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFhmYSgpLnRoZW4oeGZhID0+IFhmYVRleHQudGV4dENvbnRlbnQoeGZhKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gdGhpcy5zdHJlYW1UZXh0Q29udGVudChwYXJhbXMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICByZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHRDb250ZW50LmxhbmcgPz89IHZhbHVlLmxhbmc7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih0ZXh0Q29udGVudC5zdHlsZXMsIHZhbHVlLnN0eWxlcyk7XG4gICAgICAgICAgdGV4dENvbnRlbnQuaXRlbXMucHVzaCguLi52YWx1ZS5pdGVtcyk7XG4gICAgICAgICAgcHVtcCgpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICBjb25zdCB0ZXh0Q29udGVudCA9IHtcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBzdHlsZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIGxhbmc6IG51bGxcbiAgICAgIH07XG4gICAgICBwdW1wKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0U3RydWN0VHJlZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFN0cnVjdFRyZWUodGhpcy5fcGFnZUluZGV4KTtcbiAgfVxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgY29uc3Qgd2FpdE9uID0gW107XG4gICAgZm9yIChjb25zdCBpbnRlbnRTdGF0ZSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgIHJlYXNvbjogbmV3IEVycm9yKFwiUGFnZSB3YXMgZGVzdHJveWVkLlwiKSxcbiAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgd2FpdE9uLnB1c2goaW50ZXJuYWxSZW5kZXJUYXNrLmNvbXBsZXRlZCk7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vYmpzLmNsZWFyKCk7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwod2FpdE9uKTtcbiAgfVxuICBjbGVhbnVwKHJlc2V0U3RhdHMgPSBmYWxzZSkge1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gdHJ1ZTtcbiAgICBjb25zdCBzdWNjZXNzID0gdGhpcy4jdHJ5Q2xlYW51cCgpO1xuICAgIGlmIChyZXNldFN0YXRzICYmIHN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuX3N0YXRzICYmPSBuZXcgU3RhdFRpbWVyKCk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG4gICN0cnlDbGVhbnVwKCkge1xuICAgIGlmICghdGhpcy4jcGVuZGluZ0NsZWFudXAgfHwgdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICByZW5kZXJUYXNrcyxcbiAgICAgIG9wZXJhdG9yTGlzdFxuICAgIH0gb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocmVuZGVyVGFza3Muc2l6ZSA+IDAgfHwgIW9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuY2xlYXIoKTtcbiAgICB0aGlzLm9ianMuY2xlYXIoKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zdGFydFJlbmRlclBhZ2UodHJhbnNwYXJlbmN5LCBjYWNoZUtleSkge1xuICAgIGNvbnN0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0cz8udGltZUVuZChcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5Py5yZXNvbHZlKHRyYW5zcGFyZW5jeSk7XG4gIH1cbiAgX3JlbmRlclBhZ2VDaHVuayhvcGVyYXRvckxpc3RDaHVuaywgaW50ZW50U3RhdGUpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvcGVyYXRvckxpc3RDaHVuay5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QuZm5BcnJheS5wdXNoKG9wZXJhdG9yTGlzdENodW5rLmZuQXJyYXlbaV0pO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5wdXNoKG9wZXJhdG9yTGlzdENodW5rLmFyZ3NBcnJheVtpXSk7XG4gICAgfVxuICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmsgPSBvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bms7XG4gICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LnNlcGFyYXRlQW5ub3RzID0gb3BlcmF0b3JMaXN0Q2h1bmsuc2VwYXJhdGVBbm5vdHM7XG4gICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgfVxuICAgIGlmIChvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bmspIHtcbiAgICAgIHRoaXMuI3RyeUNsZWFudXAoKTtcbiAgICB9XG4gIH1cbiAgX3B1bXBPcGVyYXRvckxpc3Qoe1xuICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICBjYWNoZUtleSxcbiAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSxcbiAgICBtb2RpZmllZElkc1xuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGU7XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRPcGVyYXRvckxpc3RcIiwge1xuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBpbnRlbnQ6IHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5LFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IG1hcCxcbiAgICAgIG1vZGlmaWVkSWRzXG4gICAgfSwgdHJhbnNmZXIpO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gcmVhZGVyO1xuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICByZWFkZXIucmVhZCgpLnRoZW4oKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW5kZXJQYWdlQ2h1bmsodmFsdWUsIGludGVudFN0YXRlKTtcbiAgICAgICAgcHVtcCgpO1xuICAgICAgfSwgcmVhc29uID0+IHtcbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCkge1xuICAgICAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLiN0cnlDbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHB1bXAoKTtcbiAgfVxuICBfYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudFN0YXRlLFxuICAgIHJlYXNvbixcbiAgICBmb3JjZSA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoIWludGVudFN0YXRlLnN0cmVhbVJlYWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5zaXplID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uIGluc3RhbmNlb2YgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKSB7XG4gICAgICAgIGxldCBkZWxheSA9IFJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVDtcbiAgICAgICAgaWYgKHJlYXNvbi5leHRyYURlbGF5ID4gMCAmJiByZWFzb24uZXh0cmFEZWxheSA8IDEwMDApIHtcbiAgICAgICAgICBkZWxheSArPSByZWFzb24uZXh0cmFEZWxheTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyLmNhbmNlbChuZXcgQWJvcnRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtjdXJDYWNoZUtleSwgY3VySW50ZW50U3RhdGVdIG9mIHRoaXMuX2ludGVudFN0YXRlcykge1xuICAgICAgaWYgKGN1ckludGVudFN0YXRlID09PSBpbnRlbnRTdGF0ZSkge1xuICAgICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuZGVsZXRlKGN1ckNhY2hlS2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIGdldCBzdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHM7XG4gIH1cbn1cbmNsYXNzIFBERldvcmtlciB7XG4gICNjYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICNtZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICNwb3J0ID0gbnVsbDtcbiAgI3dlYldvcmtlciA9IG51bGw7XG4gIHN0YXRpYyAjZmFrZVdvcmtlcklkID0gMDtcbiAgc3RhdGljICNpc1dvcmtlckRpc2FibGVkID0gZmFsc2U7XG4gIHN0YXRpYyAjd29ya2VyUG9ydHMgPSBuZXcgV2Vha01hcCgpO1xuICBzdGF0aWMge1xuICAgIGlmIChpc05vZGVKUykge1xuICAgICAgdGhpcy4jaXNXb3JrZXJEaXNhYmxlZCA9IHRydWU7XG4gICAgICBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYyB8fD0gXCIuL3BkZi53b3JrZXIubWpzXCI7XG4gICAgfVxuICAgIHRoaXMuX2lzU2FtZU9yaWdpbiA9IChiYXNlVXJsLCBvdGhlclVybCkgPT4ge1xuICAgICAgY29uc3QgYmFzZSA9IFVSTC5wYXJzZShiYXNlVXJsKTtcbiAgICAgIGlmICghYmFzZT8ub3JpZ2luIHx8IGJhc2Uub3JpZ2luID09PSBcIm51bGxcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBvdGhlciA9IG5ldyBVUkwob3RoZXJVcmwsIGJhc2UpO1xuICAgICAgcmV0dXJuIGJhc2Uub3JpZ2luID09PSBvdGhlci5vcmlnaW47XG4gICAgfTtcbiAgICB0aGlzLl9jcmVhdGVDRE5XcmFwcGVyID0gdXJsID0+IHtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBgYXdhaXQgaW1wb3J0KFwiJHt1cmx9XCIpO2A7XG4gICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd3JhcHBlcl0sIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0L2phdmFzY3JpcHRcIlxuICAgICAgfSkpO1xuICAgIH07XG4gICAgdGhpcy5mcm9tUG9ydCA9IHBhcmFtcyA9PiB7XG4gICAgICBkZXByZWNhdGVkKFwiYFBERldvcmtlci5mcm9tUG9ydGAgLSBwbGVhc2UgdXNlIGBQREZXb3JrZXIuY3JlYXRlYCBpbnN0ZWFkLlwiKTtcbiAgICAgIGlmICghcGFyYW1zPy5wb3J0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBERldvcmtlci5mcm9tUG9ydCAtIGludmFsaWQgbWV0aG9kIHNpZ25hdHVyZS5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGUocGFyYW1zKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lID0gbnVsbCxcbiAgICBwb3J0ID0gbnVsbCxcbiAgICB2ZXJib3NpdHkgPSBnZXRWZXJib3NpdHlMZXZlbCgpXG4gIH0gPSB7fSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnZlcmJvc2l0eSA9IHZlcmJvc2l0eTtcbiAgICBpZiAocG9ydCkge1xuICAgICAgaWYgKFBERldvcmtlci4jd29ya2VyUG9ydHMuaGFzKHBvcnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgbW9yZSB0aGFuIG9uZSBQREZXb3JrZXIgcGVyIHBvcnQuXCIpO1xuICAgICAgfVxuICAgICAgUERGV29ya2VyLiN3b3JrZXJQb3J0cy5zZXQocG9ydCwgdGhpcyk7XG4gICAgICB0aGlzLiNpbml0aWFsaXplRnJvbVBvcnQocG9ydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2luaXRpYWxpemUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICAjcmVzb2x2ZSgpIHtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB0aGlzLiNtZXNzYWdlSGFuZGxlci5zZW5kKFwiY29uZmlndXJlXCIsIHtcbiAgICAgIHZlcmJvc2l0eTogdGhpcy52ZXJib3NpdHlcbiAgICB9KTtcbiAgfVxuICBnZXQgcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9ydDtcbiAgfVxuICBnZXQgbWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21lc3NhZ2VIYW5kbGVyO1xuICB9XG4gICNpbml0aWFsaXplRnJvbVBvcnQocG9ydCkge1xuICAgIHRoaXMuI3BvcnQgPSBwb3J0O1xuICAgIHRoaXMuI21lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCBwb3J0KTtcbiAgICB0aGlzLiNtZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsICgpID0+IHt9KTtcbiAgICB0aGlzLiNyZXNvbHZlKCk7XG4gIH1cbiAgI2luaXRpYWxpemUoKSB7XG4gICAgaWYgKFBERldvcmtlci4jaXNXb3JrZXJEaXNhYmxlZCB8fCBQREZXb3JrZXIuI21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuICAgICAgdGhpcy4jc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7XG4gICAgICB3b3JrZXJTcmNcbiAgICB9ID0gUERGV29ya2VyO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIVBERldvcmtlci5faXNTYW1lT3JpZ2luKHdpbmRvdy5sb2NhdGlvbiwgd29ya2VyU3JjKSkge1xuICAgICAgICB3b3JrZXJTcmMgPSBQREZXb3JrZXIuX2NyZWF0ZUNETldyYXBwZXIobmV3IFVSTCh3b3JrZXJTcmMsIHdpbmRvdy5sb2NhdGlvbikuaHJlZik7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclNyYywge1xuICAgICAgICB0eXBlOiBcIm1vZHVsZVwiXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCB3b3JrZXIpO1xuICAgICAgY29uc3QgdGVybWluYXRlRWFybHkgPSAoKSA9PiB7XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICB0aGlzLiNjYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4jc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuI3dlYldvcmtlcikge1xuICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsOiBhYy5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJ0ZXN0XCIsIGRhdGEgPT4ge1xuICAgICAgICBhYy5hYm9ydCgpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQgfHwgIWRhdGEpIHtcbiAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNtZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuICAgICAgICB0aGlzLiNwb3J0ID0gd29ya2VyO1xuICAgICAgICB0aGlzLiN3ZWJXb3JrZXIgPSB3b3JrZXI7XG4gICAgICAgIHRoaXMuI3Jlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJyZWFkeVwiLCBkYXRhID0+IHtcbiAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZW5kVGVzdCgpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB0aGlzLiNzZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzZW5kVGVzdCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdGVzdE9iaiA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJ0ZXN0XCIsIHRlc3RPYmosIFt0ZXN0T2JqLmJ1ZmZlcl0pO1xuICAgICAgfTtcbiAgICAgIHNlbmRUZXN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfSBjYXRjaCB7XG4gICAgICBpbmZvKFwiVGhlIHdvcmtlciBoYXMgYmVlbiBkaXNhYmxlZC5cIik7XG4gICAgfVxuICAgIHRoaXMuI3NldHVwRmFrZVdvcmtlcigpO1xuICB9XG4gICNzZXR1cEZha2VXb3JrZXIoKSB7XG4gICAgaWYgKCFQREZXb3JrZXIuI2lzV29ya2VyRGlzYWJsZWQpIHtcbiAgICAgIHdhcm4oXCJTZXR0aW5nIHVwIGZha2Ugd29ya2VyLlwiKTtcbiAgICAgIFBERldvcmtlci4jaXNXb3JrZXJEaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIFBERldvcmtlci5fc2V0dXBGYWtlV29ya2VyR2xvYmFsLnRoZW4oV29ya2VyTWVzc2FnZUhhbmRsZXIgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9ydCA9IG5ldyBMb29wYmFja1BvcnQoKTtcbiAgICAgIHRoaXMuI3BvcnQgPSBwb3J0O1xuICAgICAgY29uc3QgaWQgPSBgZmFrZSR7UERGV29ya2VyLiNmYWtlV29ya2VySWQrK31gO1xuICAgICAgY29uc3Qgd29ya2VySGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihpZCArIFwiX3dvcmtlclwiLCBpZCwgcG9ydCk7XG4gICAgICBXb3JrZXJNZXNzYWdlSGFuZGxlci5zZXR1cCh3b3JrZXJIYW5kbGVyLCBwb3J0KTtcbiAgICAgIHRoaXMuI21lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKGlkLCBpZCArIFwiX3dvcmtlclwiLCBwb3J0KTtcbiAgICAgIHRoaXMuI3Jlc29sdmUoKTtcbiAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhpcy4jY2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKGBTZXR0aW5nIHVwIGZha2Ugd29ya2VyIGZhaWxlZDogXCIke3JlYXNvbi5tZXNzYWdlfVwiLmApKTtcbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLiN3ZWJXb3JrZXI/LnRlcm1pbmF0ZSgpO1xuICAgIHRoaXMuI3dlYldvcmtlciA9IG51bGw7XG4gICAgUERGV29ya2VyLiN3b3JrZXJQb3J0cy5kZWxldGUodGhpcy4jcG9ydCk7XG4gICAgdGhpcy4jcG9ydCA9IG51bGw7XG4gICAgdGhpcy4jbWVzc2FnZUhhbmRsZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNtZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShwYXJhbXMpIHtcbiAgICBjb25zdCBjYWNoZWRQb3J0ID0gdGhpcy4jd29ya2VyUG9ydHMuZ2V0KHBhcmFtcz8ucG9ydCk7XG4gICAgaWYgKGNhY2hlZFBvcnQpIHtcbiAgICAgIGlmIChjYWNoZWRQb3J0Ll9wZW5kaW5nRGVzdHJveSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuY3JlYXRlIC0gdGhlIHdvcmtlciBpcyBiZWluZyBkZXN0cm95ZWQuXFxuXCIgKyBcIlBsZWFzZSByZW1lbWJlciB0byBhd2FpdCBgUERGRG9jdW1lbnRMb2FkaW5nVGFzay5kZXN0cm95KClgLWNhbGxzLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZWRQb3J0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFBERldvcmtlcihwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyBnZXQgd29ya2VyU3JjKCkge1xuICAgIGlmIChHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYykge1xuICAgICAgcmV0dXJuIEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwiR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmNcIiBzcGVjaWZpZWQuJyk7XG4gIH1cbiAgc3RhdGljIGdldCAjbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2xvYmFsVGhpcy5wZGZqc1dvcmtlcj8uV29ya2VyTWVzc2FnZUhhbmRsZXIgfHwgbnVsbDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IF9zZXR1cEZha2VXb3JrZXJHbG9iYWwoKSB7XG4gICAgY29uc3QgbG9hZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuI21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy4jbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgICAgfVxuICAgICAgY29uc3Qgd29ya2VyID0gYXdhaXQgaW1wb3J0KFxuICAgICAgLyp3ZWJwYWNrSWdub3JlOiB0cnVlKi9cbiAgICAgIC8qQHZpdGUtaWdub3JlKi9cbiAgICAgIHRoaXMud29ya2VyU3JjKTtcbiAgICAgIHJldHVybiB3b3JrZXIuV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgfTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX3NldHVwRmFrZVdvcmtlckdsb2JhbFwiLCBsb2FkZXIoKSk7XG4gIH1cbn1cbmNsYXNzIFdvcmtlclRyYW5zcG9ydCB7XG4gICNtZXRob2RQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgI3BhZ2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgI3BhZ2VQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgI3BhZ2VSZWZDYWNoZSA9IG5ldyBNYXAoKTtcbiAgI3Bhc3N3b3JkQ2FwYWJpbGl0eSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2VIYW5kbGVyLCBsb2FkaW5nVGFzaywgbmV0d29ya1N0cmVhbSwgcGFyYW1zLCBmYWN0b3J5LCBlbmFibGVIV0EpIHtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgdGhpcy5sb2FkaW5nVGFzayA9IGxvYWRpbmdUYXNrO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5mb250TG9hZGVyID0gbmV3IEZvbnRMb2FkZXIoe1xuICAgICAgb3duZXJEb2N1bWVudDogcGFyYW1zLm93bmVyRG9jdW1lbnQsXG4gICAgICBzdHlsZUVsZW1lbnQ6IHBhcmFtcy5zdHlsZUVsZW1lbnRcbiAgICB9KTtcbiAgICB0aGlzLmxvYWRpbmdQYXJhbXMgPSBwYXJhbXMubG9hZGluZ1BhcmFtcztcbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gZmFjdG9yeS5jYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZhY3RvcnkuZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLmNNYXBSZWFkZXJGYWN0b3J5ID0gZmFjdG9yeS5jTWFwUmVhZGVyRmFjdG9yeTtcbiAgICB0aGlzLnN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gZmFjdG9yeS5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbiAgICB0aGlzLndhc21GYWN0b3J5ID0gZmFjdG9yeS53YXNtRmFjdG9yeTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkgPSBudWxsO1xuICAgIHRoaXMuX25ldHdvcmtTdHJlYW0gPSBuZXR3b3JrU3RyZWFtO1xuICAgIHRoaXMuX2Z1bGxSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5kb3dubG9hZEluZm9DYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5lbmFibGVIV0EgPSBlbmFibGVIV0E7XG4gICAgdGhpcy5zZXR1cE1lc3NhZ2VIYW5kbGVyKCk7XG4gIH1cbiAgI2NhY2hlU2ltcGxlTWV0aG9kKG5hbWUsIGRhdGEgPSBudWxsKSB7XG4gICAgY29uc3QgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI21ldGhvZFByb21pc2VzLmdldChuYW1lKTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShuYW1lLCBkYXRhKTtcbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5zZXQobmFtZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJhbm5vdGF0aW9uU3RvcmFnZVwiLCBuZXcgQW5ub3RhdGlvblN0b3JhZ2UoKSk7XG4gIH1cbiAgZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZS5FTkFCTEUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsLCBpc0VkaXRpbmcgPSBmYWxzZSwgaXNPcExpc3QgPSBmYWxzZSkge1xuICAgIGxldCByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVk7XG4gICAgbGV0IGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlID0gU2VyaWFsaXphYmxlRW1wdHk7XG4gICAgc3dpdGNoIChpbnRlbnQpIHtcbiAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ID0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTlk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRpc3BsYXlcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicHJpbnRcIjpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ID0gUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3YXJuKGBnZXRSZW5kZXJpbmdJbnRlbnQgLSBpbnZhbGlkIGludGVudDogJHtpbnRlbnR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGFubm90YXRpb25TdG9yYWdlID0gcmVuZGVyaW5nSW50ZW50ICYgUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVCAmJiBwcmludEFubm90YXRpb25TdG9yYWdlIGluc3RhbmNlb2YgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA/IHByaW50QW5ub3RhdGlvblN0b3JhZ2UgOiB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIHN3aXRjaCAoYW5ub3RhdGlvbk1vZGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRElTQUJMRTpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfRElTQUJMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkVOQUJMRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkVOQUJMRV9GT1JNUzpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfRk9STVM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5FTkFCTEVfU1RPUkFHRTpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfU1RPUkFHRTtcbiAgICAgICAgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUgPSBhbm5vdGF0aW9uU3RvcmFnZS5zZXJpYWxpemFibGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd2FybihgZ2V0UmVuZGVyaW5nSW50ZW50IC0gaW52YWxpZCBhbm5vdGF0aW9uTW9kZTogJHthbm5vdGF0aW9uTW9kZX1gKTtcbiAgICB9XG4gICAgaWYgKGlzRWRpdGluZykge1xuICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuSVNfRURJVElORztcbiAgICB9XG4gICAgaWYgKGlzT3BMaXN0KSB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5PUExJU1Q7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlkczogbW9kaWZpZWRJZHMsXG4gICAgICBoYXNoOiBtb2RpZmllZElkc0hhc2hcbiAgICB9ID0gYW5ub3RhdGlvblN0b3JhZ2UubW9kaWZpZWRJZHM7XG4gICAgY29uc3QgY2FjaGVLZXlCdWYgPSBbcmVuZGVyaW5nSW50ZW50LCBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZS5oYXNoLCBtb2RpZmllZElkc0hhc2hdO1xuICAgIHJldHVybiB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleTogY2FjaGVLZXlCdWYuam9pbihcIl9cIiksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSxcbiAgICAgIG1vZGlmaWVkSWRzXG4gICAgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eT8ucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkIGR1cmluZyBvblBhc3N3b3JkIGNhbGxiYWNrXCIpKTtcbiAgICBjb25zdCB3YWl0T24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICB3YWl0T24ucHVzaChwYWdlLl9kZXN0cm95KCkpO1xuICAgIH1cbiAgICB0aGlzLiNwYWdlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLiNwYWdlUHJvbWlzZXMuY2xlYXIoKTtcbiAgICB0aGlzLiNwYWdlUmVmQ2FjaGUuY2xlYXIoKTtcbiAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShcImFubm90YXRpb25TdG9yYWdlXCIpKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgY29uc3QgdGVybWluYXRlZCA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiVGVybWluYXRlXCIsIG51bGwpO1xuICAgIHdhaXRPbi5wdXNoKHRlcm1pbmF0ZWQpO1xuICAgIFByb21pc2UuYWxsKHdhaXRPbikudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZm9udExvYWRlci5jbGVhcigpO1xuICAgICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZmlsdGVyRmFjdG9yeS5kZXN0cm95KCk7XG4gICAgICBUZXh0TGF5ZXIuY2xlYW51cCgpO1xuICAgICAgdGhpcy5fbmV0d29ya1N0cmVhbT8uY2FuY2VsQWxsUmVxdWVzdHMobmV3IEFib3J0RXhjZXB0aW9uKFwiV29ya2VyIHdhcyB0ZXJtaW5hdGVkLlwiKSk7XG4gICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyPy5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHNldHVwTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZUhhbmRsZXIsXG4gICAgICBsb2FkaW5nVGFza1xuICAgIH0gPSB0aGlzO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmVhZGVyXCIsIChkYXRhLCBzaW5rKSA9PiB7XG4gICAgICBhc3NlcnQodGhpcy5fbmV0d29ya1N0cmVhbSwgXCJHZXRSZWFkZXIgLSBubyBgSVBERlN0cmVhbWAgaW5zdGFuY2UgYXZhaWxhYmxlLlwiKTtcbiAgICAgIHRoaXMuX2Z1bGxSZWFkZXIgPSB0aGlzLl9uZXR3b3JrU3RyZWFtLmdldEZ1bGxSZWFkZXIoKTtcbiAgICAgIHRoaXMuX2Z1bGxSZWFkZXIub25Qcm9ncmVzcyA9IGV2dCA9PiB7XG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IHtcbiAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHNpbmsub25QdWxsID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIsIFwiR2V0UmVhZGVyIC0gZXhwZWN0ZWQgYW4gQXJyYXlCdWZmZXIuXCIpO1xuICAgICAgICAgIHNpbmsuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSksIDEsIFt2YWx1ZV0pO1xuICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgc2luay5vbkNhbmNlbCA9IHJlYXNvbiA9PiB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIHNpbmsucmVhZHkuY2F0Y2gocmVhZHlSZWFzb24gPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyByZWFkeVJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiUmVhZGVySGVhZGVyc1JlYWR5XCIsIGFzeW5jIGRhdGEgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5fZnVsbFJlYWRlci5oZWFkZXJzUmVhZHk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzU3RyZWFtaW5nU3VwcG9ydGVkLFxuICAgICAgICBpc1JhbmdlU3VwcG9ydGVkLFxuICAgICAgICBjb250ZW50TGVuZ3RoXG4gICAgICB9ID0gdGhpcy5fZnVsbFJlYWRlcjtcbiAgICAgIGlmICghaXNTdHJlYW1pbmdTdXBwb3J0ZWQgfHwgIWlzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RQcm9ncmVzcykge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih0aGlzLl9sYXN0UHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIub25Qcm9ncmVzcyA9IGV2dCA9PiB7XG4gICAgICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzU3RyZWFtaW5nU3VwcG9ydGVkLFxuICAgICAgICBpc1JhbmdlU3VwcG9ydGVkLFxuICAgICAgICBjb250ZW50TGVuZ3RoXG4gICAgICB9O1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmFuZ2VSZWFkZXJcIiwgKGRhdGEsIHNpbmspID0+IHtcbiAgICAgIGFzc2VydCh0aGlzLl9uZXR3b3JrU3RyZWFtLCBcIkdldFJhbmdlUmVhZGVyIC0gbm8gYElQREZTdHJlYW1gIGluc3RhbmNlIGF2YWlsYWJsZS5cIik7XG4gICAgICBjb25zdCByYW5nZVJlYWRlciA9IHRoaXMuX25ldHdvcmtTdHJlYW0uZ2V0UmFuZ2VSZWFkZXIoZGF0YS5iZWdpbiwgZGF0YS5lbmQpO1xuICAgICAgaWYgKCFyYW5nZVJlYWRlcikge1xuICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNpbmsub25QdWxsID0gKCkgPT4ge1xuICAgICAgICByYW5nZVJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyLCBcIkdldFJhbmdlUmVhZGVyIC0gZXhwZWN0ZWQgYW4gQXJyYXlCdWZmZXIuXCIpO1xuICAgICAgICAgIHNpbmsuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSksIDEsIFt2YWx1ZV0pO1xuICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgc2luay5vbkNhbmNlbCA9IHJlYXNvbiA9PiB7XG4gICAgICAgIHJhbmdlUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgICBzaW5rLnJlYWR5LmNhdGNoKHJlYWR5UmVhc29uID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldERvY1wiLCAoe1xuICAgICAgcGRmSW5mb1xuICAgIH0pID0+IHtcbiAgICAgIHRoaXMuX251bVBhZ2VzID0gcGRmSW5mby5udW1QYWdlcztcbiAgICAgIHRoaXMuX2h0bWxGb3JYZmEgPSBwZGZJbmZvLmh0bWxGb3JYZmE7XG4gICAgICBkZWxldGUgcGRmSW5mby5odG1sRm9yWGZhO1xuICAgICAgbG9hZGluZ1Rhc2suX2NhcGFiaWxpdHkucmVzb2x2ZShuZXcgUERGRG9jdW1lbnRQcm94eShwZGZJbmZvLCB0aGlzKSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEb2NFeGNlcHRpb25cIiwgZXggPT4ge1xuICAgICAgbG9hZGluZ1Rhc2suX2NhcGFiaWxpdHkucmVqZWN0KHdyYXBSZWFzb24oZXgpKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlBhc3N3b3JkUmVxdWVzdFwiLCBleCA9PiB7XG4gICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbG9hZGluZ1Rhc2sub25QYXNzd29yZCkge1xuICAgICAgICAgIHRocm93IHdyYXBSZWFzb24oZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwZGF0ZVBhc3N3b3JkID0gcGFzc3dvcmQgPT4ge1xuICAgICAgICAgIGlmIChwYXNzd29yZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KHBhc3N3b3JkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgICAgICBwYXNzd29yZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsb2FkaW5nVGFzay5vblBhc3N3b3JkKHVwZGF0ZVBhc3N3b3JkLCBleC5jb2RlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEYXRhTG9hZGVkXCIsIGRhdGEgPT4ge1xuICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgdG90YWw6IGRhdGEubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiU3RhcnRSZW5kZXJQYWdlXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLiNwYWdlQ2FjaGUuZ2V0KGRhdGEucGFnZUluZGV4KTtcbiAgICAgIHBhZ2UuX3N0YXJ0UmVuZGVyUGFnZShkYXRhLnRyYW5zcGFyZW5jeSwgZGF0YS5jYWNoZUtleSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJjb21tb25vYmpcIiwgKFtpZCwgdHlwZSwgZXhwb3J0ZWREYXRhXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29tbW9uT2Jqcy5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiBleHBvcnRlZERhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVkRXJyb3IgPSBleHBvcnRlZERhdGEuZXJyb3I7XG4gICAgICAgICAgICB3YXJuKGBFcnJvciBkdXJpbmcgZm9udCBsb2FkaW5nOiAke2V4cG9ydGVkRXJyb3J9YCk7XG4gICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWRFcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZm9udERhdGEgPSBuZXcgRm9udEluZm8oZXhwb3J0ZWREYXRhKTtcbiAgICAgICAgICBjb25zdCBpbnNwZWN0Rm9udCA9IHRoaXMuX3BhcmFtcy5wZGZCdWcgJiYgZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yPy5lbmFibGVkID8gKGZvbnQsIHVybCkgPT4gZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yLmZvbnRBZGRlZChmb250LCB1cmwpIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBmb250ID0gbmV3IEZvbnRGYWNlT2JqZWN0KGZvbnREYXRhLCBpbnNwZWN0Rm9udCwgZXhwb3J0ZWREYXRhLmV4dHJhLCBleHBvcnRlZERhdGEuY2hhclByb2NPcGVyYXRvckxpc3QpO1xuICAgICAgICAgIHRoaXMuZm9udExvYWRlci5iaW5kKGZvbnQpLmNhdGNoKCgpID0+IG1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkZvbnRGYWxsYmFja1wiLCB7XG4gICAgICAgICAgICBpZFxuICAgICAgICAgIH0pKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghZm9udC5mb250RXh0cmFQcm9wZXJ0aWVzICYmIGZvbnQuZGF0YSkge1xuICAgICAgICAgICAgICBmb250LmNsZWFyRGF0YSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGZvbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ29weUxvY2FsSW1hZ2VcIjpcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpbWFnZVJlZlxuICAgICAgICAgIH0gPSBleHBvcnRlZERhdGE7XG4gICAgICAgICAgYXNzZXJ0KGltYWdlUmVmLCBcIlRoZSBpbWFnZVJlZiBtdXN0IGJlIGRlZmluZWQuXCIpO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFnZVByb3h5IG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbLCBkYXRhXSBvZiBwYWdlUHJveHkub2Jqcykge1xuICAgICAgICAgICAgICBpZiAoZGF0YT8ucmVmICE9PSBpbWFnZVJlZikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YS5kYXRhTGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIHN0cnVjdHVyZWRDbG9uZShkYXRhKSk7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLmRhdGFMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFBhdGhcIjpcbiAgICAgICAgY2FzZSBcIkltYWdlXCI6XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGV4cG9ydGVkRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5rbm93biBjb21tb24gb2JqZWN0IHR5cGUgJHt0eXBlfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJvYmpcIiwgKFtpZCwgcGFnZUluZGV4LCB0eXBlLCBpbWFnZURhdGFdKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZVByb3h5ID0gdGhpcy4jcGFnZUNhY2hlLmdldChwYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhZ2VQcm94eS5vYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBhZ2VQcm94eS5faW50ZW50U3RhdGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgaW1hZ2VEYXRhPy5iaXRtYXA/LmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICBwYWdlUHJveHkub2Jqcy5yZXNvbHZlKGlkLCBpbWFnZURhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVua25vd24gb2JqZWN0IHR5cGUgJHt0eXBlfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jUHJvZ3Jlc3NcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBkYXRhLmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGRhdGEudG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRmV0Y2hCaW5hcnlEYXRhXCIsIGFzeW5jIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzW2RhdGEudHlwZV07XG4gICAgICBpZiAoIWZhY3RvcnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2RhdGEudHlwZX0gbm90IGluaXRpYWxpemVkLCBzZWUgdGhlIFxcYHVzZVdvcmtlckZldGNoXFxgIHBhcmFtZXRlci5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWN0b3J5LmZldGNoKGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGF0YVwiLCBudWxsKTtcbiAgfVxuICBzYXZlRG9jdW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2l6ZSA8PSAwKSB7XG4gICAgICB3YXJuKFwic2F2ZURvY3VtZW50IGNhbGxlZCB3aGlsZSBgYW5ub3RhdGlvblN0b3JhZ2VgIGlzIGVtcHR5LCBcIiArIFwicGxlYXNlIHVzZSB0aGUgZ2V0RGF0YS1tZXRob2QgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2VyaWFsaXphYmxlO1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlNhdmVEb2N1bWVudFwiLCB7XG4gICAgICBpc1B1cmVYZmE6ICEhdGhpcy5faHRtbEZvclhmYSxcbiAgICAgIG51bVBhZ2VzOiB0aGlzLl9udW1QYWdlcyxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBtYXAsXG4gICAgICBmaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbFxuICAgIH0sIHRyYW5zZmVyKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihwYWdlTnVtYmVyKSB8fCBwYWdlTnVtYmVyIDw9IDAgfHwgcGFnZU51bWJlciA+IHRoaXMuX251bVBhZ2VzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBwYWdlIHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgY29uc3QgcGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDEsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jcGFnZVByb21pc2VzLmdldChwYWdlSW5kZXgpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KS50aGVuKHBhZ2VJbmZvID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BvcnQgZGVzdHJveWVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHBhZ2VJbmZvLnJlZlN0cikge1xuICAgICAgICB0aGlzLiNwYWdlUmVmQ2FjaGUuc2V0KHBhZ2VJbmZvLnJlZlN0ciwgcGFnZU51bWJlcik7XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlID0gbmV3IFBERlBhZ2VQcm94eShwYWdlSW5kZXgsIHBhZ2VJbmZvLCB0aGlzLCB0aGlzLl9wYXJhbXMucGRmQnVnKTtcbiAgICAgIHRoaXMuI3BhZ2VDYWNoZS5zZXQocGFnZUluZGV4LCBwYWdlKTtcbiAgICAgIHJldHVybiBwYWdlO1xuICAgIH0pO1xuICAgIHRoaXMuI3BhZ2VQcm9taXNlcy5zZXQocGFnZUluZGV4LCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgaWYgKCFpc1JlZlByb3h5KHJlZikpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZ2VJbmRleCByZXF1ZXN0LlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VJbmRleFwiLCB7XG4gICAgICBudW06IHJlZi5udW0sXG4gICAgICBnZW46IHJlZi5nZW5cbiAgICB9KTtcbiAgfVxuICBnZXRBbm5vdGF0aW9ucyhwYWdlSW5kZXgsIGludGVudCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEFubm90YXRpb25zXCIsIHtcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIGludGVudFxuICAgIH0pO1xuICB9XG4gIGdldEZpZWxkT2JqZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXRGaWVsZE9iamVjdHNcIik7XG4gIH1cbiAgaGFzSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkhhc0pTQWN0aW9uc1wiKTtcbiAgfVxuICBnZXRDYWxjdWxhdGlvbk9yZGVySWRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldENhbGN1bGF0aW9uT3JkZXJJZHNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERlc3RpbmF0aW9uc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgIGlmICh0eXBlb2YgaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIGRlc3RpbmF0aW9uIHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25cIiwge1xuICAgICAgaWRcbiAgICB9KTtcbiAgfVxuICBnZXRQYWdlTGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYWJlbHNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGF5b3V0XCIsIG51bGwpO1xuICB9XG4gIGdldFBhZ2VNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VNb2RlXCIsIG51bGwpO1xuICB9XG4gIGdldFZpZXdlclByZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFZpZXdlclByZWZlcmVuY2VzXCIsIG51bGwpO1xuICB9XG4gIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3BlbkFjdGlvblwiLCBudWxsKTtcbiAgfVxuICBnZXRBdHRhY2htZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRBdHRhY2htZW50c1wiLCBudWxsKTtcbiAgfVxuICBnZXRBbm5vdGF0aW9uc0J5VHlwZSh0eXBlcywgcGFnZUluZGV4ZXNUb1NraXApIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRBbm5vdGF0aW9uc0J5VHlwZVwiLCB7XG4gICAgICB0eXBlcyxcbiAgICAgIHBhZ2VJbmRleGVzVG9Ta2lwXG4gICAgfSk7XG4gIH1cbiAgZ2V0RG9jSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldERvY0pTQWN0aW9uc1wiKTtcbiAgfVxuICBnZXRQYWdlSlNBY3Rpb25zKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VKU0FjdGlvbnNcIiwge1xuICAgICAgcGFnZUluZGV4XG4gICAgfSk7XG4gIH1cbiAgZ2V0U3RydWN0VHJlZShwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRTdHJ1Y3RUcmVlXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pO1xuICB9XG4gIGdldE91dGxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3V0bGluZVwiLCBudWxsKTtcbiAgfVxuICBnZXRPcHRpb25hbENvbnRlbnRDb25maWcocmVuZGVyaW5nSW50ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiR2V0T3B0aW9uYWxDb250ZW50Q29uZmlnXCIpLnRoZW4oZGF0YSA9PiBuZXcgT3B0aW9uYWxDb250ZW50Q29uZmlnKGRhdGEsIHJlbmRlcmluZ0ludGVudCkpO1xuICB9XG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBlcm1pc3Npb25zXCIsIG51bGwpO1xuICB9XG4gIGdldE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IG5hbWUgPSBcIkdldE1ldGFkYXRhXCIsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jbWV0aG9kUHJvbWlzZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKG5hbWUsIG51bGwpLnRoZW4ocmVzdWx0cyA9PiAoe1xuICAgICAgaW5mbzogcmVzdWx0c1swXSxcbiAgICAgIG1ldGFkYXRhOiByZXN1bHRzWzFdID8gbmV3IE1ldGFkYXRhKHJlc3VsdHNbMV0pIDogbnVsbCxcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lOiB0aGlzLl9mdWxsUmVhZGVyPy5maWxlbmFtZSA/PyBudWxsLFxuICAgICAgY29udGVudExlbmd0aDogdGhpcy5fZnVsbFJlYWRlcj8uY29udGVudExlbmd0aCA/PyBudWxsXG4gICAgfSkpO1xuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLnNldChuYW1lLCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXRNYXJrSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRNYXJrSW5mb1wiLCBudWxsKTtcbiAgfVxuICBhc3luYyBzdGFydENsZWFudXAoa2VlcExvYWRlZEZvbnRzID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJDbGVhbnVwXCIsIG51bGwpO1xuICAgIGZvciAoY29uc3QgcGFnZSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGNsZWFudXBTdWNjZXNzZnVsID0gcGFnZS5jbGVhbnVwKCk7XG4gICAgICBpZiAoIWNsZWFudXBTdWNjZXNzZnVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RhcnRDbGVhbnVwOiBQYWdlICR7cGFnZS5wYWdlTnVtYmVyfSBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLmApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcbiAgICBpZiAoIWtlZXBMb2FkZWRGb250cykge1xuICAgICAgdGhpcy5mb250TG9hZGVyLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLmNsZWFyKCk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5LmRlc3Ryb3kodHJ1ZSk7XG4gICAgVGV4dExheWVyLmNsZWFudXAoKTtcbiAgfVxuICBjYWNoZWRQYWdlTnVtYmVyKHJlZikge1xuICAgIGlmICghaXNSZWZQcm94eShyZWYpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVmU3RyID0gcmVmLmdlbiA9PT0gMCA/IGAke3JlZi5udW19UmAgOiBgJHtyZWYubnVtfVIke3JlZi5nZW59YDtcbiAgICByZXR1cm4gdGhpcy4jcGFnZVJlZkNhY2hlLmdldChyZWZTdHIpID8/IG51bGw7XG4gIH1cbn1cbmNsYXNzIFJlbmRlclRhc2sge1xuICAjaW50ZXJuYWxSZW5kZXJUYXNrID0gbnVsbDtcbiAgb25Db250aW51ZSA9IG51bGw7XG4gIG9uRXJyb3IgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihpbnRlcm5hbFJlbmRlclRhc2spIHtcbiAgICB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2s7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbChudWxsLCBleHRyYURlbGF5KTtcbiAgfVxuICBnZXQgc2VwYXJhdGVBbm5vdHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2VwYXJhdGVBbm5vdHNcbiAgICB9ID0gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdDtcbiAgICBpZiAoIXNlcGFyYXRlQW5ub3RzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25DYW52YXNNYXBcbiAgICB9ID0gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrO1xuICAgIHJldHVybiBzZXBhcmF0ZUFubm90cy5mb3JtIHx8IHNlcGFyYXRlQW5ub3RzLmNhbnZhcyAmJiBhbm5vdGF0aW9uQ2FudmFzTWFwPy5zaXplID4gMDtcbiAgfVxufVxuY2xhc3MgSW50ZXJuYWxSZW5kZXJUYXNrIHtcbiAgI3JBRiA9IG51bGw7XG4gIHN0YXRpYyAjY2FudmFzSW5Vc2UgPSBuZXcgV2Vha1NldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2FsbGJhY2ssXG4gICAgcGFyYW1zLFxuICAgIG9ianMsXG4gICAgY29tbW9uT2JqcyxcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgIG9wZXJhdG9yTGlzdCxcbiAgICBwYWdlSW5kZXgsXG4gICAgY2FudmFzRmFjdG9yeSxcbiAgICBmaWx0ZXJGYWN0b3J5LFxuICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZhbHNlLFxuICAgIHBkZkJ1ZyA9IGZhbHNlLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsLFxuICAgIGVuYWJsZUhXQSA9IGZhbHNlLFxuICAgIG9wZXJhdGlvbnNGaWx0ZXIgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSBudWxsO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gb3BlcmF0b3JMaXN0O1xuICAgIHRoaXMuX3BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5fcGRmQnVnID0gcGRmQnVnO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdHJ1ZSAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy50YXNrID0gbmV3IFJlbmRlclRhc2sodGhpcyk7XG4gICAgdGhpcy5fY2FuY2VsQm91bmQgPSB0aGlzLmNhbmNlbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NvbnRpbnVlQm91bmQgPSB0aGlzLl9jb250aW51ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kID0gdGhpcy5fc2NoZWR1bGVOZXh0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fbmV4dEJvdW5kID0gdGhpcy5fbmV4dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NhbnZhcyA9IHBhcmFtcy5jYW52YXM7XG4gICAgdGhpcy5fY2FudmFzQ29udGV4dCA9IHBhcmFtcy5jYW52YXMgPyBudWxsIDogcGFyYW1zLmNhbnZhc0NvbnRleHQ7XG4gICAgdGhpcy5fZW5hYmxlSFdBID0gZW5hYmxlSFdBO1xuICAgIHRoaXMuX2RlcGVuZGVuY3lUcmFja2VyID0gcGFyYW1zLmRlcGVuZGVuY3lUcmFja2VyO1xuICAgIHRoaXMuX29wZXJhdGlvbnNGaWx0ZXIgPSBvcGVyYXRpb25zRmlsdGVyO1xuICB9XG4gIGdldCBjb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FwYWJpbGl0eS5wcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgfVxuICBpbml0aWFsaXplR3JhcGhpY3Moe1xuICAgIHRyYW5zcGFyZW5jeSA9IGZhbHNlLFxuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICB9KSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgIGlmIChJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmhhcyh0aGlzLl9jYW52YXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgdGhlIHNhbWUgY2FudmFzIGR1cmluZyBtdWx0aXBsZSByZW5kZXIoKSBvcGVyYXRpb25zLiBcIiArIFwiVXNlIGRpZmZlcmVudCBjYW52YXMgb3IgZW5zdXJlIHByZXZpb3VzIG9wZXJhdGlvbnMgd2VyZSBcIiArIFwiY2FuY2VsbGVkIG9yIGNvbXBsZXRlZC5cIik7XG4gICAgICB9XG4gICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmFkZCh0aGlzLl9jYW52YXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGRmQnVnICYmIGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXI/LmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuc3RlcHBlciA9IGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXIuY3JlYXRlKHRoaXMuX3BhZ2VJbmRleCk7XG4gICAgICB0aGlzLnN0ZXBwZXIuaW5pdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgICB0aGlzLnN0ZXBwZXIubmV4dEJyZWFrUG9pbnQgPSB0aGlzLnN0ZXBwZXIuZ2V0TmV4dEJyZWFrUG9pbnQoKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBiYWNrZ3JvdW5kLFxuICAgICAgZGVwZW5kZW5jeVRyYWNrZXJcbiAgICB9ID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY2FudmFzQ29udGV4dCA9IHRoaXMuX2NhbnZhc0NvbnRleHQgfHwgdGhpcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogZmFsc2UsXG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICF0aGlzLl9lbmFibGVIV0FcbiAgICB9KTtcbiAgICB0aGlzLmdmeCA9IG5ldyBDYW52YXNHcmFwaGljcyhjYW52YXNDb250ZXh0LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgIH0sIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCwgdGhpcy5wYWdlQ29sb3JzLCBkZXBlbmRlbmN5VHJhY2tlcik7XG4gICAgdGhpcy5nZnguYmVnaW5EcmF3aW5nKHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgYmFja2dyb3VuZFxuICAgIH0pO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gMDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrPy4oKTtcbiAgfVxuICBjYW5jZWwoZXJyb3IgPSBudWxsLCBleHRyYURlbGF5ID0gMCkge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLmdmeD8uZW5kRHJhd2luZygpO1xuICAgIGlmICh0aGlzLiNyQUYpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLiNyQUYpO1xuICAgICAgdGhpcy4jckFGID0gbnVsbDtcbiAgICB9XG4gICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5kZWxldGUodGhpcy5fY2FudmFzKTtcbiAgICBlcnJvciB8fD0gbmV3IFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbihgUmVuZGVyaW5nIGNhbmNlbGxlZCwgcGFnZSAke3RoaXMuX3BhZ2VJbmRleCArIDF9YCwgZXh0cmFEZWxheSk7XG4gICAgdGhpcy5jYWxsYmFjayhlcnJvcik7XG4gICAgdGhpcy50YXNrLm9uRXJyb3I/LihlcnJvcik7XG4gIH1cbiAgb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICBpZiAoIXRoaXMuZ3JhcGhpY3NSZWFkeSkge1xuICAgICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgfHw9IHRoaXMuX2NvbnRpbnVlQm91bmQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ2Z4LmRlcGVuZGVuY3lUcmFja2VyPy5ncm93T3BlcmF0aW9uc0NvdW50KHRoaXMub3BlcmF0b3JMaXN0LmZuQXJyYXkubGVuZ3RoKTtcbiAgICB0aGlzLnN0ZXBwZXI/LnVwZGF0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jb250aW51ZSgpO1xuICB9XG4gIF9jb250aW51ZSgpIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50YXNrLm9uQ29udGludWUpIHtcbiAgICAgIHRoaXMudGFzay5vbkNvbnRpbnVlKHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2NoZWR1bGVOZXh0KCk7XG4gICAgfVxuICB9XG4gIF9zY2hlZHVsZU5leHQoKSB7XG4gICAgaWYgKHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgdGhpcy4jckFGID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuI3JBRiA9IG51bGw7XG4gICAgICAgIHRoaXMuX25leHRCb3VuZCgpLmNhdGNoKHRoaXMuX2NhbmNlbEJvdW5kKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKHRoaXMuX25leHRCb3VuZCkuY2F0Y2godGhpcy5fY2FuY2VsQm91bmQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBfbmV4dCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSB0aGlzLmdmeC5leGVjdXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0LCB0aGlzLm9wZXJhdG9yTGlzdElkeCwgdGhpcy5fY29udGludWVCb3VuZCwgdGhpcy5zdGVwcGVyLCB0aGlzLl9vcGVyYXRpb25zRmlsdGVyKTtcbiAgICBpZiAodGhpcy5vcGVyYXRvckxpc3RJZHggPT09IHRoaXMub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICB0aGlzLmdmeC5lbmREcmF3aW5nKCk7XG4gICAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuZGVsZXRlKHRoaXMuX2NhbnZhcyk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHZlcnNpb24gPSBcIjUuNC4yOTZcIjtcbmNvbnN0IGJ1aWxkID0gXCJmNTZkYzg2MDFcIjtcblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2NvbG9yX3BpY2tlci5qc1xuXG5cblxuY2xhc3MgQ29sb3JQaWNrZXIge1xuICAjYnV0dG9uID0gbnVsbDtcbiAgI2J1dHRvblN3YXRjaCA9IG51bGw7XG4gICNkZWZhdWx0Q29sb3I7XG4gICNkcm9wZG93biA9IG51bGw7XG4gICNkcm9wZG93bldhc0Zyb21LZXlib2FyZCA9IGZhbHNlO1xuICAjaXNNYWluQ29sb3JQaWNrZXIgPSBmYWxzZTtcbiAgI2VkaXRvciA9IG51bGw7XG4gICNldmVudEJ1cztcbiAgI29wZW5Ecm9wZG93bkFDID0gbnVsbDtcbiAgI3VpTWFuYWdlciA9IG51bGw7XG4gIHN0YXRpYyAjbDEwbkNvbG9yID0gbnVsbDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZF0sIFtbXCIgXCIsIFwibWFjKyBcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fY29sb3JTZWxlY3RGcm9tS2V5Ym9hcmRdLCBbW1wiQXJyb3dEb3duXCIsIFwiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9OZXh0XSwgW1tcIkFycm93VXBcIiwgXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dVcFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fbW92ZVRvUHJldmlvdXNdLCBbW1wiSG9tZVwiLCBcIm1hYytIb21lXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb0JlZ2lubmluZ10sIFtbXCJFbmRcIiwgXCJtYWMrRW5kXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb0VuZF1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3Ioe1xuICAgIGVkaXRvciA9IG51bGwsXG4gICAgdWlNYW5hZ2VyID0gbnVsbFxuICB9KSB7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy4jaXNNYWluQ29sb3JQaWNrZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaXNNYWluQ29sb3JQaWNrZXIgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIgPSBlZGl0b3I/Ll91aU1hbmFnZXIgfHwgdWlNYW5hZ2VyO1xuICAgIHRoaXMuI2V2ZW50QnVzID0gdGhpcy4jdWlNYW5hZ2VyLl9ldmVudEJ1cztcbiAgICB0aGlzLiNkZWZhdWx0Q29sb3IgPSBlZGl0b3I/LmNvbG9yPy50b1VwcGVyQ2FzZSgpIHx8IHRoaXMuI3VpTWFuYWdlcj8uaGlnaGxpZ2h0Q29sb3JzLnZhbHVlcygpLm5leHQoKS52YWx1ZSB8fCBcIiNGRkZGOThcIjtcbiAgICBDb2xvclBpY2tlci4jbDEwbkNvbG9yIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIGJsdWU6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWJsdWVcIixcbiAgICAgIGdyZWVuOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1ncmVlblwiLFxuICAgICAgcGluazogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItcGlua1wiLFxuICAgICAgcmVkOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1yZWRcIixcbiAgICAgIHllbGxvdzogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXIteWVsbG93XCJcbiAgICB9KTtcbiAgfVxuICByZW5kZXJCdXR0b24oKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NOYW1lID0gXCJjb2xvclBpY2tlclwiO1xuICAgIGJ1dHRvbi50YWJJbmRleCA9IFwiMFwiO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5hcmlhSGFzUG9wdXAgPSBcInRydWVcIjtcbiAgICBpZiAodGhpcy4jZWRpdG9yKSB7XG4gICAgICBidXR0b24uYXJpYUNvbnRyb2xzID0gYCR7dGhpcy4jZWRpdG9yLmlkfV9jb2xvcnBpY2tlcl9kcm9wZG93bmA7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jb3BlbkRyb3Bkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHN3YXRjaCA9IHRoaXMuI2J1dHRvblN3YXRjaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHN3YXRjaC5jbGFzc05hbWUgPSBcInN3YXRjaFwiO1xuICAgIHN3YXRjaC5hcmlhSGlkZGVuID0gXCJ0cnVlXCI7XG4gICAgc3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuI2RlZmF1bHRDb2xvcjtcbiAgICBidXR0b24uYXBwZW5kKHN3YXRjaCk7XG4gICAgcmV0dXJuIGJ1dHRvbjtcbiAgfVxuICByZW5kZXJNYWluRHJvcGRvd24oKSB7XG4gICAgY29uc3QgZHJvcGRvd24gPSB0aGlzLiNkcm9wZG93biA9IHRoaXMuI2dldERyb3Bkb3duUm9vdCgpO1xuICAgIGRyb3Bkb3duLmFyaWFPcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiO1xuICAgIGRyb3Bkb3duLmFyaWFMYWJlbGxlZEJ5ID0gXCJoaWdobGlnaHRDb2xvclBpY2tlckxhYmVsXCI7XG4gICAgcmV0dXJuIGRyb3Bkb3duO1xuICB9XG4gICNnZXREcm9wZG93blJvb3QoKSB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRpdi5jbGFzc05hbWUgPSBcImRyb3Bkb3duXCI7XG4gICAgZGl2LnJvbGUgPSBcImxpc3Rib3hcIjtcbiAgICBkaXYuYXJpYU11bHRpU2VsZWN0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICBkaXYuYXJpYU9yaWVudGF0aW9uID0gXCJ2ZXJ0aWNhbFwiO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItZHJvcGRvd25cIik7XG4gICAgaWYgKHRoaXMuI2VkaXRvcikge1xuICAgICAgZGl2LmlkID0gYCR7dGhpcy4jZWRpdG9yLmlkfV9jb2xvcnBpY2tlcl9kcm9wZG93bmA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUsIGNvbG9yXSBvZiB0aGlzLiN1aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzKSB7XG4gICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgYnV0dG9uLnRhYkluZGV4ID0gXCIwXCI7XG4gICAgICBidXR0b24ucm9sZSA9IFwib3B0aW9uXCI7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiLCBjb2xvcik7XG4gICAgICBidXR0b24udGl0bGUgPSBuYW1lO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBDb2xvclBpY2tlci4jbDEwbkNvbG9yW25hbWVdKTtcbiAgICAgIGNvbnN0IHN3YXRjaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgYnV0dG9uLmFwcGVuZChzd2F0Y2gpO1xuICAgICAgc3dhdGNoLmNsYXNzTmFtZSA9IFwic3dhdGNoXCI7XG4gICAgICBzd2F0Y2guc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgICBidXR0b24uYXJpYVNlbGVjdGVkID0gY29sb3IgPT09IHRoaXMuI2RlZmF1bHRDb2xvcjtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jY29sb3JTZWxlY3QuYmluZCh0aGlzLCBjb2xvciksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGRpdi5hcHBlbmQoYnV0dG9uKTtcbiAgICB9XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2tleURvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICAjY29sb3JTZWxlY3QoY29sb3IsIGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy4jZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ycGFyYW1zXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUixcbiAgICAgIHZhbHVlOiBjb2xvclxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlQ29sb3IoY29sb3IpO1xuICB9XG4gIF9jb2xvclNlbGVjdEZyb21LZXlib2FyZChldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29sb3IgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKTtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbG9yU2VsZWN0KGNvbG9yLCBldmVudCk7XG4gIH1cbiAgX21vdmVUb05leHQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIHRoaXMuI2Ryb3Bkb3duLmZpcnN0Q2hpbGQ/LmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnRhcmdldC5uZXh0U2libGluZz8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvUHJldmlvdXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNkcm9wZG93bj8uZmlyc3RDaGlsZCB8fCBldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgaWYgKHRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgIH1cbiAgICBldmVudC50YXJnZXQucHJldmlvdXNTaWJsaW5nPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9CZWdpbm5pbmcoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bi5maXJzdENoaWxkPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9FbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bi5sYXN0Q2hpbGQ/LmZvY3VzKCk7XG4gIH1cbiAgI2tleURvd24oZXZlbnQpIHtcbiAgICBDb2xvclBpY2tlci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gICNvcGVuRHJvcGRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHRoaXMuaGlkZURyb3Bkb3duKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2Ryb3Bkb3duV2FzRnJvbUtleWJvYXJkID0gZXZlbnQuZGV0YWlsID09PSAwO1xuICAgIGlmICghdGhpcy4jb3BlbkRyb3Bkb3duQUMpIHtcbiAgICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNwb2ludGVyRG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI29wZW5Ecm9wZG93bkFDKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuI2J1dHRvbi5hcmlhRXhwYW5kZWQgPSBcInRydWVcIjtcbiAgICBpZiAodGhpcy4jZHJvcGRvd24pIHtcbiAgICAgIHRoaXMuI2Ryb3Bkb3duLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvb3QgPSB0aGlzLiNkcm9wZG93biA9IHRoaXMuI2dldERyb3Bkb3duUm9vdCgpO1xuICAgIHRoaXMuI2J1dHRvbi5hcHBlbmQocm9vdCk7XG4gIH1cbiAgI3BvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI2Ryb3Bkb3duPy5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaGlkZURyb3Bkb3duKCk7XG4gIH1cbiAgaGlkZURyb3Bkb3duKCkge1xuICAgIHRoaXMuI2Ryb3Bkb3duPy5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuI2J1dHRvbi5hcmlhRXhwYW5kZWQgPSBcImZhbHNlXCI7XG4gICAgdGhpcy4jb3BlbkRyb3Bkb3duQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jb3BlbkRyb3Bkb3duQUMgPSBudWxsO1xuICB9XG4gIGdldCAjaXNEcm9wZG93blZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Ryb3Bkb3duICYmICF0aGlzLiNkcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRkZW5cIik7XG4gIH1cbiAgX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCgpIHtcbiAgICBpZiAodGhpcy4jaXNNYWluQ29sb3JQaWNrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jZWRpdG9yPy51bnNlbGVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgIHRoaXMuI2J1dHRvbi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgZm9jdXNWaXNpYmxlOiB0aGlzLiNkcm9wZG93bldhc0Zyb21LZXlib2FyZFxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKHRoaXMuI2J1dHRvblN3YXRjaCkge1xuICAgICAgdGhpcy4jYnV0dG9uU3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2Ryb3Bkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0aGlzLiN1aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzLnZhbHVlcygpO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy4jZHJvcGRvd24uY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkLmFyaWFTZWxlY3RlZCA9IGkubmV4dCgpLnZhbHVlID09PSBjb2xvci50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2J1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jYnV0dG9uID0gbnVsbDtcbiAgICB0aGlzLiNidXR0b25Td2F0Y2ggPSBudWxsO1xuICAgIHRoaXMuI2Ryb3Bkb3duPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNkcm9wZG93biA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIEJhc2ljQ29sb3JQaWNrZXIge1xuICAjaW5wdXQgPSBudWxsO1xuICAjZWRpdG9yID0gbnVsbDtcbiAgI3VpTWFuYWdlciA9IG51bGw7XG4gIHN0YXRpYyAjbDEwbkNvbG9yID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuI3VpTWFuYWdlciA9IGVkaXRvci5fdWlNYW5hZ2VyO1xuICAgIEJhc2ljQ29sb3JQaWNrZXIuI2wxMG5Db2xvciB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBmcmVldGV4dDogXCJwZGZqcy1lZGl0b3ItY29sb3ItcGlja2VyLWZyZWUtdGV4dC1pbnB1dFwiLFxuICAgICAgaW5rOiBcInBkZmpzLWVkaXRvci1jb2xvci1waWNrZXItaW5rLWlucHV0XCJcbiAgICB9KTtcbiAgfVxuICByZW5kZXJCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuI2lucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy4jaW5wdXQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGVkaXRvclR5cGUsXG4gICAgICBjb2xvclR5cGUsXG4gICAgICBjb2xvclZhbHVlXG4gICAgfSA9IHRoaXMuI2VkaXRvcjtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuI2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImNvbG9yXCI7XG4gICAgaW5wdXQudmFsdWUgPSBjb2xvclZhbHVlIHx8IFwiIzAwMDAwMFwiO1xuICAgIGlucHV0LmNsYXNzTmFtZSA9IFwiYmFzaWNDb2xvclBpY2tlclwiO1xuICAgIGlucHV0LnRhYkluZGV4ID0gMDtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQmFzaWNDb2xvclBpY2tlci4jbDEwbkNvbG9yW2VkaXRvclR5cGVdKTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZVBhcmFtcyhjb2xvclR5cGUsIGlucHV0LnZhbHVlKTtcbiAgICB9LCB7XG4gICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jaW5wdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2lucHV0Py5yZW1vdmUoKTtcbiAgICB0aGlzLiNpbnB1dCA9IG51bGw7XG4gIH1cbiAgaGlkZURyb3Bkb3duKCkge31cbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IuZmluZC5qc1xudmFyIGVzX2l0ZXJhdG9yX2ZpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5pdGVyYXRvci5mbGF0LW1hcC5qc1xudmFyIGVzX2l0ZXJhdG9yX2ZsYXRfbWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MzEpO1xuOy8vIC4vc3JjL3NoYXJlZC9zY3JpcHRpbmdfdXRpbHMuanNcblxuXG5mdW5jdGlvbiBtYWtlQ29sb3JDb21wKG4pIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgbikpICogMjU1KS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xufVxuZnVuY3Rpb24gc2NhbGVBbmRDbGFtcCh4KSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIDI1NSAqIHgpKTtcbn1cbmNsYXNzIENvbG9yQ29udmVydGVycyB7XG4gIHN0YXRpYyBDTVlLX0coW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtcIkdcIiwgMSAtIE1hdGgubWluKDEsIDAuMyAqIGMgKyAwLjU5ICogbSArIDAuMTEgKiB5ICsgayldO1xuICB9XG4gIHN0YXRpYyBHX0NNWUsoW2ddKSB7XG4gICAgcmV0dXJuIFtcIkNNWUtcIiwgMCwgMCwgMCwgMSAtIGddO1xuICB9XG4gIHN0YXRpYyBHX1JHQihbZ10pIHtcbiAgICByZXR1cm4gW1wiUkdCXCIsIGcsIGcsIGddO1xuICB9XG4gIHN0YXRpYyBHX3JnYihbZ10pIHtcbiAgICBnID0gc2NhbGVBbmRDbGFtcChnKTtcbiAgICByZXR1cm4gW2csIGcsIGddO1xuICB9XG4gIHN0YXRpYyBHX0hUTUwoW2ddKSB7XG4gICAgY29uc3QgRyA9IG1ha2VDb2xvckNvbXAoZyk7XG4gICAgcmV0dXJuIGAjJHtHfSR7R30ke0d9YDtcbiAgfVxuICBzdGF0aWMgUkdCX0coW3IsIGcsIGJdKSB7XG4gICAgcmV0dXJuIFtcIkdcIiwgMC4zICogciArIDAuNTkgKiBnICsgMC4xMSAqIGJdO1xuICB9XG4gIHN0YXRpYyBSR0JfcmdiKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yLm1hcChzY2FsZUFuZENsYW1wKTtcbiAgfVxuICBzdGF0aWMgUkdCX0hUTUwoY29sb3IpIHtcbiAgICByZXR1cm4gYCMke2NvbG9yLm1hcChtYWtlQ29sb3JDb21wKS5qb2luKFwiXCIpfWA7XG4gIH1cbiAgc3RhdGljIFRfSFRNTCgpIHtcbiAgICByZXR1cm4gXCIjMDAwMDAwMDBcIjtcbiAgfVxuICBzdGF0aWMgVF9yZ2IoKSB7XG4gICAgcmV0dXJuIFtudWxsXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19SR0IoW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtcIlJHQlwiLCAxIC0gTWF0aC5taW4oMSwgYyArIGspLCAxIC0gTWF0aC5taW4oMSwgbSArIGspLCAxIC0gTWF0aC5taW4oMSwgeSArIGspXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19yZ2IoW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCBjICsgaykpLCBzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCBtICsgaykpLCBzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCB5ICsgaykpXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19IVE1MKGNvbXBvbmVudHMpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLkNNWUtfUkdCKGNvbXBvbmVudHMpLnNsaWNlKDEpO1xuICAgIHJldHVybiB0aGlzLlJHQl9IVE1MKHJnYik7XG4gIH1cbiAgc3RhdGljIFJHQl9DTVlLKFtyLCBnLCBiXSkge1xuICAgIGNvbnN0IGMgPSAxIC0gcjtcbiAgICBjb25zdCBtID0gMSAtIGc7XG4gICAgY29uc3QgeSA9IDEgLSBiO1xuICAgIGNvbnN0IGsgPSBNYXRoLm1pbihjLCBtLCB5KTtcbiAgICByZXR1cm4gW1wiQ01ZS1wiLCBjLCBtLCB5LCBrXTtcbiAgfVxufVxuY29uc3QgRGF0ZUZvcm1hdHMgPSAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChbXCJtL2RcIiwgXCJtL2QveXlcIiwgXCJtbS9kZC95eVwiLCBcIm1tL3l5XCIsIFwiZC1tbW1cIiwgXCJkLW1tbS15eVwiLCBcImRkLW1tbS15eVwiLCBcInl5LW1tLWRkXCIsIFwibW1tLXl5XCIsIFwibW1tbS15eVwiLCBcIm1tbSBkLCB5eXl5XCIsIFwibW1tbSBkLCB5eXl5XCIsIFwibS9kL3l5IGg6TU0gdHRcIiwgXCJtL2QveXkgSEg6TU1cIl0pKTtcbmNvbnN0IFRpbWVGb3JtYXRzID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoW1wiSEg6TU1cIiwgXCJoOk1NIHR0XCIsIFwiSEg6TU06c3NcIiwgXCJoOk1NOnNzIHR0XCJdKSk7XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3N2Z19mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZVNWR0ZhY3Rvcnkge1xuICBjcmVhdGUod2lkdGgsIGhlaWdodCwgc2tpcERpbWVuc2lvbnMgPSBmYWxzZSkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBkaW1lbnNpb25zXCIpO1xuICAgIH1cbiAgICBjb25zdCBzdmcgPSB0aGlzLl9jcmVhdGVTVkcoXCJzdmc6c3ZnXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIsIFwiMS4xXCIpO1xuICAgIGlmICghc2tpcERpbWVuc2lvbnMpIHtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBgJHt3aWR0aH1weGApO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBgJHtoZWlnaHR9cHhgKTtcbiAgICB9XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJub25lXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCk7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuICBjcmVhdGVFbGVtZW50KHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgU1ZHIGVsZW1lbnQgdHlwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVNWRyh0eXBlKTtcbiAgfVxuICBfY3JlYXRlU1ZHKHR5cGUpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2NyZWF0ZVNWR2AgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgRE9NU1ZHRmFjdG9yeSBleHRlbmRzIEJhc2VTVkdGYWN0b3J5IHtcbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIHR5cGUpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2Fubm90YXRpb25fbGF5ZXIuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBhbm5vdGF0aW9uX2xheWVyX0RFRkFVTFRfRk9OVF9TSVpFID0gOTtcbmNvbnN0IEdldEVsZW1lbnRzQnlOYW1lU2V0ID0gbmV3IFdlYWtTZXQoKTtcbmNvbnN0IFRJTUVaT05FX09GRlNFVCA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwICogMTAwMDtcbmNsYXNzIEFubm90YXRpb25FbGVtZW50RmFjdG9yeSB7XG4gIHN0YXRpYyBjcmVhdGUocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN1YnR5cGUgPSBwYXJhbWV0ZXJzLmRhdGEuYW5ub3RhdGlvblR5cGU7XG4gICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkxJTks6XG4gICAgICAgIHJldHVybiBuZXcgTGlua0Fubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5URVhUOlxuICAgICAgICByZXR1cm4gbmV3IFRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuV0lER0VUOlxuICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSBwYXJhbWV0ZXJzLmRhdGEuZmllbGRUeXBlO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJUeFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIkJ0blwiOlxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMuZGF0YS5yYWRpb0J1dHRvbikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMuZGF0YS5jaGVja0JveCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiQ2hcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIlNpZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5QT1BVUDpcbiAgICAgICAgcmV0dXJuIG5ldyBQb3B1cEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5GUkVFVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5MSU5FOlxuICAgICAgICByZXR1cm4gbmV3IExpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1FVQVJFOlxuICAgICAgICByZXR1cm4gbmV3IFNxdWFyZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5DSVJDTEU6XG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlBPTFlMSU5FOlxuICAgICAgICByZXR1cm4gbmV3IFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkNBUkVUOlxuICAgICAgICByZXR1cm4gbmV3IENhcmV0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLklOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBJbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuUE9MWUdPTjpcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkhJR0hMSUdIVDpcbiAgICAgICAgcmV0dXJuIG5ldyBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuVU5ERVJMSU5FOlxuICAgICAgICByZXR1cm4gbmV3IFVuZGVybGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5TUVVJR0dMWTpcbiAgICAgICAgcmV0dXJuIG5ldyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5TVFJJS0VPVVQ6XG4gICAgICAgIHJldHVybiBuZXcgU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNUQU1QOlxuICAgICAgICByZXR1cm4gbmV3IFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkZJTEVBVFRBQ0hNRU5UOlxuICAgICAgICByZXR1cm4gbmV3IEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjdXBkYXRlcyA9IG51bGw7XG4gICNoYXNCb3JkZXIgPSBmYWxzZTtcbiAgI3BvcHVwRWxlbWVudCA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIHtcbiAgICBpc1JlbmRlcmFibGUgPSBmYWxzZSxcbiAgICBpZ25vcmVCb3JkZXIgPSBmYWxzZSxcbiAgICBjcmVhdGVRdWFkcmlsYXRlcmFscyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuaXNSZW5kZXJhYmxlID0gaXNSZW5kZXJhYmxlO1xuICAgIHRoaXMuZGF0YSA9IHBhcmFtZXRlcnMuZGF0YTtcbiAgICB0aGlzLmxheWVyID0gcGFyYW1ldGVycy5sYXllcjtcbiAgICB0aGlzLmxpbmtTZXJ2aWNlID0gcGFyYW1ldGVycy5saW5rU2VydmljZTtcbiAgICB0aGlzLmRvd25sb2FkTWFuYWdlciA9IHBhcmFtZXRlcnMuZG93bmxvYWRNYW5hZ2VyO1xuICAgIHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoID0gcGFyYW1ldGVycy5pbWFnZVJlc291cmNlc1BhdGg7XG4gICAgdGhpcy5yZW5kZXJGb3JtcyA9IHBhcmFtZXRlcnMucmVuZGVyRm9ybXM7XG4gICAgdGhpcy5zdmdGYWN0b3J5ID0gcGFyYW1ldGVycy5zdmdGYWN0b3J5O1xuICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIHRoaXMuZW5hYmxlQ29tbWVudCA9IHBhcmFtZXRlcnMuZW5hYmxlQ29tbWVudDtcbiAgICB0aGlzLmVuYWJsZVNjcmlwdGluZyA9IHBhcmFtZXRlcnMuZW5hYmxlU2NyaXB0aW5nO1xuICAgIHRoaXMuaGFzSlNBY3Rpb25zID0gcGFyYW1ldGVycy5oYXNKU0FjdGlvbnM7XG4gICAgdGhpcy5fZmllbGRPYmplY3RzID0gcGFyYW1ldGVycy5maWVsZE9iamVjdHM7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJhbWV0ZXJzLnBhcmVudDtcbiAgICBpZiAoaXNSZW5kZXJhYmxlKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlUXVhZHJpbGF0ZXJhbHMpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfaGFzUG9wdXBEYXRhKHtcbiAgICBjb250ZW50c09iaixcbiAgICByaWNoVGV4dFxuICB9KSB7XG4gICAgcmV0dXJuICEhKGNvbnRlbnRzT2JqPy5zdHIgfHwgcmljaFRleHQ/LnN0cik7XG4gIH1cbiAgZ2V0IF9pc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuaXNFZGl0YWJsZTtcbiAgfVxuICBnZXQgaGFzUG9wdXBEYXRhKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWxlbWVudC5faGFzUG9wdXBEYXRhKHRoaXMuZGF0YSkgfHwgdGhpcy5lbmFibGVDb21tZW50ICYmICEhdGhpcy5jb21tZW50VGV4dDtcbiAgfVxuICBnZXQgY29tbWVudERhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U/LmdldEVkaXRvcihkYXRhLmlkKTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICByZXR1cm4gZWRpdG9yLmdldERhdGEoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZ2V0IGhhc0NvbW1lbnRCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlQ29tbWVudCAmJiB0aGlzLmhhc1BvcHVwRWxlbWVudDtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U/LmdldEVkaXRvcih0aGlzLmRhdGEuaWQpO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHJldHVybiBlZGl0b3IuY29tbWVudEJ1dHRvblBvc2l0aW9uSW5QYWdlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBxdWFkUG9pbnRzLFxuICAgICAgaW5rTGlzdHMsXG4gICAgICByZWN0XG4gICAgfSA9IHRoaXMuZGF0YTtcbiAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcbiAgICBpZiAocXVhZFBvaW50cz8ubGVuZ3RoID49IDgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZFBvaW50cy5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICBpZiAocXVhZFBvaW50c1tpICsgMV0gPiBtYXhZKSB7XG4gICAgICAgICAgbWF4WSA9IHF1YWRQb2ludHNbaSArIDFdO1xuICAgICAgICAgIG1heFggPSBxdWFkUG9pbnRzW2kgKyAyXTtcbiAgICAgICAgfSBlbHNlIGlmIChxdWFkUG9pbnRzW2kgKyAxXSA9PT0gbWF4WSkge1xuICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBxdWFkUG9pbnRzW2kgKyAyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbbWF4WCwgbWF4WV07XG4gICAgfVxuICAgIGlmIChpbmtMaXN0cz8ubGVuZ3RoID49IDEpIHtcbiAgICAgIGZvciAoY29uc3QgaW5rTGlzdCBvZiBpbmtMaXN0cykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbmtMaXN0Lmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoaW5rTGlzdFtpICsgMV0gPiBtYXhZKSB7XG4gICAgICAgICAgICBtYXhZID0gaW5rTGlzdFtpICsgMV07XG4gICAgICAgICAgICBtYXhYID0gaW5rTGlzdFtpXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlua0xpc3RbaSArIDFdID09PSBtYXhZKSB7XG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgaW5rTGlzdFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWF4WCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIFttYXhYLCBtYXhZXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIHJldHVybiBbcmVjdFsyXSwgcmVjdFszXV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9ub3JtYWxpemVQb2ludChwb2ludCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgdmlld1xuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICBwYWdlWVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXMucGFyZW50O1xuICAgIHBvaW50WzFdID0gdmlld1szXSAtIHBvaW50WzFdICsgdmlld1sxXTtcbiAgICBwb2ludFswXSA9IDEwMCAqIChwb2ludFswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICBwb2ludFsxXSA9IDEwMCAqIChwb2ludFsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG4gIGdldCBjb21tZW50VGV4dCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUoYCR7QW5ub3RhdGlvbkVkaXRvclByZWZpeH0ke2RhdGEuaWR9YCk/LnBvcHVwPy5jb250ZW50cyB8fCBkYXRhLmNvbnRlbnRzT2JqPy5zdHIgfHwgXCJcIjtcbiAgfVxuICBzZXQgY29tbWVudFRleHQodGV4dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBwb3B1cCA9IHtcbiAgICAgIGRlbGV0ZWQ6ICF0ZXh0LFxuICAgICAgY29udGVudHM6IHRleHQgfHwgXCJcIlxuICAgIH07XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25TdG9yYWdlLnVwZGF0ZUVkaXRvcihkYXRhLmlkLCB7XG4gICAgICBwb3B1cFxuICAgIH0pKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKGAke0Fubm90YXRpb25FZGl0b3JQcmVmaXh9JHtkYXRhLmlkfWAsIHtcbiAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgIGFubm90YXRpb25UeXBlOiBkYXRhLmFubm90YXRpb25UeXBlLFxuICAgICAgICBwYWdlSW5kZXg6IHRoaXMucGFyZW50LnBhZ2UuX3BhZ2VJbmRleCxcbiAgICAgICAgcG9wdXAsXG4gICAgICAgIHBvcHVwUmVmOiBkYXRhLnBvcHVwUmVmLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlOiBuZXcgRGF0ZSgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICB0aGlzLnJlbW92ZVBvcHVwKCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZVBvcHVwKCkge1xuICAgICh0aGlzLiNwb3B1cEVsZW1lbnQ/LnBvcHVwIHx8IHRoaXMucG9wdXApPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNwb3B1cEVsZW1lbnQgPSB0aGlzLnBvcHVwID0gbnVsbDtcbiAgfVxuICB1cGRhdGVFZGl0ZWQocGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnJlY3QpIHtcbiAgICAgIHRoaXMuI3VwZGF0ZXMgfHw9IHtcbiAgICAgICAgcmVjdDogdGhpcy5kYXRhLnJlY3Quc2xpY2UoMClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHJlY3QsXG4gICAgICBwb3B1cDogbmV3UG9wdXBcbiAgICB9ID0gcGFyYW1zO1xuICAgIGlmIChyZWN0KSB7XG4gICAgICB0aGlzLiNzZXRSZWN0RWRpdGVkKHJlY3QpO1xuICAgIH1cbiAgICBsZXQgcG9wdXAgPSB0aGlzLiNwb3B1cEVsZW1lbnQ/LnBvcHVwIHx8IHRoaXMucG9wdXA7XG4gICAgaWYgKCFwb3B1cCAmJiBuZXdQb3B1cD8udGV4dCkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAobmV3UG9wdXApO1xuICAgICAgcG9wdXAgPSB0aGlzLiNwb3B1cEVsZW1lbnQucG9wdXA7XG4gICAgfVxuICAgIGlmICghcG9wdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcG9wdXAudXBkYXRlRWRpdGVkKHBhcmFtcyk7XG4gICAgaWYgKG5ld1BvcHVwPy5kZWxldGVkKSB7XG4gICAgICBwb3B1cC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI3BvcHVwRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLnBvcHVwID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmVzZXRFZGl0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLiN1cGRhdGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NldFJlY3RFZGl0ZWQodGhpcy4jdXBkYXRlcy5yZWN0KTtcbiAgICB0aGlzLiNwb3B1cEVsZW1lbnQ/LnBvcHVwLnJlc2V0RWRpdGVkKCk7XG4gICAgdGhpcy4jdXBkYXRlcyA9IG51bGw7XG4gIH1cbiAgI3NldFJlY3RFZGl0ZWQocmVjdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICBzdHlsZVxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVjdDogY3VycmVudFJlY3QsXG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9LFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgcmF3RGltczoge1xuICAgICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjdXJyZW50UmVjdD8uc3BsaWNlKDAsIDQsIC4uLnJlY3QpO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiAocmVjdFswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aH0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiAocGFnZUhlaWdodCAtIHJlY3RbM10gKyBwYWdlWSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIGlmIChyb3RhdGlvbiA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSBgJHsxMDAgKiAocmVjdFsyXSAtIHJlY3RbMF0pIC8gcGFnZVdpZHRofSVgO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogKHJlY3RbM10gLSByZWN0WzFdKSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24pO1xuICAgIH1cbiAgfVxuICBfY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgcGFnZSxcbiAgICAgICAgdmlld3BvcnRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1hbm5vdGF0aW9uLWlkXCIsIGRhdGEuaWQpO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkgJiYgISh0aGlzIGluc3RhbmNlb2YgTGlua0Fubm90YXRpb25FbGVtZW50KSkge1xuICAgICAgY29udGFpbmVyLnRhYkluZGV4ID0gMDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gY29udGFpbmVyO1xuICAgIHN0eWxlLnpJbmRleCA9IHRoaXMucGFyZW50LnpJbmRleDtcbiAgICB0aGlzLnBhcmVudC56SW5kZXggKz0gMjtcbiAgICBpZiAoZGF0YS5hbHRlcm5hdGl2ZVRleHQpIHtcbiAgICAgIGNvbnRhaW5lci50aXRsZSA9IGRhdGEuYWx0ZXJuYXRpdmVUZXh0O1xuICAgIH1cbiAgICBpZiAoZGF0YS5ub1JvdGF0ZSkge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJub3JvdGF0ZVwiKTtcbiAgICB9XG4gICAgaWYgKCFkYXRhLnJlY3QgfHwgdGhpcyBpbnN0YW5jZW9mIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaWYgKCFkYXRhLmhhc093bkNhbnZhcyAmJiByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uLCBjb250YWluZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWlnbm9yZUJvcmRlciAmJiBkYXRhLmJvcmRlclN0eWxlLndpZHRoID4gMCkge1xuICAgICAgc3R5bGUuYm9yZGVyV2lkdGggPSBgJHtkYXRhLmJvcmRlclN0eWxlLndpZHRofXB4YDtcbiAgICAgIGNvbnN0IGhvcml6b250YWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLmhvcml6b250YWxDb3JuZXJSYWRpdXM7XG4gICAgICBjb25zdCB2ZXJ0aWNhbFJhZGl1cyA9IGRhdGEuYm9yZGVyU3R5bGUudmVydGljYWxDb3JuZXJSYWRpdXM7XG4gICAgICBpZiAoaG9yaXpvbnRhbFJhZGl1cyA+IDAgfHwgdmVydGljYWxSYWRpdXMgPiAwKSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7aG9yaXpvbnRhbFJhZGl1c31weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpIC8gY2FsYygke3ZlcnRpY2FsUmFkaXVzfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgICBzdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7d2lkdGh9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHtoZWlnaHR9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICAgIHN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGF0YS5ib3JkZXJTdHlsZS5zdHlsZSkge1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuU09MSUQ6XG4gICAgICAgICAgc3R5bGUuYm9yZGVyU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5EQVNIRUQ6XG4gICAgICAgICAgc3R5bGUuYm9yZGVyU3R5bGUgPSBcImRhc2hlZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuQkVWRUxFRDpcbiAgICAgICAgICB3YXJuKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGJldmVsZWRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5JTlNFVDpcbiAgICAgICAgICB3YXJuKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGluc2V0XCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuVU5ERVJMSU5FOlxuICAgICAgICAgIHN0eWxlLmJvcmRlckJvdHRvbVN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9yZGVyQ29sb3IgPSBkYXRhLmJvcmRlckNvbG9yIHx8IG51bGw7XG4gICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgdGhpcy4jaGFzQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgc3R5bGUuYm9yZGVyQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihib3JkZXJDb2xvclswXSB8IDAsIGJvcmRlckNvbG9yWzFdIHwgMCwgYm9yZGVyQ29sb3JbMl0gfCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVjdCA9IFV0aWwubm9ybWFsaXplUmVjdChbZGF0YS5yZWN0WzBdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbMV0gKyBwYWdlLnZpZXdbMV0sIGRhdGEucmVjdFsyXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzNdICsgcGFnZS52aWV3WzFdXSk7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogKHJlY3RbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGh9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7MTAwICogKHJlY3RbMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGRhdGEuaGFzT3duQ2FudmFzIHx8IHJvdGF0aW9uID09PSAwKSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGAkezEwMCAqIHdpZHRoIC8gcGFnZVdpZHRofSVgO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0IC8gcGFnZUhlaWdodH0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBzZXRSb3RhdGlvbihhbmdsZSwgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5yZWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQucmF3RGltcztcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoYW5nbGUgJSAxODAgIT09IDApIHtcbiAgICAgIFt3aWR0aCwgaGVpZ2h0XSA9IFtoZWlnaHQsIHdpZHRoXTtcbiAgICB9XG4gICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGggLyBwYWdlV2lkdGh9JWA7XG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCAoMzYwIC0gYW5nbGUpICUgMzYwKTtcbiAgfVxuICBnZXQgX2NvbW1vbkFjdGlvbnMoKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSAoanNOYW1lLCBzdHlsZU5hbWUsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBjb2xvciA9IGV2ZW50LmRldGFpbFtqc05hbWVdO1xuICAgICAgY29uc3QgY29sb3JUeXBlID0gY29sb3JbMF07XG4gICAgICBjb25zdCBjb2xvckFycmF5ID0gY29sb3Iuc2xpY2UoMSk7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGVbc3R5bGVOYW1lXSA9IENvbG9yQ29udmVydGVyc1tgJHtjb2xvclR5cGV9X0hUTUxgXShjb2xvckFycmF5KTtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgIFtzdHlsZU5hbWVdOiBDb2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9yZ2JgXShjb2xvckFycmF5KVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2NvbW1vbkFjdGlvbnNcIiwge1xuICAgICAgZGlzcGxheTogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGlzcGxheVxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zdCBoaWRkZW4gPSBkaXNwbGF5ICUgMiA9PT0gMTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IGhpZGRlbiA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlbixcbiAgICAgICAgICBub1ByaW50OiBkaXNwbGF5ID09PSAxIHx8IGRpc3BsYXkgPT09IDJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ByaW50OiAhZXZlbnQuZGV0YWlsLnByaW50XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaGlkZGVuXG4gICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogaGlkZGVuLFxuICAgICAgICAgIG5vVmlldzogaGlkZGVuXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBmYWxzZVxuICAgICAgICB9KSwgMCk7XG4gICAgICB9LFxuICAgICAgdXNlck5hbWU6IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnRpdGxlID0gZXZlbnQuZGV0YWlsLnVzZXJOYW1lO1xuICAgICAgfSxcbiAgICAgIHJlYWRvbmx5OiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9IGV2ZW50LmRldGFpbC5yZWFkb25seTtcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9zZXRSZXF1aXJlZChldmVudC50YXJnZXQsIGV2ZW50LmRldGFpbC5yZXF1aXJlZCk7XG4gICAgICB9LFxuICAgICAgYmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJnQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZpbGxDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZpbGxDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgZmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZnQ29sb3JcIiwgXCJjb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgdGV4dENvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwidGV4dENvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGJvcmRlckNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiYm9yZGVyQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJzdHJva2VDb2xvclwiLCBcImJvcmRlckNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICByb3RhdGlvbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IGV2ZW50LmRldGFpbC5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihhbmdsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgcm90YXRpb246IGFuZ2xlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCkge1xuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhqc0V2ZW50LmRldGFpbCkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbbmFtZV0gfHwgY29tbW9uQWN0aW9uc1tuYW1lXTtcbiAgICAgIGFjdGlvbj8uKGpzRXZlbnQpO1xuICAgIH1cbiAgfVxuICBfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUodGhpcy5kYXRhLmlkKTtcbiAgICBpZiAoIXN0b3JlZERhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29tbW9uQWN0aW9ucyA9IHRoaXMuX2NvbW1vbkFjdGlvbnM7XG4gICAgZm9yIChjb25zdCBbYWN0aW9uTmFtZSwgZGV0YWlsXSBvZiBPYmplY3QuZW50cmllcyhzdG9yZWREYXRhKSkge1xuICAgICAgY29uc3QgYWN0aW9uID0gY29tbW9uQWN0aW9uc1thY3Rpb25OYW1lXTtcbiAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXZlbnRQcm94eSA9IHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIFthY3Rpb25OYW1lXTogZGV0YWlsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0YXJnZXQ6IGVsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgYWN0aW9uKGV2ZW50UHJveHkpO1xuICAgICAgICBkZWxldGUgc3RvcmVkRGF0YVthY3Rpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCkge1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcXVhZFBvaW50c1xuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgaWYgKCFxdWFkUG9pbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtyZWN0QmxYLCByZWN0QmxZLCByZWN0VHJYLCByZWN0VHJZXSA9IHRoaXMuZGF0YS5yZWN0Lm1hcCh4ID0+IE1hdGguZnJvdW5kKHgpKTtcbiAgICBpZiAocXVhZFBvaW50cy5sZW5ndGggPT09IDgpIHtcbiAgICAgIGNvbnN0IFt0clgsIHRyWSwgYmxYLCBibFldID0gcXVhZFBvaW50cy5zdWJhcnJheSgyLCA2KTtcbiAgICAgIGlmIChyZWN0VHJYID09PSB0clggJiYgcmVjdFRyWSA9PT0gdHJZICYmIHJlY3RCbFggPT09IGJsWCAmJiByZWN0QmxZID09PSBibFkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBsZXQgc3ZnQnVmZmVyO1xuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICAgIGJvcmRlcldpZHRoXG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICBzdmdCdWZmZXIgPSBbXCJ1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LFwiLCBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJgLCBgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCIgdmlld0JveD1cIjAgMCAxIDFcIj5gLCBgPGcgZmlsbD1cInRyYW5zcGFyZW50XCIgc3Ryb2tlPVwiJHtib3JkZXJDb2xvcn1cIiBzdHJva2Utd2lkdGg9XCIke2JvcmRlcldpZHRofVwiPmBdO1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc0JvcmRlclwiKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSByZWN0VHJYIC0gcmVjdEJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0VHJZIC0gcmVjdEJsWTtcbiAgICBjb25zdCB7XG4gICAgICBzdmdGYWN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3ZnID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnXCIpO1xuICAgIHN2Zy5jbGFzc0xpc3QuYWRkKFwicXVhZHJpbGF0ZXJhbHNDb250YWluZXJcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDApO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgc3ZnLnJvbGUgPSBcIm5vbmVcIjtcbiAgICBjb25zdCBkZWZzID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICBzdmcuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IGNsaXBQYXRoID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIik7XG4gICAgY29uc3QgaWQgPSBgY2xpcHBhdGhfJHt0aGlzLmRhdGEuaWR9YDtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiY2xpcFBhdGhVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgIGRlZnMuYXBwZW5kKGNsaXBQYXRoKTtcbiAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBxdWFkUG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDgpIHtcbiAgICAgIGNvbnN0IHRyWCA9IHF1YWRQb2ludHNbaV07XG4gICAgICBjb25zdCB0clkgPSBxdWFkUG9pbnRzW2kgKyAxXTtcbiAgICAgIGNvbnN0IGJsWCA9IHF1YWRQb2ludHNbaSArIDJdO1xuICAgICAgY29uc3QgYmxZID0gcXVhZFBvaW50c1tpICsgM107XG4gICAgICBjb25zdCByZWN0ID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicmVjdFwiKTtcbiAgICAgIGNvbnN0IHggPSAoYmxYIC0gcmVjdEJsWCkgLyB3aWR0aDtcbiAgICAgIGNvbnN0IHkgPSAocmVjdFRyWSAtIHRyWSkgLyBoZWlnaHQ7XG4gICAgICBjb25zdCByZWN0V2lkdGggPSAodHJYIC0gYmxYKSAvIHdpZHRoO1xuICAgICAgY29uc3QgcmVjdEhlaWdodCA9ICh0clkgLSBibFkpIC8gaGVpZ2h0O1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ4XCIsIHgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ5XCIsIHkpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCByZWN0V2lkdGgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgcmVjdEhlaWdodCk7XG4gICAgICBjbGlwUGF0aC5hcHBlbmQocmVjdCk7XG4gICAgICBzdmdCdWZmZXI/LnB1c2goYDxyZWN0IHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiB4PVwiJHt4fVwiIHk9XCIke3l9XCIgd2lkdGg9XCIke3JlY3RXaWR0aH1cIiBoZWlnaHQ9XCIke3JlY3RIZWlnaHR9XCIvPmApO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaGFzQm9yZGVyKSB7XG4gICAgICBzdmdCdWZmZXIucHVzaChgPC9nPjwvc3ZnPicpYCk7XG4gICAgICBzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBzdmdCdWZmZXIuam9pbihcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUuY2xpcFBhdGggPSBgdXJsKCMke2lkfSlgO1xuICB9XG4gIF9jcmVhdGVQb3B1cChwb3B1cERhdGEgPSBudWxsKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBjb250ZW50c09iaiwgbW9kaWZpY2F0aW9uRGF0ZTtcbiAgICBpZiAocG9wdXBEYXRhKSB7XG4gICAgICBjb250ZW50c09iaiA9IHtcbiAgICAgICAgc3RyOiBwb3B1cERhdGEudGV4dFxuICAgICAgfTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUgPSBwb3B1cERhdGEuZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudHNPYmogPSBkYXRhLmNvbnRlbnRzT2JqO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZSA9IGRhdGEubW9kaWZpY2F0aW9uRGF0ZTtcbiAgICB9XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLiNwb3B1cEVsZW1lbnQgPSBuZXcgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNvbG9yOiBkYXRhLmNvbG9yLFxuICAgICAgICB0aXRsZU9iajogZGF0YS50aXRsZU9iaixcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZSxcbiAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgIHJpY2hUZXh0OiBkYXRhLnJpY2hUZXh0LFxuICAgICAgICBwYXJlbnRSZWN0OiBkYXRhLnJlY3QsXG4gICAgICAgIGJvcmRlclN0eWxlOiAwLFxuICAgICAgICBpZDogYHBvcHVwXyR7ZGF0YS5pZH1gLFxuICAgICAgICByb3RhdGlvbjogZGF0YS5yb3RhdGlvbixcbiAgICAgICAgbm9Sb3RhdGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBsaW5rU2VydmljZTogdGhpcy5saW5rU2VydmljZSxcbiAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXG4gICAgICBlbGVtZW50czogW3RoaXNdXG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLnBhcmVudC5fY29tbWVudE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5hcHBlbmQocG9wdXAucmVuZGVyKCkpO1xuICAgIH1cbiAgfVxuICBnZXQgaGFzUG9wdXBFbGVtZW50KCkge1xuICAgIHJldHVybiAhISh0aGlzLiNwb3B1cEVsZW1lbnQgfHwgdGhpcy5wb3B1cCB8fCB0aGlzLmRhdGEucG9wdXBSZWYpO1xuICB9XG4gIGdldCBleHRyYVBvcHVwRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9wdXBFbGVtZW50O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgQW5ub3RhdGlvbkVsZW1lbnQucmVuZGVyYCBjYWxsZWRcIik7XG4gIH1cbiAgX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIHNraXBJZCA9IG51bGwpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBpZiAodGhpcy5fZmllbGRPYmplY3RzKSB7XG4gICAgICBjb25zdCBmaWVsZE9iaiA9IHRoaXMuX2ZpZWxkT2JqZWN0c1tuYW1lXTtcbiAgICAgIGlmIChmaWVsZE9iaikge1xuICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICBwYWdlLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGV4cG9ydFZhbHVlc1xuICAgICAgICB9IG9mIGZpZWxkT2JqKSB7XG4gICAgICAgICAgaWYgKHBhZ2UgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlkID09PSBza2lwSWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IHR5cGVvZiBleHBvcnRWYWx1ZXMgPT09IFwic3RyaW5nXCIgPyBleHBvcnRWYWx1ZXMgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1lbGVtZW50LWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgICAgICBpZiAoZG9tRWxlbWVudCAmJiAhR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgICB3YXJuKGBfZ2V0RWxlbWVudHNCeU5hbWUgLSBlbGVtZW50IG5vdCBhbGxvd2VkOiAke2lkfWApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZXhwb3J0VmFsdWUsXG4gICAgICAgICAgICBkb21FbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZG9tRWxlbWVudCBvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShuYW1lKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgfSA9IGRvbUVsZW1lbnQ7XG4gICAgICBjb25zdCBpZCA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIpO1xuICAgICAgaWYgKGlkID09PSBza2lwSWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGV4cG9ydFZhbHVlLFxuICAgICAgICBkb21FbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucG9wdXA/Lm1heWJlU2hvdygpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnBvcHVwPy5mb3JjZUhpZGUoKTtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIGNvbnN0IHRyaWdnZXJzID0gdGhpcy5nZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJpZ2dlcnMpKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHJpZ2dlcnMpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlcnMuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gICAgfVxuICB9XG4gIF9lZGl0T25Eb3VibGVDbGljaygpIHtcbiAgICBpZiAoIXRoaXMuX2lzRWRpdGFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkVkaXRvclR5cGU6IG1vZGUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiBlZGl0SWRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgZWRpdElkLFxuICAgICAgICBtdXN0RW50ZXJJbkVkaXRNb2RlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5yZWN0WzJdIC0gdGhpcy5kYXRhLnJlY3RbMF07XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnJlY3RbM10gLSB0aGlzLmRhdGEucmVjdFsxXTtcbiAgfVxufVxuY2xhc3MgRWRpdG9yQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvciA9IHBhcmFtZXRlcnMuZWRpdG9yO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImVkaXRvckFubm90YXRpb25cIjtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgY3JlYXRlT3JVcGRhdGVQb3B1cCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBlZGl0b3JcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWVkaXRvci5oYXNDb21tZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NyZWF0ZVBvcHVwKGVkaXRvci5jb21tZW50KTtcbiAgICB0aGlzLmV4dHJhUG9wdXBFbGVtZW50LnBvcHVwLnJlbmRlckNvbW1lbnRCdXR0b24oKTtcbiAgfVxuICBnZXQgaGFzQ29tbWVudEJ1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbmFibGVDb21tZW50ICYmIHRoaXMuZWRpdG9yLmhhc0NvbW1lbnQ7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3IuY29tbWVudEJ1dHRvblBvc2l0aW9uSW5QYWdlO1xuICB9XG4gIGdldCBjb21tZW50VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3IuY29tbWVudC50ZXh0O1xuICB9XG4gIHNldCBjb21tZW50VGV4dCh0ZXh0KSB7XG4gICAgdGhpcy5lZGl0b3IuY29tbWVudCA9IHRleHQ7XG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICB0aGlzLnJlbW92ZVBvcHVwKCk7XG4gICAgfVxuICB9XG4gIGdldCBjb21tZW50RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0RGF0YSgpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVQb3B1cCgpO1xuICB9XG59XG5jbGFzcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiAhIW9wdGlvbnM/Lmlnbm9yZUJvcmRlcixcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc1Rvb2x0aXBPbmx5ID0gcGFyYW1ldGVycy5kYXRhLmlzVG9vbHRpcE9ubHk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBsaW5rU2VydmljZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBkYXRhLmlkKTtcbiAgICBsZXQgaXNCb3VuZCA9IGZhbHNlO1xuICAgIGlmIChkYXRhLnVybCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMobGluaywgZGF0YS51cmwsIGRhdGEubmV3V2luZG93KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24pIHtcbiAgICAgIHRoaXMuX2JpbmROYW1lZEFjdGlvbihsaW5rLCBkYXRhLmFjdGlvbiwgZGF0YS5vdmVybGFpZFRleHQpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmF0dGFjaG1lbnQpIHtcbiAgICAgIHRoaXMuI2JpbmRBdHRhY2htZW50KGxpbmssIGRhdGEuYXR0YWNobWVudCwgZGF0YS5vdmVybGFpZFRleHQsIGRhdGEuYXR0YWNobWVudERlc3QpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLnNldE9DR1N0YXRlKSB7XG4gICAgICB0aGlzLiNiaW5kU2V0T0NHU3RhdGUobGluaywgZGF0YS5zZXRPQ0dTdGF0ZSwgZGF0YS5vdmVybGFpZFRleHQpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmRlc3QpIHtcbiAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIGRhdGEuZGVzdCwgZGF0YS5vdmVybGFpZFRleHQpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRhLmFjdGlvbnMgJiYgKGRhdGEuYWN0aW9ucy5BY3Rpb24gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgVXBcIl0gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgRG93blwiXSkgJiYgdGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYmluZEpTQWN0aW9uKGxpbmssIGRhdGEpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnJlc2V0Rm9ybSkge1xuICAgICAgICB0aGlzLl9iaW5kUmVzZXRGb3JtQWN0aW9uKGxpbmssIGRhdGEucmVzZXRGb3JtKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUb29sdGlwT25seSAmJiAhaXNCb3VuZCkge1xuICAgICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBcIlwiKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5rQW5ub3RhdGlvblwiKTtcbiAgICBpZiAoaXNCb3VuZCkge1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgI3NldEludGVybmFsTGluaygpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWludGVybmFsLWxpbmtcIiwgXCJcIik7XG4gIH1cbiAgX2JpbmRMaW5rKGxpbmssIGRlc3RpbmF0aW9uLCBvdmVybGFpZFRleHQgPSBcIlwiKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXREZXN0aW5hdGlvbkhhc2goZGVzdGluYXRpb24pO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmdvVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBpZiAoZGVzdGluYXRpb24gfHwgZGVzdGluYXRpb24gPT09IFwiXCIpIHtcbiAgICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICAgIH1cbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBsaW5rLnRpdGxlID0gb3ZlcmxhaWRUZXh0O1xuICAgIH1cbiAgfVxuICBfYmluZE5hbWVkQWN0aW9uKGxpbmssIGFjdGlvbiwgb3ZlcmxhaWRUZXh0ID0gXCJcIikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXhlY3V0ZU5hbWVkQWN0aW9uKGFjdGlvbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBsaW5rLnRpdGxlID0gb3ZlcmxhaWRUZXh0O1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICAjYmluZEF0dGFjaG1lbnQobGluaywgYXR0YWNobWVudCwgb3ZlcmxhaWRUZXh0ID0gXCJcIiwgZGVzdCA9IG51bGwpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBpZiAoYXR0YWNobWVudC5kZXNjcmlwdGlvbikge1xuICAgICAgbGluay50aXRsZSA9IGF0dGFjaG1lbnQuZGVzY3JpcHRpb247XG4gICAgfSBlbHNlIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGxpbmsudGl0bGUgPSBvdmVybGFpZFRleHQ7XG4gICAgfVxuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEoYXR0YWNobWVudC5jb250ZW50LCBhdHRhY2htZW50LmZpbGVuYW1lLCBkZXN0KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kU2V0T0NHU3RhdGUobGluaywgYWN0aW9uLCBvdmVybGFpZFRleHQgPSBcIlwiKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlU2V0T0NHU3RhdGUoYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGxpbmsudGl0bGUgPSBvdmVybGFpZFRleHQ7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kSlNBY3Rpb24obGluaywgZGF0YSkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoW1tcIkFjdGlvblwiLCBcIm9uY2xpY2tcIl0sIFtcIk1vdXNlIFVwXCIsIFwib25tb3VzZXVwXCJdLCBbXCJNb3VzZSBEb3duXCIsIFwib25tb3VzZWRvd25cIl1dKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZGF0YS5hY3Rpb25zKSkge1xuICAgICAgY29uc3QganNOYW1lID0gbWFwLmdldChuYW1lKTtcbiAgICAgIGlmICghanNOYW1lKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGlua1tqc05hbWVdID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChkYXRhLm92ZXJsYWlkVGV4dCkge1xuICAgICAgbGluay50aXRsZSA9IGRhdGEub3ZlcmxhaWRUZXh0O1xuICAgIH1cbiAgICBpZiAoIWxpbmsub25jbGljaykge1xuICAgICAgbGluay5vbmNsaWNrID0gKCkgPT4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kUmVzZXRGb3JtQWN0aW9uKGxpbmssIHJlc2V0Rm9ybSkge1xuICAgIGNvbnN0IG90aGVyQ2xpY2tBY3Rpb24gPSBsaW5rLm9uY2xpY2s7XG4gICAgaWYgKCFvdGhlckNsaWNrQWN0aW9uKSB7XG4gICAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gICAgaWYgKCF0aGlzLl9maWVsZE9iamVjdHMpIHtcbiAgICAgIHdhcm4oYF9iaW5kUmVzZXRGb3JtQWN0aW9uIC0gXCJyZXNldEZvcm1cIiBhY3Rpb24gbm90IHN1cHBvcnRlZCwgYCArIFwiZW5zdXJlIHRoYXQgdGhlIGBmaWVsZE9iamVjdHNgIHBhcmFtZXRlciBpcyBwcm92aWRlZC5cIik7XG4gICAgICBpZiAoIW90aGVyQ2xpY2tBY3Rpb24pIHtcbiAgICAgICAgbGluay5vbmNsaWNrID0gKCkgPT4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIG90aGVyQ2xpY2tBY3Rpb24/LigpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaWVsZHM6IHJlc2V0Rm9ybUZpZWxkcyxcbiAgICAgICAgcmVmczogcmVzZXRGb3JtUmVmcyxcbiAgICAgICAgaW5jbHVkZVxuICAgICAgfSA9IHJlc2V0Rm9ybTtcbiAgICAgIGNvbnN0IGFsbEZpZWxkcyA9IFtdO1xuICAgICAgaWYgKHJlc2V0Rm9ybUZpZWxkcy5sZW5ndGggIT09IDAgfHwgcmVzZXRGb3JtUmVmcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3QgZmllbGRJZHMgPSBuZXcgU2V0KHJlc2V0Rm9ybVJlZnMpO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiByZXNldEZvcm1GaWVsZHMpIHtcbiAgICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZE9iamVjdHNbZmllbGROYW1lXSB8fCBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGZpZWxkSWRzLmFkZChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRzIG9mIE9iamVjdC52YWx1ZXModGhpcy5fZmllbGRPYmplY3RzKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRJZHMuaGFzKGZpZWxkLmlkKSA9PT0gaW5jbHVkZSkge1xuICAgICAgICAgICAgICBhbGxGaWVsZHMucHVzaChmaWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX2ZpZWxkT2JqZWN0cykpIHtcbiAgICAgICAgICBhbGxGaWVsZHMucHVzaCguLi5maWVsZHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICAgIGNvbnN0IGFsbElkcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBhbGxGaWVsZHMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBmaWVsZDtcbiAgICAgICAgYWxsSWRzLnB1c2goaWQpO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRWYWx1ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICAgIGNhc2UgXCJyYWRpb2J1dHRvblwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRWYWx1ZSA9PT0gZmllbGQuZXhwb3J0VmFsdWVzO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJjb21ib2JveFwiOlxuICAgICAgICAgIGNhc2UgXCJsaXN0Ym94XCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1lbGVtZW50LWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgICAgaWYgKCFkb21FbGVtZW50KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICAgIHdhcm4oYF9iaW5kUmVzZXRGb3JtQWN0aW9uIC0gZWxlbWVudCBub3QgYWxsb3dlZDogJHtpZH1gKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBkb21FbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicmVzZXRmb3JtXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZykge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiBcImFwcFwiLFxuICAgICAgICAgICAgaWRzOiBhbGxJZHMsXG4gICAgICAgICAgICBuYW1lOiBcIlJlc2V0Rm9ybVwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG59XG5jbGFzcyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInRleHRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICBpbWFnZS5zcmMgPSB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCArIFwiYW5ub3RhdGlvbi1cIiArIHRoaXMuZGF0YS5uYW1lLnRvTG93ZXJDYXNlKCkgKyBcIi5zdmdcIjtcbiAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy10ZXh0LWFubm90YXRpb24tdHlwZVwiKTtcbiAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB0eXBlOiB0aGlzLmRhdGEubmFtZVxuICAgIH0pKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGltYWdlKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIHNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyhlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgIGlmIChlbGVtZW50LnByZXZpb3VzU2libGluZz8ubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgICAgZWxlbWVudC5wcmV2aW91c1NpYmxpbmcuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIF9nZXRLZXlNb2RpZmllcihldmVudCkge1xuICAgIHJldHVybiB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtLmlzTWFjID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXk7XG4gIH1cbiAgX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIGJhc2VOYW1lLCBldmVudE5hbWUsIHZhbHVlR2V0dGVyKSB7XG4gICAgaWYgKGJhc2VOYW1lLmluY2x1ZGVzKFwibW91c2VcIikpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlTmFtZSwgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIoZXZlbnQpLFxuICAgICAgICAgICAgc2hpZnQ6IGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgbW9kaWZpZXI6IHRoaXMuX2dldEtleU1vZGlmaWVyKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VOYW1lLCBldmVudCA9PiB7XG4gICAgICAgIGlmIChiYXNlTmFtZSA9PT0gXCJibHVyXCIpIHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmZvY3VzZWQgfHwgIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGJhc2VOYW1lID09PSBcImZvY3VzXCIpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEuZm9jdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbHVlR2V0dGVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZUdldHRlcihldmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBlbGVtZW50RGF0YSwgbmFtZXMsIGdldHRlcikge1xuICAgIGZvciAoY29uc3QgW2Jhc2VOYW1lLCBldmVudE5hbWVdIG9mIG5hbWVzKSB7XG4gICAgICBpZiAoZXZlbnROYW1lID09PSBcIkFjdGlvblwiIHx8IHRoaXMuZGF0YS5hY3Rpb25zPy5bZXZlbnROYW1lXSkge1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIkZvY3VzXCIgfHwgZXZlbnROYW1lID09PSBcIkJsdXJcIikge1xuICAgICAgICAgIGVsZW1lbnREYXRhIHx8PSB7XG4gICAgICAgICAgICBmb2N1c2VkOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgYmFzZU5hbWUsIGV2ZW50TmFtZSwgZ2V0dGVyKTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJGb2N1c1wiICYmICF0aGlzLmRhdGEuYWN0aW9ucz8uQmx1cikge1xuICAgICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIFwiYmx1clwiLCBcIkJsdXJcIiwgbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSBcIkJsdXJcIiAmJiAhdGhpcy5kYXRhLmFjdGlvbnM/LkZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgXCJmb2N1c1wiLCBcIkZvY3VzXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCkge1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5kYXRhLmJhY2tncm91bmRDb2xvciB8fCBudWxsO1xuICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3IgPT09IG51bGwgPyBcInRyYW5zcGFyZW50XCIgOiBVdGlsLm1ha2VIZXhDb2xvcihjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdKTtcbiAgfVxuICBfc2V0VGV4dFN0eWxlKGVsZW1lbnQpIHtcbiAgICBjb25zdCBURVhUX0FMSUdOTUVOVCA9IFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiXTtcbiAgICBjb25zdCB7XG4gICAgICBmb250Q29sb3JcbiAgICB9ID0gdGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YTtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEuZm9udFNpemUgfHwgYW5ub3RhdGlvbl9sYXllcl9ERUZBVUxUX0ZPTlRfU0laRTtcbiAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgbGV0IGNvbXB1dGVkRm9udFNpemU7XG4gICAgY29uc3QgQk9SREVSX1NJWkUgPSAyO1xuICAgIGNvbnN0IHJvdW5kVG9PbmVEZWNpbWFsID0geCA9PiBNYXRoLnJvdW5kKDEwICogeCkgLyAxMDtcbiAgICBpZiAodGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLnJlY3RbM10gLSB0aGlzLmRhdGEucmVjdFsxXSAtIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNvbnN0IG51bWJlck9mTGluZXMgPSBNYXRoLnJvdW5kKGhlaWdodCAvIChMSU5FX0ZBQ1RPUiAqIGZvbnRTaXplKSkgfHwgMTtcbiAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBoZWlnaHQgLyBudW1iZXJPZkxpbmVzO1xuICAgICAgY29tcHV0ZWRGb250U2l6ZSA9IE1hdGgubWluKGZvbnRTaXplLCByb3VuZFRvT25lRGVjaW1hbChsaW5lSGVpZ2h0IC8gTElORV9GQUNUT1IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLnJlY3RbM10gLSB0aGlzLmRhdGEucmVjdFsxXSAtIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1pbihmb250U2l6ZSwgcm91bmRUb09uZURlY2ltYWwoaGVpZ2h0IC8gTElORV9GQUNUT1IpKTtcbiAgICB9XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke2NvbXB1dGVkRm9udFNpemV9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgc3R5bGUuY29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihmb250Q29sb3JbMF0sIGZvbnRDb2xvclsxXSwgZm9udENvbG9yWzJdKTtcbiAgICBpZiAodGhpcy5kYXRhLnRleHRBbGlnbm1lbnQgIT09IG51bGwpIHtcbiAgICAgIHN0eWxlLnRleHRBbGlnbiA9IFRFWFRfQUxJR05NRU5UW3RoaXMuZGF0YS50ZXh0QWxpZ25tZW50XTtcbiAgICB9XG4gIH1cbiAgX3NldFJlcXVpcmVkKGVsZW1lbnQsIGlzUmVxdWlyZWQpIHtcbiAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJlcXVpcmVkXCIsIGlzUmVxdWlyZWQpO1xuICB9XG59XG5jbGFzcyBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zIHx8IHBhcmFtZXRlcnMuZGF0YS5oYXNPd25DYW52YXMgfHwgIXBhcmFtZXRlcnMuZGF0YS5oYXNBcHBlYXJhbmNlICYmICEhcGFyYW1ldGVycy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlXG4gICAgfSk7XG4gIH1cbiAgc2V0UHJvcGVydHlPblNpYmxpbmdzKGJhc2UsIGtleSwgdmFsdWUsIGtleUluU3RvcmFnZSkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShiYXNlLm5hbWUsIGJhc2UuaWQpKSB7XG4gICAgICBpZiAoZWxlbWVudC5kb21FbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuZG9tRWxlbWVudFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGVsZW1lbnQuaWQsIHtcbiAgICAgICAgW2tleUluU3RvcmFnZV06IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ0ZXh0V2lkZ2V0QW5ub3RhdGlvblwiKTtcbiAgICBsZXQgZWxlbWVudCA9IG51bGw7XG4gICAgaWYgKHRoaXMucmVuZGVyRm9ybXMpIHtcbiAgICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmRhdGEuZmllbGRWYWx1ZVxuICAgICAgfSk7XG4gICAgICBsZXQgdGV4dENvbnRlbnQgPSBzdG9yZWREYXRhLnZhbHVlIHx8IFwiXCI7XG4gICAgICBjb25zdCBtYXhMZW4gPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICAgIGNoYXJMaW1pdDogdGhpcy5kYXRhLm1heExlblxuICAgICAgfSkuY2hhckxpbWl0O1xuICAgICAgaWYgKG1heExlbiAmJiB0ZXh0Q29udGVudC5sZW5ndGggPiBtYXhMZW4pIHtcbiAgICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgwLCBtYXhMZW4pO1xuICAgICAgfVxuICAgICAgbGV0IGZpZWxkRm9ybWF0dGVkVmFsdWVzID0gc3RvcmVkRGF0YS5mb3JtYXR0ZWRWYWx1ZSB8fCB0aGlzLmRhdGEudGV4dENvbnRlbnQ/LmpvaW4oXCJcXG5cIikgfHwgbnVsbDtcbiAgICAgIGlmIChmaWVsZEZvcm1hdHRlZFZhbHVlcyAmJiB0aGlzLmRhdGEuY29tYikge1xuICAgICAgICBmaWVsZEZvcm1hdHRlZFZhbHVlcyA9IGZpZWxkRm9ybWF0dGVkVmFsdWVzLnJlcGxhY2VBbGwoL1xccysvZywgXCJcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBlbGVtZW50RGF0YSA9IHtcbiAgICAgICAgdXNlclZhbHVlOiB0ZXh0Q29udGVudCxcbiAgICAgICAgZm9ybWF0dGVkVmFsdWU6IGZpZWxkRm9ybWF0dGVkVmFsdWVzLFxuICAgICAgICBsYXN0Q29tbWl0dGVkVmFsdWU6IG51bGwsXG4gICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPz8gdGV4dENvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZG9Ob3RTY3JvbGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGVsZW1lbnQudHlwZSA9IHRoaXMuZGF0YS5wYXNzd29yZCA/IFwicGFzc3dvcmRcIiA6IFwidGV4dFwiO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIGZpZWxkRm9ybWF0dGVkVmFsdWVzID8/IHRleHRDb250ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5kb05vdFNjcm9sbCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3dYID0gXCJoaWRkZW5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgICAgZWxlbWVudC5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgICAgZWxlbWVudC5kaXNhYmxlZCA9IHRoaXMuZGF0YS5yZWFkT25seTtcbiAgICAgIGVsZW1lbnQubmFtZSA9IHRoaXMuZGF0YS5maWVsZE5hbWU7XG4gICAgICBlbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0ZXRpbWVGb3JtYXQsXG4gICAgICAgIGRhdGV0aW1lVHlwZSxcbiAgICAgICAgdGltZVN0ZXBcbiAgICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgICBjb25zdCBoYXNEYXRlT3JUaW1lID0gISFkYXRldGltZVR5cGUgJiYgdGhpcy5lbmFibGVTY3JpcHRpbmc7XG4gICAgICBpZiAoZGF0ZXRpbWVGb3JtYXQpIHtcbiAgICAgICAgZWxlbWVudC50aXRsZSA9IGRhdGV0aW1lRm9ybWF0O1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICAgIGlmIChtYXhMZW4pIHtcbiAgICAgICAgZWxlbWVudC5tYXhMZW5ndGggPSBtYXhMZW47XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5T25TaWJsaW5ncyhlbGVtZW50LCBcInZhbHVlXCIsIGV2ZW50LnRhcmdldC52YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWUgPz8gXCJcIjtcbiAgICAgICAgZWxlbWVudC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBsZXQgYmx1ckxpc3RlbmVyID0gZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgfSA9IGVsZW1lbnREYXRhO1xuICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldC5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBpZiAoaGFzRGF0ZU9yVGltZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnR5cGUgPSBkYXRldGltZVR5cGU7XG4gICAgICAgICAgICBpZiAodGltZVN0ZXApIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LnN0ZXAgPSB0aW1lU3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLnVzZXJWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICBpZiAoaGFzRGF0ZU9yVGltZSkge1xuICAgICAgICAgICAgICBpZiAoZGF0ZXRpbWVUeXBlID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBbZGF0ZS5nZXRIb3VycygpLCBkYXRlLmdldE1pbnV0ZXMoKSwgZGF0ZS5nZXRTZWNvbmRzKCldO1xuICAgICAgICAgICAgICAgIHRhcmdldC52YWx1ZSA9IHBhcnRzLm1hcCh2ID0+IHYudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCI6XCIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldC52YWx1ZSA9IG5ldyBEYXRlKHZhbHVlIC0gVElNRVpPTkVfT0ZGU0VUKS50b0lTT1N0cmluZygpLnNwbGl0KGRhdGV0aW1lVHlwZSA9PT0gXCJkYXRlXCIgPyBcIlRcIiA6IFwiLlwiLCAxKVswXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAxO1xuICAgICAgICAgIGlmICghdGhpcy5kYXRhLmFjdGlvbnM/LkZvY3VzKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgICB0aGlzLnNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyhqc0V2ZW50LnRhcmdldCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZSA/PyBcIlwiO1xuICAgICAgICAgICAgICBpZiAoIWhhc0RhdGVPclRpbWUpIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZWxlbWVudERhdGEudXNlclZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSAhPT0gbnVsbCAmJiBmb3JtYXR0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LnRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKGhhc0RhdGVPclRpbWUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwgZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsUmFuZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnNldFNlbGVjdGlvblJhbmdlKC4uLmV2ZW50LmRldGFpbC5zZWxSYW5nZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhckxpbWl0OiBldmVudCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBjaGFyTGltaXRcbiAgICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgIGlmIChjaGFyTGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwibWF4TGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwibWF4TGVuZ3RoXCIsIGNoYXJMaW1pdCk7XG4gICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPD0gY2hhckxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICAgICAgICBzZWxTdGFydDogdGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgc2VsRW5kOiB0YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGVsZW1lbnREYXRhLmNvbW1pdEtleSA9IDE7XG4gICAgICAgICAgbGV0IGNvbW1pdEtleSA9IC0xO1xuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICAgIGNvbW1pdEtleSA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiAmJiAhdGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1pdEtleSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICBjb21taXRLZXksXG4gICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2JsdXJMaXN0ZW5lciA9IGJsdXJMaXN0ZW5lcjtcbiAgICAgICAgYmx1ckxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50RGF0YS5mb2N1c2VkIHx8ICFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5kYXRhLmFjdGlvbnM/LkJsdXIpIHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSB0YXJnZXQ7XG4gICAgICAgICAgaWYgKGhhc0RhdGVPclRpbWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBkYXRldGltZVR5cGUgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gdmFsdWUuc3BsaXQoXCI6XCIpLm1hcCh2ID0+IHBhcnNlSW50KHYsIDEwKSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUoMjAwMCwgMCwgMSwgcGFydHNbMF0sIHBhcnRzWzFdLCBwYXJ0c1syXSB8fCAwKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgIHRhcmdldC5zdGVwID0gXCJcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghdmFsdWUuaW5jbHVkZXMoXCJUXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBgJHt2YWx1ZX1UMDA6MDBgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb21taXRLZXk6IGVsZW1lbnREYXRhLmNvbW1pdEtleSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgIHNlbEVuZDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2JsdXJMaXN0ZW5lcihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5kYXRhLmFjdGlvbnM/LktleXN0cm9rZSkge1xuICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgfSA9IHRhcmdldDtcbiAgICAgICAgICAgIGxldCBzZWxTdGFydCA9IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICBzZWxFbmQgPSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmlucHV0VHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlV29yZEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9cXHcqW15cXHddKiQvKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxTdGFydCAtPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVXb3JkRm9yd2FyZFwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvblN0YXJ0KS5tYXRjaCgvXlteXFx3XSpcXHcqLyk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiOlxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICBzZWxTdGFydCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbEVuZCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgY2hhbmdlOiBkYXRhIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VsU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBbW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoYmx1ckxpc3RlbmVyKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1ckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuY29tYikge1xuICAgICAgICBjb25zdCBmaWVsZFdpZHRoID0gdGhpcy5kYXRhLnJlY3RbMl0gLSB0aGlzLmRhdGEucmVjdFswXTtcbiAgICAgICAgY29uc3QgY29tYldpZHRoID0gZmllbGRXaWR0aCAvIG1heExlbjtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiY29tYlwiKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gYGNhbGMoJHtjb21iV2lkdGh9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpIC0gMWNoKWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IHRoaXMuZGF0YS5maWVsZFZhbHVlO1xuICAgICAgZWxlbWVudC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJtaWRkbGVcIjtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwidGFibGUtY2VsbFwiO1xuICAgICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgICAgZWxlbWVudC5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zZXRUZXh0U3R5bGUoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiAhIXBhcmFtZXRlcnMuZGF0YS5oYXNPd25DYW52YXNcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGlkID0gZGF0YS5pZDtcbiAgICBsZXQgdmFsdWUgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogZGF0YS5leHBvcnRWYWx1ZSA9PT0gZGF0YS5maWVsZFZhbHVlXG4gICAgfSkudmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gXCJPZmZcIjtcbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcImNoZWNrQm94XCIpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIGVsZW1lbnQudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICBlbGVtZW50Lm5hbWUgPSBkYXRhLmZpZWxkTmFtZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJleHBvcnRWYWx1ZVwiLCBkYXRhLmV4cG9ydFZhbHVlKTtcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgY2hlY2tib3guZXhwb3J0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgICAgIGlmIChjaGVja2JveC5kb21FbGVtZW50KSB7XG4gICAgICAgICAgY2hlY2tib3guZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGNoZWNrYm94LmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSB8fCBcIk9mZlwiO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBldmVudC5kZXRhaWwudmFsdWUgIT09IFwiT2ZmXCI7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInJhZGlvQnV0dG9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmZpZWxkVmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShkYXRhLmZpZWxkTmFtZSwgaWQpKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIGVsZW1lbnQudHlwZSA9IFwicmFkaW9cIjtcbiAgICBlbGVtZW50Lm5hbWUgPSBkYXRhLmZpZWxkTmFtZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxlbWVudC50YWJJbmRleCA9IDA7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2hlY2tlZFxuICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgaWQpKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZTtcbiAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkID0gZGVmYXVsdFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGRlZmF1bHRWYWx1ZSA9PT0gZGF0YS5idXR0b25WYWx1ZTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgIGNvbnN0IHBkZkJ1dHRvblZhbHVlID0gZGF0YS5idXR0b25WYWx1ZTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgIHZhbHVlOiBldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGVja2VkID0gcGRmQnV0dG9uVmFsdWUgPT09IGV2ZW50LmRldGFpbC52YWx1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoZXZlbnQudGFyZ2V0Lm5hbWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ckNoZWNrZWQgPSBjaGVja2VkICYmIHJhZGlvLmlkID09PSBpZDtcbiAgICAgICAgICAgICAgaWYgKHJhZGlvLmRvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByYWRpby5kb21FbGVtZW50LmNoZWNrZWQgPSBjdXJDaGVja2VkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY3VyQ2hlY2tlZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgbnVsbCwgW1tcImNoYW5nZVwiLCBcIlZhbGlkYXRlXCJdLCBbXCJjaGFuZ2VcIiwgXCJBY3Rpb25cIl0sIFtcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfVxuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KTtcbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhlbGVtZW50KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaWdub3JlQm9yZGVyOiBwYXJhbWV0ZXJzLmRhdGEuaGFzQXBwZWFyYW5jZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBzdXBlci5yZW5kZXIoKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImJ1dHRvbldpZGdldEFubm90YXRpb25cIiwgXCJwdXNoQnV0dG9uXCIpO1xuICAgIGNvbnN0IGxpbmtFbGVtZW50ID0gY29udGFpbmVyLmxhc3RDaGlsZDtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMgJiYgbGlua0VsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGxpbmtFbGVtZW50KTtcbiAgICAgIGxpbmtFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KHt9LCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2hvaWNlV2lkZ2V0QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IHRoaXMuZGF0YS5maWVsZFZhbHVlXG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZWN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKHNlbGVjdEVsZW1lbnQpO1xuICAgIHNlbGVjdEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBzZWxlY3RFbGVtZW50LmRpc2FibGVkID0gdGhpcy5kYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKHNlbGVjdEVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgc2VsZWN0RWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcbiAgICBzZWxlY3RFbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgICBsZXQgYWRkQW5FbXB0eUVudHJ5ID0gdGhpcy5kYXRhLmNvbWJvICYmIHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aCA+IDA7XG4gICAgaWYgKCF0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuc2l6ZSA9IHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgc2VsZWN0RWxlbWVudC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBzZWxlY3RFbGVtZW50Lm9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uLnZhbHVlID09PSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgdGhpcy5kYXRhLm9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbi5kaXNwbGF5VmFsdWU7XG4gICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gb3B0aW9uLmV4cG9ydFZhbHVlO1xuICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUuaW5jbHVkZXMob3B0aW9uLmV4cG9ydFZhbHVlKSkge1xuICAgICAgICBvcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgICBhZGRBbkVtcHR5RW50cnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgIH1cbiAgICBsZXQgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgaWYgKGFkZEFuRW1wdHlFbnRyeSkge1xuICAgICAgY29uc3Qgbm9uZU9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQudmFsdWUgPSBcIiBcIjtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCB0cnVlKTtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgc2VsZWN0RWxlbWVudC5wcmVwZW5kKG5vbmVPcHRpb25FbGVtZW50KTtcbiAgICAgIHJlbW92ZUVtcHR5RW50cnkgPSAoKSA9PiB7XG4gICAgICAgIG5vbmVPcHRpb25FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgICB9O1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgcmVtb3ZlRW1wdHlFbnRyeSk7XG4gICAgfVxuICAgIGNvbnN0IGdldFZhbHVlID0gaXNFeHBvcnQgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGlzRXhwb3J0ID8gXCJ2YWx1ZVwiIDogXCJ0ZXh0Q29udGVudFwiO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBtdWx0aXBsZVxuICAgICAgfSA9IHNlbGVjdEVsZW1lbnQ7XG4gICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gbnVsbCA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XVtuYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwob3B0aW9ucywgb3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCkubWFwKG9wdGlvbiA9PiBvcHRpb25bbmFtZV0pO1xuICAgIH07XG4gICAgbGV0IHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgIGNvbnN0IGdldEl0ZW1zID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChvcHRpb25zLCBvcHRpb24gPT4gKHtcbiAgICAgICAgZGlzcGxheVZhbHVlOiBvcHRpb24udGV4dENvbnRlbnQsXG4gICAgICAgIGV4cG9ydFZhbHVlOiBvcHRpb24udmFsdWVcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgIHJlbW92ZUVtcHR5RW50cnk/LigpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNlbGVjdEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZXMuaGFzKG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG11bHRpcGxlU2VsZWN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZShldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHNlbGVjdEVsZW1lbnQub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnQuZGV0YWlsLnJlbW92ZTtcbiAgICAgICAgICAgIG9wdGlvbnNbaW5kZXhdLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZShpbmRleCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGkgPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4LmNhbGwob3B0aW9ucywgb3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCk7XG4gICAgICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKSxcbiAgICAgICAgICAgICAgaXRlbXM6IGdldEl0ZW1zKGV2ZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsZWFyKGV2ZW50KSB7XG4gICAgICAgICAgICB3aGlsZSAoc2VsZWN0RWxlbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnNlcnQoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZSxcbiAgICAgICAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWwuaW5zZXJ0O1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0Q2hpbGQgPSBzZWxlY3RFbGVtZW50LmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBleHBvcnRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RDaGlsZCkge1xuICAgICAgICAgICAgICBzZWxlY3RDaGlsZC5iZWZvcmUob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaXRlbXMoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaXRlbXNcbiAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICB3aGlsZSAoc2VsZWN0RWxlbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZSxcbiAgICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgICB9ID0gaXRlbTtcbiAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudGV4dENvbnRlbnQgPSBkaXNwbGF5VmFsdWU7XG4gICAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBleHBvcnRWYWx1ZTtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0RWxlbWVudC5vcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5vcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5kaWNlcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBTZXQoZXZlbnQuZGV0YWlsLmluZGljZXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZXZlbnQudGFyZ2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gaW5kaWNlcy5oYXMob3B0aW9uLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZWRpdGFibGUoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9ICFldmVudC5kZXRhaWwuZWRpdGFibGU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgZXhwb3J0VmFsdWUgPSBnZXRWYWx1ZSh0cnVlKTtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGV4cG9ydFZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBzZWxlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIGNoYW5nZSxcbiAgICAgICAgICAgIGNoYW5nZUV4OiBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIHdpbGxDb21taXQ6IGZhbHNlLFxuICAgICAgICAgICAgY29tbWl0S2V5OiAxLFxuICAgICAgICAgICAga2V5RG93bjogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhzZWxlY3RFbGVtZW50LCBudWxsLCBbW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXSwgW1wiaW5wdXRcIiwgXCJBY3Rpb25cIl0sIFtcImlucHV0XCIsIFwiVmFsaWRhdGVcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5kYXRhLmNvbWJvKSB7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGUoc2VsZWN0RWxlbWVudCk7XG4gICAgfSBlbHNlIHt9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzZWxlY3RFbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBwYXJlbnRcbiAgICB9ID0gcGFyYW1ldGVycztcbiAgICBjb25zdCBoYXNDb21tZW50TWFuYWdlciA9ICEhcGFyZW50Ll9jb21tZW50TWFuYWdlcjtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6ICFoYXNDb21tZW50TWFuYWdlciAmJiBBbm5vdGF0aW9uRWxlbWVudC5faGFzUG9wdXBEYXRhKGRhdGEpXG4gICAgfSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIGlmIChoYXNDb21tZW50TWFuYWdlciAmJiBBbm5vdGF0aW9uRWxlbWVudC5faGFzUG9wdXBEYXRhKGRhdGEpKSB7XG4gICAgICBjb25zdCBwb3B1cCA9IHRoaXMucG9wdXAgPSB0aGlzLiNjcmVhdGVQb3B1cCgpO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGVsZW1lbnQucG9wdXAgPSBwb3B1cDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3B1cCA9IG51bGw7XG4gICAgfVxuICB9XG4gICNjcmVhdGVQb3B1cCgpIHtcbiAgICByZXR1cm4gbmV3IFBvcHVwRWxlbWVudCh7XG4gICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgY29sb3I6IHRoaXMuZGF0YS5jb2xvcixcbiAgICAgIHRpdGxlT2JqOiB0aGlzLmRhdGEudGl0bGVPYmosXG4gICAgICBtb2RpZmljYXRpb25EYXRlOiB0aGlzLmRhdGEubW9kaWZpY2F0aW9uRGF0ZSB8fCB0aGlzLmRhdGEuY3JlYXRpb25EYXRlLFxuICAgICAgY29udGVudHNPYmo6IHRoaXMuZGF0YS5jb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLmRhdGEucmljaFRleHQsXG4gICAgICByZWN0OiB0aGlzLmRhdGEucmVjdCxcbiAgICAgIHBhcmVudFJlY3Q6IHRoaXMuZGF0YS5wYXJlbnRSZWN0IHx8IG51bGwsXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHMsXG4gICAgICBvcGVuOiB0aGlzLmRhdGEub3BlbixcbiAgICAgIGNvbW1lbnRNYW5hZ2VyOiB0aGlzLnBhcmVudC5fY29tbWVudE1hbmFnZXJcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyXG4gICAgfSA9IHRoaXM7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJwb3B1cEFubm90YXRpb25cIik7XG4gICAgY29udGFpbmVyLnJvbGUgPSBcImNvbW1lbnRcIjtcbiAgICBjb25zdCBwb3B1cCA9IHRoaXMucG9wdXAgPSB0aGlzLiNjcmVhdGVQb3B1cCgpO1xuICAgIGNvbnN0IGVsZW1lbnRJZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgZWxlbWVudC5wb3B1cCA9IHBvcHVwO1xuICAgICAgZWxlbWVudC5jb250YWluZXIuYXJpYUhhc1BvcHVwID0gXCJkaWFsb2dcIjtcbiAgICAgIGVsZW1lbnRJZHMucHVzaChlbGVtZW50LmRhdGEuaWQpO1xuICAgICAgZWxlbWVudC5hZGRIaWdobGlnaHRBcmVhKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIiwgZWxlbWVudElkcy5tYXAoaWQgPT4gYCR7QW5ub3RhdGlvblByZWZpeH0ke2lkfWApLmpvaW4oXCIsXCIpKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFBvcHVwRWxlbWVudCB7XG4gICNjb21tZW50TWFuYWdlciA9IG51bGw7XG4gICNib3VuZEtleURvd24gPSB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyk7XG4gICNib3VuZEhpZGUgPSB0aGlzLiNoaWRlLmJpbmQodGhpcyk7XG4gICNib3VuZFNob3cgPSB0aGlzLiNzaG93LmJpbmQodGhpcyk7XG4gICNib3VuZFRvZ2dsZSA9IHRoaXMuI3RvZ2dsZS5iaW5kKHRoaXMpO1xuICAjY29sb3IgPSBudWxsO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI2NvbnRlbnRzT2JqID0gbnVsbDtcbiAgI2RhdGVPYmogPSBudWxsO1xuICAjZWxlbWVudHMgPSBudWxsO1xuICAjcGFyZW50ID0gbnVsbDtcbiAgI3BhcmVudFJlY3QgPSBudWxsO1xuICAjcGlubmVkID0gZmFsc2U7XG4gICNwb3B1cCA9IG51bGw7XG4gICNwb3B1cEFib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICNwb3NpdGlvbiA9IG51bGw7XG4gICNjb21tZW50QnV0dG9uID0gbnVsbDtcbiAgI2NvbW1lbnRCdXR0b25Qb3NpdGlvbiA9IG51bGw7XG4gICNwb3B1cFBvc2l0aW9uID0gbnVsbDtcbiAgI3JlY3QgPSBudWxsO1xuICAjcmljaFRleHQgPSBudWxsO1xuICAjdGl0bGVPYmogPSBudWxsO1xuICAjdXBkYXRlcyA9IG51bGw7XG4gICN3YXNWaXNpYmxlID0gZmFsc2U7XG4gICNmaXJzdEVsZW1lbnQgPSBudWxsO1xuICAjY29tbWVudFRleHQgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGFpbmVyLFxuICAgIGNvbG9yLFxuICAgIGVsZW1lbnRzLFxuICAgIHRpdGxlT2JqLFxuICAgIG1vZGlmaWNhdGlvbkRhdGUsXG4gICAgY29udGVudHNPYmosXG4gICAgcmljaFRleHQsXG4gICAgcGFyZW50LFxuICAgIHJlY3QsXG4gICAgcGFyZW50UmVjdCxcbiAgICBvcGVuLFxuICAgIGNvbW1lbnRNYW5hZ2VyID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3RpdGxlT2JqID0gdGl0bGVPYmo7XG4gICAgdGhpcy4jY29udGVudHNPYmogPSBjb250ZW50c09iajtcbiAgICB0aGlzLiNyaWNoVGV4dCA9IHJpY2hUZXh0O1xuICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLiNjb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuI3JlY3QgPSByZWN0O1xuICAgIHRoaXMuI3BhcmVudFJlY3QgPSBwYXJlbnRSZWN0O1xuICAgIHRoaXMuI2VsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgdGhpcy4jY29tbWVudE1hbmFnZXIgPSBjb21tZW50TWFuYWdlcjtcbiAgICB0aGlzLiNmaXJzdEVsZW1lbnQgPSBlbGVtZW50c1swXTtcbiAgICB0aGlzLiNkYXRlT2JqID0gUERGRGF0ZVN0cmluZy50b0RhdGVPYmplY3QobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgdGhpcy50cmlnZ2VyID0gZWxlbWVudHMuZmxhdE1hcChlID0+IGUuZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpKTtcbiAgICBpZiAoY29tbWVudE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyQ29tbWVudEJ1dHRvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNhZGRFdmVudExpc3RlbmVycygpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgICBpZiAob3Blbikge1xuICAgICAgICB0aGlzLiN0b2dnbGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLiNwb3B1cEFib3J0Q29udHJvbGxlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNwb3B1cEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYWxcbiAgICB9ID0gdGhpcy4jcG9wdXBBYm9ydENvbnRyb2xsZXI7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudHJpZ2dlcikge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCB0aGlzLiNib3VuZFNob3csIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLiNib3VuZEhpZGUsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLiNlbGVtZW50cykge1xuICAgICAgZWxlbWVudC5jb250YWluZXI/LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93biwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAjc2V0Q29tbWVudEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLiNlbGVtZW50cy5maW5kKGUgPT4gZS5oYXNDb21tZW50QnV0dG9uKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudEJ1dHRvblBvc2l0aW9uID0gZWxlbWVudC5fbm9ybWFsaXplUG9pbnQoZWxlbWVudC5jb21tZW50QnV0dG9uUG9zaXRpb24pO1xuICB9XG4gIHJlbmRlckNvbW1lbnRCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuI2NvbW1lbnRCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb24pIHtcbiAgICAgIHRoaXMuI3NldENvbW1lbnRCdXR0b25Qb3NpdGlvbigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2NvbW1lbnRCdXR0b25Qb3NpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzaWduYWxcbiAgICB9ID0gdGhpcy4jcG9wdXBBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgaGFzT3duQnV0dG9uID0gISF0aGlzLiNmaXJzdEVsZW1lbnQuZXh0cmFQb3B1cEVsZW1lbnQ7XG4gICAgY29uc3QgdG9nZ2xlUG9wdXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNjb21tZW50TWFuYWdlci50b2dnbGVDb21tZW50UG9wdXAodGhpcywgdHJ1ZSwgdW5kZWZpbmVkLCAhaGFzT3duQnV0dG9uKTtcbiAgICB9O1xuICAgIGNvbnN0IHNob3dQb3B1cCA9ICgpID0+IHtcbiAgICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyLnRvZ2dsZUNvbW1lbnRQb3B1cCh0aGlzLCBmYWxzZSwgdHJ1ZSwgIWhhc093bkJ1dHRvbik7XG4gICAgfTtcbiAgICBjb25zdCBoaWRlUG9wdXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNjb21tZW50TWFuYWdlci50b2dnbGVDb21tZW50UG9wdXAodGhpcywgZmFsc2UsIGZhbHNlKTtcbiAgICB9O1xuICAgIGlmICghaGFzT3duQnV0dG9uKSB7XG4gICAgICBjb25zdCBidXR0b24gPSB0aGlzLiNjb21tZW50QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImFubm90YXRpb25Db21tZW50QnV0dG9uXCI7XG4gICAgICBjb25zdCBwYXJlbnRDb250YWluZXIgPSB0aGlzLiNmaXJzdEVsZW1lbnQuY29udGFpbmVyO1xuICAgICAgYnV0dG9uLnN0eWxlLnpJbmRleCA9IHBhcmVudENvbnRhaW5lci5zdHlsZS56SW5kZXggKyAxO1xuICAgICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICAgIGJ1dHRvbi5hcmlhSGFzUG9wdXAgPSBcImRpYWxvZ1wiO1xuICAgICAgYnV0dG9uLmFyaWFDb250cm9scyA9IFwiY29tbWVudFBvcHVwXCI7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtc2hvdy1jb21tZW50LWJ1dHRvblwiKTtcbiAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKCk7XG4gICAgICB0aGlzLiN1cGRhdGVDb21tZW50QnV0dG9uUG9zaXRpb24oKTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdG9nZ2xlUG9wdXAsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmVudGVyXCIsIHNob3dQb3B1cCwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgaGlkZVBvcHVwLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBwYXJlbnRDb250YWluZXIuYWZ0ZXIoYnV0dG9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jY29tbWVudEJ1dHRvbiA9IHRoaXMuI2ZpcnN0RWxlbWVudC5jb250YWluZXI7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy50cmlnZ2VyKSB7XG4gICAgICAgIGVsZW1lbnQuYXJpYUhhc1BvcHVwID0gXCJkaWFsb2dcIjtcbiAgICAgICAgZWxlbWVudC5hcmlhQ29udHJvbHMgPSBcImNvbW1lbnRQb3B1cFwiO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93biwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdG9nZ2xlUG9wdXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBzaG93UG9wdXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBoaWRlUG9wdXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICN1cGRhdGVDb21tZW50QnV0dG9uUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuI2ZpcnN0RWxlbWVudC5leHRyYVBvcHVwRWxlbWVudCAmJiAhdGhpcy4jZmlyc3RFbGVtZW50LmVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlckNvbW1lbnRCdXR0b24oKTtcbiAgICBjb25zdCBbeCwgeV0gPSB0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb247XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jY29tbWVudEJ1dHRvbjtcbiAgICBzdHlsZS5sZWZ0ID0gYGNhbGMoJHt4fSUpYDtcbiAgICBzdHlsZS50b3AgPSBgY2FsYygke3l9JSAtIHZhcigtLWNvbW1lbnQtYnV0dG9uLWRpbSkpYDtcbiAgfVxuICAjdXBkYXRlQ29sb3IoKSB7XG4gICAgaWYgKHRoaXMuI2ZpcnN0RWxlbWVudC5leHRyYVBvcHVwRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlckNvbW1lbnRCdXR0b24oKTtcbiAgICB0aGlzLiNjb21tZW50QnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuY29tbWVudEJ1dHRvbkNvbG9yIHx8IFwiXCI7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Db2xvcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHlcbiAgICB9ID0gdGhpcy4jZmlyc3RFbGVtZW50LmNvbW1lbnREYXRhO1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jcGFyZW50Ll9jb21tZW50TWFuYWdlci5tYWtlQ29tbWVudENvbG9yKGNvbG9yLCBvcGFjaXR5KTtcbiAgfVxuICBmb2N1c0NvbW1lbnRCdXR0b24oKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNjb21tZW50QnV0dG9uPy5mb2N1cygpO1xuICAgIH0sIDApO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmljaFRleHQsXG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHksXG4gICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgfSA9IHRoaXMuI2ZpcnN0RWxlbWVudC5jb21tZW50RGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudHNPYmo6IHtcbiAgICAgICAgc3RyOiB0aGlzLmNvbW1lbnRcbiAgICAgIH0sXG4gICAgICByaWNoVGV4dCxcbiAgICAgIGNvbG9yLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICB9O1xuICB9XG4gIGdldCBlbGVtZW50QmVmb3JlUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnRCdXR0b247XG4gIH1cbiAgZ2V0IGNvbW1lbnQoKSB7XG4gICAgdGhpcy4jY29tbWVudFRleHQgfHw9IHRoaXMuI2ZpcnN0RWxlbWVudC5jb21tZW50VGV4dDtcbiAgICByZXR1cm4gdGhpcy4jY29tbWVudFRleHQ7XG4gIH1cbiAgc2V0IGNvbW1lbnQodGV4dCkge1xuICAgIGlmICh0ZXh0ID09PSB0aGlzLmNvbW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZmlyc3RFbGVtZW50LmNvbW1lbnRUZXh0ID0gdGhpcy4jY29tbWVudFRleHQgPSB0ZXh0O1xuICB9XG4gIGdldCBwYXJlbnRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZpcnN0RWxlbWVudC5sYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBzZXRDb21tZW50QnV0dG9uU3RhdGVzKHtcbiAgICBzZWxlY3RlZCxcbiAgICBoYXNQb3B1cFxuICB9KSB7XG4gICAgaWYgKCF0aGlzLiNjb21tZW50QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnRCdXR0b24uY2xhc3NMaXN0LnRvZ2dsZShcInNlbGVjdGVkXCIsIHNlbGVjdGVkKTtcbiAgICB0aGlzLiNjb21tZW50QnV0dG9uLmFyaWFFeHBhbmRlZCA9IGhhc1BvcHVwO1xuICB9XG4gIHNldFNlbGVjdGVkQ29tbWVudEJ1dHRvbihzZWxlY3RlZCkge1xuICAgIHRoaXMuI2NvbW1lbnRCdXR0b24uY2xhc3NMaXN0LnRvZ2dsZShcInNlbGVjdGVkXCIsIHNlbGVjdGVkKTtcbiAgfVxuICBnZXQgY29tbWVudFBvcHVwUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuI3BvcHVwUG9zaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLiNwb3B1cFBvc2l0aW9uO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNjb21tZW50QnV0dG9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IHBhcmVudFgsXG4gICAgICB5OiBwYXJlbnRZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGhpcy4jZmlyc3RFbGVtZW50LmxheWVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBbKHggLSBwYXJlbnRYKSAvIHBhcmVudFdpZHRoLCAoeSArIGhlaWdodCAtIHBhcmVudFkpIC8gcGFyZW50SGVpZ2h0XTtcbiAgfVxuICBzZXQgY29tbWVudFBvcHVwUG9zaXRpb24ocG9zKSB7XG4gICAgdGhpcy4jcG9wdXBQb3NpdGlvbiA9IHBvcztcbiAgfVxuICBoYXNEZWZhdWx0UG9wdXBQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9wdXBQb3NpdGlvbiA9PT0gbnVsbDtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb247XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25XaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29tbWVudEJ1dHRvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAvIHRoaXMucGFyZW50Qm91bmRpbmdDbGllbnRSZWN0LndpZHRoO1xuICB9XG4gIGVkaXRDb21tZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBbcG9zWCwgcG9zWV0gPSB0aGlzLiNwb3B1cFBvc2l0aW9uIHx8IHRoaXMuY29tbWVudEJ1dHRvblBvc2l0aW9uLm1hcCh4ID0+IHggLyAxMDApO1xuICAgIGNvbnN0IHBhcmVudERpbWVuc2lvbnMgPSB0aGlzLnBhcmVudEJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgICBjb25zdCB7XG4gICAgICB4OiBwYXJlbnRYLFxuICAgICAgeTogcGFyZW50WSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy4jY29tbWVudE1hbmFnZXIuc2hvd0RpYWxvZyhudWxsLCB0aGlzLCBwYXJlbnRYICsgcG9zWCAqIHBhcmVudFdpZHRoLCBwYXJlbnRZICsgcG9zWSAqIHBhcmVudEhlaWdodCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHBhcmVudERpbWVuc2lvbnNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuI3BvcHVwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBvcHVwID0gdGhpcy4jcG9wdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHBvcHVwLmNsYXNzTmFtZSA9IFwicG9wdXBcIjtcbiAgICBpZiAodGhpcy4jY29sb3IpIHtcbiAgICAgIGNvbnN0IGJhc2VDb2xvciA9IHBvcHVwLnN0eWxlLm91dGxpbmVDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLnRoaXMuI2NvbG9yKTtcbiAgICAgIHBvcHVwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGBjb2xvci1taXgoaW4gc3JnYiwgJHtiYXNlQ29sb3J9IDMwJSwgd2hpdGUpYDtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgaGVhZGVyLmNsYXNzTmFtZSA9IFwiaGVhZGVyXCI7XG4gICAgaWYgKHRoaXMuI3RpdGxlT2JqPy5zdHIpIHtcbiAgICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICB0aXRsZS5jbGFzc05hbWUgPSBcInRpdGxlXCI7XG4gICAgICBoZWFkZXIuYXBwZW5kKHRpdGxlKTtcbiAgICAgICh7XG4gICAgICAgIGRpcjogdGl0bGUuZGlyLFxuICAgICAgICBzdHI6IHRpdGxlLnRleHRDb250ZW50XG4gICAgICB9ID0gdGhpcy4jdGl0bGVPYmopO1xuICAgIH1cbiAgICBwb3B1cC5hcHBlbmQoaGVhZGVyKTtcbiAgICBpZiAodGhpcy4jZGF0ZU9iaikge1xuICAgICAgY29uc3QgbW9kaWZpY2F0aW9uRGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0aW1lXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5jbGFzc05hbWUgPSBcInBvcHVwRGF0ZVwiO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1hbm5vdGF0aW9uLWRhdGUtdGltZS1zdHJpbmdcIik7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZGF0ZU9iajogdGhpcy4jZGF0ZU9iai52YWx1ZU9mKClcbiAgICAgIH0pKTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuZGF0ZVRpbWUgPSB0aGlzLiNkYXRlT2JqLnRvSVNPU3RyaW5nKCk7XG4gICAgICBoZWFkZXIuYXBwZW5kKG1vZGlmaWNhdGlvbkRhdGUpO1xuICAgIH1cbiAgICByZW5kZXJSaWNoVGV4dCh7XG4gICAgICBodG1sOiB0aGlzLiNodG1sIHx8IHRoaXMuI2NvbnRlbnRzT2JqLnN0cixcbiAgICAgIGRpcjogdGhpcy4jY29udGVudHNPYmo/LmRpcixcbiAgICAgIGNsYXNzTmFtZTogXCJwb3B1cENvbnRlbnRcIlxuICAgIH0sIHBvcHVwKTtcbiAgICB0aGlzLiNjb250YWluZXIuYXBwZW5kKHBvcHVwKTtcbiAgfVxuICBnZXQgI2h0bWwoKSB7XG4gICAgY29uc3QgcmljaFRleHQgPSB0aGlzLiNyaWNoVGV4dDtcbiAgICBjb25zdCBjb250ZW50c09iaiA9IHRoaXMuI2NvbnRlbnRzT2JqO1xuICAgIGlmIChyaWNoVGV4dD8uc3RyICYmICghY29udGVudHNPYmo/LnN0ciB8fCBjb250ZW50c09iai5zdHIgPT09IHJpY2hUZXh0LnN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLiNyaWNoVGV4dC5odG1sIHx8IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCAjZm9udFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2h0bWw/LmF0dHJpYnV0ZXM/LnN0eWxlPy5mb250U2l6ZSB8fCAwO1xuICB9XG4gIGdldCAjZm9udENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLiNodG1sPy5hdHRyaWJ1dGVzPy5zdHlsZT8uY29sb3IgfHwgbnVsbDtcbiAgfVxuICAjbWFrZVBvcHVwQ29udGVudCh0ZXh0KSB7XG4gICAgY29uc3QgcG9wdXBMaW5lcyA9IFtdO1xuICAgIGNvbnN0IHBvcHVwQ29udGVudCA9IHtcbiAgICAgIHN0cjogdGV4dCxcbiAgICAgIGh0bWw6IHtcbiAgICAgICAgbmFtZTogXCJkaXZcIixcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIGRpcjogXCJhdXRvXCJcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgbmFtZTogXCJwXCIsXG4gICAgICAgICAgY2hpbGRyZW46IHBvcHVwTGluZXNcbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxpbmVBdHRyaWJ1dGVzID0ge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY29sb3I6IHRoaXMuI2ZvbnRDb2xvcixcbiAgICAgICAgZm9udFNpemU6IHRoaXMuI2ZvbnRTaXplID8gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpYCA6IFwiXCJcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgbGluZSBvZiB0ZXh0LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgICBwb3B1cExpbmVzLnB1c2goe1xuICAgICAgICBuYW1lOiBcInNwYW5cIixcbiAgICAgICAgdmFsdWU6IGxpbmUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGxpbmVBdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcHVwQ29udGVudDtcbiAgfVxuICAja2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC5hbHRLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiB8fCBldmVudC5rZXkgPT09IFwiRXNjYXBlXCIgJiYgdGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiN0b2dnbGUoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlRWRpdGVkKHtcbiAgICByZWN0LFxuICAgIHBvcHVwLFxuICAgIGRlbGV0ZWRcbiAgfSkge1xuICAgIGlmICh0aGlzLiNjb21tZW50TWFuYWdlcikge1xuICAgICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy4jY29tbWVudFRleHQgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChwb3B1cCkge1xuICAgICAgICBpZiAocG9wdXAuZGVsZXRlZCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4jdXBkYXRlQ29sb3IoKTtcbiAgICAgICAgICB0aGlzLiNjb21tZW50VGV4dCA9IHBvcHVwLnRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgIHRoaXMuI2NvbW1lbnRCdXR0b25Qb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuI3NldENvbW1lbnRCdXR0b25Qb3NpdGlvbigpO1xuICAgICAgICB0aGlzLiN1cGRhdGVDb21tZW50QnV0dG9uUG9zaXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlbGV0ZWQgfHwgcG9wdXA/LmRlbGV0ZWQpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy4jdXBkYXRlcyB8fD0ge1xuICAgICAgY29udGVudHNPYmo6IHRoaXMuI2NvbnRlbnRzT2JqLFxuICAgICAgcmljaFRleHQ6IHRoaXMuI3JpY2hUZXh0XG4gICAgfTtcbiAgICBpZiAocmVjdCkge1xuICAgICAgdGhpcy4jcG9zaXRpb24gPSBudWxsO1xuICAgIH1cbiAgICBpZiAocG9wdXAgJiYgcG9wdXAudGV4dCkge1xuICAgICAgdGhpcy4jcmljaFRleHQgPSB0aGlzLiNtYWtlUG9wdXBDb250ZW50KHBvcHVwLnRleHQpO1xuICAgICAgdGhpcy4jZGF0ZU9iaiA9IFBERkRhdGVTdHJpbmcudG9EYXRlT2JqZWN0KHBvcHVwLmRhdGUpO1xuICAgICAgdGhpcy4jY29udGVudHNPYmogPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNwb3B1cD8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jcG9wdXAgPSBudWxsO1xuICB9XG4gIHJlc2V0RWRpdGVkKCkge1xuICAgIGlmICghdGhpcy4jdXBkYXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoe1xuICAgICAgY29udGVudHNPYmo6IHRoaXMuI2NvbnRlbnRzT2JqLFxuICAgICAgcmljaFRleHQ6IHRoaXMuI3JpY2hUZXh0XG4gICAgfSA9IHRoaXMuI3VwZGF0ZXMpO1xuICAgIHRoaXMuI3VwZGF0ZXMgPSBudWxsO1xuICAgIHRoaXMuI3BvcHVwPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNwb3B1cCA9IG51bGw7XG4gICAgdGhpcy4jcG9zaXRpb24gPSBudWxsO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNwb3B1cEFib3J0Q29udHJvbGxlcj8uYWJvcnQoKTtcbiAgICB0aGlzLiNwb3B1cEFib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy4jcG9wdXA/LnJlbW92ZSgpO1xuICAgIHRoaXMuI3BvcHVwID0gbnVsbDtcbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy4jcGlubmVkID0gZmFsc2U7XG4gICAgdGhpcy4jY29tbWVudEJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jY29tbWVudEJ1dHRvbiA9IG51bGw7XG4gICAgaWYgKHRoaXMudHJpZ2dlcikge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudHJpZ2dlcikge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjc2V0UG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgdmlld1xuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICBwYWdlWVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXMuI3BhcmVudDtcbiAgICBsZXQgdXNlUGFyZW50UmVjdCA9ICEhdGhpcy4jcGFyZW50UmVjdDtcbiAgICBsZXQgcmVjdCA9IHVzZVBhcmVudFJlY3QgPyB0aGlzLiNwYXJlbnRSZWN0IDogdGhpcy4jcmVjdDtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy4jZWxlbWVudHMpIHtcbiAgICAgIGlmICghcmVjdCB8fCBVdGlsLmludGVyc2VjdChlbGVtZW50LmRhdGEucmVjdCwgcmVjdCkgIT09IG51bGwpIHtcbiAgICAgICAgcmVjdCA9IGVsZW1lbnQuZGF0YS5yZWN0O1xuICAgICAgICB1c2VQYXJlbnRSZWN0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRSZWN0ID0gVXRpbC5ub3JtYWxpemVSZWN0KFtyZWN0WzBdLCB2aWV3WzNdIC0gcmVjdFsxXSArIHZpZXdbMV0sIHJlY3RbMl0sIHZpZXdbM10gLSByZWN0WzNdICsgdmlld1sxXV0pO1xuICAgIGNvbnN0IEhPUklaT05UQUxfU1BBQ0VfQUZURVJfQU5OT1RBVElPTiA9IDU7XG4gICAgY29uc3QgcGFyZW50V2lkdGggPSB1c2VQYXJlbnRSZWN0ID8gcmVjdFsyXSAtIHJlY3RbMF0gKyBIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04gOiAwO1xuICAgIGNvbnN0IHBvcHVwTGVmdCA9IG5vcm1hbGl6ZWRSZWN0WzBdICsgcGFyZW50V2lkdGg7XG4gICAgY29uc3QgcG9wdXBUb3AgPSBub3JtYWxpemVkUmVjdFsxXTtcbiAgICB0aGlzLiNwb3NpdGlvbiA9IFsxMDAgKiAocG9wdXBMZWZ0IC0gcGFnZVgpIC8gcGFnZVdpZHRoLCAxMDAgKiAocG9wdXBUb3AgLSBwYWdlWSkgLyBwYWdlSGVpZ2h0XTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLiNjb250YWluZXI7XG4gICAgc3R5bGUubGVmdCA9IGAke3RoaXMuI3Bvc2l0aW9uWzBdfSVgO1xuICAgIHN0eWxlLnRvcCA9IGAke3RoaXMuI3Bvc2l0aW9uWzFdfSVgO1xuICB9XG4gICN0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuI2NvbW1lbnRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLiNjb21tZW50TWFuYWdlci50b2dnbGVDb21tZW50UG9wdXAodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNwaW5uZWQgPSAhdGhpcy4jcGlubmVkO1xuICAgIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI3Nob3coKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2hpZGUoKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfVxuICB9XG4gICNzaG93KCkge1xuICAgIGlmICghdGhpcy4jcG9wdXApIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgIHRoaXMuI3NldFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgICB0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4ID0gcGFyc2VJbnQodGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCkgKyAxMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZvY3VzZWRcIik7XG4gICAgfVxuICB9XG4gICNoaWRlKCkge1xuICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwiZm9jdXNlZFwiKTtcbiAgICBpZiAodGhpcy4jcGlubmVkIHx8ICF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICB0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4ID0gcGFyc2VJbnQodGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCkgLSAxMDAwO1xuICB9XG4gIGZvcmNlSGlkZSgpIHtcbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gdGhpcy5pc1Zpc2libGU7XG4gICAgaWYgKCF0aGlzLiN3YXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICB9XG4gIG1heWJlU2hvdygpIHtcbiAgICBpZiAodGhpcy4jY29tbWVudE1hbmFnZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNwb3B1cCkge1xuICAgICAgdGhpcy4jc2hvdygpO1xuICAgIH1cbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgaWYgKHRoaXMuI2NvbW1lbnRNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjb250YWluZXIuaGlkZGVuID09PSBmYWxzZTtcbiAgfVxufVxuY2xhc3MgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSBwYXJhbWV0ZXJzLmRhdGEudGV4dENvbnRlbnQ7XG4gICAgdGhpcy50ZXh0UG9zaXRpb24gPSBwYXJhbWV0ZXJzLmRhdGEudGV4dFBvc2l0aW9uO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZyZWVUZXh0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAodGhpcy50ZXh0Q29udGVudCkge1xuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uVGV4dENvbnRlbnRcIik7XG4gICAgICBjb250ZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjb21tZW50XCIpO1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgbGluZVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgbGluZVNwYW4udGV4dENvbnRlbnQgPSBsaW5lO1xuICAgICAgICBjb250ZW50LmFwcGVuZChsaW5lU3Bhbik7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoY29udGVudCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgTGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjbGluZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImxpbmVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuI2xpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpsaW5lXCIpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDFcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMF0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTFcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMV0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDJcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMl0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTJcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbM10pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xpbmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNzcXVhcmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVhcmVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IHNxdWFyZSA9IHRoaXMuI3NxdWFyZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInhcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwieVwiLCBib3JkZXJXaWR0aCAvIDIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQoc3F1YXJlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNzcXVhcmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNjaXJjbGUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaXJjbGVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IGNpcmNsZSA9IHRoaXMuI2NpcmNsZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmVsbGlwc2VcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN4XCIsIHdpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN5XCIsIGhlaWdodCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeFwiLCB3aWR0aCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeVwiLCBoZWlnaHQgLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQoY2lyY2xlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNjaXJjbGU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3BvbHlsaW5lID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJwb2x5bGluZUFubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWxpbmVcIjtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICByZWN0LFxuICAgICAgICB2ZXJ0aWNlcyxcbiAgICAgICAgYm9yZGVyU3R5bGUsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXZlcnRpY2VzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgbGV0IHBvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSB2ZXJ0aWNlc1tpXSAtIHJlY3RbMF07XG4gICAgICBjb25zdCB5ID0gcmVjdFszXSAtIHZlcnRpY2VzW2kgKyAxXTtcbiAgICAgIHBvaW50cy5wdXNoKGAke3h9LCR7eX1gKTtcbiAgICB9XG4gICAgcG9pbnRzID0gcG9pbnRzLmpvaW4oXCIgXCIpO1xuICAgIGNvbnN0IHBvbHlsaW5lID0gdGhpcy4jcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQocG9seWxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJwb2x5Z29uQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5Z29uXCI7XG4gIH1cbn1cbmNsYXNzIENhcmV0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNhcmV0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBJbmtBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3BvbHlsaW5lc0dyb3VwRWxlbWVudCA9IG51bGw7XG4gICNwb2x5bGluZXMgPSBbXTtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJpbmtBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IHRoaXMuZGF0YS5pdCA9PT0gXCJJbmtIaWdobGlnaHRcIiA/IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCA6IEFubm90YXRpb25FZGl0b3JUeXBlLklOSztcbiAgfVxuICAjZ2V0VHJhbnNmb3JtKHJvdGF0aW9uLCByZWN0KSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoOTApIHRyYW5zbGF0ZSgkey1yZWN0WzBdfSwke3JlY3RbMV19KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbM10gLSByZWN0WzFdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFsyXSAtIHJlY3RbMF1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgxODApIHRyYW5zbGF0ZSgkey1yZWN0WzJdfSwke3JlY3RbMV19KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbMl0gLSByZWN0WzBdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFszXSAtIHJlY3RbMV1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgyNzApIHRyYW5zbGF0ZSgkey1yZWN0WzJdfSwke3JlY3RbM119KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbM10gLSByZWN0WzFdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFsyXSAtIHJlY3RbMF1cbiAgICAgICAgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7LXJlY3RbMF19LCR7cmVjdFszXX0pIHNjYWxlKDEsLTEpYCxcbiAgICAgICAgICB3aWR0aDogcmVjdFsyXSAtIHJlY3RbMF0sXG4gICAgICAgICAgaGVpZ2h0OiByZWN0WzNdIC0gcmVjdFsxXVxuICAgICAgICB9O1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICByZWN0LFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgaW5rTGlzdHMsXG4gICAgICAgIGJvcmRlclN0eWxlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2dldFRyYW5zZm9ybShyb3RhdGlvbiwgcmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBnID0gdGhpcy4jcG9seWxpbmVzR3JvdXBFbGVtZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICBzdmcuYXBwZW5kKGcpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJyb3VuZFwiKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLW1pdGVybGltaXRcIiwgMTApO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbmtMaXN0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgICAgdGhpcy4jcG9seWxpbmVzLnB1c2gocG9seWxpbmUpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIGlua0xpc3RzW2ldLmpvaW4oXCIsXCIpKTtcbiAgICAgIGcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB9XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgdXBkYXRlRWRpdGVkKHBhcmFtcykge1xuICAgIHN1cGVyLnVwZGF0ZUVkaXRlZChwYXJhbXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHBvaW50cyxcbiAgICAgIHJlY3RcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGcgPSB0aGlzLiNwb2x5bGluZXNHcm91cEVsZW1lbnQ7XG4gICAgaWYgKHRoaWNrbmVzcyA+PSAwKSB7XG4gICAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCB0aGlja25lc3MgfHwgMSk7XG4gICAgfVxuICAgIGlmIChwb2ludHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuI3BvbHlsaW5lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHRoaXMuI3BvbHlsaW5lc1tpXS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzW2ldLmpvaW4oXCIsXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gdGhpcy4jZ2V0VHJhbnNmb3JtKHRoaXMuZGF0YS5yb3RhdGlvbiwgcmVjdCk7XG4gICAgICBjb25zdCByb290ID0gZy5wYXJlbnRFbGVtZW50O1xuICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCk7XG4gICAgICBnLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZXM7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQ7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgb3ZlcmxhaWRUZXh0LFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBbm5vdGF0aW9uXCIpO1xuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgY29uc3QgbWFyayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJtYXJrXCIpO1xuICAgICAgbWFyay5jbGFzc0xpc3QuYWRkKFwib3ZlcmxhaWRUZXh0XCIpO1xuICAgICAgbWFyay50ZXh0Q29udGVudCA9IG92ZXJsYWlkVGV4dDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChtYXJrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgb3ZlcmxhaWRUZXh0LFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ1bmRlcmxpbmVBbm5vdGF0aW9uXCIpO1xuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGNvbnN0IHVuZGVybGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1XCIpO1xuICAgICAgdW5kZXJsaW5lLmNsYXNzTGlzdC5hZGQoXCJvdmVybGFpZFRleHRcIik7XG4gICAgICB1bmRlcmxpbmUudGV4dENvbnRlbnQgPSBvdmVybGFpZFRleHQ7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQodW5kZXJsaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICBvdmVybGFpZFRleHQsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInNxdWlnZ2x5QW5ub3RhdGlvblwiKTtcbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBjb25zdCB1bmRlcmxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidVwiKTtcbiAgICAgIHVuZGVybGluZS5jbGFzc0xpc3QuYWRkKFwib3ZlcmxhaWRUZXh0XCIpO1xuICAgICAgdW5kZXJsaW5lLnRleHRDb250ZW50ID0gb3ZlcmxhaWRUZXh0O1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHVuZGVybGluZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIG92ZXJsYWlkVGV4dCxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3RyaWtlb3V0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBjb25zdCBzdHJpa2VvdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic1wiKTtcbiAgICAgIHN0cmlrZW91dC5jbGFzc0xpc3QuYWRkKFwib3ZlcmxhaWRUZXh0XCIpO1xuICAgICAgc3RyaWtlb3V0LnRleHRDb250ZW50ID0gb3ZlcmxhaWRUZXh0O1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN0cmlrZW91dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0YW1wQW5ub3RhdGlvblwiKTtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiaW1nXCIpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3RyaWdnZXIgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgZmlsZVxuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgdGhpcy5maWxlbmFtZSA9IGZpbGUuZmlsZW5hbWU7XG4gICAgdGhpcy5jb250ZW50ID0gZmlsZS5jb250ZW50O1xuICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZmlsZWF0dGFjaG1lbnRhbm5vdGF0aW9uXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIC4uLmZpbGVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZpbGVBdHRhY2htZW50QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXIsXG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHRyaWdnZXI7XG4gICAgaWYgKGRhdGEuaGFzQXBwZWFyYW5jZSB8fCBkYXRhLmZpbGxBbHBoYSA9PT0gMCkge1xuICAgICAgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgdHJpZ2dlci5zcmMgPSBgJHt0aGlzLmltYWdlUmVzb3VyY2VzUGF0aH1hbm5vdGF0aW9uLSR7L3BhcGVyY2xpcC9pLnRlc3QoZGF0YS5uYW1lKSA/IFwicGFwZXJjbGlwXCIgOiBcInB1c2hwaW5cIn0uc3ZnYDtcbiAgICAgIGlmIChkYXRhLmZpbGxBbHBoYSAmJiBkYXRhLmZpbGxBbHBoYSA8IDEpIHtcbiAgICAgICAgdHJpZ2dlci5zdHlsZSA9IGBmaWx0ZXI6IG9wYWNpdHkoJHtNYXRoLnJvdW5kKGRhdGEuZmlsbEFscGhhICogMTAwKX0lKTtgO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCB0aGlzLiNkb3dubG9hZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLiN0cmlnZ2VyID0gdHJpZ2dlcjtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldnQgPT4ge1xuICAgICAgaWYgKGV2dC5rZXkgPT09IFwiRW50ZXJcIiAmJiAoaXNNYWMgPyBldnQubWV0YUtleSA6IGV2dC5jdHJsS2V5KSkge1xuICAgICAgICB0aGlzLiNkb3dubG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlci5jbGFzc0xpc3QuYWRkKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICB9XG4gICAgY29udGFpbmVyLmFwcGVuZCh0cmlnZ2VyKTtcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RyaWdnZXI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxuICAjZG93bmxvYWQoKSB7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXI/Lm9wZW5PckRvd25sb2FkRGF0YSh0aGlzLmNvbnRlbnQsIHRoaXMuZmlsZW5hbWUpO1xuICB9XG59XG5jbGFzcyBBbm5vdGF0aW9uTGF5ZXIge1xuICAjYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBudWxsO1xuICAjYW5ub3RhdGlvbkNhbnZhc01hcCA9IG51bGw7XG4gICNhbm5vdGF0aW9uU3RvcmFnZSA9IG51bGw7XG4gICNlZGl0YWJsZUFubm90YXRpb25zID0gbmV3IE1hcCgpO1xuICAjc3RydWN0VHJlZUxheWVyID0gbnVsbDtcbiAgI2xpbmtTZXJ2aWNlID0gbnVsbDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRpdixcbiAgICBhY2Nlc3NpYmlsaXR5TWFuYWdlcixcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgIGFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIsXG4gICAgcGFnZSxcbiAgICB2aWV3cG9ydCxcbiAgICBzdHJ1Y3RUcmVlTGF5ZXIsXG4gICAgY29tbWVudE1hbmFnZXIsXG4gICAgbGlua1NlcnZpY2UsXG4gICAgYW5ub3RhdGlvblN0b3JhZ2VcbiAgfSkge1xuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy4jc3RydWN0VHJlZUxheWVyID0gc3RydWN0VHJlZUxheWVyIHx8IG51bGw7XG4gICAgdGhpcy4jbGlua1NlcnZpY2UgPSBsaW5rU2VydmljZSB8fCBudWxsO1xuICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlID0gYW5ub3RhdGlvblN0b3JhZ2UgfHwgbmV3IEFubm90YXRpb25TdG9yYWdlKCk7XG4gICAgdGhpcy5wYWdlID0gcGFnZTtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgdGhpcy56SW5kZXggPSAwO1xuICAgIHRoaXMuX2Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXIgPSBhbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyO1xuICAgIHRoaXMuX2NvbW1lbnRNYW5hZ2VyID0gY29tbWVudE1hbmFnZXIgfHwgbnVsbDtcbiAgfVxuICBoYXNFZGl0YWJsZUFubm90YXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnNpemUgPiAwO1xuICB9XG4gIGFzeW5jICNhcHBlbmRFbGVtZW50KGVsZW1lbnQsIGlkLCBwb3B1cEVsZW1lbnRzKSB7XG4gICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBlbGVtZW50LmZpcnN0Q2hpbGQgfHwgZWxlbWVudDtcbiAgICBjb25zdCBhbm5vdGF0aW9uSWQgPSBjb250ZW50RWxlbWVudC5pZCA9IGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gO1xuICAgIGNvbnN0IGFyaWFBdHRyaWJ1dGVzID0gYXdhaXQgdGhpcy4jc3RydWN0VHJlZUxheWVyPy5nZXRBcmlhQXR0cmlidXRlcyhhbm5vdGF0aW9uSWQpO1xuICAgIGlmIChhcmlhQXR0cmlidXRlcykge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXJpYUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29udGVudEVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocG9wdXBFbGVtZW50cykge1xuICAgICAgcG9wdXBFbGVtZW50cy5hdCgtMSkuY29udGFpbmVyLmFmdGVyKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZWxlbWVudCk7XG4gICAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ubW92ZUVsZW1lbnRJbkRPTSh0aGlzLmRpdiwgZWxlbWVudCwgY29udGVudEVsZW1lbnQsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVuZGVyKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25zXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIHNldExheWVyRGltZW5zaW9ucyhsYXllciwgdGhpcy52aWV3cG9ydCk7XG4gICAgY29uc3QgcG9wdXBUb0VsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGVsZW1lbnRQYXJhbXMgPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgbGF5ZXIsXG4gICAgICBsaW5rU2VydmljZTogdGhpcy4jbGlua1NlcnZpY2UsXG4gICAgICBkb3dubG9hZE1hbmFnZXI6IHBhcmFtcy5kb3dubG9hZE1hbmFnZXIsXG4gICAgICBpbWFnZVJlc291cmNlc1BhdGg6IHBhcmFtcy5pbWFnZVJlc291cmNlc1BhdGggfHwgXCJcIixcbiAgICAgIHJlbmRlckZvcm1zOiBwYXJhbXMucmVuZGVyRm9ybXMgIT09IGZhbHNlLFxuICAgICAgc3ZnRmFjdG9yeTogbmV3IERPTVNWR0ZhY3RvcnkoKSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSxcbiAgICAgIGVuYWJsZUNvbW1lbnQ6IHBhcmFtcy5lbmFibGVDb21tZW50ID09PSB0cnVlLFxuICAgICAgZW5hYmxlU2NyaXB0aW5nOiBwYXJhbXMuZW5hYmxlU2NyaXB0aW5nID09PSB0cnVlLFxuICAgICAgaGFzSlNBY3Rpb25zOiBwYXJhbXMuaGFzSlNBY3Rpb25zLFxuICAgICAgZmllbGRPYmplY3RzOiBwYXJhbXMuZmllbGRPYmplY3RzLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgZWxlbWVudHM6IG51bGxcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZGF0YSBvZiBhbm5vdGF0aW9ucykge1xuICAgICAgaWYgKGRhdGEubm9IVE1MKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNQb3B1cEFubm90YXRpb24gPSBkYXRhLmFubm90YXRpb25UeXBlID09PSBBbm5vdGF0aW9uVHlwZS5QT1BVUDtcbiAgICAgIGlmICghaXNQb3B1cEFubm90YXRpb24pIHtcbiAgICAgICAgaWYgKGRhdGEucmVjdFsyXSA9PT0gZGF0YS5yZWN0WzBdIHx8IGRhdGEucmVjdFszXSA9PT0gZGF0YS5yZWN0WzFdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcG9wdXBUb0VsZW1lbnRzLmdldChkYXRhLmlkKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRQYXJhbXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRQYXJhbXMuZGF0YSA9IGRhdGE7XG4gICAgICBjb25zdCBlbGVtZW50ID0gQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5LmNyZWF0ZShlbGVtZW50UGFyYW1zKTtcbiAgICAgIGlmICghZWxlbWVudC5pc1JlbmRlcmFibGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUG9wdXBBbm5vdGF0aW9uICYmIGRhdGEucG9wdXBSZWYpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBwb3B1cFRvRWxlbWVudHMuZ2V0KGRhdGEucG9wdXBSZWYpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICAgICAgcG9wdXBUb0VsZW1lbnRzLnNldChkYXRhLnBvcHVwUmVmLCBbZWxlbWVudF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlcmVkID0gZWxlbWVudC5yZW5kZXIoKTtcbiAgICAgIGlmIChkYXRhLmhpZGRlbikge1xuICAgICAgICByZW5kZXJlZC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuI2FwcGVuZEVsZW1lbnQocmVuZGVyZWQsIGRhdGEuaWQsIGVsZW1lbnRQYXJhbXMuZWxlbWVudHMpO1xuICAgICAgZWxlbWVudC5leHRyYVBvcHVwRWxlbWVudD8ucG9wdXA/LnJlbmRlckNvbW1lbnRCdXR0b24oKTtcbiAgICAgIGlmIChlbGVtZW50Ll9pc0VkaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuc2V0KGVsZW1lbnQuZGF0YS5pZCwgZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXI/LnJlbmRlckFubm90YXRpb25FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCk7XG4gIH1cbiAgYXN5bmMgYWRkTGlua0Fubm90YXRpb25zKGFubm90YXRpb25zKSB7XG4gICAgY29uc3QgZWxlbWVudFBhcmFtcyA9IHtcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgICBsYXllcjogdGhpcy5kaXYsXG4gICAgICBsaW5rU2VydmljZTogdGhpcy4jbGlua1NlcnZpY2UsXG4gICAgICBzdmdGYWN0b3J5OiBuZXcgRE9NU1ZHRmFjdG9yeSgpLFxuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGRhdGEgb2YgYW5ub3RhdGlvbnMpIHtcbiAgICAgIGRhdGEuYm9yZGVyU3R5bGUgfHw9IEFubm90YXRpb25MYXllci5fZGVmYXVsdEJvcmRlclN0eWxlO1xuICAgICAgZWxlbWVudFBhcmFtcy5kYXRhID0gZGF0YTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBBbm5vdGF0aW9uRWxlbWVudEZhY3RvcnkuY3JlYXRlKGVsZW1lbnRQYXJhbXMpO1xuICAgICAgaWYgKCFlbGVtZW50LmlzUmVuZGVyYWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlcmVkID0gZWxlbWVudC5yZW5kZXIoKTtcbiAgICAgIGF3YWl0IHRoaXMuI2FwcGVuZEVsZW1lbnQocmVuZGVyZWQsIGRhdGEuaWQsIG51bGwpO1xuICAgIH1cbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICBzZXRMYXllckRpbWVuc2lvbnMobGF5ZXIsIHtcbiAgICAgIHJvdGF0aW9uOiB2aWV3cG9ydC5yb3RhdGlvblxuICAgIH0pO1xuICAgIHRoaXMuI3NldEFubm90YXRpb25DYW52YXNNYXAoKTtcbiAgICBsYXllci5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICAjc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpIHtcbiAgICBpZiAoIXRoaXMuI2Fubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICBmb3IgKGNvbnN0IFtpZCwgY2FudmFzXSBvZiB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gbGF5ZXIucXVlcnlTZWxlY3RvcihgW2RhdGEtYW5ub3RhdGlvbi1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjYW52YXMuY2xhc3NOYW1lID0gXCJhbm5vdGF0aW9uQ29udGVudFwiO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaXJzdENoaWxkXG4gICAgICB9ID0gZWxlbWVudDtcbiAgICAgIGlmICghZmlyc3RDaGlsZCkge1xuICAgICAgICBlbGVtZW50LmFwcGVuZChjYW52YXMpO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdENoaWxkLm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQucmVwbGFjZVdpdGgoY2FudmFzKTtcbiAgICAgIH0gZWxzZSBpZiAoIWZpcnN0Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYW5ub3RhdGlvbkNvbnRlbnRcIikpIHtcbiAgICAgICAgZmlyc3RDaGlsZC5iZWZvcmUoY2FudmFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuYWZ0ZXIoY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkaXRhYmxlQW5ub3RhdGlvbiA9IHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgICAgIGlmICghZWRpdGFibGVBbm5vdGF0aW9uKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRhYmxlQW5ub3RhdGlvbi5faGFzTm9DYW52YXMpIHtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcj8uc2V0TWlzc2luZ0NhbnZhcyhpZCwgZWxlbWVudC5pZCwgY2FudmFzKTtcbiAgICAgICAgZWRpdGFibGVBbm5vdGF0aW9uLl9oYXNOb0NhbnZhcyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdGFibGVBbm5vdGF0aW9uLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcC5jbGVhcigpO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy52YWx1ZXMoKSk7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgfVxuICBhZGRGYWtlQW5ub3RhdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXZcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICBjb25zdCBlbGVtZW50ID0gbmV3IEVkaXRvckFubm90YXRpb25FbGVtZW50KHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHJlY3Q6IGVkaXRvci5nZXRQREZSZWN0KCksXG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9LFxuICAgICAgZWRpdG9yLFxuICAgICAgbGF5ZXI6IGRpdixcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGVuYWJsZUNvbW1lbnQ6ICEhdGhpcy5fY29tbWVudE1hbmFnZXIsXG4gICAgICBsaW5rU2VydmljZTogdGhpcy4jbGlua1NlcnZpY2UsXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2VcbiAgICB9KTtcbiAgICBjb25zdCBodG1sRWxlbWVudCA9IGVsZW1lbnQucmVuZGVyKCk7XG4gICAgZGl2LmFwcGVuZChodG1sRWxlbWVudCk7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00oZGl2LCBodG1sRWxlbWVudCwgaHRtbEVsZW1lbnQsIGZhbHNlKTtcbiAgICBlbGVtZW50LmNyZWF0ZU9yVXBkYXRlUG9wdXAoKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBzdGF0aWMgZ2V0IF9kZWZhdWx0Qm9yZGVyU3R5bGUoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9kZWZhdWx0Qm9yZGVyU3R5bGVcIiwgT2JqZWN0LmZyZWV6ZSh7XG4gICAgICB3aWR0aDogMSxcbiAgICAgIHJhd1dpZHRoOiAxLFxuICAgICAgc3R5bGU6IEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuU09MSUQsXG4gICAgICBkYXNoQXJyYXk6IFszXSxcbiAgICAgIGhvcml6b250YWxDb3JuZXJSYWRpdXM6IDAsXG4gICAgICB2ZXJ0aWNhbENvcm5lclJhZGl1czogMFxuICAgIH0pKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZnJlZXRleHQuanNcblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IEVPTF9QQVRURVJOID0gL1xcclxcbj98XFxuL2c7XG5jbGFzcyBGcmVlVGV4dEVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjY29udGVudCA9IFwiXCI7XG4gICNlZGl0b3JEaXZJZCA9IGAke3RoaXMuaWR9LWVkaXRvcmA7XG4gICNlZGl0TW9kZUFDID0gbnVsbDtcbiAgI2ZvbnRTaXplO1xuICBfY29sb3JQaWNrZXIgPSBudWxsO1xuICBzdGF0aWMgX2ZyZWVUZXh0RGVmYXVsdENvbnRlbnQgPSBcIlwiO1xuICBzdGF0aWMgX2ludGVybmFsUGFkZGluZyA9IDA7XG4gIHN0YXRpYyBfZGVmYXVsdENvbG9yID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0Rm9udFNpemUgPSAxMDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gRnJlZVRleHRFZGl0b3IucHJvdG90eXBlO1xuICAgIGNvbnN0IGFycm93Q2hlY2tlciA9IHNlbGYgPT4gc2VsZi5pc0VtcHR5KCk7XG4gICAgY29uc3Qgc21hbGwgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9rZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcImN0cmwrc1wiLCBcIm1hYyttZXRhK3NcIiwgXCJjdHJsK3BcIiwgXCJtYWMrbWV0YStwXCJdLCBwcm90by5jb21taXRPclJlbW92ZSwge1xuICAgICAgYnViYmxlczogdHJ1ZVxuICAgIH1dLCBbW1wiY3RybCtFbnRlclwiLCBcIm1hYyttZXRhK0VudGVyXCIsIFwiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgcHJvdG8uY29tbWl0T3JSZW1vdmVdLCBbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbLXNtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0xlZnRcIiwgXCJtYWMrc2hpZnQrQXJyb3dMZWZ0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFstYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFtzbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dSaWdodFwiLCBcIm1hYytzaGlmdCtBcnJvd1JpZ2h0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFtiaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIC1zbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dVcFwiLCBcIm1hYytzaGlmdCtBcnJvd1VwXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCAtYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93RG93blwiLCBcIm1hYytzaGlmdCtBcnJvd0Rvd25cIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIGJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XV0pKTtcbiAgfVxuICBzdGF0aWMgX3R5cGUgPSBcImZyZWV0ZXh0XCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImZyZWVUZXh0RWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yIHx8IEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcjtcbiAgICB0aGlzLiNmb250U2l6ZSA9IHBhcmFtcy5mb250U2l6ZSB8fCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplO1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYTExeUFsZXJ0KFwicGRmanMtZWRpdG9yLWZyZWV0ZXh0LWFkZGVkLWFsZXJ0XCIpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICB0aGlzLl9pbnRlcm5hbFBhZGRpbmcgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLWZyZWV0ZXh0LXBhZGRpbmdcIikpO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemUgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SOlxuICAgICAgICBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRTpcbiAgICAgICAgdGhpcy4jdXBkYXRlRm9udFNpemUodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yIHx8IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdXTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsIHRoaXMuI2ZvbnRTaXplXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLCB0aGlzLmNvbG9yXV07XG4gIH1cbiAgZ2V0IHRvb2xiYXJCdXR0b25zKCkge1xuICAgIHRoaXMuX2NvbG9yUGlja2VyIHx8PSBuZXcgQmFzaWNDb2xvclBpY2tlcih0aGlzKTtcbiAgICByZXR1cm4gW1tcImNvbG9yUGlja2VyXCIsIHRoaXMuX2NvbG9yUGlja2VyXV07XG4gIH1cbiAgZ2V0IGNvbG9yVHlwZSgpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I7XG4gIH1cbiAgI3VwZGF0ZUZvbnRTaXplKGZvbnRTaXplKSB7XG4gICAgY29uc3Qgc2V0Rm9udHNpemUgPSBzaXplID0+IHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LnN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHtzaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgdGhpcy50cmFuc2xhdGUoMCwgLShzaXplIC0gdGhpcy4jZm9udFNpemUpICogdGhpcy5wYXJlbnRTY2FsZSk7XG4gICAgICB0aGlzLiNmb250U2l6ZSA9IHNpemU7XG4gICAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICBjb25zdCBzYXZlZEZvbnRzaXplID0gdGhpcy4jZm9udFNpemU7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldEZvbnRzaXplLmJpbmQodGhpcywgZm9udFNpemUpLFxuICAgICAgdW5kbzogc2V0Rm9udHNpemUuYmluZCh0aGlzLCBzYXZlZEZvbnRzaXplKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICBvblVwZGF0ZWRDb2xvcigpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zdHlsZS5jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgdGhpcy5fY29sb3JQaWNrZXI/LnVwZGF0ZSh0aGlzLmNvbG9yKTtcbiAgICBzdXBlci5vblVwZGF0ZWRDb2xvcigpO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNldENvbG9yID0gY29sID0+IHtcbiAgICAgIHRoaXMuY29sb3IgPSBjb2w7XG4gICAgICB0aGlzLm9uVXBkYXRlZENvbG9yKCk7XG4gICAgfTtcbiAgICBjb25zdCBzYXZlZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0Q29sb3IuYmluZCh0aGlzLCBjb2xvciksXG4gICAgICB1bmRvOiBzZXRDb2xvci5iaW5kKHRoaXMsIHNhdmVkQ29sb3IpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICBfdHJhbnNsYXRlRW1wdHkoeCwgeSkge1xuICAgIHRoaXMuX3VpTWFuYWdlci50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMoeCwgeSwgdHJ1ZSk7XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5wYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gWy1GcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogc2NhbGUsIC0oRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyArIHRoaXMuI2ZvbnRTaXplKSAqIHNjYWxlXTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICghc3VwZXIuZW5hYmxlRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LnJlbW92ZShcImVuYWJsZWRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGl2LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKTtcbiAgICB0aGlzLiNlZGl0TW9kZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNlZGl0TW9kZUFDKTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmVkaXRvckRpdktleWRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuZWRpdG9yRGl2Rm9jdXMuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5lZGl0b3JEaXZCbHVyLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLmVkaXRvckRpdklucHV0LmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCB0aGlzLmVkaXRvckRpdlBhc3RlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXN1cGVyLmRpc2FibGVFZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QuYWRkKFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgdGhpcy4jZWRpdG9yRGl2SWQpO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLiNlZGl0TW9kZUFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2VkaXRNb2RlQUMgPSBudWxsO1xuICAgIHRoaXMuZGl2LmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZXRleHRFZGl0aW5nXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5mb2N1c2luKGV2ZW50KTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmVkaXRvckRpdikge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2luaXRpYWxPcHRpb25zPy5pc0NlbnRlcmVkKSB7XG4gICAgICB0aGlzLmNlbnRlcigpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZWRpdG9yRGl2IHx8IHRoaXMuZWRpdG9yRGl2LmlubmVyVGV4dC50cmltKCkgPT09IFwiXCI7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWV0ZXh0RWRpdGluZ1wiKTtcbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgI2V4dHJhY3RUZXh0KCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuZWRpdG9yRGl2Lm5vcm1hbGl6ZSgpO1xuICAgIGxldCBwcmV2Q2hpbGQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgaWYgKHByZXZDaGlsZD8ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIGNoaWxkLm5vZGVOYW1lID09PSBcIkJSXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgIHByZXZDaGlsZCA9IGNoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgI3NldEVkaXRvckRpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGxldCByZWN0O1xuICAgIGlmICh0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmVjdCA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGN1cnJlbnRMYXllcixcbiAgICAgICAgZGl2XG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHNhdmVkRGlzcGxheSA9IGRpdi5zdHlsZS5kaXNwbGF5O1xuICAgICAgY29uc3Qgc2F2ZWRWaXNpYmlsaXR5ID0gZGl2LmNsYXNzTGlzdC5jb250YWlucyhcImhpZGRlblwiKTtcbiAgICAgIGRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBcImhpZGRlblwiO1xuICAgICAgY3VycmVudExheWVyLmRpdi5hcHBlbmQodGhpcy5kaXYpO1xuICAgICAgcmVjdCA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGRpdi5yZW1vdmUoKTtcbiAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gc2F2ZWREaXNwbGF5O1xuICAgICAgZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIiwgc2F2ZWRWaXNpYmlsaXR5KTtcbiAgICB9XG4gICAgaWYgKHRoaXMucm90YXRpb24gJSAxODAgPT09IHRoaXMucGFyZW50Um90YXRpb24gJSAxODApIHtcbiAgICAgIHRoaXMud2lkdGggPSByZWN0LndpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHJlY3QuaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gcmVjdC5oZWlnaHQgLyBwYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC53aWR0aCAvIHBhcmVudEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGNvbW1pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICBjb25zdCBzYXZlZFRleHQgPSB0aGlzLiNjb250ZW50O1xuICAgIGNvbnN0IG5ld1RleHQgPSB0aGlzLiNjb250ZW50ID0gdGhpcy4jZXh0cmFjdFRleHQoKS50cmltRW5kKCk7XG4gICAgaWYgKHNhdmVkVGV4dCA9PT0gbmV3VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZXRUZXh0ID0gdGV4dCA9PiB7XG4gICAgICB0aGlzLiNjb250ZW50ID0gdGV4dDtcbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVidWlsZCh0aGlzKTtcbiAgICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHNldFRleHQobmV3VGV4dCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICBzZXRUZXh0KHNhdmVkVGV4dCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzSW5FZGl0TW9kZSgpO1xuICB9XG4gIGVudGVySW5FZGl0TW9kZSgpIHtcbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgfVxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5kaXYgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgIHRoaXMuZW50ZXJJbkVkaXRNb2RlKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBlZGl0b3JEaXZLZXlkb3duKGV2ZW50KSB7XG4gICAgRnJlZVRleHRFZGl0b3IuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICBlZGl0b3JEaXZGb2N1cyhldmVudCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcbiAgfVxuICBlZGl0b3JEaXZCbHVyKGV2ZW50KSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgfVxuICBlZGl0b3JEaXZJbnB1dChldmVudCkge1xuICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZnJlZXRleHRFZGl0aW5nXCIsIHRoaXMuaXNFbXB0eSgpKTtcbiAgfVxuICBkaXNhYmxlRWRpdGluZygpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tbWVudFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW11bHRpbGluZVwiKTtcbiAgfVxuICBlbmFibGVFZGl0aW5nKCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0ZXh0Ym94XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbXVsdGlsaW5lXCIsIHRydWUpO1xuICB9XG4gIGdldCBjYW5DaGFuZ2VDb250ZW50KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy5faXNDb3B5IHx8IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxcIjtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0aGlzLiNlZGl0b3JEaXZJZCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZnJlZS10ZXh0MlwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXR0cnNcIiwgXCJkZWZhdWx0LWNvbnRlbnRcIik7XG4gICAgdGhpcy5lbmFibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmVkaXRvckRpdjtcbiAgICBzdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7dGhpcy4jZm9udFNpemV9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgc3R5bGUuY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLmVkaXRvckRpdik7XG4gICAgdGhpcy5vdmVybGF5RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LmFkZChcIm92ZXJsYXlcIiwgXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLm92ZXJsYXlEaXYpO1xuICAgIGlmICh0aGlzLl9pc0NvcHkgfHwgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICB9ID0gdGhpcy5faW5pdGlhbERhdGE7XG4gICAgICAgIGxldCBbdHgsIHR5XSA9IHRoaXMuZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCk7XG4gICAgICAgIFt0eCwgdHldID0gdGhpcy5wYWdlVHJhbnNsYXRpb25Ub1NjcmVlbih0eCwgdHkpO1xuICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgICAgIGxldCBwb3NYLCBwb3NZO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgKyB0aGlzLmhlaWdodCAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZIC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gW3R5LCAtdHhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxODA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggLSB0aGlzLndpZHRoICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZIC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gWy10eCwgLXR5XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjcwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVggLSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZICsgKHBvc2l0aW9uWzFdIC0gcGFnZVkgLSB0aGlzLndpZHRoICogcGFnZVdpZHRoKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFstdHksIHR4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QXQocG9zWCAqIHBhcmVudFdpZHRoLCBwb3NZICogcGFyZW50SGVpZ2h0LCB0eCwgdHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbW92ZUFmdGVyUGFzdGUoYmFzZVgsIGJhc2VZKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NldENvbnRlbnQoKTtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHN0YXRpYyAjZ2V0Tm9kZUNvbnRlbnQobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgPyBub2RlLm5vZGVWYWx1ZSA6IG5vZGUuaW5uZXJUZXh0KS5yZXBsYWNlQWxsKEVPTF9QQVRURVJOLCBcIlwiKTtcbiAgfVxuICBlZGl0b3JEaXZQYXN0ZShldmVudCkge1xuICAgIGNvbnN0IGNsaXBib2FyZERhdGEgPSBldmVudC5jbGlwYm9hcmREYXRhIHx8IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVzXG4gICAgfSA9IGNsaXBib2FyZERhdGE7XG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSAmJiB0eXBlc1swXSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBwYXN0ZSA9IEZyZWVUZXh0RWRpdG9yLiNkZXNlcmlhbGl6ZUNvbnRlbnQoY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dFwiKSB8fCBcIlwiKS5yZXBsYWNlQWxsKEVPTF9QQVRURVJOLCBcIlxcblwiKTtcbiAgICBpZiAoIXBhc3RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbi5yYW5nZUNvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZWRpdG9yRGl2Lm5vcm1hbGl6ZSgpO1xuICAgIHNlbGVjdGlvbi5kZWxldGVGcm9tRG9jdW1lbnQoKTtcbiAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgIGlmICghcGFzdGUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgIHJhbmdlLmluc2VydE5vZGUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGFzdGUpKTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2Lm5vcm1hbGl6ZSgpO1xuICAgICAgc2VsZWN0aW9uLmNvbGxhcHNlVG9TdGFydCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdGFydENvbnRhaW5lcixcbiAgICAgIHN0YXJ0T2Zmc2V0XG4gICAgfSA9IHJhbmdlO1xuICAgIGNvbnN0IGJ1ZmZlckJlZm9yZSA9IFtdO1xuICAgIGNvbnN0IGJ1ZmZlckFmdGVyID0gW107XG4gICAgaWYgKHN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gc3RhcnRDb250YWluZXIucGFyZW50RWxlbWVudDtcbiAgICAgIGJ1ZmZlckFmdGVyLnB1c2goc3RhcnRDb250YWluZXIubm9kZVZhbHVlLnNsaWNlKHN0YXJ0T2Zmc2V0KS5yZXBsYWNlQWxsKEVPTF9QQVRURVJOLCBcIlwiKSk7XG4gICAgICBpZiAocGFyZW50ICE9PSB0aGlzLmVkaXRvckRpdikge1xuICAgICAgICBsZXQgYnVmZmVyID0gYnVmZmVyQmVmb3JlO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoY2hpbGQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyQWZ0ZXI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmZmVyLnB1c2goRnJlZVRleHRFZGl0b3IuI2dldE5vZGVDb250ZW50KGNoaWxkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ1ZmZlckJlZm9yZS5wdXNoKHN0YXJ0Q29udGFpbmVyLm5vZGVWYWx1ZS5zbGljZSgwLCBzdGFydE9mZnNldCkucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcIikpO1xuICAgIH0gZWxzZSBpZiAoc3RhcnRDb250YWluZXIgPT09IHRoaXMuZWRpdG9yRGl2KSB7XG4gICAgICBsZXQgYnVmZmVyID0gYnVmZmVyQmVmb3JlO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmVkaXRvckRpdi5jaGlsZE5vZGVzKSB7XG4gICAgICAgIGlmIChpKysgPT09IHN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgYnVmZmVyID0gYnVmZmVyQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnB1c2goRnJlZVRleHRFZGl0b3IuI2dldE5vZGVDb250ZW50KGNoaWxkKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbnRlbnQgPSBgJHtidWZmZXJCZWZvcmUuam9pbihcIlxcblwiKX0ke3Bhc3RlfSR7YnVmZmVyQWZ0ZXIuam9pbihcIlxcblwiKX1gO1xuICAgIHRoaXMuI3NldENvbnRlbnQoKTtcbiAgICBjb25zdCBuZXdSYW5nZSA9IG5ldyBSYW5nZSgpO1xuICAgIGxldCBiZWZvcmVMZW5ndGggPSBNYXRoLnN1bVByZWNpc2UoYnVmZmVyQmVmb3JlLm1hcChsaW5lID0+IGxpbmUubGVuZ3RoKSk7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBmaXJzdENoaWxkXG4gICAgfSBvZiB0aGlzLmVkaXRvckRpdi5jaGlsZE5vZGVzKSB7XG4gICAgICBpZiAoZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZmlyc3RDaGlsZC5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICBpZiAoYmVmb3JlTGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgICAgIG5ld1JhbmdlLnNldFN0YXJ0KGZpcnN0Q2hpbGQsIGJlZm9yZUxlbmd0aCk7XG4gICAgICAgICAgbmV3UmFuZ2Uuc2V0RW5kKGZpcnN0Q2hpbGQsIGJlZm9yZUxlbmd0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYmVmb3JlTGVuZ3RoIC09IGxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbGVjdGlvbi5hZGRSYW5nZShuZXdSYW5nZSk7XG4gIH1cbiAgI3NldENvbnRlbnQoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVwbGFjZUNoaWxkcmVuKCk7XG4gICAgaWYgKCF0aGlzLiNjb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLiNjb250ZW50LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmFwcGVuZChsaW5lID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuYXBwZW5kKGRpdik7XG4gICAgfVxuICB9XG4gICNzZXJpYWxpemVDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNjb250ZW50LnJlcGxhY2VBbGwoXCJcXHhhMFwiLCBcIiBcIik7XG4gIH1cbiAgc3RhdGljICNkZXNlcmlhbGl6ZUNvbnRlbnQoY29udGVudCkge1xuICAgIHJldHVybiBjb250ZW50LnJlcGxhY2VBbGwoXCIgXCIsIFwiXFx4YTBcIik7XG4gIH1cbiAgZ2V0IGNvbnRlbnREaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yRGl2O1xuICB9XG4gIGdldFBERlJlY3QoKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiB0aGlzLnBhcmVudFNjYWxlO1xuICAgIHJldHVybiB0aGlzLmdldFJlY3QocGFkZGluZywgcGFkZGluZyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRlZmF1bHRBcHBlYXJhbmNlRGF0YToge1xuICAgICAgICAgICAgZm9udFNpemUsXG4gICAgICAgICAgICBmb250Q29sb3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgcmljaFRleHQsXG4gICAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgIHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpZiAoIXRleHRDb250ZW50IHx8IHRleHRDb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhULFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShmb250Q29sb3IpLFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgdmFsdWU6IHRleHRDb250ZW50LmpvaW4oXCJcXG5cIiksXG4gICAgICAgIHBvc2l0aW9uOiB0ZXh0UG9zaXRpb24sXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBpZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgY29tbWVudDogY29udGVudHNPYmo/LnN0ciB8fCBudWxsLFxuICAgICAgICByaWNoVGV4dCxcbiAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLiNmb250U2l6ZSA9IGRhdGEuZm9udFNpemU7XG4gICAgZWRpdG9yLmNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uZGF0YS5jb2xvcik7XG4gICAgZWRpdG9yLiNjb250ZW50ID0gRnJlZVRleHRFZGl0b3IuI2Rlc2VyaWFsaXplQ29udGVudChkYXRhLnZhbHVlKTtcbiAgICBlZGl0b3IuX2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgaWYgKGRhdGEuY29tbWVudCkge1xuICAgICAgZWRpdG9yLnNldENvbW1lbnREYXRhKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgY29sb3IgPSBBbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydCh0aGlzLmlzQXR0YWNoZWRUb0RPTSA/IGdldENvbXB1dGVkU3R5bGUodGhpcy5lZGl0b3JEaXYpLmNvbG9yIDogdGhpcy5jb2xvcik7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IE9iamVjdC5hc3NpZ24oc3VwZXIuc2VyaWFsaXplKGlzRm9yQ29weWluZyksIHtcbiAgICAgIGNvbG9yLFxuICAgICAgZm9udFNpemU6IHRoaXMuI2ZvbnRTaXplLFxuICAgICAgdmFsdWU6IHRoaXMuI3NlcmlhbGl6ZUNvbnRlbnQoKVxuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmlzQ29weSA9IHRydWU7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGNvbG9yLFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiB0aGlzLmhhc0VkaXRlZENvbW1lbnQgfHwgdGhpcy5faGFzQmVlbk1vdmVkIHx8IHNlcmlhbGl6ZWQudmFsdWUgIT09IHZhbHVlIHx8IHNlcmlhbGl6ZWQuZm9udFNpemUgIT09IGZvbnRTaXplIHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pIHx8IHNlcmlhbGl6ZWQucGFnZUluZGV4ICE9PSBwYWdlSW5kZXg7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzdXBlci5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKTtcbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBjb250ZW50O1xuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgY29udGVudC5yZXBsYWNlQ2hpbGRyZW4oKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy4jY29udGVudC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5hcHBlbmQobGluZSA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIGNvbnRlbnQuYXBwZW5kKGRpdik7XG4gICAgfVxuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpLFxuICAgICAgcG9wdXA6IHRoaXMuX3VpTWFuYWdlci5oYXNDb21tZW50TWFuYWdlcigpIHx8IHRoaXMuaGFzRWRpdGVkQ29tbWVudCA/IHRoaXMuY29tbWVudCA6IHtcbiAgICAgICAgdGV4dDogdGhpcy4jY29udGVudFxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIHJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIHN1cGVyLnJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbik7XG4gICAgYW5ub3RhdGlvbi5yZXNldEVkaXRlZCgpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL291dGxpbmUuanNcblxuXG5cblxuXG5jbGFzcyBPdXRsaW5lIHtcbiAgc3RhdGljIFBSRUNJU0lPTiA9IDFlLTQ7XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgdG9TVkdQYXRoYCBtdXN0IGJlIGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgZ2V0dGVyIGBib3hgIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShfYmJveCwgX3JvdGF0aW9uKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYHNlcmlhbGl6ZWAgbXVzdCBiZSBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgc3RhdGljIF9yZXNjYWxlKHNyYywgdHgsIHR5LCBzeCwgc3ksIGRlc3QpIHtcbiAgICBkZXN0IHx8PSBuZXcgRmxvYXQzMkFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaV0gKiBzeDtcbiAgICAgIGRlc3RbaSArIDFdID0gdHkgKyBzcmNbaSArIDFdICogc3k7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHN0YXRpYyBfcmVzY2FsZUFuZFN3YXAoc3JjLCB0eCwgdHksIHN4LCBzeSwgZGVzdCkge1xuICAgIGRlc3QgfHw9IG5ldyBGbG9hdDMyQXJyYXkoc3JjLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGRlc3RbaV0gPSB0eCArIHNyY1tpICsgMV0gKiBzeDtcbiAgICAgIGRlc3RbaSArIDFdID0gdHkgKyBzcmNbaV0gKiBzeTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgc3RhdGljIF90cmFuc2xhdGUoc3JjLCB0eCwgdHksIGRlc3QpIHtcbiAgICBkZXN0IHx8PSBuZXcgRmxvYXQzMkFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaV07XG4gICAgICBkZXN0W2kgKyAxXSA9IHR5ICsgc3JjW2kgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgc3RhdGljIHN2Z1JvdW5kKHgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh4ICogMTAwMDApO1xuICB9XG4gIHN0YXRpYyBfbm9ybWFsaXplUG9pbnQoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pIHtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC8gcGFyZW50V2lkdGgsIHggLyBwYXJlbnRIZWlnaHRdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHggLyBwYXJlbnRXaWR0aCwgMSAtIHkgLyBwYXJlbnRIZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSAvIHBhcmVudFdpZHRoLCAxIC0geCAvIHBhcmVudEhlaWdodF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3ggLyBwYXJlbnRXaWR0aCwgeSAvIHBhcmVudEhlaWdodF07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfbm9ybWFsaXplUGFnZVBvaW50KHgsIHksIHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUJlemllclBvaW50cyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgcmV0dXJuIFsoeDEgKyA1ICogeDIpIC8gNiwgKHkxICsgNSAqIHkyKSAvIDYsICg1ICogeDIgKyB4MykgLyA2LCAoNSAqIHkyICsgeTMpIC8gNiwgKHgyICsgeDMpIC8gMiwgKHkyICsgeTMpIC8gMl07XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvZnJlZWRyYXcuanNcblxuXG5cblxuXG5cblxuY2xhc3MgRnJlZURyYXdPdXRsaW5lciB7XG4gICNib3g7XG4gICNib3R0b20gPSBbXTtcbiAgI2lubmVyTWFyZ2luO1xuICAjaXNMVFI7XG4gICN0b3AgPSBbXTtcbiAgI2xhc3QgPSBuZXcgRmxvYXQzMkFycmF5KDE4KTtcbiAgI2xhc3RYO1xuICAjbGFzdFk7XG4gICNtaW47XG4gICNtaW5fZGlzdDtcbiAgI3NjYWxlRmFjdG9yO1xuICAjdGhpY2tuZXNzO1xuICAjcG9pbnRzID0gW107XG4gIHN0YXRpYyAjTUlOX0RJU1QgPSA4O1xuICBzdGF0aWMgI01JTl9ESUZGID0gMjtcbiAgc3RhdGljICNNSU4gPSBGcmVlRHJhd091dGxpbmVyLiNNSU5fRElTVCArIEZyZWVEcmF3T3V0bGluZXIuI01JTl9ESUZGO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgeCxcbiAgICB5XG4gIH0sIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luID0gMCkge1xuICAgIHRoaXMuI2JveCA9IGJveDtcbiAgICB0aGlzLiN0aGlja25lc3MgPSB0aGlja25lc3MgKiBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNpc0xUUiA9IGlzTFRSO1xuICAgIHRoaXMuI2xhc3Quc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHldLCA2KTtcbiAgICB0aGlzLiNpbm5lck1hcmdpbiA9IGlubmVyTWFyZ2luO1xuICAgIHRoaXMuI21pbl9kaXN0ID0gRnJlZURyYXdPdXRsaW5lci4jTUlOX0RJU1QgKiBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNtaW4gPSBGcmVlRHJhd091dGxpbmVyLiNNSU4gKiBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNzY2FsZUZhY3RvciA9IHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI3BvaW50cy5wdXNoKHgsIHkpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGlzTmFOKHRoaXMuI2xhc3RbOF0pO1xuICB9XG4gICNnZXRMYXN0Q29vcmRzKCkge1xuICAgIGNvbnN0IGxhc3RUb3AgPSB0aGlzLiNsYXN0LnN1YmFycmF5KDQsIDYpO1xuICAgIGNvbnN0IGxhc3RCb3R0b20gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE2LCAxOCk7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIHJldHVybiBbKHRoaXMuI2xhc3RYICsgKGxhc3RUb3BbMF0gLSBsYXN0Qm90dG9tWzBdKSAvIDIgLSB4KSAvIHdpZHRoLCAodGhpcy4jbGFzdFkgKyAobGFzdFRvcFsxXSAtIGxhc3RCb3R0b21bMV0pIC8gMiAtIHkpIC8gaGVpZ2h0LCAodGhpcy4jbGFzdFggKyAobGFzdEJvdHRvbVswXSAtIGxhc3RUb3BbMF0pIC8gMiAtIHgpIC8gd2lkdGgsICh0aGlzLiNsYXN0WSArIChsYXN0Qm90dG9tWzFdIC0gbGFzdFRvcFsxXSkgLyAyIC0geSkgLyBoZWlnaHRdO1xuICB9XG4gIGFkZCh7XG4gICAgeCxcbiAgICB5XG4gIH0pIHtcbiAgICB0aGlzLiNsYXN0WCA9IHg7XG4gICAgdGhpcy4jbGFzdFkgPSB5O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGxldCBbeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSg4LCAxMik7XG4gICAgY29uc3QgZGlmZlggPSB4IC0geDI7XG4gICAgY29uc3QgZGlmZlkgPSB5IC0geTI7XG4gICAgY29uc3QgZCA9IE1hdGguaHlwb3QoZGlmZlgsIGRpZmZZKTtcbiAgICBpZiAoZCA8IHRoaXMuI21pbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBkaWZmRCA9IGQgLSB0aGlzLiNtaW5fZGlzdDtcbiAgICBjb25zdCBLID0gZGlmZkQgLyBkO1xuICAgIGNvbnN0IHNoaWZ0WCA9IEsgKiBkaWZmWDtcbiAgICBjb25zdCBzaGlmdFkgPSBLICogZGlmZlk7XG4gICAgbGV0IHgwID0geDE7XG4gICAgbGV0IHkwID0geTE7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICAgIHgyICs9IHNoaWZ0WDtcbiAgICB5MiArPSBzaGlmdFk7XG4gICAgdGhpcy4jcG9pbnRzPy5wdXNoKHgsIHkpO1xuICAgIGNvbnN0IG5YID0gLXNoaWZ0WSAvIGRpZmZEO1xuICAgIGNvbnN0IG5ZID0gc2hpZnRYIC8gZGlmZkQ7XG4gICAgY29uc3QgdGhYID0gblggKiB0aGlzLiN0aGlja25lc3M7XG4gICAgY29uc3QgdGhZID0gblkgKiB0aGlzLiN0aGlja25lc3M7XG4gICAgdGhpcy4jbGFzdC5zZXQodGhpcy4jbGFzdC5zdWJhcnJheSgyLCA4KSwgMCk7XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gyICsgdGhYLCB5MiArIHRoWV0sIDQpO1xuICAgIHRoaXMuI2xhc3Quc2V0KHRoaXMuI2xhc3Quc3ViYXJyYXkoMTQsIDE4KSwgMTIpO1xuICAgIHRoaXMuI2xhc3Quc2V0KFt4MiAtIHRoWCwgeTIgLSB0aFldLCAxNik7XG4gICAgaWYgKGlzTmFOKHRoaXMuI2xhc3RbNl0pKSB7XG4gICAgICBpZiAodGhpcy4jdG9wLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLiNsYXN0LnNldChbeDEgKyB0aFgsIHkxICsgdGhZXSwgMik7XG4gICAgICAgIHRoaXMuI3RvcC5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKHgxICsgdGhYIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICh5MSArIHRoWSAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MSAtIHRoWCwgeTEgLSB0aFldLCAxNCk7XG4gICAgICAgIHRoaXMuI2JvdHRvbS5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKHgxIC0gdGhYIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICh5MSAtIHRoWSAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNsYXN0LnNldChbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0sIDYpO1xuICAgICAgcmV0dXJuICF0aGlzLmlzRW1wdHkoKTtcbiAgICB9XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTJdLCA2KTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGguYWJzKE1hdGguYXRhbjIoeTAgLSB5MSwgeDAgLSB4MSkgLSBNYXRoLmF0YW4yKHNoaWZ0WSwgc2hpZnRYKSk7XG4gICAgaWYgKGFuZ2xlIDwgTWF0aC5QSSAvIDIpIHtcbiAgICAgIFt4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDIsIDYpO1xuICAgICAgdGhpcy4jdG9wLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoKHgxICsgeDIpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkxICsgeTIpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICBbeDEsIHkxLCB4MCwgeTBdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNCwgMTgpO1xuICAgICAgdGhpcy4jYm90dG9tLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoKHgwICsgeDEpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkwICsgeTEpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgwLCA2KTtcbiAgICB0aGlzLiN0b3AucHVzaCgoKHgwICsgNSAqIHgxKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MCArIDUgKiB5MSkgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKDUgKiB4MSArIHgyKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCg1ICogeTEgKyB5MikgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKHgxICsgeDIpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkxICsgeTIpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgW3gyLCB5MiwgeDEsIHkxLCB4MCwgeTBdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxMiwgMTgpO1xuICAgIHRoaXMuI2JvdHRvbS5wdXNoKCgoeDAgKyA1ICogeDEpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkwICsgNSAqIHkxKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoNSAqIHgxICsgeDIpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKDUgKiB5MSArIHkyKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoeDEgKyB4MikgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTEgKyB5MikgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgY29uc3QgdG9wID0gdGhpcy4jdG9wO1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBpZiAoaXNOYU4odGhpcy4jbGFzdFs2XSkgJiYgIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jdG9TVkdQYXRoVHdvUG9pbnRzKCk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGJ1ZmZlci5wdXNoKGBNJHt0b3BbNF19ICR7dG9wWzVdfWApO1xuICAgIGZvciAobGV0IGkgPSA2OyBpIDwgdG9wLmxlbmd0aDsgaSArPSA2KSB7XG4gICAgICBpZiAoaXNOYU4odG9wW2ldKSkge1xuICAgICAgICBidWZmZXIucHVzaChgTCR7dG9wW2kgKyA0XX0gJHt0b3BbaSArIDVdfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEMke3RvcFtpXX0gJHt0b3BbaSArIDFdfSAke3RvcFtpICsgMl19ICR7dG9wW2kgKyAzXX0gJHt0b3BbaSArIDRdfSAke3RvcFtpICsgNV19YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3RvU1ZHUGF0aEVuZChidWZmZXIpO1xuICAgIGZvciAobGV0IGkgPSBib3R0b20ubGVuZ3RoIC0gNjsgaSA+PSA2OyBpIC09IDYpIHtcbiAgICAgIGlmIChpc05hTihib3R0b21baV0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHtib3R0b21baSArIDRdfSAke2JvdHRvbVtpICsgNV19YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIucHVzaChgQyR7Ym90dG9tW2ldfSAke2JvdHRvbVtpICsgMV19ICR7Ym90dG9tW2kgKyAyXX0gJHtib3R0b21baSArIDNdfSAke2JvdHRvbVtpICsgNF19ICR7Ym90dG9tW2kgKyA1XX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdG9TVkdQYXRoU3RhcnQoYnVmZmVyKTtcbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gICN0b1NWR1BhdGhUd29Qb2ludHMoKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgcmV0dXJuIGBNJHsodGhpcy4jbGFzdFsyXSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbM10gLSB5KSAvIGhlaWdodH0gTCR7KHRoaXMuI2xhc3RbNF0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzVdIC0geSkgLyBoZWlnaHR9IEwke2xhc3RUb3BYfSAke2xhc3RUb3BZfSBMJHtsYXN0Qm90dG9tWH0gJHtsYXN0Qm90dG9tWX0gTCR7KHRoaXMuI2xhc3RbMTZdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFsxN10gLSB5KSAvIGhlaWdodH0gTCR7KHRoaXMuI2xhc3RbMTRdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFsxNV0gLSB5KSAvIGhlaWdodH0gWmA7XG4gIH1cbiAgI3RvU1ZHUGF0aFN0YXJ0KGJ1ZmZlcikge1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBidWZmZXIucHVzaChgTCR7Ym90dG9tWzRdfSAke2JvdHRvbVs1XX0gWmApO1xuICB9XG4gICN0b1NWR1BhdGhFbmQoYnVmZmVyKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IGxhc3RUb3AgPSB0aGlzLiNsYXN0LnN1YmFycmF5KDQsIDYpO1xuICAgIGNvbnN0IGxhc3RCb3R0b20gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE2LCAxOCk7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICBidWZmZXIucHVzaChgTCR7KGxhc3RUb3BbMF0gLSB4KSAvIHdpZHRofSAkeyhsYXN0VG9wWzFdIC0geSkgLyBoZWlnaHR9IEwke2xhc3RUb3BYfSAke2xhc3RUb3BZfSBMJHtsYXN0Qm90dG9tWH0gJHtsYXN0Qm90dG9tWX0gTCR7KGxhc3RCb3R0b21bMF0gLSB4KSAvIHdpZHRofSAkeyhsYXN0Qm90dG9tWzFdIC0geSkgLyBoZWlnaHR9YCk7XG4gIH1cbiAgbmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpO1xuICB9XG4gIGdldE91dGxpbmVzKCkge1xuICAgIGNvbnN0IHRvcCA9IHRoaXMuI3RvcDtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuI2xhc3Q7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSgodGhpcy4jcG9pbnRzPy5sZW5ndGggPz8gMCkgKyAyKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoIC0gMjsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIHBvaW50c1tpXSA9ICh0aGlzLiNwb2ludHNbaV0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aDtcbiAgICAgIHBvaW50c1tpICsgMV0gPSAodGhpcy4jcG9pbnRzW2kgKyAxXSAtIGxheWVyWSkgLyBsYXllckhlaWdodDtcbiAgICB9XG4gICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSA9ICh0aGlzLiNsYXN0WCAtIGxheWVyWCkgLyBsYXllcldpZHRoO1xuICAgIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gPSAodGhpcy4jbGFzdFkgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQ7XG4gICAgaWYgKGlzTmFOKGxhc3RbNl0pICYmICF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2dldE91dGxpbmVUd29Qb2ludHMocG9pbnRzKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy4jdG9wLmxlbmd0aCArIDI0ICsgdGhpcy4jYm90dG9tLmxlbmd0aCk7XG4gICAgbGV0IE4gPSB0b3AubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSArPSAyKSB7XG4gICAgICBpZiAoaXNOYU4odG9wW2ldKSkge1xuICAgICAgICBvdXRsaW5lW2ldID0gb3V0bGluZVtpICsgMV0gPSBOYU47XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgb3V0bGluZVtpXSA9IHRvcFtpXTtcbiAgICAgIG91dGxpbmVbaSArIDFdID0gdG9wW2kgKyAxXTtcbiAgICB9XG4gICAgTiA9IHRoaXMuI2dldE91dGxpbmVFbmQob3V0bGluZSwgTik7XG4gICAgZm9yIChsZXQgaSA9IGJvdHRvbS5sZW5ndGggLSA2OyBpID49IDY7IGkgLT0gNikge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA2OyBqICs9IDIpIHtcbiAgICAgICAgaWYgKGlzTmFOKGJvdHRvbVtpICsgal0pKSB7XG4gICAgICAgICAgb3V0bGluZVtOXSA9IG91dGxpbmVbTiArIDFdID0gTmFOO1xuICAgICAgICAgIE4gKz0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvdXRsaW5lW05dID0gYm90dG9tW2kgKyBqXTtcbiAgICAgICAgb3V0bGluZVtOICsgMV0gPSBib3R0b21baSArIGogKyAxXTtcbiAgICAgICAgTiArPSAyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNnZXRPdXRsaW5lU3RhcnQob3V0bGluZSwgTik7XG4gICAgcmV0dXJuIHRoaXMubmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgdGhpcy4jYm94LCB0aGlzLiNzY2FsZUZhY3RvciwgdGhpcy4jaW5uZXJNYXJnaW4sIHRoaXMuI2lzTFRSKTtcbiAgfVxuICAjZ2V0T3V0bGluZVR3b1BvaW50cyhwb2ludHMpIHtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy4jbGFzdDtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIGNvbnN0IG91dGxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KDM2KTtcbiAgICBvdXRsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFsyXSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFszXSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFs0XSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFs1XSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0VG9wWCwgbGFzdFRvcFksIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzE2XSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFsxN10gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbMTRdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzE1XSAtIGxheWVyWSkgLyBsYXllckhlaWdodF0sIDApO1xuICAgIHJldHVybiB0aGlzLm5ld0ZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIHRoaXMuI2JveCwgdGhpcy4jc2NhbGVGYWN0b3IsIHRoaXMuI2lubmVyTWFyZ2luLCB0aGlzLiNpc0xUUik7XG4gIH1cbiAgI2dldE91dGxpbmVTdGFydChvdXRsaW5lLCBwb3MpIHtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgb3V0bGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgYm90dG9tWzRdLCBib3R0b21bNV1dLCBwb3MpO1xuICAgIHJldHVybiBwb3MgKz0gNjtcbiAgfVxuICAjZ2V0T3V0bGluZUVuZChvdXRsaW5lLCBwb3MpIHtcbiAgICBjb25zdCBsYXN0VG9wID0gdGhpcy4jbGFzdC5zdWJhcnJheSg0LCA2KTtcbiAgICBjb25zdCBsYXN0Qm90dG9tID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNiwgMTgpO1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgb3V0bGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RUb3BbMF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RUb3BbMV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdFRvcFgsIGxhc3RUb3BZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdEJvdHRvbVswXSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdEJvdHRvbVsxXSAtIGxheWVyWSkgLyBsYXllckhlaWdodF0sIHBvcyk7XG4gICAgcmV0dXJuIHBvcyArPSAyNDtcbiAgfVxufVxuY2xhc3MgRnJlZURyYXdPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNib3g7XG4gICNiYm94ID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgI2lubmVyTWFyZ2luO1xuICAjaXNMVFI7XG4gICNwb2ludHM7XG4gICNzY2FsZUZhY3RvcjtcbiAgI291dGxpbmU7XG4gIGNvbnN0cnVjdG9yKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNvdXRsaW5lID0gb3V0bGluZTtcbiAgICB0aGlzLiNwb2ludHMgPSBwb2ludHM7XG4gICAgdGhpcy4jYm94ID0gYm94O1xuICAgIHRoaXMuI3NjYWxlRmFjdG9yID0gc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jaW5uZXJNYXJnaW4gPSBpbm5lck1hcmdpbjtcbiAgICB0aGlzLiNpc0xUUiA9IGlzTFRSO1xuICAgIHRoaXMuZmlyc3RQb2ludCA9IFtOYU4sIE5hTl07XG4gICAgdGhpcy5sYXN0UG9pbnQgPSBbTmFOLCBOYU5dO1xuICAgIHRoaXMuI2NvbXB1dGVNaW5NYXgoaXNMVFIpO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2Jib3g7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3V0bGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBvdXRsaW5lW2ldID0gKG91dGxpbmVbaV0gLSB4KSAvIHdpZHRoO1xuICAgICAgb3V0bGluZVtpICsgMV0gPSAob3V0bGluZVtpICsgMV0gLSB5KSAvIGhlaWdodDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIHBvaW50c1tpXSA9IChwb2ludHNbaV0gLSB4KSAvIHdpZHRoO1xuICAgICAgcG9pbnRzW2kgKyAxXSA9IChwb2ludHNbaSArIDFdIC0geSkgLyBoZWlnaHQ7XG4gICAgfVxuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbYE0ke3RoaXMuI291dGxpbmVbNF19ICR7dGhpcy4jb3V0bGluZVs1XX1gXTtcbiAgICBmb3IgKGxldCBpID0gNiwgaWkgPSB0aGlzLiNvdXRsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgIGlmIChpc05hTih0aGlzLiNvdXRsaW5lW2ldKSkge1xuICAgICAgICBidWZmZXIucHVzaChgTCR7dGhpcy4jb3V0bGluZVtpICsgNF19ICR7dGhpcy4jb3V0bGluZVtpICsgNV19YCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goYEMke3RoaXMuI291dGxpbmVbaV19ICR7dGhpcy4jb3V0bGluZVtpICsgMV19ICR7dGhpcy4jb3V0bGluZVtpICsgMl19ICR7dGhpcy4jb3V0bGluZVtpICsgM119ICR7dGhpcy4jb3V0bGluZVtpICsgNF19ICR7dGhpcy4jb3V0bGluZVtpICsgNV19YCk7XG4gICAgfVxuICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShbYmxYLCBibFksIHRyWCwgdHJZXSwgcm90YXRpb24pIHtcbiAgICBjb25zdCB3aWR0aCA9IHRyWCAtIGJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSB0clkgLSBibFk7XG4gICAgbGV0IG91dGxpbmU7XG4gICAgbGV0IHBvaW50cztcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIG91dGxpbmUgPSBPdXRsaW5lLl9yZXNjYWxlKHRoaXMuI291dGxpbmUsIGJsWCwgdHJZLCB3aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IE91dGxpbmUuX3Jlc2NhbGUodGhpcy4jcG9pbnRzLCBibFgsIHRyWSwgd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIG91dGxpbmUgPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcCh0aGlzLiNvdXRsaW5lLCBibFgsIGJsWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwKHRoaXMuI3BvaW50cywgYmxYLCBibFksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICBvdXRsaW5lID0gT3V0bGluZS5fcmVzY2FsZSh0aGlzLiNvdXRsaW5lLCB0clgsIGJsWSwgLXdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBPdXRsaW5lLl9yZXNjYWxlKHRoaXMuI3BvaW50cywgdHJYLCBibFksIC13aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgb3V0bGluZSA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwKHRoaXMuI291dGxpbmUsIHRyWCwgdHJZLCAtd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcCh0aGlzLiNwb2ludHMsIHRyWCwgdHJZLCAtd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dGxpbmU6IEFycmF5LmZyb20ob3V0bGluZSksXG4gICAgICBwb2ludHM6IFtBcnJheS5mcm9tKHBvaW50cyldXG4gICAgfTtcbiAgfVxuICAjY29tcHV0ZU1pbk1heChpc0xUUikge1xuICAgIGNvbnN0IG91dGxpbmUgPSB0aGlzLiNvdXRsaW5lO1xuICAgIGxldCBsYXN0WCA9IG91dGxpbmVbNF07XG4gICAgbGV0IGxhc3RZID0gb3V0bGluZVs1XTtcbiAgICBjb25zdCBtaW5NYXggPSBbbGFzdFgsIGxhc3RZLCBsYXN0WCwgbGFzdFldO1xuICAgIGxldCBmaXJzdFBvaW50WCA9IGxhc3RYO1xuICAgIGxldCBmaXJzdFBvaW50WSA9IGxhc3RZO1xuICAgIGxldCBsYXN0UG9pbnRYID0gbGFzdFg7XG4gICAgbGV0IGxhc3RQb2ludFkgPSBsYXN0WTtcbiAgICBjb25zdCBsdHJDYWxsYmFjayA9IGlzTFRSID8gTWF0aC5tYXggOiBNYXRoLm1pbjtcbiAgICBjb25zdCBiZXppZXJCYm94ID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICBmb3IgKGxldCBpID0gNiwgaWkgPSBvdXRsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgIGNvbnN0IHggPSBvdXRsaW5lW2kgKyA0XSxcbiAgICAgICAgeSA9IG91dGxpbmVbaSArIDVdO1xuICAgICAgaWYgKGlzTmFOKG91dGxpbmVbaV0pKSB7XG4gICAgICAgIFV0aWwucG9pbnRCb3VuZGluZ0JveCh4LCB5LCBtaW5NYXgpO1xuICAgICAgICBpZiAoZmlyc3RQb2ludFkgPiB5KSB7XG4gICAgICAgICAgZmlyc3RQb2ludFggPSB4O1xuICAgICAgICAgIGZpcnN0UG9pbnRZID0geTtcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdFBvaW50WSA9PT0geSkge1xuICAgICAgICAgIGZpcnN0UG9pbnRYID0gbHRyQ2FsbGJhY2soZmlyc3RQb2ludFgsIHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UG9pbnRZIDwgeSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSB4O1xuICAgICAgICAgIGxhc3RQb2ludFkgPSB5O1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQb2ludFkgPT09IHkpIHtcbiAgICAgICAgICBsYXN0UG9pbnRYID0gbHRyQ2FsbGJhY2sobGFzdFBvaW50WCwgeCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlemllckJib3hbMF0gPSBiZXppZXJCYm94WzFdID0gSW5maW5pdHk7XG4gICAgICAgIGJlemllckJib3hbMl0gPSBiZXppZXJCYm94WzNdID0gLUluZmluaXR5O1xuICAgICAgICBVdGlsLmJlemllckJvdW5kaW5nQm94KGxhc3RYLCBsYXN0WSwgLi4ub3V0bGluZS5zbGljZShpLCBpICsgNiksIGJlemllckJib3gpO1xuICAgICAgICBVdGlsLnJlY3RCb3VuZGluZ0JveChiZXppZXJCYm94WzBdLCBiZXppZXJCYm94WzFdLCBiZXppZXJCYm94WzJdLCBiZXppZXJCYm94WzNdLCBtaW5NYXgpO1xuICAgICAgICBpZiAoZmlyc3RQb2ludFkgPiBiZXppZXJCYm94WzFdKSB7XG4gICAgICAgICAgZmlyc3RQb2ludFggPSBiZXppZXJCYm94WzBdO1xuICAgICAgICAgIGZpcnN0UG9pbnRZID0gYmV6aWVyQmJveFsxXTtcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdFBvaW50WSA9PT0gYmV6aWVyQmJveFsxXSkge1xuICAgICAgICAgIGZpcnN0UG9pbnRYID0gbHRyQ2FsbGJhY2soZmlyc3RQb2ludFgsIGJlemllckJib3hbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UG9pbnRZIDwgYmV6aWVyQmJveFszXSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBiZXppZXJCYm94WzJdO1xuICAgICAgICAgIGxhc3RQb2ludFkgPSBiZXppZXJCYm94WzNdO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQb2ludFkgPT09IGJlemllckJib3hbM10pIHtcbiAgICAgICAgICBsYXN0UG9pbnRYID0gbHRyQ2FsbGJhY2sobGFzdFBvaW50WCwgYmV6aWVyQmJveFsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RYID0geDtcbiAgICAgIGxhc3RZID0geTtcbiAgICB9XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgYmJveFswXSA9IG1pbk1heFswXSAtIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIGJib3hbMV0gPSBtaW5NYXhbMV0gLSB0aGlzLiNpbm5lck1hcmdpbjtcbiAgICBiYm94WzJdID0gbWluTWF4WzJdIC0gbWluTWF4WzBdICsgMiAqIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIGJib3hbM10gPSBtaW5NYXhbM10gLSBtaW5NYXhbMV0gKyAyICogdGhpcy4jaW5uZXJNYXJnaW47XG4gICAgdGhpcy5maXJzdFBvaW50ID0gW2ZpcnN0UG9pbnRYLCBmaXJzdFBvaW50WV07XG4gICAgdGhpcy5sYXN0UG9pbnQgPSBbbGFzdFBvaW50WCwgbGFzdFBvaW50WV07XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYmJveDtcbiAgfVxuICBuZXdPdXRsaW5lcihwb2ludCwgYm94LCBzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCBpc0xUUiwgaW5uZXJNYXJnaW4gPSAwKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlRHJhd091dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbik7XG4gIH1cbiAgZ2V0TmV3T3V0bGluZSh0aGlja25lc3MsIGlubmVyTWFyZ2luKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBzeCA9IHdpZHRoICogbGF5ZXJXaWR0aDtcbiAgICBjb25zdCBzeSA9IGhlaWdodCAqIGxheWVySGVpZ2h0O1xuICAgIGNvbnN0IHR4ID0geCAqIGxheWVyV2lkdGggKyBsYXllclg7XG4gICAgY29uc3QgdHkgPSB5ICogbGF5ZXJIZWlnaHQgKyBsYXllclk7XG4gICAgY29uc3Qgb3V0bGluZXIgPSB0aGlzLm5ld091dGxpbmVyKHtcbiAgICAgIHg6IHRoaXMuI3BvaW50c1swXSAqIHN4ICsgdHgsXG4gICAgICB5OiB0aGlzLiNwb2ludHNbMV0gKiBzeSArIHR5XG4gICAgfSwgdGhpcy4jYm94LCB0aGlzLiNzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCB0aGlzLiNpc0xUUiwgaW5uZXJNYXJnaW4gPz8gdGhpcy4jaW5uZXJNYXJnaW4pO1xuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgdGhpcy4jcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBvdXRsaW5lci5hZGQoe1xuICAgICAgICB4OiB0aGlzLiNwb2ludHNbaV0gKiBzeCArIHR4LFxuICAgICAgICB5OiB0aGlzLiNwb2ludHNbaSArIDFdICogc3kgKyB0eVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRsaW5lci5nZXRPdXRsaW5lcygpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL2hpZ2hsaWdodC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgSGlnaGxpZ2h0T3V0bGluZXIge1xuICAjYm94O1xuICAjZmlyc3RQb2ludDtcbiAgI2xhc3RQb2ludDtcbiAgI3ZlcnRpY2FsRWRnZXMgPSBbXTtcbiAgI2ludGVydmFscyA9IFtdO1xuICBjb25zdHJ1Y3Rvcihib3hlcywgYm9yZGVyV2lkdGggPSAwLCBpbm5lck1hcmdpbiA9IDAsIGlzTFRSID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1pbk1heCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICBjb25zdCBOVU1CRVJfT0ZfRElHSVRTID0gNDtcbiAgICBjb25zdCBFUFNJTE9OID0gMTAgKiogLU5VTUJFUl9PRl9ESUdJVFM7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSBvZiBib3hlcykge1xuICAgICAgY29uc3QgeDEgPSBNYXRoLmZsb29yKCh4IC0gYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeDIgPSBNYXRoLmNlaWwoKHggKyB3aWR0aCArIGJvcmRlcldpZHRoKSAvIEVQU0lMT04pICogRVBTSUxPTjtcbiAgICAgIGNvbnN0IHkxID0gTWF0aC5mbG9vcigoeSAtIGJvcmRlcldpZHRoKSAvIEVQU0lMT04pICogRVBTSUxPTjtcbiAgICAgIGNvbnN0IHkyID0gTWF0aC5jZWlsKCh5ICsgaGVpZ2h0ICsgYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgbGVmdCA9IFt4MSwgeTEsIHkyLCB0cnVlXTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gW3gyLCB5MSwgeTIsIGZhbHNlXTtcbiAgICAgIHRoaXMuI3ZlcnRpY2FsRWRnZXMucHVzaChsZWZ0LCByaWdodCk7XG4gICAgICBVdGlsLnJlY3RCb3VuZGluZ0JveCh4MSwgeTEsIHgyLCB5MiwgbWluTWF4KTtcbiAgICB9XG4gICAgY29uc3QgYmJveFdpZHRoID0gbWluTWF4WzJdIC0gbWluTWF4WzBdICsgMiAqIGlubmVyTWFyZ2luO1xuICAgIGNvbnN0IGJib3hIZWlnaHQgPSBtaW5NYXhbM10gLSBtaW5NYXhbMV0gKyAyICogaW5uZXJNYXJnaW47XG4gICAgY29uc3Qgc2hpZnRlZE1pblggPSBtaW5NYXhbMF0gLSBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBzaGlmdGVkTWluWSA9IG1pbk1heFsxXSAtIGlubmVyTWFyZ2luO1xuICAgIGxldCBmaXJzdFBvaW50WCA9IGlzTFRSID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gICAgbGV0IGZpcnN0UG9pbnRZID0gSW5maW5pdHk7XG4gICAgY29uc3QgbGFzdEVkZ2UgPSB0aGlzLiN2ZXJ0aWNhbEVkZ2VzLmF0KGlzTFRSID8gLTEgOiAtMik7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gW2xhc3RFZGdlWzBdLCBsYXN0RWRnZVsyXV07XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIHRoaXMuI3ZlcnRpY2FsRWRnZXMpIHtcbiAgICAgIGNvbnN0IFt4LCB5MSwgeTIsIGxlZnRdID0gZWRnZTtcbiAgICAgIGlmICghbGVmdCAmJiBpc0xUUikge1xuICAgICAgICBpZiAoeTEgPCBmaXJzdFBvaW50WSkge1xuICAgICAgICAgIGZpcnN0UG9pbnRZID0geTE7XG4gICAgICAgICAgZmlyc3RQb2ludFggPSB4O1xuICAgICAgICB9IGVsc2UgaWYgKHkxID09PSBmaXJzdFBvaW50WSkge1xuICAgICAgICAgIGZpcnN0UG9pbnRYID0gTWF0aC5tYXgoZmlyc3RQb2ludFgsIHgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxlZnQgJiYgIWlzTFRSKSB7XG4gICAgICAgIGlmICh5MSA8IGZpcnN0UG9pbnRZKSB7XG4gICAgICAgICAgZmlyc3RQb2ludFkgPSB5MTtcbiAgICAgICAgICBmaXJzdFBvaW50WCA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeTEgPT09IGZpcnN0UG9pbnRZKSB7XG4gICAgICAgICAgZmlyc3RQb2ludFggPSBNYXRoLm1pbihmaXJzdFBvaW50WCwgeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVkZ2VbMF0gPSAoeCAtIHNoaWZ0ZWRNaW5YKSAvIGJib3hXaWR0aDtcbiAgICAgIGVkZ2VbMV0gPSAoeTEgLSBzaGlmdGVkTWluWSkgLyBiYm94SGVpZ2h0O1xuICAgICAgZWRnZVsyXSA9ICh5MiAtIHNoaWZ0ZWRNaW5ZKSAvIGJib3hIZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuI2JveCA9IG5ldyBGbG9hdDMyQXJyYXkoW3NoaWZ0ZWRNaW5YLCBzaGlmdGVkTWluWSwgYmJveFdpZHRoLCBiYm94SGVpZ2h0XSk7XG4gICAgdGhpcy4jZmlyc3RQb2ludCA9IFtmaXJzdFBvaW50WCwgZmlyc3RQb2ludFldO1xuICAgIHRoaXMuI2xhc3RQb2ludCA9IGxhc3RQb2ludDtcbiAgfVxuICBnZXRPdXRsaW5lcygpIHtcbiAgICB0aGlzLiN2ZXJ0aWNhbEVkZ2VzLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdIHx8IGFbMV0gLSBiWzFdIHx8IGFbMl0gLSBiWzJdKTtcbiAgICBjb25zdCBvdXRsaW5lVmVydGljYWxFZGdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiB0aGlzLiN2ZXJ0aWNhbEVkZ2VzKSB7XG4gICAgICBpZiAoZWRnZVszXSkge1xuICAgICAgICBvdXRsaW5lVmVydGljYWxFZGdlcy5wdXNoKC4uLnRoaXMuI2JyZWFrRWRnZShlZGdlKSk7XG4gICAgICAgIHRoaXMuI2luc2VydChlZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI3JlbW92ZShlZGdlKTtcbiAgICAgICAgb3V0bGluZVZlcnRpY2FsRWRnZXMucHVzaCguLi50aGlzLiNicmVha0VkZ2UoZWRnZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jZ2V0T3V0bGluZXMob3V0bGluZVZlcnRpY2FsRWRnZXMpO1xuICB9XG4gICNnZXRPdXRsaW5lcyhvdXRsaW5lVmVydGljYWxFZGdlcykge1xuICAgIGNvbnN0IGVkZ2VzID0gW107XG4gICAgY29uc3QgYWxsRWRnZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIG91dGxpbmVWZXJ0aWNhbEVkZ2VzKSB7XG4gICAgICBjb25zdCBbeCwgeTEsIHkyXSA9IGVkZ2U7XG4gICAgICBlZGdlcy5wdXNoKFt4LCB5MSwgZWRnZV0sIFt4LCB5MiwgZWRnZV0pO1xuICAgIH1cbiAgICBlZGdlcy5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSB8fCBhWzBdIC0gYlswXSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZWRnZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgY29uc3QgZWRnZTEgPSBlZGdlc1tpXVsyXTtcbiAgICAgIGNvbnN0IGVkZ2UyID0gZWRnZXNbaSArIDFdWzJdO1xuICAgICAgZWRnZTEucHVzaChlZGdlMik7XG4gICAgICBlZGdlMi5wdXNoKGVkZ2UxKTtcbiAgICAgIGFsbEVkZ2VzLmFkZChlZGdlMSk7XG4gICAgICBhbGxFZGdlcy5hZGQoZWRnZTIpO1xuICAgIH1cbiAgICBjb25zdCBvdXRsaW5lcyA9IFtdO1xuICAgIGxldCBvdXRsaW5lO1xuICAgIHdoaWxlIChhbGxFZGdlcy5zaXplID4gMCkge1xuICAgICAgY29uc3QgZWRnZSA9IGFsbEVkZ2VzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICAgIGxldCBbeCwgeTEsIHkyLCBlZGdlMSwgZWRnZTJdID0gZWRnZTtcbiAgICAgIGFsbEVkZ2VzLmRlbGV0ZShlZGdlKTtcbiAgICAgIGxldCBsYXN0UG9pbnRYID0geDtcbiAgICAgIGxldCBsYXN0UG9pbnRZID0geTE7XG4gICAgICBvdXRsaW5lID0gW3gsIHkyXTtcbiAgICAgIG91dGxpbmVzLnB1c2gob3V0bGluZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgZTtcbiAgICAgICAgaWYgKGFsbEVkZ2VzLmhhcyhlZGdlMSkpIHtcbiAgICAgICAgICBlID0gZWRnZTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsRWRnZXMuaGFzKGVkZ2UyKSkge1xuICAgICAgICAgIGUgPSBlZGdlMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhbGxFZGdlcy5kZWxldGUoZSk7XG4gICAgICAgIFt4LCB5MSwgeTIsIGVkZ2UxLCBlZGdlMl0gPSBlO1xuICAgICAgICBpZiAobGFzdFBvaW50WCAhPT0geCkge1xuICAgICAgICAgIG91dGxpbmUucHVzaChsYXN0UG9pbnRYLCBsYXN0UG9pbnRZLCB4LCBsYXN0UG9pbnRZID09PSB5MSA/IHkxIDogeTIpO1xuICAgICAgICAgIGxhc3RQb2ludFggPSB4O1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQb2ludFkgPSBsYXN0UG9pbnRZID09PSB5MSA/IHkyIDogeTE7XG4gICAgICB9XG4gICAgICBvdXRsaW5lLnB1c2gobGFzdFBvaW50WCwgbGFzdFBvaW50WSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0T3V0bGluZShvdXRsaW5lcywgdGhpcy4jYm94LCB0aGlzLiNmaXJzdFBvaW50LCB0aGlzLiNsYXN0UG9pbnQpO1xuICB9XG4gICNiaW5hcnlTZWFyY2goeSkge1xuICAgIGNvbnN0IGFycmF5ID0gdGhpcy4jaW50ZXJ2YWxzO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgICAgY29uc3QgbWlkZGxlID0gc3RhcnQgKyBlbmQgPj4gMTtcbiAgICAgIGNvbnN0IHkxID0gYXJyYXlbbWlkZGxlXVswXTtcbiAgICAgIGlmICh5MSA9PT0geSkge1xuICAgICAgICByZXR1cm4gbWlkZGxlO1xuICAgICAgfVxuICAgICAgaWYgKHkxIDwgeSkge1xuICAgICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSBtaWRkbGUgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kICsgMTtcbiAgfVxuICAjaW5zZXJ0KFssIHkxLCB5Ml0pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuI2JpbmFyeVNlYXJjaCh5MSk7XG4gICAgdGhpcy4jaW50ZXJ2YWxzLnNwbGljZShpbmRleCwgMCwgW3kxLCB5Ml0pO1xuICB9XG4gICNyZW1vdmUoWywgeTEsIHkyXSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy4jYmluYXJ5U2VhcmNoKHkxKTtcbiAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCB0aGlzLiNpbnRlcnZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuI2ludGVydmFsc1tpXTtcbiAgICAgIGlmIChzdGFydCAhPT0geTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPT09IHkxICYmIGVuZCA9PT0geTIpIHtcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdGhpcy4jaW50ZXJ2YWxzW2ldO1xuICAgICAgaWYgKHN0YXJ0ICE9PSB5MSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA9PT0geTEgJiYgZW5kID09PSB5Mikge1xuICAgICAgICB0aGlzLiNpbnRlcnZhbHMuc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNicmVha0VkZ2UoZWRnZSkge1xuICAgIGNvbnN0IFt4LCB5MSwgeTJdID0gZWRnZTtcbiAgICBjb25zdCByZXN1bHRzID0gW1t4LCB5MSwgeTJdXTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuI2JpbmFyeVNlYXJjaCh5Mik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLiNpbnRlcnZhbHNbaV07XG4gICAgICBmb3IgKGxldCBqID0gMCwgamogPSByZXN1bHRzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgY29uc3QgWywgeTMsIHk0XSA9IHJlc3VsdHNbal07XG4gICAgICAgIGlmIChlbmQgPD0geTMgfHwgeTQgPD0gc3RhcnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeTMgPj0gc3RhcnQpIHtcbiAgICAgICAgICBpZiAoeTQgPiBlbmQpIHtcbiAgICAgICAgICAgIHJlc3VsdHNbal1bMV0gPSBlbmQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChqaiA9PT0gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIGpqLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHNbal1bMl0gPSBzdGFydDtcbiAgICAgICAgaWYgKHk0ID4gZW5kKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKFt4LCBlbmQsIHk0XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbn1cbmNsYXNzIEhpZ2hsaWdodE91dGxpbmUgZXh0ZW5kcyBPdXRsaW5lIHtcbiAgI2JveDtcbiAgI291dGxpbmVzO1xuICBjb25zdHJ1Y3RvcihvdXRsaW5lcywgYm94LCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI291dGxpbmVzID0gb3V0bGluZXM7XG4gICAgdGhpcy4jYm94ID0gYm94O1xuICAgIHRoaXMuZmlyc3RQb2ludCA9IGZpcnN0UG9pbnQ7XG4gICAgdGhpcy5sYXN0UG9pbnQgPSBsYXN0UG9pbnQ7XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGZvciAoY29uc3QgcG9seWdvbiBvZiB0aGlzLiNvdXRsaW5lcykge1xuICAgICAgbGV0IFtwcmV2WCwgcHJldlldID0gcG9seWdvbjtcbiAgICAgIGJ1ZmZlci5wdXNoKGBNJHtwcmV2WH0gJHtwcmV2WX1gKTtcbiAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCB4ID0gcG9seWdvbltpXTtcbiAgICAgICAgY29uc3QgeSA9IHBvbHlnb25baSArIDFdO1xuICAgICAgICBpZiAoeCA9PT0gcHJldlgpIHtcbiAgICAgICAgICBidWZmZXIucHVzaChgViR7eX1gKTtcbiAgICAgICAgICBwcmV2WSA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAoeSA9PT0gcHJldlkpIHtcbiAgICAgICAgICBidWZmZXIucHVzaChgSCR7eH1gKTtcbiAgICAgICAgICBwcmV2WCA9IHg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgfVxuICBzZXJpYWxpemUoW2JsWCwgYmxZLCB0clgsIHRyWV0sIF9yb3RhdGlvbikge1xuICAgIGNvbnN0IG91dGxpbmVzID0gW107XG4gICAgY29uc3Qgd2lkdGggPSB0clggLSBibFg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdHJZIC0gYmxZO1xuICAgIGZvciAoY29uc3Qgb3V0bGluZSBvZiB0aGlzLiNvdXRsaW5lcykge1xuICAgICAgY29uc3QgcG9pbnRzID0gbmV3IEFycmF5KG91dGxpbmUubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0bGluZS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwb2ludHNbaV0gPSBibFggKyBvdXRsaW5lW2ldICogd2lkdGg7XG4gICAgICAgIHBvaW50c1tpICsgMV0gPSB0clkgLSBvdXRsaW5lW2kgKyAxXSAqIGhlaWdodDtcbiAgICAgIH1cbiAgICAgIG91dGxpbmVzLnB1c2gocG9pbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGxpbmVzO1xuICB9XG4gIGdldCBib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2JveDtcbiAgfVxuICBnZXQgY2xhc3NOYW1lc0Zvck91dGxpbmluZygpIHtcbiAgICByZXR1cm4gW1wiaGlnaGxpZ2h0T3V0bGluZVwiXTtcbiAgfVxufVxuY2xhc3MgRnJlZUhpZ2hsaWdodE91dGxpbmVyIGV4dGVuZHMgRnJlZURyYXdPdXRsaW5lciB7XG4gIG5ld0ZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUikge1xuICAgIHJldHVybiBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmUob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpO1xuICB9XG59XG5jbGFzcyBGcmVlSGlnaGxpZ2h0T3V0bGluZSBleHRlbmRzIEZyZWVEcmF3T3V0bGluZSB7XG4gIG5ld091dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbiA9IDApIHtcbiAgICByZXR1cm4gbmV3IEZyZWVIaWdobGlnaHRPdXRsaW5lcihwb2ludCwgYm94LCBzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCBpc0xUUiwgaW5uZXJNYXJnaW4pO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9oaWdobGlnaHQuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jbGFzcyBIaWdobGlnaHRFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2FuY2hvck5vZGUgPSBudWxsO1xuICAjYW5jaG9yT2Zmc2V0ID0gMDtcbiAgI2JveGVzO1xuICAjY2xpcFBhdGhJZCA9IG51bGw7XG4gICNjb2xvclBpY2tlciA9IG51bGw7XG4gICNmb2N1c091dGxpbmVzID0gbnVsbDtcbiAgI2ZvY3VzTm9kZSA9IG51bGw7XG4gICNmb2N1c09mZnNldCA9IDA7XG4gICNoaWdobGlnaHREaXYgPSBudWxsO1xuICAjaGlnaGxpZ2h0T3V0bGluZXMgPSBudWxsO1xuICAjaWQgPSBudWxsO1xuICAjaXNGcmVlSGlnaGxpZ2h0ID0gZmFsc2U7XG4gICNmaXJzdFBvaW50ID0gbnVsbDtcbiAgI2xhc3RQb2ludCA9IG51bGw7XG4gICNvdXRsaW5lSWQgPSBudWxsO1xuICAjdGV4dCA9IFwiXCI7XG4gICN0aGlja25lc3M7XG4gICNtZXRob2RPZkNyZWF0aW9uID0gXCJcIjtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRPcGFjaXR5ID0gMTtcbiAgc3RhdGljIF9kZWZhdWx0VGhpY2tuZXNzID0gMTI7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaGlnaGxpZ2h0XCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0SWQgPSAtMTtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0ID0gbnVsbDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0Q2xpcElkID0gXCJcIjtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gSGlnaGxpZ2h0RWRpdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8uX21vdmVDYXJldCwge1xuICAgICAgYXJnczogWzBdXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFsxXVxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fbW92ZUNhcmV0LCB7XG4gICAgICBhcmdzOiBbMl1cbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFszXVxuICAgIH1dXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiaGlnaGxpZ2h0RWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHBhcmFtcy50aGlja25lc3MgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzO1xuICAgIHRoaXMub3BhY2l0eSA9IHBhcmFtcy5vcGFjaXR5IHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdE9wYWNpdHk7XG4gICAgdGhpcy4jYm94ZXMgPSBwYXJhbXMuYm94ZXMgfHwgbnVsbDtcbiAgICB0aGlzLiNtZXRob2RPZkNyZWF0aW9uID0gcGFyYW1zLm1ldGhvZE9mQ3JlYXRpb24gfHwgXCJcIjtcbiAgICB0aGlzLiN0ZXh0ID0gcGFyYW1zLnRleHQgfHwgXCJcIjtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGVmYXVsdEwxMG5JZCA9IFwicGRmanMtZWRpdG9yLWhpZ2hsaWdodC1lZGl0b3JcIjtcbiAgICBpZiAocGFyYW1zLmhpZ2hsaWdodElkID4gLTEpIHtcbiAgICAgIHRoaXMuI2lzRnJlZUhpZ2hsaWdodCA9IHRydWU7XG4gICAgICB0aGlzLiNjcmVhdGVGcmVlT3V0bGluZXMocGFyYW1zKTtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNib3hlcykge1xuICAgICAgdGhpcy4jYW5jaG9yTm9kZSA9IHBhcmFtcy5hbmNob3JOb2RlO1xuICAgICAgdGhpcy4jYW5jaG9yT2Zmc2V0ID0gcGFyYW1zLmFuY2hvck9mZnNldDtcbiAgICAgIHRoaXMuI2ZvY3VzTm9kZSA9IHBhcmFtcy5mb2N1c05vZGU7XG4gICAgICB0aGlzLiNmb2N1c09mZnNldCA9IHBhcmFtcy5mb2N1c09mZnNldDtcbiAgICAgIHRoaXMuI2NyZWF0ZU91dGxpbmVzKCk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgICAgdGhpcy5yb3RhdGUodGhpcy5yb3RhdGlvbik7XG4gICAgfVxuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYTExeUFsZXJ0KFwicGRmanMtZWRpdG9yLWhpZ2hsaWdodC1hZGRlZC1hbGVydFwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUluaXRpYWxEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246IFwiYWRkZWRcIixcbiAgICAgIHR5cGU6IHRoaXMuI2lzRnJlZUhpZ2hsaWdodCA/IFwiZnJlZV9oaWdobGlnaHRcIiA6IFwiaGlnaGxpZ2h0XCIsXG4gICAgICBjb2xvcjogdGhpcy5fdWlNYW5hZ2VyLmdldE5vbkhDTUNvbG9yTmFtZSh0aGlzLmNvbG9yKSxcbiAgICAgIHRoaWNrbmVzczogdGhpcy4jdGhpY2tuZXNzLFxuICAgICAgbWV0aG9kT2ZDcmVhdGlvbjogdGhpcy4jbWV0aG9kT2ZDcmVhdGlvblxuICAgIH07XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJoaWdobGlnaHRcIixcbiAgICAgIGNvbG9yOiB0aGlzLl91aU1hbmFnZXIuZ2V0Tm9uSENNQ29sb3JOYW1lKHRoaXMuY29sb3IpXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlck9mQ29sb3JzOiBkYXRhLmdldChcImNvbG9yXCIpLnNpemVcbiAgICB9O1xuICB9XG4gICNjcmVhdGVPdXRsaW5lcygpIHtcbiAgICBjb25zdCBvdXRsaW5lciA9IG5ldyBIaWdobGlnaHRPdXRsaW5lcih0aGlzLiNib3hlcywgMC4wMDEpO1xuICAgIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzID0gb3V0bGluZXIuZ2V0T3V0bGluZXMoKTtcbiAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSA9IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveDtcbiAgICBjb25zdCBvdXRsaW5lckZvck91dGxpbmUgPSBuZXcgSGlnaGxpZ2h0T3V0bGluZXIodGhpcy4jYm94ZXMsIDAuMDAyNSwgMC4wMDEsIHRoaXMuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIpO1xuICAgIHRoaXMuI2ZvY3VzT3V0bGluZXMgPSBvdXRsaW5lckZvck91dGxpbmUuZ2V0T3V0bGluZXMoKTtcbiAgICBjb25zdCB7XG4gICAgICBmaXJzdFBvaW50XG4gICAgfSA9IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzO1xuICAgIHRoaXMuI2ZpcnN0UG9pbnQgPSBbKGZpcnN0UG9pbnRbMF0gLSB0aGlzLngpIC8gdGhpcy53aWR0aCwgKGZpcnN0UG9pbnRbMV0gLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHRdO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RQb2ludFxuICAgIH0gPSB0aGlzLiNmb2N1c091dGxpbmVzO1xuICAgIHRoaXMuI2xhc3RQb2ludCA9IFsobGFzdFBvaW50WzBdIC0gdGhpcy54KSAvIHRoaXMud2lkdGgsIChsYXN0UG9pbnRbMV0gLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHRdO1xuICB9XG4gICNjcmVhdGVGcmVlT3V0bGluZXMoe1xuICAgIGhpZ2hsaWdodE91dGxpbmVzLFxuICAgIGhpZ2hsaWdodElkLFxuICAgIGNsaXBQYXRoSWRcbiAgfSkge1xuICAgIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzID0gaGlnaGxpZ2h0T3V0bGluZXM7XG4gICAgY29uc3QgZXh0cmFUaGlja25lc3MgPSAxLjU7XG4gICAgdGhpcy4jZm9jdXNPdXRsaW5lcyA9IGhpZ2hsaWdodE91dGxpbmVzLmdldE5ld091dGxpbmUodGhpcy4jdGhpY2tuZXNzIC8gMiArIGV4dHJhVGhpY2tuZXNzLCAwLjAwMjUpO1xuICAgIGlmIChoaWdobGlnaHRJZCA+PSAwKSB7XG4gICAgICB0aGlzLiNpZCA9IGhpZ2hsaWdodElkO1xuICAgICAgdGhpcy4jY2xpcFBhdGhJZCA9IGNsaXBQYXRoSWQ7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIuZmluYWxpemVEcmF3KGhpZ2hsaWdodElkLCB7XG4gICAgICAgIGJib3g6IGhpZ2hsaWdodE91dGxpbmVzLmJveCxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IGhpZ2hsaWdodE91dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy4jb3V0bGluZUlkID0gdGhpcy5wYXJlbnQuZHJhd0xheWVyLmRyYXdPdXRsaW5lKHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlnaGxpZ2h0T3V0bGluZTogdHJ1ZSxcbiAgICAgICAgICBmcmVlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGJib3g6IHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy4jZm9jdXNPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBjb25zdCBhbmdsZSA9IHRoaXMucGFyZW50LnZpZXdwb3J0LnJvdGF0aW9uO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jaWQsIHtcbiAgICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveCwgKGFuZ2xlIC0gdGhpcy5yb3RhdGlvbiArIDM2MCkgJSAzNjApLFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogaGlnaGxpZ2h0T3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LCBhbmdsZSksXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiB0aGlzLiNmb2N1c091dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBoaWdobGlnaHRPdXRsaW5lcy5ib3g7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgICAgIHRoaXMueCA9IHk7XG4gICAgICAgICAgdGhpcy55ID0gMSAtIHg7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcGFnZUhlaWdodCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB0aGlzLnggPSAxIC0geDtcbiAgICAgICAgdGhpcy55ID0gMSAtIHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgICB0aGlzLnggPSAxIC0geTtcbiAgICAgICAgICB0aGlzLnkgPSB4O1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZpcnN0UG9pbnRcbiAgICB9ID0gaGlnaGxpZ2h0T3V0bGluZXM7XG4gICAgdGhpcy4jZmlyc3RQb2ludCA9IFsoZmlyc3RQb2ludFswXSAtIHgpIC8gd2lkdGgsIChmaXJzdFBvaW50WzFdIC0geSkgLyBoZWlnaHRdO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RQb2ludFxuICAgIH0gPSB0aGlzLiNmb2N1c091dGxpbmVzO1xuICAgIHRoaXMuI2xhc3RQb2ludCA9IFsobGFzdFBvaW50WzBdIC0geCkgLyB3aWR0aCwgKGxhc3RQb2ludFsxXSAtIHkpIC8gaGVpZ2h0XTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fD0gdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycz8udmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IFwiI2ZmZjA2NlwiO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUjpcbiAgICAgICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1M6XG4gICAgICAgIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzcyA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdHJhbnNsYXRlSW5QYWdlKHgsIHkpIHt9XG4gIGdldCB0b29sYmFyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xhc3RQb2ludDtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNmaXJzdFBvaW50O1xuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1M6XG4gICAgICAgIHRoaXMuI3VwZGF0ZVRoaWNrbmVzcyh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SLCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvcl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTLCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdXTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUiwgdGhpcy5jb2xvciB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvcl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTLCB0aGlzLiN0aGlja25lc3MgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9GUkVFLCB0aGlzLiNpc0ZyZWVIaWdobGlnaHRdXTtcbiAgfVxuICBvblVwZGF0ZWRDb2xvcigpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jaWQsIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgZmlsbDogdGhpcy5jb2xvcixcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogdGhpcy5vcGFjaXR5XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jY29sb3JQaWNrZXI/LnVwZGF0ZUNvbG9yKHRoaXMuY29sb3IpO1xuICAgIHN1cGVyLm9uVXBkYXRlZENvbG9yKCk7XG4gIH1cbiAgI3VwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3Qgc2V0Q29sb3JBbmRPcGFjaXR5ID0gKGNvbCwgb3BhKSA9PiB7XG4gICAgICB0aGlzLmNvbG9yID0gY29sO1xuICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhO1xuICAgICAgdGhpcy5vblVwZGF0ZWRDb2xvcigpO1xuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgY29uc3Qgc2F2ZWRPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRDb2xvckFuZE9wYWNpdHkuYmluZCh0aGlzLCBjb2xvciwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0T3BhY2l0eSksXG4gICAgICB1bmRvOiBzZXRDb2xvckFuZE9wYWNpdHkuYmluZCh0aGlzLCBzYXZlZENvbG9yLCBzYXZlZE9wYWNpdHkpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJjb2xvcl9jaGFuZ2VkXCIsXG4gICAgICBjb2xvcjogdGhpcy5fdWlNYW5hZ2VyLmdldE5vbkhDTUNvbG9yTmFtZShjb2xvcilcbiAgICB9LCB0cnVlKTtcbiAgfVxuICAjdXBkYXRlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGNvbnN0IHNhdmVkVGhpY2tuZXNzID0gdGhpcy4jdGhpY2tuZXNzO1xuICAgIGNvbnN0IHNldFRoaWNrbmVzcyA9IHRoID0+IHtcbiAgICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoO1xuICAgICAgdGhpcy4jY2hhbmdlVGhpY2tuZXNzKHRoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRUaGlja25lc3MuYmluZCh0aGlzLCB0aGlja25lc3MpLFxuICAgICAgdW5kbzogc2V0VGhpY2tuZXNzLmJpbmQodGhpcywgc2F2ZWRUaGlja25lc3MpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUyxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwidGhpY2tuZXNzX2NoYW5nZWRcIixcbiAgICAgIHRoaWNrbmVzc1xuICAgIH0sIHRydWUpO1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycykge1xuICAgICAgY29uc3QgY29sb3JQaWNrZXIgPSB0aGlzLiNjb2xvclBpY2tlciA9IG5ldyBDb2xvclBpY2tlcih7XG4gICAgICAgIGVkaXRvcjogdGhpc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW1tcImNvbG9yUGlja2VyXCIsIGNvbG9yUGlja2VyXV07XG4gICAgfVxuICAgIHJldHVybiBzdXBlci50b29sYmFyQnV0dG9ucztcbiAgfVxuICBkaXNhYmxlRWRpdGluZygpIHtcbiAgICBzdXBlci5kaXNhYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgfVxuICBlbmFibGVFZGl0aW5nKCkge1xuICAgIHN1cGVyLmVuYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuICB9XG4gIGZpeEFuZFNldFBvc2l0aW9uKCkge1xuICAgIHJldHVybiBzdXBlci5maXhBbmRTZXRQb3NpdGlvbih0aGlzLiNnZXRSb3RhdGlvbigpKTtcbiAgfVxuICBnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBnZXRSZWN0KHR4LCB0eSkge1xuICAgIHJldHVybiBzdXBlci5nZXRSZWN0KHR4LCB0eSwgdGhpcy4jZ2V0Um90YXRpb24oKSk7XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICBpZiAoZm9jdXMpIHtcbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiZGVsZXRlZFwiXG4gICAgfSk7XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBsZXQgbXVzdEJlU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgIXBhcmVudCkge1xuICAgICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIocGFyZW50KTtcbiAgICAgIG11c3RCZVNlbGVjdGVkID0gIXRoaXMucGFyZW50ICYmIHRoaXMuZGl2Py5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0UGFyZW50KHBhcmVudCk7XG4gICAgdGhpcy5zaG93KHRoaXMuX2lzVmlzaWJsZSk7XG4gICAgaWYgKG11c3RCZVNlbGVjdGVkKSB7XG4gICAgICB0aGlzLnNlbGVjdCgpO1xuICAgIH1cbiAgfVxuICAjY2hhbmdlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGlmICghdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZUZyZWVPdXRsaW5lcyh7XG4gICAgICBoaWdobGlnaHRPdXRsaW5lczogdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuZ2V0TmV3T3V0bGluZSh0aGlja25lc3MgLyAyKVxuICAgIH0pO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9XG4gICNjbGVhbkRyYXdMYXllcigpIHtcbiAgICBpZiAodGhpcy4jaWQgPT09IG51bGwgfHwgIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy4jaWQpO1xuICAgIHRoaXMuI2lkID0gbnVsbDtcbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuI291dGxpbmVJZCk7XG4gICAgdGhpcy4jb3V0bGluZUlkID0gbnVsbDtcbiAgfVxuICAjYWRkVG9EcmF3TGF5ZXIocGFyZW50ID0gdGhpcy5wYXJlbnQpIHtcbiAgICBpZiAodGhpcy4jaWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKHtcbiAgICAgIGlkOiB0aGlzLiNpZCxcbiAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuI2NsaXBQYXRoSWRcbiAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHtcbiAgICAgIGJib3g6IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveCxcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogXCIwIDAgMSAxXCIsXG4gICAgICAgIGZpbGw6IHRoaXMuY29sb3IsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHRoaXMub3BhY2l0eVxuICAgICAgfSxcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBoaWdobGlnaHQ6IHRydWUsXG4gICAgICAgIGZyZWU6IHRoaXMuI2lzRnJlZUhpZ2hsaWdodFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9LCBmYWxzZSwgdHJ1ZSkpO1xuICAgIHRoaXMuI291dGxpbmVJZCA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhd091dGxpbmUoe1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGhpZ2hsaWdodE91dGxpbmU6IHRydWUsXG4gICAgICAgIGZyZWU6IHRoaXMuI2lzRnJlZUhpZ2hsaWdodFxuICAgICAgfSxcbiAgICAgIGJib3g6IHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLiNmb2N1c091dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfSwgdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KTtcbiAgICBpZiAodGhpcy4jaGlnaGxpZ2h0RGl2KSB7XG4gICAgICB0aGlzLiNoaWdobGlnaHREaXYuc3R5bGUuY2xpcFBhdGggPSB0aGlzLiNjbGlwUGF0aElkO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgI3JvdGF0ZUJib3goW3gsIHksIHdpZHRoLCBoZWlnaHRdLCBhbmdsZSkge1xuICAgIHN3aXRjaCAoYW5nbGUpIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHkgLSBoZWlnaHQsIHgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHggLSB3aWR0aCwgMSAtIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHggLSB3aWR0aCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgfVxuICAgIHJldHVybiBbeCwgeSwgd2lkdGgsIGhlaWdodF07XG4gIH1cbiAgcm90YXRlKGFuZ2xlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZHJhd0xheWVyXG4gICAgfSA9IHRoaXMucGFyZW50O1xuICAgIGxldCBib3g7XG4gICAgaWYgKHRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgYW5nbGUgPSAoYW5nbGUgLSB0aGlzLnJvdGF0aW9uICsgMzYwKSAlIDM2MDtcbiAgICAgIGJveCA9IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3gsIGFuZ2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94ID0gSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdLCBhbmdsZSk7XG4gICAgfVxuICAgIGRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICBiYm94OiBib3gsXG4gICAgICByb290OiB7XG4gICAgICAgIFwiZGF0YS1tYWluLXJvdGF0aW9uXCI6IGFuZ2xlXG4gICAgICB9XG4gICAgfSk7XG4gICAgZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICBiYm94OiBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3godGhpcy4jZm9jdXNPdXRsaW5lcy5ib3gsIGFuZ2xlKSxcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgXCJkYXRhLW1haW4tcm90YXRpb25cIjogYW5nbGVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGlmICh0aGlzLiN0ZXh0KSB7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLiN0ZXh0KTtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibWFya1wiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNrZXlkb3duLmJpbmQodGhpcyksIHtcbiAgICAgICAgc2lnbmFsOiB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGhpZ2hsaWdodERpdiA9IHRoaXMuI2hpZ2hsaWdodERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmFwcGVuZChoaWdobGlnaHREaXYpO1xuICAgIGhpZ2hsaWdodERpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgaGlnaGxpZ2h0RGl2LmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxcIjtcbiAgICBoaWdobGlnaHREaXYuc3R5bGUuY2xpcFBhdGggPSB0aGlzLiNjbGlwUGF0aElkO1xuICAgIHRoaXMuc2V0RGltcyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgYmluZEV2ZW50cyh0aGlzLCB0aGlzLiNoaWdobGlnaHREaXYsIFtcInBvaW50ZXJvdmVyXCIsIFwicG9pbnRlcmxlYXZlXCJdKTtcbiAgICB0aGlzLmVuYWJsZUVkaXRpbmcoKTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gIHBvaW50ZXJvdmVyKCkge1xuICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKSB7XG4gICAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhvdmVyZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBvaW50ZXJsZWF2ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgICBob3ZlcmVkOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgI2tleWRvd24oZXZlbnQpIHtcbiAgICBIaWdobGlnaHRFZGl0b3IuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICBfbW92ZUNhcmV0KGRpcmVjdGlvbikge1xuICAgIHRoaXMucGFyZW50LnVuc2VsZWN0KHRoaXMpO1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuI3NldENhcmV0KHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgdGhpcy4jc2V0Q2FyZXQoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgI3NldENhcmV0KHN0YXJ0KSB7XG4gICAgaWYgKCF0aGlzLiNhbmNob3JOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHNlbGVjdGlvbi5zZXRQb3NpdGlvbih0aGlzLiNhbmNob3JOb2RlLCB0aGlzLiNhbmNob3JPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uc2V0UG9zaXRpb24odGhpcy4jZm9jdXNOb2RlLCB0aGlzLiNmb2N1c09mZnNldCk7XG4gICAgfVxuICB9XG4gIHNlbGVjdCgpIHtcbiAgICBzdXBlci5zZWxlY3QoKTtcbiAgICBpZiAoIXRoaXMuI291dGxpbmVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgaG92ZXJlZDogZmFsc2UsXG4gICAgICAgIHNlbGVjdGVkOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdW5zZWxlY3QoKSB7XG4gICAgc3VwZXIudW5zZWxlY3QoKTtcbiAgICBpZiAoIXRoaXMuI291dGxpbmVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIHRoaXMuI3NldENhcmV0KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9tdXN0Rml4UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLiNpc0ZyZWVIaWdobGlnaHQ7XG4gIH1cbiAgc2hvdyh2aXNpYmxlID0gdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgc3VwZXIuc2hvdyh2aXNpYmxlKTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZGRlbjogIXZpc2libGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlkZGVuOiAhdmlzaWJsZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgI2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0ZyZWVIaWdobGlnaHQgPyB0aGlzLnJvdGF0aW9uIDogMDtcbiAgfVxuICAjc2VyaWFsaXplQm94ZXMoKSB7XG4gICAgaWYgKHRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IGJveGVzID0gdGhpcy4jYm94ZXM7XG4gICAgY29uc3QgcXVhZFBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoYm94ZXMubGVuZ3RoICogOCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHN4ID0geCAqIHBhZ2VXaWR0aCArIHBhZ2VYO1xuICAgICAgY29uc3Qgc3kgPSAoMSAtIHkpICogcGFnZUhlaWdodCArIHBhZ2VZO1xuICAgICAgcXVhZFBvaW50c1tpXSA9IHF1YWRQb2ludHNbaSArIDRdID0gc3g7XG4gICAgICBxdWFkUG9pbnRzW2kgKyAxXSA9IHF1YWRQb2ludHNbaSArIDNdID0gc3k7XG4gICAgICBxdWFkUG9pbnRzW2kgKyAyXSA9IHF1YWRQb2ludHNbaSArIDZdID0gc3ggKyB3aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICAgIHF1YWRQb2ludHNbaSArIDVdID0gcXVhZFBvaW50c1tpICsgN10gPSBzeSAtIGhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgICBpICs9IDg7XG4gICAgfVxuICAgIHJldHVybiBxdWFkUG9pbnRzO1xuICB9XG4gICNzZXJpYWxpemVPdXRsaW5lcyhyZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLnNlcmlhbGl6ZShyZWN0LCB0aGlzLiNnZXRSb3RhdGlvbigpKTtcbiAgfVxuICBzdGF0aWMgc3RhcnRIaWdobGlnaHRpbmcocGFyZW50LCBpc0xUUiwge1xuICAgIHRhcmdldDogdGV4dExheWVyLFxuICAgIHgsXG4gICAgeVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgeDogbGF5ZXJYLFxuICAgICAgeTogbGF5ZXJZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGV4dExheWVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHBhcmVudC5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSBlID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICB0aGlzLiNlbmRIaWdobGlnaHQocGFyZW50LCBlKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgc3RvcEV2ZW50LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRleHRMYXllci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy4jaGlnaGxpZ2h0TW92ZS5iaW5kKHRoaXMsIHBhcmVudCksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuX2ZyZWVIaWdobGlnaHQgPSBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSwgW2xheWVyWCwgbGF5ZXJZLCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSwgcGFyZW50LnNjYWxlLCB0aGlzLl9kZWZhdWx0VGhpY2tuZXNzIC8gMiwgaXNMVFIsIDAuMDAxKTtcbiAgICAoe1xuICAgICAgaWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRJZCxcbiAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRDbGlwSWRcbiAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHtcbiAgICAgIGJib3g6IFswLCAwLCAxLCAxXSxcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogXCIwIDAgMSAxXCIsXG4gICAgICAgIGZpbGw6IHRoaXMuX2RlZmF1bHRDb2xvcixcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogdGhpcy5fZGVmYXVsdE9wYWNpdHlcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgaGlnaGxpZ2h0OiB0cnVlLFxuICAgICAgICBmcmVlOiB0cnVlXG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0LnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfSwgdHJ1ZSwgdHJ1ZSkpO1xuICB9XG4gIHN0YXRpYyAjaGlnaGxpZ2h0TW92ZShwYXJlbnQsIGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2ZyZWVIaWdobGlnaHQuYWRkKGV2ZW50KSkge1xuICAgICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2ZyZWVIaWdobGlnaHRJZCwge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy5fZnJlZUhpZ2hsaWdodC50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljICNlbmRIaWdobGlnaHQocGFyZW50LCBldmVudCkge1xuICAgIGlmICghdGhpcy5fZnJlZUhpZ2hsaWdodC5pc0VtcHR5KCkpIHtcbiAgICAgIHBhcmVudC5jcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGZhbHNlLCB7XG4gICAgICAgIGhpZ2hsaWdodElkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0SWQsXG4gICAgICAgIGhpZ2hsaWdodE91dGxpbmVzOiB0aGlzLl9mcmVlSGlnaGxpZ2h0LmdldE91dGxpbmVzKCksXG4gICAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRDbGlwSWQsXG4gICAgICAgIG1ldGhvZE9mQ3JlYXRpb246IFwibWFpbl90b29sYmFyXCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuZHJhd0xheWVyLnJlbW92ZSh0aGlzLl9mcmVlSGlnaGxpZ2h0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9mcmVlSGlnaGxpZ2h0SWQgPSAtMTtcbiAgICB0aGlzLl9mcmVlSGlnaGxpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLl9mcmVlSGlnaGxpZ2h0Q2xpcElkID0gXCJcIjtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHF1YWRQb2ludHMsXG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBvcGFjaXR5LFxuICAgICAgICAgIHBvcHVwUmVmLFxuICAgICAgICAgIHJpY2hUZXh0LFxuICAgICAgICAgIGNvbnRlbnRzT2JqLFxuICAgICAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShjb2xvciksXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHF1YWRQb2ludHMsXG4gICAgICAgIGJveGVzOiBudWxsLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZDogaWQsXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgIHJpY2hUZXh0LFxuICAgICAgICBjb21tZW50OiBjb250ZW50c09iaj8uc3RyIHx8IG51bGwsXG4gICAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBJbmtBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaW5rTGlzdHMsXG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBib3JkZXJTdHlsZToge1xuICAgICAgICAgICAgcmF3V2lkdGg6IHRoaWNrbmVzc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgcmljaFRleHQsXG4gICAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yKSxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICBpbmtMaXN0cyxcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBpZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgcmljaFRleHQsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbCxcbiAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb2xvcixcbiAgICAgIHF1YWRQb2ludHMsXG4gICAgICBpbmtMaXN0cyxcbiAgICAgIG9wYWNpdHlcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLmNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uY29sb3IpO1xuICAgIGVkaXRvci5vcGFjaXR5ID0gb3BhY2l0eSB8fCAxO1xuICAgIGlmIChpbmtMaXN0cykge1xuICAgICAgZWRpdG9yLiN0aGlja25lc3MgPSBkYXRhLnRoaWNrbmVzcztcbiAgICB9XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIGlmIChkYXRhLmNvbW1lbnQpIHtcbiAgICAgIGVkaXRvci5zZXRDb21tZW50RGF0YShkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSBlZGl0b3IucGFnZVRyYW5zbGF0aW9uO1xuICAgIGlmIChxdWFkUG9pbnRzKSB7XG4gICAgICBjb25zdCBib3hlcyA9IGVkaXRvci4jYm94ZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZFBvaW50cy5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICBib3hlcy5wdXNoKHtcbiAgICAgICAgICB4OiAocXVhZFBvaW50c1tpXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aCxcbiAgICAgICAgICB5OiAxIC0gKHF1YWRQb2ludHNbaSArIDFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodCxcbiAgICAgICAgICB3aWR0aDogKHF1YWRQb2ludHNbaSArIDJdIC0gcXVhZFBvaW50c1tpXSkgLyBwYWdlV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiAocXVhZFBvaW50c1tpICsgMV0gLSBxdWFkUG9pbnRzW2kgKyA1XSkgLyBwYWdlSGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWRpdG9yLiNjcmVhdGVPdXRsaW5lcygpO1xuICAgICAgZWRpdG9yLiNhZGRUb0RyYXdMYXllcigpO1xuICAgICAgZWRpdG9yLnJvdGF0ZShlZGl0b3Iucm90YXRpb24pO1xuICAgIH0gZWxzZSBpZiAoaW5rTGlzdHMpIHtcbiAgICAgIGVkaXRvci4jaXNGcmVlSGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHBvaW50cyA9IGlua0xpc3RzWzBdO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IHBvaW50c1swXSAtIHBhZ2VYLFxuICAgICAgICB5OiBwYWdlSGVpZ2h0IC0gKHBvaW50c1sxXSAtIHBhZ2VZKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG91dGxpbmVyID0gbmV3IEZyZWVIaWdobGlnaHRPdXRsaW5lcihwb2ludCwgWzAsIDAsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIDEsIGVkaXRvci4jdGhpY2tuZXNzIC8gMiwgdHJ1ZSwgMC4wMDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgcG9pbnQueCA9IHBvaW50c1tpXSAtIHBhZ2VYO1xuICAgICAgICBwb2ludC55ID0gcGFnZUhlaWdodCAtIChwb2ludHNbaSArIDFdIC0gcGFnZVkpO1xuICAgICAgICBvdXRsaW5lci5hZGQocG9pbnQpO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgY2xpcFBhdGhJZFxuICAgICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh7XG4gICAgICAgIGJib3g6IFswLCAwLCAxLCAxXSxcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDEgMVwiLFxuICAgICAgICAgIGZpbGw6IGVkaXRvci5jb2xvcixcbiAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBlZGl0b3IuX2RlZmF1bHRPcGFjaXR5XG4gICAgICAgIH0sXG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZ2hsaWdodDogdHJ1ZSxcbiAgICAgICAgICBmcmVlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiBvdXRsaW5lci50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9LCB0cnVlLCB0cnVlKTtcbiAgICAgIGVkaXRvci4jY3JlYXRlRnJlZU91dGxpbmVzKHtcbiAgICAgICAgaGlnaGxpZ2h0T3V0bGluZXM6IG91dGxpbmVyLmdldE91dGxpbmVzKCksXG4gICAgICAgIGhpZ2hsaWdodElkOiBpZCxcbiAgICAgICAgY2xpcFBhdGhJZFxuICAgICAgfSk7XG4gICAgICBlZGl0b3IuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgICBlZGl0b3Iucm90YXRlKGVkaXRvci5wYXJlbnRSb3RhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpIHx8IGlzRm9yQ29weWluZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgY29sb3IgPSBBbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydCh0aGlzLl91aU1hbmFnZXIuZ2V0Tm9uSENNQ29sb3IodGhpcy5jb2xvcikpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzdXBlci5zZXJpYWxpemUoaXNGb3JDb3B5aW5nKTtcbiAgICBPYmplY3QuYXNzaWduKHNlcmlhbGl6ZWQsIHtcbiAgICAgIGNvbG9yLFxuICAgICAgb3BhY2l0eTogdGhpcy5vcGFjaXR5LFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLiN0aGlja25lc3MsXG4gICAgICBxdWFkUG9pbnRzOiB0aGlzLiNzZXJpYWxpemVCb3hlcygpLFxuICAgICAgb3V0bGluZXM6IHRoaXMuI3NlcmlhbGl6ZU91dGxpbmVzKHNlcmlhbGl6ZWQucmVjdClcbiAgICB9KTtcbiAgICB0aGlzLmFkZENvbW1lbnQoc2VyaWFsaXplZCk7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3JcbiAgICB9ID0gdGhpcy5faW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIHRoaXMuaGFzRWRpdGVkQ29tbWVudCB8fCBzZXJpYWxpemVkLmNvbG9yLnNvbWUoKGMsIGkpID0+IGMgIT09IGNvbG9yW2ldKTtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgYW5ub3RhdGlvbi5oaWRlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQoe1xuICAgICAgcmVjdDogdGhpcy5nZXRQREZSZWN0KCksXG4gICAgICBwb3B1cDogdGhpcy5jb21tZW50XG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RhdGljIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhdy5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cbmNsYXNzIERyYXdpbmdPcHRpb25zIHtcbiAgI3N2Z1Byb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB1cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpKSB7XG4gICAgICBpZiAoIW5hbWUuc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy4jc3ZnUHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICB9XG4gIHRvU1ZHUHJvcGVydGllcygpIHtcbiAgICBjb25zdCByb290ID0gdGhpcy4jc3ZnUHJvcGVydGllcztcbiAgICB0aGlzLiNzdmdQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdFxuICAgIH07XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy4jc3ZnUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgdXBkYXRlQWxsKG9wdGlvbnMgPSB0aGlzKSB7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKG9wdGlvbnMpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG59XG5jbGFzcyBEcmF3aW5nRWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNkcmF3T3V0bGluZXMgPSBudWxsO1xuICAjbXVzdEJlQ29tbWl0dGVkO1xuICBfY29sb3JQaWNrZXIgPSBudWxsO1xuICBfZHJhd0lkID0gbnVsbDtcbiAgc3RhdGljIF9jdXJyZW50RHJhd0lkID0gLTE7XG4gIHN0YXRpYyBfY3VycmVudFBhcmVudCA9IG51bGw7XG4gIHN0YXRpYyAjY3VycmVudERyYXcgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnREcmF3aW5nQUMgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnREcmF3aW5nT3B0aW9ucyA9IG51bGw7XG4gIHN0YXRpYyAjY3VycmVudFBvaW50ZXJJZCA9IE5hTjtcbiAgc3RhdGljICNjdXJyZW50UG9pbnRlclR5cGUgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnRQb2ludGVySWRzID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50TW92ZVRpbWVzdGFtcCA9IE5hTjtcbiAgc3RhdGljIF9JTk5FUl9NQVJHSU4gPSAzO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcihwYXJhbXMpO1xuICAgIHRoaXMuI211c3RCZUNvbW1pdHRlZCA9IHBhcmFtcy5tdXN0QmVDb21taXR0ZWQgfHwgZmFsc2U7XG4gICAgdGhpcy5fYWRkT3V0bGluZXMocGFyYW1zKTtcbiAgfVxuICBvblVwZGF0ZWRDb2xvcigpIHtcbiAgICB0aGlzLl9jb2xvclBpY2tlcj8udXBkYXRlKHRoaXMuY29sb3IpO1xuICAgIHN1cGVyLm9uVXBkYXRlZENvbG9yKCk7XG4gIH1cbiAgX2FkZE91dGxpbmVzKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMuZHJhd091dGxpbmVzKSB7XG4gICAgICB0aGlzLiNjcmVhdGVEcmF3T3V0bGluZXMocGFyYW1zKTtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgfVxuICB9XG4gICNjcmVhdGVEcmF3T3V0bGluZXMoe1xuICAgIGRyYXdPdXRsaW5lcyxcbiAgICBkcmF3SWQsXG4gICAgZHJhd2luZ09wdGlvbnNcbiAgfSkge1xuICAgIHRoaXMuI2RyYXdPdXRsaW5lcyA9IGRyYXdPdXRsaW5lcztcbiAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucyB8fD0gZHJhd2luZ09wdGlvbnM7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5hMTF5QWxlcnQoYHBkZmpzLWVkaXRvci0ke3RoaXMuZWRpdG9yVHlwZX0tYWRkZWQtYWxlcnRgKTtcbiAgICB9XG4gICAgaWYgKGRyYXdJZCA+PSAwKSB7XG4gICAgICB0aGlzLl9kcmF3SWQgPSBkcmF3SWQ7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIuZmluYWxpemVEcmF3KGRyYXdJZCwgZHJhd091dGxpbmVzLmRlZmF1bHRQcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZHJhd0lkID0gdGhpcy4jY3JlYXRlRHJhd2luZyhkcmF3T3V0bGluZXMsIHRoaXMucGFyZW50KTtcbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlQmJveChkcmF3T3V0bGluZXMuYm94KTtcbiAgfVxuICAjY3JlYXRlRHJhd2luZyhkcmF3T3V0bGluZXMsIHBhcmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyhEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy5fZHJhd2luZ09wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCksIGRyYXdPdXRsaW5lcy5kZWZhdWx0U1ZHUHJvcGVydGllcyksIGZhbHNlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHN0YXRpYyBfbWVyZ2VTVkdQcm9wZXJ0aWVzKHAxLCBwMikge1xuICAgIGNvbnN0IHAxS2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMocDEpKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwMikpIHtcbiAgICAgIGlmIChwMUtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwMVtrZXldLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwMVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwMTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKF9vcHRpb25zKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlc01hcCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRHJhd2VyKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgY29uc3QgcHJvcGVydHlOYW1lID0gdGhpcy50eXBlc01hcC5nZXQodHlwZSk7XG4gICAgaWYgKHByb3BlcnR5TmFtZSkge1xuICAgICAgdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLnVwZGF0ZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY3VycmVudFBhcmVudCkge1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcudXBkYXRlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLl9jdXJyZW50UGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHRoaXMuY29uc3RydWN0b3IudHlwZXNNYXAuZ2V0KHR5cGUpO1xuICAgIGlmIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVByb3BlcnR5KHR5cGUsIHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IFtdO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnM7XG4gICAgZm9yIChjb25zdCBbdHlwZSwgbmFtZV0gb2YgdGhpcy50eXBlc01hcCkge1xuICAgICAgcHJvcGVydGllcy5wdXNoKFt0eXBlLCBvcHRpb25zW25hbWVdXSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IFtdO1xuICAgIGNvbnN0IHtcbiAgICAgIF9kcmF3aW5nT3B0aW9uc1xuICAgIH0gPSB0aGlzO1xuICAgIGZvciAoY29uc3QgW3R5cGUsIG5hbWVdIG9mIHRoaXMuY29uc3RydWN0b3IudHlwZXNNYXApIHtcbiAgICAgIHByb3BlcnRpZXMucHVzaChbdHlwZSwgX2RyYXdpbmdPcHRpb25zW25hbWVdXSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9XG4gIF91cGRhdGVQcm9wZXJ0eSh0eXBlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kcmF3aW5nT3B0aW9ucztcbiAgICBjb25zdCBzYXZlZFZhbHVlID0gb3B0aW9uc1tuYW1lXTtcbiAgICBjb25zdCBzZXR0ZXIgPSB2YWwgPT4ge1xuICAgICAgb3B0aW9ucy51cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgICAgY29uc3QgYmJveCA9IHRoaXMuI2RyYXdPdXRsaW5lcy51cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgICAgaWYgKGJib3gpIHtcbiAgICAgICAgdGhpcy4jdXBkYXRlQmJveChiYm94KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIG9wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCkpO1xuICAgICAgaWYgKHR5cGUgPT09IHRoaXMuY29sb3JUeXBlKSB7XG4gICAgICAgIHRoaXMub25VcGRhdGVkQ29sb3IoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXR0ZXIuYmluZCh0aGlzLCB2YWx1ZSksXG4gICAgICB1bmRvOiBzZXR0ZXIuYmluZCh0aGlzLCBzYXZlZFZhbHVlKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGUsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICBfb25SZXNpemluZygpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy4jZHJhd091dGxpbmVzLmdldFBhdGhSZXNpemluZ1NWR1Byb3BlcnRpZXModGhpcy4jY29udmVydFRvRHJhd1NwYWNlKCkpLCB7XG4gICAgICBiYm94OiB0aGlzLiNyb3RhdGVCb3goKVxuICAgIH0pKTtcbiAgfVxuICBfb25SZXNpemVkKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh0aGlzLiNkcmF3T3V0bGluZXMuZ2V0UGF0aFJlc2l6ZWRTVkdQcm9wZXJ0aWVzKHRoaXMuI2NvbnZlcnRUb0RyYXdTcGFjZSgpKSwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KSk7XG4gIH1cbiAgX29uVHJhbnNsYXRpbmcoX3gsIF95KSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KTtcbiAgfVxuICBfb25UcmFuc2xhdGVkKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh0aGlzLiNkcmF3T3V0bGluZXMuZ2V0UGF0aFRyYW5zbGF0ZWRTVkdQcm9wZXJ0aWVzKHRoaXMuI2NvbnZlcnRUb0RyYXdTcGFjZSgpLCB0aGlzLnBhcmVudERpbWVuc2lvbnMpLCB7XG4gICAgICBiYm94OiB0aGlzLiNyb3RhdGVCb3goKVxuICAgIH0pKTtcbiAgfVxuICBfb25TdGFydERyYWdnaW5nKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBtb3Zpbmc6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfb25TdG9wRHJhZ2dpbmcoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwge1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIG1vdmluZzogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21taXQoKSB7XG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLmRpc2FibGVFZGl0aW5nKCk7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICBzdXBlci5lbmFibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIGZhbHNlKTtcbiAgfVxuICBnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuI211c3RCZUNvbW1pdHRlZCkge1xuICAgICAgdGhpcy4jbXVzdEJlQ29tbWl0dGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgICBpZiAoZm9jdXMgJiYgdGhpcy5pc09uU2NyZWVuKSB7XG4gICAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgdGhpcy4jdXBkYXRlQmJveCh0aGlzLiNkcmF3T3V0bGluZXMuYm94KTtcbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBsZXQgbXVzdEJlU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgIXBhcmVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZVNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIH0gZWxzZSBpZiAocGFyZW50KSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYWRkU2hvdWxkUmVzY2FsZSh0aGlzKTtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKHBhcmVudCk7XG4gICAgICBtdXN0QmVTZWxlY3RlZCA9ICF0aGlzLnBhcmVudCAmJiB0aGlzLmRpdj8uY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgfVxuICAgIHN1cGVyLnNldFBhcmVudChwYXJlbnQpO1xuICAgIGlmIChtdXN0QmVTZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZWxlY3QoKTtcbiAgICB9XG4gIH1cbiAgI2NsZWFuRHJhd0xheWVyKCkge1xuICAgIGlmICh0aGlzLl9kcmF3SWQgPT09IG51bGwgfHwgIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy5fZHJhd0lkKTtcbiAgICB0aGlzLl9kcmF3SWQgPSBudWxsO1xuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zLnJlc2V0KCk7XG4gIH1cbiAgI2FkZFRvRHJhd0xheWVyKHBhcmVudCA9IHRoaXMucGFyZW50KSB7XG4gICAgaWYgKHRoaXMuX2RyYXdJZCAhPT0gbnVsbCAmJiB0aGlzLnBhcmVudCA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9kcmF3SWQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQYXJlbnQodGhpcy5fZHJhd0lkLCBwYXJlbnQuZHJhd0xheWVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZHJhd2luZ09wdGlvbnMudXBkYXRlQWxsKCk7XG4gICAgdGhpcy5fZHJhd0lkID0gdGhpcy4jY3JlYXRlRHJhd2luZyh0aGlzLiNkcmF3T3V0bGluZXMsIHBhcmVudCk7XG4gIH1cbiAgI2NvbnZlcnRUb1BhcmVudFNwYWNlKFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudERpbWVuc2lvbnM6IFtwVywgcEhdLFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcztcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4LCB3aWR0aCAqIChwSCAvIHBXKSwgaGVpZ2h0ICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWzEgLSB4LCAxIC0geSwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeCwgd2lkdGggKiAocEggLyBwVyksIGhlaWdodCAqIChwVyAvIHBIKV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgIH1cbiAgfVxuICAjY29udmVydFRvRHJhd1NwYWNlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcFcsIHBIXSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeCwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHgsIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgI3VwZGF0ZUJib3goYmJveCkge1xuICAgIFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdID0gdGhpcy4jY29udmVydFRvUGFyZW50U3BhY2UoYmJveCk7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLnNldERpbXMoKTtcbiAgICB9XG4gICAgdGhpcy5fb25SZXNpemVkKCk7XG4gIH1cbiAgI3JvdGF0ZUJveCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcm90YXRpb24sXG4gICAgICBwYXJlbnRSb3RhdGlvbixcbiAgICAgIHBhcmVudERpbWVuc2lvbnM6IFtwVywgcEhdXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoICgocm90YXRpb24gKiA0ICsgcGFyZW50Um90YXRpb24pIC8gOTApIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIFsxIC0geSAtIGhlaWdodCwgeCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBbMSAtIHggLSB3aWR0aCwgMSAtIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4IC0gd2lkdGgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gW3gsIHkgLSB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gWzEgLSB4IC0gaGVpZ2h0ICogKHBIIC8gcFcpLCAxIC0geSwgaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDc6XG4gICAgICAgIHJldHVybiBbeSAtIHdpZHRoICogKHBXIC8gcEgpLCAxIC0geCAtIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBjYXNlIDg6XG4gICAgICAgIHJldHVybiBbeCAtIHdpZHRoLCB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgOTpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeCAtIHdpZHRoLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMTE6XG4gICAgICAgIHJldHVybiBbeSAtIGhlaWdodCwgMSAtIHgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxMjpcbiAgICAgICAgcmV0dXJuIFt4IC0gaGVpZ2h0ICogKHBIIC8gcFcpLCB5LCBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIHJldHVybiBbMSAtIHkgLSB3aWR0aCAqIChwVyAvIHBIKSwgeCAtIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBjYXNlIDE0OlxuICAgICAgICByZXR1cm4gWzEgLSB4LCAxIC0geSAtIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHgsIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgcm90YXRlKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXMoe1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9LCB0aGlzLiNkcmF3T3V0bGluZXMudXBkYXRlUm90YXRpb24oKHRoaXMucGFyZW50Um90YXRpb24gLSB0aGlzLnJvdGF0aW9uICsgMzYwKSAlIDM2MCkpKTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVCYm94KHRoaXMuI2RyYXdPdXRsaW5lcy51cGRhdGVQYXJlbnREaW1lbnNpb25zKHRoaXMucGFyZW50RGltZW5zaW9ucywgdGhpcy5wYXJlbnQuc2NhbGUpKTtcbiAgfVxuICBzdGF0aWMgb25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmcoKSB7fVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMuX2lzQ29weSkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgY29uc3QgZGl2ID0gc3VwZXIucmVuZGVyKCk7XG4gICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJkcmF3XCIpO1xuICAgIGNvbnN0IGRyYXdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5hcHBlbmQoZHJhd0Rpdik7XG4gICAgZHJhd0Rpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgZHJhd0Rpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgdGhpcy5zZXREaW1zKCk7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdGluZygpO1xuICAgIGlmICh0aGlzLl9pc0NvcHkpIHtcbiAgICAgIHRoaXMuX21vdmVBZnRlclBhc3RlKGJhc2VYLCBiYXNlWSk7XG4gICAgfVxuICAgIHJldHVybiBkaXY7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZURyYXdlckluc3RhbmNlKF94LCBfeSwgX3BhcmVudFdpZHRoLCBfcGFyZW50SGVpZ2h0LCBfcm90YXRpb24pIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBzdGF0aWMgc3RhcnREcmF3aW5nKHBhcmVudCwgdWlNYW5hZ2VyLCBfaXNMVFIsIGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAgb2Zmc2V0WDogeCxcbiAgICAgIG9mZnNldFk6IHksXG4gICAgICBwb2ludGVySWQsXG4gICAgICBwb2ludGVyVHlwZVxuICAgIH0gPSBldmVudDtcbiAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJUeXBlICYmIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSAhPT0gcG9pbnRlclR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH1cbiAgICB9ID0gcGFyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBhYyA9IERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gcGFyZW50LmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkIHx8PSBwb2ludGVySWQ7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJUeXBlID8/PSBwb2ludGVyVHlwZTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBlID0+IHtcbiAgICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuICAgICAgICB0aGlzLl9lbmREcmF3KGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZHM/LmRlbGV0ZShlLnBvaW50ZXJJZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIGUgPT4ge1xuICAgICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQuZW5kRHJhd2luZ1Nlc3Npb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWRzPy5kZWxldGUoZS5wb2ludGVySWQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZSA9PiB7XG4gICAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJUeXBlICE9PSBlLnBvaW50ZXJUeXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkcyB8fD0gbmV3IFNldCgpKS5hZGQoZS5wb2ludGVySWQpO1xuICAgICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmlzQ2FuY2VsbGFibGUoKSkge1xuICAgICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5yZW1vdmVMYXN0RWxlbWVudCgpO1xuICAgICAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFBhcmVudC5lbmREcmF3aW5nU2Vzc2lvbih0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9lbmREcmF3KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuX2RyYXdNb3ZlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGUgPT4ge1xuICAgICAgaWYgKGUudGltZVN0YW1wID09PSBEcmF3aW5nRWRpdG9yLiNjdXJyZW50TW92ZVRpbWVzdGFtcCkge1xuICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcGFyZW50LnRvZ2dsZURyYXdpbmcoKTtcbiAgICB1aU1hbmFnZXIuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcpIHtcbiAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9jdXJyZW50RHJhd0lkLCBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5zdGFydE5ldyh4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1aU1hbmFnZXIudXBkYXRlVUlGb3JEZWZhdWx0UHJvcGVydGllcyh0aGlzKTtcbiAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdyA9IHRoaXMuY3JlYXRlRHJhd2VySW5zdGFuY2UoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pO1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nT3B0aW9ucyA9IHRoaXMuZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKCk7XG4gICAgdGhpcy5fY3VycmVudFBhcmVudCA9IHBhcmVudDtcbiAgICAoe1xuICAgICAgaWQ6IHRoaXMuX2N1cnJlbnREcmF3SWRcbiAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHRoaXMuX21lcmdlU1ZHUHJvcGVydGllcyhEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ09wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCksIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmRlZmF1bHRTVkdQcm9wZXJ0aWVzKSwgdHJ1ZSwgZmFsc2UpKTtcbiAgfVxuICBzdGF0aWMgX2RyYXdNb3ZlKGV2ZW50KSB7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudE1vdmVUaW1lc3RhbXAgPSAtMTtcbiAgICBpZiAoIURyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgcG9pbnRlcklkXG4gICAgfSA9IGV2ZW50O1xuICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkICE9PSBwb2ludGVySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWRzPy5zaXplID49IDEpIHtcbiAgICAgIHRoaXMuX2VuZERyYXcoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50UGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmFkZChvZmZzZXRYLCBvZmZzZXRZKSk7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudE1vdmVUaW1lc3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG4gICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgfVxuICBzdGF0aWMgX2NsZWFudXAoYWxsKSB7XG4gICAgaWYgKGFsbCkge1xuICAgICAgdGhpcy5fY3VycmVudERyYXdJZCA9IC0xO1xuICAgICAgdGhpcy5fY3VycmVudFBhcmVudCA9IG51bGw7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdyA9IG51bGw7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ09wdGlvbnMgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRNb3ZlVGltZXN0YW1wID0gTmFOO1xuICAgIH1cbiAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdBQykge1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdBQy5hYm9ydCgpO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdBQyA9IG51bGw7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkID0gTmFOO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZHMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX2VuZERyYXcoZXZlbnQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9jdXJyZW50UGFyZW50O1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhcmVudC50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xuICAgIGlmIChldmVudD8udGFyZ2V0ID09PSBwYXJlbnQuZGl2KSB7XG4gICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuZW5kKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MpIHtcbiAgICAgIGNvbnN0IGRyYXcgPSBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdztcbiAgICAgIGNvbnN0IGRyYXdJZCA9IHRoaXMuX2N1cnJlbnREcmF3SWQ7XG4gICAgICBjb25zdCBsYXN0RWxlbWVudCA9IGRyYXcuZ2V0TGFzdEVsZW1lbnQoKTtcbiAgICAgIHBhcmVudC5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyhkcmF3SWQsIGRyYXcuc2V0TGFzdEVsZW1lbnQobGFzdEVsZW1lbnQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyhkcmF3SWQsIGRyYXcucmVtb3ZlTGFzdEVsZW1lbnQoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG11c3RFeGVjOiBmYWxzZSxcbiAgICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRFJBV19TVEVQXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmREcmF3aW5nKGZhbHNlKTtcbiAgfVxuICBzdGF0aWMgZW5kRHJhd2luZyhpc0Fib3J0ZWQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9jdXJyZW50UGFyZW50O1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGFyZW50LnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgcGFyZW50LmNsZWFuVW5kb1N0YWNrKEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkRSQVdfU1RFUCk7XG4gICAgaWYgKCFEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5pc0VtcHR5KCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdLFxuICAgICAgICBzY2FsZVxuICAgICAgfSA9IHBhcmVudDtcbiAgICAgIGNvbnN0IGVkaXRvciA9IHBhcmVudC5jcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwXG4gICAgICB9LCBmYWxzZSwge1xuICAgICAgICBkcmF3SWQ6IHRoaXMuX2N1cnJlbnREcmF3SWQsXG4gICAgICAgIGRyYXdPdXRsaW5lczogRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuZ2V0T3V0bGluZXMocGFnZVdpZHRoICogc2NhbGUsIHBhZ2VIZWlnaHQgKiBzY2FsZSwgc2NhbGUsIHRoaXMuX0lOTkVSX01BUkdJTiksXG4gICAgICAgIGRyYXdpbmdPcHRpb25zOiBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ09wdGlvbnMsXG4gICAgICAgIG11c3RCZUNvbW1pdHRlZDogIWlzQWJvcnRlZFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9jbGVhbnVwKHRydWUpO1xuICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9XG4gICAgcGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy5fY3VycmVudERyYXdJZCk7XG4gICAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjcmVhdGVEcmF3aW5nT3B0aW9ucyhfZGF0YSkge31cbiAgc3RhdGljIGRlc2VyaWFsaXplRHJhdyhfcGFnZVgsIF9wYWdlWSwgX3BhZ2VXaWR0aCwgX3BhZ2VIZWlnaHQsIF9pbm5lcldpZHRoLCBfZGF0YSkge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICBwYWdlWCxcbiAgICAgICAgcGFnZVlcbiAgICAgIH1cbiAgICB9ID0gcGFyZW50LnZpZXdwb3J0O1xuICAgIGNvbnN0IGRyYXdPdXRsaW5lcyA9IHRoaXMuZGVzZXJpYWxpemVEcmF3KHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCB0aGlzLl9JTk5FUl9NQVJHSU4sIGRhdGEpO1xuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuY3JlYXRlRHJhd2luZ09wdGlvbnMoZGF0YSk7XG4gICAgZWRpdG9yLiNjcmVhdGVEcmF3T3V0bGluZXMoe1xuICAgICAgZHJhd091dGxpbmVzXG4gICAgfSk7XG4gICAgZWRpdG9yLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIGVkaXRvci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICBlZGl0b3Iucm90YXRlKCk7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemVEcmF3KGlzRm9yQ29weWluZykge1xuICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIHJldHVybiB0aGlzLiNkcmF3T3V0bGluZXMuc2VyaWFsaXplKFtwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIGlzRm9yQ29weWluZyk7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpXG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RhdGljIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhd2Vycy9pbmtkcmF3LmpzXG5cblxuXG5cblxuXG5cblxuXG5jbGFzcyBJbmtEcmF3T3V0bGluZXIge1xuICAjbGFzdCA9IG5ldyBGbG9hdDY0QXJyYXkoNik7XG4gICNsaW5lO1xuICAjbGluZXM7XG4gICNyb3RhdGlvbjtcbiAgI3RoaWNrbmVzcztcbiAgI3BvaW50cztcbiAgI2xhc3RTVkdQYXRoID0gXCJcIjtcbiAgI2xhc3RJbmRleCA9IDA7XG4gICNvdXRsaW5lcyA9IG5ldyBJbmtEcmF3T3V0bGluZSgpO1xuICAjcGFyZW50V2lkdGg7XG4gICNwYXJlbnRIZWlnaHQ7XG4gIGNvbnN0cnVjdG9yKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uLCB0aGlja25lc3MpIHtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHBhcmVudFdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoaWNrbmVzcztcbiAgICBbeCwgeV0gPSB0aGlzLiNub3JtYWxpemVQb2ludCh4LCB5KTtcbiAgICBjb25zdCBsaW5lID0gdGhpcy4jbGluZSA9IFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHldO1xuICAgIHRoaXMuI3BvaW50cyA9IFt4LCB5XTtcbiAgICB0aGlzLiNsaW5lcyA9IFt7XG4gICAgICBsaW5lLFxuICAgICAgcG9pbnRzOiB0aGlzLiNwb2ludHNcbiAgICB9XTtcbiAgICB0aGlzLiNsYXN0LnNldChsaW5lLCAwKTtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lID09PSBcInN0cm9rZS13aWR0aFwiKSB7XG4gICAgICB0aGlzLiN0aGlja25lc3MgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgI25vcm1hbGl6ZVBvaW50KHgsIHkpIHtcbiAgICByZXR1cm4gT3V0bGluZS5fbm9ybWFsaXplUG9pbnQoeCwgeSwgdGhpcy4jcGFyZW50V2lkdGgsIHRoaXMuI3BhcmVudEhlaWdodCwgdGhpcy4jcm90YXRpb24pO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLiNsaW5lcyB8fCB0aGlzLiNsaW5lcy5sZW5ndGggPT09IDA7XG4gIH1cbiAgaXNDYW5jZWxsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9pbnRzLmxlbmd0aCA8PSAxMDtcbiAgfVxuICBhZGQoeCwgeSkge1xuICAgIFt4LCB5XSA9IHRoaXMuI25vcm1hbGl6ZVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IFt4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDIsIDYpO1xuICAgIGNvbnN0IGRpZmZYID0geCAtIHgyO1xuICAgIGNvbnN0IGRpZmZZID0geSAtIHkyO1xuICAgIGNvbnN0IGQgPSBNYXRoLmh5cG90KHRoaXMuI3BhcmVudFdpZHRoICogZGlmZlgsIHRoaXMuI3BhcmVudEhlaWdodCAqIGRpZmZZKTtcbiAgICBpZiAoZCA8PSAyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgaWYgKGlzTmFOKHgxKSkge1xuICAgICAgdGhpcy4jbGFzdC5zZXQoW3gyLCB5MiwgeCwgeV0sIDIpO1xuICAgICAgdGhpcy4jbGluZS5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgeCwgeSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNOYU4odGhpcy4jbGFzdFswXSkpIHtcbiAgICAgIHRoaXMuI2xpbmUuc3BsaWNlKDYsIDYpO1xuICAgIH1cbiAgICB0aGlzLiNsYXN0LnNldChbeDEsIHkxLCB4MiwgeTIsIHgsIHldLCAwKTtcbiAgICB0aGlzLiNsaW5lLnB1c2goLi4uT3V0bGluZS5jcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgsIHkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBlbmQoeCwgeSkge1xuICAgIGNvbnN0IGNoYW5nZSA9IHRoaXMuYWRkKHgsIHkpO1xuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGlmICh0aGlzLiNwb2ludHMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGFydE5ldyh4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbikge1xuICAgIHRoaXMuI3BhcmVudFdpZHRoID0gcGFyZW50V2lkdGg7XG4gICAgdGhpcy4jcGFyZW50SGVpZ2h0ID0gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuI3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgW3gsIHldID0gdGhpcy4jbm9ybWFsaXplUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuI2xpbmUgPSBbTmFOLCBOYU4sIE5hTiwgTmFOLCB4LCB5XTtcbiAgICB0aGlzLiNwb2ludHMgPSBbeCwgeV07XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuI2xpbmVzLmF0KC0xKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5saW5lID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LmxpbmUpO1xuICAgICAgbGFzdC5wb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGxhc3QucG9pbnRzKTtcbiAgICB9XG4gICAgdGhpcy4jbGluZXMucHVzaCh7XG4gICAgICBsaW5lLFxuICAgICAgcG9pbnRzOiB0aGlzLiNwb2ludHNcbiAgICB9KTtcbiAgICB0aGlzLiNsYXN0LnNldChsaW5lLCAwKTtcbiAgICB0aGlzLiNsYXN0SW5kZXggPSAwO1xuICAgIHRoaXMudG9TVkdQYXRoKCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0TGFzdEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xpbmVzLmF0KC0xKTtcbiAgfVxuICBzZXRMYXN0RWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKCF0aGlzLiNsaW5lcykge1xuICAgICAgcmV0dXJuIHRoaXMuI291dGxpbmVzLnNldExhc3RFbGVtZW50KGVsZW1lbnQpO1xuICAgIH1cbiAgICB0aGlzLiNsaW5lcy5wdXNoKGVsZW1lbnQpO1xuICAgIHRoaXMuI2xpbmUgPSBlbGVtZW50LmxpbmU7XG4gICAgdGhpcy4jcG9pbnRzID0gZWxlbWVudC5wb2ludHM7XG4gICAgdGhpcy4jbGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZW1vdmVMYXN0RWxlbWVudCgpIHtcbiAgICBpZiAoIXRoaXMuI2xpbmVzKSB7XG4gICAgICByZXR1cm4gdGhpcy4jb3V0bGluZXMucmVtb3ZlTGFzdEVsZW1lbnQoKTtcbiAgICB9XG4gICAgdGhpcy4jbGluZXMucG9wKCk7XG4gICAgdGhpcy4jbGFzdFNWR1BhdGggPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuI2xpbmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9ID0gdGhpcy4jbGluZXNbaV07XG4gICAgICB0aGlzLiNsaW5lID0gbGluZTtcbiAgICAgIHRoaXMuI3BvaW50cyA9IHBvaW50cztcbiAgICAgIHRoaXMuI2xhc3RJbmRleCA9IDA7XG4gICAgICB0aGlzLnRvU1ZHUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLiNsYXN0U1ZHUGF0aFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGZpcnN0WCA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVs0XSk7XG4gICAgY29uc3QgZmlyc3RZID0gT3V0bGluZS5zdmdSb3VuZCh0aGlzLiNsaW5lWzVdKTtcbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy4jbGFzdFNWR1BhdGggPSBgJHt0aGlzLiNsYXN0U1ZHUGF0aH0gTSAke2ZpcnN0WH0gJHtmaXJzdFl9IFpgO1xuICAgICAgcmV0dXJuIHRoaXMuI2xhc3RTVkdQYXRoO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA8PSA2KSB7XG4gICAgICBjb25zdCBpID0gdGhpcy4jbGFzdFNWR1BhdGgubGFzdEluZGV4T2YoXCJNXCIpO1xuICAgICAgdGhpcy4jbGFzdFNWR1BhdGggPSBgJHt0aGlzLiNsYXN0U1ZHUGF0aC5zbGljZSgwLCBpKX0gTSAke2ZpcnN0WH0gJHtmaXJzdFl9YDtcbiAgICAgIHRoaXMuI2xhc3RJbmRleCA9IDY7XG4gICAgfVxuICAgIGlmICh0aGlzLiNwb2ludHMubGVuZ3RoID09PSA0KSB7XG4gICAgICBjb25zdCBzZWNvbmRYID0gT3V0bGluZS5zdmdSb3VuZCh0aGlzLiNsaW5lWzEwXSk7XG4gICAgICBjb25zdCBzZWNvbmRZID0gT3V0bGluZS5zdmdSb3VuZCh0aGlzLiNsaW5lWzExXSk7XG4gICAgICB0aGlzLiNsYXN0U1ZHUGF0aCA9IGAke3RoaXMuI2xhc3RTVkdQYXRofSBMICR7c2Vjb25kWH0gJHtzZWNvbmRZfWA7XG4gICAgICB0aGlzLiNsYXN0SW5kZXggPSAxMjtcbiAgICAgIHJldHVybiB0aGlzLiNsYXN0U1ZHUGF0aDtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgaWYgKHRoaXMuI2xhc3RJbmRleCA9PT0gMCkge1xuICAgICAgYnVmZmVyLnB1c2goYE0gJHtmaXJzdFh9ICR7Zmlyc3RZfWApO1xuICAgICAgdGhpcy4jbGFzdEluZGV4ID0gNjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuI2xhc3RJbmRleCwgaWkgPSB0aGlzLiNsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgIGNvbnN0IFtjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHldID0gdGhpcy4jbGluZS5zbGljZShpLCBpICsgNikubWFwKE91dGxpbmUuc3ZnUm91bmQpO1xuICAgICAgYnVmZmVyLnB1c2goYEMke2MxeH0gJHtjMXl9ICR7YzJ4fSAke2MyeX0gJHt4fSAke3l9YCk7XG4gICAgfVxuICAgIHRoaXMuI2xhc3RTVkdQYXRoICs9IGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgICB0aGlzLiNsYXN0SW5kZXggPSB0aGlzLiNsaW5lLmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy4jbGFzdFNWR1BhdGg7XG4gIH1cbiAgZ2V0T3V0bGluZXMocGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgc2NhbGUsIGlubmVyTWFyZ2luKSB7XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuI2xpbmVzLmF0KC0xKTtcbiAgICBsYXN0LmxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KGxhc3QubGluZSk7XG4gICAgbGFzdC5wb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGxhc3QucG9pbnRzKTtcbiAgICB0aGlzLiNvdXRsaW5lcy5idWlsZCh0aGlzLiNsaW5lcywgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgc2NhbGUsIHRoaXMuI3JvdGF0aW9uLCB0aGlzLiN0aGlja25lc3MsIGlubmVyTWFyZ2luKTtcbiAgICB0aGlzLiNsYXN0ID0gbnVsbDtcbiAgICB0aGlzLiNsaW5lID0gbnVsbDtcbiAgICB0aGlzLiNsaW5lcyA9IG51bGw7XG4gICAgdGhpcy4jbGFzdFNWR1BhdGggPSBudWxsO1xuICAgIHJldHVybiB0aGlzLiNvdXRsaW5lcztcbiAgfVxuICBnZXQgZGVmYXVsdFNWR1Byb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogXCIwIDAgMTAwMDAgMTAwMDBcIlxuICAgICAgfSxcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBkcmF3OiB0cnVlXG4gICAgICB9LFxuICAgICAgYmJveDogWzAsIDAsIDEsIDFdXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgSW5rRHJhd091dGxpbmUgZXh0ZW5kcyBPdXRsaW5lIHtcbiAgI2Jib3g7XG4gICNjdXJyZW50Um90YXRpb24gPSAwO1xuICAjaW5uZXJNYXJnaW47XG4gICNsaW5lcztcbiAgI3BhcmVudFdpZHRoO1xuICAjcGFyZW50SGVpZ2h0O1xuICAjcGFyZW50U2NhbGU7XG4gICNyb3RhdGlvbjtcbiAgI3RoaWNrbmVzcztcbiAgYnVpbGQobGluZXMsIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHBhcmVudFNjYWxlLCByb3RhdGlvbiwgdGhpY2tuZXNzLCBpbm5lck1hcmdpbikge1xuICAgIHRoaXMuI3BhcmVudFdpZHRoID0gcGFyZW50V2lkdGg7XG4gICAgdGhpcy4jcGFyZW50SGVpZ2h0ID0gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuI3BhcmVudFNjYWxlID0gcGFyZW50U2NhbGU7XG4gICAgdGhpcy4jcm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLiN0aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgdGhpcy4jaW5uZXJNYXJnaW4gPSBpbm5lck1hcmdpbiA/PyAwO1xuICAgIHRoaXMuI2xpbmVzID0gbGluZXM7XG4gICAgdGhpcy4jY29tcHV0ZUJib3goKTtcbiAgfVxuICBnZXQgdGhpY2tuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLiN0aGlja25lc3M7XG4gIH1cbiAgc2V0TGFzdEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHRoaXMuI2xpbmVzLnB1c2goZWxlbWVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmVtb3ZlTGFzdEVsZW1lbnQoKSB7XG4gICAgdGhpcy4jbGluZXMucG9wKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbGluZVxuICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGBNJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbNF0pfSAke091dGxpbmUuc3ZnUm91bmQobGluZVs1XSl9YCk7XG4gICAgICBpZiAobGluZS5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMTIgJiYgaXNOYU4obGluZVs2XSkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke091dGxpbmUuc3ZnUm91bmQobGluZVsxMF0pfSAke091dGxpbmUuc3ZnUm91bmQobGluZVsxMV0pfWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgICBjb25zdCBbYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5XSA9IGxpbmUuc3ViYXJyYXkoaSwgaSArIDYpLm1hcChPdXRsaW5lLnN2Z1JvdW5kKTtcbiAgICAgICAgYnVmZmVyLnB1c2goYEMke2MxeH0gJHtjMXl9ICR7YzJ4fSAke2MyeX0gJHt4fSAke3l9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihcIlwiKTtcbiAgfVxuICBzZXJpYWxpemUoW3BhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSwgaXNGb3JDb3B5aW5nKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZExpbmVzID0gW107XG4gICAgY29uc3Qgc2VyaWFsaXplZFBvaW50cyA9IFtdO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2dldEJCb3hXaXRoTm9NYXJnaW4oKTtcbiAgICBsZXQgdHgsIHR5LCBzeCwgc3ksIHgxLCB5MSwgeDIsIHkyLCByZXNjYWxlRm47XG4gICAgc3dpdGNoICh0aGlzLiNyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IHBhZ2VYO1xuICAgICAgICB0eSA9IHBhZ2VZICsgcGFnZUhlaWdodDtcbiAgICAgICAgc3ggPSBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gLXBhZ2VIZWlnaHQ7XG4gICAgICAgIHgxID0gcGFnZVggKyB4ICogcGFnZVdpZHRoO1xuICAgICAgICB5MSA9IHBhZ2VZICsgKDEgLSB5IC0gaGVpZ2h0KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgyID0gcGFnZVggKyAoeCArIHdpZHRoKSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICgxIC0geSkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IHBhZ2VYO1xuICAgICAgICB0eSA9IHBhZ2VZO1xuICAgICAgICBzeCA9IHBhZ2VXaWR0aDtcbiAgICAgICAgc3kgPSBwYWdlSGVpZ2h0O1xuICAgICAgICB4MSA9IHBhZ2VYICsgeSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArIHggKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKHkgKyBoZWlnaHQpICogcGFnZVdpZHRoO1xuICAgICAgICB5MiA9IHBhZ2VZICsgKHggKyB3aWR0aCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IHBhZ2VYICsgcGFnZVdpZHRoO1xuICAgICAgICB0eSA9IHBhZ2VZO1xuICAgICAgICBzeCA9IC1wYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gcGFnZUhlaWdodDtcbiAgICAgICAgeDEgPSBwYWdlWCArICgxIC0geCAtIHdpZHRoKSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArIHkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKDEgLSB4KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICh5ICsgaGVpZ2h0KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IHBhZ2VYICsgcGFnZVdpZHRoO1xuICAgICAgICB0eSA9IHBhZ2VZICsgcGFnZUhlaWdodDtcbiAgICAgICAgc3ggPSAtcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IC1wYWdlSGVpZ2h0O1xuICAgICAgICB4MSA9IHBhZ2VYICsgKDEgLSB5IC0gaGVpZ2h0KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArICgxIC0geCAtIHdpZHRoKSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgyID0gcGFnZVggKyAoMSAtIHkpICogcGFnZVdpZHRoO1xuICAgICAgICB5MiA9IHBhZ2VZICsgKDEgLSB4KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGxpbmUsXG4gICAgICBwb2ludHNcbiAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICBzZXJpYWxpemVkTGluZXMucHVzaChyZXNjYWxlRm4obGluZSwgdHgsIHR5LCBzeCwgc3ksIGlzRm9yQ29weWluZyA/IG5ldyBBcnJheShsaW5lLmxlbmd0aCkgOiBudWxsKSk7XG4gICAgICBzZXJpYWxpemVkUG9pbnRzLnB1c2gocmVzY2FsZUZuKHBvaW50cywgdHgsIHR5LCBzeCwgc3ksIGlzRm9yQ29weWluZyA/IG5ldyBBcnJheShwb2ludHMubGVuZ3RoKSA6IG51bGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVzOiBzZXJpYWxpemVkTGluZXMsXG4gICAgICBwb2ludHM6IHNlcmlhbGl6ZWRQb2ludHMsXG4gICAgICByZWN0OiBbeDEsIHkxLCB4MiwgeTJdXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCB7XG4gICAgcGF0aHM6IHtcbiAgICAgIGxpbmVzLFxuICAgICAgcG9pbnRzXG4gICAgfSxcbiAgICByb3RhdGlvbixcbiAgICB0aGlja25lc3NcbiAgfSkge1xuICAgIGNvbnN0IG5ld0xpbmVzID0gW107XG4gICAgbGV0IHR4LCB0eSwgc3gsIHN5LCByZXNjYWxlRm47XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IC1wYWdlWCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgdHkgPSBwYWdlWSAvIHBhZ2VIZWlnaHQgKyAxO1xuICAgICAgICBzeCA9IDEgLyBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gLTEgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IC1wYWdlWSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHR5ID0gLXBhZ2VYIC8gcGFnZVdpZHRoO1xuICAgICAgICBzeCA9IDEgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBzeSA9IDEgLyBwYWdlV2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGU7XG4gICAgICAgIHR4ID0gcGFnZVggLyBwYWdlV2lkdGggKyAxO1xuICAgICAgICB0eSA9IC1wYWdlWSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN4ID0gLTEgLyBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gMSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IHBhZ2VZIC8gcGFnZUhlaWdodCArIDE7XG4gICAgICAgIHR5ID0gcGFnZVggLyBwYWdlV2lkdGggKyAxO1xuICAgICAgICBzeCA9IC0xIC8gcGFnZUhlaWdodDtcbiAgICAgICAgc3kgPSAtMSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbGluZXMpIHtcbiAgICAgIGxpbmVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHBvaW50cykge1xuICAgICAgICBjb25zdCBsZW4gPSBwb2ludC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDIpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkoW05hTiwgTmFOLCBOYU4sIE5hTiwgcG9pbnRbMF0sIHBvaW50WzFdXSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPT09IDQpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkoW05hTiwgTmFOLCBOYU4sIE5hTiwgcG9pbnRbMF0sIHBvaW50WzFdLCBOYU4sIE5hTiwgTmFOLCBOYU4sIHBvaW50WzJdLCBwb2ludFszXV0pKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lID0gbmV3IEZsb2F0MzJBcnJheSgzICogKGxlbiAtIDIpKTtcbiAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgbGV0IFt4MSwgeTEsIHgyLCB5Ml0gPSBwb2ludC5zdWJhcnJheSgwLCA0KTtcbiAgICAgICAgbGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgeDEsIHkxXSwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSA0OyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRbaV07XG4gICAgICAgICAgY29uc3QgeSA9IHBvaW50W2kgKyAxXTtcbiAgICAgICAgICBsaW5lLnNldChPdXRsaW5lLmNyZWF0ZUJlemllclBvaW50cyh4MSwgeTEsIHgyLCB5MiwgeCwgeSksIChpIC0gMikgKiAzKTtcbiAgICAgICAgICBbeDEsIHkxLCB4MiwgeTJdID0gW3gyLCB5MiwgeCwgeV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGluZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgbmV3TGluZXMucHVzaCh7XG4gICAgICAgIGxpbmU6IHJlc2NhbGVGbihsaW5lc1tpXS5tYXAoeCA9PiB4ID8/IE5hTiksIHR4LCB0eSwgc3gsIHN5KSxcbiAgICAgICAgcG9pbnRzOiByZXNjYWxlRm4ocG9pbnRzW2ldLm1hcCh4ID0+IHggPz8gTmFOKSwgdHgsIHR5LCBzeCwgc3kpXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZXMgPSBuZXcgdGhpcy5wcm90b3R5cGUuY29uc3RydWN0b3IoKTtcbiAgICBvdXRsaW5lcy5idWlsZChuZXdMaW5lcywgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCAxLCByb3RhdGlvbiwgdGhpY2tuZXNzLCBpbm5lck1hcmdpbik7XG4gICAgcmV0dXJuIG91dGxpbmVzO1xuICB9XG4gICNnZXRNYXJnaW5Db21wb25lbnRzKHRoaWNrbmVzcyA9IHRoaXMuI3RoaWNrbmVzcykge1xuICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMuI2lubmVyTWFyZ2luICsgdGhpY2tuZXNzIC8gMiAqIHRoaXMuI3BhcmVudFNjYWxlO1xuICAgIHJldHVybiB0aGlzLiNyb3RhdGlvbiAlIDE4MCA9PT0gMCA/IFttYXJnaW4gLyB0aGlzLiNwYXJlbnRXaWR0aCwgbWFyZ2luIC8gdGhpcy4jcGFyZW50SGVpZ2h0XSA6IFttYXJnaW4gLyB0aGlzLiNwYXJlbnRIZWlnaHQsIG1hcmdpbiAvIHRoaXMuI3BhcmVudFdpZHRoXTtcbiAgfVxuICAjZ2V0QkJveFdpdGhOb01hcmdpbigpIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IFttYXJnaW5YLCBtYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoMCk7XG4gICAgcmV0dXJuIFt4ICsgbWFyZ2luWCwgeSArIG1hcmdpblksIHdpZHRoIC0gMiAqIG1hcmdpblgsIGhlaWdodCAtIDIgKiBtYXJnaW5ZXTtcbiAgfVxuICAjY29tcHV0ZUJib3goKSB7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3ggPSBuZXcgRmxvYXQzMkFycmF5KFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XSk7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBsaW5lXG4gICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgaWYgKGxpbmUubGVuZ3RoIDw9IDEyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSA0LCBpaSA9IGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgICAgIFV0aWwucG9pbnRCb3VuZGluZ0JveChsaW5lW2ldLCBsaW5lW2kgKyAxXSwgYmJveCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgbGFzdFggPSBsaW5lWzRdLFxuICAgICAgICBsYXN0WSA9IGxpbmVbNV07XG4gICAgICBmb3IgKGxldCBpID0gNiwgaWkgPSBsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgY29uc3QgW2MxeCwgYzF5LCBjMngsIGMyeSwgeCwgeV0gPSBsaW5lLnN1YmFycmF5KGksIGkgKyA2KTtcbiAgICAgICAgVXRpbC5iZXppZXJCb3VuZGluZ0JveChsYXN0WCwgbGFzdFksIGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSwgYmJveCk7XG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgYmJveFswXSA9IE1hdGhDbGFtcChiYm94WzBdIC0gbWFyZ2luWCwgMCwgMSk7XG4gICAgYmJveFsxXSA9IE1hdGhDbGFtcChiYm94WzFdIC0gbWFyZ2luWSwgMCwgMSk7XG4gICAgYmJveFsyXSA9IE1hdGhDbGFtcChiYm94WzJdICsgbWFyZ2luWCwgMCwgMSk7XG4gICAgYmJveFszXSA9IE1hdGhDbGFtcChiYm94WzNdICsgbWFyZ2luWSwgMCwgMSk7XG4gICAgYmJveFsyXSAtPSBiYm94WzBdO1xuICAgIGJib3hbM10gLT0gYmJveFsxXTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHJldHVybiB0aGlzLiNiYm94O1xuICB9XG4gIHVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUgPT09IFwic3Ryb2tlLXdpZHRoXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLiN1cGRhdGVUaGlja25lc3ModmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAjdXBkYXRlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGNvbnN0IFtvbGRNYXJnaW5YLCBvbGRNYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICB0aGlzLiN0aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgY29uc3QgW25ld01hcmdpblgsIG5ld01hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IFtkaWZmTWFyZ2luWCwgZGlmZk1hcmdpblldID0gW25ld01hcmdpblggLSBvbGRNYXJnaW5YLCBuZXdNYXJnaW5ZIC0gb2xkTWFyZ2luWV07XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgYmJveFswXSAtPSBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzFdIC09IGRpZmZNYXJnaW5ZO1xuICAgIGJib3hbMl0gKz0gMiAqIGRpZmZNYXJnaW5YO1xuICAgIGJib3hbM10gKz0gMiAqIGRpZmZNYXJnaW5ZO1xuICAgIHJldHVybiBiYm94O1xuICB9XG4gIHVwZGF0ZVBhcmVudERpbWVuc2lvbnMoW3dpZHRoLCBoZWlnaHRdLCBzY2FsZSkge1xuICAgIGNvbnN0IFtvbGRNYXJnaW5YLCBvbGRNYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLiNwYXJlbnRTY2FsZSA9IHNjYWxlO1xuICAgIGNvbnN0IFtuZXdNYXJnaW5YLCBuZXdNYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBkaWZmTWFyZ2luWCA9IG5ld01hcmdpblggLSBvbGRNYXJnaW5YO1xuICAgIGNvbnN0IGRpZmZNYXJnaW5ZID0gbmV3TWFyZ2luWSAtIG9sZE1hcmdpblk7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgYmJveFswXSAtPSBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzFdIC09IGRpZmZNYXJnaW5ZO1xuICAgIGJib3hbMl0gKz0gMiAqIGRpZmZNYXJnaW5YO1xuICAgIGJib3hbM10gKz0gMiAqIGRpZmZNYXJnaW5ZO1xuICAgIHJldHVybiBiYm94O1xuICB9XG4gIHVwZGF0ZVJvdGF0aW9uKHJvdGF0aW9uKSB7XG4gICAgdGhpcy4jY3VycmVudFJvdGF0aW9uID0gcm90YXRpb247XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnJvdGF0aW9uVHJhbnNmb3JtXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXQgdmlld0JveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYmJveC5tYXAoT3V0bGluZS5zdmdSb3VuZCkuam9pbihcIiBcIik7XG4gIH1cbiAgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzKCkge1xuICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMuI2Jib3g7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZCh4KX0gJHtPdXRsaW5lLnN2Z1JvdW5kKHkpfWBcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldCByb3RhdGlvblRyYW5zZm9ybSgpIHtcbiAgICBjb25zdCBbLCwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGxldCBhID0gMCxcbiAgICAgIGIgPSAwLFxuICAgICAgYyA9IDAsXG4gICAgICBkID0gMCxcbiAgICAgIGUgPSAwLFxuICAgICAgZiA9IDA7XG4gICAgc3dpdGNoICh0aGlzLiNjdXJyZW50Um90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIGIgPSBoZWlnaHQgLyB3aWR0aDtcbiAgICAgICAgYyA9IC13aWR0aCAvIGhlaWdodDtcbiAgICAgICAgZSA9IHdpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICBhID0gLTE7XG4gICAgICAgIGQgPSAtMTtcbiAgICAgICAgZSA9IHdpZHRoO1xuICAgICAgICBmID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICBiID0gLWhlaWdodCAvIHdpZHRoO1xuICAgICAgICBjID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICAgIGYgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBgbWF0cml4KCR7YX0gJHtifSAke2N9ICR7ZH0gJHtPdXRsaW5lLnN2Z1JvdW5kKGUpfSAke091dGxpbmUuc3ZnUm91bmQoZil9KWA7XG4gIH1cbiAgZ2V0UGF0aFJlc2l6aW5nU1ZHUHJvcGVydGllcyhbbmV3WCwgbmV3WSwgbmV3V2lkdGgsIG5ld0hlaWdodF0pIHtcbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBpZiAoTWF0aC5hYnMod2lkdGggLSBtYXJnaW5YKSA8PSBPdXRsaW5lLlBSRUNJU0lPTiB8fCBNYXRoLmFicyhoZWlnaHQgLSBtYXJnaW5ZKSA8PSBPdXRsaW5lLlBSRUNJU0lPTikge1xuICAgICAgY29uc3QgdHggPSBuZXdYICsgbmV3V2lkdGggLyAyIC0gKHggKyB3aWR0aCAvIDIpO1xuICAgICAgY29uc3QgdHkgPSBuZXdZICsgbmV3SGVpZ2h0IC8gMiAtICh5ICsgaGVpZ2h0IC8gMik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQobmV3WCl9ICR7T3V0bGluZS5zdmdSb3VuZChuZXdZKX1gLFxuICAgICAgICAgIHRyYW5zZm9ybTogYCR7dGhpcy5yb3RhdGlvblRyYW5zZm9ybX0gdHJhbnNsYXRlKCR7dHh9ICR7dHl9KWBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgczF4ID0gKG5ld1dpZHRoIC0gMiAqIG1hcmdpblgpIC8gKHdpZHRoIC0gMiAqIG1hcmdpblgpO1xuICAgIGNvbnN0IHMxeSA9IChuZXdIZWlnaHQgLSAyICogbWFyZ2luWSkgLyAoaGVpZ2h0IC0gMiAqIG1hcmdpblkpO1xuICAgIGNvbnN0IHMyeCA9IHdpZHRoIC8gbmV3V2lkdGg7XG4gICAgY29uc3QgczJ5ID0gaGVpZ2h0IC8gbmV3SGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKHgpfSAke091dGxpbmUuc3ZnUm91bmQoeSl9YCxcbiAgICAgICAgdHJhbnNmb3JtOiBgJHt0aGlzLnJvdGF0aW9uVHJhbnNmb3JtfSBzY2FsZSgke3MyeH0gJHtzMnl9KSBgICsgYHRyYW5zbGF0ZSgke091dGxpbmUuc3ZnUm91bmQobWFyZ2luWCl9ICR7T3V0bGluZS5zdmdSb3VuZChtYXJnaW5ZKX0pIHNjYWxlKCR7czF4fSAke3MxeX0pIGAgKyBgdHJhbnNsYXRlKCR7T3V0bGluZS5zdmdSb3VuZCgtbWFyZ2luWCl9ICR7T3V0bGluZS5zdmdSb3VuZCgtbWFyZ2luWSl9KWBcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldFBhdGhSZXNpemVkU1ZHUHJvcGVydGllcyhbbmV3WCwgbmV3WSwgbmV3V2lkdGgsIG5ld0hlaWdodF0pIHtcbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gYmJveDtcbiAgICBiYm94WzBdID0gbmV3WDtcbiAgICBiYm94WzFdID0gbmV3WTtcbiAgICBiYm94WzJdID0gbmV3V2lkdGg7XG4gICAgYmJveFszXSA9IG5ld0hlaWdodDtcbiAgICBpZiAoTWF0aC5hYnMod2lkdGggLSBtYXJnaW5YKSA8PSBPdXRsaW5lLlBSRUNJU0lPTiB8fCBNYXRoLmFicyhoZWlnaHQgLSBtYXJnaW5ZKSA8PSBPdXRsaW5lLlBSRUNJU0lPTikge1xuICAgICAgY29uc3QgdHggPSBuZXdYICsgbmV3V2lkdGggLyAyIC0gKHggKyB3aWR0aCAvIDIpO1xuICAgICAgY29uc3QgdHkgPSBuZXdZICsgbmV3SGVpZ2h0IC8gMiAtICh5ICsgaGVpZ2h0IC8gMik7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICAgIE91dGxpbmUuX3RyYW5zbGF0ZShsaW5lLCB0eCwgdHksIGxpbmUpO1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUocG9pbnRzLCB0eCwgdHksIHBvaW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICAgIH0sXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChuZXdYKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1kpfWAsXG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnJvdGF0aW9uVHJhbnNmb3JtIHx8IG51bGwsXG4gICAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzMXggPSAobmV3V2lkdGggLSAyICogbWFyZ2luWCkgLyAod2lkdGggLSAyICogbWFyZ2luWCk7XG4gICAgY29uc3QgczF5ID0gKG5ld0hlaWdodCAtIDIgKiBtYXJnaW5ZKSAvIChoZWlnaHQgLSAyICogbWFyZ2luWSk7XG4gICAgY29uc3QgdHggPSAtczF4ICogKHggKyBtYXJnaW5YKSArIG5ld1ggKyBtYXJnaW5YO1xuICAgIGNvbnN0IHR5ID0gLXMxeSAqICh5ICsgbWFyZ2luWSkgKyBuZXdZICsgbWFyZ2luWTtcbiAgICBpZiAoczF4ICE9PSAxIHx8IHMxeSAhPT0gMSB8fCB0eCAhPT0gMCB8fCB0eSAhPT0gMCkge1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgICBPdXRsaW5lLl9yZXNjYWxlKGxpbmUsIHR4LCB0eSwgczF4LCBzMXksIGxpbmUpO1xuICAgICAgICBPdXRsaW5lLl9yZXNjYWxlKHBvaW50cywgdHgsIHR5LCBzMXgsIHMxeSwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChuZXdYKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1kpfWAsXG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5yb3RhdGlvblRyYW5zZm9ybSB8fCBudWxsLFxuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXRQYXRoVHJhbnNsYXRlZFNWR1Byb3BlcnRpZXMoW25ld1gsIG5ld1ldLCBwYXJlbnREaW1lbnNpb25zKSB7XG4gICAgY29uc3QgW25ld1BhcmVudFdpZHRoLCBuZXdQYXJlbnRIZWlnaHRdID0gcGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCB0eCA9IG5ld1ggLSBiYm94WzBdO1xuICAgIGNvbnN0IHR5ID0gbmV3WSAtIGJib3hbMV07XG4gICAgaWYgKHRoaXMuI3BhcmVudFdpZHRoID09PSBuZXdQYXJlbnRXaWR0aCAmJiB0aGlzLiNwYXJlbnRIZWlnaHQgPT09IG5ld1BhcmVudEhlaWdodCkge1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUobGluZSwgdHgsIHR5LCBsaW5lKTtcbiAgICAgICAgT3V0bGluZS5fdHJhbnNsYXRlKHBvaW50cywgdHgsIHR5LCBwb2ludHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzeCA9IHRoaXMuI3BhcmVudFdpZHRoIC8gbmV3UGFyZW50V2lkdGg7XG4gICAgICBjb25zdCBzeSA9IHRoaXMuI3BhcmVudEhlaWdodCAvIG5ld1BhcmVudEhlaWdodDtcbiAgICAgIHRoaXMuI3BhcmVudFdpZHRoID0gbmV3UGFyZW50V2lkdGg7XG4gICAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBuZXdQYXJlbnRIZWlnaHQ7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICAgIE91dGxpbmUuX3Jlc2NhbGUobGluZSwgdHgsIHR5LCBzeCwgc3ksIGxpbmUpO1xuICAgICAgICBPdXRsaW5lLl9yZXNjYWxlKHBvaW50cywgdHgsIHR5LCBzeCwgc3ksIHBvaW50cyk7XG4gICAgICB9XG4gICAgICBiYm94WzJdICo9IHN4O1xuICAgICAgYmJveFszXSAqPSBzeTtcbiAgICB9XG4gICAgYmJveFswXSA9IG5ld1g7XG4gICAgYmJveFsxXSA9IG5ld1k7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpLFxuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChuZXdYKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1kpfWBcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldCBkZWZhdWx0U1ZHUHJvcGVydGllcygpIHtcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgZHJhdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKSxcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQoYmJveFswXSl9ICR7T3V0bGluZS5zdmdSb3VuZChiYm94WzFdKX1gLFxuICAgICAgICB0cmFuc2Zvcm06IHRoaXMucm90YXRpb25UcmFuc2Zvcm0gfHwgbnVsbFxuICAgICAgfSxcbiAgICAgIGJib3hcbiAgICB9O1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9pbmsuanNcblxuXG5cblxuXG5cblxuXG5jbGFzcyBJbmtEcmF3aW5nT3B0aW9ucyBleHRlbmRzIERyYXdpbmdPcHRpb25zIHtcbiAgY29uc3RydWN0b3Iodmlld2VyUGFyYW1ldGVycykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdmlld1BhcmFtZXRlcnMgPSB2aWV3ZXJQYXJhbWV0ZXJzO1xuICAgIHN1cGVyLnVwZGF0ZVByb3BlcnRpZXMoe1xuICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICBzdHJva2U6IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3IsXG4gICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IDEsXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiAxLFxuICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiBcInJvdW5kXCIsXG4gICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIsXG4gICAgICBcInN0cm9rZS1taXRlcmxpbWl0XCI6IDEwXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlU1ZHUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJzdHJva2Utd2lkdGhcIikge1xuICAgICAgdmFsdWUgPz89IHRoaXNbXCJzdHJva2Utd2lkdGhcIl07XG4gICAgICB2YWx1ZSAqPSB0aGlzLl92aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gICAgfVxuICAgIHN1cGVyLnVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBJbmtEcmF3aW5nT3B0aW9ucyh0aGlzLl92aWV3UGFyYW1ldGVycyk7XG4gICAgY2xvbmUudXBkYXRlQWxsKHRoaXMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuY2xhc3MgSW5rRWRpdG9yIGV4dGVuZHMgRHJhd2luZ0VkaXRvciB7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaW5rXCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLklOSztcbiAgc3RhdGljIF9kZWZhdWx0RHJhd2luZ09wdGlvbnMgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImlua0VkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgdGhpcy5kZWZhdWx0TDEwbklkID0gXCJwZGZqcy1lZGl0b3ItaW5rLWVkaXRvclwiO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucyA9IG5ldyBJbmtEcmF3aW5nT3B0aW9ucyh1aU1hbmFnZXIudmlld1BhcmFtZXRlcnMpO1xuICB9XG4gIHN0YXRpYyBnZXREZWZhdWx0RHJhd2luZ09wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IGNsb25lID0gdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLmNsb25lKCk7XG4gICAgY2xvbmUudXBkYXRlUHJvcGVydGllcyhvcHRpb25zKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0TXVsdGlwbGVEcmF3aW5ncygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGVzTWFwKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJ0eXBlc01hcFwiLCBuZXcgTWFwKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUywgXCJzdHJva2Utd2lkdGhcIl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1IsIFwic3Ryb2tlXCJdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksIFwic3Ryb2tlLW9wYWNpdHlcIl1dKSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZURyYXdlckluc3RhbmNlKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBJbmtEcmF3T3V0bGluZXIoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24sIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9uc1tcInN0cm9rZS13aWR0aFwiXSk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplRHJhdyhwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgaW5uZXJNYXJnaW4sIGRhdGEpIHtcbiAgICByZXR1cm4gSW5rRHJhd091dGxpbmUuZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgSW5rQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlua0xpc3RzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICBib3JkZXJTdHlsZToge1xuICAgICAgICAgICAgcmF3V2lkdGg6IHRoaWNrbmVzc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgcmljaFRleHQsXG4gICAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkssXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yKSxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBwYXRoczoge1xuICAgICAgICAgIHBvaW50czogaW5rTGlzdHNcbiAgICAgICAgfSxcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBpZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgcmljaFRleHQsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbCxcbiAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIGlmIChkYXRhLmNvbW1lbnQpIHtcbiAgICAgIGVkaXRvci5zZXRDb21tZW50RGF0YShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBnZXQgdG9vbGJhckJ1dHRvbnMoKSB7XG4gICAgdGhpcy5fY29sb3JQaWNrZXIgfHw9IG5ldyBCYXNpY0NvbG9yUGlja2VyKHRoaXMpO1xuICAgIHJldHVybiBbW1wiY29sb3JQaWNrZXJcIiwgdGhpcy5fY29sb3JQaWNrZXJdXTtcbiAgfVxuICBnZXQgY29sb3JUeXBlKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1I7XG4gIH1cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9kcmF3aW5nT3B0aW9ucy5zdHJva2U7XG4gIH1cbiAgZ2V0IG9wYWNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RyYXdpbmdPcHRpb25zW1wic3Ryb2tlLW9wYWNpdHlcIl07XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIub25TY2FsZUNoYW5naW5nKCk7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdJZCxcbiAgICAgIF9kcmF3aW5nT3B0aW9ucyxcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzO1xuICAgIF9kcmF3aW5nT3B0aW9ucy51cGRhdGVTVkdQcm9wZXJ0eShcInN0cm9rZS13aWR0aFwiKTtcbiAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoX2RyYXdJZCwgX2RyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgfVxuICBzdGF0aWMgb25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmcoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5vblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZygpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy51cGRhdGVTVkdQcm9wZXJ0eShcInN0cm9rZS13aWR0aFwiKTtcbiAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgfVxuICBjcmVhdGVEcmF3aW5nT3B0aW9ucyh7XG4gICAgY29sb3IsXG4gICAgdGhpY2tuZXNzLFxuICAgIG9wYWNpdHlcbiAgfSkge1xuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zID0gSW5rRWRpdG9yLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucyh7XG4gICAgICBzdHJva2U6IFV0aWwubWFrZUhleENvbG9yKC4uLmNvbG9yKSxcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzcyxcbiAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogb3BhY2l0eVxuICAgIH0pO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbGluZXMsXG4gICAgICBwb2ludHNcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVEcmF3KGlzRm9yQ29weWluZyk7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdpbmdPcHRpb25zOiB7XG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiBvcGFjaXR5LFxuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlja25lc3NcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzZXJpYWxpemVkID0gT2JqZWN0LmFzc2lnbihzdXBlci5zZXJpYWxpemUoaXNGb3JDb3B5aW5nKSwge1xuICAgICAgY29sb3I6IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHN0cm9rZSksXG4gICAgICBvcGFjaXR5LFxuICAgICAgdGhpY2tuZXNzLFxuICAgICAgcGF0aHM6IHtcbiAgICAgICAgbGluZXMsXG4gICAgICAgIHBvaW50c1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmlzQ29weSA9IHRydWU7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IsXG4gICAgICB0aGlja25lc3MsXG4gICAgICBvcGFjaXR5LFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiB0aGlzLmhhc0VkaXRlZENvbW1lbnQgfHwgdGhpcy5faGFzQmVlbk1vdmVkIHx8IHRoaXMuX2hhc0JlZW5SZXNpemVkIHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pIHx8IHNlcmlhbGl6ZWQudGhpY2tuZXNzICE9PSB0aGlja25lc3MgfHwgc2VyaWFsaXplZC5vcGFjaXR5ICE9PSBvcGFjaXR5IHx8IHNlcmlhbGl6ZWQucGFnZUluZGV4ICE9PSBwYWdlSW5kZXg7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGFubm90YXRpb24uaGlkZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBvaW50cyxcbiAgICAgIHJlY3RcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVEcmF3KGZhbHNlKTtcbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0LFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLl9kcmF3aW5nT3B0aW9uc1tcInN0cm9rZS13aWR0aFwiXSxcbiAgICAgIHBvaW50cyxcbiAgICAgIHBvcHVwOiB0aGlzLmNvbW1lbnRcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhd2Vycy9jb250b3VyLmpzXG5cbmNsYXNzIENvbnRvdXJEcmF3T3V0bGluZSBleHRlbmRzIElua0RyYXdPdXRsaW5lIHtcbiAgdG9TVkdQYXRoKCkge1xuICAgIGxldCBwYXRoID0gc3VwZXIudG9TVkdQYXRoKCk7XG4gICAgaWYgKCFwYXRoLmVuZHNXaXRoKFwiWlwiKSkge1xuICAgICAgcGF0aCArPSBcIlpcIjtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvc2lnbmF0dXJlZHJhdy5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgQkFTRV9IRUFERVJfTEVOR1RIID0gODtcbmNvbnN0IFBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiA9IDM7XG5jbGFzcyBTaWduYXR1cmVFeHRyYWN0b3Ige1xuICBzdGF0aWMgI1BBUkFNRVRFUlMgPSB7XG4gICAgbWF4RGltOiA1MTIsXG4gICAgc2lnbWFTRmFjdG9yOiAwLjAyLFxuICAgIHNpZ21hUjogMjUsXG4gICAga2VybmVsU2l6ZTogMTZcbiAgfTtcbiAgc3RhdGljICNuZWlnaGJvckluZGV4VG9JZChpMCwgajAsIGksIGopIHtcbiAgICBpIC09IGkwO1xuICAgIGogLT0gajA7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHJldHVybiBqID4gMCA/IDAgOiA0O1xuICAgIH1cbiAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGogKyA2O1xuICAgIH1cbiAgICByZXR1cm4gMiAtIGo7XG4gIH1cbiAgc3RhdGljICNuZWlnaGJvcklkVG9JbmRleCA9IG5ldyBJbnQzMkFycmF5KFswLCAxLCAtMSwgMSwgLTEsIDAsIC0xLCAtMSwgMCwgLTEsIDEsIC0xLCAxLCAwLCAxLCAxXSk7XG4gIHN0YXRpYyAjY2xvY2t3aXNlTm9uWmVybyhidWYsIHdpZHRoLCBpMCwgajAsIGksIGosIG9mZnNldCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy4jbmVpZ2hib3JJbmRleFRvSWQoaTAsIGowLCBpLCBqKTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgY29uc3Qga2sgPSAoLWsgKyBpZCAtIG9mZnNldCArIDE2KSAlIDg7XG4gICAgICBjb25zdCBzaGlmdEkgPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2tdO1xuICAgICAgY29uc3Qgc2hpZnRKID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrICsgMV07XG4gICAgICBpZiAoYnVmWyhpMCArIHNoaWZ0SSkgKiB3aWR0aCArIChqMCArIHNoaWZ0SildICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBraztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHN0YXRpYyAjY291bnRlckNsb2Nrd2lzZU5vblplcm8oYnVmLCB3aWR0aCwgaTAsIGowLCBpLCBqLCBvZmZzZXQpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuI25laWdoYm9ySW5kZXhUb0lkKGkwLCBqMCwgaSwgaik7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGNvbnN0IGtrID0gKGsgKyBpZCArIG9mZnNldCArIDE2KSAlIDg7XG4gICAgICBjb25zdCBzaGlmdEkgPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2tdO1xuICAgICAgY29uc3Qgc2hpZnRKID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrICsgMV07XG4gICAgICBpZiAoYnVmWyhpMCArIHNoaWZ0SSkgKiB3aWR0aCArIChqMCArIHNoaWZ0SildICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBraztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHN0YXRpYyAjZmluZENvbnRvdXJzKGJ1Ziwgd2lkdGgsIGhlaWdodCwgdGhyZXNob2xkKSB7XG4gICAgY29uc3QgTiA9IGJ1Zi5sZW5ndGg7XG4gICAgY29uc3QgdHlwZXMgPSBuZXcgSW50MzJBcnJheShOKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdHlwZXNbaV0gPSBidWZbaV0gPD0gdGhyZXNob2xkID8gMSA6IDA7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVpZ2h0IC0gMTsgaSsrKSB7XG4gICAgICB0eXBlc1tpICogd2lkdGhdID0gdHlwZXNbaSAqIHdpZHRoICsgd2lkdGggLSAxXSA9IDA7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgdHlwZXNbaV0gPSB0eXBlc1t3aWR0aCAqIGhlaWdodCAtIDEgLSBpXSA9IDA7XG4gICAgfVxuICAgIGxldCBuYmQgPSAxO1xuICAgIGxldCBsbmJkO1xuICAgIGNvbnN0IGNvbnRvdXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBoZWlnaHQgLSAxOyBpKyspIHtcbiAgICAgIGxuYmQgPSAxO1xuICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCB3aWR0aCAtIDE7IGorKykge1xuICAgICAgICBjb25zdCBpaiA9IGkgKiB3aWR0aCArIGo7XG4gICAgICAgIGNvbnN0IHBpeCA9IHR5cGVzW2lqXTtcbiAgICAgICAgaWYgKHBpeCA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpMiA9IGk7XG4gICAgICAgIGxldCBqMiA9IGo7XG4gICAgICAgIGlmIChwaXggPT09IDEgJiYgdHlwZXNbaWogLSAxXSA9PT0gMCkge1xuICAgICAgICAgIG5iZCArPSAxO1xuICAgICAgICAgIGoyIC09IDE7XG4gICAgICAgIH0gZWxzZSBpZiAocGl4ID49IDEgJiYgdHlwZXNbaWogKyAxXSA9PT0gMCkge1xuICAgICAgICAgIG5iZCArPSAxO1xuICAgICAgICAgIGoyICs9IDE7XG4gICAgICAgICAgaWYgKHBpeCA+IDEpIHtcbiAgICAgICAgICAgIGxuYmQgPSBwaXg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwaXggIT09IDEpIHtcbiAgICAgICAgICAgIGxuYmQgPSBNYXRoLmFicyhwaXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludHMgPSBbaiwgaV07XG4gICAgICAgIGNvbnN0IGlzSG9sZSA9IGoyID09PSBqICsgMTtcbiAgICAgICAgY29uc3QgY29udG91ciA9IHtcbiAgICAgICAgICBpc0hvbGUsXG4gICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgIGlkOiBuYmQsXG4gICAgICAgICAgcGFyZW50OiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnRvdXJzLnB1c2goY29udG91cik7XG4gICAgICAgIGxldCBjb250b3VyMDtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbnRvdXJzKSB7XG4gICAgICAgICAgaWYgKGMuaWQgPT09IGxuYmQpIHtcbiAgICAgICAgICAgIGNvbnRvdXIwID0gYztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRvdXIwKSB7XG4gICAgICAgICAgY29udG91ci5wYXJlbnQgPSBpc0hvbGUgPyBsbmJkIDogMDtcbiAgICAgICAgfSBlbHNlIGlmIChjb250b3VyMC5pc0hvbGUpIHtcbiAgICAgICAgICBjb250b3VyLnBhcmVudCA9IGlzSG9sZSA/IGNvbnRvdXIwLnBhcmVudCA6IGxuYmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udG91ci5wYXJlbnQgPSBpc0hvbGUgPyBsbmJkIDogY29udG91cjAucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLiNjbG9ja3dpc2VOb25aZXJvKHR5cGVzLCB3aWR0aCwgaSwgaiwgaTIsIGoyLCAwKTtcbiAgICAgICAgaWYgKGsgPT09IC0xKSB7XG4gICAgICAgICAgdHlwZXNbaWpdID0gLW5iZDtcbiAgICAgICAgICBpZiAodHlwZXNbaWpdICE9PSAxKSB7XG4gICAgICAgICAgICBsbmJkID0gTWF0aC5hYnModHlwZXNbaWpdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNoaWZ0SSA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBrXTtcbiAgICAgICAgbGV0IHNoaWZ0SiA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBrICsgMV07XG4gICAgICAgIGNvbnN0IGkxID0gaSArIHNoaWZ0STtcbiAgICAgICAgY29uc3QgajEgPSBqICsgc2hpZnRKO1xuICAgICAgICBpMiA9IGkxO1xuICAgICAgICBqMiA9IGoxO1xuICAgICAgICBsZXQgaTMgPSBpO1xuICAgICAgICBsZXQgajMgPSBqO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IGtrID0gdGhpcy4jY291bnRlckNsb2Nrd2lzZU5vblplcm8odHlwZXMsIHdpZHRoLCBpMywgajMsIGkyLCBqMiwgMSk7XG4gICAgICAgICAgc2hpZnRJID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrXTtcbiAgICAgICAgICBzaGlmdEogPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2sgKyAxXTtcbiAgICAgICAgICBjb25zdCBpNCA9IGkzICsgc2hpZnRJO1xuICAgICAgICAgIGNvbnN0IGo0ID0gajMgKyBzaGlmdEo7XG4gICAgICAgICAgcG9pbnRzLnB1c2goajQsIGk0KTtcbiAgICAgICAgICBjb25zdCBpajMgPSBpMyAqIHdpZHRoICsgajM7XG4gICAgICAgICAgaWYgKHR5cGVzW2lqMyArIDFdID09PSAwKSB7XG4gICAgICAgICAgICB0eXBlc1tpajNdID0gLW5iZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVzW2lqM10gPT09IDEpIHtcbiAgICAgICAgICAgIHR5cGVzW2lqM10gPSBuYmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpNCA9PT0gaSAmJiBqNCA9PT0gaiAmJiBpMyA9PT0gaTEgJiYgajMgPT09IGoxKSB7XG4gICAgICAgICAgICBpZiAodHlwZXNbaWpdICE9PSAxKSB7XG4gICAgICAgICAgICAgIGxuYmQgPSBNYXRoLmFicyh0eXBlc1tpal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkyID0gaTM7XG4gICAgICAgICAgICBqMiA9IGozO1xuICAgICAgICAgICAgaTMgPSBpNDtcbiAgICAgICAgICAgIGozID0gajQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250b3VycztcbiAgfVxuICBzdGF0aWMgI2RvdWdsYXNQZXVja2VySGVscGVyKHBvaW50cywgc3RhcnQsIGVuZCwgb3V0cHV0KSB7XG4gICAgaWYgKGVuZCAtIHN0YXJ0IDw9IDQpIHtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZCAtIDI7IGkgKz0gMikge1xuICAgICAgICBvdXRwdXQucHVzaChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBheCA9IHBvaW50c1tzdGFydF07XG4gICAgY29uc3QgYXkgPSBwb2ludHNbc3RhcnQgKyAxXTtcbiAgICBjb25zdCBhYnggPSBwb2ludHNbZW5kIC0gNF0gLSBheDtcbiAgICBjb25zdCBhYnkgPSBwb2ludHNbZW5kIC0gM10gLSBheTtcbiAgICBjb25zdCBkaXN0ID0gTWF0aC5oeXBvdChhYngsIGFieSk7XG4gICAgY29uc3QgbmFieCA9IGFieCAvIGRpc3Q7XG4gICAgY29uc3QgbmFieSA9IGFieSAvIGRpc3Q7XG4gICAgY29uc3QgYWEgPSBuYWJ4ICogYXkgLSBuYWJ5ICogYXg7XG4gICAgY29uc3QgbSA9IGFieSAvIGFieDtcbiAgICBjb25zdCBpbnZTID0gMSAvIGRpc3Q7XG4gICAgY29uc3QgcGhpID0gTWF0aC5hdGFuKG0pO1xuICAgIGNvbnN0IGNvc1BoaSA9IE1hdGguY29zKHBoaSk7XG4gICAgY29uc3Qgc2luUGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICBjb25zdCB0bWF4ID0gaW52UyAqIChNYXRoLmFicyhjb3NQaGkpICsgTWF0aC5hYnMoc2luUGhpKSk7XG4gICAgY29uc3QgcG9seSA9IGludlMgKiAoMSAtIHRtYXggKyB0bWF4ICoqIDIpO1xuICAgIGNvbnN0IHBhcnRpYWxQaGkgPSBNYXRoLm1heChNYXRoLmF0YW4oTWF0aC5hYnMoc2luUGhpICsgY29zUGhpKSAqIHBvbHkpLCBNYXRoLmF0YW4oTWF0aC5hYnMoc2luUGhpIC0gY29zUGhpKSAqIHBvbHkpKTtcbiAgICBsZXQgZG1heCA9IDA7XG4gICAgbGV0IGluZGV4ID0gc3RhcnQ7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0ICsgMjsgaSA8IGVuZCAtIDI7IGkgKz0gMikge1xuICAgICAgY29uc3QgZCA9IE1hdGguYWJzKGFhIC0gbmFieCAqIHBvaW50c1tpICsgMV0gKyBuYWJ5ICogcG9pbnRzW2ldKTtcbiAgICAgIGlmIChkID4gZG1heCkge1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIGRtYXggPSBkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZG1heCA+IChkaXN0ICogcGFydGlhbFBoaSkgKiogMikge1xuICAgICAgdGhpcy4jZG91Z2xhc1BldWNrZXJIZWxwZXIocG9pbnRzLCBzdGFydCwgaW5kZXggKyAyLCBvdXRwdXQpO1xuICAgICAgdGhpcy4jZG91Z2xhc1BldWNrZXJIZWxwZXIocG9pbnRzLCBpbmRleCwgZW5kLCBvdXRwdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChheCwgYXkpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgI2RvdWdsYXNQZXVja2VyKHBvaW50cykge1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgdGhpcy4jZG91Z2xhc1BldWNrZXJIZWxwZXIocG9pbnRzLCAwLCBsZW4sIG91dHB1dCk7XG4gICAgb3V0cHV0LnB1c2gocG9pbnRzW2xlbiAtIDJdLCBwb2ludHNbbGVuIC0gMV0pO1xuICAgIHJldHVybiBvdXRwdXQubGVuZ3RoIDw9IDQgPyBudWxsIDogb3V0cHV0O1xuICB9XG4gIHN0YXRpYyAjYmlsYXRlcmFsRmlsdGVyKGJ1Ziwgd2lkdGgsIGhlaWdodCwgc2lnbWFTLCBzaWdtYVIsIGtlcm5lbFNpemUpIHtcbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgRmxvYXQzMkFycmF5KGtlcm5lbFNpemUgKiogMik7XG4gICAgY29uc3Qgc2lnbWFTMiA9IC0yICogc2lnbWFTICoqIDI7XG4gICAgY29uc3QgaGFsZlNpemUgPSBrZXJuZWxTaXplID4+IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSAoaSAtIGhhbGZTaXplKSAqKiAyO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXJuZWxTaXplOyBqKyspIHtcbiAgICAgICAga2VybmVsW2kgKiBrZXJuZWxTaXplICsgal0gPSBNYXRoLmV4cCgoeCArIChqIC0gaGFsZlNpemUpICoqIDIpIC8gc2lnbWFTMik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSgyNTYpO1xuICAgIGNvbnN0IHNpZ21hUjIgPSAtMiAqIHNpZ21hUiAqKiAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIHJhbmdlVmFsdWVzW2ldID0gTWF0aC5leHAoaSAqKiAyIC8gc2lnbWFSMik7XG4gICAgfVxuICAgIGNvbnN0IE4gPSBidWYubGVuZ3RoO1xuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KE4pO1xuICAgIGNvbnN0IGhpc3RvZ3JhbSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICBjb25zdCBpaiA9IGkgKiB3aWR0aCArIGo7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGJ1Zltpal07XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgbm9ybSA9IDA7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwga2VybmVsU2l6ZTsgaysrKSB7XG4gICAgICAgICAgY29uc3QgeSA9IGkgKyBrIC0gaGFsZlNpemU7XG4gICAgICAgICAgaWYgKHkgPCAwIHx8IHkgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBrZXJuZWxTaXplOyBsKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBqICsgbCAtIGhhbGZTaXplO1xuICAgICAgICAgICAgaWYgKHggPCAwIHx8IHggPj0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZWlnaGJvdXIgPSBidWZbeSAqIHdpZHRoICsgeF07XG4gICAgICAgICAgICBjb25zdCB3ID0ga2VybmVsW2sgKiBrZXJuZWxTaXplICsgbF0gKiByYW5nZVZhbHVlc1tNYXRoLmFicyhuZWlnaGJvdXIgLSBjZW50ZXIpXTtcbiAgICAgICAgICAgIHN1bSArPSBuZWlnaGJvdXIgKiB3O1xuICAgICAgICAgICAgbm9ybSArPSB3O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaXggPSBvdXRbaWpdID0gTWF0aC5yb3VuZChzdW0gLyBub3JtKTtcbiAgICAgICAgaGlzdG9ncmFtW3BpeF0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtvdXQsIGhpc3RvZ3JhbV07XG4gIH1cbiAgc3RhdGljICNnZXRIaXN0b2dyYW0oYnVmKSB7XG4gICAgY29uc3QgaGlzdG9ncmFtID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgZm9yIChjb25zdCBnIG9mIGJ1Zikge1xuICAgICAgaGlzdG9ncmFtW2ddKys7XG4gICAgfVxuICAgIHJldHVybiBoaXN0b2dyYW07XG4gIH1cbiAgc3RhdGljICN0b1VpbnQ4KGJ1Zikge1xuICAgIGNvbnN0IE4gPSBidWYubGVuZ3RoO1xuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OENsYW1wZWRBcnJheShOID4+IDIpO1xuICAgIGxldCBtYXggPSAtSW5maW5pdHk7XG4gICAgbGV0IG1pbiA9IEluZmluaXR5O1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG91dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBwaXggPSBvdXRbaV0gPSBidWZbaSA8PCAyXTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcGl4KTtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcGl4KTtcbiAgICB9XG4gICAgY29uc3QgcmF0aW8gPSAyNTUgLyAobWF4IC0gbWluKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvdXQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgb3V0W2ldID0gKG91dFtpXSAtIG1pbikgKiByYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBzdGF0aWMgI2d1ZXNzVGhyZXNob2xkKGhpc3RvZ3JhbSkge1xuICAgIGxldCBpO1xuICAgIGxldCBNID0gLUluZmluaXR5O1xuICAgIGxldCBMID0gLUluZmluaXR5O1xuICAgIGNvbnN0IG1pbiA9IGhpc3RvZ3JhbS5maW5kSW5kZXgodiA9PiB2ICE9PSAwKTtcbiAgICBsZXQgcG9zID0gbWluO1xuICAgIGxldCBzcG9zID0gbWluO1xuICAgIGZvciAoaSA9IG1pbjsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBjb25zdCB2ID0gaGlzdG9ncmFtW2ldO1xuICAgICAgaWYgKHYgPiBNKSB7XG4gICAgICAgIGlmIChpIC0gcG9zID4gTCkge1xuICAgICAgICAgIEwgPSBpIC0gcG9zO1xuICAgICAgICAgIHNwb3MgPSBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBNID0gdjtcbiAgICAgICAgcG9zID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gc3BvcyAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoaGlzdG9ncmFtW2ldID4gaGlzdG9ncmFtW2kgKyAxXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgc3RhdGljICNnZXRHcmF5UGl4ZWxzKGJpdG1hcCkge1xuICAgIGNvbnN0IG9yaWdpbmFsQml0bWFwID0gYml0bWFwO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGJpdG1hcDtcbiAgICBjb25zdCB7XG4gICAgICBtYXhEaW1cbiAgICB9ID0gdGhpcy4jUEFSQU1FVEVSUztcbiAgICBsZXQgbmV3V2lkdGggPSB3aWR0aDtcbiAgICBsZXQgbmV3SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGlmICh3aWR0aCA+IG1heERpbSB8fCBoZWlnaHQgPiBtYXhEaW0pIHtcbiAgICAgIGxldCBwcmV2V2lkdGggPSB3aWR0aDtcbiAgICAgIGxldCBwcmV2SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgbGV0IHN0ZXBzID0gTWF0aC5sb2cyKE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpIC8gbWF4RGltKTtcbiAgICAgIGNvbnN0IGlzdGVwcyA9IE1hdGguZmxvb3Ioc3RlcHMpO1xuICAgICAgc3RlcHMgPSBzdGVwcyA9PT0gaXN0ZXBzID8gaXN0ZXBzIC0gMSA6IGlzdGVwcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcHM7IGkrKykge1xuICAgICAgICBuZXdXaWR0aCA9IE1hdGguY2VpbChwcmV2V2lkdGggLyAyKTtcbiAgICAgICAgbmV3SGVpZ2h0ID0gTWF0aC5jZWlsKHByZXZIZWlnaHQgLyAyKTtcbiAgICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICAgIHByZXZXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICBwcmV2SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICBpZiAoYml0bWFwICE9PSBvcmlnaW5hbEJpdG1hcCkge1xuICAgICAgICAgIGJpdG1hcC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJpdG1hcCA9IG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4obWF4RGltIC8gbmV3V2lkdGgsIG1heERpbSAvIG5ld0hlaWdodCk7XG4gICAgICBuZXdXaWR0aCA9IE1hdGgucm91bmQobmV3V2lkdGggKiByYXRpbyk7XG4gICAgICBuZXdIZWlnaHQgPSBNYXRoLnJvdW5kKG5ld0hlaWdodCAqIHJhdGlvKTtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgIGN0eC5maWx0ZXIgPSBcImdyYXlzY2FsZSgxKVwiO1xuICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgIGNvbnN0IGdyYXlJbWFnZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCkuZGF0YTtcbiAgICBjb25zdCB1aW50OEJ1ZiA9IHRoaXMuI3RvVWludDgoZ3JheUltYWdlKTtcbiAgICByZXR1cm4gW3VpbnQ4QnVmLCBuZXdXaWR0aCwgbmV3SGVpZ2h0XTtcbiAgfVxuICBzdGF0aWMgZXh0cmFjdENvbnRvdXJzRnJvbVRleHQodGV4dCwge1xuICAgIGZvbnRGYW1pbHksXG4gICAgZm9udFN0eWxlLFxuICAgIGZvbnRXZWlnaHRcbiAgfSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCByb3RhdGlvbiwgaW5uZXJNYXJnaW4pIHtcbiAgICBsZXQgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTtcbiAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCBmb250U2l6ZSA9IDIwMDtcbiAgICBjb25zdCBmb250ID0gY3R4LmZvbnQgPSBgJHtmb250U3R5bGV9ICR7Zm9udFdlaWdodH0gJHtmb250U2l6ZX1weCAke2ZvbnRGYW1pbHl9YDtcbiAgICBjb25zdCB7XG4gICAgICBhY3R1YWxCb3VuZGluZ0JveExlZnQsXG4gICAgICBhY3R1YWxCb3VuZGluZ0JveFJpZ2h0LFxuICAgICAgYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICBhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICBmb250Qm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICBmb250Qm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgd2lkdGhcbiAgICB9ID0gY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgIGNvbnN0IFNDQUxFID0gMS41O1xuICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gTWF0aC5jZWlsKE1hdGgubWF4KE1hdGguYWJzKGFjdHVhbEJvdW5kaW5nQm94TGVmdCkgKyBNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveFJpZ2h0KSB8fCAwLCB3aWR0aCkgKiBTQ0FMRSk7XG4gICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubWF4KE1hdGguYWJzKGFjdHVhbEJvdW5kaW5nQm94QXNjZW50KSArIE1hdGguYWJzKGFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCkgfHwgZm9udFNpemUsIE1hdGguYWJzKGZvbnRCb3VuZGluZ0JveEFzY2VudCkgKyBNYXRoLmFicyhmb250Qm91bmRpbmdCb3hEZXNjZW50KSB8fCBmb250U2l6ZSkgKiBTQ0FMRSk7XG4gICAgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgfSk7XG4gICAgY3R4LmZvbnQgPSBmb250O1xuICAgIGN0eC5maWx0ZXIgPSBcImdyYXlzY2FsZSgxKVwiO1xuICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgY3R4LmZpbGxUZXh0KHRleHQsIGNhbnZhc1dpZHRoICogKFNDQUxFIC0gMSkgLyAyLCBjYW52YXNIZWlnaHQgKiAoMyAtIFNDQUxFKSAvIDIpO1xuICAgIGNvbnN0IHVpbnQ4QnVmID0gdGhpcy4jdG9VaW50OChjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpLmRhdGEpO1xuICAgIGNvbnN0IGhpc3RvZ3JhbSA9IHRoaXMuI2dldEhpc3RvZ3JhbSh1aW50OEJ1Zik7XG4gICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy4jZ3Vlc3NUaHJlc2hvbGQoaGlzdG9ncmFtKTtcbiAgICBjb25zdCBjb250b3VyTGlzdCA9IHRoaXMuI2ZpbmRDb250b3Vycyh1aW50OEJ1ZiwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCwgdGhyZXNob2xkKTtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICBsaW5lczoge1xuICAgICAgICBjdXJ2ZXM6IGNvbnRvdXJMaXN0LFxuICAgICAgICB3aWR0aDogY2FudmFzV2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzSGVpZ2h0XG4gICAgICB9LFxuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgaW5uZXJNYXJnaW4sXG4gICAgICBtdXN0U21vb3RoOiB0cnVlLFxuICAgICAgYXJlQ29udG91cnM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgcHJvY2VzcyhiaXRtYXAsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgcm90YXRpb24sIGlubmVyTWFyZ2luKSB7XG4gICAgY29uc3QgW3VpbnQ4QnVmLCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2dldEdyYXlQaXhlbHMoYml0bWFwKTtcbiAgICBjb25zdCBbYnVmZmVyLCBoaXN0b2dyYW1dID0gdGhpcy4jYmlsYXRlcmFsRmlsdGVyKHVpbnQ4QnVmLCB3aWR0aCwgaGVpZ2h0LCBNYXRoLmh5cG90KHdpZHRoLCBoZWlnaHQpICogdGhpcy4jUEFSQU1FVEVSUy5zaWdtYVNGYWN0b3IsIHRoaXMuI1BBUkFNRVRFUlMuc2lnbWFSLCB0aGlzLiNQQVJBTUVURVJTLmtlcm5lbFNpemUpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuI2d1ZXNzVGhyZXNob2xkKGhpc3RvZ3JhbSk7XG4gICAgY29uc3QgY29udG91ckxpc3QgPSB0aGlzLiNmaW5kQ29udG91cnMoYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCB0aHJlc2hvbGQpO1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NEcmF3bkxpbmVzKHtcbiAgICAgIGxpbmVzOiB7XG4gICAgICAgIGN1cnZlczogY29udG91ckxpc3QsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0sXG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcm90YXRpb24sXG4gICAgICBpbm5lck1hcmdpbixcbiAgICAgIG11c3RTbW9vdGg6IHRydWUsXG4gICAgICBhcmVDb250b3VyczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBwcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgbGluZXMsXG4gICAgcGFnZVdpZHRoLFxuICAgIHBhZ2VIZWlnaHQsXG4gICAgcm90YXRpb24sXG4gICAgaW5uZXJNYXJnaW4sXG4gICAgbXVzdFNtb290aCxcbiAgICBhcmVDb250b3Vyc1xuICB9KSB7XG4gICAgaWYgKHJvdGF0aW9uICUgMTgwICE9PSAwKSB7XG4gICAgICBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IFtwYWdlSGVpZ2h0LCBwYWdlV2lkdGhdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjdXJ2ZXMsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBsaW5lcztcbiAgICBjb25zdCB0aGlja25lc3MgPSBsaW5lcy50aGlja25lc3MgPz8gMDtcbiAgICBjb25zdCBsaW5lc0FuZFBvaW50cyA9IFtdO1xuICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4ocGFnZVdpZHRoIC8gd2lkdGgsIHBhZ2VIZWlnaHQgLyBoZWlnaHQpO1xuICAgIGNvbnN0IHhTY2FsZSA9IHJhdGlvIC8gcGFnZVdpZHRoO1xuICAgIGNvbnN0IHlTY2FsZSA9IHJhdGlvIC8gcGFnZUhlaWdodDtcbiAgICBjb25zdCBuZXdDdXJ2ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHBvaW50c1xuICAgIH0gb2YgY3VydmVzKSB7XG4gICAgICBjb25zdCByZWR1Y2VkUG9pbnRzID0gbXVzdFNtb290aCA/IHRoaXMuI2RvdWdsYXNQZXVja2VyKHBvaW50cykgOiBwb2ludHM7XG4gICAgICBpZiAoIXJlZHVjZWRQb2ludHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBuZXdDdXJ2ZXMucHVzaChyZWR1Y2VkUG9pbnRzKTtcbiAgICAgIGNvbnN0IGxlbiA9IHJlZHVjZWRQb2ludHMubGVuZ3RoO1xuICAgICAgY29uc3QgbmV3UG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgICAgY29uc3QgbGluZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyAqIChsZW4gPT09IDIgPyAyIDogbGVuIC0gMikpO1xuICAgICAgbGluZXNBbmRQb2ludHMucHVzaCh7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50czogbmV3UG9pbnRzXG4gICAgICB9KTtcbiAgICAgIGlmIChsZW4gPT09IDIpIHtcbiAgICAgICAgbmV3UG9pbnRzWzBdID0gcmVkdWNlZFBvaW50c1swXSAqIHhTY2FsZTtcbiAgICAgICAgbmV3UG9pbnRzWzFdID0gcmVkdWNlZFBvaW50c1sxXSAqIHlTY2FsZTtcbiAgICAgICAgbGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgbmV3UG9pbnRzWzBdLCBuZXdQb2ludHNbMV1dLCAwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgW3gxLCB5MSwgeDIsIHkyXSA9IHJlZHVjZWRQb2ludHM7XG4gICAgICB4MSAqPSB4U2NhbGU7XG4gICAgICB5MSAqPSB5U2NhbGU7XG4gICAgICB4MiAqPSB4U2NhbGU7XG4gICAgICB5MiAqPSB5U2NhbGU7XG4gICAgICBuZXdQb2ludHMuc2V0KFt4MSwgeTEsIHgyLCB5Ml0sIDApO1xuICAgICAgbGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgeDEsIHkxXSwgMCk7XG4gICAgICBmb3IgKGxldCBpID0gNDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHggPSBuZXdQb2ludHNbaV0gPSByZWR1Y2VkUG9pbnRzW2ldICogeFNjYWxlO1xuICAgICAgICBjb25zdCB5ID0gbmV3UG9pbnRzW2kgKyAxXSA9IHJlZHVjZWRQb2ludHNbaSArIDFdICogeVNjYWxlO1xuICAgICAgICBsaW5lLnNldChPdXRsaW5lLmNyZWF0ZUJlemllclBvaW50cyh4MSwgeTEsIHgyLCB5MiwgeCwgeSksIChpIC0gMikgKiAzKTtcbiAgICAgICAgW3gxLCB5MSwgeDIsIHkyXSA9IFt4MiwgeTIsIHgsIHldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGluZXNBbmRQb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZSA9IGFyZUNvbnRvdXJzID8gbmV3IENvbnRvdXJEcmF3T3V0bGluZSgpIDogbmV3IElua0RyYXdPdXRsaW5lKCk7XG4gICAgb3V0bGluZS5idWlsZChsaW5lc0FuZFBvaW50cywgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCAxLCByb3RhdGlvbiwgYXJlQ29udG91cnMgPyAwIDogdGhpY2tuZXNzLCBpbm5lck1hcmdpbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dGxpbmUsXG4gICAgICBuZXdDdXJ2ZXMsXG4gICAgICBhcmVDb250b3VycyxcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY29tcHJlc3NTaWduYXR1cmUoe1xuICAgIG91dGxpbmVzLFxuICAgIGFyZUNvbnRvdXJzLFxuICAgIHRoaWNrbmVzcyxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSkge1xuICAgIGxldCBtaW5EaWZmID0gSW5maW5pdHk7XG4gICAgbGV0IG1heERpZmYgPSAtSW5maW5pdHk7XG4gICAgbGV0IG91dGxpbmVzTGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50cyBvZiBvdXRsaW5lcykge1xuICAgICAgb3V0bGluZXNMZW5ndGggKz0gcG9pbnRzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAyLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gcG9pbnRzW2ldIC0gcG9pbnRzW2kgLSAyXTtcbiAgICAgICAgbWluRGlmZiA9IE1hdGgubWluKG1pbkRpZmYsIGR4KTtcbiAgICAgICAgbWF4RGlmZiA9IE1hdGgubWF4KG1heERpZmYsIGR4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJ1ZmZlclR5cGU7XG4gICAgaWYgKG1pbkRpZmYgPj0gLTEyOCAmJiBtYXhEaWZmIDw9IDEyNykge1xuICAgICAgYnVmZmVyVHlwZSA9IEludDhBcnJheTtcbiAgICB9IGVsc2UgaWYgKG1pbkRpZmYgPj0gLTMyNzY4ICYmIG1heERpZmYgPD0gMzI3NjcpIHtcbiAgICAgIGJ1ZmZlclR5cGUgPSBJbnQxNkFycmF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXJUeXBlID0gSW50MzJBcnJheTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gb3V0bGluZXMubGVuZ3RoO1xuICAgIGNvbnN0IGhlYWRlckxlbmd0aCA9IEJBU0VfSEVBREVSX0xFTkdUSCArIFBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAqIGxlbjtcbiAgICBjb25zdCBoZWFkZXIgPSBuZXcgVWludDMyQXJyYXkoaGVhZGVyTGVuZ3RoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gaGVhZGVyTGVuZ3RoICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKyAob3V0bGluZXNMZW5ndGggLSAyICogbGVuKSAqIGJ1ZmZlclR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IDA7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IHdpZHRoO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBoZWlnaHQ7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IGFyZUNvbnRvdXJzID8gMCA6IDE7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IodGhpY2tuZXNzID8/IDApKTtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gbGVuO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBidWZmZXJUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIGZvciAoY29uc3QgcG9pbnRzIG9mIG91dGxpbmVzKSB7XG4gICAgICBoZWFkZXJbb2Zmc2V0KytdID0gcG9pbnRzLmxlbmd0aCAtIDI7XG4gICAgICBoZWFkZXJbb2Zmc2V0KytdID0gcG9pbnRzWzBdO1xuICAgICAgaGVhZGVyW29mZnNldCsrXSA9IHBvaW50c1sxXTtcbiAgICB9XG4gICAgY29uc3QgY3MgPSBuZXcgQ29tcHJlc3Npb25TdHJlYW0oXCJkZWZsYXRlLXJhd1wiKTtcbiAgICBjb25zdCB3cml0ZXIgPSBjcy53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgd3JpdGVyLndyaXRlKGhlYWRlcik7XG4gICAgY29uc3QgQnVmZmVyQ3RvciA9IGJ1ZmZlclR5cGUucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuICAgIGZvciAoY29uc3QgcG9pbnRzIG9mIG91dGxpbmVzKSB7XG4gICAgICBjb25zdCBkaWZmcyA9IG5ldyBCdWZmZXJDdG9yKHBvaW50cy5sZW5ndGggLSAyKTtcbiAgICAgIGZvciAobGV0IGkgPSAyLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGRpZmZzW2kgLSAyXSA9IHBvaW50c1tpXSAtIHBvaW50c1tpIC0gMl07XG4gICAgICB9XG4gICAgICB3cml0ZXIud3JpdGUoZGlmZnMpO1xuICAgIH1cbiAgICB3cml0ZXIuY2xvc2UoKTtcbiAgICBjb25zdCBidWYgPSBhd2FpdCBuZXcgUmVzcG9uc2UoY3MucmVhZGFibGUpLmFycmF5QnVmZmVyKCk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIHJldHVybiB0b0Jhc2U2NFV0aWwoYnl0ZXMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZWNvbXByZXNzU2lnbmF0dXJlKHNpZ25hdHVyZURhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBmcm9tQmFzZTY0VXRpbChzaWduYXR1cmVEYXRhKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVhZGFibGUsXG4gICAgICAgIHdyaXRhYmxlXG4gICAgICB9ID0gbmV3IERlY29tcHJlc3Npb25TdHJlYW0oXCJkZWZsYXRlLXJhd1wiKTtcbiAgICAgIGNvbnN0IHdyaXRlciA9IHdyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgd3JpdGVyLndyaXRlKGJ5dGVzKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgICBhd2FpdCB3cml0ZXIuY2xvc2UoKTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgIGxldCBkYXRhID0gbnVsbDtcbiAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZWFkYWJsZSkge1xuICAgICAgICBkYXRhIHx8PSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoY2h1bmsuYnVmZmVyLCAwLCA0KVswXSk7XG4gICAgICAgIGRhdGEuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgfVxuICAgICAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEuYnVmZmVyLCAwLCBkYXRhLmxlbmd0aCA+PiAyKTtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBoZWFkZXJbMV07XG4gICAgICBpZiAodmVyc2lvbiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmVyc2lvbjogJHt2ZXJzaW9ufWApO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lkdGggPSBoZWFkZXJbMl07XG4gICAgICBjb25zdCBoZWlnaHQgPSBoZWFkZXJbM107XG4gICAgICBjb25zdCBhcmVDb250b3VycyA9IGhlYWRlcls0XSA9PT0gMDtcbiAgICAgIGNvbnN0IHRoaWNrbmVzcyA9IGhlYWRlcls1XTtcbiAgICAgIGNvbnN0IG51bWJlck9mRHJhd2luZ3MgPSBoZWFkZXJbNl07XG4gICAgICBjb25zdCBidWZmZXJUeXBlID0gaGVhZGVyWzddO1xuICAgICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICAgIGNvbnN0IGRpZmZzT2Zmc2V0ID0gKEJBU0VfSEVBREVSX0xFTkdUSCArIFBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAqIG51bWJlck9mRHJhd2luZ3MpICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICBsZXQgZGlmZnM7XG4gICAgICBzd2l0Y2ggKGJ1ZmZlclR5cGUpIHtcbiAgICAgICAgY2FzZSBJbnQ4QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ6XG4gICAgICAgICAgZGlmZnMgPSBuZXcgSW50OEFycmF5KGRhdGEuYnVmZmVyLCBkaWZmc09mZnNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSW50MTZBcnJheS5CWVRFU19QRVJfRUxFTUVOVDpcbiAgICAgICAgICBkaWZmcyA9IG5ldyBJbnQxNkFycmF5KGRhdGEuYnVmZmVyLCBkaWZmc09mZnNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDpcbiAgICAgICAgICBkaWZmcyA9IG5ldyBJbnQzMkFycmF5KGRhdGEuYnVmZmVyLCBkaWZmc09mZnNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkRyYXdpbmdzOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGVuID0gaGVhZGVyW1BPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAqIGkgKyBCQVNFX0hFQURFUl9MRU5HVEhdO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGxlbiArIDIpO1xuICAgICAgICBvdXRsaW5lcy5wdXNoKHBvaW50cyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgUE9JTlRTX1BST1BFUlRJRVNfTlVNQkVSIC0gMTsgaisrKSB7XG4gICAgICAgICAgcG9pbnRzW2pdID0gaGVhZGVyW1BPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAqIGkgKyBCQVNFX0hFQURFUl9MRU5HVEggKyBqICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIHBvaW50c1tqICsgMl0gPSBwb2ludHNbal0gKyBkaWZmc1tvZmZzZXQrK107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFyZUNvbnRvdXJzLFxuICAgICAgICB0aGlja25lc3MsXG4gICAgICAgIG91dGxpbmVzLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oYGRlY29tcHJlc3NTaWduYXR1cmU6ICR7ZX1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3Ivc2lnbmF0dXJlLmpzXG5cblxuXG5cblxuXG5cblxuXG5jbGFzcyBTaWduYXR1cmVPcHRpb25zIGV4dGVuZHMgRHJhd2luZ09wdGlvbnMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHN1cGVyLnVwZGF0ZVByb3BlcnRpZXMoe1xuICAgICAgZmlsbDogQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcixcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDBcbiAgICB9KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBTaWduYXR1cmVPcHRpb25zKCk7XG4gICAgY2xvbmUudXBkYXRlQWxsKHRoaXMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuY2xhc3MgRHJhd25TaWduYXR1cmVPcHRpb25zIGV4dGVuZHMgSW5rRHJhd2luZ09wdGlvbnMge1xuICBjb25zdHJ1Y3Rvcih2aWV3ZXJQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIodmlld2VyUGFyYW1ldGVycyk7XG4gICAgc3VwZXIudXBkYXRlUHJvcGVydGllcyh7XG4gICAgICBzdHJva2U6IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3IsXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiAxXG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgRHJhd25TaWduYXR1cmVPcHRpb25zKHRoaXMuX3ZpZXdQYXJhbWV0ZXJzKTtcbiAgICBjbG9uZS51cGRhdGVBbGwodGhpcyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG5jbGFzcyBTaWduYXR1cmVFZGl0b3IgZXh0ZW5kcyBEcmF3aW5nRWRpdG9yIHtcbiAgI2lzRXh0cmFjdGVkID0gZmFsc2U7XG4gICNkZXNjcmlwdGlvbiA9IG51bGw7XG4gICNzaWduYXR1cmVEYXRhID0gbnVsbDtcbiAgI3NpZ25hdHVyZVVVSUQgPSBudWxsO1xuICBzdGF0aWMgX3R5cGUgPSBcInNpZ25hdHVyZVwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TSUdOQVRVUkU7XG4gIHN0YXRpYyBfZGVmYXVsdERyYXdpbmdPcHRpb25zID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbXVzdEJlQ29tbWl0dGVkOiB0cnVlLFxuICAgICAgbmFtZTogXCJzaWduYXR1cmVFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMuI3NpZ25hdHVyZURhdGEgPSBwYXJhbXMuc2lnbmF0dXJlRGF0YSB8fCBudWxsO1xuICAgIHRoaXMuI2Rlc2NyaXB0aW9uID0gbnVsbDtcbiAgICB0aGlzLmRlZmF1bHRMMTBuSWQgPSBcInBkZmpzLWVkaXRvci1zaWduYXR1cmUtZWRpdG9yMVwiO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucyA9IG5ldyBTaWduYXR1cmVPcHRpb25zKCk7XG4gICAgdGhpcy5fZGVmYXVsdERyYXduU2lnbmF0dXJlT3B0aW9ucyA9IG5ldyBEcmF3blNpZ25hdHVyZU9wdGlvbnModWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzKTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjbG9uZSA9IHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy5jbG9uZSgpO1xuICAgIGNsb25lLnVwZGF0ZVByb3BlcnRpZXMob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZXNNYXAoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInR5cGVzTWFwXCIsIG5ldyBNYXAoKSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0RyYXdlcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzaWduYXR1cmVcIixcbiAgICAgIGhhc0Rlc2NyaXB0aW9uOiAhIXRoaXMuI2Rlc2NyaXB0aW9uXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShkYXRhKSB7XG4gICAgY29uc3QgaGFzRGVzY3JpcHRpb25TdGF0cyA9IGRhdGEuZ2V0KFwiaGFzRGVzY3JpcHRpb25cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0FsdFRleHQ6IGhhc0Rlc2NyaXB0aW9uU3RhdHMuZ2V0KHRydWUpID8/IDAsXG4gICAgICBoYXNOb0FsdFRleHQ6IGhhc0Rlc2NyaXB0aW9uU3RhdHMuZ2V0KGZhbHNlKSA/PyAwXG4gICAgfTtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICh0aGlzLl9kcmF3SWQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIub25TY2FsZUNoYW5naW5nKCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGNvbnN0IHtcbiAgICAgIF9pc0NvcHlcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoX2lzQ29weSkge1xuICAgICAgdGhpcy5faXNDb3B5ID0gZmFsc2U7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICBpZiAodGhpcy5fZHJhd0lkID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy4jc2lnbmF0dXJlRGF0YSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbGluZXMsXG4gICAgICAgICAgbXVzdFNtb290aCxcbiAgICAgICAgICBhcmVDb250b3VycyxcbiAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICB1dWlkLFxuICAgICAgICAgIGhlaWdodEluUGFnZVxuICAgICAgICB9ID0gdGhpcy4jc2lnbmF0dXJlRGF0YTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICAgIHBhZ2VIZWlnaHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJvdGF0aW9uXG4gICAgICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydDtcbiAgICAgICAgY29uc3Qgb3V0bGluZSA9IFNpZ25hdHVyZUV4dHJhY3Rvci5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICAgICAgbGluZXMsXG4gICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaW5uZXJNYXJnaW46IFNpZ25hdHVyZUVkaXRvci5fSU5ORVJfTUFSR0lOLFxuICAgICAgICAgIG11c3RTbW9vdGgsXG4gICAgICAgICAgYXJlQ29udG91cnNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkU2lnbmF0dXJlKG91dGxpbmUsIGhlaWdodEluUGFnZSwgZGVzY3JpcHRpb24sIHV1aWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmdldFNpZ25hdHVyZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy4jZGVzY3JpcHRpb24gfHwgXCJcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoX2lzQ29weSkge1xuICAgICAgdGhpcy5faXNDb3B5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX21vdmVBZnRlclBhc3RlKGJhc2VYLCBiYXNlWSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBzZXRVdWlkKHV1aWQpIHtcbiAgICB0aGlzLiNzaWduYXR1cmVVVUlEID0gdXVpZDtcbiAgICB0aGlzLmFkZEVkaXRUb29sYmFyKCk7XG4gIH1cbiAgZ2V0VXVpZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2lnbmF0dXJlVVVJRDtcbiAgfVxuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Rlc2NyaXB0aW9uO1xuICB9XG4gIHNldCBkZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHRoaXMuI2Rlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgaWYgKCF0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBkZXNjcmlwdGlvblxuICAgIH0pKTtcbiAgICBzdXBlci5hZGRFZGl0VG9vbGJhcigpLnRoZW4odG9vbGJhciA9PiB7XG4gICAgICB0b29sYmFyPy51cGRhdGVFZGl0U2lnbmF0dXJlQnV0dG9uKGRlc2NyaXB0aW9uKTtcbiAgICB9KTtcbiAgfVxuICBnZXRTaWduYXR1cmVQcmV2aWV3KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5ld0N1cnZlcyxcbiAgICAgIGFyZUNvbnRvdXJzLFxuICAgICAgdGhpY2tuZXNzLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy4jc2lnbmF0dXJlRGF0YTtcbiAgICBjb25zdCBtYXhEaW0gPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBvdXRsaW5lRGF0YSA9IFNpZ25hdHVyZUV4dHJhY3Rvci5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICBsaW5lczoge1xuICAgICAgICBjdXJ2ZXM6IG5ld0N1cnZlcy5tYXAocG9pbnRzID0+ICh7XG4gICAgICAgICAgcG9pbnRzXG4gICAgICAgIH0pKSxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9LFxuICAgICAgcGFnZVdpZHRoOiBtYXhEaW0sXG4gICAgICBwYWdlSGVpZ2h0OiBtYXhEaW0sXG4gICAgICByb3RhdGlvbjogMCxcbiAgICAgIGlubmVyTWFyZ2luOiAwLFxuICAgICAgbXVzdFNtb290aDogZmFsc2UsXG4gICAgICBhcmVDb250b3Vyc1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBhcmVDb250b3VycyxcbiAgICAgIG91dGxpbmU6IG91dGxpbmVEYXRhLm91dGxpbmVcbiAgICB9O1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLnNpZ25hdHVyZU1hbmFnZXIpIHtcbiAgICAgIHJldHVybiBbW1wiZWRpdFNpZ25hdHVyZVwiLCB0aGlzLl91aU1hbmFnZXIuc2lnbmF0dXJlTWFuYWdlcl1dO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIudG9vbGJhckJ1dHRvbnM7XG4gIH1cbiAgYWRkU2lnbmF0dXJlKGRhdGEsIGhlaWdodEluUGFnZSwgZGVzY3JpcHRpb24sIHV1aWQpIHtcbiAgICBjb25zdCB7XG4gICAgICB4OiBzYXZlZFgsXG4gICAgICB5OiBzYXZlZFlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBvdXRsaW5lXG4gICAgfSA9IHRoaXMuI3NpZ25hdHVyZURhdGEgPSBkYXRhO1xuICAgIHRoaXMuI2lzRXh0cmFjdGVkID0gb3V0bGluZSBpbnN0YW5jZW9mIENvbnRvdXJEcmF3T3V0bGluZTtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgbGV0IGRyYXdpbmdPcHRpb25zO1xuICAgIGlmICh0aGlzLiNpc0V4dHJhY3RlZCkge1xuICAgICAgZHJhd2luZ09wdGlvbnMgPSBTaWduYXR1cmVFZGl0b3IuZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdpbmdPcHRpb25zID0gU2lnbmF0dXJlRWRpdG9yLl9kZWZhdWx0RHJhd25TaWduYXR1cmVPcHRpb25zLmNsb25lKCk7XG4gICAgICBkcmF3aW5nT3B0aW9ucy51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogb3V0bGluZS50aGlja25lc3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9hZGRPdXRsaW5lcyh7XG4gICAgICBkcmF3T3V0bGluZXM6IG91dGxpbmUsXG4gICAgICBkcmF3aW5nT3B0aW9uc1xuICAgIH0pO1xuICAgIGNvbnN0IFssIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBsZXQgbmV3SGVpZ2h0ID0gaGVpZ2h0SW5QYWdlIC8gcGFnZUhlaWdodDtcbiAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgPj0gMSA/IDAuNSA6IG5ld0hlaWdodDtcbiAgICB0aGlzLndpZHRoICo9IG5ld0hlaWdodCAvIHRoaXMuaGVpZ2h0O1xuICAgIGlmICh0aGlzLndpZHRoID49IDEpIHtcbiAgICAgIG5ld0hlaWdodCAqPSAwLjkgLyB0aGlzLndpZHRoO1xuICAgICAgdGhpcy53aWR0aCA9IDAuOTtcbiAgICB9XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1zKCk7XG4gICAgdGhpcy54ID0gc2F2ZWRYO1xuICAgIHRoaXMueSA9IHNhdmVkWTtcbiAgICB0aGlzLmNlbnRlcigpO1xuICAgIHRoaXMuX29uUmVzaXplZCgpO1xuICAgIHRoaXMub25TY2FsZUNoYW5naW5nKCk7XG4gICAgdGhpcy5yb3RhdGUoKTtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSh0aGlzKTtcbiAgICB0aGlzLnNldFV1aWQodXVpZCk7XG4gICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJwZGZqcy5zaWduYXR1cmUuaW5zZXJ0ZWRcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaGFzQmVlblNhdmVkOiAhIXV1aWQsXG4gICAgICAgIGhhc0Rlc2NyaXB0aW9uOiAhIWRlc2NyaXB0aW9uXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5kaXYuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgZ2V0RnJvbUltYWdlKGJpdG1hcCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0XG4gICAgICB9LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgcmV0dXJuIFNpZ25hdHVyZUV4dHJhY3Rvci5wcm9jZXNzKGJpdG1hcCwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCByb3RhdGlvbiwgU2lnbmF0dXJlRWRpdG9yLl9JTk5FUl9NQVJHSU4pO1xuICB9XG4gIGdldEZyb21UZXh0KHRleHQsIGZvbnRJbmZvKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmF3RGltczoge1xuICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgIHBhZ2VIZWlnaHRcbiAgICAgIH0sXG4gICAgICByb3RhdGlvblxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydDtcbiAgICByZXR1cm4gU2lnbmF0dXJlRXh0cmFjdG9yLmV4dHJhY3RDb250b3Vyc0Zyb21UZXh0KHRleHQsIGZvbnRJbmZvLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIHJvdGF0aW9uLCBTaWduYXR1cmVFZGl0b3IuX0lOTkVSX01BUkdJTik7XG4gIH1cbiAgZ2V0RHJhd25TaWduYXR1cmUoY3VydmVzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmF3RGltczoge1xuICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgIHBhZ2VIZWlnaHRcbiAgICAgIH0sXG4gICAgICByb3RhdGlvblxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydDtcbiAgICByZXR1cm4gU2lnbmF0dXJlRXh0cmFjdG9yLnByb2Nlc3NEcmF3bkxpbmVzKHtcbiAgICAgIGxpbmVzOiBjdXJ2ZXMsXG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcm90YXRpb24sXG4gICAgICBpbm5lck1hcmdpbjogU2lnbmF0dXJlRWRpdG9yLl9JTk5FUl9NQVJHSU4sXG4gICAgICBtdXN0U21vb3RoOiBmYWxzZSxcbiAgICAgIGFyZUNvbnRvdXJzOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZURyYXdpbmdPcHRpb25zKHtcbiAgICBhcmVDb250b3VycyxcbiAgICB0aGlja25lc3NcbiAgfSkge1xuICAgIGlmIChhcmVDb250b3Vycykge1xuICAgICAgdGhpcy5fZHJhd2luZ09wdGlvbnMgPSBTaWduYXR1cmVFZGl0b3IuZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zID0gU2lnbmF0dXJlRWRpdG9yLl9kZWZhdWx0RHJhd25TaWduYXR1cmVPcHRpb25zLmNsb25lKCk7XG4gICAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucy51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogdGhpY2tuZXNzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbGluZXMsXG4gICAgICBwb2ludHNcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVEcmF3KGlzRm9yQ29weWluZyk7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdpbmdPcHRpb25zOiB7XG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzc1xuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBPYmplY3QuYXNzaWduKHN1cGVyLnNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpLCB7XG4gICAgICBpc1NpZ25hdHVyZTogdHJ1ZSxcbiAgICAgIGFyZUNvbnRvdXJzOiB0aGlzLiNpc0V4dHJhY3RlZCxcbiAgICAgIGNvbG9yOiBbMCwgMCwgMF0sXG4gICAgICB0aGlja25lc3M6IHRoaXMuI2lzRXh0cmFjdGVkID8gMCA6IHRoaWNrbmVzc1xuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLnBhdGhzID0ge1xuICAgICAgICBsaW5lcyxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9O1xuICAgICAgc2VyaWFsaXplZC51dWlkID0gdGhpcy4jc2lnbmF0dXJlVVVJRDtcbiAgICAgIHNlcmlhbGl6ZWQuaXNDb3B5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZC5saW5lcyA9IGxpbmVzO1xuICAgIH1cbiAgICBpZiAodGhpcy4jZGVzY3JpcHRpb24pIHtcbiAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEgPSB7XG4gICAgICAgIHR5cGU6IFwiRmlndXJlXCIsXG4gICAgICAgIGFsdDogdGhpcy4jZGVzY3JpcHRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZURyYXcocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuYXJlQ29udG91cnMpIHtcbiAgICAgIHJldHVybiBDb250b3VyRHJhd091dGxpbmUuZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIElua0RyYXdPdXRsaW5lLmRlc2VyaWFsaXplKHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwgZGF0YSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci4jaXNFeHRyYWN0ZWQgPSBkYXRhLmFyZUNvbnRvdXJzO1xuICAgIGVkaXRvci5kZXNjcmlwdGlvbiA9IGRhdGEuYWNjZXNzaWJpbGl0eURhdGE/LmFsdCB8fCBcIlwiO1xuICAgIGVkaXRvci4jc2lnbmF0dXJlVVVJRCA9IGRhdGEudXVpZDtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9zdGFtcC5qc1xuXG5cblxuXG5cblxuXG5jbGFzcyBTdGFtcEVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjYml0bWFwID0gbnVsbDtcbiAgI2JpdG1hcElkID0gbnVsbDtcbiAgI2JpdG1hcFByb21pc2UgPSBudWxsO1xuICAjYml0bWFwVXJsID0gbnVsbDtcbiAgI2JpdG1hcEZpbGUgPSBudWxsO1xuICAjYml0bWFwRmlsZU5hbWUgPSBcIlwiO1xuICAjY2FudmFzID0gbnVsbDtcbiAgI21pc3NpbmdDYW52YXMgPSBmYWxzZTtcbiAgI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICNpc1N2ZyA9IGZhbHNlO1xuICAjaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgc3RhdGljIF90eXBlID0gXCJzdGFtcFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJzdGFtcEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jYml0bWFwVXJsID0gcGFyYW1zLmJpdG1hcFVybDtcbiAgICB0aGlzLiNiaXRtYXBGaWxlID0gcGFyYW1zLmJpdG1hcEZpbGU7XG4gICAgdGhpcy5kZWZhdWx0TDEwbklkID0gXCJwZGZqcy1lZGl0b3Itc3RhbXAtZWRpdG9yXCI7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gIH1cbiAgc3RhdGljIGlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhtaW1lKSB7XG4gICAgcmV0dXJuIFN1cHBvcnRlZEltYWdlTWltZVR5cGVzLmluY2x1ZGVzKG1pbWUpO1xuICB9XG4gIHN0YXRpYyBwYXN0ZShpdGVtLCBwYXJlbnQpIHtcbiAgICBwYXJlbnQucGFzdGVFZGl0b3Ioe1xuICAgICAgbW9kZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVBcbiAgICB9LCB7XG4gICAgICBiaXRtYXBGaWxlOiBpdGVtLmdldEFzRmlsZSgpXG4gICAgfSk7XG4gIH1cbiAgYWx0VGV4dEZpbmlzaCgpIHtcbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgc3VwZXIuYWx0VGV4dEZpbmlzaCgpO1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3RhbXBcIixcbiAgICAgIGhhc0FsdFRleHQ6ICEhdGhpcy5hbHRUZXh0RGF0YT8uYWx0VGV4dFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEoZGF0YSkge1xuICAgIGNvbnN0IGhhc0FsdFRleHRTdGF0cyA9IGRhdGEuZ2V0KFwiaGFzQWx0VGV4dFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzQWx0VGV4dDogaGFzQWx0VGV4dFN0YXRzLmdldCh0cnVlKSA/PyAwLFxuICAgICAgaGFzTm9BbHRUZXh0OiBoYXNBbHRUZXh0U3RhdHMuZ2V0KGZhbHNlKSA/PyAwXG4gICAgfTtcbiAgfVxuICAjZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCBmcm9tSWQgPSBmYWxzZSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYml0bWFwID0gZGF0YS5iaXRtYXA7XG4gICAgaWYgKCFmcm9tSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcElkID0gZGF0YS5pZDtcbiAgICAgIHRoaXMuI2lzU3ZnID0gZGF0YS5pc1N2ZztcbiAgICB9XG4gICAgaWYgKGRhdGEuZmlsZSkge1xuICAgICAgdGhpcy4jYml0bWFwRmlsZU5hbWUgPSBkYXRhLmZpbGUubmFtZTtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gIH1cbiAgI2dldEJpdG1hcERvbmUoKSB7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGlmICghdGhpcy4jY2FudmFzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSAmJiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cgJiYgdGhpcy4jYml0bWFwKSB7XG4gICAgICB0aGlzLmFkZEVkaXRUb29sYmFyKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VkaXRUb29sYmFyLmhpZGUoKTtcbiAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVkaXRBbHRUZXh0KHRoaXMsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgJiYgdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93ICYmIHRoaXMuI2JpdG1hcCkge1xuICAgICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmltYWdlX2FkZGVkXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBhbHRfdGV4dF9tb2RhbDogZmFsc2UsXG4gICAgICAgICAgYWx0X3RleHRfdHlwZTogXCJlbXB0eVwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5tbEd1ZXNzQWx0VGV4dCgpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIGFzeW5jIG1sR3Vlc3NBbHRUZXh0KGltYWdlRGF0YSA9IG51bGwsIHVwZGF0ZUFsdFRleHREYXRhID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmhhc0FsdFRleHREYXRhKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtbE1hbmFnZXJcbiAgICB9ID0gdGhpcy5fdWlNYW5hZ2VyO1xuICAgIGlmICghbWxNYW5hZ2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBNTC5cIik7XG4gICAgfVxuICAgIGlmICghKGF3YWl0IG1sTWFuYWdlci5pc0VuYWJsZWRGb3IoXCJhbHRUZXh0XCIpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTUwgaXNuJ3QgZW5hYmxlZCBmb3IgYWx0IHRleHQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1hZ2VEYXRhIHx8IHRoaXMuY29weUNhbnZhcyhudWxsLCBudWxsLCB0cnVlKS5pbWFnZURhdGE7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtbE1hbmFnZXIuZ3Vlc3Moe1xuICAgICAgbmFtZTogXCJhbHRUZXh0XCIsXG4gICAgICByZXF1ZXN0OiB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGNoYW5uZWxzOiBkYXRhLmxlbmd0aCAvICh3aWR0aCAqIGhlaWdodClcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXNwb25zZSBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmNhbmNlbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub3V0cHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCByZXNwb25zZSBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgY29uc3QgYWx0VGV4dCA9IHJlc3BvbnNlLm91dHB1dDtcbiAgICBhd2FpdCB0aGlzLnNldEd1ZXNzZWRBbHRUZXh0KGFsdFRleHQpO1xuICAgIGlmICh1cGRhdGVBbHRUZXh0RGF0YSAmJiAhdGhpcy5oYXNBbHRUZXh0RGF0YSgpKSB7XG4gICAgICB0aGlzLmFsdFRleHREYXRhID0ge1xuICAgICAgICBhbHQ6IGFsdFRleHQsXG4gICAgICAgIGRlY29yYXRpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYWx0VGV4dDtcbiAgfVxuICAjZ2V0Qml0bWFwKCkge1xuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21JZCh0aGlzLiNiaXRtYXBJZCkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSwgdHJ1ZSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcFVybCkge1xuICAgICAgY29uc3QgdXJsID0gdGhpcy4jYml0bWFwVXJsO1xuICAgICAgdGhpcy4jYml0bWFwVXJsID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbVVybCh1cmwpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBGaWxlKSB7XG4gICAgICBjb25zdCBmaWxlID0gdGhpcy4jYml0bWFwRmlsZTtcbiAgICAgIHRoaXMuI2JpdG1hcEZpbGUgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tRmlsZShmaWxlKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJmaWxlXCI7XG4gICAgaW5wdXQuYWNjZXB0ID0gU3VwcG9ydGVkSW1hZ2VNaW1lVHlwZXMuam9pbihcIixcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghaW5wdXQuZmlsZXMgfHwgaW5wdXQuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tRmlsZShpbnB1dC5maWxlc1swXSk7XG4gICAgICAgICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJwZGZqcy5pbWFnZS5pbWFnZV9zZWxlY3RlZFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBhbHRfdGV4dF9tb2RhbDogdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2FuY2VsXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICBpbnB1dC5jbGljaygpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcCA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmRlbGV0ZUlkKHRoaXMuI2JpdG1hcElkKTtcbiAgICAgIHRoaXMuI2NhbnZhcz8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNjYW52YXMgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jcmVzaXplVGltZW91dElkKTtcbiAgICAgICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkICYmIHRoaXMuI2NhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gISh0aGlzLiNiaXRtYXBQcm9taXNlIHx8IHRoaXMuI2JpdG1hcCB8fCB0aGlzLiNiaXRtYXBVcmwgfHwgdGhpcy4jYml0bWFwRmlsZSB8fCB0aGlzLiNiaXRtYXBJZCB8fCB0aGlzLiNtaXNzaW5nQ2FudmFzKTtcbiAgfVxuICBnZXQgdG9vbGJhckJ1dHRvbnMoKSB7XG4gICAgcmV0dXJuIFtbXCJhbHRUZXh0XCIsIHRoaXMuY3JlYXRlQWx0VGV4dCgpXV07XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy5faXNDb3B5KSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmRpdi5oaWRkZW4gPSB0cnVlO1xuICAgIHRoaXMuY3JlYXRlQWx0VGV4dCgpO1xuICAgIGlmICghdGhpcy4jbWlzc2luZ0NhbnZhcykge1xuICAgICAgaWYgKHRoaXMuI2JpdG1hcCkge1xuICAgICAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5faXNDb3B5KSB7XG4gICAgICB0aGlzLl9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpO1xuICAgIH1cbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkU2hvdWxkUmVzY2FsZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgc2V0Q2FudmFzKGFubm90YXRpb25FbGVtZW50SWQsIGNhbnZhcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkOiBiaXRtYXBJZCxcbiAgICAgIGJpdG1hcFxuICAgIH0gPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21DYW52YXMoYW5ub3RhdGlvbkVsZW1lbnRJZCwgY2FudmFzKTtcbiAgICBjYW52YXMucmVtb3ZlKCk7XG4gICAgaWYgKGJpdG1hcElkICYmIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuaXNWYWxpZElkKGJpdG1hcElkKSkge1xuICAgICAgdGhpcy4jYml0bWFwSWQgPSBiaXRtYXBJZDtcbiAgICAgIGlmIChiaXRtYXApIHtcbiAgICAgICAgdGhpcy4jYml0bWFwID0gYml0bWFwO1xuICAgICAgfVxuICAgICAgdGhpcy4jbWlzc2luZ0NhbnZhcyA9IGZhbHNlO1xuICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgfVxuICB9XG4gIF9vblJlc2l6ZWQoKSB7XG4gICAgdGhpcy5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcmVzaXplVGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jcmVzaXplVGltZW91dElkKTtcbiAgICB9XG4gICAgY29uc3QgVElNRV9UT19XQUlUID0gMjAwO1xuICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgICAgIHRoaXMuI2RyYXdCaXRtYXAoKTtcbiAgICB9LCBUSU1FX1RPX1dBSVQpO1xuICB9XG4gICNjcmVhdGVDYW52YXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2JpdG1hcDtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgTUFYX1JBVElPID0gMC43NTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgd2lkdGggPSB0aGlzLndpZHRoICogcGFnZVdpZHRoO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAod2lkdGggPiBNQVhfUkFUSU8gKiBwYWdlV2lkdGggfHwgaGVpZ2h0ID4gTUFYX1JBVElPICogcGFnZUhlaWdodCkge1xuICAgICAgY29uc3QgZmFjdG9yID0gTWF0aC5taW4oTUFYX1JBVElPICogcGFnZVdpZHRoIC8gd2lkdGgsIE1BWF9SQVRJTyAqIHBhZ2VIZWlnaHQgLyBoZWlnaHQpO1xuICAgICAgd2lkdGggKj0gZmFjdG9yO1xuICAgICAgaGVpZ2h0ICo9IGZhY3RvcjtcbiAgICB9XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuI2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJpbWdcIik7XG4gICAgdGhpcy5hZGRDb250YWluZXIoY2FudmFzKTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgLyBwYWdlSGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltcygpO1xuICAgIGlmICh0aGlzLl9pbml0aWFsT3B0aW9ucz8uaXNDZW50ZXJlZCkge1xuICAgICAgdGhpcy5jZW50ZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucyA9IG51bGw7XG4gICAgaWYgKCF0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSB8fCAhdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93IHx8IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgZGl2LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiNkcmF3Qml0bWFwKCk7XG4gICAgaWYgKCF0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjaykge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkVW5kb2FibGVFZGl0b3IodGhpcyk7XG4gICAgICB0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiaW5zZXJ0ZWRfaW1hZ2VcIlxuICAgIH0pO1xuICAgIGlmICh0aGlzLiNiaXRtYXBGaWxlTmFtZSkge1xuICAgICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmlwdGlvblwiLCB0aGlzLiNiaXRtYXBGaWxlTmFtZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYTExeUFsZXJ0KFwicGRmanMtZWRpdG9yLXN0YW1wLWFkZGVkLWFsZXJ0XCIpO1xuICAgIH1cbiAgfVxuICBjb3B5Q2FudmFzKG1heERhdGFEaW1lbnNpb24sIG1heFByZXZpZXdEaW1lbnNpb24sIGNyZWF0ZUltYWdlRGF0YSA9IGZhbHNlKSB7XG4gICAgaWYgKCFtYXhEYXRhRGltZW5zaW9uKSB7XG4gICAgICBtYXhEYXRhRGltZW5zaW9uID0gMjI0O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogYml0bWFwV2lkdGgsXG4gICAgICBoZWlnaHQ6IGJpdG1hcEhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgY29uc3Qgb3V0cHV0U2NhbGUgPSBuZXcgT3V0cHV0U2NhbGUoKTtcbiAgICBsZXQgYml0bWFwID0gdGhpcy4jYml0bWFwO1xuICAgIGxldCB3aWR0aCA9IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0ID0gYml0bWFwSGVpZ2h0O1xuICAgIGxldCBjYW52YXMgPSBudWxsO1xuICAgIGlmIChtYXhQcmV2aWV3RGltZW5zaW9uKSB7XG4gICAgICBpZiAoYml0bWFwV2lkdGggPiBtYXhQcmV2aWV3RGltZW5zaW9uIHx8IGJpdG1hcEhlaWdodCA+IG1heFByZXZpZXdEaW1lbnNpb24pIHtcbiAgICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLm1pbihtYXhQcmV2aWV3RGltZW5zaW9uIC8gYml0bWFwV2lkdGgsIG1heFByZXZpZXdEaW1lbnNpb24gLyBiaXRtYXBIZWlnaHQpO1xuICAgICAgICB3aWR0aCA9IE1hdGguZmxvb3IoYml0bWFwV2lkdGggKiByYXRpbyk7XG4gICAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IoYml0bWFwSGVpZ2h0ICogcmF0aW8pO1xuICAgICAgfVxuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogb3V0cHV0U2NhbGUuc3gpO1xuICAgICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBvdXRwdXRTY2FsZS5zeSk7XG4gICAgICBpZiAoIXRoaXMuI2lzU3ZnKSB7XG4gICAgICAgIGJpdG1hcCA9IHRoaXMuI3NjYWxlQml0bWFwKHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5maWx0ZXIgPSB0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyO1xuICAgICAgbGV0IHdoaXRlID0gXCJ3aGl0ZVwiLFxuICAgICAgICBibGFjayA9IFwiI2NmY2ZkOFwiO1xuICAgICAgaWYgKHRoaXMuX3VpTWFuYWdlci5oY21GaWx0ZXIgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGJsYWNrID0gXCJibGFja1wiO1xuICAgICAgfSBlbHNlIGlmIChDb2xvclNjaGVtZS5pc0RhcmtNb2RlKSB7XG4gICAgICAgIHdoaXRlID0gXCIjOGY4ZjlkXCI7XG4gICAgICAgIGJsYWNrID0gXCIjNDI0MTRkXCI7XG4gICAgICB9XG4gICAgICBjb25zdCBib3hEaW0gPSAxNTtcbiAgICAgIGNvbnN0IGJveERpbVdpZHRoID0gYm94RGltICogb3V0cHV0U2NhbGUuc3g7XG4gICAgICBjb25zdCBib3hEaW1IZWlnaHQgPSBib3hEaW0gKiBvdXRwdXRTY2FsZS5zeTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGJveERpbVdpZHRoICogMiwgYm94RGltSGVpZ2h0ICogMik7XG4gICAgICBjb25zdCBwYXR0ZXJuQ3R4ID0gcGF0dGVybi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxTdHlsZSA9IHdoaXRlO1xuICAgICAgcGF0dGVybkN0eC5maWxsUmVjdCgwLCAwLCBib3hEaW1XaWR0aCAqIDIsIGJveERpbUhlaWdodCAqIDIpO1xuICAgICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSBibGFjaztcbiAgICAgIHBhdHRlcm5DdHguZmlsbFJlY3QoMCwgMCwgYm94RGltV2lkdGgsIGJveERpbUhlaWdodCk7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxSZWN0KGJveERpbVdpZHRoLCBib3hEaW1IZWlnaHQsIGJveERpbVdpZHRoLCBib3hEaW1IZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGN0eC5jcmVhdGVQYXR0ZXJuKHBhdHRlcm4sIFwicmVwZWF0XCIpO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCwgMCwgMCwgc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgfVxuICAgIGxldCBpbWFnZURhdGEgPSBudWxsO1xuICAgIGlmIChjcmVhdGVJbWFnZURhdGEpIHtcbiAgICAgIGxldCBkYXRhV2lkdGgsIGRhdGFIZWlnaHQ7XG4gICAgICBpZiAob3V0cHV0U2NhbGUuc3ltbWV0cmljICYmIGJpdG1hcC53aWR0aCA8IG1heERhdGFEaW1lbnNpb24gJiYgYml0bWFwLmhlaWdodCA8IG1heERhdGFEaW1lbnNpb24pIHtcbiAgICAgICAgZGF0YVdpZHRoID0gYml0bWFwLndpZHRoO1xuICAgICAgICBkYXRhSGVpZ2h0ID0gYml0bWFwLmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICAgICAgaWYgKGJpdG1hcFdpZHRoID4gbWF4RGF0YURpbWVuc2lvbiB8fCBiaXRtYXBIZWlnaHQgPiBtYXhEYXRhRGltZW5zaW9uKSB7XG4gICAgICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLm1pbihtYXhEYXRhRGltZW5zaW9uIC8gYml0bWFwV2lkdGgsIG1heERhdGFEaW1lbnNpb24gLyBiaXRtYXBIZWlnaHQpO1xuICAgICAgICAgIGRhdGFXaWR0aCA9IE1hdGguZmxvb3IoYml0bWFwV2lkdGggKiByYXRpbyk7XG4gICAgICAgICAgZGF0YUhlaWdodCA9IE1hdGguZmxvb3IoYml0bWFwSGVpZ2h0ICogcmF0aW8pO1xuICAgICAgICAgIGlmICghdGhpcy4jaXNTdmcpIHtcbiAgICAgICAgICAgIGJpdG1hcCA9IHRoaXMuI3NjYWxlQml0bWFwKGRhdGFXaWR0aCwgZGF0YUhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGRhdGFXaWR0aCwgZGF0YUhlaWdodCk7XG4gICAgICBjb25zdCBvZmZzY3JlZW5DdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIG9mZnNjcmVlbkN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIGRhdGFXaWR0aCwgZGF0YUhlaWdodCk7XG4gICAgICBpbWFnZURhdGEgPSB7XG4gICAgICAgIHdpZHRoOiBkYXRhV2lkdGgsXG4gICAgICAgIGhlaWdodDogZGF0YUhlaWdodCxcbiAgICAgICAgZGF0YTogb2Zmc2NyZWVuQ3R4LmdldEltYWdlRGF0YSgwLCAwLCBkYXRhV2lkdGgsIGRhdGFIZWlnaHQpLmRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGltYWdlRGF0YVxuICAgIH07XG4gIH1cbiAgI3NjYWxlQml0bWFwKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogYml0bWFwV2lkdGgsXG4gICAgICBoZWlnaHQ6IGJpdG1hcEhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgbGV0IG5ld1dpZHRoID0gYml0bWFwV2lkdGg7XG4gICAgbGV0IG5ld0hlaWdodCA9IGJpdG1hcEhlaWdodDtcbiAgICBsZXQgYml0bWFwID0gdGhpcy4jYml0bWFwO1xuICAgIHdoaWxlIChuZXdXaWR0aCA+IDIgKiB3aWR0aCB8fCBuZXdIZWlnaHQgPiAyICogaGVpZ2h0KSB7XG4gICAgICBjb25zdCBwcmV2V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIGNvbnN0IHByZXZIZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICBpZiAobmV3V2lkdGggPiAyICogd2lkdGgpIHtcbiAgICAgICAgbmV3V2lkdGggPSBuZXdXaWR0aCA+PSAxNjM4NCA/IE1hdGguZmxvb3IobmV3V2lkdGggLyAyKSAtIDEgOiBNYXRoLmNlaWwobmV3V2lkdGggLyAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdIZWlnaHQgPiAyICogaGVpZ2h0KSB7XG4gICAgICAgIG5ld0hlaWdodCA9IG5ld0hlaWdodCA+PSAxNjM4NCA/IE1hdGguZmxvb3IobmV3SGVpZ2h0IC8gMikgLSAxIDogTWF0aC5jZWlsKG5ld0hlaWdodCAvIDIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgcHJldldpZHRoLCBwcmV2SGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIGJpdG1hcCA9IG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpdG1hcDtcbiAgfVxuICAjZHJhd0JpdG1hcCgpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBvdXRwdXRTY2FsZSA9IG5ldyBPdXRwdXRTY2FsZSgpO1xuICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogcGFyZW50V2lkdGggKiBvdXRwdXRTY2FsZS5zeCk7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIHBhcmVudEhlaWdodCAqIG91dHB1dFNjYWxlLnN5KTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLiNjYW52YXM7XG4gICAgaWYgKCFjYW52YXMgfHwgY2FudmFzLndpZHRoID09PSBzY2FsZWRXaWR0aCAmJiBjYW52YXMuaGVpZ2h0ID09PSBzY2FsZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FudmFzLndpZHRoID0gc2NhbGVkV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHNjYWxlZEhlaWdodDtcbiAgICBjb25zdCBiaXRtYXAgPSB0aGlzLiNpc1N2ZyA/IHRoaXMuI2JpdG1hcCA6IHRoaXMuI3NjYWxlQml0bWFwKHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LmZpbHRlciA9IHRoaXMuX3VpTWFuYWdlci5oY21GaWx0ZXI7XG4gICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCwgMCwgMCwgc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gIH1cbiAgI3NlcmlhbGl6ZUJpdG1hcCh0b1VybCkge1xuICAgIGlmICh0b1VybCkge1xuICAgICAgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0U3ZnVXJsKHRoaXMuI2JpdG1hcElkKTtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAoe1xuICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICAgIH0gPSB0aGlzLiNiaXRtYXApO1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy4jYml0bWFwLCAwLCAwKTtcbiAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiBwYWdlV2lkdGggKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuI2JpdG1hcCwgMCwgMCwgdGhpcy4jYml0bWFwLndpZHRoLCB0aGlzLiNiaXRtYXAuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJldHVybiBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodGhpcy4jYml0bWFwKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGxldCBtaXNzaW5nQ2FudmFzID0gZmFsc2U7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBTdGFtcEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHN0cnVjdFBhcmVudCxcbiAgICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgICByaWNoVGV4dCxcbiAgICAgICAgICBjb250ZW50c09iaixcbiAgICAgICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZVxuICAgICAgICB9LFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbnZhc1xuICAgICAgfSA9IGRhdGE7XG4gICAgICBsZXQgYml0bWFwSWQsIGJpdG1hcDtcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgZGVsZXRlIGRhdGEuY2FudmFzO1xuICAgICAgICAoe1xuICAgICAgICAgIGlkOiBiaXRtYXBJZCxcbiAgICAgICAgICBiaXRtYXBcbiAgICAgICAgfSA9IHVpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUNhbnZhcyhjb250YWluZXIuaWQsIGNhbnZhcykpO1xuICAgICAgICBjYW52YXMucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaXNzaW5nQ2FudmFzID0gdHJ1ZTtcbiAgICAgICAgZGF0YS5faGFzTm9DYW52YXMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgYWx0VGV4dCA9IChhd2FpdCBwYXJlbnQuX3N0cnVjdFRyZWUuZ2V0QXJpYUF0dHJpYnV0ZXMoYCR7QW5ub3RhdGlvblByZWZpeH0ke2lkfWApKT8uZ2V0KFwiYXJpYS1sYWJlbFwiKSB8fCBcIlwiO1xuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAsXG4gICAgICAgIGJpdG1hcElkLFxuICAgICAgICBiaXRtYXAsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBpZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBhY2Nlc3NpYmlsaXR5RGF0YToge1xuICAgICAgICAgIGRlY29yYXRpdmU6IGZhbHNlLFxuICAgICAgICAgIGFsdFRleHRcbiAgICAgICAgfSxcbiAgICAgICAgaXNTdmc6IGZhbHNlLFxuICAgICAgICBzdHJ1Y3RQYXJlbnQsXG4gICAgICAgIHBvcHVwUmVmLFxuICAgICAgICByaWNoVGV4dCxcbiAgICAgICAgY29tbWVudDogY29udGVudHNPYmo/LnN0ciB8fCBudWxsLFxuICAgICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBjb25zdCB7XG4gICAgICByZWN0LFxuICAgICAgYml0bWFwLFxuICAgICAgYml0bWFwVXJsLFxuICAgICAgYml0bWFwSWQsXG4gICAgICBpc1N2ZyxcbiAgICAgIGFjY2Vzc2liaWxpdHlEYXRhXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKG1pc3NpbmdDYW52YXMpIHtcbiAgICAgIHVpTWFuYWdlci5hZGRNaXNzaW5nQ2FudmFzKGRhdGEuaWQsIGVkaXRvcik7XG4gICAgICBlZGl0b3IuI21pc3NpbmdDYW52YXMgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoYml0bWFwSWQgJiYgdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5pc1ZhbGlkSWQoYml0bWFwSWQpKSB7XG4gICAgICBlZGl0b3IuI2JpdG1hcElkID0gYml0bWFwSWQ7XG4gICAgICBpZiAoYml0bWFwKSB7XG4gICAgICAgIGVkaXRvci4jYml0bWFwID0gYml0bWFwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IuI2JpdG1hcFVybCA9IGJpdG1hcFVybDtcbiAgICB9XG4gICAgZWRpdG9yLiNpc1N2ZyA9IGlzU3ZnO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBlZGl0b3Iud2lkdGggPSAocmVjdFsyXSAtIHJlY3RbMF0pIC8gcGFyZW50V2lkdGg7XG4gICAgZWRpdG9yLmhlaWdodCA9IChyZWN0WzNdIC0gcmVjdFsxXSkgLyBwYXJlbnRIZWlnaHQ7XG4gICAgaWYgKGFjY2Vzc2liaWxpdHlEYXRhKSB7XG4gICAgICBlZGl0b3IuYWx0VGV4dERhdGEgPSBhY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICB9XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIGlmIChkYXRhLmNvbW1lbnQpIHtcbiAgICAgIGVkaXRvci5zZXRDb21tZW50RGF0YShkYXRhKTtcbiAgICB9XG4gICAgZWRpdG9yLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9ICEhaW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVkID0gT2JqZWN0LmFzc2lnbihzdXBlci5zZXJpYWxpemUoaXNGb3JDb3B5aW5nKSwge1xuICAgICAgYml0bWFwSWQ6IHRoaXMuI2JpdG1hcElkLFxuICAgICAgaXNTdmc6IHRoaXMuI2lzU3ZnXG4gICAgfSk7XG4gICAgdGhpcy5hZGRDb21tZW50KHNlcmlhbGl6ZWQpO1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHNlcmlhbGl6ZWQuYml0bWFwVXJsID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKHRydWUpO1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHRoaXMuc2VyaWFsaXplQWx0VGV4dCh0cnVlKTtcbiAgICAgIHNlcmlhbGl6ZWQuaXNDb3B5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkZWNvcmF0aXZlLFxuICAgICAgYWx0VGV4dFxuICAgIH0gPSB0aGlzLnNlcmlhbGl6ZUFsdFRleHQoZmFsc2UpO1xuICAgIGlmICghZGVjb3JhdGl2ZSAmJiBhbHRUZXh0KSB7XG4gICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhID0ge1xuICAgICAgICB0eXBlOiBcIkZpZ3VyZVwiLFxuICAgICAgICBhbHQ6IGFsdFRleHRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKTtcbiAgICAgIGlmIChjaGFuZ2VzLmlzU2FtZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFuZ2VzLmlzU2FtZUFsdFRleHQpIHtcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhLnN0cnVjdFBhcmVudCA9IHRoaXMuX2luaXRpYWxEYXRhLnN0cnVjdFBhcmVudCA/PyAtMTtcbiAgICAgIH1cbiAgICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgICBkZWxldGUgc2VyaWFsaXplZC5iaXRtYXBJZDtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGNvbnRleHQuc3RhbXBzIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuI2lzU3ZnID8gKHNlcmlhbGl6ZWQucmVjdFsyXSAtIHNlcmlhbGl6ZWQucmVjdFswXSkgKiAoc2VyaWFsaXplZC5yZWN0WzNdIC0gc2VyaWFsaXplZC5yZWN0WzFdKSA6IG51bGw7XG4gICAgaWYgKCFjb250ZXh0LnN0YW1wcy5oYXModGhpcy4jYml0bWFwSWQpKSB7XG4gICAgICBjb250ZXh0LnN0YW1wcy5zZXQodGhpcy4jYml0bWFwSWQsIHtcbiAgICAgICAgYXJlYSxcbiAgICAgICAgc2VyaWFsaXplZFxuICAgICAgfSk7XG4gICAgICBzZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgY29uc3QgcHJldkRhdGEgPSBjb250ZXh0LnN0YW1wcy5nZXQodGhpcy4jYml0bWFwSWQpO1xuICAgICAgaWYgKGFyZWEgPiBwcmV2RGF0YS5hcmVhKSB7XG4gICAgICAgIHByZXZEYXRhLmFyZWEgPSBhcmVhO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcC5jbG9zZSgpO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZUluZGV4LFxuICAgICAgYWNjZXNzaWJpbGl0eURhdGE6IHtcbiAgICAgICAgYWx0VGV4dFxuICAgICAgfVxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICBjb25zdCBpc1NhbWVQYWdlSW5kZXggPSBzZXJpYWxpemVkLnBhZ2VJbmRleCA9PT0gcGFnZUluZGV4O1xuICAgIGNvbnN0IGlzU2FtZUFsdFRleHQgPSAoc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YT8uYWx0IHx8IFwiXCIpID09PSBhbHRUZXh0O1xuICAgIHJldHVybiB7XG4gICAgICBpc1NhbWU6ICF0aGlzLmhhc0VkaXRlZENvbW1lbnQgJiYgIXRoaXMuX2hhc0JlZW5Nb3ZlZCAmJiAhdGhpcy5faGFzQmVlblJlc2l6ZWQgJiYgaXNTYW1lUGFnZUluZGV4ICYmIGlzU2FtZUFsdFRleHQsXG4gICAgICBpc1NhbWVBbHRUZXh0XG4gICAgfTtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgYW5ub3RhdGlvbi5oaWRlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQoe1xuICAgICAgcmVjdDogdGhpcy5nZXRQREZSZWN0KCksXG4gICAgICBwb3B1cDogdGhpcy5jb21tZW50XG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2Fubm90YXRpb25fZWRpdG9yX2xheWVyLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIge1xuICAjYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICNhbGxvd0NsaWNrID0gZmFsc2U7XG4gICNhbm5vdGF0aW9uTGF5ZXIgPSBudWxsO1xuICAjY2xpY2tBQyA9IG51bGw7XG4gICNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IG51bGw7XG4gICNlZGl0b3JzID0gbmV3IE1hcCgpO1xuICAjaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gICNpc0VuYWJsaW5nID0gZmFsc2U7XG4gICNkcmF3aW5nQUMgPSBudWxsO1xuICAjZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuICAjdGV4dExheWVyID0gbnVsbDtcbiAgI3RleHRTZWxlY3Rpb25BQyA9IG51bGw7XG4gICN0ZXh0TGF5ZXJEYmxDbGlja0FDID0gbnVsbDtcbiAgI2xhc3RQb2ludGVyRG93blRpbWVzdGFtcCA9IC0xO1xuICAjdWlNYW5hZ2VyO1xuICBzdGF0aWMgX2luaXRpYWxpemVkID0gZmFsc2U7XG4gIHN0YXRpYyAjZWRpdG9yVHlwZXMgPSBuZXcgTWFwKFtGcmVlVGV4dEVkaXRvciwgSW5rRWRpdG9yLCBTdGFtcEVkaXRvciwgSGlnaGxpZ2h0RWRpdG9yLCBTaWduYXR1cmVFZGl0b3JdLm1hcCh0eXBlID0+IFt0eXBlLl9lZGl0b3JUeXBlLCB0eXBlXSkpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdWlNYW5hZ2VyLFxuICAgIHBhZ2VJbmRleCxcbiAgICBkaXYsXG4gICAgc3RydWN0VHJlZUxheWVyLFxuICAgIGFjY2Vzc2liaWxpdHlNYW5hZ2VyLFxuICAgIGFubm90YXRpb25MYXllcixcbiAgICBkcmF3TGF5ZXIsXG4gICAgdGV4dExheWVyLFxuICAgIHZpZXdwb3J0LFxuICAgIGwxMG5cbiAgfSkge1xuICAgIGNvbnN0IGVkaXRvclR5cGVzID0gWy4uLkFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMudmFsdWVzKCldO1xuICAgIGlmICghQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCkge1xuICAgICAgQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgZWRpdG9yVHlwZS5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHVpTWFuYWdlci5yZWdpc3RlckVkaXRvclR5cGVzKGVkaXRvclR5cGVzKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgICB0aGlzLiNhbm5vdGF0aW9uTGF5ZXIgPSBhbm5vdGF0aW9uTGF5ZXI7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMuI3RleHRMYXllciA9IHRleHRMYXllcjtcbiAgICB0aGlzLmRyYXdMYXllciA9IGRyYXdMYXllcjtcbiAgICB0aGlzLl9zdHJ1Y3RUcmVlID0gc3RydWN0VHJlZUxheWVyO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRMYXllcih0aGlzKTtcbiAgfVxuICBnZXQgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdG9ycy5zaXplID09PSAwO1xuICB9XG4gIGdldCBpc0ludmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VtcHR5ICYmIHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gIH1cbiAgdXBkYXRlVG9vbGJhcihvcHRpb25zKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZVRvb2xiYXIob3B0aW9ucyk7XG4gIH1cbiAgdXBkYXRlTW9kZShtb2RlID0gdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSkge1xuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTpcbiAgICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcIm5vbkVkaXRpbmdcIiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgdGhpcy50b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgICB0aGlzLmRpc2FibGVDbGljaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JUeXBlLklOSzpcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZW5hYmxlQ2xpY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDpcbiAgICAgICAgdGhpcy5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUNsaWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZW5hYmxlQ2xpY2soKTtcbiAgICB9XG4gICAgdGhpcy50b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICBjb25zdCB7XG4gICAgICBjbGFzc0xpc3RcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgY2xhc3NMaXN0LnRvZ2dsZShcIm5vbkVkaXRpbmdcIiwgZmFsc2UpO1xuICAgIGlmIChtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5QT1BVUCkge1xuICAgICAgY2xhc3NMaXN0LnRvZ2dsZShcImNvbW1lbnRFZGl0aW5nXCIsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGFzc0xpc3QudG9nZ2xlKFwiY29tbWVudEVkaXRpbmdcIiwgZmFsc2UpO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgICAgY2xhc3NMaXN0LnRvZ2dsZShgJHtlZGl0b3JUeXBlLl90eXBlfUVkaXRpbmdgLCBtb2RlID09PSBlZGl0b3JUeXBlLl9lZGl0b3JUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kaXYuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgaGFzVGV4dExheWVyKHRleHRMYXllcikge1xuICAgIHJldHVybiB0ZXh0TGF5ZXIgPT09IHRoaXMuI3RleHRMYXllcj8uZGl2O1xuICB9XG4gIHNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZyk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cbiAgY2xlYW5VbmRvU3RhY2sodHlwZSkge1xuICAgIHRoaXMuI3VpTWFuYWdlci5jbGVhblVuZG9TdGFjayh0eXBlKTtcbiAgfVxuICB0b2dnbGVEcmF3aW5nKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkcmF3aW5nXCIsICFlbmFibGVkKTtcbiAgfVxuICB0b2dnbGVQb2ludGVyRXZlbnRzKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCAhZW5hYmxlZCk7XG4gIH1cbiAgdG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyhlbmFibGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLiNhbm5vdGF0aW9uTGF5ZXI/LmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgIWVuYWJsZWQpO1xuICB9XG4gIGdldCAjYWxsRWRpdG9yc0l0ZXJhdG9yKCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0b3JzLnNpemUgIT09IDAgPyB0aGlzLiNlZGl0b3JzLnZhbHVlcygpIDogdGhpcy4jdWlNYW5hZ2VyLmdldEVkaXRvcnModGhpcy5wYWdlSW5kZXgpO1xuICB9XG4gIGFzeW5jIGVuYWJsZSgpIHtcbiAgICB0aGlzLiNpc0VuYWJsaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi50YWJJbmRleCA9IDA7XG4gICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJub25FZGl0aW5nXCIsIGZhbHNlKTtcbiAgICB0aGlzLiN0ZXh0TGF5ZXJEYmxDbGlja0FDPy5hYm9ydCgpO1xuICAgIHRoaXMuI3RleHRMYXllckRibENsaWNrQUMgPSBudWxsO1xuICAgIGNvbnN0IGFubm90YXRpb25FbGVtZW50SWRzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnNJdGVyYXRvcikge1xuICAgICAgZWRpdG9yLmVuYWJsZUVkaXRpbmcoKTtcbiAgICAgIGVkaXRvci5zaG93KHRydWUpO1xuICAgICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWRzLmFkZChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFubm90YXRpb25MYXllciA9IHRoaXMuI2Fubm90YXRpb25MYXllcjtcbiAgICBpZiAoYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRhYmxlIG9mIGFubm90YXRpb25MYXllci5nZXRFZGl0YWJsZUFubm90YXRpb25zKCkpIHtcbiAgICAgICAgZWRpdGFibGUuaGlkZSgpO1xuICAgICAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRhYmxlLmRhdGEuaWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb25FbGVtZW50SWRzLmhhcyhlZGl0YWJsZS5kYXRhLmlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHRoaXMuZGVzZXJpYWxpemUoZWRpdGFibGUpO1xuICAgICAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5lbmFibGVFZGl0aW5nKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2lzRW5hYmxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLiN1aU1hbmFnZXIuX2V2ZW50QnVzLmRpc3BhdGNoKFwiZWRpdG9yc3JlbmRlcmVkXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIHBhZ2VOdW1iZXI6IHRoaXMucGFnZUluZGV4ICsgMVxuICAgIH0pO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwibm9uRWRpdGluZ1wiLCB0cnVlKTtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyICYmICF0aGlzLiN0ZXh0TGF5ZXJEYmxDbGlja0FDKSB7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXJEYmxDbGlja0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI3RleHRMYXllckRibENsaWNrQUMpO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZSA9PiB7XG4gICAgICAgIGNvbnN0IERCTF9DTElDS19USFJFU0hPTEQgPSA1MDA7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjbGllbnRYLFxuICAgICAgICAgIGNsaWVudFksXG4gICAgICAgICAgdGltZVN0YW1wXG4gICAgICAgIH0gPSBlO1xuICAgICAgICBjb25zdCBsYXN0UG9pbnRlckRvd25UaW1lc3RhbXAgPSB0aGlzLiNsYXN0UG9pbnRlckRvd25UaW1lc3RhbXA7XG4gICAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0UG9pbnRlckRvd25UaW1lc3RhbXAgPiBEQkxfQ0xJQ0tfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgdGhpcy4jbGFzdFBvaW50ZXJEb3duVGltZXN0YW1wID0gdGltZVN0YW1wO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNsYXN0UG9pbnRlckRvd25UaW1lc3RhbXAgPSAtMTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNsYXNzTGlzdFxuICAgICAgICB9ID0gdGhpcy5kaXY7XG4gICAgICAgIGNsYXNzTGlzdC50b2dnbGUoXCJnZXRFbGVtZW50c1wiLCB0cnVlKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgY2xhc3NMaXN0LnRvZ2dsZShcImdldEVsZW1lbnRzXCIsIGZhbHNlKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpdi5jb250YWlucyhlbGVtZW50c1swXSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4ke0Fubm90YXRpb25FZGl0b3JQcmVmaXh9WzAtOV0rJGApO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICBpZiAocmVnZXgudGVzdChlbGVtZW50LmlkKSkge1xuICAgICAgICAgICAgaWQgPSBlbGVtZW50LmlkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy4jZWRpdG9ycy5nZXQoaWQpO1xuICAgICAgICBpZiAoZWRpdG9yPy5hbm5vdGF0aW9uRWxlbWVudElkID09PSBudWxsKSB7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZWRpdG9yLmRibGNsaWNrKGUpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFubm90YXRpb25MYXllciA9IHRoaXMuI2Fubm90YXRpb25MYXllcjtcbiAgICBpZiAoYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkQW5ub3RhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCByZXNldEFubm90YXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9yc0l0ZXJhdG9yKSB7XG4gICAgICAgIGVkaXRvci5kaXNhYmxlRWRpdGluZygpO1xuICAgICAgICBpZiAoIWVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgICAgZWRpdG9yLnVwZGF0ZUZha2VBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uTGF5ZXIpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZGl0b3Iuc2VyaWFsaXplKCkgIT09IG51bGwpIHtcbiAgICAgICAgICBjaGFuZ2VkQW5ub3RhdGlvbnMuc2V0KGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkLCBlZGl0b3IpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0QW5ub3RhdGlvbnMuc2V0KGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkLCBlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKT8uc2hvdygpO1xuICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0YWJsZXMgPSBhbm5vdGF0aW9uTGF5ZXIuZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpO1xuICAgICAgZm9yIChjb25zdCBlZGl0YWJsZSBvZiBlZGl0YWJsZXMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBlZGl0YWJsZS5kYXRhO1xuICAgICAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGlkKSkge1xuICAgICAgICAgIGVkaXRhYmxlLnVwZGF0ZUVkaXRlZCh7XG4gICAgICAgICAgICBkZWxldGVkOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVkaXRvciA9IHJlc2V0QW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgIGVkaXRvci5yZXNldEFubm90YXRpb25FbGVtZW50KGVkaXRhYmxlKTtcbiAgICAgICAgICBlZGl0b3Iuc2hvdyhmYWxzZSk7XG4gICAgICAgICAgZWRpdGFibGUuc2hvdygpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvciA9IGNoYW5nZWRBbm5vdGF0aW9ucy5nZXQoaWQpO1xuICAgICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZENoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oZWRpdG9yKTtcbiAgICAgICAgICBpZiAoZWRpdG9yLnJlbmRlckFubm90YXRpb25FbGVtZW50KGVkaXRhYmxlKSkge1xuICAgICAgICAgICAgZWRpdG9yLnNob3coZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlZGl0YWJsZS5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBpZiAodGhpcy5pc0VtcHR5KSB7XG4gICAgICB0aGlzLmRpdi5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjbGFzc0xpc3RcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGNsYXNzTGlzdC5yZW1vdmUoYCR7ZWRpdG9yVHlwZS5fdHlwZX1FZGl0aW5nYCk7XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICB0aGlzLnRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSBmYWxzZTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYW5ub3RhdGlvbkxheWVyPy5nZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHx8IG51bGw7XG4gIH1cbiAgc2V0QWN0aXZlRWRpdG9yKGVkaXRvcikge1xuICAgIGNvbnN0IGN1cnJlbnRBY3RpdmUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk7XG4gICAgaWYgKGN1cnJlbnRBY3RpdmUgPT09IGVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKGVkaXRvcik7XG4gIH1cbiAgZW5hYmxlVGV4dFNlbGVjdGlvbigpIHtcbiAgICB0aGlzLmRpdi50YWJJbmRleCA9IC0xO1xuICAgIGlmICh0aGlzLiN0ZXh0TGF5ZXI/LmRpdiAmJiAhdGhpcy4jdGV4dFNlbGVjdGlvbkFDKSB7XG4gICAgICB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jdGV4dFNlbGVjdGlvbkFDKTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI3RleHRMYXllclBvaW50ZXJEb3duLmJpbmQodGhpcyksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodGluZ1wiKTtcbiAgICB9XG4gIH1cbiAgZGlzYWJsZVRleHRTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAwO1xuICAgIGlmICh0aGlzLiN0ZXh0TGF5ZXI/LmRpdiAmJiB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMpIHtcbiAgICAgIHRoaXMuI3RleHRTZWxlY3Rpb25BQy5hYm9ydCgpO1xuICAgICAgdGhpcy4jdGV4dFNlbGVjdGlvbkFDID0gbnVsbDtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZ2hsaWdodGluZ1wiKTtcbiAgICB9XG4gIH1cbiAgI3RleHRMYXllclBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0QWxsKCk7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0XG4gICAgfSA9IGV2ZW50O1xuICAgIGlmICh0YXJnZXQgPT09IHRoaXMuI3RleHRMYXllci5kaXYgfHwgKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpID09PSBcImltZ1wiIHx8IHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJlbmRPZkNvbnRlbnRcIikpICYmIHRoaXMuI3RleHRMYXllci5kaXYuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc01hY1xuICAgICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHRydWUsIHRydWUpO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZVwiKTtcbiAgICAgIHRoaXMudG9nZ2xlRHJhd2luZygpO1xuICAgICAgSGlnaGxpZ2h0RWRpdG9yLnN0YXJ0SGlnaGxpZ2h0aW5nKHRoaXMsIHRoaXMuI3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIsIHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLiN0ZXh0TGF5ZXIuZGl2LFxuICAgICAgICB4OiBldmVudC54LFxuICAgICAgICB5OiBldmVudC55XG4gICAgICB9KTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LnJlbW92ZShcImZyZWVcIik7XG4gICAgICAgIHRoaXMudG9nZ2xlRHJhd2luZyh0cnVlKTtcbiAgICAgIH0sIHtcbiAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgc2lnbmFsOiB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgfSk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBlbmFibGVDbGljaygpIHtcbiAgICBpZiAodGhpcy4jY2xpY2tBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjbGlja0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNjbGlja0FDKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy5wb2ludGVyZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBwb2ludGVydXAgPSB0aGlzLnBvaW50ZXJ1cC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlcnVwLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBwb2ludGVydXAsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGRpc2FibGVDbGljaygpIHtcbiAgICB0aGlzLiNjbGlja0FDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2NsaWNrQUMgPSBudWxsO1xuICB9XG4gIGF0dGFjaChlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzLnNldChlZGl0b3IuaWQsIGVkaXRvcik7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZFxuICAgIH0gPSBlZGl0b3I7XG4gICAgaWYgKGFubm90YXRpb25FbGVtZW50SWQgJiYgdGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb25FbGVtZW50SWQpKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGRldGFjaChlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzLmRlbGV0ZShlZGl0b3IuaWQpO1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5yZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIoZWRpdG9yLmNvbnRlbnREaXYpO1xuICAgIGlmICghdGhpcy4jaXNEaXNhYmxpbmcgJiYgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKGVkaXRvcikge1xuICAgIHRoaXMuZGV0YWNoKGVkaXRvcik7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUVkaXRvcihlZGl0b3IpO1xuICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICB9XG4gIGNoYW5nZVBhcmVudChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWRpdG9yLnBhcmVudCAmJiBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yLmRlbGV0ZUFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgICBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG4gICAgZWRpdG9yLnBhcmVudD8uZGV0YWNoKGVkaXRvcik7XG4gICAgZWRpdG9yLnNldFBhcmVudCh0aGlzKTtcbiAgICBpZiAoZWRpdG9yLmRpdiAmJiBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGVkaXRvci5kaXYpO1xuICAgIH1cbiAgfVxuICBhZGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IHRoaXMgJiYgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICB0aGlzLmF0dGFjaChlZGl0b3IpO1xuICAgIGlmICghZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgY29uc3QgZGl2ID0gZWRpdG9yLnJlbmRlcigpO1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGRpdik7XG4gICAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gdHJ1ZTtcbiAgICB9XG4gICAgZWRpdG9yLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgZWRpdG9yLm9uY2VBZGRlZCghdGhpcy4jaXNFbmFibGluZyk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKTtcbiAgICBlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeShlZGl0b3IudGVsZW1ldHJ5SW5pdGlhbERhdGEpO1xuICB9XG4gIG1vdmVFZGl0b3JJbkRPTShlZGl0b3IpIHtcbiAgICBpZiAoIWVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlRWxlbWVudFxuICAgIH0gPSBkb2N1bWVudDtcbiAgICBpZiAoZWRpdG9yLmRpdi5jb250YWlucyhhY3RpdmVFbGVtZW50KSAmJiAhdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQpIHtcbiAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIGlmICghZWRpdG9yLmRpdi5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgIGVkaXRvci5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGVkaXRvci5fc3RydWN0VHJlZVBhcmVudElkID0gdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00odGhpcy5kaXYsIGVkaXRvci5kaXYsIGVkaXRvci5jb250ZW50RGl2LCB0cnVlKTtcbiAgfVxuICBhZGRPclJlYnVpbGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5uZWVkc1RvQmVSZWJ1aWx0KCkpIHtcbiAgICAgIGVkaXRvci5wYXJlbnQgfHw9IHRoaXM7XG4gICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgICAgZWRpdG9yLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgYWRkVW5kb2FibGVFZGl0b3IoZWRpdG9yKSB7XG4gICAgY29uc3QgY21kID0gKCkgPT4gZWRpdG9yLl91aU1hbmFnZXIucmVidWlsZChlZGl0b3IpO1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBnZXRFZGl0b3JCeVVJRCh1aWQpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLnVpZCA9PT0gdWlkKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldE5leHRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLmdldElkKCk7XG4gIH1cbiAgZ2V0ICNjdXJyZW50RWRpdG9yVHlwZSgpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy5nZXQodGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSk7XG4gIH1cbiAgY29tYmluZWRTaWduYWwoYWMpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgfVxuICAjY3JlYXRlTmV3RWRpdG9yKHBhcmFtcykge1xuICAgIGNvbnN0IGVkaXRvclR5cGUgPSB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZTtcbiAgICByZXR1cm4gZWRpdG9yVHlwZSA/IG5ldyBlZGl0b3JUeXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcihwYXJhbXMpIDogbnVsbDtcbiAgfVxuICBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudEVkaXRvclR5cGU/LmNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCk7XG4gIH1cbiAgYXN5bmMgcGFzdGVFZGl0b3Iob3B0aW9ucywgcGFyYW1zKSB7XG4gICAgdGhpcy51cGRhdGVUb29sYmFyKG9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuI3VpTWFuYWdlci51cGRhdGVNb2RlKG9wdGlvbnMubW9kZSk7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9ID0gdGhpcy4jZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlTmV3RWRpdG9yKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGlkLFxuICAgICAgeDogb2Zmc2V0WCxcbiAgICAgIHk6IG9mZnNldFksXG4gICAgICB1aU1hbmFnZXI6IHRoaXMuI3VpTWFuYWdlcixcbiAgICAgIGlzQ2VudGVyZWQ6IHRydWUsXG4gICAgICAuLi5wYXJhbXNcbiAgICB9KTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgcmV0dXJuIChhd2FpdCBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLmdldChkYXRhLmFubm90YXRpb25UeXBlID8/IGRhdGEuYW5ub3RhdGlvbkVkaXRvclR5cGUpPy5kZXNlcmlhbGl6ZShkYXRhLCB0aGlzLCB0aGlzLiN1aU1hbmFnZXIpKSB8fCBudWxsO1xuICB9XG4gIGNyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgaXNDZW50ZXJlZCwgZGF0YSA9IHt9KSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldE5leHRJZCgpO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2NyZWF0ZU5ld0VkaXRvcih7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBpZCxcbiAgICAgIHg6IGV2ZW50Lm9mZnNldFgsXG4gICAgICB5OiBldmVudC5vZmZzZXRZLFxuICAgICAgdWlNYW5hZ2VyOiB0aGlzLiN1aU1hbmFnZXIsXG4gICAgICBpc0NlbnRlcmVkLFxuICAgICAgLi4uZGF0YVxuICAgIH0pO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgZ2V0IGJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgI2dldENlbnRlclBvaW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy5ib3VuZGluZ0NsaWVudFJlY3Q7XG4gICAgY29uc3QgdGxYID0gTWF0aC5tYXgoMCwgeCk7XG4gICAgY29uc3QgdGxZID0gTWF0aC5tYXgoMCwgeSk7XG4gICAgY29uc3QgYnJYID0gTWF0aC5taW4od2luZG93LmlubmVyV2lkdGgsIHggKyB3aWR0aCk7XG4gICAgY29uc3QgYnJZID0gTWF0aC5taW4od2luZG93LmlubmVySGVpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBjb25zdCBjZW50ZXJYID0gKHRsWCArIGJyWCkgLyAyIC0geDtcbiAgICBjb25zdCBjZW50ZXJZID0gKHRsWSArIGJyWSkgLyAyIC0geTtcbiAgICBjb25zdCBbb2Zmc2V0WCwgb2Zmc2V0WV0gPSB0aGlzLnZpZXdwb3J0LnJvdGF0aW9uICUgMTgwID09PSAwID8gW2NlbnRlclgsIGNlbnRlclldIDogW2NlbnRlclksIGNlbnRlclhdO1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH07XG4gIH1cbiAgYWRkTmV3RWRpdG9yKGRhdGEgPSB7fSkge1xuICAgIHRoaXMuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHRoaXMuI2dldENlbnRlclBvaW50KCksIHRydWUsIGRhdGEpO1xuICB9XG4gIHNldFNlbGVjdGVkKGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRTZWxlY3RlZChlZGl0b3IpO1xuICB9XG4gIHRvZ2dsZVNlbGVjdGVkKGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci50b2dnbGVTZWxlY3RlZChlZGl0b3IpO1xuICB9XG4gIHVuc2VsZWN0KGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdChlZGl0b3IpO1xuICB9XG4gIHBvaW50ZXJ1cChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaGFkUG9pbnRlckRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICBpZiAodGhpcy4jY3VycmVudEVkaXRvclR5cGU/LmlzRHJhd2VyICYmIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLnN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jYWxsb3dDbGljaykge1xuICAgICAgdGhpcy4jYWxsb3dDbGljayA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRNb2RlID0gdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKTtcbiAgICBpZiAoY3VycmVudE1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QIHx8IGN1cnJlbnRNb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TSUdOQVRVUkUpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdEFsbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgZmFsc2UpO1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCkge1xuICAgICAgdGhpcy5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNoYWRQb2ludGVyRG93bikge1xuICAgICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSB0cnVlO1xuICAgIGlmICh0aGlzLiNjdXJyZW50RWRpdG9yVHlwZT8uaXNEcmF3ZXIpIHtcbiAgICAgIHRoaXMuc3RhcnREcmF3aW5nU2Vzc2lvbihldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKTtcbiAgICB0aGlzLiNhbGxvd0NsaWNrID0gIWVkaXRvciB8fCBlZGl0b3IuaXNFbXB0eSgpO1xuICB9XG4gIHN0YXJ0RHJhd2luZ1Nlc3Npb24oZXZlbnQpIHtcbiAgICB0aGlzLmRpdi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuI2RyYXdpbmdBQykge1xuICAgICAgdGhpcy4jY3VycmVudEVkaXRvclR5cGUuc3RhcnREcmF3aW5nKHRoaXMsIHRoaXMuI3VpTWFuYWdlciwgZmFsc2UsIGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEN1cnJlbnREcmF3aW5nU2Vzc2lvbih0aGlzKTtcbiAgICB0aGlzLiNkcmF3aW5nQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2RyYXdpbmdBQyk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgKHtcbiAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAocmVsYXRlZFRhcmdldCAmJiAhdGhpcy5kaXYuY29udGFpbnMocmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgdGhpcy4jZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy4jY3VycmVudEVkaXRvclR5cGUuc3RhcnREcmF3aW5nKHRoaXMsIHRoaXMuI3VpTWFuYWdlciwgZmFsc2UsIGV2ZW50KTtcbiAgfVxuICBwYXVzZShvbikge1xuICAgIGlmIChvbikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3RpdmVFbGVtZW50XG4gICAgICB9ID0gZG9jdW1lbnQ7XG4gICAgICBpZiAodGhpcy5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy4jZm9jdXNlZEVsZW1lbnQgPSBhY3RpdmVFbGVtZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jZm9jdXNlZEVsZW1lbnQpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiNmb2N1c2VkRWxlbWVudD8uZm9jdXMoKTtcbiAgICAgICAgdGhpcy4jZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG4gIGVuZERyYXdpbmdTZXNzaW9uKGlzQWJvcnRlZCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0Q3VycmVudERyYXdpbmdTZXNzaW9uKG51bGwpO1xuICAgIHRoaXMuI2RyYXdpbmdBQy5hYm9ydCgpO1xuICAgIHRoaXMuI2RyYXdpbmdBQyA9IG51bGw7XG4gICAgdGhpcy4jZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5lbmREcmF3aW5nKGlzQWJvcnRlZCk7XG4gIH1cbiAgZmluZE5ld1BhcmVudChlZGl0b3IsIHgsIHkpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI3VpTWFuYWdlci5maW5kUGFyZW50KHgsIHkpO1xuICAgIGlmIChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsYXllci5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy4jZHJhd2luZ0FDKSB7XG4gICAgICB0aGlzLmVuZERyYXdpbmdTZXNzaW9uKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBpZiAoIXRoaXMuI2RyYXdpbmdBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5vblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZyh0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpPy5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5jb21taXRPclJlbW92ZSgpO1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnNldEFjdGl2ZUVkaXRvcihudWxsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ucmVtb3ZlUG9pbnRlckluVGV4dExheWVyKGVkaXRvci5jb250ZW50RGl2KTtcbiAgICAgIGVkaXRvci5zZXRQYXJlbnQobnVsbCk7XG4gICAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgdGhpcy4jZWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVMYXllcih0aGlzKTtcbiAgfVxuICAjY2xlYW51cCgpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbmRlcih7XG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICBzZXRMYXllckRpbWVuc2lvbnModGhpcy5kaXYsIHZpZXdwb3J0KTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiN1aU1hbmFnZXIuZ2V0RWRpdG9ycyh0aGlzLnBhZ2VJbmRleCkpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZU1vZGUoKTtcbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgY29uc3Qgb2xkUm90YXRpb24gPSB0aGlzLnZpZXdwb3J0LnJvdGF0aW9uO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdmlld3BvcnQucm90YXRpb247XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHNldExheWVyRGltZW5zaW9ucyh0aGlzLmRpdiwge1xuICAgICAgcm90YXRpb25cbiAgICB9KTtcbiAgICBpZiAob2xkUm90YXRpb24gIT09IHJvdGF0aW9uKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5yb3RhdGUocm90YXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcGFnZURpbWVuc2lvbnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB0aGlzLnZpZXdwb3J0LnJhd0RpbXM7XG4gICAgcmV0dXJuIFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdO1xuICB9XG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9kcmF3X2xheWVyLmpzXG5cblxuY2xhc3MgRHJhd0xheWVyIHtcbiAgI3BhcmVudCA9IG51bGw7XG4gICNtYXBwaW5nID0gbmV3IE1hcCgpO1xuICAjdG9VcGRhdGUgPSBuZXcgTWFwKCk7XG4gIHN0YXRpYyAjaWQgPSAwO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFnZUluZGV4XG4gIH0pIHtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgaWYgKCF0aGlzLiNwYXJlbnQpIHtcbiAgICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BhcmVudCAhPT0gcGFyZW50KSB7XG4gICAgICBpZiAodGhpcy4jbWFwcGluZy5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvb3Qgb2YgdGhpcy4jbWFwcGluZy52YWx1ZXMoKSkge1xuICAgICAgICAgIHJvb3QucmVtb3ZlKCk7XG4gICAgICAgICAgcGFyZW50LmFwcGVuZChyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IF9zdmdGYWN0b3J5KCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfc3ZnRmFjdG9yeVwiLCBuZXcgRE9NU1ZHRmFjdG9yeSgpKTtcbiAgfVxuICBzdGF0aWMgI3NldEJveChlbGVtZW50LCBbeCwgeSwgd2lkdGgsIGhlaWdodF0pIHtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBlbGVtZW50O1xuICAgIHN0eWxlLnRvcCA9IGAkezEwMCAqIHl9JWA7XG4gICAgc3R5bGUubGVmdCA9IGAkezEwMCAqIHh9JWA7XG4gICAgc3R5bGUud2lkdGggPSBgJHsxMDAgKiB3aWR0aH0lYDtcbiAgICBzdHlsZS5oZWlnaHQgPSBgJHsxMDAgKiBoZWlnaHR9JWA7XG4gIH1cbiAgI2NyZWF0ZVNWRygpIHtcbiAgICBjb25zdCBzdmcgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlKDEsIDEsIHRydWUpO1xuICAgIHRoaXMuI3BhcmVudC5hcHBlbmQoc3ZnKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuICAjY3JlYXRlQ2xpcFBhdGgoZGVmcywgcGF0aElkKSB7XG4gICAgY29uc3QgY2xpcFBhdGggPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpO1xuICAgIGRlZnMuYXBwZW5kKGNsaXBQYXRoKTtcbiAgICBjb25zdCBjbGlwUGF0aElkID0gYGNsaXBfJHtwYXRoSWR9YDtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBjbGlwUGF0aElkKTtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJjbGlwUGF0aFVuaXRzXCIsIFwib2JqZWN0Qm91bmRpbmdCb3hcIik7XG4gICAgY29uc3QgY2xpcFBhdGhVc2UgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICBjbGlwUGF0aC5hcHBlbmQoY2xpcFBhdGhVc2UpO1xuICAgIGNsaXBQYXRoVXNlLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3BhdGhJZH1gKTtcbiAgICBjbGlwUGF0aFVzZS5jbGFzc0xpc3QuYWRkKFwiY2xpcFwiKTtcbiAgICByZXR1cm4gY2xpcFBhdGhJZDtcbiAgfVxuICAjdXBkYXRlUHJvcGVydGllcyhlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXcocHJvcGVydGllcywgaXNQYXRoVXBkYXRhYmxlID0gZmFsc2UsIGhhc0NsaXAgPSBmYWxzZSkge1xuICAgIGNvbnN0IGlkID0gRHJhd0xheWVyLiNpZCsrO1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLiNjcmVhdGVTVkcoKTtcbiAgICBjb25zdCBkZWZzID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpO1xuICAgIHJvb3QuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IHBhdGggPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInBhdGhcIik7XG4gICAgZGVmcy5hcHBlbmQocGF0aCk7XG4gICAgY29uc3QgcGF0aElkID0gYHBhdGhfcCR7dGhpcy5wYWdlSW5kZXh9XyR7aWR9YDtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIHBhdGhJZCk7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJ2ZWN0b3ItZWZmZWN0XCIsIFwibm9uLXNjYWxpbmctc3Ryb2tlXCIpO1xuICAgIGlmIChpc1BhdGhVcGRhdGFibGUpIHtcbiAgICAgIHRoaXMuI3RvVXBkYXRlLnNldChpZCwgcGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IGNsaXBQYXRoSWQgPSBoYXNDbGlwID8gdGhpcy4jY3JlYXRlQ2xpcFBhdGgoZGVmcywgcGF0aElkKSA6IG51bGw7XG4gICAgY29uc3QgdXNlID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIik7XG4gICAgcm9vdC5hcHBlbmQodXNlKTtcbiAgICB1c2Uuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIHRoaXMudXBkYXRlUHJvcGVydGllcyhyb290LCBwcm9wZXJ0aWVzKTtcbiAgICB0aGlzLiNtYXBwaW5nLnNldChpZCwgcm9vdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkLFxuICAgICAgY2xpcFBhdGhJZDogYHVybCgjJHtjbGlwUGF0aElkfSlgXG4gICAgfTtcbiAgfVxuICBkcmF3T3V0bGluZShwcm9wZXJ0aWVzLCBtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMpIHtcbiAgICBjb25zdCBpZCA9IERyYXdMYXllci4jaWQrKztcbiAgICBjb25zdCByb290ID0gdGhpcy4jY3JlYXRlU1ZHKCk7XG4gICAgY29uc3QgZGVmcyA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICByb290LmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBwYXRoID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpO1xuICAgIGRlZnMuYXBwZW5kKHBhdGgpO1xuICAgIGNvbnN0IHBhdGhJZCA9IGBwYXRoX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBwYXRoSWQpO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwidmVjdG9yLWVmZmVjdFwiLCBcIm5vbi1zY2FsaW5nLXN0cm9rZVwiKTtcbiAgICBsZXQgbWFza0lkO1xuICAgIGlmIChtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMpIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcIm1hc2tcIik7XG4gICAgICBkZWZzLmFwcGVuZChtYXNrKTtcbiAgICAgIG1hc2tJZCA9IGBtYXNrX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZShcImlkXCIsIG1hc2tJZCk7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZShcIm1hc2tVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgICAgY29uc3QgcmVjdCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicmVjdFwiKTtcbiAgICAgIG1hc2suYXBwZW5kKHJlY3QpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjFcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjFcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ3aGl0ZVwiKTtcbiAgICAgIGNvbnN0IHVzZSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgICAgbWFzay5hcHBlbmQodXNlKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwibm9uZVwiKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwiYmxhY2tcIik7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwiZmlsbC1ydWxlXCIsIFwibm9uemVyb1wiKTtcbiAgICAgIHVzZS5jbGFzc0xpc3QuYWRkKFwibWFza1wiKTtcbiAgICB9XG4gICAgY29uc3QgdXNlMSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgIHJvb3QuYXBwZW5kKHVzZTEpO1xuICAgIHVzZTEuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIGlmIChtYXNrSWQpIHtcbiAgICAgIHVzZTEuc2V0QXR0cmlidXRlKFwibWFza1wiLCBgdXJsKCMke21hc2tJZH0pYCk7XG4gICAgfVxuICAgIGNvbnN0IHVzZTIgPSB1c2UxLmNsb25lTm9kZSgpO1xuICAgIHJvb3QuYXBwZW5kKHVzZTIpO1xuICAgIHVzZTEuY2xhc3NMaXN0LmFkZChcIm1haW5PdXRsaW5lXCIpO1xuICAgIHVzZTIuY2xhc3NMaXN0LmFkZChcInNlY29uZGFyeU91dGxpbmVcIik7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKHJvb3QsIHByb3BlcnRpZXMpO1xuICAgIHRoaXMuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgZmluYWxpemVEcmF3KGlkLCBwcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy4jdG9VcGRhdGUuZGVsZXRlKGlkKTtcbiAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMoaWQsIHByb3BlcnRpZXMpO1xuICB9XG4gIHVwZGF0ZVByb3BlcnRpZXMoZWxlbWVudE9ySWQsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcm9vdCxcbiAgICAgIGJib3gsXG4gICAgICByb290Q2xhc3MsXG4gICAgICBwYXRoXG4gICAgfSA9IHByb3BlcnRpZXM7XG4gICAgY29uc3QgZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50T3JJZCA9PT0gXCJudW1iZXJcIiA/IHRoaXMuI21hcHBpbmcuZ2V0KGVsZW1lbnRPcklkKSA6IGVsZW1lbnRPcklkO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocm9vdCkge1xuICAgICAgdGhpcy4jdXBkYXRlUHJvcGVydGllcyhlbGVtZW50LCByb290KTtcbiAgICB9XG4gICAgaWYgKGJib3gpIHtcbiAgICAgIERyYXdMYXllci4jc2V0Qm94KGVsZW1lbnQsIGJib3gpO1xuICAgIH1cbiAgICBpZiAocm9vdENsYXNzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsYXNzTGlzdFxuICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICBmb3IgKGNvbnN0IFtjbGFzc05hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyb290Q2xhc3MpKSB7XG4gICAgICAgIGNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXRoKSB7XG4gICAgICBjb25zdCBkZWZzID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgY29uc3QgcGF0aEVsZW1lbnQgPSBkZWZzLmZpcnN0Q2hpbGQ7XG4gICAgICB0aGlzLiN1cGRhdGVQcm9wZXJ0aWVzKHBhdGhFbGVtZW50LCBwYXRoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyZW50KGlkLCBsYXllcikge1xuICAgIGlmIChsYXllciA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290ID0gdGhpcy4jbWFwcGluZy5nZXQoaWQpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXllci4jcGFyZW50LmFwcGVuZChyb290KTtcbiAgICB0aGlzLiNtYXBwaW5nLmRlbGV0ZShpZCk7XG4gICAgbGF5ZXIuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgfVxuICByZW1vdmUoaWQpIHtcbiAgICB0aGlzLiN0b1VwZGF0ZS5kZWxldGUoaWQpO1xuICAgIGlmICh0aGlzLiNwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jbWFwcGluZy5nZXQoaWQpLnJlbW92ZSgpO1xuICAgIHRoaXMuI21hcHBpbmcuZGVsZXRlKGlkKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI3BhcmVudCA9IG51bGw7XG4gICAgZm9yIChjb25zdCByb290IG9mIHRoaXMuI21hcHBpbmcudmFsdWVzKCkpIHtcbiAgICAgIHJvb3QucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuI21hcHBpbmcuY2xlYXIoKTtcbiAgICB0aGlzLiN0b1VwZGF0ZS5jbGVhcigpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9wZGYuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxue1xuICBnbG9iYWxUaGlzLl9wZGZqc1Rlc3RpbmdVdGlscyA9IHtcbiAgICBIaWdobGlnaHRPdXRsaW5lcjogSGlnaGxpZ2h0T3V0bGluZXJcbiAgfTtcbn1cbmdsb2JhbFRoaXMucGRmanNMaWIgPSB7XG4gIEFib3J0RXhjZXB0aW9uOiBBYm9ydEV4Y2VwdGlvbixcbiAgQW5ub3RhdGlvbkVkaXRvckxheWVyOiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIsXG4gIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSxcbiAgQW5ub3RhdGlvbkVkaXRvclR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLFxuICBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyOiBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLFxuICBBbm5vdGF0aW9uTGF5ZXI6IEFubm90YXRpb25MYXllcixcbiAgQW5ub3RhdGlvbk1vZGU6IEFubm90YXRpb25Nb2RlLFxuICBBbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvblR5cGUsXG4gIGFwcGx5T3BhY2l0eTogYXBwbHlPcGFjaXR5LFxuICBidWlsZDogYnVpbGQsXG4gIENvbG9yUGlja2VyOiBDb2xvclBpY2tlcixcbiAgY3JlYXRlVmFsaWRBYnNvbHV0ZVVybDogY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCxcbiAgQ1NTQ29uc3RhbnRzOiBDU1NDb25zdGFudHMsXG4gIERPTVNWR0ZhY3Rvcnk6IERPTVNWR0ZhY3RvcnksXG4gIERyYXdMYXllcjogRHJhd0xheWVyLFxuICBGZWF0dXJlVGVzdDogdXRpbF9GZWF0dXJlVGVzdCxcbiAgZmV0Y2hEYXRhOiBmZXRjaERhdGEsXG4gIGZpbmRDb250cmFzdENvbG9yOiBmaW5kQ29udHJhc3RDb2xvcixcbiAgZ2V0RG9jdW1lbnQ6IGdldERvY3VtZW50LFxuICBnZXRGaWxlbmFtZUZyb21Vcmw6IGdldEZpbGVuYW1lRnJvbVVybCxcbiAgZ2V0UGRmRmlsZW5hbWVGcm9tVXJsOiBnZXRQZGZGaWxlbmFtZUZyb21VcmwsXG4gIGdldFJHQjogZ2V0UkdCLFxuICBnZXRVdWlkOiBnZXRVdWlkLFxuICBnZXRYZmFQYWdlVmlld3BvcnQ6IGdldFhmYVBhZ2VWaWV3cG9ydCxcbiAgR2xvYmFsV29ya2VyT3B0aW9uczogR2xvYmFsV29ya2VyT3B0aW9ucyxcbiAgSW1hZ2VLaW5kOiB1dGlsX0ltYWdlS2luZCxcbiAgSW52YWxpZFBERkV4Y2VwdGlvbjogSW52YWxpZFBERkV4Y2VwdGlvbixcbiAgaXNEYXRhU2NoZW1lOiBpc0RhdGFTY2hlbWUsXG4gIGlzUGRmRmlsZTogaXNQZGZGaWxlLFxuICBpc1ZhbGlkRXhwbGljaXREZXN0OiBpc1ZhbGlkRXhwbGljaXREZXN0LFxuICBNYXRoQ2xhbXA6IE1hdGhDbGFtcCxcbiAgbm9Db250ZXh0TWVudTogbm9Db250ZXh0TWVudSxcbiAgbm9ybWFsaXplVW5pY29kZTogbm9ybWFsaXplVW5pY29kZSxcbiAgT1BTOiBPUFMsXG4gIE91dHB1dFNjYWxlOiBPdXRwdXRTY2FsZSxcbiAgUGFzc3dvcmRSZXNwb25zZXM6IFBhc3N3b3JkUmVzcG9uc2VzLFxuICBQREZEYXRhUmFuZ2VUcmFuc3BvcnQ6IFBERkRhdGFSYW5nZVRyYW5zcG9ydCxcbiAgUERGRGF0ZVN0cmluZzogUERGRGF0ZVN0cmluZyxcbiAgUERGV29ya2VyOiBQREZXb3JrZXIsXG4gIFBlcm1pc3Npb25GbGFnOiBQZXJtaXNzaW9uRmxhZyxcbiAgUGl4ZWxzUGVySW5jaDogUGl4ZWxzUGVySW5jaCxcbiAgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uOiBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24sXG4gIHJlbmRlclJpY2hUZXh0OiByZW5kZXJSaWNoVGV4dCxcbiAgUmVzcG9uc2VFeGNlcHRpb246IFJlc3BvbnNlRXhjZXB0aW9uLFxuICBzZXRMYXllckRpbWVuc2lvbnM6IHNldExheWVyRGltZW5zaW9ucyxcbiAgc2hhZG93OiBzaGFkb3csXG4gIFNpZ25hdHVyZUV4dHJhY3RvcjogU2lnbmF0dXJlRXh0cmFjdG9yLFxuICBzdG9wRXZlbnQ6IHN0b3BFdmVudCxcbiAgU3VwcG9ydGVkSW1hZ2VNaW1lVHlwZXM6IFN1cHBvcnRlZEltYWdlTWltZVR5cGVzLFxuICBUZXh0TGF5ZXI6IFRleHRMYXllcixcbiAgVG91Y2hNYW5hZ2VyOiBUb3VjaE1hbmFnZXIsXG4gIHVwZGF0ZVVybEhhc2g6IHVwZGF0ZVVybEhhc2gsXG4gIFV0aWw6IFV0aWwsXG4gIFZlcmJvc2l0eUxldmVsOiBWZXJib3NpdHlMZXZlbCxcbiAgdmVyc2lvbjogdmVyc2lvbixcbiAgWGZhTGF5ZXI6IFhmYUxheWVyXG59O1xuXG5leHBvcnQgeyBBYm9ydEV4Y2VwdGlvbiwgQW5ub3RhdGlvbkVkaXRvckxheWVyLCBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSwgQW5ub3RhdGlvbkVkaXRvclR5cGUsIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIsIEFubm90YXRpb25MYXllciwgQW5ub3RhdGlvbk1vZGUsIEFubm90YXRpb25UeXBlLCBDU1NDb25zdGFudHMsIENvbG9yUGlja2VyLCBET01TVkdGYWN0b3J5LCBEcmF3TGF5ZXIsIHV0aWxfRmVhdHVyZVRlc3QgYXMgRmVhdHVyZVRlc3QsIEdsb2JhbFdvcmtlck9wdGlvbnMsIHV0aWxfSW1hZ2VLaW5kIGFzIEltYWdlS2luZCwgSW52YWxpZFBERkV4Y2VwdGlvbiwgTWF0aENsYW1wLCBPUFMsIE91dHB1dFNjYWxlLCBQREZEYXRhUmFuZ2VUcmFuc3BvcnQsIFBERkRhdGVTdHJpbmcsIFBERldvcmtlciwgUGFzc3dvcmRSZXNwb25zZXMsIFBlcm1pc3Npb25GbGFnLCBQaXhlbHNQZXJJbmNoLCBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24sIFJlc3BvbnNlRXhjZXB0aW9uLCBTaWduYXR1cmVFeHRyYWN0b3IsIFN1cHBvcnRlZEltYWdlTWltZVR5cGVzLCBUZXh0TGF5ZXIsIFRvdWNoTWFuYWdlciwgVXRpbCwgVmVyYm9zaXR5TGV2ZWwsIFhmYUxheWVyLCBhcHBseU9wYWNpdHksIGJ1aWxkLCBjcmVhdGVWYWxpZEFic29sdXRlVXJsLCBmZXRjaERhdGEsIGZpbmRDb250cmFzdENvbG9yLCBnZXREb2N1bWVudCwgZ2V0RmlsZW5hbWVGcm9tVXJsLCBnZXRQZGZGaWxlbmFtZUZyb21VcmwsIGdldFJHQiwgZ2V0VXVpZCwgZ2V0WGZhUGFnZVZpZXdwb3J0LCBpc0RhdGFTY2hlbWUsIGlzUGRmRmlsZSwgaXNWYWxpZEV4cGxpY2l0RGVzdCwgbm9Db250ZXh0TWVudSwgbm9ybWFsaXplVW5pY29kZSwgcmVuZGVyUmljaFRleHQsIHNldExheWVyRGltZW5zaW9ucywgc2hhZG93LCBzdG9wRXZlbnQsIHVwZGF0ZVVybEhhc2gsIHZlcnNpb24gfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGRmLm1qcy5tYXAiXSwibmFtZXMiOlsiX193ZWJwYWNrX21vZHVsZXNfXyIsIm1vZHVsZSIsIl9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJpc0NhbGxhYmxlIiwiZXhwb3J0cyIsIml0IiwiY2FsbCIsImFDYWxsYWJsZSIsImFuT2JqZWN0IiwidHJ5VG9TdHJpbmciLCJnZXRJdGVyYXRvck1ldGhvZCIsIiRUeXBlRXJyb3IiLCJUeXBlRXJyb3IiLCJhcmd1bWVudCIsInVzaW5nSXRlcmF0b3IiLCJpdGVyYXRvck1ldGhvZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsIl9fdW51c2VkX3dlYnBhY2tfbW9kdWxlIiwiJCIsIml0ZXJhdGUiLCJnZXRJdGVyYXRvckRpcmVjdCIsIml0ZXJhdG9yQ2xvc2UiLCJpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIiwiZmluZFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIiwidGFyZ2V0IiwicHJvdG8iLCJyZWFsIiwiZm9yY2VkIiwiZmluZCIsInByZWRpY2F0ZSIsImVycm9yIiwicmVjb3JkIiwiY291bnRlciIsInZhbHVlIiwic3RvcCIsIklTX1JFQ09SRCIsIklOVEVSUlVQVEVEIiwicmVzdWx0IiwidW5jdXJyeVRoaXMiLCJmYWlscyIsImhhc093biIsIkRFU0NSSVBUT1JTIiwiQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUiLCJDT05GSUdVUkFCTEUiLCJpbnNwZWN0U291cmNlIiwiSW50ZXJuYWxTdGF0ZU1vZHVsZSIsImVuZm9yY2VJbnRlcm5hbFN0YXRlIiwiZW5mb3JjZSIsImdldEludGVybmFsU3RhdGUiLCJnZXQiLCIkU3RyaW5nIiwiU3RyaW5nIiwiZGVmaW5lUHJvcGVydHkiLCJPYmplY3QiLCJzdHJpbmdTbGljZSIsInNsaWNlIiwicmVwbGFjZSIsImpvaW4iLCJDT05GSUdVUkFCTEVfTEVOR1RIIiwiVEVNUExBVEUiLCJzcGxpdCIsIm1ha2VCdWlsdEluIiwibmFtZSIsIm9wdGlvbnMiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJjb25maWd1cmFibGUiLCJhcml0eSIsImNvbnN0cnVjdG9yIiwid3JpdGFibGUiLCJwcm90b3R5cGUiLCJ1bmRlZmluZWQiLCJzdGF0ZSIsInNvdXJjZSIsIkZ1bmN0aW9uIiwidG9TdHJpbmciLCJGdW5jdGlvblByb3RvdHlwZSIsImdldERlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJFWElTVFMiLCJQUk9QRVIiLCJzb21ldGhpbmciLCJnZXRCdWlsdEluIiwiZ2xvYmFsVGhpcyIsImFuVWludDhBcnJheSIsIm5vdERldGFjaGVkIiwibnVtYmVyVG9TdHJpbmciLCJVaW50OEFycmF5IiwiSU5DT1JSRUNUX0JFSEFWSU9SX09SX0RPRVNOVF9FWElTVFMiLCJ0b0hleCIsImJ1ZmZlciIsImkiLCJoZXgiLCJmbiIsIklURVJBVE9SX0lOU1RFQURfT0ZfUkVDT1JEIiwiaXRlcmF0b3IiLCJuZXh0Iiwic3RlcCIsImRvbmUiLCJnZXRJdGVyYXRvckZsYXR0ZW5hYmxlIiwiY3JlYXRlSXRlcmF0b3JQcm94eSIsIklTX1BVUkUiLCJpdGVyYXRvckhlbHBlclRocm93c09uSW52YWxpZEl0ZXJhdG9yIiwiRkxBVF9NQVBfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SIiwiZmxhdE1hcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIiwiRk9SQ0VEIiwiSXRlcmF0b3JQcm94eSIsIm1hcHBlciIsImlubmVyIiwiZmxhdE1hcCIsInRlc3QiLCJiaW5kIiwiaGFzT3duUHJvcGVydHkiLCJjbGFzc29mIiwiaXNQcm90b3R5cGVPZiIsIlByb3RvdHlwZSIsIm1ldGhvZE5hbWUiLCJtZXRob2QiLCJJdGVyYXRvciIsImNlaWwiLCJNYXRoIiwiZmxvb3IiLCJ0cnVuYyIsIngiLCJuIiwiVVNFX1NZTUJPTF9BU19VSUQiLCIkT2JqZWN0IiwiJFN5bWJvbCIsImdldE1ldGhvZCIsImlzTnVsbE9yVW5kZWZpbmVkIiwiSXRlcmF0b3JzIiwid2VsbEtub3duU3ltYm9sIiwiSVRFUkFUT1IiLCJhbHBoYWJldCIsImludGVybmFsT2JqZWN0S2V5cyIsImVudW1CdWdLZXlzIiwia2V5cyIsIk8iLCJleGVjIiwia2xhc3MiLCJldmVyeVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIiwiZXZlcnkiLCJzdG9wcGVkIiwiTkFUSVZFX1dFQUtfTUFQIiwiaXNPYmplY3QiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkiLCJzaGFyZWQiLCJzaGFyZWRLZXkiLCJoaWRkZW5LZXlzIiwiT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQiLCJXZWFrTWFwIiwic2V0IiwiaGFzIiwiZ2V0dGVyRm9yIiwiVFlQRSIsInR5cGUiLCJzdG9yZSIsIm1ldGFkYXRhIiwiZmFjYWRlIiwiU1RBVEUiLCJudW1iZXIiLCJpdGVycyIsImtpbmQiLCJWOCIsIkVOVklST05NRU5UIiwic3RydWN0dXJlZENsb25lIiwiQXJyYXlCdWZmZXIiLCJjbG9uZSIsInRyYW5zZmVyIiwiYnl0ZUxlbmd0aCIsImFwcGx5IiwibmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUiLCJwZXJmb3JtIiwiUHJvbWlzZSIsIkFDQ0VQVF9BUkdVTUVOVFMiLCJzdGF0IiwiY2FsbGJhY2tmbiIsImFyZ3MiLCJwcm9taXNlQ2FwYWJpbGl0eSIsImYiLCJyZWplY3QiLCJyZXNvbHZlIiwicHJvbWlzZSIsInVuaW9uIiwic2V0TWV0aG9kR2V0S2V5c0JlZm9yZUNsb25pbmciLCJzZXRNZXRob2RBY2NlcHRTZXRMaWtlIiwiY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyIsIk1BUF9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1IiLCJtYXBXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciIsIm1hcCIsIm9iaiIsInRvSW5kZXhlZE9iamVjdCIsImluZGV4T2YiLCJwdXNoIiwib2JqZWN0IiwibmFtZXMiLCJrZXkiLCJkZXNjcmlwdG9yIiwiVE9fU1RSSU5HX1RBRyIsIkYiLCJnZXRQcm90b3R5cGVPZiIsIlN5bnRheEVycm9yIiwicGFyc2VJbnQiLCJtaW4iLCJOT1RfSEVYIiwic3RyaW5nIiwiaW50byIsInN0cmluZ0xlbmd0aCIsIm1heExlbmd0aCIsImJ5dGVzIiwicmVhZCIsIndyaXR0ZW4iLCJoZXhpdHMiLCJkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlIiwiaHRtbCIsImRvY3VtZW50Q3JlYXRlRWxlbWVudCIsIkdUIiwiTFQiLCJQUk9UT1RZUEUiLCJTQ1JJUFQiLCJJRV9QUk9UTyIsIkVtcHR5Q29uc3RydWN0b3IiLCJzY3JpcHRUYWciLCJjb250ZW50IiwiTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCIsImFjdGl2ZVhEb2N1bWVudCIsIndyaXRlIiwiY2xvc2UiLCJ0ZW1wIiwicGFyZW50V2luZG93IiwiTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lIiwiaWZyYW1lIiwiSlMiLCJpZnJhbWVEb2N1bWVudCIsInN0eWxlIiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwic3JjIiwiY29udGVudFdpbmRvdyIsImRvY3VtZW50Iiwib3BlbiIsIk51bGxQcm90b09iamVjdCIsIkFjdGl2ZVhPYmplY3QiLCJkb21haW4iLCJjcmVhdGUiLCJQcm9wZXJ0aWVzIiwiaXNTdXBlcnNldE9mIiwiSU5DT1JSRUNUIiwiRklMVEVSX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiIsImZpbHRlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIiwiZmlsdGVyIiwiJGRlZmF1bHQiLCJpc0FycmF5SXRlcmF0b3JNZXRob2QiLCJsZW5ndGhPZkFycmF5TGlrZSIsImdldEl0ZXJhdG9yIiwiUmVzdWx0IiwiUmVzdWx0UHJvdG90eXBlIiwiaXRlcmFibGUiLCJ1bmJvdW5kRnVuY3Rpb24iLCJ0aGF0IiwiQVNfRU5UUklFUyIsIklTX0lURVJBVE9SIiwiaXRlckZuIiwiaW5kZXgiLCJjb25kaXRpb24iLCJjYWxsRm4iLCJpc1N5bWJvbCIsIm9yZGluYXJ5VG9QcmltaXRpdmUiLCJUT19QUklNSVRJVkUiLCJpbnB1dCIsInByZWYiLCJleG90aWNUb1ByaW0iLCJ0b09iamVjdCIsIkNPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiIsIk9iamVjdFByb3RvdHlwZSIsInJlcGxhY2VtZW50IiwiaXNGb3JjZWQiLCJmZWF0dXJlIiwiZGV0ZWN0aW9uIiwiZGF0YSIsIm5vcm1hbGl6ZSIsIlBPTFlGSUxMIiwiTkFUSVZFIiwidG9Mb3dlckNhc2UiLCJjb21tb25BbHBoYWJldCIsImJhc2U2NEFscGhhYmV0IiwiYmFzZTY0VXJsQWxwaGFiZXQiLCJpbnZlcnNlIiwiY2hhcmFjdGVycyIsImNoYXJBdCIsImkyYyIsImMyaSIsImkyY1VybCIsImMyaVVybCIsInBhc3NlZCIsInJlcXVpcmVkIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidW5jdXJyeVRoaXNBY2Nlc3NvciIsInJlcXVpcmVPYmplY3RDb2VyY2libGUiLCJhUG9zc2libGVQcm90b3R5cGUiLCJzZXRQcm90b3R5cGVPZiIsIkNPUlJFQ1RfU0VUVEVSIiwiQXJyYXkiLCJfX3Byb3RvX18iLCIkUmFuZ2VFcnJvciIsIlJhbmdlRXJyb3IiLCIkSW5maW5pdHkiLCJJbmZpbml0eSIsIiROYU4iLCJOYU4iLCJhYnMiLCJwb3ciLCJQT1dfMl8xMDIzIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1BWF9ET1VCTEUiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJNQVhfVUxQIiwiTk9UX0FfTlVNQkVSIiwiTUlOVVNfSU5GSU5JVFkiLCJQTFVTX0lORklOSVRZIiwiTUlOVVNfWkVSTyIsIkZJTklURSIsInR3b3N1bSIsInkiLCJoaSIsImxvIiwic3VtUHJlY2lzZSIsIml0ZW1zIiwibnVtYmVycyIsImNvdW50IiwicGFydGlhbHMiLCJvdmVyZmxvdyIsInN1bSIsInRtcCIsImFjdHVhbGx5VXNlZFBhcnRpYWxzIiwiaiIsInNpZ24iLCIkdGhpcyIsImR1bW15IiwiV3JhcHBlciIsIk5ld1RhcmdldCIsIk5ld1RhcmdldFByb3RvdHlwZSIsIk5BVElWRV9BUlJBWV9CVUZGRVIiLCJhcnJheUJ1ZmZlckJ5dGVMZW5ndGgiLCJEYXRhVmlldyIsImlkIiwicG9zdGZpeCIsInJhbmRvbSIsImFTZXQiLCJTZXRIZWxwZXJzIiwic2l6ZSIsImdldFNldFJlY29yZCIsIml0ZXJhdGVTZXQiLCJpdGVyYXRlU2ltcGxlIiwicmVtb3ZlIiwiZGlmZmVyZW5jZSIsIm90aGVyIiwib3RoZXJSZWMiLCJlIiwiaW5jbHVkZXMiLCJpc1Bvc3NpYmxlUHJvdG90eXBlIiwic29tZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIiwic29tZSIsImFkZCIsInN5bW1ldHJpY0RpZmZlcmVuY2UiLCJrZXlzSXRlciIsImZ1bmN0aW9uVG9TdHJpbmciLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJ0b0ludGVnZXJPckluZmluaXR5IiwiSU5WQUxJRF9TSVpFIiwibWF4IiwiU2V0UmVjb3JkIiwiaW50U2l6ZSIsIm51bVNpemUiLCJpc1N1YnNldE9mIiwiaXNEaXNqb2ludEZyb20iLCJjcmVhdGVFbGVtZW50Iiwic2V0QXJyYXlMZW5ndGgiLCJkb2VzTm90RXhjZWVkU2FmZUludGVnZXIiLCJJTkNPUlJFQ1RfVE9fTEVOR1RIIiwicHJvcGVyRXJyb3JPbk5vbldyaXRhYmxlTGVuZ3RoIiwiaXRlbSIsImxlbiIsImFyZ0NvdW50IiwiQXJyYXlQcm90b3R5cGUiLCJ1c2VyQWdlbnRTdGFydHNXaXRoIiwiQnVuIiwidmVyc2lvbiIsIkRlbm8iLCJwcm9jZXNzIiwid2luZG93IiwiYVN0cmluZyIsIiRmcm9tSGV4Iiwic2V0RnJvbUhleCIsInZhbCIsInZhbHVlT2YiLCJpc0FycmF5IiwiU2V0UHJvdG90eXBlIiwiU2V0IiwiZ2V0QnVpbHRJbk5vZGVNb2R1bGUiLCJQUk9QRVJfU1RSVUNUVVJFRF9DTE9ORV9UUkFOU0ZFUiIsIiRBcnJheUJ1ZmZlciIsIiRNZXNzYWdlQ2hhbm5lbCIsIk1lc3NhZ2VDaGFubmVsIiwiZGV0YWNoIiwiV29ya2VyVGhyZWFkcyIsImNoYW5uZWwiLCIkZGV0YWNoIiwidHJhbnNmZXJhYmxlIiwicG9ydDEiLCJwb3N0TWVzc2FnZSIsIlY4X1ZFUlNJT04iLCJzeW1ib2wiLCJTeW1ib2wiLCJzaGFtIiwiU0lMRU5UX09OX05PTl9XUklUQUJMRV9MRU5HVEhfU0VUIiwiTUVUSE9EX05BTUUiLCJFeHBlY3RlZEVycm9yIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJDTE9TRUQiLCJjaGVjayIsInNlbGYiLCJnbG9iYWwiLCJkZWZpbmVCdWlsdEluIiwidmFsaWRhdGVBcmd1bWVudHNMZW5ndGgiLCIkVVJMU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlIiwiYXBwZW5kIiwiJGRlbGV0ZSIsImZvckVhY2giLCJwYXJhbXMiLCIkdmFsdWUiLCJlbnRyaWVzIiwidiIsImsiLCJkaW5kZXgiLCJmb3VuZCIsImVudHJpZXNMZW5ndGgiLCJlbnRyeSIsImVudW1lcmFibGUiLCJ1bnNhZmUiLCJ3aXRoUmVzb2x2ZXJzIiwiZGVmaW5lQnVpbHRJbkFjY2Vzc29yIiwidWlkIiwiSW50OEFycmF5IiwiSW50OEFycmF5UHJvdG90eXBlIiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSIsIlR5cGVkQXJyYXkiLCJUeXBlZEFycmF5UHJvdG90eXBlIiwiVFlQRURfQVJSQVlfVEFHIiwiVFlQRURfQVJSQVlfQ09OU1RSVUNUT1IiLCJOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIiwib3BlcmEiLCJUWVBFRF9BUlJBWV9UQUdfUkVRVUlSRUQiLCJOQU1FIiwiQ29uc3RydWN0b3IiLCJUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCIsIkludDE2QXJyYXkiLCJVaW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJVaW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIkJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCIsIkJpZ0ludDY0QXJyYXkiLCJCaWdVaW50NjRBcnJheSIsImlzVmlldyIsImdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvciIsImlzVHlwZWRBcnJheSIsImFUeXBlZEFycmF5IiwiYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciIsIkMiLCJleHBvcnRUeXBlZEFycmF5TWV0aG9kIiwiS0VZIiwicHJvcGVydHkiLCJBUlJBWSIsIlR5cGVkQXJyYXlDb25zdHJ1Y3RvciIsImVycm9yMiIsImV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QiLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSIsImNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciIsImRvY3VtZW50QWxsIiwiYWxsIiwiSUU4X0RPTV9ERUZJTkUiLCJWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyIsInRvUHJvcGVydHlLZXkiLCIkZGVmaW5lUHJvcGVydHkiLCIkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiRU5VTUVSQUJMRSIsIldSSVRBQkxFIiwiUCIsIkF0dHJpYnV0ZXMiLCJjdXJyZW50IiwiY3JlYXRlU2V0TGlrZSIsImNyZWF0ZVNldExpa2VXaXRoSW5maW5pdHlTaXplIiwiRXJyb3IiLCJjYWxsYmFjayIsIm5vdEFOYU4iLCJ0b1Bvc2l0aXZlSW50ZWdlciIsInRha2VXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciIsInJlbWFpbmluZyIsInRha2UiLCJsaW1pdCIsImFuSW5zdGFuY2UiLCJpbmhlcml0SWZSZXF1aXJlZCIsIm5vcm1hbGl6ZVN0cmluZ0FyZ3VtZW50IiwiRE9NRXhjZXB0aW9uQ29uc3RhbnRzIiwiY2xlYXJFcnJvclN0YWNrIiwiRE9NX0VYQ0VQVElPTiIsIk5hdGl2ZURPTUV4Y2VwdGlvbiIsIiRET01FeGNlcHRpb24iLCJET01FeGNlcHRpb24iLCJET01FeGNlcHRpb25Qcm90b3R5cGUiLCJhcmd1bWVudHNMZW5ndGgiLCJtZXNzYWdlIiwic3RhY2siLCJFUlJPUl9IQVNfU1RBQ0siLCJET01fRVhDRVBUSU9OX0hBU19TVEFDSyIsIkJVR0dZX0RFU0NSSVBUT1IiLCJGT1JDRURfQ09OU1RSVUNUT1IiLCJQb2x5ZmlsbGVkRE9NRXhjZXB0aW9uIiwiUG9seWZpbGxlZERPTUV4Y2VwdGlvblByb3RvdHlwZSIsImNvbnN0YW50IiwiY29uc3RhbnROYW1lIiwicyIsImMiLCJJbmRleFNpemVFcnJvciIsIm0iLCJET01TdHJpbmdTaXplRXJyb3IiLCJIaWVyYXJjaHlSZXF1ZXN0RXJyb3IiLCJXcm9uZ0RvY3VtZW50RXJyb3IiLCJJbnZhbGlkQ2hhcmFjdGVyRXJyb3IiLCJOb0RhdGFBbGxvd2VkRXJyb3IiLCJOb01vZGlmaWNhdGlvbkFsbG93ZWRFcnJvciIsIk5vdEZvdW5kRXJyb3IiLCJOb3RTdXBwb3J0ZWRFcnJvciIsIkluVXNlQXR0cmlidXRlRXJyb3IiLCJJbnZhbGlkU3RhdGVFcnJvciIsIkludmFsaWRNb2RpZmljYXRpb25FcnJvciIsIk5hbWVzcGFjZUVycm9yIiwiSW52YWxpZEFjY2Vzc0Vycm9yIiwiVmFsaWRhdGlvbkVycm9yIiwiVHlwZU1pc21hdGNoRXJyb3IiLCJTZWN1cml0eUVycm9yIiwiTmV0d29ya0Vycm9yIiwiQWJvcnRFcnJvciIsIlVSTE1pc21hdGNoRXJyb3IiLCJRdW90YUV4Y2VlZGVkRXJyb3IiLCJUaW1lb3V0RXJyb3IiLCJJbnZhbGlkTm9kZVR5cGVFcnJvciIsIkRhdGFDbG9uZUVycm9yIiwiZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSIsImdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSIsImNvbmNhdCIsIm93bktleXMiLCJpc0RldGFjaGVkIiwiYXJyYXlGcm9tQ29uc3RydWN0b3JBbmRMaXN0IiwiJGZyb21CYXNlNjQiLCJmcm9tQmFzZTY0IiwibGlzdCIsIiRsZW5ndGgiLCJJbmRleGVkT2JqZWN0IiwiaW50ZWdlciIsInRvSW5kZXgiLCJkZXRhY2hUcmFuc2ZlcmFibGUiLCJBcnJheUJ1ZmZlclByb3RvdHlwZSIsIkRhdGFWaWV3UHJvdG90eXBlIiwiaXNSZXNpemFibGUiLCJtYXhCeXRlTGVuZ3RoIiwiZ2V0SW50OCIsInNldEludDgiLCJhcnJheUJ1ZmZlciIsIm5ld0xlbmd0aCIsInByZXNlcnZlUmVzaXphYmlsaXR5IiwibmV3Qnl0ZUxlbmd0aCIsImZpeGVkTGVuZ3RoIiwibmV3QnVmZmVyIiwiYSIsImIiLCJjb3B5TGVuZ3RoIiwiVVNFX05BVElWRV9VUkwiLCJVUkwiLCJwYXJzZSIsInVybCIsInVybFN0cmluZyIsImJhc2UiLCJ0b1ByaW1pdGl2ZSIsInByaW0iLCJCaWdJbnQiLCJWIiwiZnVuYyIsIlByb21pc2VDYXBhYmlsaXR5IiwiJCRyZXNvbHZlIiwiJCRyZWplY3QiLCJOQVRJVkVfQklORCIsInRvTGVuZ3RoIiwiRU5UUklFUyIsImRlZmluZUdsb2JhbFByb3BlcnR5IiwiY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyIsIlRBUkdFVCIsIkdMT0JBTCIsIlNUQVRJQyIsInRhcmdldFByb3BlcnR5Iiwic291cmNlUHJvcGVydHkiLCJkb250Q2FsbEdldFNldCIsImRldGFjaGVkIiwic2V0RnJvbUJhc2U2NCIsIm9iamVjdEtleXMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJzaW1wbGUiLCJub25Db25maWd1cmFibGUiLCJub25Xcml0YWJsZSIsIlRPX1NUUklOR19UQUdfU1VQUE9SVCIsImNsYXNzb2ZSYXciLCJDT1JSRUNUX0FSR1VNRU5UUyIsInRyeUdldCIsInRhZyIsImNhbGxlZSIsImJpdG1hcCIsIk5BVElWRV9TWU1CT0wiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlIiwic2VhcmNoUGFyYW1zIiwicGFyYW1zMiIsInBhdGhuYW1lIiwidG9KU09OIiwic29ydCIsImhyZWYiLCJ1c2VybmFtZSIsImhvc3QiLCJoYXNoIiwiZ2V0QWxsIiwiJGhhcyIsInZhbHVlcyIsImZvckVhY2hXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciIsIlNIQVJFRCIsInZlcnNpb25zIiwibW9kZSIsImNvcHlyaWdodCIsImxpY2Vuc2UiLCJTRVRfTElLRV9JTkNPUlJFQ1RfQkVIQVZJT1IiLCJzZXRMaWtlIiwiYmFzZVNldCIsImNsZWFyIiwiQlVHR1lfU0FGQVJJX0lURVJBVE9SUyIsIlByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSIsImFycmF5SXRlcmF0b3IiLCJORVdfSVRFUkFUT1JfUFJPVE9UWVBFIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlIiwiZXhjZXB0aW9ucyIsImFGdW5jdGlvbiIsIm5hbWVzcGFjZSIsIiR0cmFuc2ZlciIsInRyYW5zZmVyVG9GaXhlZExlbmd0aCIsImludGVyc2VjdGlvbiIsImZyb20iLCJjcmVhdGVQcm9wZXJ0eSIsIkNPTlNUUlVDVE9SIiwiTmF0aXZlSXRlcmF0b3IiLCJJdGVyYXRvckNvbnN0cnVjdG9yIiwiZGVmaW5lSXRlcmF0b3JQcm90b3R5cGVBY2Nlc3NvciIsIldlbGxLbm93blN5bWJvbHNTdG9yZSIsImNyZWF0ZVdlbGxLbm93blN5bWJvbCIsIndpdGhvdXRTZXR0ZXIiLCIkU3ludGF4RXJyb3IiLCIkcGFyc2VJbnQiLCJmcm9tQ2hhckNvZGUiLCJhdCIsImNvZGVQb2ludHMiLCJJU180X0hFWF9ESUdJVFMiLCJJU19DMF9DT05UUk9MX0NPREUiLCJ1bnRlcm1pbmF0ZWQiLCJjaHIiLCJ0d29DaGFycyIsImZvdXJIZXhEaWdpdHMiLCJlbmQiLCJGQUlMU19PTl9JTklUSUFMX1VOREVGSU5FRCIsInJlZHVjZSIsInJlZHVjZVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIiwicmVkdWNlciIsIm5vSW5pdGlhbCIsImFjY3VtdWxhdG9yIiwicGFyc2VKU09OU3RyaW5nIiwiSlNPTiIsIm5hdGl2ZVBhcnNlIiwiZW51bWVyYWJsZU93blByb3BlcnRpZXMiLCJJU19ESUdJVCIsIklTX05PTl9aRVJPX0RJR0lUIiwiSVNfTlVNQkVSX1NUQVJUIiwiSVNfV0hJVEVTUEFDRSIsIlBSSU1JVElWRSIsIk9CSkVDVCIsIiRwYXJzZSIsInJldml2ZXIiLCJjb250ZXh0IiwiQ29udGV4dCIsInJvb3QiLCJlbmRJbmRleCIsInNraXAiLCJpbnRlcm5hbGl6ZSIsImhvbGRlciIsIm5vZGUiLCJ1bm1vZGlmaWVkIiwiZWxlbWVudFJlY29yZHNMZW4iLCJub2RlSXNBcnJheSIsIm5vZGVzIiwiaW50ZXJuYWxpemVQcm9wZXJ0eSIsIk5vZGUiLCJmb3JrIiwibmV4dEluZGV4IiwiYXJyYXkiLCJrZXl3b3JkIiwic3RhcnQiLCJleHBlY3RLZXlwYWlyIiwidW50aWwiLCJleHBlY3RFbGVtZW50IiwicGFyc2VkIiwic3RhcnRJbmRleCIsImV4cG9uZW50U3RhcnRJbmRleCIsInJlZ2V4IiwiTk9fU09VUkNFX1NVUFBPUlQiLCJ1bnNhZmVJbnQiLCJQUk9QRVJfQkFTRV9QQVJTRSIsInRleHQiLCJpbnRlcnJ1cHRpYmxlIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIiRFcnJvciIsIlRFU1QiLCJhcmciLCJWOF9PUl9DSEFLUkFfU1RBQ0tfRU5UUlkiLCJJU19WOF9PUl9DSEFLUkFfU1RBQ0siLCJkcm9wRW50cmllcyIsInByZXBhcmVTdGFja1RyYWNlIiwic3RyaW5nSGFuZGxpbmciLCJSZWZsZWN0IiwiJHByb3BlcnR5SXNFbnVtZXJhYmxlIiwiTkFTSE9STl9CVUciLCJhbk9iamVjdE9yVW5kZWZpbmVkIiwiYmFzZTY0TWFwIiwiZ2V0QWxwaGFiZXRPcHRpb24iLCJza2lwQXNjaWlXaGl0ZXNwYWNlIiwiZGVjb2RlQmFzZTY0Q2h1bmsiLCJjaHVuayIsInRocm93T25FeHRyYUJpdHMiLCJjaHVua0xlbmd0aCIsInRyaXBsZXQiLCJjaHVua0J5dGVzIiwid3JpdGVCeXRlcyIsImVsZW1lbnRzIiwiZWxlbWVudHNMZW5ndGgiLCJsYXN0Q2h1bmtIYW5kbGluZyIsInJlbWFpbmluZ0J5dGVzIiwiRFJPUF9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1IiLCJkcm9wV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IiLCJkcm9wIiwiSVNfTk9ERSIsImdldEJ1aWx0aW5Nb2R1bGUiLCJkZWZpbmVCdWlsdElucyIsImNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QiLCJpdGVyYXRvckNsb3NlQWxsIiwiSVRFUkFUT1JfSEVMUEVSIiwiV1JBUF9GT1JfVkFMSURfSVRFUkFUT1IiLCJOT1JNQUwiLCJUSFJPVyIsInNldEludGVybmFsU3RhdGUiLCJjcmVhdGVJdGVyYXRvclByb3h5UHJvdG90eXBlIiwibmV4dEhhbmRsZXIiLCJyZXR1cm5IYW5kbGVyUmVzdWx0IiwicmV0dXJuTWV0aG9kIiwib3Blbkl0ZXJzIiwiV3JhcEZvclZhbGlkSXRlcmF0b3JQcm90b3R5cGUiLCJJdGVyYXRvckhlbHBlclByb3RvdHlwZSIsIlJFVFVSTl9IQU5ETEVSX1JFU1VMVCIsInRvQmFzZTY0Iiwib21pdFBhZGRpbmciLCJzaGlmdCIsInVuY3VycnlUaGlzV2l0aEJpbmQiLCJ2OCIsIm1hdGNoIiwiaW5uZXJSZXN1bHQiLCJpbm5lckVycm9yIiwiYXJyYXlXaXRoIiwiQXJyYXlCdWZmZXJWaWV3Q29yZSIsImlzQmlnSW50QXJyYXkiLCJ0b0JpZ0ludCIsIlBST1BFUl9PUkRFUiIsIlRIUk9XX09OX05FR0FUSVZFX0ZSQUNUSU9OQUxfSU5ERVgiLCJyZWxhdGl2ZUluZGV4IiwiYWN0dWFsVmFsdWUiLCJ0b0Fic29sdXRlSW5kZXgiLCJjcmVhdGVNZXRob2QiLCJJU19JTkNMVURFUyIsImVsIiwiZnJvbUluZGV4IiwiYWN0dWFsSW5kZXgiLCJBIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJkIiwiZGVmaW5pdGlvbiIsIm8iLCJwcm9wIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImVzX2FycmF5X3B1c2giLCJlc19hcnJheV9idWZmZXJfZGV0YWNoZWQiLCJlc19hcnJheV9idWZmZXJfdHJhbnNmZXIiLCJlc19hcnJheV9idWZmZXJfdHJhbnNmZXJfdG9fZml4ZWRfbGVuZ3RoIiwiZXNfaXRlcmF0b3JfY29uc3RydWN0b3IiLCJlc19pdGVyYXRvcl9yZWR1Y2UiLCJlc19wcm9taXNlX3RyeSIsImVzX3R5cGVkX2FycmF5X3dpdGgiLCJlc25leHRfbWF0aF9zdW1fcHJlY2lzZSIsImVzbmV4dF91aW50OF9hcnJheV9mcm9tX2Jhc2U2NCIsImVzbmV4dF91aW50OF9hcnJheV9zZXRfZnJvbV9iYXNlNjQiLCJlc25leHRfdWludDhfYXJyYXlfc2V0X2Zyb21faGV4IiwiZXNuZXh0X3VpbnQ4X2FycmF5X3RvX2Jhc2U2NCIsImVzbmV4dF91aW50OF9hcnJheV90b19oZXgiLCJ3ZWJfZG9tX2V4Y2VwdGlvbl9zdGFjayIsIndlYl91cmxfcGFyc2UiLCJpc05vZGVKUyIsIm53IiwiZWxlY3Ryb24iLCJGT05UX0lERU5USVRZX01BVFJJWCIsIkxJTkVfRkFDVE9SIiwiTElORV9ERVNDRU5UX0ZBQ1RPUiIsIkJBU0VMSU5FX0ZBQ1RPUiIsIlJlbmRlcmluZ0ludGVudEZsYWciLCJBTlkiLCJESVNQTEFZIiwiUFJJTlQiLCJTQVZFIiwiQU5OT1RBVElPTlNfRk9STVMiLCJBTk5PVEFUSU9OU19TVE9SQUdFIiwiQU5OT1RBVElPTlNfRElTQUJMRSIsIklTX0VESVRJTkciLCJPUExJU1QiLCJBbm5vdGF0aW9uTW9kZSIsIkRJU0FCTEUiLCJFTkFCTEUiLCJFTkFCTEVfRk9STVMiLCJFTkFCTEVfU1RPUkFHRSIsIkFubm90YXRpb25FZGl0b3JQcmVmaXgiLCJBbm5vdGF0aW9uRWRpdG9yVHlwZSIsIk5PTkUiLCJGUkVFVEVYVCIsIkhJR0hMSUdIVCIsIlNUQU1QIiwiSU5LIiwiUE9QVVAiLCJTSUdOQVRVUkUiLCJDT01NRU5UIiwiQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUiLCJSRVNJWkUiLCJDUkVBVEUiLCJGUkVFVEVYVF9TSVpFIiwiRlJFRVRFWFRfQ09MT1IiLCJGUkVFVEVYVF9PUEFDSVRZIiwiSU5LX0NPTE9SIiwiSU5LX1RISUNLTkVTUyIsIklOS19PUEFDSVRZIiwiSElHSExJR0hUX0NPTE9SIiwiSElHSExJR0hUX1RISUNLTkVTUyIsIkhJR0hMSUdIVF9GUkVFIiwiSElHSExJR0hUX1NIT1dfQUxMIiwiRFJBV19TVEVQIiwiUGVybWlzc2lvbkZsYWciLCJNT0RJRllfQ09OVEVOVFMiLCJDT1BZIiwiTU9ESUZZX0FOTk9UQVRJT05TIiwiRklMTF9JTlRFUkFDVElWRV9GT1JNUyIsIkNPUFlfRk9SX0FDQ0VTU0lCSUxJVFkiLCJBU1NFTUJMRSIsIlBSSU5UX0hJR0hfUVVBTElUWSIsIlRleHRSZW5kZXJpbmdNb2RlIiwiRklMTCIsIlNUUk9LRSIsIkZJTExfU1RST0tFIiwiSU5WSVNJQkxFIiwiRklMTF9BRERfVE9fUEFUSCIsIlNUUk9LRV9BRERfVE9fUEFUSCIsIkZJTExfU1RST0tFX0FERF9UT19QQVRIIiwiQUREX1RPX1BBVEgiLCJGSUxMX1NUUk9LRV9NQVNLIiwiQUREX1RPX1BBVEhfRkxBRyIsInV0aWxfSW1hZ2VLaW5kIiwiR1JBWVNDQUxFXzFCUFAiLCJSR0JfMjRCUFAiLCJSR0JBXzMyQlBQIiwiQW5ub3RhdGlvblR5cGUiLCJURVhUIiwiTElOSyIsIkxJTkUiLCJTUVVBUkUiLCJDSVJDTEUiLCJQT0xZR09OIiwiUE9MWUxJTkUiLCJVTkRFUkxJTkUiLCJTUVVJR0dMWSIsIlNUUklLRU9VVCIsIkNBUkVUIiwiRklMRUFUVEFDSE1FTlQiLCJTT1VORCIsIk1PVklFIiwiV0lER0VUIiwiU0NSRUVOIiwiUFJJTlRFUk1BUksiLCJUUkFQTkVUIiwiV0FURVJNQVJLIiwiVEhSRUVEIiwiUkVEQUNUIiwiQW5ub3RhdGlvblJlcGx5VHlwZSIsIkdST1VQIiwiUkVQTFkiLCJBbm5vdGF0aW9uRmxhZyIsIkhJRERFTiIsIk5PWk9PTSIsIk5PUk9UQVRFIiwiTk9WSUVXIiwiUkVBRE9OTFkiLCJMT0NLRUQiLCJUT0dHTEVOT1ZJRVciLCJMT0NLRURDT05URU5UUyIsIkFubm90YXRpb25GaWVsZEZsYWciLCJSRVFVSVJFRCIsIk5PRVhQT1JUIiwiTVVMVElMSU5FIiwiUEFTU1dPUkQiLCJOT1RPR0dMRVRPT0ZGIiwiUkFESU8iLCJQVVNIQlVUVE9OIiwiQ09NQk8iLCJFRElUIiwiU09SVCIsIkZJTEVTRUxFQ1QiLCJNVUxUSVNFTEVDVCIsIkRPTk9UU1BFTExDSEVDSyIsIkRPTk9UU0NST0xMIiwiQ09NQiIsIlJJQ0hURVhUIiwiUkFESU9TSU5VTklTT04iLCJDT01NSVRPTlNFTENIQU5HRSIsIkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUiLCJTT0xJRCIsIkRBU0hFRCIsIkJFVkVMRUQiLCJJTlNFVCIsIkFubm90YXRpb25BY3Rpb25FdmVudFR5cGUiLCJFIiwiWCIsIkQiLCJVIiwiRm8iLCJCbCIsIlBPIiwiUEMiLCJQViIsIlBJIiwiSyIsIkRvY3VtZW50QWN0aW9uRXZlbnRUeXBlIiwiV0MiLCJXUyIsIkRTIiwiV1AiLCJEUCIsIlBhZ2VBY3Rpb25FdmVudFR5cGUiLCJWZXJib3NpdHlMZXZlbCIsIkVSUk9SUyIsIldBUk5JTkdTIiwiSU5GT1MiLCJPUFMiLCJkZXBlbmRlbmN5Iiwic2V0TGluZVdpZHRoIiwic2V0TGluZUNhcCIsInNldExpbmVKb2luIiwic2V0TWl0ZXJMaW1pdCIsInNldERhc2giLCJzZXRSZW5kZXJpbmdJbnRlbnQiLCJzZXRGbGF0bmVzcyIsInNldEdTdGF0ZSIsInNhdmUiLCJyZXN0b3JlIiwidHJhbnNmb3JtIiwibW92ZVRvIiwibGluZVRvIiwiY3VydmVUbyIsImN1cnZlVG8yIiwiY3VydmVUbzMiLCJjbG9zZVBhdGgiLCJyZWN0YW5nbGUiLCJzdHJva2UiLCJjbG9zZVN0cm9rZSIsImZpbGwiLCJlb0ZpbGwiLCJmaWxsU3Ryb2tlIiwiZW9GaWxsU3Ryb2tlIiwiY2xvc2VGaWxsU3Ryb2tlIiwiY2xvc2VFT0ZpbGxTdHJva2UiLCJlbmRQYXRoIiwiY2xpcCIsImVvQ2xpcCIsImJlZ2luVGV4dCIsImVuZFRleHQiLCJzZXRDaGFyU3BhY2luZyIsInNldFdvcmRTcGFjaW5nIiwic2V0SFNjYWxlIiwic2V0TGVhZGluZyIsInNldEZvbnQiLCJzZXRUZXh0UmVuZGVyaW5nTW9kZSIsInNldFRleHRSaXNlIiwibW92ZVRleHQiLCJzZXRMZWFkaW5nTW92ZVRleHQiLCJzZXRUZXh0TWF0cml4IiwibmV4dExpbmUiLCJzaG93VGV4dCIsInNob3dTcGFjZWRUZXh0IiwibmV4dExpbmVTaG93VGV4dCIsIm5leHRMaW5lU2V0U3BhY2luZ1Nob3dUZXh0Iiwic2V0Q2hhcldpZHRoIiwic2V0Q2hhcldpZHRoQW5kQm91bmRzIiwic2V0U3Ryb2tlQ29sb3JTcGFjZSIsInNldEZpbGxDb2xvclNwYWNlIiwic2V0U3Ryb2tlQ29sb3IiLCJzZXRTdHJva2VDb2xvck4iLCJzZXRGaWxsQ29sb3IiLCJzZXRGaWxsQ29sb3JOIiwic2V0U3Ryb2tlR3JheSIsInNldEZpbGxHcmF5Iiwic2V0U3Ryb2tlUkdCQ29sb3IiLCJzZXRGaWxsUkdCQ29sb3IiLCJzZXRTdHJva2VDTVlLQ29sb3IiLCJzZXRGaWxsQ01ZS0NvbG9yIiwic2hhZGluZ0ZpbGwiLCJiZWdpbklubGluZUltYWdlIiwiYmVnaW5JbWFnZURhdGEiLCJlbmRJbmxpbmVJbWFnZSIsInBhaW50WE9iamVjdCIsIm1hcmtQb2ludCIsIm1hcmtQb2ludFByb3BzIiwiYmVnaW5NYXJrZWRDb250ZW50IiwiYmVnaW5NYXJrZWRDb250ZW50UHJvcHMiLCJlbmRNYXJrZWRDb250ZW50IiwiYmVnaW5Db21wYXQiLCJlbmRDb21wYXQiLCJwYWludEZvcm1YT2JqZWN0QmVnaW4iLCJwYWludEZvcm1YT2JqZWN0RW5kIiwiYmVnaW5Hcm91cCIsImVuZEdyb3VwIiwiYmVnaW5Bbm5vdGF0aW9uIiwiZW5kQW5ub3RhdGlvbiIsInBhaW50SW1hZ2VNYXNrWE9iamVjdCIsInBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwIiwicGFpbnRJbWFnZVhPYmplY3QiLCJwYWludElubGluZUltYWdlWE9iamVjdCIsInBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAiLCJwYWludEltYWdlWE9iamVjdFJlcGVhdCIsInBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdCIsInBhaW50U29saWRDb2xvckltYWdlTWFzayIsImNvbnN0cnVjdFBhdGgiLCJzZXRTdHJva2VUcmFuc3BhcmVudCIsInNldEZpbGxUcmFuc3BhcmVudCIsInJhd0ZpbGxQYXRoIiwiRHJhd09QUyIsIlBhc3N3b3JkUmVzcG9uc2VzIiwiTkVFRF9QQVNTV09SRCIsIklOQ09SUkVDVF9QQVNTV09SRCIsInZlcmJvc2l0eSIsInNldFZlcmJvc2l0eUxldmVsIiwibGV2ZWwiLCJpc0ludGVnZXIiLCJnZXRWZXJib3NpdHlMZXZlbCIsImluZm8iLCJtc2ciLCJjb25zb2xlIiwid2FybiIsInVucmVhY2hhYmxlIiwiYXNzZXJ0IiwiY29uZCIsIl9pc1ZhbGlkUHJvdG9jb2wiLCJwcm90b2NvbCIsImNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwiLCJiYXNlVXJsIiwiYWRkRGVmYXVsdFByb3RvY29sIiwic3RhcnRzV2l0aCIsImRvdHMiLCJ0cnlDb252ZXJ0RW5jb2RpbmciLCJzdHJpbmdUb1VURjhTdHJpbmciLCJhYnNvbHV0ZVVybCIsInVwZGF0ZVVybEhhc2giLCJhbGxvd1JlbCIsInJlcyIsInNoYWRvdyIsIm5vblNlcmlhbGl6YWJsZSIsIkJhc2VFeGNlcHRpb24iLCJCYXNlRXhjZXB0aW9uQ2xvc3VyZSIsIlBhc3N3b3JkRXhjZXB0aW9uIiwiY29kZSIsIlVua25vd25FcnJvckV4Y2VwdGlvbiIsImRldGFpbHMiLCJJbnZhbGlkUERGRXhjZXB0aW9uIiwiUmVzcG9uc2VFeGNlcHRpb24iLCJzdGF0dXMiLCJtaXNzaW5nIiwiRm9ybWF0RXJyb3IiLCJBYm9ydEV4Y2VwdGlvbiIsImJ5dGVzVG9TdHJpbmciLCJNQVhfQVJHVU1FTlRfQ09VTlQiLCJzdHJCdWYiLCJjaHVua0VuZCIsInN1YmFycmF5Iiwic3RyaW5nVG9CeXRlcyIsInN0ciIsImNoYXJDb2RlQXQiLCJzdHJpbmczMiIsIm9iamVjdFNpemUiLCJpc0xpdHRsZUVuZGlhbiIsImJ1ZmZlcjgiLCJ2aWV3MzIiLCJpc0V2YWxTdXBwb3J0ZWQiLCJ1dGlsX0ZlYXR1cmVUZXN0IiwiaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQiLCJPZmZzY3JlZW5DYW52YXMiLCJpc0ltYWdlRGVjb2RlclN1cHBvcnRlZCIsIkltYWdlRGVjb2RlciIsInBsYXRmb3JtIiwiaXNBbmRyb2lkIiwiaXNMaW51eCIsImlzTWFjIiwiaXNXaW5kb3dzIiwiaXNGaXJlZm94IiwiaXNDU1NSb3VuZFN1cHBvcnRlZCIsIkNTUyIsInN1cHBvcnRzIiwiaGV4TnVtYmVycyIsInBhZFN0YXJ0IiwiVXRpbCIsIm1ha2VIZXhDb2xvciIsInIiLCJnIiwiZG9tTWF0cml4VG9UcmFuc2Zvcm0iLCJkbSIsInNjYWxlTWluTWF4IiwibWluTWF4IiwibTEiLCJtMiIsIm11bHRpcGx5QnlET01NYXRyaXgiLCJtZCIsImFwcGx5VHJhbnNmb3JtIiwicCIsInBvcyIsInAwIiwicDEiLCJhcHBseVRyYW5zZm9ybVRvQmV6aWVyIiwibTAiLCJtMyIsIm00IiwibTUiLCJwSSIsInBJMSIsImFwcGx5SW52ZXJzZVRyYW5zZm9ybSIsImF4aWFsQWxpZ25lZEJvdW5kaW5nQm94IiwicmVjdCIsIm91dHB1dCIsInIwIiwicjEiLCJyMiIsInIzIiwiYTAiLCJhMiIsImExIiwiYTMiLCJiMCIsImIyIiwiYjEiLCJiMyIsIm0xcjAiLCJtMXIyIiwibTJyMSIsIm0ycjMiLCJpbnZlcnNlVHJhbnNmb3JtIiwic2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUiLCJtYXRyaXgiLCJmaXJzdCIsInNlY29uZCIsInNxcnQiLCJub3JtYWxpemVSZWN0IiwiaW50ZXJzZWN0IiwicmVjdDEiLCJyZWN0MiIsInhMb3ciLCJ4SGlnaCIsInlMb3ciLCJ5SGlnaCIsInBvaW50Qm91bmRpbmdCb3giLCJyZWN0Qm91bmRpbmdCb3giLCJ4MCIsInkwIiwieDEiLCJ5MSIsImdldEV4dHJlbXVtT25DdXJ2ZSIsIngyIiwieDMiLCJ5MiIsInkzIiwidCIsIm10IiwidHQiLCJ0dHQiLCJnZXRFeHRyZW11bSIsImRlbHRhIiwic3FydERlbHRhIiwiYmV6aWVyQm91bmRpbmdCb3giLCJQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSIsInN0cmluZ1RvUERGU3RyaW5nIiwia2VlcEVzY2FwZVNlcXVlbmNlIiwiZW5jb2RpbmciLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJmYXRhbCIsImRlY29kZWQiLCJkZWNvZGUiLCJyZXBsYWNlQWxsIiwiZXgiLCJpaSIsImNoYXJDb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXNjYXBlIiwidXRmOFN0cmluZ1RvU3RyaW5nIiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJpc0FycmF5RXF1YWwiLCJhcnIxIiwiYXJyMiIsImdldE1vZGlmaWNhdGlvbkRhdGUiLCJkYXRlIiwiRGF0ZSIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsIk5vcm1hbGl6ZVJlZ2V4IiwiTm9ybWFsaXphdGlvbk1hcCIsIm5vcm1hbGl6ZVVuaWNvZGUiLCJNYXAiLCJfIiwicDIiLCJnZXRVdWlkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsImJ1ZiIsImdldFJhbmRvbVZhbHVlcyIsIkFubm90YXRpb25QcmVmaXgiLCJfaXNWYWxpZEV4cGxpY2l0RGVzdCIsInZhbGlkUmVmIiwidmFsaWROYW1lIiwiZGVzdCIsInBhZ2UiLCJ6b29tIiwiYXJnc0xlbiIsImFsbG93TnVsbCIsIk1hdGhDbGFtcCIsInRvSGV4VXRpbCIsImFyciIsIm51bSIsInRvQmFzZTY0VXRpbCIsImJ0b2EiLCJmcm9tQmFzZTY0VXRpbCIsImF0b2IiLCJBYm9ydFNpZ25hbCIsImFueSIsImFjIiwiQWJvcnRDb250cm9sbGVyIiwic2lnbmFsIiwiYWJvcnRlZCIsImFib3J0IiwicmVhc29uIiwiYWRkRXZlbnRMaXN0ZW5lciIsImVzX2l0ZXJhdG9yX21hcCIsIndlYl91cmxfc2VhcmNoX3BhcmFtc19kZWxldGUiLCJ3ZWJfdXJsX3NlYXJjaF9wYXJhbXNfaGFzIiwid2ViX3VybF9zZWFyY2hfcGFyYW1zX3NpemUiLCJYZmFUZXh0IiwidGV4dENvbnRlbnQiLCJ4ZmEiLCJzdHlsZXMiLCJ3YWxrIiwic2hvdWxkQnVpbGRUZXh0IiwiYXR0cmlidXRlcyIsImNoaWxkcmVuIiwiY2hpbGQiLCJYZmFMYXllciIsInNldHVwU3RvcmFnZSIsImVsZW1lbnQiLCJzdG9yYWdlIiwiaW50ZW50Iiwic3RvcmVkRGF0YSIsImdldFZhbHVlIiwiZXZlbnQiLCJzZXRWYWx1ZSIsInhmYU9uIiwic2V0QXR0cmlidXRlIiwieGZhT2ZmIiwicmVtb3ZlQXR0cmlidXRlIiwiY2hlY2tlZCIsImdldEF0dHJpYnV0ZSIsIm9wdGlvbiIsInNlbGVjdGVkIiwic2VsZWN0ZWRJbmRleCIsInNldEF0dHJpYnV0ZXMiLCJsaW5rU2VydmljZSIsImlzSFRNTEFuY2hvckVsZW1lbnQiLCJIVE1MQW5jaG9yRWxlbWVudCIsImFzc2lnbiIsImFkZExpbmtBdHRyaWJ1dGVzIiwibmV3V2luZG93IiwiZGF0YUlkIiwicmVuZGVyIiwicGFyYW1ldGVycyIsImFubm90YXRpb25TdG9yYWdlIiwieGZhSHRtbCIsInJvb3RIdG1sIiwiaXNOb3RGb3JSaWNoVGV4dCIsInJvb3REaXYiLCJkaXYiLCJ2aWV3cG9ydCIsInRleHREaXZzIiwiY3JlYXRlVGV4dE5vZGUiLCJwYXJlbnQiLCJwb3AiLCJjaGlsZEh0bWwiLCJ4bWxucyIsImNyZWF0ZUVsZW1lbnROUyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ1cGRhdGUiLCJoaWRkZW4iLCJTVkdfTlMiLCJQaXhlbHNQZXJJbmNoIiwiUERGIiwiUERGX1RPX0NTU19VTklUUyIsImZldGNoRGF0YSIsImlzVmFsaWRGZXRjaFVybCIsImJhc2VVUkkiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJzdGF0dXNUZXh0IiwiYmxvYiIsImpzb24iLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJyZXNwb25zZVR5cGUiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwiRE9ORSIsInJlc3BvbnNlVGV4dCIsInNlbmQiLCJQYWdlVmlld3BvcnQiLCJ2aWV3Qm94IiwidXNlclVuaXQiLCJzY2FsZSIsInJvdGF0aW9uIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJkb250RmxpcCIsImNlbnRlclgiLCJjZW50ZXJZIiwicm90YXRlQSIsInJvdGF0ZUIiLCJyb3RhdGVDIiwicm90YXRlRCIsIm9mZnNldENhbnZhc1giLCJvZmZzZXRDYW52YXNZIiwid2lkdGgiLCJoZWlnaHQiLCJyYXdEaW1zIiwiZGltcyIsInBhZ2VXaWR0aCIsInBhZ2VIZWlnaHQiLCJwYWdlWCIsInBhZ2VZIiwiY29udmVydFRvVmlld3BvcnRQb2ludCIsImNvbnZlcnRUb1ZpZXdwb3J0UmVjdGFuZ2xlIiwidG9wTGVmdCIsImJvdHRvbVJpZ2h0IiwiY29udmVydFRvUGRmUG9pbnQiLCJSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24iLCJleHRyYURlbGF5IiwiaXNEYXRhU2NoZW1lIiwidHJpbSIsInN1YnN0cmluZyIsImlzUGRmRmlsZSIsImZpbGVuYW1lIiwiZ2V0RmlsZW5hbWVGcm9tVXJsIiwibGFzdEluZGV4T2YiLCJnZXRQZGZGaWxlbmFtZUZyb21VcmwiLCJkZWZhdWx0RmlsZW5hbWUiLCJnZXRVUkwiLCJuZXdVUkwiLCJwZGZSZWdleCIsInJldmVyc2UiLCJyZUZpbGVuYW1lIiwiaGFzaEZpbGVuYW1lIiwiU3RhdFRpbWVyIiwidGltZSIsInN0YXJ0ZWQiLCJub3ciLCJ0aW1lRW5kIiwidGltZXMiLCJvdXRCdWYiLCJsb25nZXN0IiwicGFkRW5kIiwibm9Db250ZXh0TWVudSIsInByZXZlbnREZWZhdWx0Iiwic3RvcEV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwiZGVwcmVjYXRlZCIsImxvZyIsIlBERkRhdGVTdHJpbmciLCJ0b0RhdGVPYmplY3QiLCJSZWdFeHAiLCJtYXRjaGVzIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInVuaXZlcnNhbFRpbWVSZWxhdGlvbiIsIm9mZnNldEhvdXIiLCJvZmZzZXRNaW51dGUiLCJVVEMiLCJnZXRYZmFQYWdlVmlld3BvcnQiLCJ4ZmFQYWdlIiwiZ2V0UkdCIiwiY29sb3IiLCJjb2xvclJHQiIsImdldENvbG9yVmFsdWVzIiwiY29sb3JzIiwic3BhbiIsInZpc2liaWxpdHkiLCJjb2xvclNjaGVtZSIsImJvZHkiLCJjb21wdXRlZENvbG9yIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldEN1cnJlbnRUcmFuc2Zvcm0iLCJjdHgiLCJnZXRUcmFuc2Zvcm0iLCJnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSIsImludmVydFNlbGYiLCJzZXRMYXllckRpbWVuc2lvbnMiLCJtdXN0RmxpcCIsIm11c3RSb3RhdGUiLCJ1c2VSb3VuZCIsInciLCJoIiwid2lkdGhTdHIiLCJoZWlnaHRTdHIiLCJPdXRwdXRTY2FsZSIsInBpeGVsUmF0aW8iLCJzeCIsInN5Iiwic2NhbGVkIiwic3ltbWV0cmljIiwibGltaXRDYW52YXMiLCJtYXhQaXhlbHMiLCJtYXhEaW0iLCJjYXBBcmVhRmFjdG9yIiwibWF4QXJlYVNjYWxlIiwibWF4V2lkdGhTY2FsZSIsIm1heEhlaWdodFNjYWxlIiwiY2FwUGl4ZWxzIiwibWF4U2NhbGUiLCJkZXZpY2VQaXhlbFJhdGlvIiwid2luUGl4ZWxzIiwic2NyZWVuIiwiYXZhaWxXaWR0aCIsImF2YWlsSGVpZ2h0IiwiU3VwcG9ydGVkSW1hZ2VNaW1lVHlwZXMiLCJDb2xvclNjaGVtZSIsImlzRGFya01vZGUiLCJtYXRjaE1lZGlhIiwiQ1NTQ29uc3RhbnRzIiwiY29tbWVudEZvcmVncm91bmRDb2xvciIsImNsYXNzTGlzdCIsImFwcGx5T3BhY2l0eSIsIm9wYWNpdHkiLCJ3aGl0ZSIsInJvdW5kIiwiUkdCVG9IU0wiLCJyZ2IiLCJsIiwiSFNMVG9SR0IiLCJoc2wiLCJjb21wdXRlTHVtaW5hbmNlIiwiY29udHJhc3RSYXRpbyIsImhzbDEiLCJoc2wyIiwibHVtMSIsImx1bTIiLCJjb250cmFzdENhY2hlIiwiZmluZENvbnRyYXN0Q29sb3IiLCJiYXNlQ29sb3IiLCJmaXhlZENvbG9yIiwiY2FjaGVkVmFsdWUiLCJiYXNlSFNMIiwiZml4ZWRIU0wiLCJpc0ZpeGVkQ29sb3JEYXJrIiwibWluQ29udHJhc3QiLCJQUkVDSVNJT04iLCJtaWQiLCJyZW5kZXJSaWNoVGV4dCIsImRpciIsImNsYXNzTmFtZSIsImNvbnRhaW5lciIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImxpbmVzIiwibGluZSIsImZpcnN0Q2hpbGQiLCJlc19pdGVyYXRvcl90YWtlIiwiZXNfcHJvbWlzZV93aXRoX3Jlc29sdmVycyIsImVzX3NldF9kaWZmZXJlbmNlX3YyIiwiZXNfc2V0X2ludGVyc2VjdGlvbl92MiIsImVzX3NldF9pc19kaXNqb2ludF9mcm9tX3YyIiwiZXNfc2V0X2lzX3N1YnNldF9vZl92MiIsImVzX3NldF9pc19zdXBlcnNldF9vZl92MiIsImVzX3NldF9zeW1tZXRyaWNfZGlmZmVyZW5jZV92MiIsImVzX3NldF91bmlvbl92MiIsImVzX2l0ZXJhdG9yX2Ryb3AiLCJlc19pdGVyYXRvcl9ldmVyeSIsImVzX2l0ZXJhdG9yX3NvbWUiLCJlc25leHRfanNvbl9wYXJzZSIsIkVkaXRvclRvb2xiYXIiLCJ0b29sYmFyIiwiY29sb3JQaWNrZXIiLCJlZGl0b3IiLCJidXR0b25zIiwiYWx0VGV4dCIsImNvbW1lbnQiLCJjb21tZW50QnV0dG9uRGl2aWRlciIsInNpZ25hdHVyZURlc2NyaXB0aW9uQnV0dG9uIiwibDEwblJlbW92ZSIsImZyZWV6ZSIsImZyZWV0ZXh0IiwiaGlnaGxpZ2h0IiwiaW5rIiwic3RhbXAiLCJzaWduYXR1cmUiLCJlZGl0VG9vbGJhciIsIl91aU1hbmFnZXIiLCJfc2lnbmFsIiwicG9pbnRlckRvd24iLCJwb3NpdGlvbiIsInRvb2xiYXJQb3NpdGlvbiIsImRpcmVjdGlvbiIsImluc2V0SW5saW5lRW5kIiwidG9wIiwiZm9jdXNJbiIsIl9mb2N1c0V2ZW50c0FsbG93ZWQiLCJmb2N1c091dCIsImFkZExpc3RlbmVyc1RvRWxlbWVudCIsImNhcHR1cmUiLCJoaWRlIiwiaGlkZURyb3Bkb3duIiwic2hvdyIsInNob3duIiwiYWRkRGVsZXRlQnV0dG9uIiwiZWRpdG9yVHlwZSIsImJ1dHRvbiIsInRhYkluZGV4IiwiZGVsZXRlIiwiZGl2aWRlciIsImFkZEFsdFRleHQiLCJhZGRDb21tZW50IiwiYmVmb3JlRWxlbWVudCIsInJlbmRlckZvclRvb2xiYXIiLCJpbnNlcnRCZWZvcmUiLCJhZGRDb2xvclBpY2tlciIsInJlbmRlckJ1dHRvbiIsImFkZEVkaXRTaWduYXR1cmVCdXR0b24iLCJzaWduYXR1cmVNYW5hZ2VyIiwicmVuZGVyRWRpdEJ1dHRvbiIsInJlbW92ZUJ1dHRvbiIsInJlbW92ZVRvb2xiYXJDb21tZW50QnV0dG9uIiwiYWRkQnV0dG9uIiwidG9vbCIsImFkZEJ1dHRvbkJlZm9yZSIsImJlZm9yZVNlbGVjdG9yIiwicXVlcnlTZWxlY3RvciIsInVwZGF0ZUVkaXRTaWduYXR1cmVCdXR0b24iLCJkZXNjcmlwdGlvbiIsInRpdGxlIiwiZGVzdHJveSIsIkZsb2F0aW5nVG9vbGJhciIsInVpTWFuYWdlciIsImhhc0NvbW1lbnRNYW5hZ2VyIiwibWFrZUJ1dHRvbiIsImNvbW1lbnRTZWxlY3Rpb24iLCJoaWdobGlnaHRTZWxlY3Rpb24iLCJnZXRMYXN0UG9pbnQiLCJib3hlcyIsImlzTFRSIiwibGFzdFkiLCJsYXN0WCIsImJveCIsImJ1dHRvbkNsYXNzIiwibDEwbklkIiwibGFiZWxMMTBuSWQiLCJjbGlja0hhbmRsZXIiLCJiaW5kRXZlbnRzIiwiSWRNYW5hZ2VyIiwiSW1hZ2VNYW5hZ2VyIiwiYmFzZUlkIiwiY2FjaGUiLCJfaXNTVkdGaXR0aW5nQ2FudmFzIiwic3ZnIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsIndpbGxSZWFkRnJlcXVlbnRseSIsImltYWdlIiwiSW1hZ2UiLCJ0aGVuIiwiZHJhd0ltYWdlIiwiZ2V0SW1hZ2VEYXRhIiwicmF3RGF0YSIsInJlZkNvdW50ZXIiLCJpc1N2ZyIsIkZpbGUiLCJmaWxlIiwiQmxvYiIsIm11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UiLCJmaWxlUmVhZGVyIiwiRmlsZVJlYWRlciIsImltYWdlRWxlbWVudCIsImltYWdlUHJvbWlzZSIsIm9ubG9hZCIsInN2Z1VybCIsIm9uZXJyb3IiLCJyZWFkQXNEYXRhVVJMIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJnZXRGcm9tRmlsZSIsImxhc3RNb2RpZmllZCIsImdldEZyb21VcmwiLCJnZXRGcm9tQmxvYiIsImJsb2JQcm9taXNlIiwiZ2V0RnJvbUlkIiwiZ2V0RnJvbUNhbnZhcyIsIm9mZnNjcmVlbiIsInRyYW5zZmVyVG9JbWFnZUJpdG1hcCIsImdldFN2Z1VybCIsImRlbGV0ZUlkIiwidHJhbnNmZXJGcm9tSW1hZ2VCaXRtYXAiLCJjb252ZXJ0VG9CbG9iIiwiaXNWYWxpZElkIiwiQ29tbWFuZE1hbmFnZXIiLCJjb21tYW5kcyIsImxvY2tlZCIsIm1heFNpemUiLCJjbWQiLCJ1bmRvIiwicG9zdCIsIm11c3RFeGVjIiwib3ZlcndyaXRlSWZTYW1lVHlwZSIsImtlZXBVbmRvIiwic3BsaWNlIiwicmVkbyIsImhhc1NvbWV0aGluZ1RvVW5kbyIsImhhc1NvbWV0aGluZ1RvUmVkbyIsImNsZWFuVHlwZSIsIktleWJvYXJkTWFuYWdlciIsImNhbGxiYWNrcyIsImFsbEtleXMiLCJpc01hY0tleSIsInNlcmlhbGl6ZSIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJidWJibGVzIiwiY2hlY2tlciIsIkNvbG9yTWFuYWdlciIsIl9jb2xvcnNNYXBwaW5nIiwiX2NvbG9ycyIsImNvbnZlcnQiLCJSR0IiLCJnZXRIZXhDb2RlIiwiQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciIsImFib3J0Q29udHJvbGxlciIsImFjdGl2ZUVkaXRvciIsImFsbEVkaXRhYmxlQW5ub3RhdGlvbnMiLCJhbGxFZGl0b3JzIiwiYWxsTGF5ZXJzIiwiYWx0VGV4dE1hbmFnZXIiLCJjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucyIsImNvbW1hbmRNYW5hZ2VyIiwiY29tbWVudE1hbmFnZXIiLCJjb3B5UGFzdGVBQyIsImN1cnJlbnREcmF3aW5nU2Vzc2lvbiIsImN1cnJlbnRQYWdlSW5kZXgiLCJkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzIiwiZHJhZ2dpbmdFZGl0b3JzIiwiZWRpdG9yVHlwZXMiLCJlZGl0b3JzVG9SZXNjYWxlIiwiZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24iLCJlbmFibGVVcGRhdGVkQWRkSW1hZ2UiLCJlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlIiwiZmlsdGVyRmFjdG9yeSIsImZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCIsImZvY3VzTWFuYWdlckFDIiwiaGlnaGxpZ2h0Q29sb3JzIiwiaGlnaGxpZ2h0V2hlblNoaWZ0VXAiLCJmbG9hdGluZ1Rvb2xiYXIiLCJpZE1hbmFnZXIiLCJpc0VuYWJsZWQiLCJpc1BvaW50ZXJEb3duIiwiaXNXYWl0aW5nIiwia2V5Ym9hcmRNYW5hZ2VyQUMiLCJsYXN0QWN0aXZlRWxlbWVudCIsIm1haW5IaWdobGlnaHRDb2xvclBpY2tlciIsIm1pc3NpbmdDYW52YXNlcyIsIm1sTWFuYWdlciIsInNlbGVjdGVkRWRpdG9ycyIsInNlbGVjdGVkVGV4dE5vZGUiLCJwYWdlQ29sb3JzIiwic2hvd0FsbFN0YXRlcyIsInBkZkRvY3VtZW50IiwicHJldmlvdXNTdGF0ZXMiLCJ0cmFuc2xhdGlvbiIsInRyYW5zbGF0aW9uVGltZW91dElkIiwidmlld2VyIiwidmlld2VyQWxlcnQiLCJ1cGRhdGVNb2RlQ2FwYWJpbGl0eSIsIlRSQU5TTEFURV9TTUFMTCIsIlRSQU5TTEFURV9CSUciLCJfa2V5Ym9hcmRNYW5hZ2VyIiwiYXJyb3dDaGVja2VyIiwiY29udGFpbnMiLCJhY3RpdmVFbGVtZW50IiwidGFnTmFtZSIsImhhc1NvbWV0aGluZ1RvQ29udHJvbCIsInRleHRJbnB1dENoZWNrZXIiLCJfc2VsZiIsIkhUTUxJbnB1dEVsZW1lbnQiLCJzbWFsbCIsImJpZyIsInNlbGVjdEFsbCIsImFkZE5ld0VkaXRvckZyb21LZXlib2FyZCIsIkhUTUxCdXR0b25FbGVtZW50IiwiaXNFbnRlckhhbmRsZWQiLCJ1bnNlbGVjdEFsbCIsInRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycyIsImV2ZW50QnVzIiwiZWRpdG9yVW5kb0JhciIsInN1cHBvcnRzUGluY2hUb1pvb20iLCJfZWRpdG9yVW5kb0JhciIsImlzRWRpdGluZyIsImlzRW1wdHkiLCJoYXNTZWxlY3RlZEVkaXRvciIsImhhc1NlbGVjdGVkVGV4dCIsIl9ldmVudEJ1cyIsIl9vbiIsIm9uRWRpdGluZ0FjdGlvbiIsIm9uUGFnZUNoYW5naW5nIiwib25TY2FsZUNoYW5naW5nIiwib25Sb3RhdGlvbkNoYW5naW5nIiwib25TZXRQcmVmZXJlbmNlIiwiZXZ0IiwidXBkYXRlUGFyYW1zIiwiYWRkU2VsZWN0aW9uTGlzdGVuZXIiLCJhZGREcmFnQW5kRHJvcExpc3RlbmVycyIsImFkZEtleWJvYXJkTWFuYWdlciIsInZpZXdQYXJhbWV0ZXJzIiwicmVhbFNjYWxlIiwiaXNTaGlmdEtleURvd24iLCJfc3VwcG9ydHNQaW5jaFRvWm9vbSIsInNldFNpZGViYXJVaU1hbmFnZXIiLCJsYXllciIsImNsZWFyVGltZW91dCIsImNvbWJpbmVkU2lnbmFsIiwidXNlTmV3QWx0VGV4dEZsb3ciLCJ1c2VOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlIiwiaGNtRmlsdGVyIiwiYWRkSENNRmlsdGVyIiwiZm9yZWdyb3VuZCIsImJhY2tncm91bmQiLCJfaGlnaGxpZ2h0Q29sb3JzIiwicGFpciIsInRvVXBwZXJDYXNlIiwiaGFzSENNIiwiaXNOYW1lRm9ySENNIiwiZW5kc1dpdGgiLCJoaWdobGlnaHRDb2xvck5hbWVzIiwiZ2V0Tm9uSENNQ29sb3IiLCJjb2xvck5hbWUiLCJnZXROb25IQ01Db2xvck5hbWUiLCJzZXRDdXJyZW50RHJhd2luZ1Nlc3Npb24iLCJkaXNhYmxlVXNlclNlbGVjdCIsInNldE1haW5IaWdobGlnaHRDb2xvclBpY2tlciIsImVkaXRBbHRUZXh0IiwiZmlyc3RUaW1lIiwiZWRpdENvbW1lbnQiLCJwb3NYIiwicG9zWSIsInNob3dEaWFsb2ciLCJzZWxlY3RDb21tZW50IiwicGFnZUluZGV4IiwiZ2V0RWRpdG9yQnlVSUQiLCJ0b2dnbGVDb21tZW50IiwidXBkYXRlQ29tbWVudCIsImdldERhdGEiLCJ1cGRhdGVQb3B1cENvbG9yIiwicmVtb3ZlQ29tbWVudCIsInJlbW92ZUNvbW1lbnRzIiwiaXNTZWxlY3RlZCIsInRvZ2dsZUNvbW1lbnRQb3B1cCIsIm1ha2VDb21tZW50Q29sb3IiLCJnZXRDb21tZW50RGlhbG9nRWxlbWVudCIsImRpYWxvZ0VsZW1lbnQiLCJ3YWl0Rm9yRWRpdG9yc1JlbmRlcmVkIiwicGFnZU51bWJlciIsIm9uRWRpdG9yc1JlbmRlcmVkIiwiX29mZiIsIm9uIiwiZ2V0U2lnbmF0dXJlIiwic3dpdGNoVG9Nb2RlIiwib25jZSIsImRpc3BhdGNoIiwic2V0UHJlZmVyZW5jZSIsImZvY3VzTWFpbkNvbnRhaW5lciIsImZvY3VzIiwiZmluZFBhcmVudCIsImxheWVyWCIsImxheWVyWSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvZ2dsZSIsImFkZFNob3VsZFJlc2NhbGUiLCJyZW1vdmVTaG91bGRSZXNjYWxlIiwiY29tbWl0T3JSZW1vdmUiLCJwYWdlc1JvdGF0aW9uIiwiZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbiIsImFuY2hvck5vZGUiLCJub2RlVHlwZSIsIlRFWFRfTk9ERSIsInBhcmVudEVsZW1lbnQiLCJnZXRMYXllckZvclRleHRMYXllciIsInRleHRMYXllciIsImN1cnJlbnRMYXllciIsImhhc1RleHRMYXllciIsIm1ldGhvZE9mQ3JlYXRpb24iLCJzZWxlY3Rpb24iLCJnZXRTZWxlY3Rpb24iLCJpc0NvbGxhcHNlZCIsImFuY2hvck9mZnNldCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwiYW5jaG9yRWxlbWVudCIsImNsb3Nlc3QiLCJnZXRTZWxlY3Rpb25Cb3hlcyIsImVtcHR5IiwiaXNOb25lTW9kZSIsImNyZWF0ZUFuZEFkZE5ld0VkaXRvciIsInNob3dBbGxFZGl0b3JzIiwiZGlzcGxheUZsb2F0aW5nVG9vbGJhciIsImdldEFuZFJlbW92ZURhdGFGcm9tQW5ub3RhdGlvblN0b3JhZ2UiLCJhbm5vdGF0aW9uSWQiLCJzdG9yZWRWYWx1ZSIsImdldFJhd1ZhbHVlIiwiYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSIsImExMXlBbGVydCIsIm1lc3NhZ2VJZCIsInN0cmluZ2lmeSIsInNlbGVjdGlvbkNoYW5nZSIsImRpc3BhdGNoVXBkYXRlU3RhdGVzIiwiYWN0aXZlTGF5ZXIiLCJ0b2dnbGVEcmF3aW5nIiwicG9pbnRlcnVwIiwib25TZWxlY3RFbmQiLCJhZGRGb2N1c01hbmFnZXIiLCJibHVyIiwicmVtb3ZlRm9jdXNNYW5hZ2VyIiwiaGFzU2VsZWN0aW9uIiwibGFzdEVkaXRvciIsImtleWRvd24iLCJrZXl1cCIsInJlbW92ZUtleWJvYXJkTWFuYWdlciIsImFkZENvcHlQYXN0ZUxpc3RlbmVycyIsImNvcHkiLCJjdXQiLCJwYXN0ZSIsInJlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycyIsImRyYWdPdmVyIiwiYWRkRWRpdExpc3RlbmVycyIsInJlbW92ZUVkaXRMaXN0ZW5lcnMiLCJkYXRhVHJhbnNmZXIiLCJpc0hhbmRsaW5nTWltZUZvclBhc3RpbmciLCJkcm9wRWZmZWN0IiwiZWRpdG9ycyIsInNlcmlhbGl6ZWQiLCJjbGlwYm9hcmREYXRhIiwic2V0RGF0YSIsIm5ld0VkaXRvcnMiLCJkZXNlcmlhbGl6ZWRFZGl0b3IiLCJkZXNlcmlhbGl6ZSIsImFkZEVkaXRvclRvTGF5ZXIiLCJzZWxlY3RFZGl0b3JzIiwiYWRkQ29tbWFuZHMiLCJpc0VkaXRvckhhbmRsaW5nS2V5Ym9hcmQiLCJoYXNDaGFuZ2VkIiwiZGlzcGF0Y2hVcGRhdGVVSSIsInNldEVkaXRpbmdTdGF0ZSIsInJlZ2lzdGVyRWRpdG9yVHlwZXMiLCJ0eXBlcyIsImRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUiLCJnZXRJZCIsImdldExheWVyIiwiYWRkTGF5ZXIiLCJlbmFibGUiLCJkaXNhYmxlIiwicmVtb3ZlTGF5ZXIiLCJ1cGRhdGVNb2RlIiwiZWRpdElkIiwiaXNGcm9tS2V5Ym9hcmQiLCJtdXN0RW50ZXJJbkVkaXRNb2RlIiwiaGlkZVNpZGViYXIiLCJkZXN0cm95UG9wdXAiLCJkaXNhYmxlQWxsIiwiaGlkZVN0YW5kYWxvbmVDb21tZW50QnV0dG9uIiwiYWRkU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24iLCJsb2FkU2lnbmF0dXJlcyIsImVuYWJsZUFsbCIsImdldEFubm90YXRpb25zQnlUeXBlIiwiZWRpdG9yQ2xhc3MiLCJfZWRpdG9yVHlwZSIsImVsZW1lbnRJZHMiLCJhbGxDb21tZW50cyIsImFubm90YXRpb25FbGVtZW50SWQiLCJoYXNDb21tZW50IiwiZGVsZXRlZCIsImFubm90YXRpb24iLCJwb3B1cFJlZiIsImNvbnRlbnRzT2JqIiwic2hvd1NpZGViYXIiLCJzZXRTZWxlY3RlZCIsImVudGVySW5FZGl0TW9kZSIsInVuc2VsZWN0IiwiY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IiLCJhZGROZXdFZGl0b3IiLCJ1cGRhdGVUb29sYmFyIiwiYWN0aW9uIiwidXBkYXRlRGVmYXVsdFBhcmFtcyIsInZpc2libGUiLCJ1cGRhdGVCdXR0b24iLCJlbmFibGVXYWl0aW5nIiwibXVzdFdhaXQiLCJkaXNhYmxlQ2xpY2siLCJlbmFibGVDbGljayIsInByb21pc2VzIiwiZ2V0RWRpdG9ycyIsImdldEVkaXRvciIsImFkZEVkaXRvciIsInJlbW92ZUVkaXRvciIsInNldFRpbWVvdXQiLCJhZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQiLCJhZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uIiwiaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQiLCJyZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQiLCJyZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uIiwiYWRkT3JSZWJ1aWxkIiwic2V0QWN0aXZlRWRpdG9yIiwicHJvcGVydGllc1RvVXBkYXRlIiwibGFzdFNlbGVjdGVkRWRpdG9yIiwiZWQiLCJ1cGRhdGVVSSIsInVwZGF0ZVVJRm9yRGVmYXVsdFByb3BlcnRpZXMiLCJ0b2dnbGVTZWxlY3RlZCIsInNlbGVjdCIsImZpcnN0U2VsZWN0ZWRFZGl0b3IiLCJjbGVhblVuZG9TdGFjayIsImRyYXdpbmdFZGl0b3IiLCJlbmREcmF3aW5nU2Vzc2lvbiIsImNvbW1pdCIsIm5vQ29tbWl0IiwidG90YWxYIiwidG90YWxZIiwiVElNRV9UT19XQUlUIiwidHJhbnNsYXRlSW5QYWdlIiwidHJhbnNsYXRpb25Eb25lIiwic2V0VXBEcmFnU2Vzc2lvbiIsInNhdmVkWCIsInNhdmVkWSIsInNhdmVkUGFnZUluZGV4IiwibmV3WCIsIm5ld1kiLCJuZXdQYWdlSW5kZXgiLCJlbmREcmFnU2Vzc2lvbiIsIm11c3RCZUFkZGVkSW5VbmRvU3RhY2siLCJtb3ZlIiwiX3NldFBhcmVudEFuZFBvc2l0aW9uIiwiZHJhZ1NlbGVjdGVkRWRpdG9ycyIsInR4IiwidHkiLCJkcmFnIiwicmVidWlsZCIsImNoYW5nZVBhcmVudCIsImdldEFjdGl2ZSIsInNob3VsZEdldEtleWJvYXJkRXZlbnRzIiwiaXNBY3RpdmUiLCJnZXRNb2RlIiwiaXNFZGl0aW5nTW9kZSIsImltYWdlTWFuYWdlciIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0IiwiY29tbW9uQW5jZXN0b3JDb250YWluZXIiLCJwYXJlbnRXaWR0aCIsInBhcmVudEhlaWdodCIsInJvdGF0b3IiLCJyYW5nZSIsImNvbGxhcHNlZCIsImdldENsaWVudFJlY3RzIiwicmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQiLCJlZGl0b3JJZCIsImhhc0JlZW5Nb2RpZmllZCIsInNldE1pc3NpbmdDYW52YXMiLCJzZXRDYW52YXMiLCJhZGRNaXNzaW5nQ2FudmFzIiwiQWx0VGV4dCIsImFsdFRleHREZWNvcmF0aXZlIiwiYWx0VGV4dEJ1dHRvbiIsImFsdFRleHRCdXR0b25MYWJlbCIsImFsdFRleHRUb29sdGlwIiwiYWx0VGV4dFRvb2x0aXBUaW1lb3V0IiwiYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCIsImJhZGdlIiwiZ3Vlc3NlZFRleHQiLCJ0ZXh0V2l0aERpc2NsYWltZXIiLCJsMTBuTmV3QnV0dG9uIiwiX2wxMG4iLCJhZGRlZCIsInJldmlldyIsImluaXRpYWxpemUiLCJsMTBuIiwibGFiZWwiLCJvbkNsaWNrIiwiX3JlcG9ydFRlbGVtZXRyeSIsInNldFN0YXRlIiwiZmluaXNoIiwiZm9jdXNWaXNpYmxlIiwiaGFzRGF0YSIsInNldEd1ZXNzZWRUZXh0IiwiZ2VuZXJhdGVkQWx0VGV4dCIsInRvZ2dsZUFsdFRleHRCYWRnZSIsImlzRm9yQ29weWluZyIsImRlY29yYXRpdmUiLCJjYW5jZWwiLCJlbmFibGVkIiwiZGlzYWJsZWQiLCJ0b29sdGlwIiwiREVMQVlfVE9fU0hPV19UT09MVElQIiwicGFyZW50Tm9kZSIsImdldEVsZW1lbnRGb3JBbHRUZXh0IiwiQ29tbWVudCIsImNvbW1lbnRTdGFuZGFsb25lQnV0dG9uIiwiY29tbWVudFRvb2xiYXJCdXR0b24iLCJjb21tZW50V2FzRnJvbUtleUJvYXJkIiwiaW5pdGlhbFRleHQiLCJyaWNoVGV4dCIsInBvcHVwUG9zaXRpb24iLCJyZW5kZXJGb3JTdGFuZGFsb25lIiwiY29tbWVudEJ1dHRvblBvc2l0aW9uIiwiY29tbWVudEJ1dHRvbkNvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiZm9jdXNCdXR0b24iLCJvblVwZGF0ZWRDb2xvciIsImNvbW1lbnRCdXR0b25XaWR0aCIsImJvdW5kaW5nQ2xpZW50UmVjdCIsImNvbW1lbnRQb3B1cFBvc2l0aW9uSW5MYXllciIsInBhcmVudFgiLCJwYXJlbnRZIiwiaGFzRGVmYXVsdFBvcHVwUG9zaXRpb24iLCJyZW1vdmVTdGFuZGFsb25lQ29tbWVudEJ1dHRvbiIsInNldENvbW1lbnRCdXR0b25TdGF0ZXMiLCJoYXNQb3B1cCIsImFyaWFFeHBhbmRlZCIsImlzU3RhbmRhbG9uZSIsImFyaWFIYXNQb3B1cCIsImFyaWFDb250cm9scyIsImFyaWFDb250cm9sc0VsZW1lbnRzIiwiZWRpdCIsInBhcmVudERpbWVuc2lvbnMiLCJpc0RlbGV0ZWQiLCJoYXNCZWVuRWRpdGVkIiwic2V0SW5pdGlhbFRleHQiLCJUb3VjaE1hbmFnZXIiLCJpc1BpbmNoaW5nIiwiaXNQaW5jaGluZ1N0b3BwZWQiLCJpc1BpbmNoaW5nRGlzYWJsZWQiLCJvblBpbmNoU3RhcnQiLCJvblBpbmNoaW5nIiwib25QaW5jaEVuZCIsInBvaW50ZXJEb3duQUMiLCJ0b3VjaEluZm8iLCJ0b3VjaE1hbmFnZXJBQyIsInRvdWNoTW92ZUFDIiwib25Ub3VjaFN0YXJ0IiwicGFzc2l2ZSIsIk1JTl9UT1VDSF9ESVNUQU5DRV9UT19QSU5DSCIsInRvdWNoZXMiLCJvcHRzIiwiY2FuY2VsUG9pbnRlckRvd24iLCJwb2ludGVyVHlwZSIsIm9wdCIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaEVuZCIsInRvdWNoMCIsInRvdWNoMSIsImlkZW50aWZpZXIiLCJ0b3VjaDBYIiwic2NyZWVuWCIsInRvdWNoMFkiLCJzY3JlZW5ZIiwidG91Y2gxWCIsInRvdWNoMVkiLCJzY3JlZW4wWCIsInNjcmVlbjBZIiwic2NyZWVuMVgiLCJzY3JlZW4xWSIsInBUb3VjaDBYIiwicFRvdWNoMFkiLCJwVG91Y2gxWCIsInBUb3VjaDFZIiwicHJldkdhcFgiLCJwcmV2R2FwWSIsImN1cnJHYXBYIiwiY3VyckdhcFkiLCJkaXN0YW5jZSIsImh5cG90IiwicERpc3RhbmNlIiwib3JpZ2luIiwiQW5ub3RhdGlvbkVkaXRvciIsImFjY2Vzc2liaWxpdHlEYXRhIiwiYWxsUmVzaXplckRpdnMiLCJkcmFnUG9pbnRlcklkIiwiZHJhZ1BvaW50ZXJUeXBlIiwicmVzaXplcnNEaXYiLCJsYXN0UG9pbnRlckNvb3JkcyIsInNhdmVkRGltZW5zaW9ucyIsImZha2VBbm5vdGF0aW9uIiwiZm9jdXNBQyIsImZvY3VzZWRSZXNpemVyTmFtZSIsImhhc0JlZW5DbGlja2VkIiwiaW5pdGlhbFJlY3QiLCJpc0luRWRpdE1vZGUiLCJpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQiLCJtb3ZlSW5ET01UaW1lb3V0IiwicHJldkRyYWdYIiwicHJldkRyYWdZIiwidGVsZW1ldHJ5VGltZW91dHMiLCJ0b3VjaE1hbmFnZXIiLCJfbDEwblJlc2l6ZXIiLCJpc0RyYWdnYWJsZSIsInpJbmRleCIsIl9ib3JkZXJMaW5lV2lkdGgiLCJfY29sb3JNYW5hZ2VyIiwiX3pJbmRleCIsIl90ZWxlbWV0cnlUaW1lb3V0IiwiX3Jlc2l6ZXJLZXlib2FyZE1hbmFnZXIiLCJyZXNpemUiLCJfcmVzaXplV2l0aEtleWJvYXJkIiwiX3N0b3BSZXNpemluZ1dpdGhLZXlib2FyZCIsIl9pc0NvcHkiLCJfZWRpdFRvb2xiYXIiLCJfaW5pdGlhbE9wdGlvbnMiLCJfaW5pdGlhbERhdGEiLCJfaXNWaXNpYmxlIiwiX3dpbGxLZWVwQXNwZWN0UmF0aW8iLCJpc0NlbnRlcmVkIiwiX3N0cnVjdFRyZWVQYXJlbnRJZCIsImNyZWF0aW9uRGF0ZSIsIm1vZGlmaWNhdGlvbkRhdGUiLCJwYWdlUm90YXRpb24iLCJwYWdlRGltZW5zaW9ucyIsInBhZ2VUcmFuc2xhdGlvbiIsImlzQXR0YWNoZWRUb0RPTSIsIl90eXBlIiwiaXNEcmF3ZXIiLCJfZGVmYXVsdExpbmVDb2xvciIsImRlbGV0ZUFubm90YXRpb25FbGVtZW50IiwiZmFrZUVkaXRvciIsIkZha2VFZGl0b3IiLCJnZXROZXh0SWQiLCJ0b3BNaWRkbGUiLCJ0b3BSaWdodCIsIm1pZGRsZVJpZ2h0IiwiYm90dG9tTWlkZGxlIiwiYm90dG9tTGVmdCIsIm1pZGRsZUxlZnQiLCJkb2N1bWVudEVsZW1lbnQiLCJwYXJzZUZsb2F0IiwiZ2V0UHJvcGVydHlWYWx1ZSIsIl92YWx1ZSIsIm1pbWUiLCJfaXNEcmFnZ2FibGUiLCJjZW50ZXIiLCJwYXJlbnRSb3RhdGlvbiIsImZpeEFuZFNldFBvc2l0aW9uIiwic2V0SW5CYWNrZ3JvdW5kIiwic2V0SW5Gb3JlZ3JvdW5kIiwic2V0UGFyZW50Iiwic3RvcFJlc2l6aW5nIiwiZm9jdXNpbiIsImZvY3Vzb3V0IiwicmVsYXRlZFRhcmdldCIsImlzTXVsdGlwbGVTZWxlY3Rpb24iLCJzZXRBdCIsInNjcmVlblRvUGFnZVRyYW5zbGF0aW9uIiwiX21vdmVBZnRlclBhc3RlIiwiYmFzZVgiLCJiYXNlWSIsIl9vblRyYW5zbGF0ZWQiLCJ0cmFuc2xhdGUiLCJfb25UcmFuc2xhdGluZyIsInNjcm9sbEludG9WaWV3IiwiYmxvY2siLCJmaW5kTmV3UGFyZW50IiwiYngiLCJieSIsImdldEJhc2VUcmFuc2xhdGlvbiIsImxlZnQiLCJ0b0ZpeGVkIiwiX2hhc0JlZW5Nb3ZlZCIsIl9oYXNCZWVuUmVzaXplZCIsIl9tdXN0Rml4UG9zaXRpb24iLCJtb3ZlSW5ET00iLCJyb3RhdGVQb2ludCIsImFuZ2xlIiwicGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4iLCJnZXRSb3RhdGlvbk1hdHJpeCIsInBhcmVudFNjYWxlIiwic2V0RGltcyIsImdldEluaXRpYWxUcmFuc2xhdGlvbiIsImNyZWF0ZVJlc2l6ZXJzIiwiY2xhc3NlcyIsInJlc2l6ZXJQb2ludGVyZG93biIsInByZXBlbmQiLCJzYXZlZERyYWdnYWJsZSIsInRvZ2dsZVBvaW50ZXJFdmVudHMiLCJyZXNpemVyUG9pbnRlcm1vdmUiLCJzYXZlZFdpZHRoIiwic2F2ZWRIZWlnaHQiLCJzYXZlZFBhcmVudEN1cnNvciIsImN1cnNvciIsInNhdmVkQ3Vyc29yIiwicG9pbnRlclVwQ2FsbGJhY2siLCJhZGRSZXNpemVUb1VuZG9TdGFjayIsIl9vblJlc2l6ZWQiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsIl9yb3VuZCIsIm1pbldpZHRoIiwiTUlOX1NJWkUiLCJtaW5IZWlnaHQiLCJyb3RhdGlvbk1hdHJpeCIsInRyYW5zZiIsImludlJvdGF0aW9uTWF0cml4IiwiaW52VHJhbnNmIiwiZ2V0UG9pbnQiLCJnZXRPcHBvc2l0ZSIsImlzRGlhZ29uYWwiLCJpc0hvcml6b250YWwiLCJwb2ludCIsIm9wcG9zaXRlUG9pbnQiLCJ0cmFuc2ZPcHBvc2l0ZVBvaW50Iiwib3Bwb3NpdGVYIiwib3Bwb3NpdGVZIiwicmF0aW9YIiwicmF0aW9ZIiwiZGVsdGFYIiwiZGVsdGFZIiwiZnJvbUtleWJvYXJkIiwibGFzdFNjcmVlblgiLCJsYXN0U2NyZWVuWSIsIm9sZERpYWciLCJfb25SZXNpemluZyIsImFsdFRleHRGaW5pc2giLCJ0b29sYmFyQnV0dG9ucyIsImFkZEVkaXRUb29sYmFyIiwiYWRkQ29tbWVudEJ1dHRvbiIsImFkZENvbW1lbnRCdXR0b25JblRvb2xiYXIiLCJyZW1vdmVDb21tZW50QnV0dG9uRnJvbVRvb2xiYXIiLCJyZW1vdmVFZGl0VG9vbGJhciIsImFkZENvbnRhaW5lciIsImVkaXRUb29sYmFyRGl2IiwiYmVmb3JlIiwiZ2V0Q2xpZW50RGltZW5zaW9ucyIsImNyZWF0ZUFsdFRleHQiLCJhbHRUZXh0RGF0YSIsImd1ZXNzZWRBbHRUZXh0Iiwic2V0R3Vlc3NlZEFsdFRleHQiLCJzZXJpYWxpemVBbHRUZXh0IiwiaGFzQWx0VGV4dCIsImhhc0FsdFRleHREYXRhIiwiZm9jdXNDb21tZW50QnV0dG9uIiwic2V0Q29tbWVudERhdGEiLCJ1cGRhdGVGcm9tQW5ub3RhdGlvbkxheWVyIiwiaGFzRWRpdGVkQ29tbWVudCIsImhhc0RlbGV0ZWRDb21tZW50Iiwic2V0U2VsZWN0ZWRDb21tZW50QnV0dG9uIiwic2V0U2VsZWN0ZWRCdXR0b24iLCJERUZBVUxUX1BPUFVQX1dJRFRIIiwiREVGQVVMVF9QT1BVUF9IRUlHSFQiLCJ0clkiLCJibFgiLCJibFkiLCJ0clgiLCJwb3B1cCIsImNvbnRlbnRzIiwicGFyZW50Qm91bmRpbmdDbGllbnRSZWN0IiwiZGVmYXVsdEwxMG5JZCIsImFkZEZvY3VzTGlzdGVuZXJzIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJ0b3VjaFBpbmNoU3RhcnRDYWxsYmFjayIsInRvdWNoUGluY2hDYWxsYmFjayIsInRvdWNoUGluY2hFbmRDYWxsYmFjayIsIl9vcmlnaW4iLCJwcmV2RGlzdGFuY2UiLCJzbG93RG93bkZhY3RvciIsImZhY3RvciIsInRyYW5zZkNlbnRlclBvaW50IiwibmV3VHJhbnNmQ2VudGVyUG9pbnQiLCJwb2ludGVyZG93biIsInNlbGVjdE9uUG9pbnRlckV2ZW50IiwiaGFzRHJhZ2dpbmdTdGFydGVkIiwiY2FuY2VsRHJhZyIsIl9vblN0b3BEcmFnZ2luZyIsImNsaWVudFgiLCJjbGllbnRZIiwicG9pbnRlcklkIiwiX29uU3RhcnREcmFnZ2luZyIsImlzUHJpbWFyeSIsIm1vdmVFZGl0b3JJbkRPTSIsImdldFJlY3QiLCJzaGlmdFgiLCJzaGlmdFkiLCJnZXRSZWN0SW5DdXJyZW50Q29vcmRzIiwiZ2V0UERGUmVjdCIsIm9uY2VBZGRlZCIsImVuYWJsZUVkaXRNb2RlIiwiZGlzYWJsZUVkaXRNb2RlIiwibmVlZHNUb0JlUmVidWlsdCIsImlzT25TY3JlZW4iLCJib3R0b20iLCJyaWdodCIsImlubmVySGVpZ2h0IiwiaW5uZXJXaWR0aCIsInJvdGF0ZSIsIl9hbmdsZSIsInNlcmlhbGl6ZURlbGV0ZWQiLCJhbm5vdGF0aW9uVHlwZSIsInN0cnVjdFRyZWVQYXJlbnRJZCIsImlzQ29weSIsInRpbWVvdXQiLCJtYWtlUmVzaXphYmxlIiwiY29tbWVudEJ1dHRvblBvc2l0aW9uSW5QYWdlIiwiY29tbWVudFBvcHVwUG9zaXRpb24iLCJlbGVtZW50QmVmb3JlUG9wdXAiLCJib3VuZFJlc2l6ZXJLZXlkb3duIiwicmVzaXplcktleWRvd24iLCJib3VuZFJlc2l6ZXJCbHVyIiwicmVzaXplckJsdXIiLCJyZXNpemVyRm9jdXMiLCJmaXJzdFBvc2l0aW9uIiwibmV4dEZpcnN0UG9zaXRpb24iLCJsYXN0Q2hpbGQiLCJzZXRSZXNpemVyVGFiSW5kZXgiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJwcmV2ZW50U2Nyb2xsIiwiZGlzYWJsZUVkaXRpbmciLCJlbmFibGVFZGl0aW5nIiwiY2FuQ2hhbmdlQ29udGVudCIsImRibGNsaWNrIiwibm9kZU5hbWUiLCJjb250ZW50RGl2IiwidGVsZW1ldHJ5SW5pdGlhbERhdGEiLCJ0ZWxlbWV0cnlGaW5hbERhdGEiLCJ1cGRhdGVGYWtlQW5ub3RhdGlvbkVsZW1lbnQiLCJhbm5vdGF0aW9uTGF5ZXIiLCJhZGRGYWtlQW5ub3RhdGlvbiIsInVwZGF0ZUVkaXRlZCIsInJlc2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJTRUVEIiwiTUFTS19ISUdIIiwiTUFTS19MT1ciLCJNdXJtdXJIYXNoM182NCIsInNlZWQiLCJoMSIsImgyIiwiYmxvY2tDb3VudHMiLCJ0YWlsTGVuZ3RoIiwiZGF0YVVpbnQzMiIsImsxIiwiazIiLCJDMSIsIkMyIiwiQzFfTE9XIiwiQzJfTE9XIiwiaGV4ZGlnZXN0IiwiU2VyaWFsaXphYmxlRW1wdHkiLCJBbm5vdGF0aW9uU3RvcmFnZSIsIm1vZGlmaWVkIiwibW9kaWZpZWRJZHMiLCJlZGl0b3JzTWFwIiwib25TZXRNb2RpZmllZCIsIm9uUmVzZXRNb2RpZmllZCIsIm9uQW5ub3RhdGlvbkVkaXRvciIsImRlZmF1bHRWYWx1ZSIsInJlc2V0TW9kaWZpZWQiLCJzZXRNb2RpZmllZCIsInByaW50IiwiUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSIsInNlcmlhbGl6YWJsZSIsImhhc0JpdG1hcCIsImVkaXRvclN0YXRzIiwic3RhdHMiLCJ0eXBlVG9FZGl0b3IiLCJudW1iZXJPZkVkaXRlZENvbW1lbnRzIiwibnVtYmVyT2ZEZWxldGVkQ29tbWVudHMiLCJpc0NvbW1lbnREZWxldGVkIiwiY291bnRlcnMiLCJjb21tZW50cyIsImVkaXRlZCIsImNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEiLCJyZXNldE1vZGlmaWVkSWRzIiwidXBkYXRlRWRpdG9yIiwiaWRzIiwiRm9udExvYWRlciIsInN5c3RlbUZvbnRzIiwib3duZXJEb2N1bWVudCIsInN0eWxlRWxlbWVudCIsIl9kb2N1bWVudCIsIm5hdGl2ZUZvbnRGYWNlcyIsImxvYWRpbmdSZXF1ZXN0cyIsImxvYWRUZXN0Rm9udElkIiwiYWRkTmF0aXZlRm9udEZhY2UiLCJuYXRpdmVGb250RmFjZSIsImZvbnRzIiwicmVtb3ZlTmF0aXZlRm9udEZhY2UiLCJpbnNlcnRSdWxlIiwicnVsZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwic3R5bGVTaGVldCIsInNoZWV0IiwiY3NzUnVsZXMiLCJsb2FkU3lzdGVtRm9udCIsInN5c3RlbUZvbnRJbmZvIiwiZGlzYWJsZUZvbnRGYWNlIiwiX2luc3BlY3RGb250IiwibG9hZGVkTmFtZSIsImlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQiLCJmb250RmFjZSIsIkZvbnRGYWNlIiwibG9hZCIsImJhc2VGb250TmFtZSIsImZvbnQiLCJhdHRhY2hlZCIsIm1pc3NpbmdGaWxlIiwiY3JlYXRlTmF0aXZlRm9udEZhY2UiLCJsb2FkZWQiLCJmYW1pbHkiLCJjcmVhdGVGb250RmFjZVJ1bGUiLCJpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCIsIl9xdWV1ZUxvYWRpbmdDYWxsYmFjayIsIl9wcmVwYXJlRm9udExvYWRFdmVudCIsImhhc0ZvbnRzIiwiY29tcGxldGVSZXF1ZXN0Iiwib3RoZXJSZXF1ZXN0IiwiY29tcGxldGUiLCJfbG9hZFRlc3RGb250IiwidGVzdEZvbnQiLCJpbnQzMiIsIm9mZnNldCIsInNwbGljZVN0cmluZyIsImluc2VydCIsImNodW5rMSIsImNodW5rMiIsImNhbGxlZCIsImlzRm9udFJlYWR5IiwiZmlsbFRleHQiLCJpbWFnZURhdGEiLCJDT01NRU5UX09GRlNFVCIsIkNGRl9DSEVDS1NVTV9PRkZTRVQiLCJYWFhYX1ZBTFVFIiwiY2hlY2tzdW0iLCJmb250RmFtaWx5IiwiRm9udEZhY2VPYmplY3QiLCJmb250RGF0YSIsInRyYW5zbGF0ZWREYXRhIiwiaW5zcGVjdEZvbnQiLCJleHRyYSIsImNoYXJQcm9jT3BlcmF0b3JMaXN0IiwiY29tcGlsZWRHbHlwaHMiLCJjc3NGb250SW5mbyIsImNzcyIsIndlaWdodCIsImZvbnRXZWlnaHQiLCJpdGFsaWNBbmdsZSIsIm1pbWV0eXBlIiwiZ2V0UGF0aEdlbmVyYXRvciIsIm9ianMiLCJjaGFyYWN0ZXIiLCJvYmpJZCIsImNtZHMiLCJwYXRoIiwiUGF0aDJEIiwiZm9udEV4dHJhUHJvcGVydGllcyIsImJsYWNrIiwiYm9sZCIsImlzSW52YWxpZFBERmpzRm9udCIsImlzVHlwZTNGb250IiwiaXRhbGljIiwicmVtZWFzdXJlIiwidmVydGljYWwiLCJhc2NlbnQiLCJkZWZhdWx0V2lkdGgiLCJkZXNjZW50IiwiYmJveCIsImZvbnRNYXRyaXgiLCJmYWxsYmFja05hbWUiLCJjbGVhckRhdGEiLCJkZWZhdWx0Vk1ldHJpY3MiLCJnZXRVcmxQcm9wIiwibG9jYXRpb24iLCJnZXREYXRhUHJvcCIsIkJ1ZmZlciIsImlzTmFOIiwiZ2V0RmFjdG9yeVVybFByb3AiLCJpc1JlZlByb3h5IiwiZ2VuIiwiaXNOYW1lUHJveHkiLCJpc1ZhbGlkRXhwbGljaXREZXN0IiwiTG9vcGJhY2tQb3J0IiwibGlzdGVuZXJzIiwiZGVmZXJyZWQiLCJsaXN0ZW5lciIsInJtQWJvcnQiLCJvbkFib3J0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInRlcm1pbmF0ZSIsIkNhbGxiYWNrS2luZCIsIkRBVEEiLCJFUlJPUiIsIlN0cmVhbUtpbmQiLCJDQU5DRUwiLCJDQU5DRUxfQ09NUExFVEUiLCJDTE9TRSIsIkVOUVVFVUUiLCJQVUxMIiwiUFVMTF9DT01QTEVURSIsIlNUQVJUX0NPTVBMRVRFIiwib25GbiIsIndyYXBSZWFzb24iLCJNZXNzYWdlSGFuZGxlciIsIm1lc3NhZ2VBQyIsInNvdXJjZU5hbWUiLCJ0YXJnZXROYW1lIiwiY29tT2JqIiwiY2FsbGJhY2tJZCIsInN0cmVhbUlkIiwic3RyZWFtU2lua3MiLCJzdHJlYW1Db250cm9sbGVycyIsImNhbGxiYWNrQ2FwYWJpbGl0aWVzIiwiYWN0aW9uSGFuZGxlciIsIm9uTWVzc2FnZSIsInN0cmVhbSIsInByb2Nlc3NTdHJlYW1NZXNzYWdlIiwiY2FwYWJpbGl0eSIsInRyeSIsImNyZWF0ZVN0cmVhbVNpbmsiLCJhY3Rpb25OYW1lIiwiaGFuZGxlciIsImFoIiwidHJhbnNmZXJzIiwic2VuZFdpdGhQcm9taXNlIiwic2VuZFdpdGhTdHJlYW0iLCJxdWV1ZWluZ1N0cmF0ZWd5IiwiUmVhZGFibGVTdHJlYW0iLCJjb250cm9sbGVyIiwic3RhcnRDYXBhYmlsaXR5Iiwic3RhcnRDYWxsIiwicHVsbENhbGwiLCJjYW5jZWxDYWxsIiwiaXNDbG9zZWQiLCJkZXNpcmVkU2l6ZSIsInB1bGwiLCJwdWxsQ2FwYWJpbGl0eSIsImNhbmNlbENhcGFiaWxpdHkiLCJzdHJlYW1TaW5rIiwiZW5xdWV1ZSIsImlzQ2FuY2VsbGVkIiwibGFzdERlc2lyZWRTaXplIiwic2lua0NhcGFiaWxpdHkiLCJyZWFkeSIsIm9uUHVsbCIsIm9uQ2FuY2VsIiwic3VjY2VzcyIsInN0cmVhbUNvbnRyb2xsZXIiLCJkZWxldGVTdHJlYW1Db250cm9sbGVyIiwiZGF0YVJlYXNvbiIsImFsbFNldHRsZWQiLCJCYXNlQ2FudmFzRmFjdG9yeSIsImVuYWJsZUhXQSIsIl9jcmVhdGVDYW52YXMiLCJyZXNldCIsImNhbnZhc0FuZENvbnRleHQiLCJET01DYW52YXNGYWN0b3J5IiwiQmFzZUNNYXBSZWFkZXJGYWN0b3J5IiwiaXNDb21wcmVzc2VkIiwiX2ZldGNoIiwiY01hcERhdGEiLCJjYXRjaCIsIkRPTUNNYXBSZWFkZXJGYWN0b3J5IiwiZXNfaXRlcmF0b3JfZmlsdGVyIiwiQmFzZUZpbHRlckZhY3RvcnkiLCJhZGRGaWx0ZXIiLCJtYXBzIiwiZmdDb2xvciIsImJnQ29sb3IiLCJhZGRBbHBoYUZpbHRlciIsImFkZEx1bWlub3NpdHlGaWx0ZXIiLCJhZGRIaWdobGlnaHRIQ01GaWx0ZXIiLCJmaWx0ZXJOYW1lIiwibmV3RmdDb2xvciIsIm5ld0JnQ29sb3IiLCJrZWVwSENNIiwiRE9NRmlsdGVyRmFjdG9yeSIsIl9jYWNoZSIsIl9kZWZzIiwiZG9jSWQiLCJfaGNtQ2FjaGUiLCJoY21DYWNoZSIsImRlZnMiLCJjb250YWluIiwiY3JlYXRlVGFibGVzIiwibWFwUiIsInRhYmxlIiwibWFwRyIsIm1hcEIiLCJidWZmZXJSIiwiYnVmZmVyRyIsImJ1ZmZlckIiLCJjcmVhdGVVcmwiLCJ0YWJsZVIiLCJ0YWJsZUciLCJ0YWJsZUIiLCJjcmVhdGVGaWx0ZXIiLCJhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24iLCJmZ1JHQiIsImJnUkdCIiwiYWRkR3JheUNvbnZlcnNpb24iLCJnZXRTdGVwcyIsInRhYmxlQSIsImFkZFRyYW5zZmVyTWFwQWxwaGFDb252ZXJzaW9uIiwiYWRkTHVtaW5vc2l0eUNvbnZlcnNpb24iLCJmZ0dyYXkiLCJiZ0dyYXkiLCJuZXdGZ1JHQiIsIm5ld0JnUkdCIiwiZmciLCJiZyIsIm5ld1N0YXJ0IiwibmV3U3RlcCIsInByZXYiLCJmZUNvbG9yTWF0cml4IiwiYXBwZW5kRmVGdW5jIiwiZmVDb21wb25lbnRUcmFuc2ZlciIsImZlRnVuYyIsInJUYWJsZSIsImdUYWJsZSIsImJUYWJsZSIsImFUYWJsZSIsIkJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIkRPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwiQmFzZVdhc21GYWN0b3J5IiwiRE9NV2FzbUZhY3RvcnkiLCJyZXF1aXJlIiwiY3JlYXRlUmVxdWlyZSIsIkRPTU1hdHJpeCIsIkltYWdlRGF0YSIsImxhbmd1YWdlIiwibm9kZV91dGlsc19mZXRjaERhdGEiLCJmcyIsInJlYWRGaWxlIiwiTm9kZUZpbHRlckZhY3RvcnkiLCJOb2RlQ2FudmFzRmFjdG9yeSIsImNyZWF0ZUNhbnZhcyIsIk5vZGVDTWFwUmVhZGVyRmFjdG9yeSIsIk5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIk5vZGVXYXNtRmFjdG9yeSIsImVzX2l0ZXJhdG9yX2Zvcl9lYWNoIiwiRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUwiLCJleHBhbmRCQm94IiwibWluWCIsIm1pblkiLCJtYXhYIiwibWF4WSIsIkVNUFRZX0JCT1giLCJCQm94UmVhZGVyIiwiYmJveGVzIiwiY29vcmRzIiwiZW5zdXJlRGVidWdNZXRhZGF0YSIsImRlcGVuZGVuY2llcyIsImlzUmVuZGVyaW5nT3BlcmF0aW9uIiwiQ2FudmFzRGVwZW5kZW5jeVRyYWNrZXIiLCJpbmNyZW1lbnRhbCIsIm5hbWVkRGVwZW5kZW5jaWVzIiwic2F2ZXNTdGFjayIsIm1hcmtlZENvbnRlbnRTdGFjayIsImJhc2VUcmFuc2Zvcm1TdGFjayIsImNsaXBCb3giLCJwZW5kaW5nQkJveCIsInBlbmRpbmdCQm94SWR4IiwicGVuZGluZ0RlcGVuZGVuY2llcyIsIm9wZXJhdGlvbnMiLCJmb250QkJveFRydXN0d29ydGh5IiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJiYm94ZXNDb29yZHMiLCJkZWJ1Z01ldGFkYXRhIiwib3BlcmF0aW9uc0NvdW50IiwicmVjb3JkRGVidWdNZXRhZGF0YSIsInNhbWVMaW5lVGV4dCIsImluaXRpYWxpemVCQm94ZXMiLCJncm93T3BlcmF0aW9uc0NvdW50Iiwib2xkQkJveGVzIiwib3BJZHgiLCJwcmV2aW91cyIsImxhc3RTYXZlIiwicmVjb3JkT3Blbk1hcmtlciIsImlkeCIsImdldE9wZW5NYXJrZXIiLCJyZWNvcmRDbG9zZU1hcmtlciIsInB1c2hCYXNlVHJhbnNmb3JtIiwicG9wQmFzZVRyYW5zZm9ybSIsInJlY29yZFNpbXBsZURhdGEiLCJyZWNvcmRJbmNyZW1lbnRhbERhdGEiLCJyZXNldEluY3JlbWVudGFsRGF0YSIsInJlY29yZE5hbWVkRGF0YSIsInJlY29yZFNpbXBsZURhdGFGcm9tTmFtZWQiLCJkZXBOYW1lIiwiZmFsbGJhY2tJZHgiLCJyZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5IiwiaW5oZXJpdFNpbXBsZURhdGFBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcyIsImluaGVyaXRQZW5kaW5nRGVwZW5kZW5jaWVzQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMiLCJkZXAiLCJyZXNldEJCb3giLCJyZWNvcmRDbGlwQm94IiwicmVjb3JkQkJveCIsInJlY29yZENoYXJhY3RlckJCb3giLCJnZXRNZWFzdXJlIiwiZm9udEJCb3giLCJpc0JCb3hUcnVzdHdvcnRoeSIsImNvbXB1dGVkQkJveCIsInJlY29yZEZ1bGxQYWdlQkJveCIsIm1lYXN1cmUiLCJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCJhY3R1YWxCb3VuZGluZ0JveFJpZ2h0IiwiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCJhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQiLCJnZXRTaW1wbGVJbmRleCIsImRlcGVuZGVuY3lOYW1lIiwicmVjb3JkRGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jeU5hbWVzIiwicmVjb3JkTmFtZWREZXBlbmRlbmN5IiwicmVjb3JkT3BlcmF0aW9uIiwicHJlc2VydmUiLCJkZXBJZHgiLCJzYXZlSWR4IiwicmVjb3JkU2hvd1RleHRPcGVyYXRpb24iLCJkZXBzIiwiYmJveFRvQ2xpcEJveERyb3BPcGVyYXRpb24iLCJfdGFrZVBlbmRpbmdEZXBlbmRlbmNpZXMiLCJfZXh0cmFjdE9wZXJhdGlvbiIsIm9wZXJhdGlvbiIsIl9wdXNoUGVuZGluZ0RlcGVuZGVuY2llcyIsInRha2VEZWJ1Z01ldGFkYXRhIiwiQ2FudmFzTmVzdGVkRGVwZW5kZW5jeVRyYWNrZXIiLCJkZXBlbmRlbmN5VHJhY2tlciIsImlnbm9yZUJCb3hlcyIsIm5lc3RpbmdMZXZlbCIsInNhdmVzTGV2ZWwiLCJEZXBlbmRlbmNpZXMiLCJpbWFnZVhPYmplY3QiLCJ0cmFuc2Zvcm1BbmRGaWxsIiwiUGF0aFR5cGUiLCJTSEFESU5HIiwiYXBwbHlCb3VuZGluZ0JveCIsInJlZ2lvbiIsIkJhc2VTaGFkaW5nUGF0dGVybiIsImlzTW9kaWZ5aW5nQ3VycmVudFRyYW5zZm9ybSIsImdldFBhdHRlcm4iLCJSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuIiwiSVIiLCJfYmJveCIsIl9jb2xvclN0b3BzIiwiX3AwIiwiX3AxIiwiX3IwIiwiX3IxIiwiX2NyZWF0ZUdyYWRpZW50IiwiZ3JhZCIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJjb2xvclN0b3AiLCJhZGRDb2xvclN0b3AiLCJvd25lciIsInBhdGhUeXBlIiwicGF0dGVybiIsIm93bmVyQkJveCIsImdldENsaXBwZWRQYXRoQm91bmRpbmdCb3giLCJ0bXBDYW52YXMiLCJjYWNoZWRDYW52YXNlcyIsImdldENhbnZhcyIsInRtcEN0eCIsImNsZWFyUmVjdCIsImJlZ2luUGF0aCIsImJhc2VUcmFuc2Zvcm0iLCJmaWxsU3R5bGUiLCJjcmVhdGVQYXR0ZXJuIiwiZG9tTWF0cml4Iiwic2V0VHJhbnNmb3JtIiwiZHJhd1RyaWFuZ2xlIiwicDMiLCJjMSIsImMyIiwiYzMiLCJyb3dTaXplIiwic2NhbGVYIiwic2NhbGVZIiwiYzFyIiwiYzFnIiwiYzFiIiwiYzJyIiwiYzJnIiwiYzJiIiwiYzNyIiwiYzNnIiwiYzNiIiwieGEiLCJjYXIiLCJjYWciLCJjYWIiLCJ4YiIsImNiciIsImNiZyIsImNiYiIsIngxXyIsIngyXyIsImRyYXdGaWd1cmUiLCJmaWd1cmUiLCJwcyIsImNzIiwidmVydGljZXNQZXJSb3ciLCJyb3dzIiwiY29scyIsInEiLCJNZXNoU2hhZGluZ1BhdHRlcm4iLCJfY29vcmRzIiwiX2ZpZ3VyZXMiLCJfYm91bmRzIiwiX2JhY2tncm91bmQiLCJfY3JlYXRlTWVzaENhbnZhcyIsImNvbWJpbmVkU2NhbGUiLCJFWFBFQ1RFRF9TQ0FMRSIsIk1BWF9QQVRURVJOX1NJWkUiLCJCT1JERVJfU0laRSIsImJvdW5kc1dpZHRoIiwiYm91bmRzSGVpZ2h0IiwicGFkZGVkV2lkdGgiLCJwYWRkZWRIZWlnaHQiLCJjcmVhdGVJbWFnZURhdGEiLCJwdXRJbWFnZURhdGEiLCJtYXRyaXhTY2FsZVgiLCJtYXRyaXhTY2FsZVkiLCJ0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzIiwiRHVtbXlTaGFkaW5nUGF0dGVybiIsImdldFNoYWRpbmdQYXR0ZXJuIiwiUGFpbnRUeXBlIiwiQ09MT1JFRCIsIlVOQ09MT1JFRCIsIlRpbGluZ1BhdHRlcm4iLCJjYW52YXNHcmFwaGljc0ZhY3RvcnkiLCJvcGVyYXRvckxpc3QiLCJ4c3RlcCIsInlzdGVwIiwicGFpbnRUeXBlIiwidGlsaW5nVHlwZSIsImNyZWF0ZVBhdHRlcm5DYW52YXMiLCJjb21iaW5lZFNjYWxlWCIsImNvbWJpbmVkU2NhbGVZIiwicmVkcmF3SG9yaXpvbnRhbGx5IiwicmVkcmF3VmVydGljYWxseSIsInhTY2FsZWRTdGVwIiwieVNjYWxlZFN0ZXAiLCJ4U2NhbGVkV2lkdGgiLCJ5U2NhbGVkSGVpZ2h0IiwiZGlteCIsImdldFNpemVBbmRTY2FsZSIsImRpbXkiLCJncmFwaGljcyIsImNyZWF0ZUNhbnZhc0dyYXBoaWNzIiwiZ3JvdXBMZXZlbCIsInNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dCIsImNsaXBCYm94IiwiZXhlY3V0ZU9wZXJhdG9yTGlzdCIsImVuZERyYXdpbmciLCJkaW14MiIsImRpbXkyIiwieFNpemUiLCJ5U2l6ZSIsInRtcENhbnZhczIiLCJ0bXBDdHgyIiwiamoiLCJyZWFsT3V0cHV0U2l6ZSIsImJib3hXaWR0aCIsImJib3hIZWlnaHQiLCJzdHJva2VTdHlsZSIsImZpbGxDb2xvciIsInN0cm9rZUNvbG9yIiwiY29udmVydFRvUkdCQSIsIkltYWdlS2luZCIsImNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBIiwiY29udmVydFJHQlRvUkdCQSIsInNyY1BvcyIsIm5vbkJsYWNrQ29sb3IiLCJpbnZlcnNlRGVjb2RlIiwiemVyb01hcHBpbmciLCJvbmVNYXBwaW5nIiwid2lkdGhJblNvdXJjZSIsIndpZHRoUmVtYWluZGVyIiwic3JjTGVuZ3RoIiwiZGVzdFBvcyIsImVsZW0iLCJsZW4zMiIsInNyYzMyIiwiRmVhdHVyZVRlc3QiLCJzMSIsInMyIiwiczMiLCJncmF5VG9SR0JBIiwiTUlOX0ZPTlRfU0laRSIsIk1BWF9GT05UX1NJWkUiLCJFWEVDVVRJT05fVElNRSIsIkVYRUNVVElPTl9TVEVQUyIsIkZVTExfQ0hVTktfSEVJR0hUIiwiU0NBTEVfTUFUUklYIiwiWFkiLCJNSU5fTUFYX0lOSVQiLCJtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyIsImRlc3RDdHgiLCJfcmVtb3ZlTWlycm9yaW5nIiwiX19vcmlnaW5hbFNhdmUiLCJfX29yaWdpbmFsUmVzdG9yZSIsIl9fb3JpZ2luYWxSb3RhdGUiLCJfX29yaWdpbmFsU2NhbGUiLCJfX29yaWdpbmFsVHJhbnNsYXRlIiwiX19vcmlnaW5hbFRyYW5zZm9ybSIsIl9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0iLCJfX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm0iLCJyZXNldFRyYW5zZm9ybSIsIl9fb3JpZ2luYWxDbGlwIiwiX19vcmlnaW5hbE1vdmVUbyIsIl9fb3JpZ2luYWxMaW5lVG8iLCJfX29yaWdpbmFsQmV6aWVyQ3VydmVUbyIsImJlemllckN1cnZlVG8iLCJfX29yaWdpbmFsUmVjdCIsIl9fb3JpZ2luYWxDbG9zZVBhdGgiLCJfX29yaWdpbmFsQmVnaW5QYXRoIiwiY3AxeCIsImNwMXkiLCJjcDJ4IiwiY3AyeSIsIkNhY2hlZENhbnZhc2VzIiwiY2FudmFzRmFjdG9yeSIsImNhbnZhc0VudHJ5IiwiZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzIiwic3JjSW1nIiwic3JjWCIsInNyY1kiLCJzcmNXIiwic3JjSCIsImRlc3RYIiwiZGVzdFkiLCJkZXN0VyIsImRlc3RIIiwidGxYIiwiclRsWCIsInRsWSIsInJUbFkiLCJiclgiLCJyV2lkdGgiLCJiclkiLCJySGVpZ2h0IiwiQ2FudmFzRXh0cmFTdGF0ZSIsInByZUluaXQiLCJhbHBoYUlzU2hhcGUiLCJmb250U2l6ZSIsImZvbnRTaXplU2NhbGUiLCJ0ZXh0TWF0cml4IiwidGV4dE1hdHJpeFNjYWxlIiwibGVhZGluZyIsImxpbmVYIiwibGluZVkiLCJjaGFyU3BhY2luZyIsIndvcmRTcGFjaW5nIiwidGV4dEhTY2FsZSIsInRleHRSZW5kZXJpbmdNb2RlIiwidGV4dFJpc2UiLCJwYXR0ZXJuRmlsbCIsInBhdHRlcm5TdHJva2UiLCJmaWxsQWxwaGEiLCJzdHJva2VBbHBoYSIsImxpbmVXaWR0aCIsImFjdGl2ZVNNYXNrIiwidHJhbnNmZXJNYXBzIiwiZ2V0UGF0aEJvdW5kaW5nQm94IiwieFN0cm9rZVBhZCIsInlTdHJva2VQYWQiLCJ1cGRhdGVDbGlwRnJvbVBhdGgiLCJzdGFydE5ld1BhdGhBbmRDbGlwQm94IiwiaXNFbXB0eUNsaXAiLCJwdXRCaW5hcnlJbWFnZURhdGEiLCJpbWdEYXRhIiwicGFydGlhbENodW5rSGVpZ2h0IiwiZnVsbENodW5rcyIsInRvdGFsQ2h1bmtzIiwiY2h1bmtJbWdEYXRhIiwidGhpc0NodW5rSGVpZ2h0IiwiZWxlbXNJblRoaXNDaHVuayIsImRlc3QzMiIsImRlc3QzMkRhdGFMZW5ndGgiLCJmdWxsU3JjRGlmZiIsInNyY0RpZmYiLCJrRW5kIiwia0VuZFVucm9sbGVkIiwibWFzayIsInNyY0J5dGUiLCJwdXRCaW5hcnlJbWFnZU1hc2siLCJjb3B5Q3R4U3RhdGUiLCJzb3VyY2VDdHgiLCJwcm9wZXJ0aWVzIiwic2V0TGluZURhc2giLCJnZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwicmVzZXRDdHhUb0RlZmF1bHQiLCJmaWxsUnVsZSIsImdsb2JhbEFscGhhIiwibGluZUNhcCIsImxpbmVKb2luIiwibWl0ZXJMaW1pdCIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsImdldEltYWdlU21vb3RoaW5nRW5hYmxlZCIsImludGVycG9sYXRlIiwiYWN0dWFsU2NhbGUiLCJmcm91bmQiLCJMSU5FX0NBUF9TVFlMRVMiLCJMSU5FX0pPSU5fU1RZTEVTIiwiTk9STUFMX0NMSVAiLCJFT19DTElQIiwiQ2FudmFzR3JhcGhpY3MiLCJjYW52YXNDdHgiLCJjb21tb25PYmpzIiwib3B0aW9uYWxDb250ZW50Q29uZmlnIiwiYW5ub3RhdGlvbkNhbnZhc01hcCIsInN0YXRlU3RhY2siLCJwZW5kaW5nQ2xpcCIsInBlbmRpbmdFT0ZpbGwiLCJ4b2JqcyIsImdyb3VwU3RhY2siLCJzbWFza1N0YWNrIiwic21hc2tDb3VudGVyIiwidGVtcFNNYXNrIiwic3VzcGVuZGVkQ3R4IiwiY29udGVudFZpc2libGUiLCJjYWNoZWRQYXR0ZXJucyIsInZpZXdwb3J0U2NhbGUiLCJvdXRwdXRTY2FsZVgiLCJvdXRwdXRTY2FsZVkiLCJfY2FjaGVkU2NhbGVGb3JTdHJva2luZyIsIl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoIiwiX2NhY2hlZEJpdG1hcHNNYXAiLCJnZXRPYmplY3QiLCJmYWxsYmFjayIsImJlZ2luRHJhd2luZyIsInRyYW5zcGFyZW5jeSIsInNhdmVkRmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ0cmFuc3BhcmVudENhbnZhcyIsImNvbXBvc2l0ZUN0eCIsImV4ZWN1dGlvblN0YXJ0SWR4IiwiY29udGludWVDYWxsYmFjayIsInN0ZXBwZXIiLCJvcGVyYXRpb25zRmlsdGVyIiwiYXJnc0FycmF5IiwiZm5BcnJheSIsImFyZ3NBcnJheUxlbiIsImNodW5rT3BlcmF0aW9ucyIsImVuZFRpbWUiLCJzdGVwcyIsImZuSWQiLCJmbkFyZ3MiLCJuZXh0QnJlYWtQb2ludCIsImJyZWFrSXQiLCJkZXBPYmpJZCIsIm9ianNQb29sIiwicmVzdG9yZUluaXRpYWxTdGF0ZSIsImluU01hc2tNb2RlIiwiSFRNTENhbnZhc0VsZW1lbnQiLCJkcmF3RmlsdGVyIiwiaGNtRmlsdGVySWQiLCJzYXZlZEZpbHRlciIsIl9zY2FsZUltYWdlIiwiaW1nIiwiZGlzcGxheVdpZHRoIiwiZGlzcGxheUhlaWdodCIsIndpZHRoU2NhbGUiLCJoZWlnaHRTY2FsZSIsInBhaW50V2lkdGgiLCJwYWludEhlaWdodCIsInRtcENhbnZhc0lkIiwiX2NyZWF0ZU1hc2tDYW52YXMiLCJpc1BhdHRlcm5GaWxsIiwiY3VycmVudFRyYW5zZm9ybSIsImNhY2hlS2V5IiwibWFza0NhbnZhcyIsIm1haW5LZXkiLCJjYWNoZWRJbWFnZSIsIm1hc2tUb0NhbnZhcyIsImRyYXduV2lkdGgiLCJkcmF3bkhlaWdodCIsImZpbGxDYW52YXMiLCJmaWxsQ3R4IiwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwiZGFzaEFycmF5IiwiZGFzaFBoYXNlIiwiZmxhdG5lc3MiLCJzdGF0ZXMiLCJjaGVja1NNYXNrU3RhdGUiLCJiZWdpblNNYXNrTW9kZSIsImVuZFNNYXNrTW9kZSIsImNhY2hlSWQiLCJzY3JhdGNoQ2FudmFzIiwiY29tcG9zZSIsImRpcnR5Qm94Iiwic21hc2siLCJjb21wb3NlU01hc2siLCJsYXllckN0eCIsImxheWVyQm94IiwibGF5ZXJPZmZzZXRYIiwibGF5ZXJPZmZzZXRZIiwibGF5ZXJXaWR0aCIsImxheWVySGVpZ2h0IiwiZ2VuZXJpY0NvbXBvc2VTTWFzayIsInN1YnR5cGUiLCJiYWNrZHJvcCIsInRyYW5zZmVyTWFwIiwibWFza0N0eCIsIm1hc2tPZmZzZXRYIiwibWFza09mZnNldFkiLCJtYXNrWCIsIm1hc2tZIiwib2xkIiwib3AiLCJvdXRlckV4dHJhU2l6ZSIsInBhdGgyZCIsIl9wYXRoU3RhcnRJZHgiLCJjb25zdW1lUGF0aCIsIm5ld1BhdGgiLCJhZGRQYXRoIiwibXVsdGlwbHlTZWxmIiwicmVzY2FsZUFuZFN0cm9rZSIsIm5lZWRSZXN0b3JlIiwicGF0aHMiLCJwZW5kaW5nVGV4dFBhdGhzIiwicHJlTXVsdGlwbHlTZWxmIiwic3BhY2luZyIsImZvbnRSZWZOYW1lIiwiZm9udE9iaiIsImZvbnREaXJlY3Rpb24iLCJ0eXBlZmFjZSIsImJyb3dzZXJGb250U2l6ZSIsInJpc2UiLCJnZXRTY2FsZWRQYXRoIiwicGFpbnRDaGFyIiwicGF0dGVybkZpbGxUcmFuc2Zvcm0iLCJwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtIiwiZmlsbFN0cm9rZU1vZGUiLCJpc0FkZFRvUGF0aFNldCIsInNjYWxlZFBhdGgiLCJpbnZQYXR0ZXJuVHJhbnNmb3JtIiwibWVhc3VyZVRleHQiLCJzdHJva2VUZXh0IiwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWQiLCJnbHlwaHMiLCJzaG93VHlwZTNUZXh0IiwiZ2x5cGhzTGVuZ3RoIiwic3BhY2luZ0RpciIsIndpZHRoQWR2YW5jZVNjYWxlIiwic2ltcGxlRmlsbFRleHQiLCJnZXRTaW5nbGVQaXhlbFdpZHRoIiwiY2hhcnMiLCJnbHlwaCIsInVuaWNvZGUiLCJqb2luZWRDaGFycyIsInJlc3RvcmVOZWVkZWQiLCJpc1NwYWNlIiwiZm9udENoYXIiLCJhY2NlbnQiLCJzY2FsZWRYIiwic2NhbGVkWSIsInZtZXRyaWMiLCJ2eCIsInZ5IiwibWVhc3VyZWRXaWR0aCIsImNoYXJhY3RlclNjYWxlWCIsImlzSW5Gb250Iiwic2NhbGVkQWNjZW50WCIsInNjYWxlZEFjY2VudFkiLCJjaGFyV2lkdGgiLCJpc1RleHRJbnZpc2libGUiLCJzcGFjaW5nTGVuZ3RoIiwib3BlcmF0b3JMaXN0SWQiLCJ4V2lkdGgiLCJ5V2lkdGgiLCJsbHgiLCJsbHkiLCJ1cngiLCJ1cnkiLCJnZXRDb2xvck5fUGF0dGVybiIsInJlbmRlcmluZ09wSWR4IiwiX2dldFBhdHRlcm4iLCJpbnYiLCJncm91cCIsImN1cnJlbnRDdHgiLCJpc29sYXRlZCIsImtub2Nrb3V0IiwiYm91bmRzIiwiY2FudmFzQm91bmRzIiwiZ3JvdXBDdHgiLCJzdGFydFRyYW5zZm9ybUludmVyc2UiLCJjdXJyZW50TXR4IiwiaGFzT3duQ2FudmFzIiwiYW5ub3RhdGlvbkNhbnZhcyIsInNhdmVkQ3R4Iiwic2tld1giLCJza2V3WSIsInBvc2l0aW9ucyIsInRyYW5zIiwiaW1hZ2VzIiwiYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyIsImFwcGx5VHJhbnNmZXJNYXBzVG9CaXRtYXAiLCJpbWdUb1BhaW50IiwiSFRNTEVsZW1lbnQiLCJpc1Zpc2libGUiLCJpc0NvbnRlbnRWaXNpYmxlIiwiYWJzRGV0Iiwibm9ybVgiLCJub3JtWSIsImdldFNjYWxlRm9yU3Ryb2tpbmciLCJzY2FsZWRMaW5lV2lkdGgiLCJzY2FsZWRYTGluZVdpZHRoIiwic2NhbGVkWUxpbmVXaWR0aCIsImJhc2VBcmVhIiwic2F2ZVJlc3RvcmUiLCJkYXNoZXMiLCJDc3NGb250SW5mbyIsInZpZXciLCJzdHJpbmdzIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlZFN0cmluZ3MiLCJzdHJpbmdzTGVuZ3RoIiwiZW5jb2RlZCIsImVuY29kZSIsInNldFVpbnQzMiIsInJlYWRTdHJpbmciLCJnZXRVaW50MzIiLCJTeXN0ZW1Gb250SW5mbyIsImVuY29kZWRTdHlsZVN0eWxlIiwiZW5jb2RlZFN0eWxlV2VpZ2h0IiwibGVuZ3RoRXN0aW1hdGUiLCJzZXRVaW50OCIsImd1ZXNzRmFsbGJhY2siLCJnZXRVaW50OCIsInN0eWxlTGVuZ3RoIiwid2VpZ2h0TGVuZ3RoIiwiRm9udEluZm8iLCJib29scyIsIk9GRlNFVF9OVU1CRVJTIiwiT0ZGU0VUX0JCT1giLCJPRkZTRVRfRk9OVF9NQVRSSVgiLCJPRkZTRVRfREVGQVVMVF9WTUVUUklDUyIsIk9GRlNFVF9TVFJJTkdTIiwicmVhZEJvb2xlYW4iLCJieXRlT2Zmc2V0IiwiYml0T2Zmc2V0IiwicmVhZE51bWJlciIsImdldEZsb2F0NjQiLCJudW1Db29yZHMiLCJnZXRJbnQxNiIsIm51bVBvaW50cyIsIm51bU1ldHJpY3MiLCJzdHJpbmdEYXRhIiwic3lzdGVtRm9udEluZm9MZW5ndGgiLCJjc3NGb250SW5mb0xlbmd0aCIsImNzc0ZvbnRJbmZvRGF0YSIsInN5c3RlbUZvbnRJbmZvRGF0YSIsInN5c3RlbUZvbnRJbmZvQnVmZmVyIiwiY3NzRm9udEluZm9CdWZmZXIiLCJudW1Cb29scyIsImJvb2xCeXRlIiwiYm9vbEJpdCIsImJpdHMiLCJzZXRGbG9hdDY0IiwiY29vcmQiLCJzZXRJbnQxNiIsIm1ldHJpYyIsIkdsb2JhbFdvcmtlck9wdGlvbnMiLCJwb3J0Iiwid29ya2VyUG9ydCIsIldvcmtlciIsIndvcmtlclNyYyIsIk1ldGFkYXRhIiwicGFyc2VkRGF0YSIsImdldFJhdyIsIklOVEVSTkFMIiwiT3B0aW9uYWxDb250ZW50R3JvdXAiLCJpc0Rpc3BsYXkiLCJpc1ByaW50IiwidXNlclNldCIsInJlbmRlcmluZ0ludGVudCIsInVzYWdlIiwicmJHcm91cHMiLCJ2aWV3U3RhdGUiLCJwcmludFN0YXRlIiwiX3NldFZpc2libGUiLCJpbnRlcm5hbCIsIk9wdGlvbmFsQ29udGVudENvbmZpZyIsImNhY2hlZEdldEhhc2giLCJncm91cHMiLCJpbml0aWFsSGFzaCIsIm9yZGVyIiwiY3JlYXRvciIsImJhc2VTdGF0ZSIsIm9mZiIsImdldEhhc2giLCJldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uIiwib3BlcmF0b3IiLCJleHByZXNzaW9uIiwicG9saWN5Iiwic2V0VmlzaWJpbGl0eSIsInByZXNlcnZlUkIiLCJyYkdyb3VwIiwib3RoZXJJZCIsInNldE9DR1N0YXRlIiwiaGFzSW5pdGlhbFZpc2liaWxpdHkiLCJnZXRPcmRlciIsImdldEdyb3VwIiwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbSIsInBkZkRhdGFSYW5nZVRyYW5zcG9ydCIsImRpc2FibGVSYW5nZSIsImRpc2FibGVTdHJlYW0iLCJpbml0aWFsRGF0YSIsInByb2dyZXNzaXZlRG9uZSIsImNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lIiwiX3F1ZXVlZENodW5rcyIsIl9wcm9ncmVzc2l2ZURvbmUiLCJfY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUiLCJfcGRmRGF0YVJhbmdlVHJhbnNwb3J0IiwiX2lzU3RyZWFtaW5nU3VwcG9ydGVkIiwiX2lzUmFuZ2VTdXBwb3J0ZWQiLCJfY29udGVudExlbmd0aCIsIl9mdWxsUmVxdWVzdFJlYWRlciIsIl9yYW5nZVJlYWRlcnMiLCJhZGRSYW5nZUxpc3RlbmVyIiwiYmVnaW4iLCJfb25SZWNlaXZlRGF0YSIsImFkZFByb2dyZXNzTGlzdGVuZXIiLCJ0b3RhbCIsIl9vblByb2dyZXNzIiwiYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXIiLCJhZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lciIsIl9vblByb2dyZXNzaXZlRG9uZSIsInRyYW5zcG9ydFJlYWR5IiwiX2VucXVldWUiLCJyYW5nZVJlYWRlciIsIl9iZWdpbiIsIl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgiLCJfbG9hZGVkIiwib25Qcm9ncmVzcyIsIl9yZW1vdmVSYW5nZVJlYWRlciIsInJlYWRlciIsImdldEZ1bGxSZWFkZXIiLCJxdWV1ZWRDaHVua3MiLCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyIiwiZ2V0UmFuZ2VSZWFkZXIiLCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIiLCJyZXF1ZXN0RGF0YVJhbmdlIiwiY2FuY2VsQWxsUmVxdWVzdHMiLCJfc3RyZWFtIiwiX2RvbmUiLCJfZmlsZW5hbWUiLCJfcmVxdWVzdHMiLCJfaGVhZGVyc1JlYWR5IiwicmVxdWVzdENhcGFiaWxpdHkiLCJoZWFkZXJzUmVhZHkiLCJpc1JhbmdlU3VwcG9ydGVkIiwiaXNTdHJlYW1pbmdTdXBwb3J0ZWQiLCJjb250ZW50TGVuZ3RoIiwiX2VuZCIsIl9xdWV1ZWRDaHVuayIsInJlcXVlc3RzQ2FwYWJpbGl0eSIsImdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlciIsImNvbnRlbnREaXNwb3NpdGlvbiIsIm5lZWRzRW5jb2RpbmdGaXh1cCIsInRvUGFyYW1SZWdFeHAiLCJyZmMyNjE2dW5xdW90ZSIsInJmYzU5ODdkZWNvZGUiLCJyZmMyMDQ3ZGVjb2RlIiwiZml4dXBFbmNvZGluZyIsInJmYzIyMzFnZXRwYXJhbSIsImF0dHJpYnV0ZVBhdHRlcm4iLCJmbGFncyIsInRleHRkZWNvZGUiLCJjb250ZW50RGlzcG9zaXRpb25TdHIiLCJpdGVyIiwicXVvdCIsInBhcnQiLCJwYXJ0cyIsInF1b3RpbmRleCIsImV4dHZhbHVlIiwiZW5jb2RpbmdlbmQiLCJsYW5ndmFsdWUiLCJjaGFyc2V0IiwiY3JlYXRlSGVhZGVycyIsImlzSHR0cCIsImh0dHBIZWFkZXJzIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJnZXRSZXNwb25zZU9yaWdpbiIsInZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzIiwicmVzcG9uc2VIZWFkZXJzIiwicmFuZ2VDaHVua1NpemUiLCJyZXR1cm5WYWx1ZXMiLCJhbGxvd1JhbmdlUmVxdWVzdHMiLCJzdWdnZXN0ZWRMZW5ndGgiLCJjb250ZW50RW5jb2RpbmciLCJleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyIiwiY3JlYXRlUmVzcG9uc2VFcnJvciIsInZhbGlkYXRlUmVzcG9uc2VTdGF0dXMiLCJjcmVhdGVGZXRjaE9wdGlvbnMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsInJlZGlyZWN0IiwiZ2V0QXJyYXlCdWZmZXIiLCJQREZGZXRjaFN0cmVhbSIsIl9yZXNwb25zZU9yaWdpbiIsIl9yYW5nZVJlcXVlc3RSZWFkZXJzIiwiUERGRmV0Y2hTdHJlYW1SZWFkZXIiLCJQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyIiwiX3JlYWRlciIsIl93aXRoQ3JlZGVudGlhbHMiLCJfaGVhZGVyc0NhcGFiaWxpdHkiLCJfZGlzYWJsZVJhbmdlIiwiX3JhbmdlQ2h1bmtTaXplIiwiX2Fib3J0Q29udHJvbGxlciIsImdldFJlYWRlciIsIl9yZWFkQ2FwYWJpbGl0eSIsInJlc3BvbnNlT3JpZ2luIiwiT0tfUkVTUE9OU0UiLCJQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UiLCJuZXR3b3JrX2dldEFycmF5QnVmZmVyIiwieGhyIiwiTmV0d29ya01hbmFnZXIiLCJjdXJyWGhySWQiLCJwZW5kaW5nUmVxdWVzdHMiLCJ4aHJJZCIsInBlbmRpbmdSZXF1ZXN0Iiwic2V0UmVxdWVzdEhlYWRlciIsImV4cGVjdGVkU3RhdHVzIiwib25FcnJvciIsIm9uU3RhdGVDaGFuZ2UiLCJvbnByb2dyZXNzIiwib25IZWFkZXJzUmVjZWl2ZWQiLCJvbkRvbmUiLCJ4aHJTdGF0dXMiLCJva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0IiwicmFuZ2VIZWFkZXIiLCJnZXRSZXNwb25zZUhlYWRlciIsImdldFJlcXVlc3RYaHIiLCJpc1BlbmRpbmdSZXF1ZXN0IiwiYWJvcnRSZXF1ZXN0IiwiUERGTmV0d29ya1N0cmVhbSIsIl9zb3VyY2UiLCJfbWFuYWdlciIsIl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZCIsIlBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciIsIlBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIiLCJvbkNsb3NlZCIsIm1hbmFnZXIiLCJfdXJsIiwiX2Z1bGxSZXF1ZXN0SWQiLCJfb25IZWFkZXJzUmVjZWl2ZWQiLCJfb25Eb25lIiwiX29uRXJyb3IiLCJfY2FjaGVkQ2h1bmtzIiwiX3N0b3JlZEVycm9yIiwiZnVsbFJlcXVlc3RYaHJJZCIsImZ1bGxSZXF1ZXN0WGhyIiwicmVzcG9uc2VVUkwiLCJyYXdSZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJ0cmltU3RhcnQiLCJsZW5ndGhDb21wdXRhYmxlIiwiX3JlcXVlc3RJZCIsIl9jbG9zZSIsInVybFJlZ2V4IiwicGFyc2VVcmxPclBhdGgiLCJzb3VyY2VVcmwiLCJwYXRoVG9GaWxlVVJMIiwiUERGTm9kZVN0cmVhbSIsIlBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIiLCJQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlciIsIl9yZWFkYWJsZVN0cmVhbSIsImxzdGF0IiwiX3NldFJlYWRhYmxlU3RyZWFtIiwiY3JlYXRlUmVhZFN0cmVhbSIsIl9lcnJvciIsInJlYWRhYmxlU3RyZWFtIiwiSU5JVElBTF9EQVRBIiwiUERGT2JqZWN0cyIsImVuc3VyZU9iaiIsIk1BWF9URVhUX0RJVlNfVE9fUkVOREVSIiwiREVGQVVMVF9GT05UX1NJWkUiLCJUZXh0TGF5ZXIiLCJkaXNhYmxlUHJvY2Vzc0l0ZW1zIiwiZm9udEluc3BlY3RvckVuYWJsZWQiLCJsYW5nIiwibGF5b3V0VGV4dFBhcmFtcyIsInJvb3RDb250YWluZXIiLCJzdHlsZUNhY2hlIiwidGV4dENvbnRlbnRJdGVtc1N0ciIsInRleHRDb250ZW50U291cmNlIiwidGV4dERpdlByb3BlcnRpZXMiLCJhc2NlbnRDYWNoZSIsImNhbnZhc0NvbnRleHRzIiwiY2FudmFzQ3R4Rm9udHMiLCJtaW5Gb250U2l6ZSIsInBlbmRpbmdUZXh0TGF5ZXJzIiwiRm9udEluc3BlY3RvciIsImVuc3VyZU1pbkZvbnRTaXplQ29tcHV0ZWQiLCJmaW5hbGx5IiwiZm9udEZhbWlseU1hcCIsInB1bXAiLCJwcm9jZXNzSXRlbXMiLCJvbkJlZm9yZSIsImdldEN0eCIsImxheW91dCIsImFib3J0RXgiLCJhcHBlbmRUZXh0IiwiZ2VvbSIsInRleHREaXYiLCJoYXNUZXh0IiwiaGFzRU9MIiwiYXRhbjIiLCJmb250TmFtZSIsImZvbnRTdWJzdGl0dXRpb24iLCJmb250SGVpZ2h0IiwiZm9udEFzY2VudCIsImdldEFzY2VudCIsInNpbiIsImNvcyIsInNjYWxlRmFjdG9yU3RyIiwiZGl2U3R5bGUiLCJkYXRhc2V0IiwiZm9udFN1YnN0aXR1dGlvbkxvYWRlZE5hbWUiLCJzaG91bGRTY2FsZVRleHQiLCJhYnNTY2FsZVgiLCJhYnNTY2FsZVkiLCJiciIsImVuc3VyZUN0eEZvbnQiLCJjbGVhbnVwIiwiYWxwaGEiLCJjYWNoZWQiLCJsaW5lSGVpZ2h0IiwiY2FjaGVkQXNjZW50IiwibWV0cmljcyIsImZvbnRCb3VuZGluZ0JveEFzY2VudCIsImZvbnRCb3VuZGluZ0JveERlc2NlbnQiLCJyYXRpbyIsIlJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVCIsImdldERvY3VtZW50IiwidGFzayIsIlBERkRvY3VtZW50TG9hZGluZ1Rhc2siLCJwYXNzd29yZCIsInJhbmdlVHJhbnNwb3J0IiwiUERGRGF0YVJhbmdlVHJhbnNwb3J0Iiwid29ya2VyIiwiUERGV29ya2VyIiwiZG9jQmFzZVVybCIsImNNYXBVcmwiLCJjTWFwUGFja2VkIiwiQ01hcFJlYWRlckZhY3RvcnkiLCJpY2NVcmwiLCJzdGFuZGFyZEZvbnREYXRhVXJsIiwiU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJ3YXNtVXJsIiwiV2FzbUZhY3RvcnkiLCJpZ25vcmVFcnJvcnMiLCJzdG9wQXRFcnJvcnMiLCJtYXhJbWFnZVNpemUiLCJjaHJvbWUiLCJjYW52YXNNYXhBcmVhSW5CeXRlcyIsImVuYWJsZVhmYSIsImRpc2FibGVBdXRvRmV0Y2giLCJwZGZCdWciLCJDYW52YXNGYWN0b3J5IiwiRmlsdGVyRmFjdG9yeSIsInVzZVdhc20iLCJ1c2VTeXN0ZW1Gb250cyIsInVzZVdvcmtlckZldGNoIiwidHJhbnNwb3J0RmFjdG9yeSIsImNNYXBSZWFkZXJGYWN0b3J5Iiwic3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJ3YXNtRmFjdG9yeSIsIl93b3JrZXIiLCJkb2NQYXJhbXMiLCJhcGlWZXJzaW9uIiwiZXZhbHVhdG9yT3B0aW9ucyIsInRyYW5zcG9ydFBhcmFtcyIsImxvYWRpbmdQYXJhbXMiLCJkZXN0cm95ZWQiLCJ3b3JrZXJJZFByb21pc2UiLCJtZXNzYWdlSGFuZGxlciIsIm5ldHdvcmtTdHJlYW0iLCJOZXR3b3JrU3RyZWFtIiwid29ya2VySWQiLCJ0cmFuc3BvcnQiLCJXb3JrZXJUcmFuc3BvcnQiLCJfdHJhbnNwb3J0IiwiX2NhcGFiaWxpdHkiLCJfcGVuZGluZ0Rlc3Ryb3kiLCJvblBhc3N3b3JkIiwicHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzIiwicHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzIiwicHJvZ3Jlc3NMaXN0ZW5lcnMiLCJyYW5nZUxpc3RlbmVycyIsIm9uRGF0YVJhbmdlIiwib25EYXRhUHJvZ3Jlc3MiLCJvbkRhdGFQcm9ncmVzc2l2ZVJlYWQiLCJvbkRhdGFQcm9ncmVzc2l2ZURvbmUiLCJQREZEb2N1bWVudFByb3h5IiwicGRmSW5mbyIsIl9wZGZJbmZvIiwibnVtUGFnZXMiLCJmaW5nZXJwcmludHMiLCJpc1B1cmVYZmEiLCJfaHRtbEZvclhmYSIsImFsbFhmYUh0bWwiLCJnZXRQYWdlIiwiZ2V0UGFnZUluZGV4IiwicmVmIiwiZ2V0RGVzdGluYXRpb25zIiwiZ2V0RGVzdGluYXRpb24iLCJnZXRQYWdlTGFiZWxzIiwiZ2V0UGFnZUxheW91dCIsImdldFBhZ2VNb2RlIiwiZ2V0Vmlld2VyUHJlZmVyZW5jZXMiLCJnZXRPcGVuQWN0aW9uIiwiZ2V0QXR0YWNobWVudHMiLCJwYWdlSW5kZXhlc1RvU2tpcCIsImdldEpTQWN0aW9ucyIsImdldERvY0pTQWN0aW9ucyIsImdldE91dGxpbmUiLCJnZXRPcHRpb25hbENvbnRlbnRDb25maWciLCJnZXRSZW5kZXJpbmdJbnRlbnQiLCJnZXRQZXJtaXNzaW9ucyIsImdldE1ldGFkYXRhIiwiZ2V0TWFya0luZm8iLCJzYXZlRG9jdW1lbnQiLCJnZXREb3dubG9hZEluZm8iLCJkb3dubG9hZEluZm9DYXBhYmlsaXR5Iiwia2VlcExvYWRlZEZvbnRzIiwic3RhcnRDbGVhbnVwIiwibG9hZGluZ1Rhc2siLCJjYWNoZWRQYWdlTnVtYmVyIiwiZ2V0RmllbGRPYmplY3RzIiwiaGFzSlNBY3Rpb25zIiwiZ2V0Q2FsY3VsYXRpb25PcmRlcklkcyIsIlBERlBhZ2VQcm94eSIsInBlbmRpbmdDbGVhbnVwIiwicGFnZUluZm8iLCJfcGFnZUluZGV4IiwiX3BhZ2VJbmZvIiwiX3N0YXRzIiwiX3BkZkJ1ZyIsIl9pbnRlbnRTdGF0ZXMiLCJyZWNvcmRlZEJCb3hlcyIsImdldFZpZXdwb3J0IiwiZ2V0QW5ub3RhdGlvbnMiLCJnZXRQYWdlSlNBY3Rpb25zIiwiZ2V0WGZhIiwiY2FudmFzQ29udGV4dCIsImFubm90YXRpb25Nb2RlIiwib3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSIsInByaW50QW5ub3RhdGlvblN0b3JhZ2UiLCJyZWNvcmRPcGVyYXRpb25zIiwiaW50ZW50QXJncyIsImludGVudFN0YXRlIiwic3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCIsImludGVudFByaW50IiwiZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSIsImxhc3RDaHVuayIsInNlcGFyYXRlQW5ub3RzIiwiX3B1bXBPcGVyYXRvckxpc3QiLCJyZWNvcmRGb3JEZWJ1Z2dlciIsIkJvb2xlYW4iLCJTdGVwcGVyTWFuYWdlciIsInNob3VsZFJlY29yZE9wZXJhdGlvbnMiLCJyZW5kZXJUYXNrcyIsImludGVybmFsUmVuZGVyVGFzayIsImdmeCIsInNldE9wZXJhdG9yQkJveGVzIiwidHJ5Q2xlYW51cCIsIl9hYm9ydE9wZXJhdG9yTGlzdCIsIlN0YXRzIiwiSW50ZXJuYWxSZW5kZXJUYXNrIiwidXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVuZGVyVGFzayIsImluaXRpYWxpemVHcmFwaGljcyIsIm9wZXJhdG9yTGlzdENoYW5nZWQiLCJnZXRPcGVyYXRvckxpc3QiLCJvcExpc3RSZWFkQ2FwYWJpbGl0eSIsIm9wTGlzdFRhc2siLCJzdHJlYW1UZXh0Q29udGVudCIsImluY2x1ZGVNYXJrZWRDb250ZW50IiwiZGlzYWJsZU5vcm1hbGl6YXRpb24iLCJURVhUX0NPTlRFTlRfQ0hVTktfU0laRSIsImhpZ2hXYXRlck1hcmsiLCJnZXRUZXh0Q29udGVudCIsImdldFN0cnVjdFRyZWUiLCJfZGVzdHJveSIsIndhaXRPbiIsImZvcmNlIiwiY29tcGxldGVkIiwicmVzZXRTdGF0cyIsIl9zdGFydFJlbmRlclBhZ2UiLCJfcmVuZGVyUGFnZUNodW5rIiwib3BlcmF0b3JMaXN0Q2h1bmsiLCJhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSIsInN0cmVhbVJlYWRlciIsImRlbGF5IiwiY3VyQ2FjaGVLZXkiLCJjdXJJbnRlbnRTdGF0ZSIsIndlYldvcmtlciIsImZha2VXb3JrZXJJZCIsImlzV29ya2VyRGlzYWJsZWQiLCJ3b3JrZXJQb3J0cyIsIl9pc1NhbWVPcmlnaW4iLCJvdGhlclVybCIsIl9jcmVhdGVDRE5XcmFwcGVyIiwid3JhcHBlciIsImNyZWF0ZU9iamVjdFVSTCIsImZyb21Qb3J0IiwiaW5pdGlhbGl6ZUZyb21Qb3J0IiwibWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyIiwic2V0dXBGYWtlV29ya2VyIiwidGVybWluYXRlRWFybHkiLCJzZW5kVGVzdCIsInRlc3RPYmoiLCJfc2V0dXBGYWtlV29ya2VyR2xvYmFsIiwiV29ya2VyTWVzc2FnZUhhbmRsZXIiLCJ3b3JrZXJIYW5kbGVyIiwic2V0dXAiLCJjYWNoZWRQb3J0IiwicGRmanNXb3JrZXIiLCJsb2FkZXIiLCJtZXRob2RQcm9taXNlcyIsInBhZ2VDYWNoZSIsInBhZ2VQcm9taXNlcyIsInBhZ2VSZWZDYWNoZSIsInBhc3N3b3JkQ2FwYWJpbGl0eSIsImZhY3RvcnkiLCJmb250TG9hZGVyIiwiX3BhcmFtcyIsImRlc3Ryb3lDYXBhYmlsaXR5IiwiX25ldHdvcmtTdHJlYW0iLCJfZnVsbFJlYWRlciIsIl9sYXN0UHJvZ3Jlc3MiLCJzZXR1cE1lc3NhZ2VIYW5kbGVyIiwiY2FjaGVTaW1wbGVNZXRob2QiLCJjYWNoZWRQcm9taXNlIiwiaXNPcExpc3QiLCJtb2RpZmllZElkc0hhc2giLCJjYWNoZUtleUJ1ZiIsInRlcm1pbmF0ZWQiLCJzaW5rIiwicmVhZHlSZWFzb24iLCJfbnVtUGFnZXMiLCJodG1sRm9yWGZhIiwidXBkYXRlUGFzc3dvcmQiLCJlcnIiLCJleHBvcnRlZERhdGEiLCJleHBvcnRlZEVycm9yIiwiZm9udEFkZGVkIiwiaW1hZ2VSZWYiLCJwYWdlUHJveHkiLCJkYXRhTGVuIiwicmVmU3RyIiwicmVzdWx0cyIsImNsZWFudXBTdWNjZXNzZnVsIiwiUmVuZGVyVGFzayIsIm9uQ29udGludWUiLCJmb3JtIiwickFGIiwiY2FudmFzSW5Vc2UiLCJXZWFrU2V0Iiwib3BlcmF0b3JMaXN0SWR4IiwicnVubmluZyIsImdyYXBoaWNzUmVhZHlDYWxsYmFjayIsImdyYXBoaWNzUmVhZHkiLCJfdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsbGVkIiwiX2NhbmNlbEJvdW5kIiwiX2NvbnRpbnVlQm91bmQiLCJfY29udGludWUiLCJfc2NoZWR1bGVOZXh0Qm91bmQiLCJfc2NoZWR1bGVOZXh0IiwiX25leHRCb3VuZCIsIl9uZXh0IiwiX2NhbnZhcyIsIl9jYW52YXNDb250ZXh0IiwiX2VuYWJsZUhXQSIsIl9kZXBlbmRlbmN5VHJhY2tlciIsIl9vcGVyYXRpb25zRmlsdGVyIiwiaW5pdCIsImdldE5leHRCcmVha1BvaW50IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ1cGRhdGVPcGVyYXRvckxpc3QiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJidWlsZCIsIkNvbG9yUGlja2VyIiwiYnV0dG9uU3dhdGNoIiwiZGVmYXVsdENvbG9yIiwiZHJvcGRvd24iLCJkcm9wZG93bldhc0Zyb21LZXlib2FyZCIsImlzTWFpbkNvbG9yUGlja2VyIiwib3BlbkRyb3Bkb3duQUMiLCJsMTBuQ29sb3IiLCJfaGlkZURyb3Bkb3duRnJvbUtleWJvYXJkIiwiX2NvbG9yU2VsZWN0RnJvbUtleWJvYXJkIiwiX21vdmVUb05leHQiLCJfbW92ZVRvUHJldmlvdXMiLCJfbW92ZVRvQmVnaW5uaW5nIiwiX21vdmVUb0VuZCIsImJsdWUiLCJncmVlbiIsInBpbmsiLCJyZWQiLCJ5ZWxsb3ciLCJvcGVuRHJvcGRvd24iLCJrZXlEb3duIiwic3dhdGNoIiwiYXJpYUhpZGRlbiIsInJlbmRlck1haW5Ecm9wZG93biIsImdldERyb3Bkb3duUm9vdCIsImFyaWFPcmllbnRhdGlvbiIsImFyaWFMYWJlbGxlZEJ5Iiwicm9sZSIsImFyaWFNdWx0aVNlbGVjdGFibGUiLCJhcmlhU2VsZWN0ZWQiLCJjb2xvclNlbGVjdCIsInVwZGF0ZUNvbG9yIiwiaXNEcm9wZG93blZpc2libGUiLCJuZXh0U2libGluZyIsInByZXZpb3VzU2libGluZyIsImRldGFpbCIsIkJhc2ljQ29sb3JQaWNrZXIiLCJjb2xvclR5cGUiLCJjb2xvclZhbHVlIiwiZXNfaXRlcmF0b3JfZmluZCIsImVzX2l0ZXJhdG9yX2ZsYXRfbWFwIiwibWFrZUNvbG9yQ29tcCIsInNjYWxlQW5kQ2xhbXAiLCJDb2xvckNvbnZlcnRlcnMiLCJDTVlLX0ciLCJHX0NNWUsiLCJHX1JHQiIsIkdfcmdiIiwiR19IVE1MIiwiRyIsIlJHQl9HIiwiUkdCX3JnYiIsIlJHQl9IVE1MIiwiVF9IVE1MIiwiVF9yZ2IiLCJDTVlLX1JHQiIsIkNNWUtfcmdiIiwiQ01ZS19IVE1MIiwiY29tcG9uZW50cyIsIlJHQl9DTVlLIiwiRGF0ZUZvcm1hdHMiLCJUaW1lRm9ybWF0cyIsIkJhc2VTVkdGYWN0b3J5Iiwic2tpcERpbWVuc2lvbnMiLCJfY3JlYXRlU1ZHIiwiRE9NU1ZHRmFjdG9yeSIsImFubm90YXRpb25fbGF5ZXJfREVGQVVMVF9GT05UX1NJWkUiLCJHZXRFbGVtZW50c0J5TmFtZVNldCIsIlRJTUVaT05FX09GRlNFVCIsImdldFRpbWV6b25lT2Zmc2V0IiwiQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5IiwiTGlua0Fubm90YXRpb25FbGVtZW50IiwiVGV4dEFubm90YXRpb25FbGVtZW50IiwiZmllbGRUeXBlIiwiVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50IiwicmFkaW9CdXR0b24iLCJSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IiwiY2hlY2tCb3giLCJDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50IiwiUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IiwiQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIldpZGdldEFubm90YXRpb25FbGVtZW50IiwiUG9wdXBBbm5vdGF0aW9uRWxlbWVudCIsIkZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQiLCJMaW5lQW5ub3RhdGlvbkVsZW1lbnQiLCJTcXVhcmVBbm5vdGF0aW9uRWxlbWVudCIsIkNpcmNsZUFubm90YXRpb25FbGVtZW50IiwiUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCIsIkNhcmV0QW5ub3RhdGlvbkVsZW1lbnQiLCJJbmtBbm5vdGF0aW9uRWxlbWVudCIsIlBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudCIsIkhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50IiwiVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQiLCJTcXVpZ2dseUFubm90YXRpb25FbGVtZW50IiwiU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQiLCJTdGFtcEFubm90YXRpb25FbGVtZW50IiwiRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCIsIkFubm90YXRpb25FbGVtZW50IiwidXBkYXRlcyIsImhhc0JvcmRlciIsInBvcHVwRWxlbWVudCIsImlzUmVuZGVyYWJsZSIsImlnbm9yZUJvcmRlciIsImNyZWF0ZVF1YWRyaWxhdGVyYWxzIiwiZG93bmxvYWRNYW5hZ2VyIiwiaW1hZ2VSZXNvdXJjZXNQYXRoIiwicmVuZGVyRm9ybXMiLCJzdmdGYWN0b3J5IiwiZW5hYmxlQ29tbWVudCIsImVuYWJsZVNjcmlwdGluZyIsIl9maWVsZE9iamVjdHMiLCJmaWVsZE9iamVjdHMiLCJfY3JlYXRlQ29udGFpbmVyIiwiX2NyZWF0ZVF1YWRyaWxhdGVyYWxzIiwiX2hhc1BvcHVwRGF0YSIsIl9pc0VkaXRhYmxlIiwiaXNFZGl0YWJsZSIsImhhc1BvcHVwRGF0YSIsImNvbW1lbnRUZXh0IiwiY29tbWVudERhdGEiLCJoYXNDb21tZW50QnV0dG9uIiwiaGFzUG9wdXBFbGVtZW50IiwicXVhZFBvaW50cyIsImlua0xpc3RzIiwiaW5rTGlzdCIsIl9ub3JtYWxpemVQb2ludCIsInJlbW92ZVBvcHVwIiwibmV3UG9wdXAiLCJzZXRSZWN0RWRpdGVkIiwiX2NyZWF0ZVBvcHVwIiwicmVzZXRFZGl0ZWQiLCJjdXJyZW50UmVjdCIsInNldFJvdGF0aW9uIiwiYWx0ZXJuYXRpdmVUZXh0Iiwibm9Sb3RhdGUiLCJib3JkZXJTdHlsZSIsImJvcmRlcldpZHRoIiwiaG9yaXpvbnRhbFJhZGl1cyIsImhvcml6b250YWxDb3JuZXJSYWRpdXMiLCJ2ZXJ0aWNhbFJhZGl1cyIsInZlcnRpY2FsQ29ybmVyUmFkaXVzIiwicmFkaXVzIiwiYm9yZGVyUmFkaXVzIiwiYm9yZGVyQm90dG9tU3R5bGUiLCJib3JkZXJDb2xvciIsIl9jb21tb25BY3Rpb25zIiwic2V0Q29sb3IiLCJqc05hbWUiLCJzdHlsZU5hbWUiLCJjb2xvckFycmF5Iiwibm9WaWV3Iiwibm9QcmludCIsInVzZXJOYW1lIiwicmVhZG9ubHkiLCJfc2V0UmVxdWlyZWQiLCJ0ZXh0Q29sb3IiLCJfZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94IiwiYWN0aW9ucyIsImpzRXZlbnQiLCJjb21tb25BY3Rpb25zIiwiX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTIiwiZXZlbnRQcm94eSIsInJlY3RCbFgiLCJyZWN0QmxZIiwicmVjdFRyWCIsInJlY3RUclkiLCJzdmdCdWZmZXIiLCJjbGlwUGF0aCIsInJlY3RXaWR0aCIsInJlY3RIZWlnaHQiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJwb3B1cERhdGEiLCJ0aXRsZU9iaiIsInBhcmVudFJlY3QiLCJfY29tbWVudE1hbmFnZXIiLCJleHRyYVBvcHVwRWxlbWVudCIsIl9nZXRFbGVtZW50c0J5TmFtZSIsInNraXBJZCIsImZpZWxkcyIsImZpZWxkT2JqIiwiZXhwb3J0VmFsdWVzIiwiZXhwb3J0VmFsdWUiLCJkb21FbGVtZW50IiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJtYXliZVNob3ciLCJmb3JjZUhpZGUiLCJnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwIiwiYWRkSGlnaGxpZ2h0QXJlYSIsInRyaWdnZXJzIiwiX2VkaXRPbkRvdWJsZUNsaWNrIiwiYW5ub3RhdGlvbkVkaXRvclR5cGUiLCJFZGl0b3JBbm5vdGF0aW9uRWxlbWVudCIsImNyZWF0ZU9yVXBkYXRlUG9wdXAiLCJyZW5kZXJDb21tZW50QnV0dG9uIiwiaXNUb29sdGlwT25seSIsImxpbmsiLCJpc0JvdW5kIiwiX2JpbmROYW1lZEFjdGlvbiIsIm92ZXJsYWlkVGV4dCIsImF0dGFjaG1lbnQiLCJiaW5kQXR0YWNobWVudCIsImF0dGFjaG1lbnREZXN0IiwiYmluZFNldE9DR1N0YXRlIiwiX2JpbmRMaW5rIiwiQWN0aW9uIiwiX2JpbmRKU0FjdGlvbiIsInJlc2V0Rm9ybSIsIl9iaW5kUmVzZXRGb3JtQWN0aW9uIiwic2V0SW50ZXJuYWxMaW5rIiwiZGVzdGluYXRpb24iLCJnZXREZXN0aW5hdGlvbkhhc2giLCJvbmNsaWNrIiwiZ29Ub0Rlc3RpbmF0aW9uIiwiZ2V0QW5jaG9yVXJsIiwiZXhlY3V0ZU5hbWVkQWN0aW9uIiwib3Blbk9yRG93bmxvYWREYXRhIiwiZXhlY3V0ZVNldE9DR1N0YXRlIiwib3RoZXJDbGlja0FjdGlvbiIsInJlc2V0Rm9ybUZpZWxkcyIsInJlZnMiLCJyZXNldEZvcm1SZWZzIiwiaW5jbHVkZSIsImFsbEZpZWxkcyIsImZpZWxkSWRzIiwiZmllbGROYW1lIiwiZmllbGQiLCJhbGxJZHMiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJzaG93RWxlbWVudEFuZEhpZGVDYW52YXMiLCJfZ2V0S2V5TW9kaWZpZXIiLCJfc2V0RXZlbnRMaXN0ZW5lciIsImVsZW1lbnREYXRhIiwiYmFzZU5hbWUiLCJldmVudE5hbWUiLCJ2YWx1ZUdldHRlciIsIm1vZGlmaWVyIiwiZm9jdXNlZCIsIl9zZXRFdmVudExpc3RlbmVycyIsIkJsdXIiLCJGb2N1cyIsIl9zZXRCYWNrZ3JvdW5kQ29sb3IiLCJfc2V0VGV4dFN0eWxlIiwiVEVYVF9BTElHTk1FTlQiLCJmb250Q29sb3IiLCJkZWZhdWx0QXBwZWFyYW5jZURhdGEiLCJjb21wdXRlZEZvbnRTaXplIiwicm91bmRUb09uZURlY2ltYWwiLCJtdWx0aUxpbmUiLCJudW1iZXJPZkxpbmVzIiwidGV4dEFsaWdubWVudCIsInRleHRBbGlnbiIsImlzUmVxdWlyZWQiLCJoYXNBcHBlYXJhbmNlIiwiZmllbGRWYWx1ZSIsInNldFByb3BlcnR5T25TaWJsaW5ncyIsImtleUluU3RvcmFnZSIsIm1heExlbiIsImNoYXJMaW1pdCIsImZpZWxkRm9ybWF0dGVkVmFsdWVzIiwiZm9ybWF0dGVkVmFsdWUiLCJjb21iIiwidXNlclZhbHVlIiwibGFzdENvbW1pdHRlZFZhbHVlIiwiY29tbWl0S2V5IiwiZG9Ob3RTY3JvbGwiLCJvdmVyZmxvd1kiLCJvdmVyZmxvd1giLCJyZWFkT25seSIsImRhdGV0aW1lRm9ybWF0IiwiZGF0ZXRpbWVUeXBlIiwidGltZVN0ZXAiLCJoYXNEYXRlT3JUaW1lIiwiZGVmYXVsdEZpZWxkVmFsdWUiLCJibHVyTGlzdGVuZXIiLCJzY3JvbGxMZWZ0IiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsInRvSVNPU3RyaW5nIiwic2VsUmFuZ2UiLCJzZXRTZWxlY3Rpb25SYW5nZSIsIndpbGxDb21taXQiLCJzZWxTdGFydCIsInNlbGVjdGlvblN0YXJ0Iiwic2VsRW5kIiwic2VsZWN0aW9uRW5kIiwiX2JsdXJMaXN0ZW5lciIsIktleXN0cm9rZSIsImlucHV0VHlwZSIsImNoYW5nZSIsImZpZWxkV2lkdGgiLCJjb21iV2lkdGgiLCJsZXR0ZXJTcGFjaW5nIiwidmVydGljYWxBbGlnbiIsImNoZWNrYm94IiwiY3VyQ2hlY2tlZCIsImJ1dHRvblZhbHVlIiwicmFkaW8iLCJwZGZCdXR0b25WYWx1ZSIsImxpbmtFbGVtZW50Iiwic2VsZWN0RWxlbWVudCIsImFkZEFuRW1wdHlFbnRyeSIsImNvbWJvIiwibXVsdGlTZWxlY3QiLCJtdWx0aXBsZSIsIm9wdGlvbkVsZW1lbnQiLCJkaXNwbGF5VmFsdWUiLCJyZW1vdmVFbXB0eUVudHJ5Iiwibm9uZU9wdGlvbkVsZW1lbnQiLCJpc0V4cG9ydCIsInNlbGVjdGVkVmFsdWVzIiwiZ2V0SXRlbXMiLCJtdWx0aXBsZVNlbGVjdGlvbiIsImZpbmRJbmRleCIsInNlbGVjdENoaWxkIiwiaW5kaWNlcyIsImVkaXRhYmxlIiwiY2hhbmdlRXgiLCJjcmVhdGVQb3B1cCIsIlBvcHVwRWxlbWVudCIsImJvdW5kS2V5RG93biIsImJvdW5kSGlkZSIsImJvdW5kU2hvdyIsImJvdW5kVG9nZ2xlIiwiZGF0ZU9iaiIsInBpbm5lZCIsInBvcHVwQWJvcnRDb250cm9sbGVyIiwiY29tbWVudEJ1dHRvbiIsIndhc1Zpc2libGUiLCJmaXJzdEVsZW1lbnQiLCJ0cmlnZ2VyIiwiYWRkRXZlbnRMaXN0ZW5lcnMiLCJzZXRDb21tZW50QnV0dG9uUG9zaXRpb24iLCJoYXNPd25CdXR0b24iLCJ0b2dnbGVQb3B1cCIsInNob3dQb3B1cCIsImhpZGVQb3B1cCIsInBhcmVudENvbnRhaW5lciIsInVwZGF0ZUNvbW1lbnRCdXR0b25Qb3NpdGlvbiIsImFmdGVyIiwib3V0bGluZUNvbG9yIiwiaGVhZGVyIiwiZGF0ZVRpbWUiLCJtYWtlUG9wdXBDb250ZW50IiwicG9wdXBMaW5lcyIsInBvcHVwQ29udGVudCIsImxpbmVBdHRyaWJ1dGVzIiwic2V0UG9zaXRpb24iLCJ1c2VQYXJlbnRSZWN0Iiwibm9ybWFsaXplZFJlY3QiLCJIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04iLCJwb3B1cExlZnQiLCJwb3B1cFRvcCIsInRleHRQb3NpdGlvbiIsImxpbmVTcGFuIiwibGluZUNvb3JkaW5hdGVzIiwic3F1YXJlIiwiY2lyY2xlIiwicG9seWxpbmUiLCJjb250YWluZXJDbGFzc05hbWUiLCJzdmdFbGVtZW50TmFtZSIsInZlcnRpY2VzIiwicG9pbnRzIiwicG9seWxpbmVzR3JvdXBFbGVtZW50IiwicG9seWxpbmVzIiwidGhpY2tuZXNzIiwibWFyayIsInVuZGVybGluZSIsInN0cmlrZW91dCIsImRvd25sb2FkIiwiQW5ub3RhdGlvbkxheWVyIiwiYWNjZXNzaWJpbGl0eU1hbmFnZXIiLCJlZGl0YWJsZUFubm90YXRpb25zIiwic3RydWN0VHJlZUxheWVyIiwiYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciIsIl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIiwiaGFzRWRpdGFibGVBbm5vdGF0aW9ucyIsImFwcGVuZEVsZW1lbnQiLCJwb3B1cEVsZW1lbnRzIiwiY29udGVudEVsZW1lbnQiLCJhcmlhQXR0cmlidXRlcyIsImdldEFyaWFBdHRyaWJ1dGVzIiwibW92ZUVsZW1lbnRJbkRPTSIsImFubm90YXRpb25zIiwicG9wdXBUb0VsZW1lbnRzIiwiZWxlbWVudFBhcmFtcyIsIm5vSFRNTCIsImlzUG9wdXBBbm5vdGF0aW9uIiwicmVuZGVyZWQiLCJzZXRBbm5vdGF0aW9uQ2FudmFzTWFwIiwiYWRkTGlua0Fubm90YXRpb25zIiwiX2RlZmF1bHRCb3JkZXJTdHlsZSIsInJlcGxhY2VXaXRoIiwiZWRpdGFibGVBbm5vdGF0aW9uIiwiX2hhc05vQ2FudmFzIiwiZ2V0RWRpdGFibGVBbm5vdGF0aW9ucyIsImdldEVkaXRhYmxlQW5ub3RhdGlvbiIsImh0bWxFbGVtZW50IiwicmF3V2lkdGgiLCJFT0xfUEFUVEVSTiIsIkZyZWVUZXh0RWRpdG9yIiwiZWRpdG9yRGl2SWQiLCJlZGl0TW9kZUFDIiwiX2ZyZWVUZXh0RGVmYXVsdENvbnRlbnQiLCJfaW50ZXJuYWxQYWRkaW5nIiwiX2RlZmF1bHRDb2xvciIsIl9kZWZhdWx0Rm9udFNpemUiLCJfdHJhbnNsYXRlRW1wdHkiLCJfY29sb3JQaWNrZXIiLCJ1cGRhdGVGb250U2l6ZSIsInNldEZvbnRzaXplIiwiZWRpdG9yRGl2Iiwic2V0RWRpdG9yRGltZW5zaW9ucyIsInNhdmVkRm9udHNpemUiLCJjb2wiLCJzYXZlZENvbG9yIiwib3ZlcmxheURpdiIsImNvbnRlbnRFZGl0YWJsZSIsImVkaXRvckRpdktleWRvd24iLCJlZGl0b3JEaXZGb2N1cyIsImVkaXRvckRpdkJsdXIiLCJlZGl0b3JEaXZJbnB1dCIsImVkaXRvckRpdlBhc3RlIiwiaW5uZXJUZXh0IiwiZXh0cmFjdFRleHQiLCJwcmV2Q2hpbGQiLCJjaGlsZE5vZGVzIiwiZ2V0Tm9kZUNvbnRlbnQiLCJzYXZlZERpc3BsYXkiLCJzYXZlZFZpc2liaWxpdHkiLCJzYXZlZFRleHQiLCJuZXdUZXh0IiwidHJpbUVuZCIsInNldFRleHQiLCJzZXRDb250ZW50Iiwibm9kZVZhbHVlIiwiZGVzZXJpYWxpemVDb250ZW50IiwiZGVsZXRlRnJvbURvY3VtZW50IiwiaW5zZXJ0Tm9kZSIsImNvbGxhcHNlVG9TdGFydCIsInN0YXJ0Q29udGFpbmVyIiwic3RhcnRPZmZzZXQiLCJidWZmZXJCZWZvcmUiLCJidWZmZXJBZnRlciIsIm5ld1JhbmdlIiwiUmFuZ2UiLCJiZWZvcmVMZW5ndGgiLCJzZXRTdGFydCIsInNldEVuZCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwicmVwbGFjZUNoaWxkcmVuIiwic2VyaWFsaXplQ29udGVudCIsInBhZGRpbmciLCJoYXNFbGVtZW50Q2hhbmdlZCIsIk91dGxpbmUiLCJ0b1NWR1BhdGgiLCJfcm90YXRpb24iLCJfcmVzY2FsZSIsIl9yZXNjYWxlQW5kU3dhcCIsIl90cmFuc2xhdGUiLCJzdmdSb3VuZCIsIl9ub3JtYWxpemVQYWdlUG9pbnQiLCJjcmVhdGVCZXppZXJQb2ludHMiLCJGcmVlRHJhd091dGxpbmVyIiwiaW5uZXJNYXJnaW4iLCJsYXN0IiwibWluX2Rpc3QiLCJzY2FsZUZhY3RvciIsIk1JTl9ESVNUIiwiTUlOX0RJRkYiLCJNSU4iLCJnZXRMYXN0Q29vcmRzIiwibGFzdFRvcCIsImxhc3RCb3R0b20iLCJkaWZmWCIsImRpZmZZIiwiZGlmZkQiLCJuWCIsIm5ZIiwidGhYIiwidGhZIiwidG9TVkdQYXRoVHdvUG9pbnRzIiwidG9TVkdQYXRoRW5kIiwidG9TVkdQYXRoU3RhcnQiLCJsYXN0VG9wWCIsImxhc3RUb3BZIiwibGFzdEJvdHRvbVgiLCJsYXN0Qm90dG9tWSIsIm5ld0ZyZWVEcmF3T3V0bGluZSIsIm91dGxpbmUiLCJGcmVlRHJhd091dGxpbmUiLCJnZXRPdXRsaW5lcyIsImdldE91dGxpbmVUd29Qb2ludHMiLCJOIiwiZ2V0T3V0bGluZUVuZCIsImdldE91dGxpbmVTdGFydCIsImZpcnN0UG9pbnQiLCJsYXN0UG9pbnQiLCJjb21wdXRlTWluTWF4IiwiZmlyc3RQb2ludFgiLCJmaXJzdFBvaW50WSIsImxhc3RQb2ludFgiLCJsYXN0UG9pbnRZIiwibHRyQ2FsbGJhY2siLCJiZXppZXJCYm94IiwibmV3T3V0bGluZXIiLCJnZXROZXdPdXRsaW5lIiwib3V0bGluZXIiLCJIaWdobGlnaHRPdXRsaW5lciIsInZlcnRpY2FsRWRnZXMiLCJpbnRlcnZhbHMiLCJOVU1CRVJfT0ZfRElHSVRTIiwiRVBTSUxPTiIsInNoaWZ0ZWRNaW5YIiwic2hpZnRlZE1pblkiLCJsYXN0RWRnZSIsImVkZ2UiLCJvdXRsaW5lVmVydGljYWxFZGdlcyIsImJyZWFrRWRnZSIsImVkZ2VzIiwiYWxsRWRnZXMiLCJlZGdlMSIsImVkZ2UyIiwib3V0bGluZXMiLCJIaWdobGlnaHRPdXRsaW5lIiwiYmluYXJ5U2VhcmNoIiwibWlkZGxlIiwieTQiLCJwb2x5Z29uIiwicHJldlgiLCJwcmV2WSIsImNsYXNzTmFtZXNGb3JPdXRsaW5pbmciLCJGcmVlSGlnaGxpZ2h0T3V0bGluZXIiLCJGcmVlSGlnaGxpZ2h0T3V0bGluZSIsIkhpZ2hsaWdodEVkaXRvciIsImNsaXBQYXRoSWQiLCJmb2N1c091dGxpbmVzIiwiaGlnaGxpZ2h0RGl2IiwiaGlnaGxpZ2h0T3V0bGluZXMiLCJpc0ZyZWVIaWdobGlnaHQiLCJvdXRsaW5lSWQiLCJfZGVmYXVsdE9wYWNpdHkiLCJfZGVmYXVsdFRoaWNrbmVzcyIsIl9mcmVlSGlnaGxpZ2h0SWQiLCJfZnJlZUhpZ2hsaWdodCIsIl9mcmVlSGlnaGxpZ2h0Q2xpcElkIiwiX21vdmVDYXJldCIsImhpZ2hsaWdodElkIiwiY3JlYXRlRnJlZU91dGxpbmVzIiwiYWRkVG9EcmF3TGF5ZXIiLCJjcmVhdGVPdXRsaW5lcyIsIm51bWJlck9mQ29sb3JzIiwib3V0bGluZXJGb3JPdXRsaW5lIiwiZXh0cmFUaGlja25lc3MiLCJkcmF3TGF5ZXIiLCJmaW5hbGl6ZURyYXciLCJkcmF3T3V0bGluZSIsInJvb3RDbGFzcyIsImhpZ2hsaWdodE91dGxpbmUiLCJmcmVlIiwidXBkYXRlUHJvcGVydGllcyIsInJvdGF0ZUJib3giLCJ1cGRhdGVUaGlja25lc3MiLCJzZXRDb2xvckFuZE9wYWNpdHkiLCJvcGEiLCJzYXZlZE9wYWNpdHkiLCJzYXZlZFRoaWNrbmVzcyIsInNldFRoaWNrbmVzcyIsInRoIiwiY2hhbmdlVGhpY2tuZXNzIiwiZ2V0Um90YXRpb24iLCJhZGRVbmRvYWJsZUVkaXRvciIsImNsZWFuRHJhd0xheWVyIiwibXVzdEJlU2VsZWN0ZWQiLCJkcmF3IiwicG9pbnRlcm92ZXIiLCJob3ZlcmVkIiwicG9pbnRlcmxlYXZlIiwic2V0Q2FyZXQiLCJzZXJpYWxpemVCb3hlcyIsInNlcmlhbGl6ZU91dGxpbmVzIiwic3RhcnRIaWdobGlnaHRpbmciLCJlbmRIaWdobGlnaHQiLCJoaWdobGlnaHRNb3ZlIiwiRHJhd2luZ09wdGlvbnMiLCJzdmdQcm9wZXJ0aWVzIiwidXBkYXRlUHJvcGVydHkiLCJ1cGRhdGVTVkdQcm9wZXJ0eSIsInRvU1ZHUHJvcGVydGllcyIsInVwZGF0ZUFsbCIsIkRyYXdpbmdFZGl0b3IiLCJkcmF3T3V0bGluZXMiLCJtdXN0QmVDb21taXR0ZWQiLCJfY3VycmVudERyYXdJZCIsIl9jdXJyZW50UGFyZW50IiwiY3VycmVudERyYXciLCJjdXJyZW50RHJhd2luZ0FDIiwiY3VycmVudERyYXdpbmdPcHRpb25zIiwiY3VycmVudFBvaW50ZXJJZCIsImN1cnJlbnRQb2ludGVyVHlwZSIsImN1cnJlbnRQb2ludGVySWRzIiwiY3VycmVudE1vdmVUaW1lc3RhbXAiLCJfSU5ORVJfTUFSR0lOIiwiX2RyYXdJZCIsIl9hZGRPdXRsaW5lcyIsImNyZWF0ZURyYXdPdXRsaW5lcyIsImRyYXdJZCIsImRyYXdpbmdPcHRpb25zIiwiX2RyYXdpbmdPcHRpb25zIiwiZGVmYXVsdFByb3BlcnRpZXMiLCJjcmVhdGVEcmF3aW5nIiwidXBkYXRlQmJveCIsIl9tZXJnZVNWR1Byb3BlcnRpZXMiLCJkZWZhdWx0U1ZHUHJvcGVydGllcyIsInAxS2V5cyIsImdldERlZmF1bHREcmF3aW5nT3B0aW9ucyIsIl9vcHRpb25zIiwidHlwZXNNYXAiLCJzdXBwb3J0TXVsdGlwbGVEcmF3aW5ncyIsInByb3BlcnR5TmFtZSIsIl9kZWZhdWx0RHJhd2luZ09wdGlvbnMiLCJfdXBkYXRlUHJvcGVydHkiLCJzYXZlZFZhbHVlIiwiZ2V0UGF0aFJlc2l6aW5nU1ZHUHJvcGVydGllcyIsImNvbnZlcnRUb0RyYXdTcGFjZSIsInJvdGF0ZUJveCIsImdldFBhdGhSZXNpemVkU1ZHUHJvcGVydGllcyIsIl94IiwiX3kiLCJnZXRQYXRoVHJhbnNsYXRlZFNWR1Byb3BlcnRpZXMiLCJtb3ZpbmciLCJ1cGRhdGVQYXJlbnQiLCJjb252ZXJ0VG9QYXJlbnRTcGFjZSIsInBXIiwicEgiLCJ1cGRhdGVSb3RhdGlvbiIsInVwZGF0ZVBhcmVudERpbWVuc2lvbnMiLCJvblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZyIsImRyYXdEaXYiLCJjcmVhdGVEcmF3ZXJJbnN0YW5jZSIsIl9wYXJlbnRXaWR0aCIsIl9wYXJlbnRIZWlnaHQiLCJzdGFydERyYXdpbmciLCJfaXNMVFIiLCJfZW5kRHJhdyIsImlzQ2FuY2VsbGFibGUiLCJyZW1vdmVMYXN0RWxlbWVudCIsIl9kcmF3TW92ZSIsInRpbWVTdGFtcCIsInN0YXJ0TmV3IiwiX2NsZWFudXAiLCJsYXN0RWxlbWVudCIsImdldExhc3RFbGVtZW50Iiwic2V0TGFzdEVsZW1lbnQiLCJpc0Fib3J0ZWQiLCJjcmVhdGVEcmF3aW5nT3B0aW9ucyIsIl9kYXRhIiwiZGVzZXJpYWxpemVEcmF3IiwiX3BhZ2VYIiwiX3BhZ2VZIiwiX3BhZ2VXaWR0aCIsIl9wYWdlSGVpZ2h0IiwiX2lubmVyV2lkdGgiLCJzZXJpYWxpemVEcmF3IiwiSW5rRHJhd091dGxpbmVyIiwibGFzdFNWR1BhdGgiLCJsYXN0SW5kZXgiLCJJbmtEcmF3T3V0bGluZSIsIm5vcm1hbGl6ZVBvaW50IiwiZmlyc3RYIiwiZmlyc3RZIiwic2Vjb25kWCIsInNlY29uZFkiLCJjMXgiLCJjMXkiLCJjMngiLCJjMnkiLCJjdXJyZW50Um90YXRpb24iLCJjb21wdXRlQmJveCIsInNlcmlhbGl6ZWRMaW5lcyIsInNlcmlhbGl6ZWRQb2ludHMiLCJnZXRCQm94V2l0aE5vTWFyZ2luIiwicmVzY2FsZUZuIiwibmV3TGluZXMiLCJnZXRNYXJnaW5Db21wb25lbnRzIiwibWFyZ2luIiwibWFyZ2luWCIsIm1hcmdpblkiLCJvbGRNYXJnaW5YIiwib2xkTWFyZ2luWSIsIm5ld01hcmdpblgiLCJuZXdNYXJnaW5ZIiwiZGlmZk1hcmdpblgiLCJkaWZmTWFyZ2luWSIsInJvdGF0aW9uVHJhbnNmb3JtIiwiczF4IiwiczF5IiwiczJ4IiwiczJ5IiwibmV3UGFyZW50V2lkdGgiLCJuZXdQYXJlbnRIZWlnaHQiLCJJbmtEcmF3aW5nT3B0aW9ucyIsInZpZXdlclBhcmFtZXRlcnMiLCJfdmlld1BhcmFtZXRlcnMiLCJJbmtFZGl0b3IiLCJDb250b3VyRHJhd091dGxpbmUiLCJCQVNFX0hFQURFUl9MRU5HVEgiLCJQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIiLCJTaWduYXR1cmVFeHRyYWN0b3IiLCJQQVJBTUVURVJTIiwic2lnbWFTRmFjdG9yIiwic2lnbWFSIiwia2VybmVsU2l6ZSIsIm5laWdoYm9ySW5kZXhUb0lkIiwiaTAiLCJqMCIsIm5laWdoYm9ySWRUb0luZGV4IiwiY2xvY2t3aXNlTm9uWmVybyIsImtrIiwic2hpZnRJIiwic2hpZnRKIiwiY291bnRlckNsb2Nrd2lzZU5vblplcm8iLCJmaW5kQ29udG91cnMiLCJ0aHJlc2hvbGQiLCJuYmQiLCJsbmJkIiwiY29udG91cnMiLCJpaiIsInBpeCIsImkyIiwiajIiLCJpc0hvbGUiLCJjb250b3VyIiwiY29udG91cjAiLCJpMSIsImoxIiwiaTMiLCJqMyIsImk0IiwiajQiLCJpajMiLCJkb3VnbGFzUGV1Y2tlckhlbHBlciIsImF4IiwiYXkiLCJhYngiLCJhYnkiLCJkaXN0IiwibmFieCIsIm5hYnkiLCJhYSIsImludlMiLCJwaGkiLCJhdGFuIiwiY29zUGhpIiwic2luUGhpIiwidG1heCIsInBvbHkiLCJwYXJ0aWFsUGhpIiwiZG1heCIsImRvdWdsYXNQZXVja2VyIiwiYmlsYXRlcmFsRmlsdGVyIiwic2lnbWFTIiwia2VybmVsIiwic2lnbWFTMiIsImhhbGZTaXplIiwiZXhwIiwicmFuZ2VWYWx1ZXMiLCJzaWdtYVIyIiwib3V0IiwiaGlzdG9ncmFtIiwibm9ybSIsIm5laWdoYm91ciIsImdldEhpc3RvZ3JhbSIsInRvVWludDgiLCJndWVzc1RocmVzaG9sZCIsIk0iLCJMIiwic3BvcyIsImdldEdyYXlQaXhlbHMiLCJvcmlnaW5hbEJpdG1hcCIsInByZXZXaWR0aCIsInByZXZIZWlnaHQiLCJsb2cyIiwiaXN0ZXBzIiwiZ3JheUltYWdlIiwidWludDhCdWYiLCJleHRyYWN0Q29udG91cnNGcm9tVGV4dCIsImZvbnRTdHlsZSIsIlNDQUxFIiwiY29udG91ckxpc3QiLCJwcm9jZXNzRHJhd25MaW5lcyIsImN1cnZlcyIsIm11c3RTbW9vdGgiLCJhcmVDb250b3VycyIsImxpbmVzQW5kUG9pbnRzIiwieFNjYWxlIiwieVNjYWxlIiwibmV3Q3VydmVzIiwicmVkdWNlZFBvaW50cyIsIm5ld1BvaW50cyIsImNvbXByZXNzU2lnbmF0dXJlIiwibWluRGlmZiIsIm1heERpZmYiLCJvdXRsaW5lc0xlbmd0aCIsImR4IiwiYnVmZmVyVHlwZSIsImhlYWRlckxlbmd0aCIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiQ29tcHJlc3Npb25TdHJlYW0iLCJ3cml0ZXIiLCJnZXRXcml0ZXIiLCJCdWZmZXJDdG9yIiwiZGlmZnMiLCJSZXNwb25zZSIsInJlYWRhYmxlIiwiZGVjb21wcmVzc1NpZ25hdHVyZSIsInNpZ25hdHVyZURhdGEiLCJEZWNvbXByZXNzaW9uU3RyZWFtIiwibnVtYmVyT2ZEcmF3aW5ncyIsImRpZmZzT2Zmc2V0IiwiU2lnbmF0dXJlT3B0aW9ucyIsIkRyYXduU2lnbmF0dXJlT3B0aW9ucyIsIlNpZ25hdHVyZUVkaXRvciIsImlzRXh0cmFjdGVkIiwic2lnbmF0dXJlVVVJRCIsIl9kZWZhdWx0RHJhd25TaWduYXR1cmVPcHRpb25zIiwiaGFzRGVzY3JpcHRpb24iLCJoYXNEZXNjcmlwdGlvblN0YXRzIiwiaGFzTm9BbHRUZXh0IiwidXVpZCIsImhlaWdodEluUGFnZSIsImFkZFNpZ25hdHVyZSIsInNldFV1aWQiLCJnZXRTaWduYXR1cmVQcmV2aWV3Iiwib3V0bGluZURhdGEiLCJoYXNCZWVuU2F2ZWQiLCJnZXRGcm9tSW1hZ2UiLCJnZXRGcm9tVGV4dCIsImZvbnRJbmZvIiwiZ2V0RHJhd25TaWduYXR1cmUiLCJpc1NpZ25hdHVyZSIsImFsdCIsIlN0YW1wRWRpdG9yIiwiYml0bWFwSWQiLCJiaXRtYXBQcm9taXNlIiwiYml0bWFwVXJsIiwiYml0bWFwRmlsZSIsImJpdG1hcEZpbGVOYW1lIiwibWlzc2luZ0NhbnZhcyIsInJlc2l6ZVRpbWVvdXRJZCIsImhhc0JlZW5BZGRlZEluVW5kb1N0YWNrIiwicGFzdGVFZGl0b3IiLCJnZXRBc0ZpbGUiLCJoYXNBbHRUZXh0U3RhdHMiLCJnZXRCaXRtYXBGZXRjaGVkIiwiZnJvbUlkIiwiZ2V0Qml0bWFwRG9uZSIsImFsdF90ZXh0X21vZGFsIiwiYWx0X3RleHRfdHlwZSIsIm1sR3Vlc3NBbHRUZXh0IiwidXBkYXRlQWx0VGV4dERhdGEiLCJpc0VuYWJsZWRGb3IiLCJjb3B5Q2FudmFzIiwiZ3Vlc3MiLCJjaGFubmVscyIsImdldEJpdG1hcCIsImFjY2VwdCIsImZpbGVzIiwiY2xpY2siLCJkcmF3Qml0bWFwIiwiTUFYX1JBVElPIiwibWF4RGF0YURpbWVuc2lvbiIsIm1heFByZXZpZXdEaW1lbnNpb24iLCJiaXRtYXBXaWR0aCIsImJpdG1hcEhlaWdodCIsIm91dHB1dFNjYWxlIiwic2NhbGVkV2lkdGgiLCJzY2FsZWRIZWlnaHQiLCJzY2FsZUJpdG1hcCIsImJveERpbSIsImJveERpbVdpZHRoIiwiYm94RGltSGVpZ2h0IiwicGF0dGVybkN0eCIsImRhdGFXaWR0aCIsImRhdGFIZWlnaHQiLCJvZmZzY3JlZW5DdHgiLCJzZXJpYWxpemVCaXRtYXAiLCJ0b1VybCIsInRvRGF0YVVSTCIsInN0cnVjdFBhcmVudCIsIl9zdHJ1Y3RUcmVlIiwiY2hhbmdlcyIsImlzU2FtZSIsImlzU2FtZUFsdFRleHQiLCJzdGFtcHMiLCJhcmVhIiwicHJldkRhdGEiLCJpc1NhbWVQYWdlSW5kZXgiLCJBbm5vdGF0aW9uRWRpdG9yTGF5ZXIiLCJhbGxvd0NsaWNrIiwiY2xpY2tBQyIsImVkaXRvckZvY3VzVGltZW91dElkIiwiaGFkUG9pbnRlckRvd24iLCJpc0Rpc2FibGluZyIsImlzRW5hYmxpbmciLCJkcmF3aW5nQUMiLCJmb2N1c2VkRWxlbWVudCIsInRleHRTZWxlY3Rpb25BQyIsInRleHRMYXllckRibENsaWNrQUMiLCJsYXN0UG9pbnRlckRvd25UaW1lc3RhbXAiLCJfaW5pdGlhbGl6ZWQiLCJpc0ludmlzaWJsZSIsImRpc2FibGVUZXh0U2VsZWN0aW9uIiwidG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyIsImVuYWJsZVRleHRTZWxlY3Rpb24iLCJhbGxFZGl0b3JzSXRlcmF0b3IiLCJhbm5vdGF0aW9uRWxlbWVudElkcyIsIkRCTF9DTElDS19USFJFU0hPTEQiLCJlbGVtZW50c0Zyb21Qb2ludCIsImNoYW5nZWRBbm5vdGF0aW9ucyIsInJlc2V0QW5ub3RhdGlvbnMiLCJlZGl0YWJsZXMiLCJjdXJyZW50QWN0aXZlIiwidGV4dExheWVyUG9pbnRlckRvd24iLCJhdHRhY2giLCJyZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIiLCJjdXJyZW50RWRpdG9yVHlwZSIsImNyZWF0ZU5ld0VkaXRvciIsImdldENlbnRlclBvaW50IiwiY3VycmVudE1vZGUiLCJzdGFydERyYXdpbmdTZXNzaW9uIiwicGF1c2UiLCJvbGRSb3RhdGlvbiIsIkRyYXdMYXllciIsIm1hcHBpbmciLCJ0b1VwZGF0ZSIsIl9zdmdGYWN0b3J5Iiwic2V0Qm94IiwiY3JlYXRlU1ZHIiwiY3JlYXRlQ2xpcFBhdGgiLCJwYXRoSWQiLCJjbGlwUGF0aFVzZSIsImlzUGF0aFVwZGF0YWJsZSIsImhhc0NsaXAiLCJ1c2UiLCJtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMiLCJtYXNrSWQiLCJ1c2UxIiwidXNlMiIsImNsb25lTm9kZSIsImVsZW1lbnRPcklkIiwicGF0aEVsZW1lbnQiLCJfcGRmanNUZXN0aW5nVXRpbHMiLCJwZGZqc0xpYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdf-parse/node_modules/pdfjs-dist/legacy/build/pdf.mjs\n");

/***/ })

};
;